import { Fragment as st, isVNode as $n, Comment as WF, Text as JU, defineComponent as pl, reactive as Nt, getCurrentInstance as Jn, onMounted as ql, onUpdated as qn, onUnmounted as Xn, watch as Bl, computed as Zl, inject as fl, ref as Ml, unref as at, shallowRef as bl, provide as nt, watchEffect as it, onBeforeUnmount as Wt, triggerRef as hF, createVNode as H, h as ua, Transition as Yn, withDirectives as ud, resolveDirective as RF, cloneVNode as rd, nextTick as dt, toRef as Ct, withModifiers as es, vShow as ei, onBeforeMount as NF, Teleport as bF, createTextVNode as Ve, isRef as mF, toRefs as uF, toRaw as Md, render as XU, onBeforeUpdate as rF, openBlock as Vt, createElementBlock as mt, createElementVNode as St, normalizeClass as qe, toDisplayString as YU, withCtx as ds, normalizeStyle as fd, createCommentVNode as _e, pushScopeId as MF, popScopeId as pF, renderList as yU, createBlock as as } from "vue";
var SF = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function di(l) {
  for (var t = 0, n, e = 0, d = l.length; d >= 4; ++e, d -= 4)
    n = l.charCodeAt(e) & 255 | (l.charCodeAt(++e) & 255) << 8 | (l.charCodeAt(++e) & 255) << 16 | (l.charCodeAt(++e) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (d) {
    case 3:
      t ^= (l.charCodeAt(e + 2) & 255) << 16;
    case 2:
      t ^= (l.charCodeAt(e + 1) & 255) << 8;
    case 1:
      t ^= l.charCodeAt(e) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var TF = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, ze = { exports: {} }, is;
function GF() {
  return is || (is = 1, function(l, t) {
    (function(n, e) {
      e(t);
    })(SF, function(n) {
      var e = "-ms-", d = "-moz-", a = "-webkit-", U = "comm", V = "rule", h = "decl", W = "@page", Z = "@media", s = "@import", o = "@charset", F = "@viewport", N = "@supports", Q = "@document", u = "@namespace", i = "@keyframes", c = "@font-face", R = "@counter-style", m = "@font-feature-values", M = "@layer", S = "@scope", p = Math.abs, Y = String.fromCharCode, k = Object.assign;
      function L($, hl) {
        return w($, 0) ^ 45 ? (((hl << 2 ^ w($, 0)) << 2 ^ w($, 1)) << 2 ^ w($, 2)) << 2 ^ w($, 3) : 0;
      }
      function z($) {
        return $.trim();
      }
      function f($, hl) {
        return ($ = hl.exec($)) ? $[0] : $;
      }
      function K($, hl, Tl) {
        return $.replace(hl, Tl);
      }
      function P($, hl, Tl) {
        return $.indexOf(hl, Tl);
      }
      function w($, hl) {
        return $.charCodeAt(hl) | 0;
      }
      function O($, hl, Tl) {
        return $.slice(hl, Tl);
      }
      function el($) {
        return $.length;
      }
      function ll($) {
        return $.length;
      }
      function q($, hl) {
        return hl.push($), $;
      }
      function _($, hl) {
        return $.map(hl).join("");
      }
      function il($, hl) {
        return $.filter(function(Tl) {
          return !f(Tl, hl);
        });
      }
      n.line = 1, n.column = 1, n.length = 0, n.position = 0, n.character = 0, n.characters = "";
      function dl($, hl, Tl, Jl, yl, Il, gl, wl) {
        return { value: $, root: hl, parent: Tl, type: Jl, props: yl, children: Il, line: n.line, column: n.column, length: gl, return: "", siblings: wl };
      }
      function tl($, hl) {
        return k(dl("", null, null, "", null, null, 0, $.siblings), $, { length: -$.length }, hl);
      }
      function al($) {
        for (; $.root; )
          $ = tl($.root, { children: [$] });
        q($, $.siblings);
      }
      function Ul() {
        return n.character;
      }
      function cl() {
        return n.character = n.position > 0 ? w(n.characters, --n.position) : 0, n.column--, n.character === 10 && (n.column = 1, n.line--), n.character;
      }
      function B() {
        return n.character = n.position < n.length ? w(n.characters, n.position++) : 0, n.column++, n.character === 10 && (n.column = 1, n.line++), n.character;
      }
      function X() {
        return w(n.characters, n.position);
      }
      function b() {
        return n.position;
      }
      function r($, hl) {
        return O(n.characters, $, hl);
      }
      function G($) {
        switch ($) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      function J($) {
        return n.line = n.column = 1, n.length = el(n.characters = $), n.position = 0, [];
      }
      function T($) {
        return n.characters = "", $;
      }
      function y($) {
        return z(r(n.position - 1, A($ === 91 ? $ + 2 : $ === 40 ? $ + 1 : $)));
      }
      function I($) {
        return T(x(J($)));
      }
      function E($) {
        for (; (n.character = X()) && n.character < 33; )
          B();
        return G($) > 2 || G(n.character) > 3 ? "" : " ";
      }
      function x($) {
        for (; B(); )
          switch (G(n.character)) {
            case 0:
              q(D(n.position - 1), $);
              break;
            case 2:
              q(y(n.character), $);
              break;
            default:
              q(Y(n.character), $);
          }
        return $;
      }
      function v($, hl) {
        for (; --hl && B() && !(n.character < 48 || n.character > 102 || n.character > 57 && n.character < 65 || n.character > 70 && n.character < 97); )
          ;
        return r($, b() + (hl < 6 && X() == 32 && B() == 32));
      }
      function A($) {
        for (; B(); )
          switch (n.character) {
            case $:
              return n.position;
            case 34:
            case 39:
              $ !== 34 && $ !== 39 && A(n.character);
              break;
            case 40:
              $ === 41 && A($);
              break;
            case 92:
              B();
              break;
          }
        return n.position;
      }
      function g($, hl) {
        for (; B() && $ + n.character !== 57; )
          if ($ + n.character === 84 && X() === 47)
            break;
        return "/*" + r(hl, n.position - 1) + "*" + Y($ === 47 ? $ : B());
      }
      function D($) {
        for (; !G(X()); )
          B();
        return r($, n.position);
      }
      function C($) {
        return T(nl("", null, null, null, [""], $ = J($), 0, [0], $));
      }
      function nl($, hl, Tl, Jl, yl, Il, gl, wl, _l) {
        for (var lt = 0, ct = 0, Nl = gl, Sl = 0, Yl = 0, Hl = 0, vl = 1, jl = 1, El = 1, Pl = 0, Jt = "", rt = yl, Ft = Il, ot = Jl, Dl = Jt; jl; )
          switch (Hl = Pl, Pl = B()) {
            case 40:
              if (Hl != 108 && w(Dl, Nl - 1) == 58) {
                P(Dl += K(y(Pl), "&", "&\f"), "&\f", p(lt ? wl[lt - 1] : 0)) != -1 && (El = -1);
                break;
              }
            case 34:
            case 39:
            case 91:
              Dl += y(Pl);
              break;
            case 9:
            case 10:
            case 13:
            case 32:
              Dl += E(Hl);
              break;
            case 92:
              Dl += v(b() - 1, 7);
              continue;
            case 47:
              switch (X()) {
                case 42:
                case 47:
                  q(sl(g(B(), b()), hl, Tl, _l), _l);
                  break;
                default:
                  Dl += "/";
              }
              break;
            case 123 * vl:
              wl[lt++] = el(Dl) * El;
            case 125 * vl:
            case 59:
            case 0:
              switch (Pl) {
                case 0:
                case 125:
                  jl = 0;
                case 59 + ct:
                  El == -1 && (Dl = K(Dl, /\f/g, "")), Yl > 0 && el(Dl) - Nl && q(Yl > 32 ? Vl(Dl + ";", Jl, Tl, Nl - 1, _l) : Vl(K(Dl, " ", "") + ";", Jl, Tl, Nl - 2, _l), _l);
                  break;
                case 59:
                  Dl += ";";
                default:
                  if (q(ot = Fl(Dl, hl, Tl, lt, ct, yl, wl, Jt, rt = [], Ft = [], Nl, Il), Il), Pl === 123)
                    if (ct === 0)
                      nl(Dl, hl, ot, ot, rt, Il, Nl, wl, Ft);
                    else
                      switch (Sl === 99 && w(Dl, 3) === 110 ? 100 : Sl) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                          nl($, ot, ot, Jl && q(Fl($, ot, ot, 0, 0, yl, wl, Jt, yl, rt = [], Nl, Ft), Ft), yl, Ft, Nl, wl, Jl ? rt : Ft);
                          break;
                        default:
                          nl(Dl, ot, ot, ot, [""], Ft, 0, wl, Ft);
                      }
              }
              lt = ct = Yl = 0, vl = El = 1, Jt = Dl = "", Nl = gl;
              break;
            case 58:
              Nl = 1 + el(Dl), Yl = Hl;
            default:
              if (vl < 1) {
                if (Pl == 123)
                  --vl;
                else if (Pl == 125 && vl++ == 0 && cl() == 125)
                  continue;
              }
              switch (Dl += Y(Pl), Pl * vl) {
                case 38:
                  El = ct > 0 ? 1 : (Dl += "\f", -1);
                  break;
                case 44:
                  wl[lt++] = (el(Dl) - 1) * El, El = 1;
                  break;
                case 64:
                  X() === 45 && (Dl += y(B())), Sl = X(), ct = Nl = el(Jt = Dl += D(b())), Pl++;
                  break;
                case 45:
                  Hl === 45 && el(Dl) == 2 && (vl = 0);
              }
          }
        return Il;
      }
      function Fl($, hl, Tl, Jl, yl, Il, gl, wl, _l, lt, ct, Nl) {
        for (var Sl = yl - 1, Yl = yl === 0 ? Il : [""], Hl = ll(Yl), vl = 0, jl = 0, El = 0; vl < Jl; ++vl)
          for (var Pl = 0, Jt = O($, Sl + 1, Sl = p(jl = gl[vl])), rt = $; Pl < Hl; ++Pl)
            (rt = z(jl > 0 ? Yl[Pl] + " " + Jt : K(Jt, /&\f/g, Yl[Pl]))) && (_l[El++] = rt);
        return dl($, hl, Tl, yl === 0 ? V : wl, _l, lt, ct, Nl);
      }
      function sl($, hl, Tl, Jl) {
        return dl($, hl, Tl, U, Y(Ul()), O($, 2, -2), 0, Jl);
      }
      function Vl($, hl, Tl, Jl, yl) {
        return dl($, hl, Tl, h, O($, 0, Jl), O($, Jl + 1, -1), Jl, yl);
      }
      function Rl($, hl, Tl) {
        switch (L($, hl)) {
          case 5103:
            return a + "print-" + $ + $;
          case 5737:
          case 4201:
          case 3177:
          case 3433:
          case 1641:
          case 4457:
          case 2921:
          case 5572:
          case 6356:
          case 5844:
          case 3191:
          case 6645:
          case 3005:
          case 6391:
          case 5879:
          case 5623:
          case 6135:
          case 4599:
          case 4855:
          case 4215:
          case 6389:
          case 5109:
          case 5365:
          case 5621:
          case 3829:
            return a + $ + $;
          case 4789:
            return d + $ + $;
          case 5349:
          case 4246:
          case 4810:
          case 6968:
          case 2756:
            return a + $ + d + $ + e + $ + $;
          case 5936:
            switch (w($, hl + 11)) {
              case 114:
                return a + $ + e + K($, /[svh]\w+-[tblr]{2}/, "tb") + $;
              case 108:
                return a + $ + e + K($, /[svh]\w+-[tblr]{2}/, "tb-rl") + $;
              case 45:
                return a + $ + e + K($, /[svh]\w+-[tblr]{2}/, "lr") + $;
            }
          case 6828:
          case 4268:
          case 2903:
            return a + $ + e + $ + $;
          case 6165:
            return a + $ + e + "flex-" + $ + $;
          case 5187:
            return a + $ + K($, /(\w+).+(:[^]+)/, a + "box-$1$2" + e + "flex-$1$2") + $;
          case 5443:
            return a + $ + e + "flex-item-" + K($, /flex-|-self/g, "") + (f($, /flex-|baseline/) ? "" : e + "grid-row-" + K($, /flex-|-self/g, "")) + $;
          case 4675:
            return a + $ + e + "flex-line-pack" + K($, /align-content|flex-|-self/g, "") + $;
          case 5548:
            return a + $ + e + K($, "shrink", "negative") + $;
          case 5292:
            return a + $ + e + K($, "basis", "preferred-size") + $;
          case 6060:
            return a + "box-" + K($, "-grow", "") + a + $ + e + K($, "grow", "positive") + $;
          case 4554:
            return a + K($, /([^-])(transform)/g, "$1" + a + "$2") + $;
          case 6187:
            return K(K(K($, /(zoom-|grab)/, a + "$1"), /(image-set)/, a + "$1"), $, "") + $;
          case 5495:
          case 3959:
            return K($, /(image-set\([^]*)/, a + "$1$`$1");
          case 4968:
            return K(K($, /(.+:)(flex-)?(.*)/, a + "box-pack:$3" + e + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + a + $ + $;
          case 4200:
            if (!f($, /flex-|baseline/))
              return e + "grid-column-align" + O($, hl) + $;
            break;
          case 2592:
          case 3360:
            return e + K($, "template-", "") + $;
          case 4384:
          case 3616:
            return Tl && Tl.some(function(Jl, yl) {
              return hl = yl, f(Jl.props, /grid-\w+-end/);
            }) ? ~P($ + (Tl = Tl[hl].value), "span", 0) ? $ : e + K($, "-start", "") + $ + e + "grid-row-span:" + (~P(Tl, "span", 0) ? f(Tl, /\d+/) : +f(Tl, /\d+/) - +f($, /\d+/)) + ";" : e + K($, "-start", "") + $;
          case 4896:
          case 4128:
            return Tl && Tl.some(function(Jl) {
              return f(Jl.props, /grid-\w+-start/);
            }) ? $ : e + K(K($, "-end", "-span"), "span ", "") + $;
          case 4095:
          case 3583:
          case 4068:
          case 2532:
            return K($, /(.+)-inline(.+)/, a + "$1$2") + $;
          case 8116:
          case 7059:
          case 5753:
          case 5535:
          case 5445:
          case 5701:
          case 4933:
          case 4677:
          case 5533:
          case 5789:
          case 5021:
          case 4765:
            if (el($) - 1 - hl > 6)
              switch (w($, hl + 1)) {
                case 109:
                  if (w($, hl + 4) !== 45)
                    break;
                case 102:
                  return K($, /(.+:)(.+)-([^]+)/, "$1" + a + "$2-$3$1" + d + (w($, hl + 3) == 108 ? "$3" : "$2-$3")) + $;
                case 115:
                  return ~P($, "stretch", 0) ? Rl(K($, "stretch", "fill-available"), hl, Tl) + $ : $;
              }
            break;
          case 5152:
          case 5920:
            return K($, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(Jl, yl, Il, gl, wl, _l, lt) {
              return e + yl + ":" + Il + lt + (gl ? e + yl + "-span:" + (wl ? _l : +_l - +Il) + lt : "") + $;
            });
          case 4949:
            if (w($, hl + 6) === 121)
              return K($, ":", ":" + a) + $;
            break;
          case 6444:
            switch (w($, w($, 14) === 45 ? 18 : 11)) {
              case 120:
                return K($, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + a + (w($, 14) === 45 ? "inline-" : "") + "box$3$1" + a + "$2$3$1" + e + "$2box$3") + $;
              case 100:
                return K($, ":", ":" + e) + $;
            }
            break;
          case 5719:
          case 2647:
          case 2135:
          case 3927:
          case 2391:
            return K($, "scroll-", "scroll-snap-") + $;
        }
        return $;
      }
      function Wl($, hl) {
        for (var Tl = "", Jl = 0; Jl < $.length; Jl++)
          Tl += hl($[Jl], Jl, $, hl) || "";
        return Tl;
      }
      function ml($, hl, Tl, Jl) {
        switch ($.type) {
          case M:
            if ($.children.length)
              break;
          case s:
          case h:
            return $.return = $.return || $.value;
          case U:
            return "";
          case i:
            return $.return = $.value + "{" + Wl($.children, Jl) + "}";
          case V:
            if (!el($.value = $.props.join(",")))
              return "";
        }
        return el(Tl = Wl($.children, Jl)) ? $.return = $.value + "{" + Tl + "}" : "";
      }
      function rl($) {
        var hl = ll($);
        return function(Tl, Jl, yl, Il) {
          for (var gl = "", wl = 0; wl < hl; wl++)
            gl += $[wl](Tl, Jl, yl, Il) || "";
          return gl;
        };
      }
      function Gl($) {
        return function(hl) {
          hl.root || (hl = hl.return) && $(hl);
        };
      }
      function Ll($, hl, Tl, Jl) {
        if ($.length > -1 && !$.return)
          switch ($.type) {
            case h:
              $.return = Rl($.value, $.length, Tl);
              return;
            case i:
              return Wl([tl($, { value: K($.value, "@", "@" + a) })], Jl);
            case V:
              if ($.length)
                return _(Tl = $.props, function(yl) {
                  switch (f(yl, Jl = /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      al(tl($, { props: [K(yl, /:(read-\w+)/, ":" + d + "$1")] })), al(tl($, { props: [yl] })), k($, { props: il(Tl, Jl) });
                      break;
                    case "::placeholder":
                      al(tl($, { props: [K(yl, /:(plac\w+)/, ":" + a + "input-$1")] })), al(tl($, { props: [K(yl, /:(plac\w+)/, ":" + d + "$1")] })), al(tl($, { props: [K(yl, /:(plac\w+)/, e + "input-$1")] })), al(tl($, { props: [yl] })), k($, { props: il(Tl, Jl) });
                      break;
                  }
                  return "";
                });
          }
      }
      function Cl($) {
        switch ($.type) {
          case V:
            $.props = $.props.map(function(hl) {
              return _(I(hl), function(Tl, Jl, yl) {
                switch (w(Tl, 0)) {
                  case 12:
                    return O(Tl, 1, el(Tl));
                  case 0:
                  case 40:
                  case 43:
                  case 62:
                  case 126:
                    return Tl;
                  case 58:
                    yl[++Jl] === "global" && (yl[Jl] = "", yl[++Jl] = "\f" + O(yl[Jl], Jl = 1, -1));
                  case 32:
                    return Jl === 1 ? "" : Tl;
                  default:
                    switch (Jl) {
                      case 0:
                        return $ = Tl, ll(yl) > 1 ? "" : Tl;
                      case (Jl = ll(yl) - 1):
                      case 2:
                        return Jl === 2 ? Tl + $ + $ : Tl + $;
                      default:
                        return Tl;
                    }
                }
              });
            });
        }
      }
      n.CHARSET = o, n.COMMENT = U, n.COUNTER_STYLE = R, n.DECLARATION = h, n.DOCUMENT = Q, n.FONT_FACE = c, n.FONT_FEATURE_VALUES = m, n.IMPORT = s, n.KEYFRAMES = i, n.LAYER = M, n.MEDIA = Z, n.MOZ = d, n.MS = e, n.NAMESPACE = u, n.PAGE = W, n.RULESET = V, n.SCOPE = S, n.SUPPORTS = N, n.VIEWPORT = F, n.WEBKIT = a, n.abs = p, n.alloc = J, n.append = q, n.assign = k, n.caret = b, n.char = Ul, n.charat = w, n.combine = _, n.comment = sl, n.commenter = g, n.compile = C, n.copy = tl, n.dealloc = T, n.declaration = Vl, n.delimit = y, n.delimiter = A, n.escaping = v, n.filter = il, n.from = Y, n.hash = L, n.identifier = D, n.indexof = P, n.lift = al, n.match = f, n.middleware = rl, n.namespace = Cl, n.next = B, n.node = dl, n.parse = nl, n.peek = X, n.prefix = Rl, n.prefixer = Ll, n.prev = cl, n.replace = K, n.ruleset = Fl, n.rulesheet = Gl, n.serialize = Wl, n.sizeof = ll, n.slice = r, n.stringify = ml, n.strlen = el, n.substr = O, n.token = G, n.tokenize = I, n.tokenizer = x, n.trim = z, n.whitespace = E, Object.defineProperty(n, "__esModule", { value: !0 });
    });
  }(ze, ze.exports)), ze.exports;
}
function Zt(l, t) {
  JF(l) && (l = "100%");
  var n = XF(l);
  return l = t === 360 ? l : Math.min(t, Math.max(0, parseFloat(l))), n && (l = parseInt(String(l * t), 10) / 100), Math.abs(l - t) < 1e-6 ? 1 : (t === 360 ? l = (l < 0 ? l % t + t : l % t) / parseFloat(String(t)) : l = l % t / parseFloat(String(t)), l);
}
function Le(l) {
  return Math.min(1, Math.max(0, l));
}
function JF(l) {
  return typeof l == "string" && l.indexOf(".") !== -1 && parseFloat(l) === 1;
}
function XF(l) {
  return typeof l == "string" && l.indexOf("%") !== -1;
}
function BU(l) {
  return l = parseFloat(l), (isNaN(l) || l < 0 || l > 1) && (l = 1), l;
}
function ke(l) {
  return l <= 1 ? "".concat(Number(l) * 100, "%") : l;
}
function Nn(l) {
  return l.length === 1 ? "0" + l : String(l);
}
function YF(l, t, n) {
  return {
    r: Zt(l, 255) * 255,
    g: Zt(t, 255) * 255,
    b: Zt(n, 255) * 255
  };
}
function ss(l, t, n) {
  l = Zt(l, 255), t = Zt(t, 255), n = Zt(n, 255);
  var e = Math.max(l, t, n), d = Math.min(l, t, n), a = 0, U = 0, V = (e + d) / 2;
  if (e === d)
    U = 0, a = 0;
  else {
    var h = e - d;
    switch (U = V > 0.5 ? h / (2 - e - d) : h / (e + d), e) {
      case l:
        a = (t - n) / h + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - l) / h + 2;
        break;
      case n:
        a = (l - t) / h + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: U, l: V };
}
function Kd(l, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? l + (t - l) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? l + (t - l) * (2 / 3 - n) * 6 : l;
}
function yF(l, t, n) {
  var e, d, a;
  if (l = Zt(l, 360), t = Zt(t, 100), n = Zt(n, 100), t === 0)
    d = n, a = n, e = n;
  else {
    var U = n < 0.5 ? n * (1 + t) : n + t - n * t, V = 2 * n - U;
    e = Kd(V, U, l + 1 / 3), d = Kd(V, U, l), a = Kd(V, U, l - 1 / 3);
  }
  return { r: e * 255, g: d * 255, b: a * 255 };
}
function ra(l, t, n) {
  l = Zt(l, 255), t = Zt(t, 255), n = Zt(n, 255);
  var e = Math.max(l, t, n), d = Math.min(l, t, n), a = 0, U = e, V = e - d, h = e === 0 ? 0 : V / e;
  if (e === d)
    a = 0;
  else {
    switch (e) {
      case l:
        a = (t - n) / V + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - l) / V + 2;
        break;
      case n:
        a = (l - t) / V + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: h, v: U };
}
function BF(l, t, n) {
  l = Zt(l, 360) * 6, t = Zt(t, 100), n = Zt(n, 100);
  var e = Math.floor(l), d = l - e, a = n * (1 - t), U = n * (1 - d * t), V = n * (1 - (1 - d) * t), h = e % 6, W = [n, U, a, a, V, n][h], Z = [V, n, n, U, a, a][h], s = [a, a, V, n, n, U][h];
  return { r: W * 255, g: Z * 255, b: s * 255 };
}
function Ma(l, t, n, e) {
  var d = [
    Nn(Math.round(l).toString(16)),
    Nn(Math.round(t).toString(16)),
    Nn(Math.round(n).toString(16))
  ];
  return e && d[0].startsWith(d[0].charAt(1)) && d[1].startsWith(d[1].charAt(1)) && d[2].startsWith(d[2].charAt(1)) ? d[0].charAt(0) + d[1].charAt(0) + d[2].charAt(0) : d.join("");
}
function zF(l, t, n, e, d) {
  var a = [
    Nn(Math.round(l).toString(16)),
    Nn(Math.round(t).toString(16)),
    Nn(Math.round(n).toString(16)),
    Nn(LF(e))
  ];
  return d && a[0].startsWith(a[0].charAt(1)) && a[1].startsWith(a[1].charAt(1)) && a[2].startsWith(a[2].charAt(1)) && a[3].startsWith(a[3].charAt(1)) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function LF(l) {
  return Math.round(parseFloat(l) * 255).toString(16);
}
function cs(l) {
  return pt(l) / 255;
}
function pt(l) {
  return parseInt(l, 16);
}
function kF(l) {
  return {
    r: l >> 16,
    g: (l & 65280) >> 8,
    b: l & 255
  };
}
var pa = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function En(l) {
  var t = { r: 0, g: 0, b: 0 }, n = 1, e = null, d = null, a = null, U = !1, V = !1;
  return typeof l == "string" && (l = CF(l)), typeof l == "object" && (jt(l.r) && jt(l.g) && jt(l.b) ? (t = YF(l.r, l.g, l.b), U = !0, V = String(l.r).substr(-1) === "%" ? "prgb" : "rgb") : jt(l.h) && jt(l.s) && jt(l.v) ? (e = ke(l.s), d = ke(l.v), t = BF(l.h, e, d), U = !0, V = "hsv") : jt(l.h) && jt(l.s) && jt(l.l) && (e = ke(l.s), a = ke(l.l), t = yF(l.h, e, a), U = !0, V = "hsl"), Object.prototype.hasOwnProperty.call(l, "a") && (n = l.a)), n = BU(n), {
    ok: U,
    format: l.format || V,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: n
  };
}
var IF = "[-\\+]?\\d+%?", DF = "[-\\+]?\\d*\\.\\d+%?", nn = "(?:".concat(DF, ")|(?:").concat(IF, ")"), Hd = "[\\s|\\(]+(".concat(nn, ")[,|\\s]+(").concat(nn, ")[,|\\s]+(").concat(nn, ")\\s*\\)?"), Pd = "[\\s|\\(]+(".concat(nn, ")[,|\\s]+(").concat(nn, ")[,|\\s]+(").concat(nn, ")[,|\\s]+(").concat(nn, ")\\s*\\)?"), Lt = {
  CSS_UNIT: new RegExp(nn),
  rgb: new RegExp("rgb" + Hd),
  rgba: new RegExp("rgba" + Pd),
  hsl: new RegExp("hsl" + Hd),
  hsla: new RegExp("hsla" + Pd),
  hsv: new RegExp("hsv" + Hd),
  hsva: new RegExp("hsva" + Pd),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function CF(l) {
  if (l = l.trim().toLowerCase(), l.length === 0)
    return !1;
  var t = !1;
  if (pa[l])
    l = pa[l], t = !0;
  else if (l === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = Lt.rgb.exec(l);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = Lt.rgba.exec(l), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = Lt.hsl.exec(l), n ? { h: n[1], s: n[2], l: n[3] } : (n = Lt.hsla.exec(l), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = Lt.hsv.exec(l), n ? { h: n[1], s: n[2], v: n[3] } : (n = Lt.hsva.exec(l), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = Lt.hex8.exec(l), n ? {
    r: pt(n[1]),
    g: pt(n[2]),
    b: pt(n[3]),
    a: cs(n[4]),
    format: t ? "name" : "hex8"
  } : (n = Lt.hex6.exec(l), n ? {
    r: pt(n[1]),
    g: pt(n[2]),
    b: pt(n[3]),
    format: t ? "name" : "hex"
  } : (n = Lt.hex4.exec(l), n ? {
    r: pt(n[1] + n[1]),
    g: pt(n[2] + n[2]),
    b: pt(n[3] + n[3]),
    a: cs(n[4] + n[4]),
    format: t ? "name" : "hex8"
  } : (n = Lt.hex3.exec(l), n ? {
    r: pt(n[1] + n[1]),
    g: pt(n[2] + n[2]),
    b: pt(n[3] + n[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function jt(l) {
  return !!Lt.CSS_UNIT.exec(String(l));
}
var et = (
  /** @class */
  function() {
    function l(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var e;
      if (t instanceof l)
        return t;
      typeof t == "number" && (t = kF(t)), this.originalInput = t;
      var d = En(t);
      this.originalInput = t, this.r = d.r, this.g = d.g, this.b = d.b, this.a = d.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (e = n.format) !== null && e !== void 0 ? e : d.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = d.ok;
    }
    return l.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, l.prototype.isLight = function() {
      return !this.isDark();
    }, l.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, l.prototype.getLuminance = function() {
      var t = this.toRgb(), n, e, d, a = t.r / 255, U = t.g / 255, V = t.b / 255;
      return a <= 0.03928 ? n = a / 12.92 : n = Math.pow((a + 0.055) / 1.055, 2.4), U <= 0.03928 ? e = U / 12.92 : e = Math.pow((U + 0.055) / 1.055, 2.4), V <= 0.03928 ? d = V / 12.92 : d = Math.pow((V + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * e + 0.0722 * d;
    }, l.prototype.getAlpha = function() {
      return this.a;
    }, l.prototype.setAlpha = function(t) {
      return this.a = BU(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, l.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, l.prototype.toHsv = function() {
      var t = ra(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, l.prototype.toHsvString = function() {
      var t = ra(this.r, this.g, this.b), n = Math.round(t.h * 360), e = Math.round(t.s * 100), d = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(e, "%, ").concat(d, "%)") : "hsva(".concat(n, ", ").concat(e, "%, ").concat(d, "%, ").concat(this.roundA, ")");
    }, l.prototype.toHsl = function() {
      var t = ss(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, l.prototype.toHslString = function() {
      var t = ss(this.r, this.g, this.b), n = Math.round(t.h * 360), e = Math.round(t.s * 100), d = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(e, "%, ").concat(d, "%)") : "hsla(".concat(n, ", ").concat(e, "%, ").concat(d, "%, ").concat(this.roundA, ")");
    }, l.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), Ma(this.r, this.g, this.b, t);
    }, l.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, l.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), zF(this.r, this.g, this.b, this.a, t);
    }, l.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, l.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, l.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, l.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), e = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(e, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(e, ", ").concat(this.roundA, ")");
    }, l.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(Zt(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, l.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(Zt(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, l.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + Ma(this.r, this.g, this.b, !1), n = 0, e = Object.entries(pa); n < e.length; n++) {
        var d = e[n], a = d[0], U = d[1];
        if (t === U)
          return a;
      }
      return !1;
    }, l.prototype.toString = function(t) {
      var n = !!t;
      t = t ?? this.format;
      var e = !1, d = this.a < 1 && this.a >= 0, a = !n && d && (t.startsWith("hex") || t === "name");
      return a ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (e = this.toRgbString()), t === "prgb" && (e = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (e = this.toHexString()), t === "hex3" && (e = this.toHexString(!0)), t === "hex4" && (e = this.toHex8String(!0)), t === "hex8" && (e = this.toHex8String()), t === "name" && (e = this.toName()), t === "hsl" && (e = this.toHslString()), t === "hsv" && (e = this.toHsvString()), e || this.toHexString());
    }, l.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, l.prototype.clone = function() {
      return new l(this.toString());
    }, l.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = Le(n.l), new l(n);
    }, l.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new l(n);
    }, l.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = Le(n.l), new l(n);
    }, l.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, l.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, l.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = Le(n.s), new l(n);
    }, l.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = Le(n.s), new l(n);
    }, l.prototype.greyscale = function() {
      return this.desaturate(100);
    }, l.prototype.spin = function(t) {
      var n = this.toHsl(), e = (n.h + t) % 360;
      return n.h = e < 0 ? 360 + e : e, new l(n);
    }, l.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var e = this.toRgb(), d = new l(t).toRgb(), a = n / 100, U = {
        r: (d.r - e.r) * a + e.r,
        g: (d.g - e.g) * a + e.g,
        b: (d.b - e.b) * a + e.b,
        a: (d.a - e.a) * a + e.a
      };
      return new l(U);
    }, l.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var e = this.toHsl(), d = 360 / n, a = [this];
      for (e.h = (e.h - (d * t >> 1) + 720) % 360; --t; )
        e.h = (e.h + d) % 360, a.push(new l(e));
      return a;
    }, l.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new l(t);
    }, l.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), e = n.h, d = n.s, a = n.v, U = [], V = 1 / t; t--; )
        U.push(new l({ h: e, s: d, v: a })), a = (a + V) % 1;
      return U;
    }, l.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new l({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new l({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, l.prototype.onBackground = function(t) {
      var n = this.toRgb(), e = new l(t).toRgb(), d = n.a + e.a * (1 - n.a);
      return new l({
        r: (n.r * n.a + e.r * e.a * (1 - n.a)) / d,
        g: (n.g * n.a + e.g * e.a * (1 - n.a)) / d,
        b: (n.b * n.a + e.b * e.a * (1 - n.a)) / d,
        a: d
      });
    }, l.prototype.triad = function() {
      return this.polyad(3);
    }, l.prototype.tetrad = function() {
      return this.polyad(4);
    }, l.prototype.polyad = function(t) {
      for (var n = this.toHsl(), e = n.h, d = [this], a = 360 / t, U = 1; U < t; U++)
        d.push(new l({ h: (e + U * a) % 360, s: n.s, l: n.l }));
      return d;
    }, l.prototype.equals = function(t) {
      return this.toRgbString() === new l(t).toRgbString();
    }, l;
  }()
), Ie = 2, Us = 0.16, wF = 0.05, EF = 0.05, xF = 0.15, zU = 5, LU = 4, gF = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function Zs(l) {
  var t = l.r, n = l.g, e = l.b, d = ra(t, n, e);
  return {
    h: d.h * 360,
    s: d.s,
    v: d.v
  };
}
function De(l) {
  var t = l.r, n = l.g, e = l.b;
  return "#".concat(Ma(t, n, e, !1));
}
function jF(l, t, n) {
  var e = n / 100, d = {
    r: (t.r - l.r) * e + l.r,
    g: (t.g - l.g) * e + l.g,
    b: (t.b - l.b) * e + l.b
  };
  return d;
}
function Fs(l, t, n) {
  var e;
  return Math.round(l.h) >= 60 && Math.round(l.h) <= 240 ? e = n ? Math.round(l.h) - Ie * t : Math.round(l.h) + Ie * t : e = n ? Math.round(l.h) + Ie * t : Math.round(l.h) - Ie * t, e < 0 ? e += 360 : e >= 360 && (e -= 360), e;
}
function os(l, t, n) {
  if (l.h === 0 && l.s === 0)
    return l.s;
  var e;
  return n ? e = l.s - Us * t : t === LU ? e = l.s + Us : e = l.s + wF * t, e > 1 && (e = 1), n && t === zU && e > 0.1 && (e = 0.1), e < 0.06 && (e = 0.06), Number(e.toFixed(2));
}
function Vs(l, t, n) {
  var e;
  return n ? e = l.v + EF * t : e = l.v - xF * t, e > 1 && (e = 1), Number(e.toFixed(2));
}
function Qe(l) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], e = En(l), d = zU; d > 0; d -= 1) {
    var a = Zs(e), U = De(En({
      h: Fs(a, d, !0),
      s: os(a, d, !0),
      v: Vs(a, d, !0)
    }));
    n.push(U);
  }
  n.push(De(e));
  for (var V = 1; V <= LU; V += 1) {
    var h = Zs(e), W = De(En({
      h: Fs(h, V),
      s: os(h, V),
      v: Vs(h, V)
    }));
    n.push(W);
  }
  return t.theme === "dark" ? gF.map(function(Z) {
    var s = Z.index, o = Z.opacity, F = De(jF(En(t.backgroundColor || "#141414"), En(n[s]), o * 100));
    return F;
  }) : n;
}
var Ad = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, fe = {}, $d = {};
Object.keys(Ad).forEach(function(l) {
  fe[l] = Qe(Ad[l]), fe[l].primary = fe[l][5], $d[l] = Qe(Ad[l], {
    theme: "dark",
    backgroundColor: "#141414"
  }), $d[l].primary = $d[l][5];
});
var OF = fe.blue;
function We(l) {
  "@babel/helpers - typeof";
  return We = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, We(l);
}
function vF(l, t) {
  if (We(l) != "object" || !l)
    return l;
  var n = l[Symbol.toPrimitive];
  if (n !== void 0) {
    var e = n.call(l, t || "default");
    if (We(e) != "object")
      return e;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(l);
}
function fF(l) {
  var t = vF(l, "string");
  return We(t) == "symbol" ? t : t + "";
}
function KF(l, t, n) {
  return (t = fF(t)) in l ? Object.defineProperty(l, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : l[t] = n, l;
}
function Qs(l, t) {
  var n = Object.keys(l);
  if (Object.getOwnPropertySymbols) {
    var e = Object.getOwnPropertySymbols(l);
    t && (e = e.filter(function(d) {
      return Object.getOwnPropertyDescriptor(l, d).enumerable;
    })), n.push.apply(n, e);
  }
  return n;
}
function Ql(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qs(Object(n), !0).forEach(function(e) {
      KF(l, e, n[e]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(l, Object.getOwnPropertyDescriptors(n)) : Qs(Object(n)).forEach(function(e) {
      Object.defineProperty(l, e, Object.getOwnPropertyDescriptor(n, e));
    });
  }
  return l;
}
function j() {
  return j = Object.assign ? Object.assign.bind() : function(l) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var e in n)
        ({}).hasOwnProperty.call(n, e) && (l[e] = n[e]);
    }
    return l;
  }, j.apply(null, arguments);
}
const HF = (l) => typeof l == "function", PF = Array.isArray, AF = (l) => typeof l == "string", $F = (l) => l !== null && typeof l == "object", qF = /^on[^a-z]/, _F = (l) => qF.test(l), kU = (l) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = l(n));
}, lo = /-(\w)/g, IU = kU((l) => l.replace(lo, (t, n) => n ? n.toUpperCase() : "")), to = /\B([A-Z])/g, no = kU((l) => l.replace(to, "-$1").toLowerCase()), eo = Object.prototype.hasOwnProperty, Ws = (l, t) => eo.call(l, t);
function ao(l, t, n, e) {
  const d = l[n];
  if (d != null) {
    const a = Ws(d, "default");
    if (a && e === void 0) {
      const U = d.default;
      e = d.type !== Function && HF(U) ? U() : U;
    }
    d.type === Boolean && (!Ws(t, n) && !a ? e = !1 : e === "" && (e = !0));
  }
  return e;
}
function Xl() {
  const l = [];
  for (let t = 0; t < arguments.length; t++) {
    const n = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    if (n) {
      if (AF(n))
        l.push(n);
      else if (PF(n))
        for (let e = 0; e < n.length; e++) {
          const d = Xl(n[e]);
          d && l.push(d);
        }
      else if ($F(n))
        for (const e in n)
          n[e] && l.push(e);
    }
  }
  return l.join(" ");
}
var DU = function() {
  if (typeof Map < "u")
    return Map;
  function l(t, n) {
    var e = -1;
    return t.some(function(d, a) {
      return d[0] === n ? (e = a, !0) : !1;
    }), e;
  }
  return (
    /** @class */
    function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.get = function(n) {
        var e = l(this.__entries__, n), d = this.__entries__[e];
        return d && d[1];
      }, t.prototype.set = function(n, e) {
        var d = l(this.__entries__, n);
        ~d ? this.__entries__[d][1] = e : this.__entries__.push([n, e]);
      }, t.prototype.delete = function(n) {
        var e = this.__entries__, d = l(e, n);
        ~d && e.splice(d, 1);
      }, t.prototype.has = function(n) {
        return !!~l(this.__entries__, n);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(n, e) {
        e === void 0 && (e = null);
        for (var d = 0, a = this.__entries__; d < a.length; d++) {
          var U = a[d];
          n.call(e, U[1], U[0]);
        }
      }, t;
    }()
  );
}(), Sa = typeof window < "u" && typeof document < "u" && window.document === document, ld = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), io = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(ld) : function(l) {
    return setTimeout(function() {
      return l(Date.now());
    }, 1e3 / 60);
  };
}(), so = 2;
function co(l, t) {
  var n = !1, e = !1, d = 0;
  function a() {
    n && (n = !1, l()), e && V();
  }
  function U() {
    io(a);
  }
  function V() {
    var h = Date.now();
    if (n) {
      if (h - d < so)
        return;
      e = !0;
    } else
      n = !0, e = !1, setTimeout(U, t);
    d = h;
  }
  return V;
}
var Uo = 20, Zo = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], Fo = typeof MutationObserver < "u", oo = (
  /** @class */
  function() {
    function l() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = co(this.refresh.bind(this), Uo);
    }
    return l.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, l.prototype.removeObserver = function(t) {
      var n = this.observers_, e = n.indexOf(t);
      ~e && n.splice(e, 1), !n.length && this.connected_ && this.disconnect_();
    }, l.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, l.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(n) {
        return n.gatherActive(), n.hasActive();
      });
      return t.forEach(function(n) {
        return n.broadcastActive();
      }), t.length > 0;
    }, l.prototype.connect_ = function() {
      !Sa || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), Fo ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, l.prototype.disconnect_ = function() {
      !Sa || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, l.prototype.onTransitionEnd_ = function(t) {
      var n = t.propertyName, e = n === void 0 ? "" : n, d = Zo.some(function(a) {
        return !!~e.indexOf(a);
      });
      d && this.refresh();
    }, l.getInstance = function() {
      return this.instance_ || (this.instance_ = new l()), this.instance_;
    }, l.instance_ = null, l;
  }()
), CU = function(l, t) {
  for (var n = 0, e = Object.keys(t); n < e.length; n++) {
    var d = e[n];
    Object.defineProperty(l, d, {
      value: t[d],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return l;
}, vn = function(l) {
  var t = l && l.ownerDocument && l.ownerDocument.defaultView;
  return t || ld;
}, wU = pd(0, 0, 0, 0);
function td(l) {
  return parseFloat(l) || 0;
}
function hs(l) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return t.reduce(function(e, d) {
    var a = l["border-" + d + "-width"];
    return e + td(a);
  }, 0);
}
function Vo(l) {
  for (var t = ["top", "right", "bottom", "left"], n = {}, e = 0, d = t; e < d.length; e++) {
    var a = d[e], U = l["padding-" + a];
    n[a] = td(U);
  }
  return n;
}
function Qo(l) {
  var t = l.getBBox();
  return pd(0, 0, t.width, t.height);
}
function Wo(l) {
  var t = l.clientWidth, n = l.clientHeight;
  if (!t && !n)
    return wU;
  var e = vn(l).getComputedStyle(l), d = Vo(e), a = d.left + d.right, U = d.top + d.bottom, V = td(e.width), h = td(e.height);
  if (e.boxSizing === "border-box" && (Math.round(V + a) !== t && (V -= hs(e, "left", "right") + a), Math.round(h + U) !== n && (h -= hs(e, "top", "bottom") + U)), !Ro(l)) {
    var W = Math.round(V + a) - t, Z = Math.round(h + U) - n;
    Math.abs(W) !== 1 && (V -= W), Math.abs(Z) !== 1 && (h -= Z);
  }
  return pd(d.left, d.top, V, h);
}
var ho = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(l) {
    return l instanceof vn(l).SVGGraphicsElement;
  } : function(l) {
    return l instanceof vn(l).SVGElement && typeof l.getBBox == "function";
  };
}();
function Ro(l) {
  return l === vn(l).document.documentElement;
}
function No(l) {
  return Sa ? ho(l) ? Qo(l) : Wo(l) : wU;
}
function bo(l) {
  var t = l.x, n = l.y, e = l.width, d = l.height, a = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, U = Object.create(a.prototype);
  return CU(U, {
    x: t,
    y: n,
    width: e,
    height: d,
    top: n,
    right: t + e,
    bottom: d + n,
    left: t
  }), U;
}
function pd(l, t, n, e) {
  return { x: l, y: t, width: n, height: e };
}
var mo = (
  /** @class */
  function() {
    function l(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = pd(0, 0, 0, 0), this.target = t;
    }
    return l.prototype.isActive = function() {
      var t = No(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, l.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, l;
  }()
), uo = (
  /** @class */
  /* @__PURE__ */ function() {
    function l(t, n) {
      var e = bo(n);
      CU(this, { target: t, contentRect: e });
    }
    return l;
  }()
), ro = (
  /** @class */
  function() {
    function l(t, n, e) {
      if (this.activeObservations_ = [], this.observations_ = new DU(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = n, this.callbackCtx_ = e;
    }
    return l.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof vn(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) || (n.set(t, new mo(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, l.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof vn(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) && (n.delete(t), n.size || this.controller_.removeObserver(this));
      }
    }, l.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, l.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(n) {
        n.isActive() && t.activeObservations_.push(n);
      });
    }, l.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, n = this.activeObservations_.map(function(e) {
          return new uo(e.target, e.broadcastRect());
        });
        this.callback_.call(t, n, t), this.clearActive();
      }
    }, l.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, l.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, l;
  }()
), EU = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new DU(), xU = (
  /** @class */
  /* @__PURE__ */ function() {
    function l(t) {
      if (!(this instanceof l))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = oo.getInstance(), e = new ro(t, n, this);
      EU.set(this, e);
    }
    return l;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(l) {
  xU.prototype[l] = function() {
    var t;
    return (t = EU.get(this))[l].apply(t, arguments);
  };
});
var gU = function() {
  return typeof ld.ResizeObserver < "u" ? ld.ResizeObserver : xU;
}();
const Mo = (l) => l != null && l !== "", yn = (l, t) => {
  const n = j({}, l);
  return Object.keys(t).forEach((e) => {
    const d = n[e];
    if (d)
      d.type || d.default ? d.default = t[e] : d.def ? d.def(t[e]) : n[e] = {
        type: d,
        default: t[e]
      };
    else
      throw new Error(`not have ${e} prop`);
  }), n;
}, jU = (l) => {
  const t = Object.keys(l), n = {}, e = {}, d = {};
  for (let a = 0, U = t.length; a < U; a++) {
    const V = t[a];
    _F(V) ? (n[V[2].toLowerCase() + V.slice(3)] = l[V], e[V] = l[V]) : d[V] = l[V];
  }
  return {
    onEvents: e,
    events: n,
    extraAttrs: d
  };
}, po = function() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = {}, e = /;(?![^(]*\))/g, d = /:(.+)/;
  return typeof l == "object" ? l : (l.split(e).forEach(function(a) {
    if (a) {
      const U = a.split(d);
      if (U.length > 1) {
        const V = t ? IU(U[0].trim()) : U[0].trim();
        n[V] = U[1].trim();
      }
    }
  }), n);
}, xn = (l, t) => l[t] !== void 0, So = Symbol("skipFlatten"), Tt = function() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = Array.isArray(l) ? l : [l], e = [];
  return n.forEach((d) => {
    Array.isArray(d) ? e.push(...Tt(d, t)) : d && d.type === st ? d.key === So ? e.push(d) : e.push(...Tt(d.children, t)) : d && $n(d) ? t && !vU(d) ? e.push(d) : t || e.push(d) : Mo(d) && e.push(d);
  }), e;
}, To = function(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if ($n(l))
    return l.type === st ? t === "default" ? Tt(l.children) : [] : l.children && l.children[t] ? Tt(l.children[t](n)) : [];
  {
    const e = l.$slots[t] && l.$slots[t](n);
    return Tt(e);
  }
}, en = (l) => {
  var t;
  let n = ((t = l?.vnode) === null || t === void 0 ? void 0 : t.el) || l && (l.$el || l);
  for (; n && !n.tagName; )
    n = n.nextSibling;
  return n;
}, Go = (l) => {
  const t = {};
  if (l.$ && l.$.vnode) {
    const n = l.$.vnode.props || {};
    Object.keys(l.$props).forEach((e) => {
      const d = l.$props[e], a = no(e);
      (d !== void 0 || a in n) && (t[e] = d);
    });
  } else if ($n(l) && typeof l.type == "object") {
    const n = l.props || {}, e = {};
    Object.keys(n).forEach((a) => {
      e[IU(a)] = n[a];
    });
    const d = l.type.props || {};
    Object.keys(d).forEach((a) => {
      const U = ao(d, e, a, e[a]);
      (U !== void 0 || a in e) && (t[a] = U);
    });
  }
  return t;
}, OU = function(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : l, e = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, d;
  if (l.$) {
    const a = l[t];
    if (a !== void 0)
      return typeof a == "function" && e ? a(n) : a;
    d = l.$slots[t], d = e && d ? d(n) : d;
  } else if ($n(l)) {
    const a = l.props && l.props[t];
    if (a !== void 0 && l.props !== null)
      return typeof a == "function" && e ? a(n) : a;
    l.type === st ? d = l.children : l.children && l.children[t] && (d = l.children[t], d = e && d ? d(n) : d);
  }
  return Array.isArray(d) && (d = Tt(d), d = d.length === 1 ? d[0] : d, d = d.length === 0 ? void 0 : d), d;
};
function Rs() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = {};
  return l.$ ? n = j(j({}, n), l.$attrs) : n = j(j({}, n), l.props), jU(n)[t ? "onEvents" : "events"];
}
function Jo(l, t) {
  let e = (($n(l) ? l.props : l.$attrs) || {}).style || {};
  return typeof e == "string" && (e = po(e, t)), e;
}
function Xo(l) {
  return l.length === 1 && l[0].type === st;
}
function vU(l) {
  return l && (l.type === WF || l.type === st && l.children.length === 0 || l.type === JU && l.children.trim() === "");
}
function Bn() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const t = [];
  return l.forEach((n) => {
    Array.isArray(n) ? t.push(...n) : n?.type === st ? t.push(...Bn(n.children)) : t.push(n);
  }), t.filter((n) => !vU(n));
}
function Pt(l) {
  return Array.isArray(l) && l.length === 1 && (l = l[0]), l && l.__v_isVNode && typeof l.type != "symbol";
}
function Yo(l, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  var e, d;
  return (e = t[n]) !== null && e !== void 0 ? e : (d = l[n]) === null || d === void 0 ? void 0 : d.call(l);
}
const Sd = pl({
  compatConfig: {
    MODE: 3
  },
  name: "ResizeObserver",
  props: {
    disabled: Boolean,
    onResize: Function
  },
  emits: ["resize"],
  setup(l, t) {
    let {
      slots: n
    } = t;
    const e = Nt({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    });
    let d = null, a = null;
    const U = () => {
      a && (a.disconnect(), a = null);
    }, V = (Z) => {
      const {
        onResize: s
      } = l, o = Z[0].target, {
        width: F,
        height: N
      } = o.getBoundingClientRect(), {
        offsetWidth: Q,
        offsetHeight: u
      } = o, i = Math.floor(F), c = Math.floor(N);
      if (e.width !== i || e.height !== c || e.offsetWidth !== Q || e.offsetHeight !== u) {
        const R = {
          width: i,
          height: c,
          offsetWidth: Q,
          offsetHeight: u
        };
        j(e, R), s && Promise.resolve().then(() => {
          s(j(j({}, R), {
            offsetWidth: Q,
            offsetHeight: u
          }), o);
        });
      }
    }, h = Jn(), W = () => {
      const {
        disabled: Z
      } = l;
      if (Z) {
        U();
        return;
      }
      const s = en(h);
      s !== d && (U(), d = s), !a && s && (a = new gU(V), a.observe(s));
    };
    return ql(() => {
      W();
    }), qn(() => {
      W();
    }), Xn(() => {
      U();
    }), Bl(() => l.disabled, () => {
      W();
    }, {
      flush: "post"
    }), () => {
      var Z;
      return (Z = n.default) === null || Z === void 0 ? void 0 : Z.call(n)[0];
    };
  }
});
let fU = (l) => setTimeout(l, 16), KU = (l) => clearTimeout(l);
typeof window < "u" && "requestAnimationFrame" in window && (fU = (l) => window.requestAnimationFrame(l), KU = (l) => window.cancelAnimationFrame(l));
let Ns = 0;
const ai = /* @__PURE__ */ new Map();
function HU(l) {
  ai.delete(l);
}
function Ol(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  Ns += 1;
  const n = Ns;
  function e(d) {
    if (d === 0)
      HU(n), l();
    else {
      const a = fU(() => {
        e(d - 1);
      });
      ai.set(n, a);
    }
  }
  return e(t), n;
}
Ol.cancel = (l) => {
  const t = ai.get(l);
  return HU(t), KU(t);
};
const he = function() {
  for (var l = arguments.length, t = new Array(l), n = 0; n < l; n++)
    t[n] = arguments[n];
  return t;
}, Td = (l) => {
  const t = l;
  return t.install = function(n) {
    n.component(t.displayName || t.name, l);
  }, l;
};
function nd() {
  return {
    type: [Function, Array]
  };
}
function dn(l) {
  return {
    type: Object,
    default: l
  };
}
function zt(l) {
  return {
    type: Boolean,
    default: l
  };
}
function ln(l) {
  return {
    type: Function,
    default: l
  };
}
function kt(l, t) {
  const n = {
    validator: () => !0,
    default: l
  };
  return n;
}
function Ta(l) {
  return {
    type: Array,
    default: l
  };
}
function Ht(l) {
  return {
    type: String,
    default: l
  };
}
function ed(l, t) {
  return l ? {
    type: l,
    default: t
  } : kt(t);
}
let Rt = !1;
try {
  const l = Object.defineProperty({}, "passive", {
    get() {
      Rt = !0;
    }
  });
  window.addEventListener("testPassive", null, l), window.removeEventListener("testPassive", null, l);
} catch {
}
function It(l, t, n, e) {
  if (l && l.addEventListener) {
    let d = e;
    d === void 0 && Rt && (t === "touchstart" || t === "touchmove" || t === "wheel") && (d = {
      passive: !1
    }), l.addEventListener(t, n, d);
  }
  return {
    remove: () => {
      l && l.removeEventListener && l.removeEventListener(t, n);
    }
  };
}
const yo = "anticon", PU = Symbol("configProvider"), AU = {
  getPrefixCls: (l, t) => t || (l ? `ant-${l}` : "ant"),
  iconPrefixCls: Zl(() => yo),
  getPopupContainer: Zl(() => () => document.body),
  direction: Zl(() => "ltr")
}, Bo = () => fl(PU, AU), zo = Symbol("DisabledContextKey"), Ge = () => fl(zo, Ml(void 0)), $U = {
  // Options.jsx
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "",
  // Pagination.jsx
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages"
}, Lo = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "Ok",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: !0,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
}, qU = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, bs = {
  lang: j({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, Lo),
  timePickerLocale: j({}, qU)
}, Mt = "${label} is not a valid ${type}", dd = {
  locale: "en",
  Pagination: $U,
  DatePicker: bs,
  TimePicker: qU,
  Calendar: bs,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: Mt,
        method: Mt,
        array: Mt,
        object: Mt,
        number: Mt,
        date: Mt,
        boolean: Mt,
        integer: Mt,
        float: Mt,
        regexp: Mt,
        email: Mt,
        url: Mt,
        hex: Mt
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  }
}, ko = pl({
  compatConfig: {
    MODE: 3
  },
  name: "LocaleReceiver",
  props: {
    componentName: String,
    defaultLocale: {
      type: [Object, Function]
    },
    children: {
      type: Function
    }
  },
  setup(l, t) {
    let {
      slots: n
    } = t;
    const e = fl("localeData", {}), d = Zl(() => {
      const {
        componentName: U = "global",
        defaultLocale: V
      } = l, h = V || dd[U || "global"], {
        antLocale: W
      } = e, Z = U && W ? W[U] : {};
      return j(j({}, typeof h == "function" ? h() : h), Z || {});
    }), a = Zl(() => {
      const {
        antLocale: U
      } = e, V = U && U.locale;
      return U && U.exist && !V ? dd.locale : V;
    });
    return () => {
      const U = l.children || n.default, {
        antLocale: V
      } = e;
      return U?.(d.value, a.value, V);
    };
  }
});
function Io(l, t, n) {
  const e = fl("localeData", {});
  return [Zl(() => {
    const {
      antLocale: a
    } = e, U = at(t) || dd[l], V = a ? a[l] : {};
    return j(j(j({}, typeof U == "function" ? U() : U), V || {}), at(n) || {});
  })];
}
const ms = "%";
class Do {
  constructor(t) {
    this.cache = /* @__PURE__ */ new Map(), this.instanceId = t;
  }
  get(t) {
    return this.cache.get(Array.isArray(t) ? t.join(ms) : t) || null;
  }
  update(t, n) {
    const e = Array.isArray(t) ? t.join(ms) : t, d = this.cache.get(e), a = n(d);
    a === null ? this.cache.delete(e) : this.cache.set(e, a);
  }
}
const _U = "data-token-hash", bn = "data-css-hash", Co = "data-cache-path", gn = "__cssinjs_instance__";
function Re() {
  const l = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    const t = document.body.querySelectorAll(`style[${bn}]`) || [], {
      firstChild: n
    } = document.head;
    Array.from(t).forEach((d) => {
      d[gn] = d[gn] || l, d[gn] === l && document.head.insertBefore(d, n);
    });
    const e = {};
    Array.from(document.querySelectorAll(`style[${bn}]`)).forEach((d) => {
      var a;
      const U = d.getAttribute(bn);
      e[U] ? d[gn] === l && ((a = d.parentNode) === null || a === void 0 || a.removeChild(d)) : e[U] = !0;
    });
  }
  return new Do(l);
}
const l0 = Symbol("StyleContextKey"), wo = () => {
  var l, t, n;
  const e = Jn();
  let d;
  if (e && e.appContext) {
    const a = (n = (t = (l = e.appContext) === null || l === void 0 ? void 0 : l.config) === null || t === void 0 ? void 0 : t.globalProperties) === null || n === void 0 ? void 0 : n.__ANTDV_CSSINJS_CACHE__;
    a ? d = a : (d = Re(), e.appContext.config.globalProperties && (e.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = d));
  } else
    d = Re();
  return d;
}, t0 = {
  cache: Re(),
  defaultCache: !0,
  hashPriority: "low"
}, Gd = () => {
  const l = wo();
  return fl(l0, bl(j(j({}, t0), {
    cache: l
  })));
}, Eo = (l) => {
  const t = Gd(), n = bl(j(j({}, t0), {
    cache: Re()
  }));
  return Bl([() => at(l), t], () => {
    const e = j({}, t.value), d = at(l);
    Object.keys(d).forEach((U) => {
      const V = d[U];
      d[U] !== void 0 && (e[U] = V);
    });
    const {
      cache: a
    } = d;
    e.cache = e.cache || Re(), e.defaultCache = !a && t.value.defaultCache, n.value = e;
  }, {
    immediate: !0
  }), nt(l0, n), n;
}, xo = () => ({
  autoClear: zt(),
  /** @private Test only. Not work in production. */
  mock: Ht(),
  /**
   * Only set when you need ssr to extract style on you own.
   * If not provided, it will auto create <style /> on the end of Provider in server side.
   */
  cache: dn(),
  /** Tell children that this context is default generated context */
  defaultCache: zt(),
  /** Use `:where` selector to reduce hashId css selector priority */
  hashPriority: Ht(),
  /** Tell cssinjs where to inject style in */
  container: ed(),
  /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
  ssrInline: zt(),
  /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
  transformers: Ta(),
  /**
   * Linters to lint css before inject in document.
   * Styles will be linted after transforming.
   * Please note that `linters` do not support dynamic update.
   */
  linters: Ta()
});
Td(pl({
  name: "AStyleProvider",
  inheritAttrs: !1,
  props: xo(),
  setup(l, t) {
    let {
      slots: n
    } = t;
    return Eo(l), () => {
      var e;
      return (e = n.default) === null || e === void 0 ? void 0 : e.call(n);
    };
  }
}));
function go() {
  return !1;
}
let Ga = !1;
function jo() {
  return Ga;
}
const Oo = process.env.NODE_ENV === "production" ? go : jo;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  const l = window;
  if (typeof l.webpackHotUpdate == "function") {
    const t = l.webpackHotUpdate;
    l.webpackHotUpdate = function() {
      return Ga = !0, setTimeout(() => {
        Ga = !1;
      }, 0), t(...arguments);
    };
  }
}
function n0(l, t, n, e) {
  const d = Gd(), a = bl(""), U = bl();
  it(() => {
    a.value = [l, ...t.value].join("%");
  });
  const V = Oo(), h = (W) => {
    d.value.cache.update(W, (Z) => {
      const [s = 0, o] = Z || [];
      return s - 1 === 0 ? (e?.(o, !1), null) : [s - 1, o];
    });
  };
  return Bl(a, (W, Z) => {
    Z && h(Z), d.value.cache.update(W, (s) => {
      const [o = 0, F] = s || [];
      let N = F;
      process.env.NODE_ENV !== "production" && F && V && (e?.(N, V), N = null);
      const Q = N || n();
      return [o + 1, Q];
    }), U.value = d.value.cache.get(a.value)[1];
  }, {
    immediate: !0
  }), Wt(() => {
    h(a.value);
  }), U;
}
function xt() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function tn(l, t) {
  return l && l.contains ? l.contains(t) : !1;
}
const us = "data-vc-order", vo = "vc-util-key", Ja = /* @__PURE__ */ new Map();
function e0() {
  let {
    mark: l
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return l ? l.startsWith("data-") ? l : `data-${l}` : vo;
}
function Jd(l) {
  return l.attachTo ? l.attachTo : document.querySelector("head") || document.body;
}
function fo(l) {
  return l === "queue" ? "prependQueue" : l ? "prepend" : "append";
}
function d0(l) {
  return Array.from((Ja.get(l) || l).children).filter((t) => t.tagName === "STYLE");
}
function a0(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!xt())
    return null;
  const {
    csp: n,
    prepend: e
  } = t, d = document.createElement("style");
  d.setAttribute(us, fo(e)), n?.nonce && (d.nonce = n?.nonce), d.innerHTML = l;
  const a = Jd(t), {
    firstChild: U
  } = a;
  if (e) {
    if (e === "queue") {
      const V = d0(a).filter((h) => ["prepend", "prependQueue"].includes(h.getAttribute(us)));
      if (V.length)
        return a.insertBefore(d, V[V.length - 1].nextSibling), d;
    }
    a.insertBefore(d, U);
  } else
    a.appendChild(d);
  return d;
}
function i0(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = Jd(t);
  return d0(n).find((e) => e.getAttribute(e0(t)) === l);
}
function ad(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = i0(l, t);
  n && Jd(t).removeChild(n);
}
function Ko(l, t) {
  const n = Ja.get(l);
  if (!n || !tn(document, n)) {
    const e = a0("", t), {
      parentNode: d
    } = e;
    Ja.set(l, d), l.removeChild(e);
  }
}
function id(l, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var e, d, a;
  const U = Jd(n);
  Ko(U, n);
  const V = i0(t, n);
  if (V)
    return !((e = n.csp) === null || e === void 0) && e.nonce && V.nonce !== ((d = n.csp) === null || d === void 0 ? void 0 : d.nonce) && (V.nonce = (a = n.csp) === null || a === void 0 ? void 0 : a.nonce), V.innerHTML !== l && (V.innerHTML = l), V;
  const h = a0(l, n);
  return h.setAttribute(e0(n), t), h;
}
function Ho(l, t) {
  if (l.length !== t.length)
    return !1;
  for (let n = 0; n < l.length; n++)
    if (l[n] !== t[n])
      return !1;
  return !0;
}
class fn {
  constructor() {
    this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, e = {
      map: this.cache
    };
    return t.forEach((d) => {
      var a;
      e ? e = (a = e?.map) === null || a === void 0 ? void 0 : a.get(d) : e = void 0;
    }), e?.value && n && (e.value[1] = this.cacheCallTimes++), e?.value;
  }
  get(t) {
    var n;
    return (n = this.internalGet(t, !0)) === null || n === void 0 ? void 0 : n[0];
  }
  has(t) {
    return !!this.internalGet(t);
  }
  set(t, n) {
    if (!this.has(t)) {
      if (this.size() + 1 > fn.MAX_CACHE_SIZE + fn.MAX_CACHE_OFFSET) {
        const [d] = this.keys.reduce((a, U) => {
          const [, V] = a;
          return this.internalGet(U)[1] < V ? [U, this.internalGet(U)[1]] : a;
        }, [this.keys[0], this.cacheCallTimes]);
        this.delete(d);
      }
      this.keys.push(t);
    }
    let e = this.cache;
    t.forEach((d, a) => {
      if (a === t.length - 1)
        e.set(d, {
          value: [n, this.cacheCallTimes++]
        });
      else {
        const U = e.get(d);
        U ? U.map || (U.map = /* @__PURE__ */ new Map()) : e.set(d, {
          map: /* @__PURE__ */ new Map()
        }), e = e.get(d).map;
      }
    });
  }
  deleteByPath(t, n) {
    var e;
    const d = t.get(n[0]);
    if (n.length === 1)
      return d.map ? t.set(n[0], {
        map: d.map
      }) : t.delete(n[0]), (e = d.value) === null || e === void 0 ? void 0 : e[0];
    const a = this.deleteByPath(d.map, n.slice(1));
    return (!d.map || d.map.size === 0) && !d.value && t.delete(n[0]), a;
  }
  delete(t) {
    if (this.has(t))
      return this.keys = this.keys.filter((n) => !Ho(n, t)), this.deleteByPath(this.cache, t);
  }
}
fn.MAX_CACHE_SIZE = 20;
fn.MAX_CACHE_OFFSET = 5;
let Xa = {};
function ii(l, t) {
  process.env.NODE_ENV !== "production" && !l && console !== void 0 && console.error(`Warning: ${t}`);
}
function Po(l, t) {
  process.env.NODE_ENV !== "production" && !l && console !== void 0 && console.warn(`Note: ${t}`);
}
function Ao() {
  Xa = {};
}
function s0(l, t, n) {
  !t && !Xa[n] && (l(!1, n), Xa[n] = !0);
}
function Bt(l, t) {
  s0(ii, l, t);
}
function rs(l, t) {
  s0(Po, l, t);
}
function $o() {
}
let Je = $o;
process.env.NODE_ENV !== "production" && (Je = (l, t, n) => {
  Bt(l, `[ant-design-vue: ${t}] ${n}`), process.env.NODE_ENV === "test" && Ao();
});
let Ms = 0;
class c0 {
  constructor(t) {
    this.derivatives = Array.isArray(t) ? t : [t], this.id = Ms, t.length === 0 && Je(t.length > 0, "[Ant Design Vue CSS-in-JS] Theme should have at least one derivative function."), Ms += 1;
  }
  getDerivativeToken(t) {
    return this.derivatives.reduce((n, e) => e(t, n), void 0);
  }
}
const qd = new fn();
function qo(l) {
  const t = Array.isArray(l) ? l : [l];
  return qd.has(t) || qd.set(t, new c0(t)), qd.get(t);
}
const ps = /* @__PURE__ */ new WeakMap();
function sd(l) {
  let t = ps.get(l) || "";
  return t || (Object.keys(l).forEach((n) => {
    const e = l[n];
    t += n, e instanceof c0 ? t += e.id : e && typeof e == "object" ? t += sd(e) : t += e;
  }), ps.set(l, t)), t;
}
function _o(l, t) {
  return di(`${t}_${sd(l)}`);
}
const se = `random-${Date.now()}-${Math.random()}`.replace(/\./g, ""), U0 = "_bAmBoO_";
function lV(l, t, n) {
  var e, d;
  if (xt()) {
    id(l, se);
    const a = document.createElement("div");
    a.style.position = "fixed", a.style.left = "0", a.style.top = "0", t?.(a), document.body.appendChild(a), process.env.NODE_ENV !== "production" && (a.innerHTML = "Test", a.style.zIndex = "9999999");
    const U = n ? n(a) : (e = getComputedStyle(a).content) === null || e === void 0 ? void 0 : e.includes(U0);
    return (d = a.parentNode) === null || d === void 0 || d.removeChild(a), ad(se), U;
  }
  return !1;
}
let _d;
function tV() {
  return _d === void 0 && (_d = lV(`@layer ${se} { .${se} { content: "${U0}"!important; } }`, (l) => {
    l.className = se;
  })), _d;
}
const Ss = {}, nV = process.env.NODE_ENV === "production", eV = process.env.NODE_ENV === "prerender", dV = !nV && !eV ? "css-dev-only-do-not-override" : "css", hn = /* @__PURE__ */ new Map();
function aV(l) {
  hn.set(l, (hn.get(l) || 0) + 1);
}
function iV(l, t) {
  typeof document < "u" && document.querySelectorAll(`style[${_U}="${l}"]`).forEach((e) => {
    var d;
    e[gn] === t && ((d = e.parentNode) === null || d === void 0 || d.removeChild(e));
  });
}
const sV = 0;
function cV(l, t) {
  hn.set(l, (hn.get(l) || 0) - 1);
  const n = Array.from(hn.keys()), e = n.filter((d) => (hn.get(d) || 0) <= 0);
  n.length - e.length > sV && e.forEach((d) => {
    iV(d, t), hn.delete(d);
  });
}
const UV = (l, t, n, e) => {
  const d = n.getDerivativeToken(l);
  let a = j(j({}, d), t);
  return e && (a = e(a)), a;
};
function ZV(l, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ml({});
  const e = Gd(), d = Zl(() => j({}, ...t.value)), a = Zl(() => sd(d.value)), U = Zl(() => sd(n.value.override || Ss));
  return n0("token", Zl(() => [n.value.salt || "", l.value.id, a.value, U.value]), () => {
    const {
      salt: h = "",
      override: W = Ss,
      formatToken: Z,
      getComputedToken: s
    } = n.value, o = s ? s(d.value, W, l.value) : UV(d.value, W, l.value, Z), F = _o(o, h);
    o._tokenKey = F, aV(F);
    const N = `${dV}-${di(F)}`;
    return o._hashId = N, [o, N];
  }, (h) => {
    var W;
    cV(h[0]._tokenKey, (W = e.value) === null || W === void 0 ? void 0 : W.cache.instanceId);
  });
}
var la = GF();
function Z0(l, t) {
  const {
    path: n,
    parentSelectors: e
  } = t;
  Bt(!1, `[Ant Design Vue CSS-in-JS] ${n ? `Error in '${n}': ` : ""}${l}${e.length ? ` Selector info: ${e.join(" -> ")}` : ""}`);
}
const FV = (l, t, n) => {
  if (l === "content") {
    const e = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    (typeof t != "string" || ["normal", "none", "initial", "inherit", "unset"].indexOf(t) === -1 && !e.test(t) && (t.charAt(0) !== t.charAt(t.length - 1) || t.charAt(0) !== '"' && t.charAt(0) !== "'")) && Z0(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${t}"'\`.`, n);
  }
}, oV = (l, t, n) => {
  l === "animation" && n.hashId && t !== "none" && Z0(`You seem to be using hashed animation '${t}', in which case 'animationName' with Keyframe as value is recommended.`, n);
}, Ts = "data-ant-cssinjs-cache-path", VV = "_FILE_STYLE__";
let mn, F0 = !0;
function QV() {
  var l;
  if (!mn && (mn = {}, xt())) {
    const t = document.createElement("div");
    t.className = Ts, t.style.position = "fixed", t.style.visibility = "hidden", t.style.top = "-9999px", document.body.appendChild(t);
    let n = getComputedStyle(t).content || "";
    n = n.replace(/^"/, "").replace(/"$/, ""), n.split(";").forEach((d) => {
      const [a, U] = d.split(":");
      mn[a] = U;
    });
    const e = document.querySelector(`style[${Ts}]`);
    e && (F0 = !1, (l = e.parentNode) === null || l === void 0 || l.removeChild(e)), document.body.removeChild(t);
  }
}
function WV(l) {
  return QV(), !!mn[l];
}
function hV(l) {
  const t = mn[l];
  let n = null;
  if (t && xt())
    if (F0)
      n = VV;
    else {
      const e = document.querySelector(`style[${bn}="${mn[l]}"]`);
      e ? n = e.innerHTML : delete mn[l];
    }
  return [n, t];
}
const Gs = xt(), o0 = "_skip_check_", V0 = "_multi_value_";
function Js(l) {
  return la.serialize(la.compile(l), la.stringify).replace(/\{%%%\:[^;];}/g, ";");
}
function RV(l) {
  return typeof l == "object" && l && (o0 in l || V0 in l);
}
function NV(l, t, n) {
  if (!t)
    return l;
  const e = `.${t}`, d = n === "low" ? `:where(${e})` : e;
  return l.split(",").map((U) => {
    var V;
    const h = U.trim().split(/\s+/);
    let W = h[0] || "";
    const Z = ((V = W.match(/^\w+/)) === null || V === void 0 ? void 0 : V[0]) || "";
    return W = `${Z}${d}${W.slice(Z.length)}`, [W, ...h.slice(1)].join(" ");
  }).join(",");
}
const Ya = /* @__PURE__ */ new Set();
process.env.NODE_ENV;
const ya = function(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    root: n,
    injectHash: e,
    parentSelectors: d
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  };
  const {
    hashId: a,
    layer: U,
    path: V,
    hashPriority: h,
    transformers: W = [],
    linters: Z = []
  } = t;
  let s = "", o = {};
  function F(u) {
    const i = u.getName(a);
    if (!o[i]) {
      const [c] = ya(u.style, t, {
        root: !1,
        parentSelectors: d
      });
      o[i] = `@keyframes ${u.getName(a)}${c}`;
    }
  }
  function N(u) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return u.forEach((c) => {
      Array.isArray(c) ? N(c, i) : c && i.push(c);
    }), i;
  }
  if (N(Array.isArray(l) ? l : [l]).forEach((u) => {
    const i = typeof u == "string" && !n ? {} : u;
    if (typeof i == "string")
      s += `${i}
`;
    else if (i._keyframe)
      F(i);
    else {
      const c = W.reduce((R, m) => {
        var M;
        return ((M = m?.visit) === null || M === void 0 ? void 0 : M.call(m, R)) || R;
      }, i);
      Object.keys(c).forEach((R) => {
        var m;
        const M = c[R];
        if (typeof M == "object" && M && (R !== "animationName" || !M._keyframe) && !RV(M)) {
          let S = !1, p = R.trim(), Y = !1;
          (n || e) && a ? p.startsWith("@") ? S = !0 : p = NV(R, a, h) : n && !a && (p === "&" || p === "") && (p = "", Y = !0);
          const [k, L] = ya(M, t, {
            root: Y,
            injectHash: S,
            parentSelectors: [...d, p]
          });
          o = j(j({}, o), L), s += `${p}${k}`;
        } else {
          let S = function(Y, k) {
            process.env.NODE_ENV !== "production" && (typeof M != "object" || !M?.[o0]) && [FV, oV, ...Z].forEach((f) => f(Y, k, {
              path: V,
              hashId: a,
              parentSelectors: d
            }));
            const L = Y.replace(/[A-Z]/g, (f) => `-${f.toLowerCase()}`);
            let z = k;
            !TF[Y] && typeof z == "number" && z !== 0 && (z = `${z}px`), Y === "animationName" && k?._keyframe && (F(k), z = k.getName(a)), s += `${L}:${z};`;
          };
          const p = (m = M?.value) !== null && m !== void 0 ? m : M;
          typeof M == "object" && M?.[V0] && Array.isArray(p) ? p.forEach((Y) => {
            S(R, Y);
          }) : S(R, p);
        }
      });
    }
  }), !n)
    s = `{${s}}`;
  else if (U && tV()) {
    const u = U.split(",");
    s = `@layer ${u[u.length - 1].trim()} {${s}}`, u.length > 1 && (s = `@layer ${U}{%%%:%}${s}`);
  }
  return [s, o];
};
function bV(l, t) {
  return di(`${l.join("%")}${t}`);
}
function Xs(l, t) {
  const n = Gd(), e = Zl(() => l.value.token._tokenKey), d = Zl(() => [e.value, ...l.value.path]);
  let a = Gs;
  return process.env.NODE_ENV !== "production" && n.value.mock !== void 0 && (a = n.value.mock === "client"), n0(
    "style",
    d,
    // Create cache if needed
    () => {
      const {
        path: U,
        hashId: V,
        layer: h,
        nonce: W,
        clientOnly: Z,
        order: s = 0
      } = l.value, o = d.value.join("|");
      if (WV(o)) {
        const [p, Y] = hV(o);
        if (p)
          return [p, e.value, Y, {}, Z, s];
      }
      const F = t(), {
        hashPriority: N,
        container: Q,
        transformers: u,
        linters: i,
        cache: c
      } = n.value, [R, m] = ya(F, {
        hashId: V,
        hashPriority: N,
        layer: h,
        path: U.join("-"),
        transformers: u,
        linters: i
      }), M = Js(R), S = bV(d.value, M);
      if (a) {
        const p = {
          mark: bn,
          prepend: "queue",
          attachTo: Q,
          priority: s
        }, Y = typeof W == "function" ? W() : W;
        Y && (p.csp = {
          nonce: Y
        });
        const k = id(M, S, p);
        k[gn] = c.instanceId, k.setAttribute(_U, e.value), process.env.NODE_ENV !== "production" && k.setAttribute(Co, d.value.join("|")), Object.keys(m).forEach((L) => {
          Ya.has(L) || (Ya.add(L), id(Js(m[L]), `_effect-${L}`, {
            mark: bn,
            prepend: "queue",
            attachTo: Q
          }));
        });
      }
      return [M, e.value, S, m, Z, s];
    },
    // Remove cache if no need
    (U, V) => {
      let [, , h] = U;
      (V || n.value.autoClear) && Gs && ad(h, {
        mark: bn
      });
    }
  ), (U) => U;
}
class xl {
  constructor(t, n) {
    this._keyframe = !0, this.name = t, this.style = n;
  }
  getName() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return t ? `${t}-${this.name}` : this.name;
  }
}
const mV = "4.2.1", cd = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"], uV = (l) => {
  const {
    controlHeight: t
  } = l;
  return {
    controlHeightSM: t * 0.75,
    controlHeightXS: t * 0.5,
    controlHeightLG: t * 1.25
  };
};
function rV(l) {
  const {
    sizeUnit: t,
    sizeStep: n
  } = l;
  return {
    sizeXXL: t * (n + 8),
    sizeXL: t * (n + 4),
    sizeLG: t * (n + 2),
    sizeMD: t * (n + 1),
    sizeMS: t * n,
    size: t * n,
    sizeSM: t * (n - 1),
    sizeXS: t * (n - 2),
    sizeXXS: t * (n - 3)
    // 4
  };
}
const Q0 = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, si = j(j({}, Q0), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1
});
function MV(l, t) {
  let {
    generateColorPalettes: n,
    generateNeutralColorPalettes: e
  } = t;
  const {
    colorSuccess: d,
    colorWarning: a,
    colorError: U,
    colorInfo: V,
    colorPrimary: h,
    colorBgBase: W,
    colorTextBase: Z
  } = l, s = n(h), o = n(d), F = n(a), N = n(U), Q = n(V), u = e(W, Z);
  return j(j({}, u), {
    colorPrimaryBg: s[1],
    colorPrimaryBgHover: s[2],
    colorPrimaryBorder: s[3],
    colorPrimaryBorderHover: s[4],
    colorPrimaryHover: s[5],
    colorPrimary: s[6],
    colorPrimaryActive: s[7],
    colorPrimaryTextHover: s[8],
    colorPrimaryText: s[9],
    colorPrimaryTextActive: s[10],
    colorSuccessBg: o[1],
    colorSuccessBgHover: o[2],
    colorSuccessBorder: o[3],
    colorSuccessBorderHover: o[4],
    colorSuccessHover: o[4],
    colorSuccess: o[6],
    colorSuccessActive: o[7],
    colorSuccessTextHover: o[8],
    colorSuccessText: o[9],
    colorSuccessTextActive: o[10],
    colorErrorBg: N[1],
    colorErrorBgHover: N[2],
    colorErrorBorder: N[3],
    colorErrorBorderHover: N[4],
    colorErrorHover: N[5],
    colorError: N[6],
    colorErrorActive: N[7],
    colorErrorTextHover: N[8],
    colorErrorText: N[9],
    colorErrorTextActive: N[10],
    colorWarningBg: F[1],
    colorWarningBgHover: F[2],
    colorWarningBorder: F[3],
    colorWarningBorderHover: F[4],
    colorWarningHover: F[4],
    colorWarning: F[6],
    colorWarningActive: F[7],
    colorWarningTextHover: F[8],
    colorWarningText: F[9],
    colorWarningTextActive: F[10],
    colorInfoBg: Q[1],
    colorInfoBgHover: Q[2],
    colorInfoBorder: Q[3],
    colorInfoBorderHover: Q[4],
    colorInfoHover: Q[4],
    colorInfo: Q[6],
    colorInfoActive: Q[7],
    colorInfoTextHover: Q[8],
    colorInfoText: Q[9],
    colorInfoTextActive: Q[10],
    colorBgMask: new et("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const pV = (l) => {
  let t = l, n = l, e = l, d = l;
  return l < 6 && l >= 5 ? t = l + 1 : l < 16 && l >= 6 ? t = l + 2 : l >= 16 && (t = 16), l < 7 && l >= 5 ? n = 4 : l < 8 && l >= 7 ? n = 5 : l < 14 && l >= 8 ? n = 6 : l < 16 && l >= 14 ? n = 7 : l >= 16 && (n = 8), l < 6 && l >= 2 ? e = 1 : l >= 6 && (e = 2), l > 4 && l < 8 ? d = 4 : l >= 8 && (d = 6), {
    borderRadius: l > 16 ? 16 : l,
    borderRadiusXS: e,
    borderRadiusSM: n,
    borderRadiusLG: t,
    borderRadiusOuter: d
  };
};
function SV(l) {
  const {
    motionUnit: t,
    motionBase: n,
    borderRadius: e,
    lineWidth: d
  } = l;
  return j({
    // motion
    motionDurationFast: `${(n + t).toFixed(1)}s`,
    motionDurationMid: `${(n + t * 2).toFixed(1)}s`,
    motionDurationSlow: `${(n + t * 3).toFixed(1)}s`,
    // line
    lineWidthBold: d + 1
  }, pV(e));
}
const Ot = (l, t) => new et(l).setAlpha(t).toRgbString(), le = (l, t) => new et(l).darken(t).toHexString(), TV = (l) => {
  const t = Qe(l);
  return {
    1: t[0],
    2: t[1],
    3: t[2],
    4: t[3],
    5: t[4],
    6: t[5],
    7: t[6],
    8: t[4],
    9: t[5],
    10: t[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, GV = (l, t) => {
  const n = l || "#fff", e = t || "#000";
  return {
    colorBgBase: n,
    colorTextBase: e,
    colorText: Ot(e, 0.88),
    colorTextSecondary: Ot(e, 0.65),
    colorTextTertiary: Ot(e, 0.45),
    colorTextQuaternary: Ot(e, 0.25),
    colorFill: Ot(e, 0.15),
    colorFillSecondary: Ot(e, 0.06),
    colorFillTertiary: Ot(e, 0.04),
    colorFillQuaternary: Ot(e, 0.02),
    colorBgLayout: le(n, 4),
    colorBgContainer: le(n, 0),
    colorBgElevated: le(n, 0),
    colorBgSpotlight: Ot(e, 0.85),
    colorBorder: le(n, 15),
    colorBorderSecondary: le(n, 6)
  };
};
function JV(l) {
  const t = new Array(10).fill(null).map((n, e) => {
    const d = e - 1, a = l * Math.pow(2.71828, d / 5), U = e > 1 ? Math.floor(a) : Math.ceil(a);
    return Math.floor(U / 2) * 2;
  });
  return t[1] = l, t.map((n) => {
    const e = n + 8;
    return {
      size: n,
      lineHeight: e / n
    };
  });
}
const XV = (l) => {
  const t = JV(l), n = t.map((d) => d.size), e = t.map((d) => d.lineHeight);
  return {
    fontSizeSM: n[0],
    fontSize: n[1],
    fontSizeLG: n[2],
    fontSizeXL: n[3],
    fontSizeHeading1: n[6],
    fontSizeHeading2: n[5],
    fontSizeHeading3: n[4],
    fontSizeHeading4: n[3],
    fontSizeHeading5: n[2],
    lineHeight: e[1],
    lineHeightLG: e[2],
    lineHeightSM: e[0],
    lineHeightHeading1: e[6],
    lineHeightHeading2: e[5],
    lineHeightHeading3: e[4],
    lineHeightHeading4: e[3],
    lineHeightHeading5: e[2]
  };
};
function YV(l) {
  const t = Object.keys(Q0).map((n) => {
    const e = Qe(l[n]);
    return new Array(10).fill(1).reduce((d, a, U) => (d[`${n}-${U + 1}`] = e[U], d), {});
  }).reduce((n, e) => (n = j(j({}, n), e), n), {});
  return j(j(j(j(j(j(j({}, l), t), MV(l, {
    generateColorPalettes: TV,
    generateNeutralColorPalettes: GV
  })), XV(l.fontSize)), rV(l)), uV(l)), SV(l));
}
function ta(l) {
  return l >= 0 && l <= 255;
}
function Ce(l, t) {
  const {
    r: n,
    g: e,
    b: d,
    a
  } = new et(l).toRgb();
  if (a < 1)
    return l;
  const {
    r: U,
    g: V,
    b: h
  } = new et(t).toRgb();
  for (let W = 0.01; W <= 1; W += 0.01) {
    const Z = Math.round((n - U * (1 - W)) / W), s = Math.round((e - V * (1 - W)) / W), o = Math.round((d - h * (1 - W)) / W);
    if (ta(Z) && ta(s) && ta(o))
      return new et({
        r: Z,
        g: s,
        b: o,
        a: Math.round(W * 100) / 100
      }).toRgbString();
  }
  return new et({
    r: n,
    g: e,
    b: d,
    a: 1
  }).toRgbString();
}
var yV = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
function BV(l) {
  const {
    override: t
  } = l, n = yV(l, ["override"]), e = j({}, t);
  Object.keys(si).forEach((F) => {
    delete e[F];
  });
  const d = j(j({}, n), e), a = 480, U = 576, V = 768, h = 992, W = 1200, Z = 1600, s = 2e3;
  return j(j(j({}, d), {
    colorLink: d.colorInfoText,
    colorLinkHover: d.colorInfoHover,
    colorLinkActive: d.colorInfoActive,
    // ============== Background ============== //
    colorFillContent: d.colorFillSecondary,
    colorFillContentHover: d.colorFill,
    colorFillAlter: d.colorFillQuaternary,
    colorBgContainerDisabled: d.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: d.colorBgContainer,
    colorSplit: Ce(d.colorBorderSecondary, d.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: d.colorTextQuaternary,
    colorTextDisabled: d.colorTextQuaternary,
    colorTextHeading: d.colorText,
    colorTextLabel: d.colorTextSecondary,
    colorTextDescription: d.colorTextTertiary,
    colorTextLightSolid: d.colorWhite,
    colorHighlight: d.colorError,
    colorBgTextHover: d.colorFillSecondary,
    colorBgTextActive: d.colorFill,
    colorIcon: d.colorTextTertiary,
    colorIconHover: d.colorText,
    colorErrorOutline: Ce(d.colorErrorBg, d.colorBgContainer),
    colorWarningOutline: Ce(d.colorWarningBg, d.colorBgContainer),
    // Font
    fontSizeIcon: d.fontSizeSM,
    // Control
    lineWidth: d.lineWidth,
    controlOutlineWidth: d.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: d.controlHeight / 2,
    controlItemBgHover: d.colorFillTertiary,
    controlItemBgActive: d.colorPrimaryBg,
    controlItemBgActiveHover: d.colorPrimaryBgHover,
    controlItemBgActiveDisabled: d.colorFill,
    controlTmpOutline: d.colorFillQuaternary,
    controlOutline: Ce(d.colorPrimaryBg, d.colorBgContainer),
    lineType: d.lineType,
    borderRadius: d.borderRadius,
    borderRadiusXS: d.borderRadiusXS,
    borderRadiusSM: d.borderRadiusSM,
    borderRadiusLG: d.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: d.sizeXXS,
    paddingXS: d.sizeXS,
    paddingSM: d.sizeSM,
    padding: d.size,
    paddingMD: d.sizeMD,
    paddingLG: d.sizeLG,
    paddingXL: d.sizeXL,
    paddingContentHorizontalLG: d.sizeLG,
    paddingContentVerticalLG: d.sizeMS,
    paddingContentHorizontal: d.sizeMS,
    paddingContentVertical: d.sizeSM,
    paddingContentHorizontalSM: d.size,
    paddingContentVerticalSM: d.sizeXS,
    marginXXS: d.sizeXXS,
    marginXS: d.sizeXS,
    marginSM: d.sizeSM,
    margin: d.size,
    marginMD: d.sizeMD,
    marginLG: d.sizeLG,
    marginXL: d.sizeXL,
    marginXXL: d.sizeXXL,
    boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: a,
    screenXSMin: a,
    screenXSMax: U - 1,
    screenSM: U,
    screenSMMin: U,
    screenSMMax: V - 1,
    screenMD: V,
    screenMDMin: V,
    screenMDMax: h - 1,
    screenLG: h,
    screenLGMin: h,
    screenLGMax: W - 1,
    screenXL: W,
    screenXLMin: W,
    screenXLMax: Z - 1,
    screenXXL: Z,
    screenXXLMin: Z,
    screenXXLMax: s - 1,
    screenXXXL: s,
    screenXXXLMin: s,
    // FIXME: component box-shadow, should be removed
    boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
    boxShadowCard: `
      0 1px 2px -2px ${new et("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new et("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new et("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), e);
}
const zV = (l, t, n, e, d) => {
  const a = l / 2, U = 0, V = a, h = n * 1 / Math.sqrt(2), W = a - n * (1 - 1 / Math.sqrt(2)), Z = a - t * (1 / Math.sqrt(2)), s = n * (Math.sqrt(2) - 1) + t * (1 / Math.sqrt(2)), o = 2 * a - Z, F = s, N = 2 * a - h, Q = W, u = 2 * a - U, i = V, c = a * Math.sqrt(2) + n * (Math.sqrt(2) - 2), R = n * (Math.sqrt(2) - 1);
  return {
    pointerEvents: "none",
    width: l,
    height: l,
    overflow: "hidden",
    "&::after": {
      content: '""',
      position: "absolute",
      width: c,
      height: c,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${t}px 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow: d,
      zIndex: 0,
      background: "transparent"
    },
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: l,
      height: l / 2,
      background: e,
      clipPath: {
        _multi_value_: !0,
        value: [`polygon(${R}px 100%, 50% ${R}px, ${2 * a - R}px 100%, ${R}px 100%)`, `path('M ${U} ${V} A ${n} ${n} 0 0 0 ${h} ${W} L ${Z} ${s} A ${t} ${t} 0 0 1 ${o} ${F} L ${N} ${Q} A ${n} ${n} 0 0 0 ${u} ${i} Z')`]
      },
      content: '""'
    }
  };
};
function LV(l, t) {
  return cd.reduce((n, e) => {
    const d = l[`${e}-1`], a = l[`${e}-3`], U = l[`${e}-6`], V = l[`${e}-7`];
    return j(j({}, n), t(e, {
      lightColor: d,
      lightBorderColor: a,
      darkColor: U,
      textColor: V
    }));
  }, {});
}
const Ud = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, sn = (l) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: l.colorText,
  fontSize: l.fontSize,
  // font-variant: @font-variant-base;
  lineHeight: l.lineHeight,
  listStyle: "none",
  // font-feature-settings: @font-feature-settings-base;
  fontFamily: l.fontFamily
}), W0 = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), kV = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), IV = (l) => ({
  a: {
    color: l.colorLink,
    textDecoration: l.linkDecoration,
    backgroundColor: "transparent",
    outline: "none",
    cursor: "pointer",
    transition: `color ${l.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    "&:hover": {
      color: l.colorLinkHover
    },
    "&:active": {
      color: l.colorLinkActive
    },
    "&:active,\n  &:hover": {
      textDecoration: l.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: l.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: l.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), DV = (l, t) => {
  const {
    fontFamily: n,
    fontSize: e
  } = l, d = `[class^="${t}"], [class*=" ${t}"]`;
  return {
    [d]: {
      fontFamily: n,
      fontSize: e,
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      },
      [d]: {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      }
    }
  };
}, Ba = (l) => ({
  outline: `${l.lineWidthBold}px solid ${l.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), h0 = (l) => ({
  "&:focus-visible": j({}, Ba(l))
});
function $t(l, t, n) {
  return (e) => {
    const d = Zl(() => e?.value), [a, U, V] = Xe(), {
      getPrefixCls: h,
      iconPrefixCls: W
    } = Bo(), Z = Zl(() => h()), s = Zl(() => ({
      theme: a.value,
      token: U.value,
      hashId: V.value,
      path: ["Shared", Z.value]
    }));
    Xs(s, () => [{
      // Link
      "&": IV(U.value)
    }]);
    const o = Zl(() => ({
      theme: a.value,
      token: U.value,
      hashId: V.value,
      path: [l, d.value, W.value]
    }));
    return [Xs(o, () => {
      const {
        token: F,
        flush: N
      } = wV(U.value), Q = typeof n == "function" ? n(F) : n, u = j(j({}, Q), U.value[l]), i = `.${d.value}`, c = tt(F, {
        componentCls: i,
        prefixCls: d.value,
        iconCls: `.${W.value}`,
        antCls: `.${Z.value}`
      }, u), R = t(c, {
        hashId: V.value,
        prefixCls: d.value,
        rootPrefixCls: Z.value,
        iconPrefixCls: W.value,
        overrideComponentToken: U.value[l]
      });
      return N(l, u), [DV(U.value, d.value), R];
    }), V];
  };
}
const R0 = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u";
let za = !0;
function tt() {
  for (var l = arguments.length, t = new Array(l), n = 0; n < l; n++)
    t[n] = arguments[n];
  if (!R0)
    return j({}, ...t);
  za = !1;
  const e = {};
  return t.forEach((d) => {
    Object.keys(d).forEach((U) => {
      Object.defineProperty(e, U, {
        configurable: !0,
        enumerable: !0,
        get: () => d[U]
      });
    });
  }), za = !0, e;
}
function CV() {
}
function wV(l) {
  let t, n = l, e = CV;
  return R0 && (t = /* @__PURE__ */ new Set(), n = new Proxy(l, {
    get(d, a) {
      return za && t.add(a), d[a];
    }
  }), e = (d, a) => {
    Array.from(t);
  }), {
    token: n,
    keys: t,
    flush: e
  };
}
const EV = qo(YV), xV = {
  token: si,
  hashed: !0
}, N0 = Symbol("DesignTokenContext"), La = bl(), gV = (l) => {
  nt(N0, l), Bl(l, () => {
    La.value = at(l), hF(La);
  }, {
    immediate: !0,
    deep: !0
  });
};
pl({
  props: {
    value: dn()
  },
  setup(l, t) {
    let {
      slots: n
    } = t;
    return gV(Zl(() => l.value)), () => {
      var e;
      return (e = n.default) === null || e === void 0 ? void 0 : e.call(n);
    };
  }
});
function Xe() {
  const l = fl(N0, Zl(() => La.value || xV)), t = Zl(() => `${mV}-${l.value.hashed || ""}`), n = Zl(() => l.value.theme || EV), e = ZV(n, Zl(() => [si, l.value.token]), Zl(() => ({
    salt: t.value,
    override: j({
      override: l.value.token
    }, l.value.components),
    formatToken: BV
  })));
  return [n, Zl(() => e.value[0]), Zl(() => l.value.hashed ? e.value[1] : "")];
}
const b0 = pl({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, l] = Xe(), t = Zl(() => new et(l.value.colorBgBase).toHsl().l < 0.5 ? {
      opacity: 0.65
    } : {});
    return () => H("svg", {
      style: t.value,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    }, [H("g", {
      fill: "none",
      "fill-rule": "evenodd"
    }, [H("g", {
      transform: "translate(24 31.67)"
    }, [H("ellipse", {
      "fill-opacity": ".8",
      fill: "#F5F5F7",
      cx: "67.797",
      cy: "106.89",
      rx: "67.797",
      ry: "12.668"
    }, null), H("path", {
      d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      fill: "#AEB8C2"
    }, null), H("path", {
      d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      fill: "url(#linearGradient-1)",
      transform: "translate(13.56)"
    }, null), H("path", {
      d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      fill: "#F5F5F7"
    }, null), H("path", {
      d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      fill: "#DCE0E6"
    }, null)]), H("path", {
      d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      fill: "#DCE0E6"
    }, null), H("g", {
      transform: "translate(149.65 15.383)",
      fill: "#FFF"
    }, [H("ellipse", {
      cx: "20.654",
      cy: "3.167",
      rx: "2.849",
      ry: "2.815"
    }, null), H("path", {
      d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }, null)])])]);
  }
});
b0.PRESENTED_IMAGE_DEFAULT = !0;
const m0 = pl({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, l] = Xe(), t = Zl(() => {
      const {
        colorFill: n,
        colorFillTertiary: e,
        colorFillQuaternary: d,
        colorBgContainer: a
      } = l.value;
      return {
        borderColor: new et(n).onBackground(a).toHexString(),
        shadowColor: new et(e).onBackground(a).toHexString(),
        contentColor: new et(d).onBackground(a).toHexString()
      };
    });
    return () => H("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg"
    }, [H("g", {
      transform: "translate(0 1)",
      fill: "none",
      "fill-rule": "evenodd"
    }, [H("ellipse", {
      fill: t.value.shadowColor,
      cx: "32",
      cy: "33",
      rx: "32",
      ry: "7"
    }, null), H("g", {
      "fill-rule": "nonzero",
      stroke: t.value.borderColor
    }, [H("path", {
      d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }, null), H("path", {
      d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      fill: t.value.contentColor
    }, null)])])]);
  }
});
m0.PRESENTED_IMAGE_SIMPLE = !0;
const jV = (l) => {
  const {
    componentCls: t,
    margin: n,
    marginXS: e,
    marginXL: d,
    fontSize: a,
    lineHeight: U
  } = l;
  return {
    [t]: {
      marginInline: e,
      fontSize: a,
      lineHeight: U,
      textAlign: "center",
      // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${t}-image`]: {
        height: l.emptyImgHeight,
        marginBottom: e,
        opacity: l.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          height: "100%",
          margin: "auto"
        }
      },
      // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${t}-footer`]: {
        marginTop: n
      },
      "&-normal": {
        marginBlock: d,
        color: l.colorTextDisabled,
        [`${t}-image`]: {
          height: l.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: e,
        color: l.colorTextDisabled,
        [`${t}-image`]: {
          height: l.emptyImgHeightSM
        }
      }
    }
  };
}, OV = $t("Empty", (l) => {
  const {
    componentCls: t,
    controlHeightLG: n
  } = l, e = tt(l, {
    emptyImgCls: `${t}-img`,
    emptyImgHeight: n * 2.5,
    emptyImgHeightMD: n,
    emptyImgHeightSM: n * 0.875
  });
  return [jV(e)];
});
var vV = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const u0 = H(b0, null, null), r0 = H(m0, null, null), fV = () => ({
  prefixCls: String,
  imageStyle: dn(),
  image: kt(),
  description: kt()
}), ci = pl({
  name: "AEmpty",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: fV(),
  setup(l, t) {
    let {
      slots: n = {},
      attrs: e
    } = t;
    const {
      direction: d,
      prefixCls: a
    } = ht("empty", l), [U, V] = OV(a);
    return () => {
      var h, W;
      const Z = a.value, s = j(j({}, l), e), {
        image: o = ((h = n.image) === null || h === void 0 ? void 0 : h.call(n)) || u0,
        description: F = ((W = n.description) === null || W === void 0 ? void 0 : W.call(n)) || void 0,
        imageStyle: N,
        class: Q = ""
      } = s, u = vV(s, ["image", "description", "imageStyle", "class"]);
      return U(H(ko, {
        componentName: "Empty",
        children: (i) => {
          const c = typeof F < "u" ? F : i.description, R = typeof c == "string" ? c : "empty";
          let m = null;
          return typeof o == "string" ? m = H("img", {
            alt: R,
            src: o
          }, null) : m = o, H("div", Ql({
            class: Xl(Z, Q, V.value, {
              [`${Z}-normal`]: o === r0,
              [`${Z}-rtl`]: d.value === "rtl"
            })
          }, u), [H("div", {
            class: `${Z}-image`,
            style: N
          }, [m]), c && H("p", {
            class: `${Z}-description`
          }, [c]), n.default && H("div", {
            class: `${Z}-footer`
          }, [Bn(n.default())])]);
        }
      }, null));
    };
  }
});
ci.PRESENTED_IMAGE_DEFAULT = u0;
ci.PRESENTED_IMAGE_SIMPLE = r0;
const te = Td(ci), M0 = (l) => {
  const {
    prefixCls: t
  } = ht("empty", l);
  return ((e) => {
    switch (e) {
      case "Table":
      case "List":
        return H(te, {
          image: te.PRESENTED_IMAGE_SIMPLE
        }, null);
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return H(te, {
          image: te.PRESENTED_IMAGE_SIMPLE,
          class: `${t.value}-small`
        }, null);
      default:
        return H(te, null, null);
    }
  })(l.componentName);
}, KV = Symbol("SizeContextKey"), HV = () => fl(KV, Ml(void 0)), ht = (l, t) => {
  const n = HV(), e = Ge(), d = fl(PU, j(j({}, AU), {
    renderEmpty: (p) => ua(M0, {
      componentName: p
    })
  })), a = Zl(() => d.getPrefixCls(l, t.prefixCls)), U = Zl(() => {
    var p, Y;
    return (p = t.direction) !== null && p !== void 0 ? p : (Y = d.direction) === null || Y === void 0 ? void 0 : Y.value;
  }), V = Zl(() => {
    var p;
    return (p = t.iconPrefixCls) !== null && p !== void 0 ? p : d.iconPrefixCls.value;
  }), h = Zl(() => d.getPrefixCls()), W = Zl(() => {
    var p;
    return (p = d.autoInsertSpaceInButton) === null || p === void 0 ? void 0 : p.value;
  }), Z = d.renderEmpty, s = d.space, o = d.pageHeader, F = d.form, N = Zl(() => {
    var p, Y;
    return (p = t.getTargetContainer) !== null && p !== void 0 ? p : (Y = d.getTargetContainer) === null || Y === void 0 ? void 0 : Y.value;
  }), Q = Zl(() => {
    var p, Y, k;
    return (Y = (p = t.getContainer) !== null && p !== void 0 ? p : t.getPopupContainer) !== null && Y !== void 0 ? Y : (k = d.getPopupContainer) === null || k === void 0 ? void 0 : k.value;
  }), u = Zl(() => {
    var p, Y;
    return (p = t.dropdownMatchSelectWidth) !== null && p !== void 0 ? p : (Y = d.dropdownMatchSelectWidth) === null || Y === void 0 ? void 0 : Y.value;
  }), i = Zl(() => {
    var p;
    return (t.virtual === void 0 ? ((p = d.virtual) === null || p === void 0 ? void 0 : p.value) !== !1 : t.virtual !== !1) && u.value !== !1;
  }), c = Zl(() => t.size || n.value), R = Zl(() => {
    var p, Y, k;
    return (p = t.autocomplete) !== null && p !== void 0 ? p : (k = (Y = d.input) === null || Y === void 0 ? void 0 : Y.value) === null || k === void 0 ? void 0 : k.autocomplete;
  }), m = Zl(() => {
    var p;
    return (p = t.disabled) !== null && p !== void 0 ? p : e.value;
  }), M = Zl(() => {
    var p;
    return (p = t.csp) !== null && p !== void 0 ? p : d.csp;
  }), S = Zl(() => {
    var p, Y;
    return (p = t.wave) !== null && p !== void 0 ? p : (Y = d.wave) === null || Y === void 0 ? void 0 : Y.value;
  });
  return {
    configProvider: d,
    prefixCls: a,
    direction: U,
    size: c,
    getTargetContainer: N,
    getPopupContainer: Q,
    space: s,
    pageHeader: o,
    form: F,
    autoInsertSpaceInButton: W,
    renderEmpty: Z,
    virtual: i,
    dropdownMatchSelectWidth: u,
    rootPrefixCls: h,
    getPrefixCls: d.getPrefixCls,
    autocomplete: R,
    csp: M,
    iconPrefixCls: V,
    disabled: m,
    select: d.select,
    wave: S
  };
};
function ut(l, t) {
  const n = j({}, l);
  for (let e = 0; e < t.length; e += 1) {
    const d = t[e];
    delete n[d];
  }
  return n;
}
function PV(l, t) {
  for (var n = 0; n < t.length; n++) {
    var e = t[n];
    e.enumerable = e.enumerable || !1, e.configurable = !0, "value" in e && (e.writable = !0), Object.defineProperty(l, e.key, e);
  }
}
function p0(l, t, n) {
  return n && PV(l, n), l;
}
function Ke() {
  return (Ke = Object.assign || function(l) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var e in n)
        Object.prototype.hasOwnProperty.call(n, e) && (l[e] = n[e]);
    }
    return l;
  }).apply(this, arguments);
}
function S0(l, t) {
  l.prototype = Object.create(t.prototype), l.prototype.constructor = l, l.__proto__ = t;
}
function T0(l, t) {
  if (l == null)
    return {};
  var n, e, d = {}, a = Object.keys(l);
  for (e = 0; e < a.length; e++)
    t.indexOf(n = a[e]) >= 0 || (d[n] = l[n]);
  return d;
}
function Ys(l) {
  return ((t = l) != null && typeof t == "object" && Array.isArray(t) === !1) == 1 && Object.prototype.toString.call(l) === "[object Object]";
  var t;
}
var G0 = Object.prototype, J0 = G0.toString, AV = G0.hasOwnProperty, X0 = /^\s*function (\w+)/;
function ys(l) {
  var t, n = (t = l?.type) !== null && t !== void 0 ? t : l;
  if (n) {
    var e = n.toString().match(X0);
    return e ? e[1] : "";
  }
  return "";
}
var Mn = function(l) {
  var t, n;
  return Ys(l) !== !1 && typeof (t = l.constructor) == "function" && Ys(n = t.prototype) !== !1 && n.hasOwnProperty("isPrototypeOf") !== !1;
}, Y0 = function(l) {
  return l;
}, Qt = Y0;
if (process.env.NODE_ENV !== "production") {
  var $V = typeof console < "u";
  Qt = $V ? function(l) {
    console.warn("[VueTypes warn]: " + l);
  } : Y0;
}
var Ne = function(l, t) {
  return AV.call(l, t);
}, qV = Number.isInteger || function(l) {
  return typeof l == "number" && isFinite(l) && Math.floor(l) === l;
}, Kn = Array.isArray || function(l) {
  return J0.call(l) === "[object Array]";
}, Hn = function(l) {
  return J0.call(l) === "[object Function]";
}, Zd = function(l) {
  return Mn(l) && Ne(l, "_vueTypes_name");
}, y0 = function(l) {
  return Mn(l) && (Ne(l, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t) {
    return Ne(l, t);
  }));
};
function Ui(l, t) {
  return Object.defineProperty(l.bind(t), "__original", { value: l });
}
function zn(l, t, n) {
  var e;
  n === void 0 && (n = !1);
  var d = !0, a = "";
  e = Mn(l) ? l : { type: l };
  var U = Zd(e) ? e._vueTypes_name + " - " : "";
  if (y0(e) && e.type !== null) {
    if (e.type === void 0 || e.type === !0 || !e.required && t === void 0)
      return d;
    Kn(e.type) ? (d = e.type.some(function(s) {
      return zn(s, t, !0) === !0;
    }), a = e.type.map(function(s) {
      return ys(s);
    }).join(" or ")) : d = (a = ys(e)) === "Array" ? Kn(t) : a === "Object" ? Mn(t) : a === "String" || a === "Number" || a === "Boolean" || a === "Function" ? function(s) {
      if (s == null)
        return "";
      var o = s.constructor.toString().match(X0);
      return o ? o[1] : "";
    }(t) === a : t instanceof e.type;
  }
  if (!d) {
    var V = U + 'value "' + t + '" should be of type "' + a + '"';
    return n === !1 ? (Qt(V), !1) : V;
  }
  if (Ne(e, "validator") && Hn(e.validator)) {
    var h = Qt, W = [];
    if (Qt = function(s) {
      W.push(s);
    }, d = e.validator(t), Qt = h, !d) {
      var Z = (W.length > 1 ? "* " : "") + W.join(`
* `);
      return W.length = 0, n === !1 ? (Qt(Z), d) : Z;
    }
  }
  return d;
}
function Gt(l, t) {
  var n = Object.defineProperties(t, { _vueTypes_name: { value: l, writable: !0 }, isRequired: { get: function() {
    return this.required = !0, this;
  } }, def: { value: function(d) {
    return d !== void 0 || this.default ? Hn(d) || zn(this, d, !0) === !0 ? (this.default = Kn(d) ? function() {
      return [].concat(d);
    } : Mn(d) ? function() {
      return Object.assign({}, d);
    } : d, this) : (Qt(this._vueTypes_name + ' - invalid default value: "' + d + '"'), this) : this;
  } } }), e = n.validator;
  return Hn(e) && (n.validator = Ui(e, n)), n;
}
function gt(l, t) {
  var n = Gt(l, t);
  return Object.defineProperty(n, "validate", { value: function(e) {
    return Hn(this.validator) && Qt(this._vueTypes_name + ` - calling .validate() will overwrite the current custom validator function. Validator info:
` + JSON.stringify(this)), this.validator = Ui(e, this), this;
  } });
}
function Bs(l, t, n) {
  var e, d, a = (e = t, d = {}, Object.getOwnPropertyNames(e).forEach(function(s) {
    d[s] = Object.getOwnPropertyDescriptor(e, s);
  }), Object.defineProperties({}, d));
  if (a._vueTypes_name = l, !Mn(n))
    return a;
  var U, V, h = n.validator, W = T0(n, ["validator"]);
  if (Hn(h)) {
    var Z = a.validator;
    Z && (Z = (V = (U = Z).__original) !== null && V !== void 0 ? V : U), a.validator = Ui(Z ? function(s) {
      return Z.call(this, s) && h.call(this, s);
    } : h, a);
  }
  return Object.assign(a, W);
}
function Xd(l) {
  return l.replace(/^(?!\s*$)/gm, "  ");
}
var _V = function() {
  return gt("any", {});
}, lQ = function() {
  return gt("function", { type: Function });
}, tQ = function() {
  return gt("boolean", { type: Boolean });
}, nQ = function() {
  return gt("string", { type: String });
}, eQ = function() {
  return gt("number", { type: Number });
}, dQ = function() {
  return gt("array", { type: Array });
}, aQ = function() {
  return gt("object", { type: Object });
}, iQ = function() {
  return Gt("integer", { type: Number, validator: function(l) {
    return qV(l);
  } });
}, sQ = function() {
  return Gt("symbol", { validator: function(l) {
    return typeof l == "symbol";
  } });
};
function cQ(l, t) {
  if (t === void 0 && (t = "custom validation failed"), typeof l != "function")
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return Gt(l.name || "<<anonymous function>>", { validator: function(n) {
    var e = l(n);
    return e || Qt(this._vueTypes_name + " - " + t), e;
  } });
}
function UQ(l) {
  if (!Kn(l))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  var t = 'oneOf - value should be one of "' + l.join('", "') + '".', n = l.reduce(function(e, d) {
    if (d != null) {
      var a = d.constructor;
      e.indexOf(a) === -1 && e.push(a);
    }
    return e;
  }, []);
  return Gt("oneOf", { type: n.length > 0 ? n : void 0, validator: function(e) {
    var d = l.indexOf(e) !== -1;
    return d || Qt(t), d;
  } });
}
function ZQ(l) {
  if (!Kn(l))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  for (var t = !1, n = [], e = 0; e < l.length; e += 1) {
    var d = l[e];
    if (y0(d)) {
      if (Zd(d) && d._vueTypes_name === "oneOf") {
        n = n.concat(d.type);
        continue;
      }
      if (Hn(d.validator) && (t = !0), d.type !== !0 && d.type) {
        n = n.concat(d.type);
        continue;
      }
    }
    n.push(d);
  }
  return n = n.filter(function(a, U) {
    return n.indexOf(a) === U;
  }), Gt("oneOfType", t ? { type: n, validator: function(a) {
    var U = [], V = l.some(function(h) {
      var W = zn(Zd(h) && h._vueTypes_name === "oneOf" ? h.type || null : h, a, !0);
      return typeof W == "string" && U.push(W), W === !0;
    });
    return V || Qt("oneOfType - provided value does not match any of the " + U.length + ` passed-in validators:
` + Xd(U.join(`
`))), V;
  } } : { type: n });
}
function FQ(l) {
  return Gt("arrayOf", { type: Array, validator: function(t) {
    var n, e = t.every(function(d) {
      return (n = zn(l, d, !0)) === !0;
    });
    return e || Qt(`arrayOf - value validation error:
` + Xd(n)), e;
  } });
}
function oQ(l) {
  return Gt("instanceOf", { type: l });
}
function VQ(l) {
  return Gt("objectOf", { type: Object, validator: function(t) {
    var n, e = Object.keys(t).every(function(d) {
      return (n = zn(l, t[d], !0)) === !0;
    });
    return e || Qt(`objectOf - value validation error:
` + Xd(n)), e;
  } });
}
function QQ(l) {
  var t = Object.keys(l), n = t.filter(function(d) {
    var a;
    return !!(!((a = l[d]) === null || a === void 0) && a.required);
  }), e = Gt("shape", { type: Object, validator: function(d) {
    var a = this;
    if (!Mn(d))
      return !1;
    var U = Object.keys(d);
    if (n.length > 0 && n.some(function(h) {
      return U.indexOf(h) === -1;
    })) {
      var V = n.filter(function(h) {
        return U.indexOf(h) === -1;
      });
      return Qt(V.length === 1 ? 'shape - required property "' + V[0] + '" is not defined.' : 'shape - required properties "' + V.join('", "') + '" are not defined.'), !1;
    }
    return U.every(function(h) {
      if (t.indexOf(h) === -1)
        return a._vueTypes_isLoose === !0 || (Qt('shape - shape definition does not include a "' + h + '" property. Allowed keys: "' + t.join('", "') + '".'), !1);
      var W = zn(l[h], d[h], !0);
      return typeof W == "string" && Qt('shape - "' + h + `" property validation error:
 ` + Xd(W)), W === !0;
    });
  } });
  return Object.defineProperty(e, "_vueTypes_isLoose", { writable: !0, value: !1 }), Object.defineProperty(e, "loose", { get: function() {
    return this._vueTypes_isLoose = !0, this;
  } }), e;
}
var Dt = function() {
  function l() {
  }
  return l.extend = function(t) {
    var n = this;
    if (Kn(t))
      return t.forEach(function(s) {
        return n.extend(s);
      }), this;
    var e = t.name, d = t.validate, a = d !== void 0 && d, U = t.getter, V = U !== void 0 && U, h = T0(t, ["name", "validate", "getter"]);
    if (Ne(this, e))
      throw new TypeError('[VueTypes error]: Type "' + e + '" already defined');
    var W, Z = h.type;
    return Zd(Z) ? (delete h.type, Object.defineProperty(this, e, V ? { get: function() {
      return Bs(e, Z, h);
    } } : { value: function() {
      var s, o = Bs(e, Z, h);
      return o.validator && (o.validator = (s = o.validator).bind.apply(s, [o].concat([].slice.call(arguments)))), o;
    } })) : (W = V ? { get: function() {
      var s = Object.assign({}, h);
      return a ? gt(e, s) : Gt(e, s);
    }, enumerable: !0 } : { value: function() {
      var s, o, F = Object.assign({}, h);
      return s = a ? gt(e, F) : Gt(e, F), F.validator && (s.validator = (o = F.validator).bind.apply(o, [s].concat([].slice.call(arguments)))), s;
    }, enumerable: !0 }, Object.defineProperty(this, e, W));
  }, p0(l, null, [{ key: "any", get: function() {
    return _V();
  } }, { key: "func", get: function() {
    return lQ().def(this.defaults.func);
  } }, { key: "bool", get: function() {
    return tQ().def(this.defaults.bool);
  } }, { key: "string", get: function() {
    return nQ().def(this.defaults.string);
  } }, { key: "number", get: function() {
    return eQ().def(this.defaults.number);
  } }, { key: "array", get: function() {
    return dQ().def(this.defaults.array);
  } }, { key: "object", get: function() {
    return aQ().def(this.defaults.object);
  } }, { key: "integer", get: function() {
    return iQ().def(this.defaults.integer);
  } }, { key: "symbol", get: function() {
    return sQ();
  } }]), l;
}();
function B0(l) {
  var t;
  return l === void 0 && (l = { func: function() {
  }, bool: !0, string: "", number: 0, array: function() {
    return [];
  }, object: function() {
    return {};
  }, integer: 0 }), (t = function(n) {
    function e() {
      return n.apply(this, arguments) || this;
    }
    return S0(e, n), p0(e, null, [{ key: "sensibleDefaults", get: function() {
      return Ke({}, this.defaults);
    }, set: function(d) {
      this.defaults = d !== !1 ? Ke({}, d !== !0 ? d : l) : {};
    } }]), e;
  }(Dt)).defaults = Ke({}, l), t;
}
Dt.defaults = {}, Dt.custom = cQ, Dt.oneOf = UQ, Dt.instanceOf = oQ, Dt.oneOfType = ZQ, Dt.arrayOf = FQ, Dt.objectOf = VQ, Dt.shape = QQ, Dt.utils = { validate: function(l, t) {
  return zn(t, l, !0) === !0;
}, toType: function(l, t, n) {
  return n === void 0 && (n = !1), n ? gt(l, t) : Gt(l, t);
} };
(function(l) {
  function t() {
    return l.apply(this, arguments) || this;
  }
  return S0(t, l), t;
})(B0());
const ol = B0({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0
});
ol.extend([{
  name: "looseBool",
  getter: !0,
  type: Boolean,
  default: void 0
}, {
  name: "style",
  getter: !0,
  type: [String, Object],
  default: void 0
}, {
  name: "VueNode",
  getter: !0,
  type: null
}]);
const Zi = (l, t, n) => {
  Bt(l, `[ant-design-vue: ${t}] ${n}`);
};
function zs(l, t) {
  const {
    key: n
  } = l;
  let e;
  return "value" in l && ({
    value: e
  } = l), n ?? (e !== void 0 ? e : `rc-index-key-${t}`);
}
function z0(l, t) {
  const {
    label: n,
    value: e,
    options: d
  } = l || {};
  return {
    label: n || (t ? "children" : "label"),
    value: e || "value",
    options: d || "options"
  };
}
function WQ(l) {
  let {
    fieldNames: t,
    childrenAsData: n
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const e = [], {
    label: d,
    value: a,
    options: U
  } = z0(t, !1);
  function V(h, W) {
    h.forEach((Z) => {
      const s = Z[d];
      if (W || !(U in Z)) {
        const o = Z[a];
        e.push({
          key: zs(Z, e.length),
          groupOption: W,
          data: Z,
          label: s,
          value: o
        });
      } else {
        let o = s;
        o === void 0 && n && (o = Z.label), e.push({
          key: zs(Z, e.length),
          group: !0,
          data: Z,
          label: o
        }), V(Z[U], !0);
      }
    });
  }
  return V(l, !1), e;
}
function ka(l) {
  const t = j({}, l);
  return "props" in t || Object.defineProperty(t, "props", {
    get() {
      return ii(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), t;
    }
  }), t;
}
function hQ(l, t) {
  if (!t || !t.length)
    return null;
  let n = !1;
  function e(a, U) {
    let [V, ...h] = U;
    if (!V)
      return [a];
    const W = a.split(V);
    return n = n || W.length > 1, W.reduce((Z, s) => [...Z, ...e(s, h)], []).filter((Z) => Z);
  }
  const d = e(l, t);
  return n ? d : null;
}
function RQ() {
  return "";
}
function NQ(l) {
  return l ? l.ownerDocument : window.document;
}
function L0() {
}
const bQ = () => ({
  action: ol.oneOfType([ol.string, ol.arrayOf(ol.string)]).def([]),
  showAction: ol.any.def([]),
  hideAction: ol.any.def([]),
  getPopupClassNameFromAlign: ol.any.def(RQ),
  onPopupVisibleChange: Function,
  afterPopupVisibleChange: ol.func.def(L0),
  popup: ol.any,
  arrow: ol.bool.def(!0),
  popupStyle: {
    type: Object,
    default: void 0
  },
  prefixCls: ol.string.def("rc-trigger-popup"),
  popupClassName: ol.string.def(""),
  popupPlacement: String,
  builtinPlacements: ol.object,
  popupTransitionName: String,
  popupAnimation: ol.any,
  mouseEnterDelay: ol.number.def(0),
  mouseLeaveDelay: ol.number.def(0.1),
  zIndex: Number,
  focusDelay: ol.number.def(0),
  blurDelay: ol.number.def(0.15),
  getPopupContainer: Function,
  getDocument: ol.func.def(NQ),
  forceRender: {
    type: Boolean,
    default: void 0
  },
  destroyPopupOnHide: {
    type: Boolean,
    default: !1
  },
  mask: {
    type: Boolean,
    default: !1
  },
  maskClosable: {
    type: Boolean,
    default: !0
  },
  // onPopupAlign: PropTypes.func.def(noop),
  popupAlign: ol.object.def(() => ({})),
  popupVisible: {
    type: Boolean,
    default: void 0
  },
  defaultPopupVisible: {
    type: Boolean,
    default: !1
  },
  maskTransitionName: String,
  maskAnimation: String,
  stretch: String,
  alignPoint: {
    type: Boolean,
    default: void 0
  },
  autoDestroy: {
    type: Boolean,
    default: !1
  },
  mobile: Object,
  getTriggerDOMNode: Function
}), Fi = {
  visible: Boolean,
  prefixCls: String,
  zIndex: Number,
  destroyPopupOnHide: Boolean,
  forceRender: Boolean,
  arrow: {
    type: Boolean,
    default: !0
  },
  // Legacy Motion
  animation: [String, Object],
  transitionName: String,
  // Measure
  stretch: {
    type: String
  },
  // Align
  align: {
    type: Object
  },
  point: {
    type: Object
  },
  getRootDomNode: {
    type: Function
  },
  getClassNameFromAlign: {
    type: Function
  },
  onAlign: {
    type: Function
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onTouchstart: {
    type: Function
  }
}, mQ = j(j({}, Fi), {
  mobile: {
    type: Object
  }
}), uQ = j(j({}, Fi), {
  mask: Boolean,
  mobile: {
    type: Object
  },
  maskAnimation: String,
  maskTransitionName: String
});
function k0(l) {
  let {
    prefixCls: t,
    animation: n,
    transitionName: e
  } = l;
  return n ? {
    name: `${t}-${n}`
  } : e ? {
    name: e
  } : {};
}
function I0(l) {
  const {
    prefixCls: t,
    visible: n,
    zIndex: e,
    mask: d,
    maskAnimation: a,
    maskTransitionName: U
  } = l;
  if (!d)
    return null;
  let V = {};
  return (U || a) && (V = k0({
    prefixCls: t,
    transitionName: U,
    animation: a
  })), H(Yn, Ql({
    appear: !0
  }, V), {
    default: () => [ud(H("div", {
      style: {
        zIndex: e
      },
      class: `${t}-mask`
    }, null), [[RF("if"), n]])]
  });
}
I0.displayName = "Mask";
const rQ = pl({
  compatConfig: {
    MODE: 3
  },
  name: "MobilePopupInner",
  inheritAttrs: !1,
  props: mQ,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(l, t) {
    let {
      expose: n,
      slots: e
    } = t;
    const d = Ml();
    return n({
      forceAlign: () => {
      },
      getElement: () => d.value
    }), () => {
      var a;
      const {
        zIndex: U,
        visible: V,
        prefixCls: h,
        mobile: {
          popupClassName: W,
          popupStyle: Z,
          popupMotion: s = {},
          popupRender: o
        } = {}
      } = l, F = j({
        zIndex: U
      }, Z);
      let N = Tt((a = e.default) === null || a === void 0 ? void 0 : a.call(e));
      N.length > 1 && (N = H("div", {
        class: `${h}-content`
      }, [N])), o && (N = o(N));
      const Q = Xl(h, W);
      return H(Yn, Ql({
        ref: d
      }, s), {
        default: () => [V ? H("div", {
          class: Q,
          style: F
        }, [N]) : null]
      });
    };
  }
});
var MQ = function(l, t, n, e) {
  function d(a) {
    return a instanceof n ? a : new n(function(U) {
      U(a);
    });
  }
  return new (n || (n = Promise))(function(a, U) {
    function V(Z) {
      try {
        W(e.next(Z));
      } catch (s) {
        U(s);
      }
    }
    function h(Z) {
      try {
        W(e.throw(Z));
      } catch (s) {
        U(s);
      }
    }
    function W(Z) {
      Z.done ? a(Z.value) : d(Z.value).then(V, h);
    }
    W((e = e.apply(l, t || [])).next());
  });
};
const Ls = ["measure", "align", null, "motion"], pQ = (l, t) => {
  const n = bl(null), e = bl(), d = bl(!1);
  function a(h) {
    d.value || (n.value = h);
  }
  function U() {
    Ol.cancel(e.value);
  }
  function V(h) {
    U(), e.value = Ol(() => {
      let W = n.value;
      switch (n.value) {
        case "align":
          W = "motion";
          break;
        case "motion":
          W = "stable";
          break;
      }
      a(W), h?.();
    });
  }
  return Bl(l, () => {
    a("measure");
  }, {
    immediate: !0,
    flush: "post"
  }), ql(() => {
    Bl(n, () => {
      switch (n.value) {
        case "measure":
          t();
          break;
      }
      n.value && (e.value = Ol(() => MQ(void 0, void 0, void 0, function* () {
        const h = Ls.indexOf(n.value), W = Ls[h + 1];
        W && h !== -1 && a(W);
      })));
    }, {
      immediate: !0,
      flush: "post"
    });
  }), Wt(() => {
    d.value = !0, U();
  }), [n, V];
}, SQ = (l) => {
  const t = bl({
    width: 0,
    height: 0
  });
  function n(d) {
    t.value = {
      width: d.offsetWidth,
      height: d.offsetHeight
    };
  }
  return [Zl(() => {
    const d = {};
    if (l.value) {
      const {
        width: a,
        height: U
      } = t.value;
      l.value.indexOf("height") !== -1 && U ? d.height = `${U}px` : l.value.indexOf("minHeight") !== -1 && U && (d.minHeight = `${U}px`), l.value.indexOf("width") !== -1 && a ? d.width = `${a}px` : l.value.indexOf("minWidth") !== -1 && a && (d.minWidth = `${a}px`);
    }
    return d;
  }), n];
};
function ks(l, t) {
  var n = Object.keys(l);
  if (Object.getOwnPropertySymbols) {
    var e = Object.getOwnPropertySymbols(l);
    t && (e = e.filter(function(d) {
      return Object.getOwnPropertyDescriptor(l, d).enumerable;
    })), n.push.apply(n, e);
  }
  return n;
}
function Is(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ks(Object(n), !0).forEach(function(e) {
      TQ(l, e, n[e]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(l, Object.getOwnPropertyDescriptors(n)) : ks(Object(n)).forEach(function(e) {
      Object.defineProperty(l, e, Object.getOwnPropertyDescriptor(n, e));
    });
  }
  return l;
}
function Ia(l) {
  "@babel/helpers - typeof";
  return Ia = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ia(l);
}
function TQ(l, t, n) {
  return t in l ? Object.defineProperty(l, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : l[t] = n, l;
}
var ne, GQ = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  // IE did it wrong again ...
  ms: "-ms-",
  O: "-o-"
};
function Fd() {
  if (ne !== void 0)
    return ne;
  ne = "";
  var l = document.createElement("p").style, t = "Transform";
  for (var n in GQ)
    n + t in l && (ne = n);
  return ne;
}
function D0() {
  return Fd() ? "".concat(Fd(), "TransitionProperty") : "transitionProperty";
}
function Yd() {
  return Fd() ? "".concat(Fd(), "Transform") : "transform";
}
function Ds(l, t) {
  var n = D0();
  n && (l.style[n] = t, n !== "transitionProperty" && (l.style.transitionProperty = t));
}
function na(l, t) {
  var n = Yd();
  n && (l.style[n] = t, n !== "transform" && (l.style.transform = t));
}
function JQ(l) {
  return l.style.transitionProperty || l.style[D0()];
}
function XQ(l) {
  var t = window.getComputedStyle(l, null), n = t.getPropertyValue("transform") || t.getPropertyValue(Yd());
  if (n && n !== "none") {
    var e = n.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(e[12] || e[4], 0),
      y: parseFloat(e[13] || e[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var YQ = /matrix\((.*)\)/, yQ = /matrix3d\((.*)\)/;
function BQ(l, t) {
  var n = window.getComputedStyle(l, null), e = n.getPropertyValue("transform") || n.getPropertyValue(Yd());
  if (e && e !== "none") {
    var d, a = e.match(YQ);
    if (a)
      a = a[1], d = a.split(",").map(function(V) {
        return parseFloat(V, 10);
      }), d[4] = t.x, d[5] = t.y, na(l, "matrix(".concat(d.join(","), ")"));
    else {
      var U = e.match(yQ)[1];
      d = U.split(",").map(function(V) {
        return parseFloat(V, 10);
      }), d[12] = t.x, d[13] = t.y, na(l, "matrix3d(".concat(d.join(","), ")"));
    }
  } else
    na(l, "translateX(".concat(t.x, "px) translateY(").concat(t.y, "px) translateZ(0)"));
}
var zQ = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, Ye;
function Cs(l) {
  var t = l.style.display;
  l.style.display = "none", l.offsetHeight, l.style.display = t;
}
function jn(l, t, n) {
  var e = n;
  if (Ia(t) === "object") {
    for (var d in t)
      t.hasOwnProperty(d) && jn(l, d, t[d]);
    return;
  }
  if (typeof e < "u") {
    typeof e == "number" && (e = "".concat(e, "px")), l.style[t] = e;
    return;
  }
  return Ye(l, t);
}
function LQ(l) {
  var t, n, e, d = l.ownerDocument, a = d.body, U = d && d.documentElement;
  return t = l.getBoundingClientRect(), n = Math.floor(t.left), e = Math.floor(t.top), n -= U.clientLeft || a.clientLeft || 0, e -= U.clientTop || a.clientTop || 0, {
    left: n,
    top: e
  };
}
function C0(l, t) {
  var n = l["page".concat(t ? "Y" : "X", "Offset")], e = "scroll".concat(t ? "Top" : "Left");
  if (typeof n != "number") {
    var d = l.document;
    n = d.documentElement[e], typeof n != "number" && (n = d.body[e]);
  }
  return n;
}
function w0(l) {
  return C0(l);
}
function E0(l) {
  return C0(l, !0);
}
function be(l) {
  var t = LQ(l), n = l.ownerDocument, e = n.defaultView || n.parentWindow;
  return t.left += w0(e), t.top += E0(e), t;
}
function oi(l) {
  return l != null && l == l.window;
}
function x0(l) {
  return oi(l) ? l.document : l.nodeType === 9 ? l : l.ownerDocument;
}
function kQ(l, t, n) {
  var e = n, d = "", a = x0(l);
  return e = e || a.defaultView.getComputedStyle(l, null), e && (d = e.getPropertyValue(t) || e[t]), d;
}
var IQ = new RegExp("^(".concat(zQ, ")(?!px)[a-z%]+$"), "i"), DQ = /^(top|right|bottom|left)$/, ea = "currentStyle", da = "runtimeStyle", Fn = "left", CQ = "px";
function wQ(l, t) {
  var n = l[ea] && l[ea][t];
  if (IQ.test(n) && !DQ.test(t)) {
    var e = l.style, d = e[Fn], a = l[da][Fn];
    l[da][Fn] = l[ea][Fn], e[Fn] = t === "fontSize" ? "1em" : n || 0, n = e.pixelLeft + CQ, e[Fn] = d, l[da][Fn] = a;
  }
  return n === "" ? "auto" : n;
}
typeof window < "u" && (Ye = window.getComputedStyle ? kQ : wQ);
function we(l, t) {
  return l === "left" ? t.useCssRight ? "right" : l : t.useCssBottom ? "bottom" : l;
}
function ws(l) {
  if (l === "left")
    return "right";
  if (l === "right")
    return "left";
  if (l === "top")
    return "bottom";
  if (l === "bottom")
    return "top";
}
function Es(l, t, n) {
  jn(l, "position") === "static" && (l.style.position = "relative");
  var e = -999, d = -999, a = we("left", n), U = we("top", n), V = ws(a), h = ws(U);
  a !== "left" && (e = 999), U !== "top" && (d = 999);
  var W = "", Z = be(l);
  ("left" in t || "top" in t) && (W = JQ(l) || "", Ds(l, "none")), "left" in t && (l.style[V] = "", l.style[a] = "".concat(e, "px")), "top" in t && (l.style[h] = "", l.style[U] = "".concat(d, "px")), Cs(l);
  var s = be(l), o = {};
  for (var F in t)
    if (t.hasOwnProperty(F)) {
      var N = we(F, n), Q = F === "left" ? e : d, u = Z[F] - s[F];
      N === F ? o[N] = Q + u : o[N] = Q - u;
    }
  jn(l, o), Cs(l), ("left" in t || "top" in t) && Ds(l, W);
  var i = {};
  for (var c in t)
    if (t.hasOwnProperty(c)) {
      var R = we(c, n), m = t[c] - Z[c];
      c === R ? i[R] = o[R] + m : i[R] = o[R] - m;
    }
  jn(l, i);
}
function EQ(l, t) {
  var n = be(l), e = XQ(l), d = {
    x: e.x,
    y: e.y
  };
  "left" in t && (d.x = e.x + t.left - n.left), "top" in t && (d.y = e.y + t.top - n.top), BQ(l, d);
}
function xQ(l, t, n) {
  if (n.ignoreShake) {
    var e = be(l), d = e.left.toFixed(0), a = e.top.toFixed(0), U = t.left.toFixed(0), V = t.top.toFixed(0);
    if (d === U && a === V)
      return;
  }
  n.useCssRight || n.useCssBottom ? Es(l, t, n) : n.useCssTransform && Yd() in document.body.style ? EQ(l, t) : Es(l, t, n);
}
function Vi(l, t) {
  for (var n = 0; n < l.length; n++)
    t(l[n]);
}
function g0(l) {
  return Ye(l, "boxSizing") === "border-box";
}
var gQ = ["margin", "border", "padding"], Da = -1, jQ = 2, Ca = 1, OQ = 0;
function vQ(l, t, n) {
  var e = {}, d = l.style, a;
  for (a in t)
    t.hasOwnProperty(a) && (e[a] = d[a], d[a] = t[a]);
  n.call(l);
  for (a in t)
    t.hasOwnProperty(a) && (d[a] = e[a]);
}
function ae(l, t, n) {
  var e = 0, d, a, U;
  for (a = 0; a < t.length; a++)
    if (d = t[a], d)
      for (U = 0; U < n.length; U++) {
        var V = void 0;
        d === "border" ? V = "".concat(d).concat(n[U], "Width") : V = d + n[U], e += parseFloat(Ye(l, V)) || 0;
      }
  return e;
}
var Et = {
  getParent: function(t) {
    var n = t;
    do
      n.nodeType === 11 && n.host ? n = n.host : n = n.parentNode;
    while (n && n.nodeType !== 1 && n.nodeType !== 9);
    return n;
  }
};
Vi(["Width", "Height"], function(l) {
  Et["doc".concat(l)] = function(t) {
    var n = t.document;
    return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      n.documentElement["scroll".concat(l)],
      // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
      n.body["scroll".concat(l)],
      Et["viewport".concat(l)](n)
    );
  }, Et["viewport".concat(l)] = function(t) {
    var n = "client".concat(l), e = t.document, d = e.body, a = e.documentElement, U = a[n];
    return e.compatMode === "CSS1Compat" && U || d && d[n] || U;
  };
});
function xs(l, t, n) {
  var e = n;
  if (oi(l))
    return t === "width" ? Et.viewportWidth(l) : Et.viewportHeight(l);
  if (l.nodeType === 9)
    return t === "width" ? Et.docWidth(l) : Et.docHeight(l);
  var d = t === "width" ? ["Left", "Right"] : ["Top", "Bottom"], a = Math.floor(t === "width" ? l.getBoundingClientRect().width : l.getBoundingClientRect().height), U = g0(l), V = 0;
  (a == null || a <= 0) && (a = void 0, V = Ye(l, t), (V == null || Number(V) < 0) && (V = l.style[t] || 0), V = Math.floor(parseFloat(V)) || 0), e === void 0 && (e = U ? Ca : Da);
  var h = a !== void 0 || U, W = a || V;
  return e === Da ? h ? W - ae(l, ["border", "padding"], d) : V : h ? e === Ca ? W : W + (e === jQ ? -ae(l, ["border"], d) : ae(l, ["margin"], d)) : V + ae(l, gQ.slice(e), d);
}
var fQ = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function gs() {
  for (var l = arguments.length, t = new Array(l), n = 0; n < l; n++)
    t[n] = arguments[n];
  var e, d = t[0];
  return d.offsetWidth !== 0 ? e = xs.apply(void 0, t) : vQ(d, fQ, function() {
    e = xs.apply(void 0, t);
  }), e;
}
Vi(["width", "height"], function(l) {
  var t = l.charAt(0).toUpperCase() + l.slice(1);
  Et["outer".concat(t)] = function(e, d) {
    return e && gs(e, l, d ? OQ : Ca);
  };
  var n = l === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  Et[l] = function(e, d) {
    var a = d;
    if (a !== void 0) {
      if (e) {
        var U = g0(e);
        return U && (a += ae(e, ["padding", "border"], n)), jn(e, l, a);
      }
      return;
    }
    return e && gs(e, l, Da);
  };
});
function j0(l, t) {
  for (var n in t)
    t.hasOwnProperty(n) && (l[n] = t[n]);
  return l;
}
var kl = {
  getWindow: function(t) {
    if (t && t.document && t.setTimeout)
      return t;
    var n = t.ownerDocument || t;
    return n.defaultView || n.parentWindow;
  },
  getDocument: x0,
  offset: function(t, n, e) {
    if (typeof n < "u")
      xQ(t, n, e || {});
    else
      return be(t);
  },
  isWindow: oi,
  each: Vi,
  css: jn,
  clone: function(t) {
    var n, e = {};
    for (n in t)
      t.hasOwnProperty(n) && (e[n] = t[n]);
    var d = t.overflow;
    if (d)
      for (n in t)
        t.hasOwnProperty(n) && (e.overflow[n] = t.overflow[n]);
    return e;
  },
  mix: j0,
  getWindowScrollLeft: function(t) {
    return w0(t);
  },
  getWindowScrollTop: function(t) {
    return E0(t);
  },
  merge: function() {
    for (var t = {}, n = 0; n < arguments.length; n++)
      kl.mix(t, n < 0 || arguments.length <= n ? void 0 : arguments[n]);
    return t;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
j0(kl, Et);
var aa = kl.getParent;
function wa(l) {
  if (kl.isWindow(l) || l.nodeType === 9)
    return null;
  var t = kl.getDocument(l), n = t.body, e, d = kl.css(l, "position"), a = d === "fixed" || d === "absolute";
  if (!a)
    return l.nodeName.toLowerCase() === "html" ? null : aa(l);
  for (e = aa(l); e && e !== n && e.nodeType !== 9; e = aa(e))
    if (d = kl.css(e, "position"), d !== "static")
      return e;
  return null;
}
var js = kl.getParent;
function KQ(l) {
  if (kl.isWindow(l) || l.nodeType === 9)
    return !1;
  var t = kl.getDocument(l), n = t.body, e = null;
  for (
    e = js(l);
    // 修复元素位于 document.documentElement 下导致崩溃问题
    e && e !== n && e !== t;
    e = js(e)
  ) {
    var d = kl.css(e, "position");
    if (d === "fixed")
      return !0;
  }
  return !1;
}
function Qi(l, t) {
  for (var n = {
    left: 0,
    right: 1 / 0,
    top: 0,
    bottom: 1 / 0
  }, e = wa(l), d = kl.getDocument(l), a = d.defaultView || d.parentWindow, U = d.body, V = d.documentElement; e; ) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || e.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    e !== U && e !== V && kl.css(e, "overflow") !== "visible") {
      var h = kl.offset(e);
      h.left += e.clientLeft, h.top += e.clientTop, n.top = Math.max(n.top, h.top), n.right = Math.min(
        n.right,
        // consider area without scrollBar
        h.left + e.clientWidth
      ), n.bottom = Math.min(n.bottom, h.top + e.clientHeight), n.left = Math.max(n.left, h.left);
    } else if (e === U || e === V)
      break;
    e = wa(e);
  }
  var W = null;
  if (!kl.isWindow(l) && l.nodeType !== 9) {
    W = l.style.position;
    var Z = kl.css(l, "position");
    Z === "absolute" && (l.style.position = "fixed");
  }
  var s = kl.getWindowScrollLeft(a), o = kl.getWindowScrollTop(a), F = kl.viewportWidth(a), N = kl.viewportHeight(a), Q = V.scrollWidth, u = V.scrollHeight, i = window.getComputedStyle(U);
  if (i.overflowX === "hidden" && (Q = a.innerWidth), i.overflowY === "hidden" && (u = a.innerHeight), l.style && (l.style.position = W), t || KQ(l))
    n.left = Math.max(n.left, s), n.top = Math.max(n.top, o), n.right = Math.min(n.right, s + F), n.bottom = Math.min(n.bottom, o + N);
  else {
    var c = Math.max(Q, s + F);
    n.right = Math.min(n.right, c);
    var R = Math.max(u, o + N);
    n.bottom = Math.min(n.bottom, R);
  }
  return n.top >= 0 && n.left >= 0 && n.bottom > n.top && n.right > n.left ? n : null;
}
function HQ(l, t, n, e) {
  var d = kl.clone(l), a = {
    width: t.width,
    height: t.height
  };
  return e.adjustX && d.left < n.left && (d.left = n.left), e.resizeWidth && d.left >= n.left && d.left + a.width > n.right && (a.width -= d.left + a.width - n.right), e.adjustX && d.left + a.width > n.right && (d.left = Math.max(n.right - a.width, n.left)), e.adjustY && d.top < n.top && (d.top = n.top), e.resizeHeight && d.top >= n.top && d.top + a.height > n.bottom && (a.height -= d.top + a.height - n.bottom), e.adjustY && d.top + a.height > n.bottom && (d.top = Math.max(n.bottom - a.height, n.top)), kl.mix(d, a);
}
function Wi(l) {
  var t, n, e;
  if (!kl.isWindow(l) && l.nodeType !== 9)
    t = kl.offset(l), n = kl.outerWidth(l), e = kl.outerHeight(l);
  else {
    var d = kl.getWindow(l);
    t = {
      left: kl.getWindowScrollLeft(d),
      top: kl.getWindowScrollTop(d)
    }, n = kl.viewportWidth(d), e = kl.viewportHeight(d);
  }
  return t.width = n, t.height = e, t;
}
function Os(l, t) {
  var n = t.charAt(0), e = t.charAt(1), d = l.width, a = l.height, U = l.left, V = l.top;
  return n === "c" ? V += a / 2 : n === "b" && (V += a), e === "c" ? U += d / 2 : e === "r" && (U += d), {
    left: U,
    top: V
  };
}
function Ee(l, t, n, e, d) {
  var a = Os(t, n[1]), U = Os(l, n[0]), V = [U.left - a.left, U.top - a.top];
  return {
    left: Math.round(l.left - V[0] + e[0] - d[0]),
    top: Math.round(l.top - V[1] + e[1] - d[1])
  };
}
function vs(l, t, n) {
  return l.left < n.left || l.left + t.width > n.right;
}
function fs(l, t, n) {
  return l.top < n.top || l.top + t.height > n.bottom;
}
function PQ(l, t, n) {
  return l.left > n.right || l.left + t.width < n.left;
}
function AQ(l, t, n) {
  return l.top > n.bottom || l.top + t.height < n.top;
}
function xe(l, t, n) {
  var e = [];
  return kl.each(l, function(d) {
    e.push(d.replace(t, function(a) {
      return n[a];
    }));
  }), e;
}
function ge(l, t) {
  return l[t] = -l[t], l;
}
function Ks(l, t) {
  var n;
  return /%$/.test(l) ? n = parseInt(l.substring(0, l.length - 1), 10) / 100 * t : n = parseInt(l, 10), n || 0;
}
function Hs(l, t) {
  l[0] = Ks(l[0], t.width), l[1] = Ks(l[1], t.height);
}
function O0(l, t, n, e) {
  var d = n.points, a = n.offset || [0, 0], U = n.targetOffset || [0, 0], V = n.overflow, h = n.source || l;
  a = [].concat(a), U = [].concat(U), V = V || {};
  var W = {}, Z = 0, s = !!(V && V.alwaysByViewport), o = Qi(h, s), F = Wi(h);
  Hs(a, F), Hs(U, t);
  var N = Ee(F, t, d, a, U), Q = kl.merge(F, N);
  if (o && (V.adjustX || V.adjustY) && e) {
    if (V.adjustX && vs(N, F, o)) {
      var u = xe(d, /[lr]/gi, {
        l: "r",
        r: "l"
      }), i = ge(a, 0), c = ge(U, 0), R = Ee(F, t, u, i, c);
      PQ(R, F, o) || (Z = 1, d = u, a = i, U = c);
    }
    if (V.adjustY && fs(N, F, o)) {
      var m = xe(d, /[tb]/gi, {
        t: "b",
        b: "t"
      }), M = ge(a, 1), S = ge(U, 1), p = Ee(F, t, m, M, S);
      AQ(p, F, o) || (Z = 1, d = m, a = M, U = S);
    }
    Z && (N = Ee(F, t, d, a, U), kl.mix(Q, N));
    var Y = vs(N, F, o), k = fs(N, F, o);
    if (Y || k) {
      var L = d;
      Y && (L = xe(d, /[lr]/gi, {
        l: "r",
        r: "l"
      })), k && (L = xe(d, /[tb]/gi, {
        t: "b",
        b: "t"
      })), d = L, a = n.offset || [0, 0], U = n.targetOffset || [0, 0];
    }
    W.adjustX = V.adjustX && Y, W.adjustY = V.adjustY && k, (W.adjustX || W.adjustY) && (Q = HQ(N, F, o, W));
  }
  return Q.width !== F.width && kl.css(h, "width", kl.width(h) + Q.width - F.width), Q.height !== F.height && kl.css(h, "height", kl.height(h) + Q.height - F.height), kl.offset(h, {
    left: Q.left,
    top: Q.top
  }, {
    useCssRight: n.useCssRight,
    useCssBottom: n.useCssBottom,
    useCssTransform: n.useCssTransform,
    ignoreShake: n.ignoreShake
  }), {
    points: d,
    offset: a,
    targetOffset: U,
    overflow: W
  };
}
function $Q(l, t) {
  var n = Qi(l, t), e = Wi(l);
  return !n || e.left + e.width <= n.left || e.top + e.height <= n.top || e.left >= n.right || e.top >= n.bottom;
}
function hi(l, t, n) {
  var e = n.target || t, d = Wi(e), a = !$Q(e, n.overflow && n.overflow.alwaysByViewport);
  return O0(l, d, n, a);
}
hi.__getOffsetParent = wa;
hi.__getVisibleRectForElement = Qi;
function qQ(l, t, n) {
  var e, d, a = kl.getDocument(l), U = a.defaultView || a.parentWindow, V = kl.getWindowScrollLeft(U), h = kl.getWindowScrollTop(U), W = kl.viewportWidth(U), Z = kl.viewportHeight(U);
  "pageX" in t ? e = t.pageX : e = V + t.clientX, "pageY" in t ? d = t.pageY : d = h + t.clientY;
  var s = {
    left: e,
    top: d,
    width: 0,
    height: 0
  }, o = e >= 0 && e <= V + W && d >= 0 && d <= h + Z, F = [n.points[0], "cc"];
  return O0(l, s, Is(Is({}, n), {}, {
    points: F
  }), o);
}
function bt(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, e = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, d = l;
  if (Array.isArray(l) && (d = Bn(l)[0]), !d)
    return null;
  const a = rd(d, t, e);
  return a.props = n ? j(j({}, a.props), t) : a.props, Je(typeof a.props.class != "object", "class must be string"), a;
}
const v0 = (l) => {
  if (!l)
    return !1;
  if (l.offsetParent)
    return !0;
  if (l.getBBox) {
    const t = l.getBBox();
    if (t.width || t.height)
      return !0;
  }
  if (l.getBoundingClientRect) {
    const t = l.getBoundingClientRect();
    if (t.width || t.height)
      return !0;
  }
  return !1;
};
function _Q(l, t) {
  return l === t ? !0 : !l || !t ? !1 : "pageX" in t && "pageY" in t ? l.pageX === t.pageX && l.pageY === t.pageY : "clientX" in t && "clientY" in t ? l.clientX === t.clientX && l.clientY === t.clientY : !1;
}
function lW(l, t) {
  l !== document.activeElement && tn(t, l) && typeof l.focus == "function" && l.focus();
}
function Ps(l, t) {
  let n = null, e = null;
  function d(U) {
    let [{
      target: V
    }] = U;
    if (!document.documentElement.contains(V))
      return;
    const {
      width: h,
      height: W
    } = V.getBoundingClientRect(), Z = Math.floor(h), s = Math.floor(W);
    (n !== Z || e !== s) && Promise.resolve().then(() => {
      t({
        width: Z,
        height: s
      });
    }), n = Z, e = s;
  }
  const a = new gU(d);
  return l && a.observe(l), () => {
    a.disconnect();
  };
}
const tW = (l, t) => {
  let n = !1, e = null;
  function d() {
    clearTimeout(e);
  }
  function a(U) {
    if (!n || U === !0) {
      if (l() === !1)
        return;
      n = !0, d(), e = setTimeout(() => {
        n = !1;
      }, t.value);
    } else
      d(), e = setTimeout(() => {
        n = !1, a();
      }, t.value);
  }
  return [a, () => {
    n = !1, d();
  }];
};
function nW() {
  this.__data__ = [], this.size = 0;
}
function f0(l, t) {
  return l === t || l !== l && t !== t;
}
function yd(l, t) {
  for (var n = l.length; n--; )
    if (f0(l[n][0], t))
      return n;
  return -1;
}
var eW = Array.prototype, dW = eW.splice;
function aW(l) {
  var t = this.__data__, n = yd(t, l);
  if (n < 0)
    return !1;
  var e = t.length - 1;
  return n == e ? t.pop() : dW.call(t, n, 1), --this.size, !0;
}
function iW(l) {
  var t = this.__data__, n = yd(t, l);
  return n < 0 ? void 0 : t[n][1];
}
function sW(l) {
  return yd(this.__data__, l) > -1;
}
function cW(l, t) {
  var n = this.__data__, e = yd(n, l);
  return e < 0 ? (++this.size, n.push([l, t])) : n[e][1] = t, this;
}
function qt(l) {
  var t = -1, n = l == null ? 0 : l.length;
  for (this.clear(); ++t < n; ) {
    var e = l[t];
    this.set(e[0], e[1]);
  }
}
qt.prototype.clear = nW;
qt.prototype.delete = aW;
qt.prototype.get = iW;
qt.prototype.has = sW;
qt.prototype.set = cW;
function UW() {
  this.__data__ = new qt(), this.size = 0;
}
function ZW(l) {
  var t = this.__data__, n = t.delete(l);
  return this.size = t.size, n;
}
function FW(l) {
  return this.__data__.get(l);
}
function oW(l) {
  return this.__data__.has(l);
}
var K0 = typeof global == "object" && global && global.Object === Object && global, VW = typeof self == "object" && self && self.Object === Object && self, _t = K0 || VW || Function("return this")(), Pn = _t.Symbol, H0 = Object.prototype, QW = H0.hasOwnProperty, WW = H0.toString, ee = Pn ? Pn.toStringTag : void 0;
function hW(l) {
  var t = QW.call(l, ee), n = l[ee];
  try {
    l[ee] = void 0;
    var e = !0;
  } catch {
  }
  var d = WW.call(l);
  return e && (t ? l[ee] = n : delete l[ee]), d;
}
var RW = Object.prototype, NW = RW.toString;
function bW(l) {
  return NW.call(l);
}
var mW = "[object Null]", uW = "[object Undefined]", As = Pn ? Pn.toStringTag : void 0;
function Ln(l) {
  return l == null ? l === void 0 ? uW : mW : As && As in Object(l) ? hW(l) : bW(l);
}
function P0(l) {
  var t = typeof l;
  return l != null && (t == "object" || t == "function");
}
var rW = "[object AsyncFunction]", MW = "[object Function]", pW = "[object GeneratorFunction]", SW = "[object Proxy]";
function A0(l) {
  if (!P0(l))
    return !1;
  var t = Ln(l);
  return t == MW || t == pW || t == rW || t == SW;
}
var ia = _t["__core-js_shared__"], $s = function() {
  var l = /[^.]+$/.exec(ia && ia.keys && ia.keys.IE_PROTO || "");
  return l ? "Symbol(src)_1." + l : "";
}();
function TW(l) {
  return !!$s && $s in l;
}
var GW = Function.prototype, JW = GW.toString;
function kn(l) {
  if (l != null) {
    try {
      return JW.call(l);
    } catch {
    }
    try {
      return l + "";
    } catch {
    }
  }
  return "";
}
var XW = /[\\^$.*+?()[\]{}|]/g, YW = /^\[object .+?Constructor\]$/, yW = Function.prototype, BW = Object.prototype, zW = yW.toString, LW = BW.hasOwnProperty, kW = RegExp(
  "^" + zW.call(LW).replace(XW, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function IW(l) {
  if (!P0(l) || TW(l))
    return !1;
  var t = A0(l) ? kW : YW;
  return t.test(kn(l));
}
function DW(l, t) {
  return l?.[t];
}
function _n(l, t) {
  var n = DW(l, t);
  return IW(n) ? n : void 0;
}
var me = _n(_t, "Map"), ue = _n(Object, "create");
function CW() {
  this.__data__ = ue ? ue(null) : {}, this.size = 0;
}
function wW(l) {
  var t = this.has(l) && delete this.__data__[l];
  return this.size -= t ? 1 : 0, t;
}
var EW = "__lodash_hash_undefined__", xW = Object.prototype, gW = xW.hasOwnProperty;
function jW(l) {
  var t = this.__data__;
  if (ue) {
    var n = t[l];
    return n === EW ? void 0 : n;
  }
  return gW.call(t, l) ? t[l] : void 0;
}
var OW = Object.prototype, vW = OW.hasOwnProperty;
function fW(l) {
  var t = this.__data__;
  return ue ? t[l] !== void 0 : vW.call(t, l);
}
var KW = "__lodash_hash_undefined__";
function HW(l, t) {
  var n = this.__data__;
  return this.size += this.has(l) ? 0 : 1, n[l] = ue && t === void 0 ? KW : t, this;
}
function pn(l) {
  var t = -1, n = l == null ? 0 : l.length;
  for (this.clear(); ++t < n; ) {
    var e = l[t];
    this.set(e[0], e[1]);
  }
}
pn.prototype.clear = CW;
pn.prototype.delete = wW;
pn.prototype.get = jW;
pn.prototype.has = fW;
pn.prototype.set = HW;
function PW() {
  this.size = 0, this.__data__ = {
    hash: new pn(),
    map: new (me || qt)(),
    string: new pn()
  };
}
function AW(l) {
  var t = typeof l;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? l !== "__proto__" : l === null;
}
function Bd(l, t) {
  var n = l.__data__;
  return AW(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function $W(l) {
  var t = Bd(this, l).delete(l);
  return this.size -= t ? 1 : 0, t;
}
function qW(l) {
  return Bd(this, l).get(l);
}
function _W(l) {
  return Bd(this, l).has(l);
}
function lh(l, t) {
  var n = Bd(this, l), e = n.size;
  return n.set(l, t), this.size += n.size == e ? 0 : 1, this;
}
function In(l) {
  var t = -1, n = l == null ? 0 : l.length;
  for (this.clear(); ++t < n; ) {
    var e = l[t];
    this.set(e[0], e[1]);
  }
}
In.prototype.clear = PW;
In.prototype.delete = $W;
In.prototype.get = qW;
In.prototype.has = _W;
In.prototype.set = lh;
var th = 200;
function nh(l, t) {
  var n = this.__data__;
  if (n instanceof qt) {
    var e = n.__data__;
    if (!me || e.length < th - 1)
      return e.push([l, t]), this.size = ++n.size, this;
    n = this.__data__ = new In(e);
  }
  return n.set(l, t), this.size = n.size, this;
}
function an(l) {
  var t = this.__data__ = new qt(l);
  this.size = t.size;
}
an.prototype.clear = UW;
an.prototype.delete = ZW;
an.prototype.get = FW;
an.prototype.has = oW;
an.prototype.set = nh;
var eh = "__lodash_hash_undefined__";
function dh(l) {
  return this.__data__.set(l, eh), this;
}
function ah(l) {
  return this.__data__.has(l);
}
function od(l) {
  var t = -1, n = l == null ? 0 : l.length;
  for (this.__data__ = new In(); ++t < n; )
    this.add(l[t]);
}
od.prototype.add = od.prototype.push = dh;
od.prototype.has = ah;
function ih(l, t) {
  for (var n = -1, e = l == null ? 0 : l.length; ++n < e; )
    if (t(l[n], n, l))
      return !0;
  return !1;
}
function sh(l, t) {
  return l.has(t);
}
var ch = 1, Uh = 2;
function $0(l, t, n, e, d, a) {
  var U = n & ch, V = l.length, h = t.length;
  if (V != h && !(U && h > V))
    return !1;
  var W = a.get(l), Z = a.get(t);
  if (W && Z)
    return W == t && Z == l;
  var s = -1, o = !0, F = n & Uh ? new od() : void 0;
  for (a.set(l, t), a.set(t, l); ++s < V; ) {
    var N = l[s], Q = t[s];
    if (e)
      var u = U ? e(Q, N, s, t, l, a) : e(N, Q, s, l, t, a);
    if (u !== void 0) {
      if (u)
        continue;
      o = !1;
      break;
    }
    if (F) {
      if (!ih(t, function(i, c) {
        if (!sh(F, c) && (N === i || d(N, i, n, e, a)))
          return F.push(c);
      })) {
        o = !1;
        break;
      }
    } else if (!(N === Q || d(N, Q, n, e, a))) {
      o = !1;
      break;
    }
  }
  return a.delete(l), a.delete(t), o;
}
var qs = _t.Uint8Array;
function Zh(l) {
  var t = -1, n = Array(l.size);
  return l.forEach(function(e, d) {
    n[++t] = [d, e];
  }), n;
}
function Fh(l) {
  var t = -1, n = Array(l.size);
  return l.forEach(function(e) {
    n[++t] = e;
  }), n;
}
var oh = 1, Vh = 2, Qh = "[object Boolean]", Wh = "[object Date]", hh = "[object Error]", Rh = "[object Map]", Nh = "[object Number]", bh = "[object RegExp]", mh = "[object Set]", uh = "[object String]", rh = "[object Symbol]", Mh = "[object ArrayBuffer]", ph = "[object DataView]", _s = Pn ? Pn.prototype : void 0, sa = _s ? _s.valueOf : void 0;
function Sh(l, t, n, e, d, a, U) {
  switch (n) {
    case ph:
      if (l.byteLength != t.byteLength || l.byteOffset != t.byteOffset)
        return !1;
      l = l.buffer, t = t.buffer;
    case Mh:
      return !(l.byteLength != t.byteLength || !a(new qs(l), new qs(t)));
    case Qh:
    case Wh:
    case Nh:
      return f0(+l, +t);
    case hh:
      return l.name == t.name && l.message == t.message;
    case bh:
    case uh:
      return l == t + "";
    case Rh:
      var V = Zh;
    case mh:
      var h = e & oh;
      if (V || (V = Fh), l.size != t.size && !h)
        return !1;
      var W = U.get(l);
      if (W)
        return W == t;
      e |= Vh, U.set(l, t);
      var Z = $0(V(l), V(t), e, d, a, U);
      return U.delete(l), Z;
    case rh:
      if (sa)
        return sa.call(l) == sa.call(t);
  }
  return !1;
}
function Th(l, t) {
  for (var n = -1, e = t.length, d = l.length; ++n < e; )
    l[d + n] = t[n];
  return l;
}
var re = Array.isArray;
function Gh(l, t, n) {
  var e = t(l);
  return re(l) ? e : Th(e, n(l));
}
function Jh(l, t) {
  for (var n = -1, e = l == null ? 0 : l.length, d = 0, a = []; ++n < e; ) {
    var U = l[n];
    t(U, n, l) && (a[d++] = U);
  }
  return a;
}
function Xh() {
  return [];
}
var Yh = Object.prototype, yh = Yh.propertyIsEnumerable, lc = Object.getOwnPropertySymbols, Bh = lc ? function(l) {
  return l == null ? [] : (l = Object(l), Jh(lc(l), function(t) {
    return yh.call(l, t);
  }));
} : Xh;
function zh(l, t) {
  for (var n = -1, e = Array(l); ++n < l; )
    e[n] = t(n);
  return e;
}
function Sn(l) {
  return l != null && typeof l == "object";
}
var Lh = "[object Arguments]";
function tc(l) {
  return Sn(l) && Ln(l) == Lh;
}
var q0 = Object.prototype, kh = q0.hasOwnProperty, Ih = q0.propertyIsEnumerable, _0 = tc(/* @__PURE__ */ function() {
  return arguments;
}()) ? tc : function(l) {
  return Sn(l) && kh.call(l, "callee") && !Ih.call(l, "callee");
};
function Dh() {
  return !1;
}
var lZ = typeof exports == "object" && exports && !exports.nodeType && exports, nc = lZ && typeof module == "object" && module && !module.nodeType && module, Ch = nc && nc.exports === lZ, ec = Ch ? _t.Buffer : void 0, wh = ec ? ec.isBuffer : void 0, Vd = wh || Dh, Eh = 9007199254740991, xh = /^(?:0|[1-9]\d*)$/;
function gh(l, t) {
  var n = typeof l;
  return t = t ?? Eh, !!t && (n == "number" || n != "symbol" && xh.test(l)) && l > -1 && l % 1 == 0 && l < t;
}
var jh = 9007199254740991;
function tZ(l) {
  return typeof l == "number" && l > -1 && l % 1 == 0 && l <= jh;
}
var Oh = "[object Arguments]", vh = "[object Array]", fh = "[object Boolean]", Kh = "[object Date]", Hh = "[object Error]", Ph = "[object Function]", Ah = "[object Map]", $h = "[object Number]", qh = "[object Object]", _h = "[object RegExp]", lR = "[object Set]", tR = "[object String]", nR = "[object WeakMap]", eR = "[object ArrayBuffer]", dR = "[object DataView]", aR = "[object Float32Array]", iR = "[object Float64Array]", sR = "[object Int8Array]", cR = "[object Int16Array]", UR = "[object Int32Array]", ZR = "[object Uint8Array]", FR = "[object Uint8ClampedArray]", oR = "[object Uint16Array]", VR = "[object Uint32Array]", Kl = {};
Kl[aR] = Kl[iR] = Kl[sR] = Kl[cR] = Kl[UR] = Kl[ZR] = Kl[FR] = Kl[oR] = Kl[VR] = !0;
Kl[Oh] = Kl[vh] = Kl[eR] = Kl[fh] = Kl[dR] = Kl[Kh] = Kl[Hh] = Kl[Ph] = Kl[Ah] = Kl[$h] = Kl[qh] = Kl[_h] = Kl[lR] = Kl[tR] = Kl[nR] = !1;
function QR(l) {
  return Sn(l) && tZ(l.length) && !!Kl[Ln(l)];
}
function WR(l) {
  return function(t) {
    return l(t);
  };
}
var nZ = typeof exports == "object" && exports && !exports.nodeType && exports, ce = nZ && typeof module == "object" && module && !module.nodeType && module, hR = ce && ce.exports === nZ, ca = hR && K0.process, dc = function() {
  try {
    var l = ce && ce.require && ce.require("util").types;
    return l || ca && ca.binding && ca.binding("util");
  } catch {
  }
}(), ac = dc && dc.isTypedArray, Ri = ac ? WR(ac) : QR, RR = Object.prototype, NR = RR.hasOwnProperty;
function bR(l, t) {
  var n = re(l), e = !n && _0(l), d = !n && !e && Vd(l), a = !n && !e && !d && Ri(l), U = n || e || d || a, V = U ? zh(l.length, String) : [], h = V.length;
  for (var W in l)
    NR.call(l, W) && !(U && // Safari 9 has enumerable `arguments.length` in strict mode.
    (W == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    d && (W == "offset" || W == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (W == "buffer" || W == "byteLength" || W == "byteOffset") || // Skip index properties.
    gh(W, h))) && V.push(W);
  return V;
}
var mR = Object.prototype;
function eZ(l) {
  var t = l && l.constructor, n = typeof t == "function" && t.prototype || mR;
  return l === n;
}
function dZ(l, t) {
  return function(n) {
    return l(t(n));
  };
}
var uR = dZ(Object.keys, Object), rR = Object.prototype, MR = rR.hasOwnProperty;
function aZ(l) {
  if (!eZ(l))
    return uR(l);
  var t = [];
  for (var n in Object(l))
    MR.call(l, n) && n != "constructor" && t.push(n);
  return t;
}
function iZ(l) {
  return l != null && tZ(l.length) && !A0(l);
}
function pR(l) {
  return iZ(l) ? bR(l) : aZ(l);
}
function ic(l) {
  return Gh(l, pR, Bh);
}
var SR = 1, TR = Object.prototype, GR = TR.hasOwnProperty;
function JR(l, t, n, e, d, a) {
  var U = n & SR, V = ic(l), h = V.length, W = ic(t), Z = W.length;
  if (h != Z && !U)
    return !1;
  for (var s = h; s--; ) {
    var o = V[s];
    if (!(U ? o in t : GR.call(t, o)))
      return !1;
  }
  var F = a.get(l), N = a.get(t);
  if (F && N)
    return F == t && N == l;
  var Q = !0;
  a.set(l, t), a.set(t, l);
  for (var u = U; ++s < h; ) {
    o = V[s];
    var i = l[o], c = t[o];
    if (e)
      var R = U ? e(c, i, o, t, l, a) : e(i, c, o, l, t, a);
    if (!(R === void 0 ? i === c || d(i, c, n, e, a) : R)) {
      Q = !1;
      break;
    }
    u || (u = o == "constructor");
  }
  if (Q && !u) {
    var m = l.constructor, M = t.constructor;
    m != M && "constructor" in l && "constructor" in t && !(typeof m == "function" && m instanceof m && typeof M == "function" && M instanceof M) && (Q = !1);
  }
  return a.delete(l), a.delete(t), Q;
}
var Ea = _n(_t, "DataView"), xa = _n(_t, "Promise"), ga = _n(_t, "Set"), ja = _n(_t, "WeakMap"), sc = "[object Map]", XR = "[object Object]", cc = "[object Promise]", Uc = "[object Set]", Zc = "[object WeakMap]", Fc = "[object DataView]", YR = kn(Ea), yR = kn(me), BR = kn(xa), zR = kn(ga), LR = kn(ja), Kt = Ln;
(Ea && Kt(new Ea(new ArrayBuffer(1))) != Fc || me && Kt(new me()) != sc || xa && Kt(xa.resolve()) != cc || ga && Kt(new ga()) != Uc || ja && Kt(new ja()) != Zc) && (Kt = function(l) {
  var t = Ln(l), n = t == XR ? l.constructor : void 0, e = n ? kn(n) : "";
  if (e)
    switch (e) {
      case YR:
        return Fc;
      case yR:
        return sc;
      case BR:
        return cc;
      case zR:
        return Uc;
      case LR:
        return Zc;
    }
  return t;
});
var kR = 1, oc = "[object Arguments]", Vc = "[object Array]", je = "[object Object]", IR = Object.prototype, Qc = IR.hasOwnProperty;
function DR(l, t, n, e, d, a) {
  var U = re(l), V = re(t), h = U ? Vc : Kt(l), W = V ? Vc : Kt(t);
  h = h == oc ? je : h, W = W == oc ? je : W;
  var Z = h == je, s = W == je, o = h == W;
  if (o && Vd(l)) {
    if (!Vd(t))
      return !1;
    U = !0, Z = !1;
  }
  if (o && !Z)
    return a || (a = new an()), U || Ri(l) ? $0(l, t, n, e, d, a) : Sh(l, t, h, n, e, d, a);
  if (!(n & kR)) {
    var F = Z && Qc.call(l, "__wrapped__"), N = s && Qc.call(t, "__wrapped__");
    if (F || N) {
      var Q = F ? l.value() : l, u = N ? t.value() : t;
      return a || (a = new an()), d(Q, u, n, e, a);
    }
  }
  return o ? (a || (a = new an()), JR(l, t, n, e, d, a)) : !1;
}
function sZ(l, t, n, e, d) {
  return l === t ? !0 : l == null || t == null || !Sn(l) && !Sn(t) ? l !== l && t !== t : DR(l, t, n, e, sZ, d);
}
function CR(l, t) {
  return sZ(l, t);
}
const wR = {
  align: Object,
  target: [Object, Function],
  onAlign: Function,
  monitorBufferTime: Number,
  monitorWindowResize: Boolean,
  disabled: Boolean
};
function Wc(l) {
  return typeof l != "function" ? null : l();
}
function hc(l) {
  return typeof l != "object" || !l ? null : l;
}
const ER = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Align",
  props: wR,
  emits: ["align"],
  setup(l, t) {
    let {
      expose: n,
      slots: e
    } = t;
    const d = Ml({}), a = Ml(), [U, V] = tW(() => {
      const {
        disabled: o,
        target: F,
        align: N,
        onAlign: Q
      } = l;
      if (!o && F && a.value) {
        const u = a.value;
        let i;
        const c = Wc(F), R = hc(F);
        d.value.element = c, d.value.point = R, d.value.align = N;
        const {
          activeElement: m
        } = document;
        return c && v0(c) ? i = hi(u, c, N) : R && (i = qQ(u, R, N)), lW(m, u), Q && i && Q(u, i), !0;
      }
      return !1;
    }, Zl(() => l.monitorBufferTime)), h = Ml({
      cancel: () => {
      }
    }), W = Ml({
      cancel: () => {
      }
    }), Z = () => {
      const o = l.target, F = Wc(o), N = hc(o);
      a.value !== W.value.element && (W.value.cancel(), W.value.element = a.value, W.value.cancel = Ps(a.value, U)), (d.value.element !== F || !_Q(d.value.point, N) || !CR(d.value.align, l.align)) && (U(), h.value.element !== F && (h.value.cancel(), h.value.element = F, h.value.cancel = Ps(F, U)));
    };
    ql(() => {
      dt(() => {
        Z();
      });
    }), qn(() => {
      dt(() => {
        Z();
      });
    }), Bl(() => l.disabled, (o) => {
      o ? V() : U();
    }, {
      immediate: !0,
      flush: "post"
    });
    const s = Ml(null);
    return Bl(() => l.monitorWindowResize, (o) => {
      o ? s.value || (s.value = It(window, "resize", U)) : s.value && (s.value.remove(), s.value = null);
    }, {
      flush: "post"
    }), Xn(() => {
      h.value.cancel(), W.value.cancel(), s.value && s.value.remove(), V();
    }), n({
      forceAlign: () => U(!0)
    }), () => {
      const o = e?.default();
      return o ? bt(o[0], {
        ref: a
      }, !0, !0) : null;
    };
  }
});
he("bottomLeft", "bottomRight", "topLeft", "topRight");
const xR = (l) => l !== void 0 && (l === "topLeft" || l === "topRight") ? "slide-down" : "slide-up", Ni = function(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return j(l ? {
    name: l,
    appear: !0,
    // type: 'animation',
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    // appearActiveClass: `antdv-base-transtion`,
    // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
    enterFromClass: `${l}-enter ${l}-enter-prepare ${l}-enter-start`,
    enterActiveClass: `${l}-enter ${l}-enter-prepare`,
    enterToClass: `${l}-enter ${l}-enter-active`,
    leaveFromClass: ` ${l}-leave`,
    leaveActiveClass: `${l}-leave ${l}-leave-active`,
    leaveToClass: `${l}-leave ${l}-leave-active`
  } : {
    css: !1
  }, t);
}, An = (l, t, n) => n !== void 0 ? n : `${l}-${t}`, gR = pl({
  compatConfig: {
    MODE: 3
  },
  name: "PopupInner",
  inheritAttrs: !1,
  props: Fi,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(l, t) {
    let {
      expose: n,
      attrs: e,
      slots: d
    } = t;
    const a = bl(), U = bl(), V = bl(), [h, W] = SQ(Ct(l, "stretch")), Z = () => {
      l.stretch && W(l.getRootDomNode());
    }, s = bl(!1);
    let o;
    Bl(() => l.visible, (S) => {
      clearTimeout(o), S ? o = setTimeout(() => {
        s.value = l.visible;
      }) : s.value = !1;
    }, {
      immediate: !0
    });
    const [F, N] = pQ(s, Z), Q = bl(), u = () => l.point ? l.point : l.getRootDomNode, i = () => {
      var S;
      (S = a.value) === null || S === void 0 || S.forceAlign();
    }, c = (S, p) => {
      var Y;
      const k = l.getClassNameFromAlign(p), L = V.value;
      V.value !== k && (V.value = k), F.value === "align" && (L !== k ? Promise.resolve().then(() => {
        i();
      }) : N(() => {
        var z;
        (z = Q.value) === null || z === void 0 || z.call(Q);
      }), (Y = l.onAlign) === null || Y === void 0 || Y.call(l, S, p));
    }, R = Zl(() => {
      const S = typeof l.animation == "object" ? l.animation : k0(l);
      return ["onAfterEnter", "onAfterLeave"].forEach((p) => {
        const Y = S[p];
        S[p] = (k) => {
          N(), F.value = "stable", Y?.(k);
        };
      }), S;
    }), m = () => new Promise((S) => {
      Q.value = S;
    });
    Bl([R, F], () => {
      !R.value && F.value === "motion" && N();
    }, {
      immediate: !0
    }), n({
      forceAlign: i,
      getElement: () => U.value.$el || U.value
    });
    const M = Zl(() => {
      var S;
      return !(!((S = l.align) === null || S === void 0) && S.points && (F.value === "align" || F.value === "stable"));
    });
    return () => {
      var S;
      const {
        zIndex: p,
        align: Y,
        prefixCls: k,
        destroyPopupOnHide: L,
        onMouseenter: z,
        onMouseleave: f,
        onTouchstart: K = () => {
        },
        onMousedown: P
      } = l, w = F.value, O = [j(j({}, h.value), {
        zIndex: p,
        opacity: w === "motion" || w === "stable" || !s.value ? null : 0,
        // pointerEvents: statusValue === 'stable' ? null : 'none',
        pointerEvents: !s.value && w !== "stable" ? "none" : null
      }), e.style];
      let el = Tt((S = d.default) === null || S === void 0 ? void 0 : S.call(d, {
        visible: l.visible
      }));
      el.length > 1 && (el = H("div", {
        class: `${k}-content`
      }, [el]));
      const ll = Xl(k, e.class, V.value, !l.arrow && `${k}-arrow-hidden`), _ = s.value || !l.visible ? Ni(R.value.name, R.value) : {};
      return H(Yn, Ql(Ql({
        ref: U
      }, _), {}, {
        onBeforeEnter: m
      }), {
        default: () => !L || l.visible ? ud(H(ER, {
          target: u(),
          key: "popup",
          ref: a,
          monitorWindowResize: !0,
          disabled: M.value,
          align: Y,
          onAlign: c
        }, {
          default: () => H("div", {
            class: ll,
            onMouseenter: z,
            onMouseleave: f,
            onMousedown: es(P, ["capture"]),
            [Rt ? "onTouchstartPassive" : "onTouchstart"]: es(K, ["capture"]),
            style: O
          }, [el])
        }), [[ei, s.value]]) : null
      });
    };
  }
}), jR = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Popup",
  inheritAttrs: !1,
  props: uQ,
  setup(l, t) {
    let {
      attrs: n,
      slots: e,
      expose: d
    } = t;
    const a = bl(!1), U = bl(!1), V = bl(), h = bl();
    return Bl([() => l.visible, () => l.mobile], () => {
      a.value = l.visible, l.visible && l.mobile && (U.value = !0);
    }, {
      immediate: !0,
      flush: "post"
    }), d({
      forceAlign: () => {
        var W;
        (W = V.value) === null || W === void 0 || W.forceAlign();
      },
      getElement: () => {
        var W;
        return (W = V.value) === null || W === void 0 ? void 0 : W.getElement();
      }
    }), () => {
      const W = j(j(j({}, l), n), {
        visible: a.value
      }), Z = U.value ? H(rQ, Ql(Ql({}, W), {}, {
        mobile: l.mobile,
        ref: V
      }), {
        default: e.default
      }) : H(gR, Ql(Ql({}, W), {}, {
        ref: V
      }), {
        default: e.default
      });
      return H("div", {
        ref: h
      }, [H(I0, W, null), Z]);
    };
  }
});
function OR(l, t, n) {
  return n ? l[0] === t[0] : l[0] === t[0] && l[1] === t[1];
}
function Rc(l, t, n) {
  const e = l[t] || {};
  return j(j({}, e), n);
}
function vR(l, t, n, e) {
  const {
    points: d
  } = n, a = Object.keys(l);
  for (let U = 0; U < a.length; U += 1) {
    const V = a[U];
    if (OR(l[V].points, d, e))
      return `${t}-placement-${V}`;
  }
  return "";
}
const cZ = {
  methods: {
    setState() {
      let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = typeof l == "function" ? l(this.$data, this.$props) : l;
      if (this.getDerivedStateFromProps) {
        const e = this.getDerivedStateFromProps(Go(this), j(j({}, this.$data), n));
        if (e === null)
          return;
        n = j(j({}, n), e || {});
      }
      j(this.$data, n), this._.isMounted && this.$forceUpdate(), dt(() => {
        t && t();
      });
    },
    __emit() {
      const l = [].slice.call(arguments, 0);
      let t = l[0];
      t = `on${t[0].toUpperCase()}${t.substring(1)}`;
      const n = this.$props[t] || this.$attrs[t];
      if (l.length && n)
        if (Array.isArray(n))
          for (let e = 0, d = n.length; e < d; e++)
            n[e](...l.slice(1));
        else
          n(...l.slice(1));
    }
  }
}, UZ = Symbol("PortalContextKey"), bi = function(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inTriggerContext: !0
  };
  nt(UZ, {
    inTriggerContext: t.inTriggerContext,
    shouldRender: Zl(() => {
      const {
        sPopupVisible: n,
        popupRef: e,
        forceRender: d,
        autoDestroy: a
      } = l || {};
      let U = !1;
      return (n || e || d) && (U = !0), !n && a && (U = !1), U;
    })
  });
}, fR = () => {
  bi({}, {
    inTriggerContext: !1
  });
  const l = fl(UZ, {
    shouldRender: Zl(() => !1),
    inTriggerContext: !1
  });
  return {
    shouldRender: Zl(() => l.shouldRender.value || l.inTriggerContext === !1)
  };
}, KR = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Portal",
  inheritAttrs: !1,
  props: {
    getContainer: ol.func.isRequired,
    didUpdate: Function
  },
  setup(l, t) {
    let {
      slots: n
    } = t, e = !0, d;
    const {
      shouldRender: a
    } = fR();
    function U() {
      a.value && (d = l.getContainer());
    }
    NF(() => {
      e = !1, U();
    }), ql(() => {
      d || U();
    });
    const V = Bl(a, () => {
      a.value && !d && (d = l.getContainer()), d && V();
    });
    return qn(() => {
      dt(() => {
        var h;
        a.value && ((h = l.didUpdate) === null || h === void 0 || h.call(l, l));
      });
    }), () => {
      var h;
      return a.value ? e ? (h = n.default) === null || h === void 0 ? void 0 : h.call(n) : d ? H(bF, {
        to: d
      }, n) : null : null;
    };
  }
});
let Ua;
function HR(l) {
  if (typeof document > "u")
    return 0;
  if (Ua === void 0) {
    const t = document.createElement("div");
    t.style.width = "100%", t.style.height = "200px";
    const n = document.createElement("div"), e = n.style;
    e.position = "absolute", e.top = "0", e.left = "0", e.pointerEvents = "none", e.visibility = "hidden", e.width = "200px", e.height = "150px", e.overflow = "hidden", n.appendChild(t), document.body.appendChild(n);
    const d = t.offsetWidth;
    n.style.overflow = "scroll";
    let a = t.offsetWidth;
    d === a && (a = n.clientWidth), document.body.removeChild(n), Ua = d - a;
  }
  return Ua;
}
const PR = `vc-util-locker-${Date.now()}`;
let Nc = 0;
function AR() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
function $R(l) {
  const t = Zl(() => !!l && !!l.value);
  Nc += 1;
  const n = `${PR}_${Nc}`;
  it((e) => {
    if (xt()) {
      if (t.value) {
        const d = HR(), a = AR();
        id(`
html body {
  overflow-y: hidden;
  ${a ? `width: calc(100% - ${d}px);` : ""}
}`, n);
      } else
        ad(n);
      e(() => {
        ad(n);
      });
    }
  }, {
    flush: "post"
  });
}
let on = 0;
const He = xt(), bc = (l) => {
  if (!He)
    return null;
  if (l) {
    if (typeof l == "string")
      return document.querySelectorAll(l)[0];
    if (typeof l == "function")
      return l();
    if (typeof l == "object" && l instanceof window.HTMLElement)
      return l;
  }
  return document.body;
}, ZZ = pl({
  compatConfig: {
    MODE: 3
  },
  name: "PortalWrapper",
  inheritAttrs: !1,
  props: {
    wrapperClassName: String,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: ol.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    autoLock: zt(),
    didUpdate: Function
  },
  setup(l, t) {
    let {
      slots: n
    } = t;
    const e = bl(), d = bl(), a = bl(), U = bl(1), V = xt() && document.createElement("div"), h = () => {
      var F, N;
      e.value === V && ((N = (F = e.value) === null || F === void 0 ? void 0 : F.parentNode) === null || N === void 0 || N.removeChild(e.value)), e.value = null;
    };
    let W = null;
    const Z = function() {
      return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) || e.value && !e.value.parentNode ? (W = bc(l.getContainer), W ? (W.appendChild(e.value), !0) : !1) : !0;
    }, s = () => He ? (e.value || (e.value = V, Z(!0)), o(), e.value) : null, o = () => {
      const {
        wrapperClassName: F
      } = l;
      e.value && F && F !== e.value.className && (e.value.className = F);
    };
    return qn(() => {
      o(), Z();
    }), $R(Zl(() => l.autoLock && l.visible && xt() && (e.value === document.body || e.value === V))), ql(() => {
      let F = !1;
      Bl([() => l.visible, () => l.getContainer], (N, Q) => {
        let [u, i] = N, [c, R] = Q;
        He && (W = bc(l.getContainer), W === document.body && (u && !c ? on += 1 : F && (on -= 1))), F && (typeof i == "function" && typeof R == "function" ? i.toString() !== R.toString() : i !== R) && h(), F = !0;
      }, {
        immediate: !0,
        flush: "post"
      }), dt(() => {
        Z() || (a.value = Ol(() => {
          U.value += 1;
        }));
      });
    }), Wt(() => {
      const {
        visible: F
      } = l;
      He && W === document.body && (on = F && on ? on - 1 : on), h(), Ol.cancel(a.value);
    }), () => {
      const {
        forceRender: F,
        visible: N
      } = l;
      let Q = null;
      const u = {
        getOpenCount: () => on,
        getContainer: s
      };
      return U.value && (F || N || d.value) && (Q = H(KR, {
        getContainer: s,
        ref: d,
        didUpdate: l.didUpdate
      }, {
        default: () => {
          var i;
          return (i = n.default) === null || i === void 0 ? void 0 : i.call(n, u);
        }
      })), Q;
    };
  }
}), qR = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"], FZ = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Trigger",
  mixins: [cZ],
  inheritAttrs: !1,
  props: bQ(),
  setup(l) {
    const t = Zl(() => {
      const {
        popupPlacement: d,
        popupAlign: a,
        builtinPlacements: U
      } = l;
      return d && U ? Rc(U, d, a) : a;
    }), n = bl(null), e = (d) => {
      n.value = d;
    };
    return {
      vcTriggerContext: fl("vcTriggerContext", {}),
      popupRef: n,
      setPopupRef: e,
      triggerRef: bl(null),
      align: t,
      focusTime: null,
      clickOutsideHandler: null,
      contextmenuOutsideHandler1: null,
      contextmenuOutsideHandler2: null,
      touchOutsideHandler: null,
      attachId: null,
      delayTimer: null,
      hasPopupMouseDown: !1,
      preClickTime: null,
      preTouchTime: null,
      mouseDownTimeout: null,
      childOriginEvents: {}
    };
  },
  data() {
    const l = this.$props;
    let t;
    return this.popupVisible !== void 0 ? t = !!l.popupVisible : t = !!l.defaultPopupVisible, qR.forEach((n) => {
      this[`fire${n}`] = (e) => {
        this.fireEvents(n, e);
      };
    }), {
      prevPopupVisible: t,
      sPopupVisible: t,
      point: null
    };
  },
  watch: {
    popupVisible(l) {
      l !== void 0 && (this.prevPopupVisible = this.sPopupVisible, this.sPopupVisible = l);
    }
  },
  created() {
    nt("vcTriggerContext", {
      onPopupMouseDown: this.onPopupMouseDown,
      onPopupMouseenter: this.onPopupMouseenter,
      onPopupMouseleave: this.onPopupMouseleave
    }), bi(this);
  },
  deactivated() {
    this.setPopupVisible(!1);
  },
  mounted() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  updated() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  beforeUnmount() {
    this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), Ol.cancel(this.attachId);
  },
  methods: {
    updatedCal() {
      const l = this.$props;
      if (this.$data.sPopupVisible) {
        let n;
        !this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow()) && (n = l.getDocument(this.getRootDomNode()), this.clickOutsideHandler = It(n, "mousedown", this.onDocumentClick)), this.touchOutsideHandler || (n = n || l.getDocument(this.getRootDomNode()), this.touchOutsideHandler = It(n, "touchstart", this.onDocumentClick, Rt ? {
          passive: !1
        } : !1)), !this.contextmenuOutsideHandler1 && this.isContextmenuToShow() && (n = n || l.getDocument(this.getRootDomNode()), this.contextmenuOutsideHandler1 = It(n, "scroll", this.onContextmenuClose)), !this.contextmenuOutsideHandler2 && this.isContextmenuToShow() && (this.contextmenuOutsideHandler2 = It(window, "blur", this.onContextmenuClose));
      } else
        this.clearOutsideHandler();
    },
    onMouseenter(l) {
      const {
        mouseEnterDelay: t
      } = this.$props;
      this.fireEvents("onMouseenter", l), this.delaySetPopupVisible(!0, t, t ? null : l);
    },
    onMouseMove(l) {
      this.fireEvents("onMousemove", l), this.setPoint(l);
    },
    onMouseleave(l) {
      this.fireEvents("onMouseleave", l), this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter() {
      const {
        vcTriggerContext: l = {}
      } = this;
      l.onPopupMouseenter && l.onPopupMouseenter(), this.clearDelayTimer();
    },
    onPopupMouseleave(l) {
      var t;
      if (l && l.relatedTarget && !l.relatedTarget.setTimeout && tn((t = this.popupRef) === null || t === void 0 ? void 0 : t.getElement(), l.relatedTarget))
        return;
      this.isMouseLeaveToHide() && this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
      const {
        vcTriggerContext: n = {}
      } = this;
      n.onPopupMouseleave && n.onPopupMouseleave(l);
    },
    onFocus(l) {
      this.fireEvents("onFocus", l), this.clearDelayTimer(), this.isFocusToShow() && (this.focusTime = Date.now(), this.delaySetPopupVisible(!0, this.$props.focusDelay));
    },
    onMousedown(l) {
      this.fireEvents("onMousedown", l), this.preClickTime = Date.now();
    },
    onTouchstart(l) {
      this.fireEvents("onTouchstart", l), this.preTouchTime = Date.now();
    },
    onBlur(l) {
      tn(l.target, l.relatedTarget || document.activeElement) || (this.fireEvents("onBlur", l), this.clearDelayTimer(), this.isBlurToHide() && this.delaySetPopupVisible(!1, this.$props.blurDelay));
    },
    onContextmenu(l) {
      l.preventDefault(), this.fireEvents("onContextmenu", l), this.setPopupVisible(!0, l);
    },
    onContextmenuClose() {
      this.isContextmenuToShow() && this.close();
    },
    onClick(l) {
      if (this.fireEvents("onClick", l), this.focusTime) {
        let n;
        if (this.preClickTime && this.preTouchTime ? n = Math.min(this.preClickTime, this.preTouchTime) : this.preClickTime ? n = this.preClickTime : this.preTouchTime && (n = this.preTouchTime), Math.abs(n - this.focusTime) < 20)
          return;
        this.focusTime = 0;
      }
      this.preClickTime = 0, this.preTouchTime = 0, this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && l && l.preventDefault && l.preventDefault(), l && l.domEvent && l.domEvent.preventDefault();
      const t = !this.$data.sPopupVisible;
      (this.isClickToHide() && !t || t && this.isClickToShow()) && this.setPopupVisible(!this.$data.sPopupVisible, l);
    },
    onPopupMouseDown() {
      const {
        vcTriggerContext: l = {}
      } = this;
      this.hasPopupMouseDown = !0, clearTimeout(this.mouseDownTimeout), this.mouseDownTimeout = setTimeout(() => {
        this.hasPopupMouseDown = !1;
      }, 0), l.onPopupMouseDown && l.onPopupMouseDown(...arguments);
    },
    onDocumentClick(l) {
      if (this.$props.mask && !this.$props.maskClosable)
        return;
      const t = l.target, n = this.getRootDomNode(), e = this.getPopupDomNode();
      // mousedown on the target should also close popup when action is contextMenu.
      // https://github.com/ant-design/ant-design/issues/29853
      (!tn(n, t) || this.isContextMenuOnly()) && !tn(e, t) && !this.hasPopupMouseDown && this.delaySetPopupVisible(!1, 0.1);
    },
    getPopupDomNode() {
      var l;
      return ((l = this.popupRef) === null || l === void 0 ? void 0 : l.getElement()) || null;
    },
    getRootDomNode() {
      var l, t, n, e;
      const {
        getTriggerDOMNode: d
      } = this.$props;
      if (d) {
        const a = ((t = (l = this.triggerRef) === null || l === void 0 ? void 0 : l.$el) === null || t === void 0 ? void 0 : t.nodeName) === "#comment" ? null : en(this.triggerRef);
        return en(d(a));
      }
      try {
        const a = ((e = (n = this.triggerRef) === null || n === void 0 ? void 0 : n.$el) === null || e === void 0 ? void 0 : e.nodeName) === "#comment" ? null : en(this.triggerRef);
        if (a)
          return a;
      } catch {
      }
      return en(this);
    },
    handleGetPopupClassFromAlign(l) {
      const t = [], n = this.$props, {
        popupPlacement: e,
        builtinPlacements: d,
        prefixCls: a,
        alignPoint: U,
        getPopupClassNameFromAlign: V
      } = n;
      return e && d && t.push(vR(d, a, l, U)), V && t.push(V(l)), t.join(" ");
    },
    getPopupAlign() {
      const l = this.$props, {
        popupPlacement: t,
        popupAlign: n,
        builtinPlacements: e
      } = l;
      return t && e ? Rc(e, t, n) : n;
    },
    getComponent() {
      const l = {};
      this.isMouseEnterToShow() && (l.onMouseenter = this.onPopupMouseenter), this.isMouseLeaveToHide() && (l.onMouseleave = this.onPopupMouseleave), l.onMousedown = this.onPopupMouseDown, l[Rt ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
      const {
        handleGetPopupClassFromAlign: t,
        getRootDomNode: n,
        $attrs: e
      } = this, {
        prefixCls: d,
        destroyPopupOnHide: a,
        popupClassName: U,
        popupAnimation: V,
        popupTransitionName: h,
        popupStyle: W,
        mask: Z,
        maskAnimation: s,
        maskTransitionName: o,
        zIndex: F,
        stretch: N,
        alignPoint: Q,
        mobile: u,
        arrow: i,
        forceRender: c
      } = this.$props, {
        sPopupVisible: R,
        point: m
      } = this.$data, M = j(j({
        prefixCls: d,
        arrow: i,
        destroyPopupOnHide: a,
        visible: R,
        point: Q ? m : null,
        align: this.align,
        animation: V,
        getClassNameFromAlign: t,
        stretch: N,
        getRootDomNode: n,
        mask: Z,
        zIndex: F,
        transitionName: h,
        maskAnimation: s,
        maskTransitionName: o,
        class: U,
        style: W,
        onAlign: e.onPopupAlign || L0
      }, l), {
        ref: this.setPopupRef,
        mobile: u,
        forceRender: c
      });
      return H(jR, M, {
        default: this.$slots.popup || (() => OU(this, "popup"))
      });
    },
    attachParent(l) {
      Ol.cancel(this.attachId);
      const {
        getPopupContainer: t,
        getDocument: n
      } = this.$props, e = this.getRootDomNode();
      let d;
      t ? (e || t.length === 0) && (d = t(e)) : d = n(this.getRootDomNode()).body, d ? d.appendChild(l) : this.attachId = Ol(() => {
        this.attachParent(l);
      });
    },
    getContainer() {
      const {
        $props: l
      } = this, {
        getDocument: t
      } = l, n = t(this.getRootDomNode()).createElement("div");
      return n.style.position = "absolute", n.style.top = "0", n.style.left = "0", n.style.width = "100%", this.attachParent(n), n;
    },
    setPopupVisible(l, t) {
      const {
        alignPoint: n,
        sPopupVisible: e,
        onPopupVisibleChange: d
      } = this;
      this.clearDelayTimer(), e !== l && (xn(this, "popupVisible") || this.setState({
        sPopupVisible: l,
        prevPopupVisible: e
      }), d && d(l)), n && t && l && this.setPoint(t);
    },
    setPoint(l) {
      const {
        alignPoint: t
      } = this.$props;
      !t || !l || this.setState({
        point: {
          pageX: l.pageX,
          pageY: l.pageY
        }
      });
    },
    handlePortalUpdate() {
      this.prevPopupVisible !== this.sPopupVisible && this.afterPopupVisibleChange(this.sPopupVisible);
    },
    delaySetPopupVisible(l, t, n) {
      const e = t * 1e3;
      if (this.clearDelayTimer(), e) {
        const d = n ? {
          pageX: n.pageX,
          pageY: n.pageY
        } : null;
        this.delayTimer = setTimeout(() => {
          this.setPopupVisible(l, d), this.clearDelayTimer();
        }, e);
      } else
        this.setPopupVisible(l, n);
    },
    clearDelayTimer() {
      this.delayTimer && (clearTimeout(this.delayTimer), this.delayTimer = null);
    },
    clearOutsideHandler() {
      this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null), this.contextmenuOutsideHandler1 && (this.contextmenuOutsideHandler1.remove(), this.contextmenuOutsideHandler1 = null), this.contextmenuOutsideHandler2 && (this.contextmenuOutsideHandler2.remove(), this.contextmenuOutsideHandler2 = null), this.touchOutsideHandler && (this.touchOutsideHandler.remove(), this.touchOutsideHandler = null);
    },
    createTwoChains(l) {
      let t = () => {
      };
      const n = Rs(this);
      return this.childOriginEvents[l] && n[l] ? this[`fire${l}`] : (t = this.childOriginEvents[l] || n[l] || t, t);
    },
    isClickToShow() {
      const {
        action: l,
        showAction: t
      } = this.$props;
      return l.indexOf("click") !== -1 || t.indexOf("click") !== -1;
    },
    isContextMenuOnly() {
      const {
        action: l
      } = this.$props;
      return l === "contextmenu" || l.length === 1 && l[0] === "contextmenu";
    },
    isContextmenuToShow() {
      const {
        action: l,
        showAction: t
      } = this.$props;
      return l.indexOf("contextmenu") !== -1 || t.indexOf("contextmenu") !== -1;
    },
    isClickToHide() {
      const {
        action: l,
        hideAction: t
      } = this.$props;
      return l.indexOf("click") !== -1 || t.indexOf("click") !== -1;
    },
    isMouseEnterToShow() {
      const {
        action: l,
        showAction: t
      } = this.$props;
      return l.indexOf("hover") !== -1 || t.indexOf("mouseenter") !== -1;
    },
    isMouseLeaveToHide() {
      const {
        action: l,
        hideAction: t
      } = this.$props;
      return l.indexOf("hover") !== -1 || t.indexOf("mouseleave") !== -1;
    },
    isFocusToShow() {
      const {
        action: l,
        showAction: t
      } = this.$props;
      return l.indexOf("focus") !== -1 || t.indexOf("focus") !== -1;
    },
    isBlurToHide() {
      const {
        action: l,
        hideAction: t
      } = this.$props;
      return l.indexOf("focus") !== -1 || t.indexOf("blur") !== -1;
    },
    forcePopupAlign() {
      var l;
      this.$data.sPopupVisible && ((l = this.popupRef) === null || l === void 0 || l.forceAlign());
    },
    fireEvents(l, t) {
      this.childOriginEvents[l] && this.childOriginEvents[l](t);
      const n = this.$props[l] || this.$attrs[l];
      n && n(t);
    },
    close() {
      this.setPopupVisible(!1);
    }
  },
  render() {
    const {
      $attrs: l
    } = this, t = Bn(To(this)), {
      alignPoint: n,
      getPopupContainer: e
    } = this.$props, d = t[0];
    this.childOriginEvents = Rs(d);
    const a = {
      key: "trigger"
    };
    this.isContextmenuToShow() ? a.onContextmenu = this.onContextmenu : a.onContextmenu = this.createTwoChains("onContextmenu"), this.isClickToHide() || this.isClickToShow() ? (a.onClick = this.onClick, a.onMousedown = this.onMousedown, a[Rt ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart) : (a.onClick = this.createTwoChains("onClick"), a.onMousedown = this.createTwoChains("onMousedown"), a[Rt ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart")), this.isMouseEnterToShow() ? (a.onMouseenter = this.onMouseenter, n && (a.onMousemove = this.onMouseMove)) : a.onMouseenter = this.createTwoChains("onMouseenter"), this.isMouseLeaveToHide() ? a.onMouseleave = this.onMouseleave : a.onMouseleave = this.createTwoChains("onMouseleave"), this.isFocusToShow() || this.isBlurToHide() ? (a.onFocus = this.onFocus, a.onBlur = this.onBlur) : (a.onFocus = this.createTwoChains("onFocus"), a.onBlur = (W) => {
      W && (!W.relatedTarget || !tn(W.target, W.relatedTarget)) && this.createTwoChains("onBlur")(W);
    });
    const U = Xl(d && d.props && d.props.class, l.class);
    U && (a.class = U);
    const V = bt(d, j(j({}, a), {
      ref: "triggerRef"
    }), !0, !0), h = H(ZZ, {
      key: "portal",
      getContainer: e && (() => e(this.getRootDomNode())),
      didUpdate: this.handlePortalUpdate,
      visible: this.$data.sPopupVisible
    }, {
      default: this.getComponent
    });
    return H(st, null, [V, h]);
  }
});
var _R = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const lN = (l) => {
  const t = l === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    }
  };
}, tN = pl({
  name: "SelectTrigger",
  inheritAttrs: !1,
  props: {
    dropdownAlign: Object,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownStyle: ol.object,
    placement: String,
    empty: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    popupClassName: String,
    animation: String,
    transitionName: String,
    getPopupContainer: Function,
    dropdownRender: Function,
    containerWidth: Number,
    dropdownMatchSelectWidth: ol.oneOfType([Number, Boolean]).def(!0),
    popupElement: ol.any,
    direction: String,
    getTriggerDOMNode: Function,
    onPopupVisibleChange: Function,
    onPopupMouseEnter: Function,
    onPopupFocusin: Function,
    onPopupFocusout: Function
  },
  setup(l, t) {
    let {
      slots: n,
      attrs: e,
      expose: d
    } = t;
    const a = Zl(() => {
      const {
        dropdownMatchSelectWidth: V
      } = l;
      return lN(V);
    }), U = Ml();
    return d({
      getPopupElement: () => U.value
    }), () => {
      const V = j(j({}, l), e), {
        empty: h = !1
      } = V, W = _R(V, ["empty"]), {
        visible: Z,
        dropdownAlign: s,
        prefixCls: o,
        popupElement: F,
        dropdownClassName: N,
        dropdownStyle: Q,
        direction: u = "ltr",
        placement: i,
        dropdownMatchSelectWidth: c,
        containerWidth: R,
        dropdownRender: m,
        animation: M,
        transitionName: S,
        getPopupContainer: p,
        getTriggerDOMNode: Y,
        onPopupVisibleChange: k,
        onPopupMouseEnter: L,
        onPopupFocusin: z,
        onPopupFocusout: f
      } = W, K = `${o}-dropdown`;
      let P = F;
      m && (P = m({
        menuNode: F,
        props: l
      }));
      const w = M ? `${K}-${M}` : S, O = j({
        minWidth: `${R}px`
      }, Q);
      return typeof c == "number" ? O.width = `${c}px` : c && (O.width = `${R}px`), H(FZ, Ql(Ql({}, l), {}, {
        showAction: k ? ["click"] : [],
        hideAction: k ? ["click"] : [],
        popupPlacement: i || (u === "rtl" ? "bottomRight" : "bottomLeft"),
        builtinPlacements: a.value,
        prefixCls: K,
        popupTransitionName: w,
        popupAlign: s,
        popupVisible: Z,
        getPopupContainer: p,
        popupClassName: Xl(N, {
          [`${K}-empty`]: h
        }),
        popupStyle: O,
        getTriggerDOMNode: Y,
        onPopupVisibleChange: k
      }), {
        default: n.default,
        popup: () => H("div", {
          ref: U,
          onMouseenter: L,
          onFocusin: z,
          onFocusout: f
        }, [P])
      });
    };
  }
}), ul = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  /**
   * END
   */
  END: 35,
  /**
   * HOME
   */
  HOME: 36,
  /**
   * LEFT
   */
  LEFT: 37,
  /**
   * UP
   */
  UP: 38,
  /**
   * RIGHT
   */
  RIGHT: 39,
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  /**
   * DELETE
   */
  DELETE: 46,
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  /**
   * DASH
   */
  DASH: 189,
  /**
   * EQUALS
   */
  EQUALS: 187,
  /**
   * COMMA
   */
  COMMA: 188,
  /**
   * PERIOD
   */
  PERIOD: 190,
  /**
   * SLASH
   */
  SLASH: 191,
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(t) {
    const {
      keyCode: n
    } = t;
    if (t.altKey && !t.ctrlKey || t.metaKey || // Function keys don't generate text
    n >= ul.F1 && n <= ul.F12)
      return !1;
    switch (n) {
      case ul.ALT:
      case ul.CAPS_LOCK:
      case ul.CONTEXT_MENU:
      case ul.CTRL:
      case ul.DOWN:
      case ul.END:
      case ul.ESC:
      case ul.HOME:
      case ul.INSERT:
      case ul.LEFT:
      case ul.MAC_FF_META:
      case ul.META:
      case ul.NUMLOCK:
      case ul.NUM_CENTER:
      case ul.PAGE_DOWN:
      case ul.PAGE_UP:
      case ul.PAUSE:
      case ul.PRINT_SCREEN:
      case ul.RIGHT:
      case ul.SHIFT:
      case ul.UP:
      case ul.WIN_KEY:
      case ul.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(t) {
    if (t >= ul.ZERO && t <= ul.NINE || t >= ul.NUM_ZERO && t <= ul.NUM_MULTIPLY || t >= ul.A && t <= ul.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && t === 0)
      return !0;
    switch (t) {
      case ul.SPACE:
      case ul.QUESTION_MARK:
      case ul.NUM_PLUS:
      case ul.NUM_MINUS:
      case ul.NUM_PERIOD:
      case ul.NUM_DIVISION:
      case ul.SEMICOLON:
      case ul.DASH:
      case ul.EQUALS:
      case ul.COMMA:
      case ul.PERIOD:
      case ul.SLASH:
      case ul.APOSTROPHE:
      case ul.SINGLE_QUOTE:
      case ul.OPEN_SQUARE_BRACKET:
      case ul.BACKSLASH:
      case ul.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
}, Tn = (l, t) => {
  let {
    slots: n
  } = t;
  var e;
  const {
    class: d,
    customizeIcon: a,
    customizeIconProps: U,
    onMousedown: V,
    onClick: h
  } = l;
  let W;
  return typeof a == "function" ? W = a(U) : W = $n(a) ? rd(a) : a, H("span", {
    class: d,
    onMousedown: (Z) => {
      Z.preventDefault(), V && V(Z);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick: h,
    "aria-hidden": !0
  }, [W !== void 0 ? W : H("span", {
    class: d.split(/\s+/).map((Z) => `${Z}-icon`)
  }, [(e = n.default) === null || e === void 0 ? void 0 : e.call(n)])]);
};
Tn.inheritAttrs = !1;
Tn.displayName = "TransBtn";
Tn.props = {
  class: String,
  customizeIcon: ol.any,
  customizeIconProps: ol.any,
  onMousedown: Function,
  onClick: Function
};
var nN = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const ye = pl({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: {
    disabled: ol.looseBool,
    type: ol.string,
    value: ol.any,
    lazy: ol.bool.def(!0),
    tag: {
      type: String,
      default: "input"
    },
    size: ol.string
  },
  emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup"],
  setup(l, t) {
    let {
      emit: n,
      attrs: e,
      expose: d
    } = t;
    const a = bl(null), U = Ml(), V = Ml(!1);
    Bl([() => l.value, V], () => {
      V.value || (U.value = l.value);
    }, {
      immediate: !0
    });
    const h = (m) => {
      n("change", m);
    }, W = (m) => {
      V.value = !0, m.target.composing = !0, n("compositionstart", m);
    }, Z = (m) => {
      V.value = !1, m.target.composing = !1, n("compositionend", m);
      const M = document.createEvent("HTMLEvents");
      M.initEvent("input", !0, !0), m.target.dispatchEvent(M);
    }, s = (m) => {
      if (V.value && l.lazy) {
        U.value = m.target.value;
        return;
      }
      n("input", m);
    }, o = (m) => {
      n("blur", m);
    }, F = (m) => {
      n("focus", m);
    }, N = () => {
      a.value && a.value.focus();
    }, Q = () => {
      a.value && a.value.blur();
    }, u = (m) => {
      n("keydown", m);
    }, i = (m) => {
      n("keyup", m);
    };
    return d({
      focus: N,
      blur: Q,
      input: a,
      setSelectionRange: (m, M, S) => {
        var p;
        (p = a.value) === null || p === void 0 || p.setSelectionRange(m, M, S);
      },
      select: () => {
        var m;
        (m = a.value) === null || m === void 0 || m.select();
      },
      getSelectionStart: () => {
        var m;
        return (m = a.value) === null || m === void 0 ? void 0 : m.selectionStart;
      },
      getSelectionEnd: () => {
        var m;
        return (m = a.value) === null || m === void 0 ? void 0 : m.selectionEnd;
      },
      getScrollTop: () => {
        var m;
        return (m = a.value) === null || m === void 0 ? void 0 : m.scrollTop;
      }
    }), () => {
      const {
        tag: m
      } = l, M = nN(l, ["tag"]);
      return H(m, Ql(Ql(Ql({}, M), e), {}, {
        onInput: s,
        onChange: h,
        onBlur: o,
        onFocus: F,
        ref: a,
        value: U.value,
        onCompositionstart: W,
        onCompositionend: Z,
        onKeyup: i,
        onKeydown: u
      }), null);
    };
  }
}), eN = {
  inputRef: ol.any,
  prefixCls: String,
  id: String,
  inputElement: ol.VueNode,
  disabled: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  editable: {
    type: Boolean,
    default: void 0
  },
  activeDescendantId: String,
  value: String,
  open: {
    type: Boolean,
    default: void 0
  },
  tabindex: ol.oneOfType([ol.number, ol.string]),
  /** Pass accessibility props to input */
  attrs: ol.object,
  onKeydown: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPaste: {
    type: Function
  },
  onCompositionstart: {
    type: Function
  },
  onCompositionend: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  }
}, oZ = pl({
  compatConfig: {
    MODE: 3
  },
  name: "SelectInput",
  inheritAttrs: !1,
  props: eN,
  setup(l) {
    let t = null;
    const n = fl("VCSelectContainerEvent");
    return () => {
      var e;
      const {
        prefixCls: d,
        id: a,
        inputElement: U,
        disabled: V,
        tabindex: h,
        autofocus: W,
        autocomplete: Z,
        editable: s,
        activeDescendantId: o,
        value: F,
        onKeydown: N,
        onMousedown: Q,
        onChange: u,
        onPaste: i,
        onCompositionstart: c,
        onCompositionend: R,
        onFocus: m,
        onBlur: M,
        open: S,
        inputRef: p,
        attrs: Y
      } = l;
      let k = U || H(ye, null, null);
      const L = k.props || {}, {
        onKeydown: z,
        onInput: f,
        onFocus: K,
        onBlur: P,
        onMousedown: w,
        onCompositionstart: O,
        onCompositionend: el,
        style: ll
      } = L;
      return k = bt(k, j(j(j(j(j({
        type: "search"
      }, L), {
        id: a,
        ref: p,
        disabled: V,
        tabindex: h,
        autocomplete: Z || "off",
        autofocus: W,
        class: Xl(`${d}-selection-search-input`, (e = k?.props) === null || e === void 0 ? void 0 : e.class),
        role: "combobox",
        "aria-expanded": S,
        "aria-haspopup": "listbox",
        "aria-owns": `${a}_list`,
        "aria-autocomplete": "list",
        "aria-controls": `${a}_list`,
        "aria-activedescendant": o
      }), Y), {
        value: s ? F : "",
        readonly: !s,
        unselectable: s ? null : "on",
        style: j(j({}, ll), {
          opacity: s ? null : 0
        }),
        onKeydown: (q) => {
          N(q), z && z(q);
        },
        onMousedown: (q) => {
          Q(q), w && w(q);
        },
        onInput: (q) => {
          u(q), f && f(q);
        },
        onCompositionstart(q) {
          c(q), O && O(q);
        },
        onCompositionend(q) {
          R(q), el && el(q);
        },
        onPaste: i,
        onFocus: function() {
          clearTimeout(t), K && K(arguments.length <= 0 ? void 0 : arguments[0]), m && m(arguments.length <= 0 ? void 0 : arguments[0]), n?.focus(arguments.length <= 0 ? void 0 : arguments[0]);
        },
        onBlur: function() {
          for (var q = arguments.length, _ = new Array(q), il = 0; il < q; il++)
            _[il] = arguments[il];
          t = setTimeout(() => {
            P && P(_[0]), M && M(_[0]), n?.blur(_[0]);
          }, 100);
        }
      }), k.type === "textarea" ? {} : {
        type: "search"
      }), !0, !0), k;
    };
  }
}), dN = `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`, aN = `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`, mc = `${dN} ${aN}`.split(/[\s\n]+/), iN = "aria-", sN = "data-";
function uc(l, t) {
  return l.indexOf(t) === 0;
}
function zd(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n;
  t === !1 ? n = {
    aria: !0,
    data: !0,
    attr: !0
  } : t === !0 ? n = {
    aria: !0
  } : n = j({}, t);
  const e = {};
  return Object.keys(l).forEach((d) => {
    // Aria
    (n.aria && (d === "role" || uc(d, iN)) || // Data
    n.data && uc(d, sN) || // Attr
    n.attr && (mc.includes(d) || mc.includes(d.toLowerCase()))) && (e[d] = l[d]);
  }), e;
}
const VZ = Symbol("OverflowContextProviderKey"), Oa = pl({
  compatConfig: {
    MODE: 3
  },
  name: "OverflowContextProvider",
  inheritAttrs: !1,
  props: {
    value: {
      type: Object
    }
  },
  setup(l, t) {
    let {
      slots: n
    } = t;
    return nt(VZ, Zl(() => l.value)), () => {
      var e;
      return (e = n.default) === null || e === void 0 ? void 0 : e.call(n);
    };
  }
}), cN = () => fl(VZ, Zl(() => null));
var UN = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const Cn = void 0, Pe = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Item",
  props: {
    prefixCls: String,
    item: ol.any,
    renderItem: Function,
    responsive: Boolean,
    itemKey: {
      type: [String, Number]
    },
    registerSize: Function,
    display: Boolean,
    order: Number,
    component: ol.any,
    invalidate: Boolean
  },
  setup(l, t) {
    let {
      slots: n,
      expose: e
    } = t;
    const d = Zl(() => l.responsive && !l.display), a = Ml();
    e({
      itemNodeRef: a
    });
    function U(V) {
      l.registerSize(l.itemKey, V);
    }
    return Xn(() => {
      U(null);
    }), () => {
      var V;
      const {
        prefixCls: h,
        invalidate: W,
        item: Z,
        renderItem: s,
        responsive: o,
        registerSize: F,
        itemKey: N,
        display: Q,
        order: u,
        component: i = "div"
      } = l, c = UN(l, ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"]), R = (V = n.default) === null || V === void 0 ? void 0 : V.call(n), m = s && Z !== Cn ? s(Z) : R;
      let M;
      W || (M = {
        opacity: d.value ? 0 : 1,
        height: d.value ? 0 : Cn,
        overflowY: d.value ? "hidden" : Cn,
        order: o ? u : Cn,
        pointerEvents: d.value ? "none" : Cn,
        position: d.value ? "absolute" : Cn
      });
      const S = {};
      return d.value && (S["aria-hidden"] = !0), H(Sd, {
        disabled: !o,
        onResize: (p) => {
          let {
            offsetWidth: Y
          } = p;
          U(Y);
        }
      }, {
        default: () => H(i, Ql(Ql(Ql({
          class: Xl(!W && h),
          style: M
        }, S), c), {}, {
          ref: a
        }), {
          default: () => [m]
        })
      });
    };
  }
});
var Za = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const ZN = pl({
  compatConfig: {
    MODE: 3
  },
  name: "RawItem",
  inheritAttrs: !1,
  props: {
    component: ol.any,
    title: ol.any,
    id: String,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    role: String,
    tabindex: Number
  },
  setup(l, t) {
    let {
      slots: n,
      attrs: e
    } = t;
    const d = cN();
    return () => {
      var a;
      if (!d.value) {
        const {
          component: s = "div"
        } = l, o = Za(l, ["component"]);
        return H(s, Ql(Ql({}, o), e), {
          default: () => [(a = n.default) === null || a === void 0 ? void 0 : a.call(n)]
        });
      }
      const U = d.value, {
        className: V
      } = U, h = Za(U, ["className"]), {
        class: W
      } = e, Z = Za(e, ["class"]);
      return H(Oa, {
        value: null
      }, {
        default: () => [H(Pe, Ql(Ql(Ql({
          class: Xl(V, W)
        }, h), Z), l), n)]
      });
    };
  }
});
var FN = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const QZ = "responsive", WZ = "invalidate";
function oN(l) {
  return `+ ${l.length} ...`;
}
const VN = () => ({
  id: String,
  prefixCls: String,
  data: Array,
  itemKey: [String, Number, Function],
  /** Used for `responsive`. It will limit render node to avoid perf issue */
  itemWidth: {
    type: Number,
    default: 10
  },
  renderItem: Function,
  /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
  renderRawItem: Function,
  maxCount: [Number, String],
  renderRest: Function,
  /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
  renderRawRest: Function,
  suffix: ol.any,
  component: String,
  itemComponent: ol.any,
  /** @private This API may be refactor since not well design */
  onVisibleChange: Function,
  /** When set to `full`, ssr will render full items by default and remove at client side */
  ssr: String,
  onMousedown: Function
}), Ld = pl({
  name: "Overflow",
  inheritAttrs: !1,
  props: VN(),
  emits: ["visibleChange"],
  setup(l, t) {
    let {
      attrs: n,
      emit: e,
      slots: d
    } = t;
    const a = Zl(() => l.ssr === "full"), U = bl(null), V = Zl(() => U.value || 0), h = bl(/* @__PURE__ */ new Map()), W = bl(0), Z = bl(0), s = bl(0), o = bl(null), F = bl(null), N = Zl(() => F.value === null && a.value ? Number.MAX_SAFE_INTEGER : F.value || 0), Q = bl(!1), u = Zl(() => `${l.prefixCls}-item`), i = Zl(() => Math.max(W.value, Z.value)), c = Zl(() => !!(l.data.length && l.maxCount === QZ)), R = Zl(() => l.maxCount === WZ), m = Zl(() => c.value || typeof l.maxCount == "number" && l.data.length > l.maxCount), M = Zl(() => {
      let w = l.data;
      return c.value ? U.value === null && a.value ? w = l.data : w = l.data.slice(0, Math.min(l.data.length, V.value / l.itemWidth)) : typeof l.maxCount == "number" && (w = l.data.slice(0, l.maxCount)), w;
    }), S = Zl(() => c.value ? l.data.slice(N.value + 1) : l.data.slice(M.value.length)), p = (w, O) => {
      var el;
      return typeof l.itemKey == "function" ? l.itemKey(w) : (el = l.itemKey && w?.[l.itemKey]) !== null && el !== void 0 ? el : O;
    }, Y = Zl(() => l.renderItem || ((w) => w)), k = (w, O) => {
      F.value = w, O || (Q.value = w < l.data.length - 1, e("visibleChange", w));
    }, L = (w, O) => {
      U.value = O.clientWidth;
    }, z = (w, O) => {
      const el = new Map(h.value);
      O === null ? el.delete(w) : el.set(w, O), h.value = el;
    }, f = (w, O) => {
      W.value = Z.value, Z.value = O;
    }, K = (w, O) => {
      s.value = O;
    }, P = (w) => h.value.get(p(M.value[w], w));
    return Bl([V, h, Z, s, () => l.itemKey, M], () => {
      if (V.value && i.value && M.value) {
        let w = s.value;
        const O = M.value.length, el = O - 1;
        if (!O) {
          k(0), o.value = null;
          return;
        }
        for (let ll = 0; ll < O; ll += 1) {
          const q = P(ll);
          if (q === void 0) {
            k(ll - 1, !0);
            break;
          }
          if (w += q, // Only one means `totalWidth` is the final width
          el === 0 && w <= V.value || // Last two width will be the final width
          ll === el - 1 && w + P(el) <= V.value) {
            k(el), o.value = null;
            break;
          } else if (w + i.value > V.value) {
            k(ll - 1), o.value = w - q - s.value + Z.value;
            break;
          }
        }
        l.suffix && P(0) + s.value > V.value && (o.value = null);
      }
    }), () => {
      const w = Q.value && !!S.value.length, {
        itemComponent: O,
        renderRawItem: el,
        renderRawRest: ll,
        renderRest: q,
        prefixCls: _ = "rc-overflow",
        suffix: il,
        component: dl = "div",
        id: tl,
        onMousedown: al
      } = l, {
        class: Ul,
        style: cl
      } = n, B = FN(n, ["class", "style"]);
      let X = {};
      o.value !== null && c.value && (X = {
        position: "absolute",
        left: `${o.value}px`,
        top: 0
      });
      const b = {
        prefixCls: u.value,
        responsive: c.value,
        component: O,
        invalidate: R.value
      }, r = el ? (y, I) => {
        const E = p(y, I);
        return H(Oa, {
          key: E,
          value: j(j({}, b), {
            order: I,
            item: y,
            itemKey: E,
            registerSize: z,
            display: I <= N.value
          })
        }, {
          default: () => [el(y, I)]
        });
      } : (y, I) => {
        const E = p(y, I);
        return H(Pe, Ql(Ql({}, b), {}, {
          order: I,
          key: E,
          item: y,
          renderItem: Y.value,
          itemKey: E,
          registerSize: z,
          display: I <= N.value
        }), null);
      };
      let G = () => null;
      const J = {
        order: w ? N.value : Number.MAX_SAFE_INTEGER,
        className: `${u.value} ${u.value}-rest`,
        registerSize: f,
        display: w
      };
      if (ll)
        ll && (G = () => H(Oa, {
          value: j(j({}, b), J)
        }, {
          default: () => [ll(S.value)]
        }));
      else {
        const y = q || oN;
        G = () => H(Pe, Ql(Ql({}, b), J), {
          default: () => typeof y == "function" ? y(S.value) : y
        });
      }
      const T = () => {
        var y;
        return H(dl, Ql({
          id: tl,
          class: Xl(!R.value && _, Ul),
          style: cl,
          onMousedown: al
        }, B), {
          default: () => [M.value.map(r), m.value ? G() : null, il && H(Pe, Ql(Ql({}, b), {}, {
            order: N.value,
            class: `${u.value}-suffix`,
            registerSize: K,
            display: !0,
            style: X
          }), {
            default: () => il
          }), (y = d.default) === null || y === void 0 ? void 0 : y.call(d)]
        });
      };
      return H(Sd, {
        disabled: !c.value,
        onResize: L
      }, {
        default: T
      });
    };
  }
});
Ld.Item = ZN;
Ld.RESPONSIVE = QZ;
Ld.INVALIDATE = WZ;
const QN = Symbol("TreeSelectLegacyContextPropsKey");
function mi() {
  return fl(QN, {});
}
const WN = {
  id: String,
  prefixCls: String,
  values: ol.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: ol.any,
  placeholder: ol.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: ol.oneOfType([ol.number, ol.string]),
  removeIcon: ol.any,
  choiceTransitionName: String,
  maxTagCount: ol.oneOfType([ol.number, ol.string]),
  maxTagTextLength: Number,
  maxTagPlaceholder: ol.any.def(() => (l) => `+ ${l.length} ...`),
  tagRender: Function,
  onToggleOpen: {
    type: Function
  },
  onRemove: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, rc = (l) => {
  l.preventDefault(), l.stopPropagation();
}, hN = pl({
  name: "MultipleSelectSelector",
  inheritAttrs: !1,
  props: WN,
  setup(l) {
    const t = bl(), n = bl(0), e = bl(!1), d = mi(), a = Zl(() => `${l.prefixCls}-selection`), U = Zl(() => l.open || l.mode === "tags" ? l.searchValue : ""), V = Zl(() => l.mode === "tags" || l.showSearch && (l.open || e.value));
    ql(() => {
      Bl(U, () => {
        n.value = t.value.scrollWidth;
      }, {
        flush: "post",
        immediate: !0
      });
    });
    function h(o, F, N, Q, u) {
      return H("span", {
        class: Xl(`${a.value}-item`, {
          [`${a.value}-item-disabled`]: N
        }),
        title: typeof o == "string" || typeof o == "number" ? o.toString() : void 0
      }, [H("span", {
        class: `${a.value}-item-content`
      }, [F]), Q && H(Tn, {
        class: `${a.value}-item-remove`,
        onMousedown: rc,
        onClick: u,
        customizeIcon: l.removeIcon
      }, {
        default: () => [Ve("×")]
      })]);
    }
    function W(o, F, N, Q, u, i) {
      var c;
      const R = (M) => {
        rc(M), l.onToggleOpen(!open);
      };
      let m = i;
      return d.keyEntities && (m = ((c = d.keyEntities[o]) === null || c === void 0 ? void 0 : c.node) || {}), H("span", {
        key: o,
        onMousedown: R
      }, [l.tagRender({
        label: F,
        value: o,
        disabled: N,
        closable: Q,
        onClose: u,
        option: m
      })]);
    }
    function Z(o) {
      const {
        disabled: F,
        label: N,
        value: Q,
        option: u
      } = o, i = !l.disabled && !F;
      let c = N;
      if (typeof l.maxTagTextLength == "number" && (typeof N == "string" || typeof N == "number")) {
        const m = String(c);
        m.length > l.maxTagTextLength && (c = `${m.slice(0, l.maxTagTextLength)}...`);
      }
      const R = (m) => {
        var M;
        m && m.stopPropagation(), (M = l.onRemove) === null || M === void 0 || M.call(l, o);
      };
      return typeof l.tagRender == "function" ? W(Q, c, F, i, R, u) : h(N, c, F, i, R);
    }
    function s(o) {
      const {
        maxTagPlaceholder: F = (Q) => `+ ${Q.length} ...`
      } = l, N = typeof F == "function" ? F(o) : F;
      return h(N, N, !1);
    }
    return () => {
      const {
        id: o,
        prefixCls: F,
        values: N,
        open: Q,
        inputRef: u,
        placeholder: i,
        disabled: c,
        autofocus: R,
        autocomplete: m,
        activeDescendantId: M,
        tabindex: S,
        onInputChange: p,
        onInputPaste: Y,
        onInputKeyDown: k,
        onInputMouseDown: L,
        onInputCompositionStart: z,
        onInputCompositionEnd: f
      } = l, K = H("div", {
        class: `${a.value}-search`,
        style: {
          width: n.value + "px"
        },
        key: "input"
      }, [H(oZ, {
        inputRef: u,
        open: Q,
        prefixCls: F,
        id: o,
        inputElement: null,
        disabled: c,
        autofocus: R,
        autocomplete: m,
        editable: V.value,
        activeDescendantId: M,
        value: U.value,
        onKeydown: k,
        onMousedown: L,
        onChange: p,
        onPaste: Y,
        onCompositionstart: z,
        onCompositionend: f,
        tabindex: S,
        attrs: zd(l, !0),
        onFocus: () => e.value = !0,
        onBlur: () => e.value = !1
      }, null), H("span", {
        ref: t,
        class: `${a.value}-search-mirror`,
        "aria-hidden": !0
      }, [U.value, Ve(" ")])]), P = H(Ld, {
        prefixCls: `${a.value}-overflow`,
        data: N,
        renderItem: Z,
        renderRest: s,
        suffix: K,
        itemKey: "key",
        maxCount: l.maxTagCount,
        key: "overflow"
      }, null);
      return H(st, null, [P, !N.length && !U.value && H("span", {
        class: `${a.value}-placeholder`
      }, [i])]);
    };
  }
}), RN = {
  inputElement: ol.any,
  id: String,
  prefixCls: String,
  values: ol.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: ol.any,
  placeholder: ol.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: ol.oneOfType([ol.number, ol.string]),
  activeValue: String,
  backfill: {
    type: Boolean,
    default: void 0
  },
  optionLabelRender: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, ui = pl({
  name: "SingleSelector",
  setup(l) {
    const t = bl(!1), n = Zl(() => l.mode === "combobox"), e = Zl(() => n.value || l.showSearch), d = Zl(() => {
      let W = l.searchValue || "";
      return n.value && l.activeValue && !t.value && (W = l.activeValue), W;
    }), a = mi();
    Bl([n, () => l.activeValue], () => {
      n.value && (t.value = !1);
    }, {
      immediate: !0
    });
    const U = Zl(() => l.mode !== "combobox" && !l.open && !l.showSearch ? !1 : !!d.value), V = Zl(() => {
      const W = l.values[0];
      return W && (typeof W.label == "string" || typeof W.label == "number") ? W.label.toString() : void 0;
    }), h = () => {
      if (l.values[0])
        return null;
      const W = U.value ? {
        visibility: "hidden"
      } : void 0;
      return H("span", {
        class: `${l.prefixCls}-selection-placeholder`,
        style: W
      }, [l.placeholder]);
    };
    return () => {
      var W, Z, s, o;
      const {
        inputElement: F,
        prefixCls: N,
        id: Q,
        values: u,
        inputRef: i,
        disabled: c,
        autofocus: R,
        autocomplete: m,
        activeDescendantId: M,
        open: S,
        tabindex: p,
        optionLabelRender: Y,
        onInputKeyDown: k,
        onInputMouseDown: L,
        onInputChange: z,
        onInputPaste: f,
        onInputCompositionStart: K,
        onInputCompositionEnd: P
      } = l, w = u[0];
      let O = null;
      if (w && a.customSlots) {
        const el = (W = w.key) !== null && W !== void 0 ? W : w.value, ll = ((Z = a.keyEntities[el]) === null || Z === void 0 ? void 0 : Z.node) || {};
        O = a.customSlots[(s = ll.slots) === null || s === void 0 ? void 0 : s.title] || a.customSlots.title || w.label, typeof O == "function" && (O = O(ll));
      } else
        O = Y && w ? Y(w.option) : w?.label;
      return H(st, null, [H("span", {
        class: `${N}-selection-search`
      }, [H(oZ, {
        inputRef: i,
        prefixCls: N,
        id: Q,
        open: S,
        inputElement: F,
        disabled: c,
        autofocus: R,
        autocomplete: m,
        editable: e.value,
        activeDescendantId: M,
        value: d.value,
        onKeydown: k,
        onMousedown: L,
        onChange: (el) => {
          t.value = !0, z(el);
        },
        onPaste: f,
        onCompositionstart: K,
        onCompositionend: P,
        tabindex: p,
        attrs: zd(l, !0)
      }, null)]), !n.value && w && !U.value && H("span", {
        class: `${N}-selection-item`,
        title: V.value
      }, [H(st, {
        key: (o = w.key) !== null && o !== void 0 ? o : w.value
      }, [O])]), h()]);
    };
  }
});
ui.props = RN;
ui.inheritAttrs = !1;
function NN(l) {
  return ![
    // System function button
    ul.ESC,
    ul.SHIFT,
    ul.BACKSPACE,
    ul.TAB,
    ul.WIN_KEY,
    ul.ALT,
    ul.META,
    ul.WIN_KEY_RIGHT,
    ul.CTRL,
    ul.SEMICOLON,
    ul.EQUALS,
    ul.CAPS_LOCK,
    ul.CONTEXT_MENU,
    // F1-F12
    ul.F1,
    ul.F2,
    ul.F3,
    ul.F4,
    ul.F5,
    ul.F6,
    ul.F7,
    ul.F8,
    ul.F9,
    ul.F10,
    ul.F11,
    ul.F12
  ].includes(l);
}
function hZ() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, t = null, n;
  Wt(() => {
    clearTimeout(n);
  });
  function e(d) {
    (d || t === null) && (t = d), clearTimeout(n), n = setTimeout(() => {
      t = null;
    }, l);
  }
  return [() => t, e];
}
function Me() {
  const l = (t) => {
    l.current = t;
  };
  return l;
}
const bN = pl({
  name: "Selector",
  inheritAttrs: !1,
  props: {
    id: String,
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    /** Display in the Selector value, it's not same as `value` prop */
    values: ol.array,
    multiple: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    searchValue: String,
    activeValue: String,
    inputElement: ol.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    tabindex: ol.oneOfType([ol.number, ol.string]),
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: ol.any,
    removeIcon: ol.any,
    // Tags
    maxTagCount: ol.oneOfType([ol.number, ol.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: ol.any,
    tagRender: Function,
    optionLabelRender: Function,
    /** Check if `tokenSeparators` contains `\n` or `\r\n` */
    tokenWithEnter: {
      type: Boolean,
      default: void 0
    },
    // Motion
    choiceTransitionName: String,
    onToggleOpen: {
      type: Function
    },
    /** `onSearch` returns go next step boolean to check if need do toggle open */
    onSearch: Function,
    onSearchSubmit: Function,
    onRemove: Function,
    onInputKeyDown: {
      type: Function
    },
    /**
     * @private get real dom for trigger align.
     * This may be removed after React provides replacement of `findDOMNode`
     */
    domRef: Function
  },
  setup(l, t) {
    let {
      expose: n
    } = t;
    const e = Me();
    let d = !1;
    const [a, U] = hZ(0), V = (i) => {
      const {
        which: c
      } = i;
      (c === ul.UP || c === ul.DOWN) && i.preventDefault(), l.onInputKeyDown && l.onInputKeyDown(i), c === ul.ENTER && l.mode === "tags" && !d && !l.open && l.onSearchSubmit(i.target.value), NN(c) && l.onToggleOpen(!0);
    }, h = () => {
      U(!0);
    };
    let W = null;
    const Z = (i) => {
      l.onSearch(i, !0, d) !== !1 && l.onToggleOpen(!0);
    }, s = () => {
      d = !0;
    }, o = (i) => {
      d = !1, l.mode !== "combobox" && Z(i.target.value);
    }, F = (i) => {
      let {
        target: {
          value: c
        }
      } = i;
      if (l.tokenWithEnter && W && /[\r\n]/.test(W)) {
        const R = W.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        c = c.replace(R, W);
      }
      W = null, Z(c);
    }, N = (i) => {
      const {
        clipboardData: c
      } = i;
      W = c.getData("text");
    }, Q = (i) => {
      let {
        target: c
      } = i;
      c !== e.current && (document.body.style.msTouchAction !== void 0 ? setTimeout(() => {
        e.current.focus();
      }) : e.current.focus());
    }, u = (i) => {
      const c = a();
      i.target !== e.current && !c && i.preventDefault(), (l.mode !== "combobox" && (!l.showSearch || !c) || !l.open) && (l.open && l.onSearch("", !0, !1), l.onToggleOpen());
    };
    return n({
      focus: () => {
        e.current.focus();
      },
      blur: () => {
        e.current.blur();
      }
    }), () => {
      const {
        prefixCls: i,
        domRef: c,
        mode: R
      } = l, m = {
        inputRef: e,
        onInputKeyDown: V,
        onInputMouseDown: h,
        onInputChange: F,
        onInputPaste: N,
        onInputCompositionStart: s,
        onInputCompositionEnd: o
      }, M = R === "multiple" || R === "tags" ? H(hN, Ql(Ql({}, l), m), null) : H(ui, Ql(Ql({}, l), m), null);
      return H("div", {
        ref: c,
        class: `${i}-selector`,
        onClick: Q,
        onMousedown: u
      }, [M]);
    };
  }
});
function mN(l, t, n) {
  function e(d) {
    var a, U, V;
    let h = d.target;
    h.shadowRoot && d.composed && (h = d.composedPath()[0] || h);
    const W = [(a = l[0]) === null || a === void 0 ? void 0 : a.value, (V = (U = l[1]) === null || U === void 0 ? void 0 : U.value) === null || V === void 0 ? void 0 : V.getPopupElement()];
    t.value && W.every((Z) => Z && !Z.contains(h) && Z !== h) && n(!1);
  }
  ql(() => {
    window.addEventListener("mousedown", e);
  }), Wt(() => {
    window.removeEventListener("mousedown", e);
  });
}
function uN() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  const t = bl(!1);
  let n;
  const e = () => {
    clearTimeout(n);
  };
  return ql(() => {
    e();
  }), [t, (a, U) => {
    e(), n = setTimeout(() => {
      t.value = a, U && U();
    }, l);
  }, e];
}
const RZ = Symbol("BaseSelectContextKey");
function rN(l) {
  return nt(RZ, l);
}
function MN() {
  return fl(RZ, {});
}
const pN = () => {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  const l = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(l) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(l?.substring(0, 4));
};
function NZ(l) {
  if (!mF(l))
    return Nt(l);
  const t = new Proxy({}, {
    get(n, e, d) {
      return Reflect.get(l.value, e, d);
    },
    set(n, e, d) {
      return l.value[e] = d, !0;
    },
    deleteProperty(n, e) {
      return Reflect.deleteProperty(l.value, e);
    },
    has(n, e) {
      return Reflect.has(l.value, e);
    },
    ownKeys() {
      return Object.keys(l.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Nt(t);
}
var SN = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const TN = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"], GN = () => ({
  prefixCls: String,
  id: String,
  omitDomProps: Array,
  // >>> Value
  displayValues: Array,
  onDisplayValuesChange: Function,
  // >>> Active
  /** Current dropdown list active item string value */
  activeValue: String,
  /** Link search input with target element */
  activeDescendantId: String,
  onActiveValueChange: Function,
  // >>> Search
  searchValue: String,
  /** Trigger onSearch, return false to prevent trigger open event */
  onSearch: Function,
  /** Trigger when search text match the `tokenSeparators`. Will provide split content */
  onSearchSplit: Function,
  maxLength: Number,
  OptionList: ol.any,
  /** Tell if provided `options` is empty */
  emptyOptions: Boolean
}), bZ = () => ({
  showSearch: {
    type: Boolean,
    default: void 0
  },
  tagRender: {
    type: Function
  },
  optionLabelRender: {
    type: Function
  },
  direction: {
    type: String
  },
  // MISC
  tabindex: Number,
  autofocus: Boolean,
  notFoundContent: ol.any,
  placeholder: ol.any,
  onClear: Function,
  choiceTransitionName: String,
  // >>> Mode
  mode: String,
  // >>> Status
  disabled: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  // >>> Open
  open: {
    type: Boolean,
    default: void 0
  },
  defaultOpen: {
    type: Boolean,
    default: void 0
  },
  onDropdownVisibleChange: {
    type: Function
  },
  // >>> Customize Input
  /** @private Internal usage. Do not use in your production. */
  getInputElement: {
    type: Function
  },
  /** @private Internal usage. Do not use in your production. */
  getRawInputElement: {
    type: Function
  },
  // >>> Selector
  maxTagTextLength: Number,
  maxTagCount: {
    type: [String, Number]
  },
  maxTagPlaceholder: ol.any,
  // >>> Search
  tokenSeparators: {
    type: Array
  },
  // >>> Icons
  allowClear: {
    type: Boolean,
    default: void 0
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  inputIcon: ol.any,
  /** Clear all icon */
  clearIcon: ol.any,
  /** Selector remove icon */
  removeIcon: ol.any,
  // >>> Dropdown
  animation: String,
  transitionName: String,
  dropdownStyle: {
    type: Object
  },
  dropdownClassName: String,
  dropdownMatchSelectWidth: {
    type: [Boolean, Number],
    default: void 0
  },
  dropdownRender: {
    type: Function
  },
  dropdownAlign: Object,
  placement: {
    type: String
  },
  getPopupContainer: {
    type: Function
  },
  // >>> Focus
  showAction: {
    type: Array
  },
  onBlur: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  // >>> Rest Events
  onKeyup: Function,
  onKeydown: Function,
  onMousedown: Function,
  onPopupScroll: Function,
  onInputKeyDown: Function,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function
}), JN = () => j(j({}, GN()), bZ());
function ri(l) {
  return l === "tags" || l === "multiple";
}
const XN = pl({
  compatConfig: {
    MODE: 3
  },
  name: "BaseSelect",
  inheritAttrs: !1,
  props: yn(JN(), {
    showAction: [],
    notFoundContent: "Not Found"
  }),
  setup(l, t) {
    let {
      attrs: n,
      expose: e,
      slots: d
    } = t;
    const a = Zl(() => ri(l.mode)), U = Zl(() => l.showSearch !== void 0 ? l.showSearch : a.value || l.mode === "combobox"), V = bl(!1);
    ql(() => {
      V.value = pN();
    });
    const h = mi(), W = bl(null), Z = Me(), s = bl(null), o = bl(null), F = bl(null), N = Ml(!1), [Q, u, i] = uN();
    e({
      focus: () => {
        var r;
        (r = o.value) === null || r === void 0 || r.focus();
      },
      blur: () => {
        var r;
        (r = o.value) === null || r === void 0 || r.blur();
      },
      scrollTo: (r) => {
        var G;
        return (G = F.value) === null || G === void 0 ? void 0 : G.scrollTo(r);
      }
    });
    const m = Zl(() => {
      var r;
      if (l.mode !== "combobox")
        return l.searchValue;
      const G = (r = l.displayValues[0]) === null || r === void 0 ? void 0 : r.value;
      return typeof G == "string" || typeof G == "number" ? String(G) : "";
    }), M = l.open !== void 0 ? l.open : l.defaultOpen, S = bl(M), p = bl(M), Y = (r) => {
      S.value = l.open !== void 0 ? l.open : r, p.value = S.value;
    };
    Bl(() => l.open, () => {
      Y(l.open);
    });
    const k = Zl(() => !l.notFoundContent && l.emptyOptions);
    it(() => {
      p.value = S.value, (l.disabled || k.value && p.value && l.mode === "combobox") && (p.value = !1);
    });
    const L = Zl(() => k.value ? !1 : p.value), z = (r) => {
      const G = r !== void 0 ? r : !p.value;
      p.value !== G && !l.disabled && (Y(G), l.onDropdownVisibleChange && l.onDropdownVisibleChange(G));
    }, f = Zl(() => (l.tokenSeparators || []).some((r) => [`
`, `\r
`].includes(r))), K = (r, G, J) => {
      var T, y;
      let I = !0, E = r;
      (T = l.onActiveValueChange) === null || T === void 0 || T.call(l, null);
      const x = J ? null : hQ(r, l.tokenSeparators);
      return l.mode !== "combobox" && x && (E = "", (y = l.onSearchSplit) === null || y === void 0 || y.call(l, x), z(!1), I = !1), l.onSearch && m.value !== E && l.onSearch(E, {
        source: G ? "typing" : "effect"
      }), I;
    }, P = (r) => {
      var G;
      !r || !r.trim() || (G = l.onSearch) === null || G === void 0 || G.call(l, r, {
        source: "submit"
      });
    };
    Bl(p, () => {
      !p.value && !a.value && l.mode !== "combobox" && K("", !1, !1);
    }, {
      immediate: !0,
      flush: "post"
    }), Bl(() => l.disabled, () => {
      S.value && l.disabled && Y(!1), l.disabled && !N.value && u(!1);
    }, {
      immediate: !0
    });
    const [w, O] = hZ(), el = function(r) {
      var G;
      const J = w(), {
        which: T
      } = r;
      if (T === ul.ENTER && (l.mode !== "combobox" && r.preventDefault(), p.value || z(!0)), O(!!m.value), T === ul.BACKSPACE && !J && a.value && !m.value && l.displayValues.length) {
        const x = [...l.displayValues];
        let v = null;
        for (let A = x.length - 1; A >= 0; A -= 1) {
          const g = x[A];
          if (!g.disabled) {
            x.splice(A, 1), v = g;
            break;
          }
        }
        v && l.onDisplayValuesChange(x, {
          type: "remove",
          values: [v]
        });
      }
      for (var y = arguments.length, I = new Array(y > 1 ? y - 1 : 0), E = 1; E < y; E++)
        I[E - 1] = arguments[E];
      p.value && F.value && F.value.onKeydown(r, ...I), (G = l.onKeydown) === null || G === void 0 || G.call(l, r, ...I);
    }, ll = function(r) {
      for (var G = arguments.length, J = new Array(G > 1 ? G - 1 : 0), T = 1; T < G; T++)
        J[T - 1] = arguments[T];
      p.value && F.value && F.value.onKeyup(r, ...J), l.onKeyup && l.onKeyup(r, ...J);
    }, q = (r) => {
      const G = l.displayValues.filter((J) => J !== r);
      l.onDisplayValuesChange(G, {
        type: "remove",
        values: [r]
      });
    }, _ = bl(!1), il = function() {
      u(!0), l.disabled || (l.onFocus && !_.value && l.onFocus(...arguments), l.showAction && l.showAction.includes("focus") && z(!0)), _.value = !0;
    }, dl = Ml(!1), tl = function() {
      if (dl.value || (N.value = !0, u(!1, () => {
        _.value = !1, N.value = !1, z(!1);
      }), l.disabled))
        return;
      const r = m.value;
      r && (l.mode === "tags" ? l.onSearch(r, {
        source: "submit"
      }) : l.mode === "multiple" && l.onSearch("", {
        source: "blur"
      })), l.onBlur && l.onBlur(...arguments);
    }, al = () => {
      dl.value = !0;
    }, Ul = () => {
      dl.value = !1;
    };
    nt("VCSelectContainerEvent", {
      focus: il,
      blur: tl
    });
    const cl = [];
    ql(() => {
      cl.forEach((r) => clearTimeout(r)), cl.splice(0, cl.length);
    }), Wt(() => {
      cl.forEach((r) => clearTimeout(r)), cl.splice(0, cl.length);
    });
    const B = function(r) {
      var G, J;
      const {
        target: T
      } = r, y = (G = s.value) === null || G === void 0 ? void 0 : G.getPopupElement();
      if (y && y.contains(T)) {
        const v = setTimeout(() => {
          var A;
          const g = cl.indexOf(v);
          g !== -1 && cl.splice(g, 1), i(), !V.value && !y.contains(document.activeElement) && ((A = o.value) === null || A === void 0 || A.focus());
        });
        cl.push(v);
      }
      for (var I = arguments.length, E = new Array(I > 1 ? I - 1 : 0), x = 1; x < I; x++)
        E[x - 1] = arguments[x];
      (J = l.onMousedown) === null || J === void 0 || J.call(l, r, ...E);
    }, X = bl(null), b = () => {
    };
    return ql(() => {
      Bl(L, () => {
        var r;
        if (L.value) {
          const G = Math.ceil((r = W.value) === null || r === void 0 ? void 0 : r.offsetWidth);
          X.value !== G && !Number.isNaN(G) && (X.value = G);
        }
      }, {
        immediate: !0,
        flush: "post"
      });
    }), mN([W, s], L, z), rN(NZ(j(j({}, uF(l)), {
      open: p,
      triggerOpen: L,
      showSearch: U,
      multiple: a,
      toggleOpen: z
    }))), () => {
      const r = j(j({}, l), n), {
        prefixCls: G,
        id: J,
        open: T,
        defaultOpen: y,
        mode: I,
        // Search related
        showSearch: E,
        searchValue: x,
        onSearch: v,
        // Icons
        allowClear: A,
        clearIcon: g,
        showArrow: D,
        inputIcon: C,
        // Others
        disabled: nl,
        loading: Fl,
        getInputElement: sl,
        getPopupContainer: Vl,
        placement: Rl,
        // Dropdown
        animation: Wl,
        transitionName: ml,
        dropdownStyle: rl,
        dropdownClassName: Gl,
        dropdownMatchSelectWidth: Ll,
        dropdownRender: Cl,
        dropdownAlign: $,
        showAction: hl,
        direction: Tl,
        // Tags
        tokenSeparators: Jl,
        tagRender: yl,
        optionLabelRender: Il,
        // Events
        onPopupScroll: gl,
        onDropdownVisibleChange: wl,
        onFocus: _l,
        onBlur: lt,
        onKeyup: ct,
        onKeydown: Nl,
        onMousedown: Sl,
        onClear: Yl,
        omitDomProps: Hl,
        getRawInputElement: vl,
        displayValues: jl,
        onDisplayValuesChange: El,
        emptyOptions: Pl,
        activeDescendantId: Jt,
        activeValue: rt,
        OptionList: Ft
      } = r, ot = SN(r, ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"]), Dl = I === "combobox" && sl && sl() || null, Dn = typeof vl == "function" && vl(), Od = j({}, ot);
      let $i;
      Dn && ($i = (Zn) => {
        z(Zn);
      }), TN.forEach((Zn) => {
        delete Od[Zn];
      }), Hl?.forEach((Zn) => {
        delete Od[Zn];
      });
      const qi = D !== void 0 ? D : Fl || !a.value && I !== "combobox";
      let _i;
      qi && (_i = H(Tn, {
        class: Xl(`${G}-arrow`, {
          [`${G}-arrow-loading`]: Fl
        }),
        customizeIcon: C,
        customizeIconProps: {
          loading: Fl,
          searchValue: m.value,
          open: p.value,
          focused: Q.value,
          showSearch: U.value
        }
      }, null));
      let ls;
      const FF = () => {
        Yl?.(), El([], {
          type: "clear",
          values: jl
        }), K("", !1, !1);
      };
      !nl && A && (jl.length || m.value) && (ls = H(Tn, {
        class: `${G}-clear`,
        onMousedown: FF,
        customizeIcon: g
      }, {
        default: () => [Ve("×")]
      }));
      const oF = H(Ft, {
        ref: F
      }, j(j({}, h.customSlots), {
        option: d.option
      })), VF = Xl(G, n.class, {
        [`${G}-focused`]: Q.value,
        [`${G}-multiple`]: a.value,
        [`${G}-single`]: !a.value,
        [`${G}-allow-clear`]: A,
        [`${G}-show-arrow`]: qi,
        [`${G}-disabled`]: nl,
        [`${G}-loading`]: Fl,
        [`${G}-open`]: p.value,
        [`${G}-customize-input`]: Dl,
        [`${G}-show-search`]: U.value
      }), ts = H(tN, {
        ref: s,
        disabled: nl,
        prefixCls: G,
        visible: L.value,
        popupElement: oF,
        containerWidth: X.value,
        animation: Wl,
        transitionName: ml,
        dropdownStyle: rl,
        dropdownClassName: Gl,
        direction: Tl,
        dropdownMatchSelectWidth: Ll,
        dropdownRender: Cl,
        dropdownAlign: $,
        placement: Rl,
        getPopupContainer: Vl,
        empty: Pl,
        getTriggerDOMNode: () => Z.current,
        onPopupVisibleChange: $i,
        onPopupMouseEnter: b,
        onPopupFocusin: al,
        onPopupFocusout: Ul
      }, {
        default: () => Dn ? Pt(Dn) && bt(Dn, {
          ref: Z
        }, !1, !0) : H(bN, Ql(Ql({}, l), {}, {
          domRef: Z,
          prefixCls: G,
          inputElement: Dl,
          ref: o,
          id: J,
          showSearch: U.value,
          mode: I,
          activeDescendantId: Jt,
          tagRender: yl,
          optionLabelRender: Il,
          values: jl,
          open: p.value,
          onToggleOpen: z,
          activeValue: rt,
          searchValue: m.value,
          onSearch: K,
          onSearchSubmit: P,
          onRemove: q,
          tokenWithEnter: f.value
        }), null)
      });
      let vd;
      return Dn ? vd = ts : vd = H("div", Ql(Ql({}, Od), {}, {
        class: VF,
        ref: W,
        onMousedown: B,
        onKeydown: el,
        onKeyup: ll
      }), [Q.value && !p.value && H("span", {
        style: {
          width: 0,
          height: 0,
          position: "absolute",
          overflow: "hidden",
          opacity: 0
        },
        "aria-live": "polite"
      }, [`${jl.map((Zn) => {
        let {
          label: ns,
          value: QF
        } = Zn;
        return ["number", "string"].includes(typeof ns) ? ns : QF;
      }).join(", ")}`]), ts, _i, ls]), vd;
    };
  }
}), kd = (l, t) => {
  let {
    height: n,
    offset: e,
    prefixCls: d,
    onInnerResize: a
  } = l, {
    slots: U
  } = t;
  var V;
  let h = {}, W = {
    display: "flex",
    flexDirection: "column"
  };
  return e !== void 0 && (h = {
    height: `${n}px`,
    position: "relative",
    overflow: "hidden"
  }, W = j(j({}, W), {
    transform: `translateY(${e}px)`,
    position: "absolute",
    left: 0,
    right: 0,
    top: 0
  })), H("div", {
    style: h
  }, [H(Sd, {
    onResize: (Z) => {
      let {
        offsetHeight: s
      } = Z;
      s && a && a();
    }
  }, {
    default: () => [H("div", {
      style: W,
      class: Xl({
        [`${d}-holder-inner`]: d
      })
    }, [(V = U.default) === null || V === void 0 ? void 0 : V.call(U)])]
  })]);
};
kd.displayName = "Filter";
kd.inheritAttrs = !1;
kd.props = {
  prefixCls: String,
  /** Virtual filler height. Should be `count * itemMinHeight` */
  height: Number,
  /** Set offset of visible items. Should be the top of start item position */
  offset: Number,
  onInnerResize: Function
};
const mZ = (l, t) => {
  let {
    setRef: n
  } = l, {
    slots: e
  } = t;
  var d;
  const a = Tt((d = e.default) === null || d === void 0 ? void 0 : d.call(e));
  return a && a.length ? rd(a[0], {
    ref: n
  }) : a;
};
mZ.props = {
  setRef: {
    type: Function,
    default: () => {
    }
  }
};
const YN = 20;
function Mc(l) {
  return "touches" in l ? l.touches[0].pageY : l.pageY;
}
const yN = pl({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollBar",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    scrollTop: Number,
    scrollHeight: Number,
    height: Number,
    count: Number,
    onScroll: {
      type: Function
    },
    onStartMove: {
      type: Function
    },
    onStopMove: {
      type: Function
    }
  },
  setup() {
    return {
      moveRaf: null,
      scrollbarRef: Me(),
      thumbRef: Me(),
      visibleTimeout: null,
      state: Nt({
        dragging: !1,
        pageY: null,
        startTop: null,
        visible: !1
      })
    };
  },
  watch: {
    scrollTop: {
      handler() {
        this.delayHidden();
      },
      flush: "post"
    }
  },
  mounted() {
    var l, t;
    (l = this.scrollbarRef.current) === null || l === void 0 || l.addEventListener("touchstart", this.onScrollbarTouchStart, Rt ? {
      passive: !1
    } : !1), (t = this.thumbRef.current) === null || t === void 0 || t.addEventListener("touchstart", this.onMouseDown, Rt ? {
      passive: !1
    } : !1);
  },
  beforeUnmount() {
    this.removeEvents(), clearTimeout(this.visibleTimeout);
  },
  methods: {
    delayHidden() {
      clearTimeout(this.visibleTimeout), this.state.visible = !0, this.visibleTimeout = setTimeout(() => {
        this.state.visible = !1;
      }, 2e3);
    },
    onScrollbarTouchStart(l) {
      l.preventDefault();
    },
    onContainerMouseDown(l) {
      l.stopPropagation(), l.preventDefault();
    },
    // ======================= Clean =======================
    patchEvents() {
      window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("mouseup", this.onMouseUp), this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, Rt ? {
        passive: !1
      } : !1), this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
    },
    removeEvents() {
      window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, Rt ? {
        passive: !1
      } : !1), this.thumbRef.current && (this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, Rt ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, Rt ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchend", this.onMouseUp)), Ol.cancel(this.moveRaf);
    },
    // ======================= Thumb =======================
    onMouseDown(l) {
      const {
        onStartMove: t
      } = this.$props;
      j(this.state, {
        dragging: !0,
        pageY: Mc(l),
        startTop: this.getTop()
      }), t(), this.patchEvents(), l.stopPropagation(), l.preventDefault();
    },
    onMouseMove(l) {
      const {
        dragging: t,
        pageY: n,
        startTop: e
      } = this.state, {
        onScroll: d
      } = this.$props;
      if (Ol.cancel(this.moveRaf), t) {
        const a = Mc(l) - n, U = e + a, V = this.getEnableScrollRange(), h = this.getEnableHeightRange(), W = h ? U / h : 0, Z = Math.ceil(W * V);
        this.moveRaf = Ol(() => {
          d(Z);
        });
      }
    },
    onMouseUp() {
      const {
        onStopMove: l
      } = this.$props;
      this.state.dragging = !1, l(), this.removeEvents();
    },
    // ===================== Calculate =====================
    getSpinHeight() {
      const {
        height: l,
        scrollHeight: t
      } = this.$props;
      let n = l / t * 100;
      return n = Math.max(n, YN), n = Math.min(n, l / 2), Math.floor(n);
    },
    getEnableScrollRange() {
      const {
        scrollHeight: l,
        height: t
      } = this.$props;
      return l - t || 0;
    },
    getEnableHeightRange() {
      const {
        height: l
      } = this.$props, t = this.getSpinHeight();
      return l - t || 0;
    },
    getTop() {
      const {
        scrollTop: l
      } = this.$props, t = this.getEnableScrollRange(), n = this.getEnableHeightRange();
      return l === 0 || t === 0 ? 0 : l / t * n;
    },
    // Not show scrollbar when height is large than scrollHeight
    showScroll() {
      const {
        height: l,
        scrollHeight: t
      } = this.$props;
      return t > l;
    }
  },
  render() {
    const {
      dragging: l,
      visible: t
    } = this.state, {
      prefixCls: n
    } = this.$props, e = this.getSpinHeight() + "px", d = this.getTop() + "px", a = this.showScroll(), U = a && t;
    return H("div", {
      ref: this.scrollbarRef,
      class: Xl(`${n}-scrollbar`, {
        [`${n}-scrollbar-show`]: a
      }),
      style: {
        width: "8px",
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute",
        display: U ? void 0 : "none"
      },
      onMousedown: this.onContainerMouseDown,
      onMousemove: this.delayHidden
    }, [H("div", {
      ref: this.thumbRef,
      class: Xl(`${n}-scrollbar-thumb`, {
        [`${n}-scrollbar-thumb-moving`]: l
      }),
      style: {
        width: "100%",
        height: e,
        top: d,
        left: 0,
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: "99px",
        cursor: "pointer",
        userSelect: "none"
      },
      onMousedown: this.onMouseDown
    }, null)]);
  }
});
function BN(l, t, n, e) {
  const d = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), U = Ml(Symbol("update"));
  Bl(l, () => {
    U.value = Symbol("update");
  });
  let V;
  function h() {
    Ol.cancel(V);
  }
  function W() {
    h(), V = Ol(() => {
      d.forEach((s, o) => {
        if (s && s.offsetParent) {
          const {
            offsetHeight: F
          } = s;
          a.get(o) !== F && (U.value = Symbol("update"), a.set(o, s.offsetHeight));
        }
      });
    });
  }
  function Z(s, o) {
    const F = t(s);
    d.get(F), o ? (d.set(F, o.$el || o), W()) : d.delete(F);
  }
  return Xn(() => {
    h();
  }), [Z, W, a, U];
}
function zN(l, t, n, e, d, a, U, V) {
  let h;
  return (W) => {
    if (W == null) {
      V();
      return;
    }
    Ol.cancel(h);
    const Z = t.value, s = e.itemHeight;
    if (typeof W == "number")
      U(W);
    else if (W && typeof W == "object") {
      let o;
      const {
        align: F
      } = W;
      "index" in W ? {
        index: o
      } = W : o = Z.findIndex((u) => d(u) === W.key);
      const {
        offset: N = 0
      } = W, Q = (u, i) => {
        if (u < 0 || !l.value)
          return;
        const c = l.value.clientHeight;
        let R = !1, m = i;
        if (c) {
          const M = i || F;
          let S = 0, p = 0, Y = 0;
          const k = Math.min(Z.length, o);
          for (let f = 0; f <= k; f += 1) {
            const K = d(Z[f]);
            p = S;
            const P = n.get(K);
            Y = p + (P === void 0 ? s : P), S = Y, f === o && P === void 0 && (R = !0);
          }
          const L = l.value.scrollTop;
          let z = null;
          switch (M) {
            case "top":
              z = p - N;
              break;
            case "bottom":
              z = Y - c + N;
              break;
            default: {
              const f = L + c;
              p < L ? m = "top" : Y > f && (m = "bottom");
            }
          }
          z !== null && z !== L && U(z);
        }
        h = Ol(() => {
          R && a(), Q(u - 1, m);
        }, 2);
      };
      Q(5);
    }
  };
}
const LN = typeof navigator == "object" && /Firefox/i.test(navigator.userAgent), uZ = (l, t) => {
  let n = !1, e = null;
  function d() {
    clearTimeout(e), n = !0, e = setTimeout(() => {
      n = !1;
    }, 50);
  }
  return function(a) {
    let U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const V = (
      // Pass origin wheel when on the top
      a < 0 && l.value || // Pass origin wheel when on the bottom
      a > 0 && t.value
    );
    return U && V ? (clearTimeout(e), n = !1) : (!V || n) && d(), !n && V;
  };
};
function kN(l, t, n, e) {
  let d = 0, a = null, U = null, V = !1;
  const h = uZ(t, n);
  function W(s) {
    if (!l.value)
      return;
    Ol.cancel(a);
    const {
      deltaY: o
    } = s;
    d += o, U = o, !h(o) && (LN || s.preventDefault(), a = Ol(() => {
      e(d * (V ? 10 : 1)), d = 0;
    }));
  }
  function Z(s) {
    l.value && (V = s.detail === U);
  }
  return [W, Z];
}
const IN = 14 / 15;
function DN(l, t, n) {
  let e = !1, d = 0, a = null, U = null;
  const V = () => {
    a && (a.removeEventListener("touchmove", h), a.removeEventListener("touchend", W));
  }, h = (o) => {
    if (e) {
      const F = Math.ceil(o.touches[0].pageY);
      let N = d - F;
      d = F, n(N) && o.preventDefault(), clearInterval(U), U = setInterval(() => {
        N *= IN, (!n(N, !0) || Math.abs(N) <= 0.1) && clearInterval(U);
      }, 16);
    }
  }, W = () => {
    e = !1, V();
  }, Z = (o) => {
    V(), o.touches.length === 1 && !e && (e = !0, d = Math.ceil(o.touches[0].pageY), a = o.target, a.addEventListener("touchmove", h, {
      passive: !1
    }), a.addEventListener("touchend", W));
  }, s = () => {
  };
  ql(() => {
    document.addEventListener("touchmove", s, {
      passive: !1
    }), Bl(l, (o) => {
      t.value.removeEventListener("touchstart", Z), V(), clearInterval(U), o && t.value.addEventListener("touchstart", Z, {
        passive: !1
      });
    }, {
      immediate: !0
    });
  }), Wt(() => {
    document.removeEventListener("touchmove", s);
  });
}
var CN = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const wN = [], EN = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function xN(l, t, n, e, d, a) {
  let {
    getKey: U
  } = a;
  return l.slice(t, n + 1).map((V, h) => {
    const W = t + h, Z = d(V, W, {
      // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    }), s = U(V);
    return H(mZ, {
      key: s,
      setRef: (o) => e(V, o)
    }, {
      default: () => [Z]
    });
  });
}
const gN = pl({
  compatConfig: {
    MODE: 3
  },
  name: "List",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    data: ol.array,
    height: Number,
    itemHeight: Number,
    /** If not match virtual scroll condition, Set List still use height of container. */
    fullHeight: {
      type: Boolean,
      default: void 0
    },
    itemKey: {
      type: [String, Number, Function],
      required: !0
    },
    component: {
      type: [String, Object]
    },
    /** Set `false` will always use real scroll instead of virtual one */
    virtual: {
      type: Boolean,
      default: void 0
    },
    children: Function,
    onScroll: Function,
    onMousedown: Function,
    onMouseenter: Function,
    onVisibleChange: Function
  },
  setup(l, t) {
    let {
      expose: n
    } = t;
    const e = Zl(() => {
      const {
        height: q,
        itemHeight: _,
        virtual: il
      } = l;
      return !!(il !== !1 && q && _);
    }), d = Zl(() => {
      const {
        height: q,
        itemHeight: _,
        data: il
      } = l;
      return e.value && il && _ * il.length > q;
    }), a = Nt({
      scrollTop: 0,
      scrollMoving: !1
    }), U = Zl(() => l.data || wN), V = bl([]);
    Bl(U, () => {
      V.value = Md(U.value).slice();
    }, {
      immediate: !0
    });
    const h = bl((q) => {
    });
    Bl(() => l.itemKey, (q) => {
      typeof q == "function" ? h.value = q : h.value = (_) => _?.[q];
    }, {
      immediate: !0
    });
    const W = bl(), Z = bl(), s = bl(), o = (q) => h.value(q), F = {
      getKey: o
    };
    function N(q) {
      let _;
      typeof q == "function" ? _ = q(a.scrollTop) : _ = q;
      const il = S(_);
      W.value && (W.value.scrollTop = il), a.scrollTop = il;
    }
    const [Q, u, i, c] = BN(V, o), R = Nt({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    }), m = bl(0);
    ql(() => {
      dt(() => {
        var q;
        m.value = ((q = Z.value) === null || q === void 0 ? void 0 : q.offsetHeight) || 0;
      });
    }), qn(() => {
      dt(() => {
        var q;
        m.value = ((q = Z.value) === null || q === void 0 ? void 0 : q.offsetHeight) || 0;
      });
    }), Bl([e, V], () => {
      e.value || j(R, {
        scrollHeight: void 0,
        start: 0,
        end: V.value.length - 1,
        offset: void 0
      });
    }, {
      immediate: !0
    }), Bl([e, V, m, d], () => {
      e.value && !d.value && j(R, {
        scrollHeight: m.value,
        start: 0,
        end: V.value.length - 1,
        offset: void 0
      }), W.value && (a.scrollTop = W.value.scrollTop);
    }, {
      immediate: !0
    }), Bl([d, e, () => a.scrollTop, V, c, () => l.height, m], () => {
      if (!e.value || !d.value)
        return;
      let q = 0, _, il, dl;
      const tl = V.value.length, al = V.value, Ul = a.scrollTop, {
        itemHeight: cl,
        height: B
      } = l, X = Ul + B;
      for (let b = 0; b < tl; b += 1) {
        const r = al[b], G = o(r);
        let J = i.get(G);
        J === void 0 && (J = cl);
        const T = q + J;
        _ === void 0 && T >= Ul && (_ = b, il = q), dl === void 0 && T > X && (dl = b), q = T;
      }
      _ === void 0 && (_ = 0, il = 0, dl = Math.ceil(B / cl)), dl === void 0 && (dl = tl - 1), dl = Math.min(dl + 1, tl), j(R, {
        scrollHeight: q,
        start: _,
        end: dl,
        offset: il
      });
    }, {
      immediate: !0
    });
    const M = Zl(() => R.scrollHeight - l.height);
    function S(q) {
      let _ = q;
      return Number.isNaN(M.value) || (_ = Math.min(_, M.value)), _ = Math.max(_, 0), _;
    }
    const p = Zl(() => a.scrollTop <= 0), Y = Zl(() => a.scrollTop >= M.value), k = uZ(p, Y);
    function L(q) {
      N(q);
    }
    function z(q) {
      var _;
      const {
        scrollTop: il
      } = q.currentTarget;
      il !== a.scrollTop && N(il), (_ = l.onScroll) === null || _ === void 0 || _.call(l, q);
    }
    const [f, K] = kN(e, p, Y, (q) => {
      N((_) => _ + q);
    });
    DN(e, W, (q, _) => k(q, _) ? !1 : (f({
      preventDefault() {
      },
      deltaY: q
    }), !0));
    function P(q) {
      e.value && q.preventDefault();
    }
    const w = () => {
      W.value && (W.value.removeEventListener("wheel", f, Rt ? {
        passive: !1
      } : !1), W.value.removeEventListener("DOMMouseScroll", K), W.value.removeEventListener("MozMousePixelScroll", P));
    };
    it(() => {
      dt(() => {
        W.value && (w(), W.value.addEventListener("wheel", f, Rt ? {
          passive: !1
        } : !1), W.value.addEventListener("DOMMouseScroll", K), W.value.addEventListener("MozMousePixelScroll", P));
      });
    }), Wt(() => {
      w();
    });
    const O = zN(W, V, i, l, o, u, N, () => {
      var q;
      (q = s.value) === null || q === void 0 || q.delayHidden();
    });
    n({
      scrollTo: O
    });
    const el = Zl(() => {
      let q = null;
      return l.height && (q = j({
        [l.fullHeight ? "height" : "maxHeight"]: l.height + "px"
      }, EN), e.value && (q.overflowY = "hidden", a.scrollMoving && (q.pointerEvents = "none"))), q;
    });
    return Bl([() => R.start, () => R.end, V], () => {
      if (l.onVisibleChange) {
        const q = V.value.slice(R.start, R.end + 1);
        l.onVisibleChange(q, V.value);
      }
    }, {
      flush: "post"
    }), {
      state: a,
      mergedData: V,
      componentStyle: el,
      onFallbackScroll: z,
      onScrollBar: L,
      componentRef: W,
      useVirtual: e,
      calRes: R,
      collectHeight: u,
      setInstance: Q,
      sharedConfig: F,
      scrollBarRef: s,
      fillerInnerRef: Z,
      delayHideScrollBar: () => {
        var q;
        (q = s.value) === null || q === void 0 || q.delayHidden();
      }
    };
  },
  render() {
    const l = j(j({}, this.$props), this.$attrs), {
      prefixCls: t = "rc-virtual-list",
      height: n,
      itemHeight: e,
      // eslint-disable-next-line no-unused-vars
      fullHeight: d,
      data: a,
      itemKey: U,
      virtual: V,
      component: h = "div",
      onScroll: W,
      children: Z = this.$slots.default,
      style: s,
      class: o
    } = l, F = CN(l, ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"]), N = Xl(t, o), {
      scrollTop: Q
    } = this.state, {
      scrollHeight: u,
      offset: i,
      start: c,
      end: R
    } = this.calRes, {
      componentStyle: m,
      onFallbackScroll: M,
      onScrollBar: S,
      useVirtual: p,
      collectHeight: Y,
      sharedConfig: k,
      setInstance: L,
      mergedData: z,
      delayHideScrollBar: f
    } = this;
    return H("div", Ql({
      style: j(j({}, s), {
        position: "relative"
      }),
      class: N
    }, F), [H(h, {
      class: `${t}-holder`,
      style: m,
      ref: "componentRef",
      onScroll: M,
      onMouseenter: f
    }, {
      default: () => [H(kd, {
        prefixCls: t,
        height: u,
        offset: i,
        onInnerResize: Y,
        ref: "fillerInnerRef"
      }, {
        default: () => xN(z, c, R, L, Z, k)
      })]
    }), p && H(yN, {
      ref: "scrollBarRef",
      prefixCls: t,
      scrollTop: Q,
      height: n,
      scrollHeight: u,
      count: z.length,
      onScroll: S,
      onStartMove: () => {
        this.state.scrollMoving = !0;
      },
      onStopMove: () => {
        this.state.scrollMoving = !1;
      }
    }, null)]);
  }
});
function jN(l, t, n) {
  const e = Ml(l());
  return Bl(t, (d, a) => {
    n ? n(d, a) && (e.value = l()) : e.value = l();
  }), e;
}
function ON() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
const rZ = Symbol("SelectContextKey");
function vN(l) {
  return nt(rZ, l);
}
function fN() {
  return fl(rZ, {});
}
var KN = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
function pc(l) {
  return typeof l == "string" || typeof l == "number";
}
const HN = pl({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(l, t) {
    let {
      expose: n,
      slots: e
    } = t;
    const d = MN(), a = fN(), U = Zl(() => `${d.prefixCls}-item`), V = jN(() => a.flattenOptions, [() => d.open, () => a.flattenOptions], (M) => M[0]), h = Me(), W = (M) => {
      M.preventDefault();
    }, Z = (M) => {
      h.current && h.current.scrollTo(typeof M == "number" ? {
        index: M
      } : M);
    }, s = function(M) {
      let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const p = V.value.length;
      for (let Y = 0; Y < p; Y += 1) {
        const k = (M + Y * S + p) % p, {
          group: L,
          data: z
        } = V.value[k];
        if (!L && !z.disabled)
          return k;
      }
      return -1;
    }, o = Nt({
      activeIndex: s(0)
    }), F = function(M) {
      let S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      o.activeIndex = M;
      const p = {
        source: S ? "keyboard" : "mouse"
      }, Y = V.value[M];
      if (!Y) {
        a.onActiveValue(null, -1, p);
        return;
      }
      a.onActiveValue(Y.value, M, p);
    };
    Bl([() => V.value.length, () => d.searchValue], () => {
      F(a.defaultActiveFirstOption !== !1 ? s(0) : -1);
    }, {
      immediate: !0
    });
    const N = (M) => a.rawValues.has(M) && d.mode !== "combobox";
    Bl([() => d.open, () => d.searchValue], () => {
      if (!d.multiple && d.open && a.rawValues.size === 1) {
        const M = Array.from(a.rawValues)[0], S = Md(V.value).findIndex((p) => {
          let {
            data: Y
          } = p;
          return Y[a.fieldNames.value] === M;
        });
        S !== -1 && (F(S), dt(() => {
          Z(S);
        }));
      }
      d.open && dt(() => {
        var M;
        (M = h.current) === null || M === void 0 || M.scrollTo(void 0);
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const Q = (M) => {
      M !== void 0 && a.onSelect(M, {
        selected: !a.rawValues.has(M)
      }), d.multiple || d.toggleOpen(!1);
    }, u = (M) => typeof M.label == "function" ? M.label() : M.label;
    function i(M) {
      const S = V.value[M];
      if (!S)
        return null;
      const p = S.data || {}, {
        value: Y
      } = p, {
        group: k
      } = S, L = zd(p, !0), z = u(S);
      return S ? H("div", Ql(Ql({
        "aria-label": typeof z == "string" && !k ? z : null
      }, L), {}, {
        key: M,
        role: k ? "presentation" : "option",
        id: `${d.id}_list_${M}`,
        "aria-selected": N(Y)
      }), [Y]) : null;
    }
    return n({
      onKeydown: (M) => {
        const {
          which: S,
          ctrlKey: p
        } = M;
        switch (S) {
          case ul.N:
          case ul.P:
          case ul.UP:
          case ul.DOWN: {
            let Y = 0;
            if (S === ul.UP ? Y = -1 : S === ul.DOWN ? Y = 1 : ON() && p && (S === ul.N ? Y = 1 : S === ul.P && (Y = -1)), Y !== 0) {
              const k = s(o.activeIndex + Y, Y);
              Z(k), F(k, !0);
            }
            break;
          }
          case ul.ENTER: {
            const Y = V.value[o.activeIndex];
            Y && !Y.data.disabled ? Q(Y.value) : Q(void 0), d.open && M.preventDefault();
            break;
          }
          case ul.ESC:
            d.toggleOpen(!1), d.open && M.stopPropagation();
        }
      },
      onKeyup: () => {
      },
      scrollTo: (M) => {
        Z(M);
      }
    }), () => {
      const {
        id: M,
        notFoundContent: S,
        onPopupScroll: p
      } = d, {
        menuItemSelectedIcon: Y,
        fieldNames: k,
        virtual: L,
        listHeight: z,
        listItemHeight: f
      } = a, K = e.option, {
        activeIndex: P
      } = o, w = Object.keys(k).map((O) => k[O]);
      return V.value.length === 0 ? H("div", {
        role: "listbox",
        id: `${M}_list`,
        class: `${U.value}-empty`,
        onMousedown: W
      }, [S]) : H(st, null, [H("div", {
        role: "listbox",
        id: `${M}_list`,
        style: {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }, [i(P - 1), i(P), i(P + 1)]), H(gN, {
        itemKey: "key",
        ref: h,
        data: V.value,
        height: z,
        itemHeight: f,
        fullHeight: !1,
        onMousedown: W,
        onScroll: p,
        virtual: L
      }, {
        default: (O, el) => {
          var ll;
          const {
            group: q,
            groupOption: _,
            data: il,
            value: dl
          } = O, {
            key: tl
          } = il, al = typeof O.label == "function" ? O.label() : O.label;
          if (q) {
            const g = (ll = il.title) !== null && ll !== void 0 ? ll : pc(al) && al;
            return H("div", {
              class: Xl(U.value, `${U.value}-group`),
              title: g
            }, [K ? K(il) : al !== void 0 ? al : tl]);
          }
          const {
            disabled: Ul,
            title: cl,
            children: B,
            style: X,
            class: b,
            className: r
          } = il, G = KN(il, ["disabled", "title", "children", "style", "class", "className"]), J = ut(G, w), T = N(dl), y = `${U.value}-option`, I = Xl(U.value, y, b, r, {
            [`${y}-grouped`]: _,
            [`${y}-active`]: P === el && !Ul,
            [`${y}-disabled`]: Ul,
            [`${y}-selected`]: T
          }), E = u(O), x = !Y || typeof Y == "function" || T, v = typeof E == "number" ? E : E || dl;
          let A = pc(v) ? v.toString() : void 0;
          return cl !== void 0 && (A = cl), H("div", Ql(Ql({}, J), {}, {
            "aria-selected": T,
            class: I,
            title: A,
            onMousemove: (g) => {
              G.onMousemove && G.onMousemove(g), !(P === el || Ul) && F(el);
            },
            onClick: (g) => {
              Ul || Q(dl), G.onClick && G.onClick(g);
            },
            style: X
          }), [H("div", {
            class: `${y}-content`
          }, [K ? K(il) : v]), Pt(Y) || T, x && H(Tn, {
            class: `${U.value}-option-state`,
            customizeIcon: Y,
            customizeIconProps: {
              isSelected: T
            }
          }, {
            default: () => [T ? "✓" : null]
          })]);
        }
      })]);
    };
  }
});
var PN = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
function AN(l) {
  const t = l, {
    key: n,
    children: e
  } = t, d = t.props, {
    value: a,
    disabled: U
  } = d, V = PN(d, ["value", "disabled"]), h = e?.default;
  return j({
    key: n,
    value: a !== void 0 ? a : n,
    children: h,
    disabled: U || U === ""
  }, V);
}
function Mi(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return Tt(l).map((e, d) => {
    var a;
    if (!Pt(e) || !e.type)
      return null;
    const {
      type: {
        isSelectOptGroup: U
      },
      key: V,
      children: h,
      props: W
    } = e;
    if (t || !U)
      return AN(e);
    const Z = h && h.default ? h.default() : void 0, s = W?.label || ((a = h.label) === null || a === void 0 ? void 0 : a.call(h)) || V;
    return j(j({
      key: `__RC_SELECT_GRP__${V === null ? d : String(V)}__`
    }, W), {
      label: s,
      options: Mi(Z || [])
    });
  }).filter((e) => e);
}
function $N(l, t, n) {
  const e = bl(), d = bl(), a = bl(), U = bl([]);
  return Bl([l, t], () => {
    l.value ? U.value = Md(l.value).slice() : U.value = Mi(t.value);
  }, {
    immediate: !0,
    deep: !0
  }), it(() => {
    const V = U.value, h = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map(), Z = n.value;
    function s(o) {
      let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      for (let N = 0; N < o.length; N += 1) {
        const Q = o[N];
        !Q[Z.options] || F ? (h.set(Q[Z.value], Q), W.set(Q[Z.label], Q)) : s(Q[Z.options], !0);
      }
    }
    s(V), e.value = V, d.value = h, a.value = W;
  }), {
    options: e,
    valueOptions: d,
    labelOptions: a
  };
}
let Sc = 0;
const qN = process.env.NODE_ENV !== "test" && xt();
function _N() {
  let l;
  return qN ? (l = Sc, Sc += 1) : l = "TEST_OR_SSR", l;
}
function lb() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ml("");
  const t = `rc_select_${_N()}`;
  return l.value || t;
}
function pi(l) {
  return Array.isArray(l) ? l : l !== void 0 ? [l] : [];
}
const tb = typeof window < "u" && window.document && window.document.documentElement;
process.env.NODE_ENV;
function nb(l) {
  const {
    mode: t,
    options: n,
    children: e,
    backfill: d,
    allowClear: a,
    placeholder: U,
    getInputElement: V,
    showSearch: h,
    onSearch: W,
    defaultOpen: Z,
    autofocus: s,
    labelInValue: o,
    value: F,
    inputValue: N,
    optionLabelProp: Q
  } = l, u = ri(t), i = h !== void 0 ? h : u || t === "combobox", c = n || Mi(e);
  if (Bt(t !== "tags" || c.every((R) => !R.disabled), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), Bt(t !== "combobox" || !Q, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), Bt(t === "combobox" || !d, "`backfill` only works with `combobox` mode."), Bt(t === "combobox" || !V, "`getInputElement` only work with `combobox` mode."), rs(t !== "combobox" || !V || !a || !U, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), W && !i && t !== "combobox" && t !== "tags" && Bt(!1, "`onSearch` should work with `showSearch` instead of use alone."), rs(!Z || s, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autofocus` if needed."), F != null) {
    const R = pi(F);
    Bt(!o || R.every((m) => typeof m == "object" && ("key" in m || "value" in m)), "`value` should in shape of `{ value: string | number, label?: any }` when you set `labelInValue` to `true`"), Bt(!u || Array.isArray(F), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (e) {
    let R = null;
    e.some((m) => {
      var M;
      if (!Pt(m) || !m.type)
        return !1;
      const {
        type: S
      } = m;
      return S.isSelectOption ? !1 : S.isSelectOptGroup ? !(((M = m.children) === null || M === void 0 ? void 0 : M.default()) || []).every((k) => !Pt(k) || !m.type || k.type.isSelectOption ? !0 : (R = k.type, !1)) : (R = S, !0);
    }), R && Bt(!1, `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${R.displayName || R.name || R}\`.`), Bt(N === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
function Fa(l, t) {
  return pi(l).join("").toUpperCase().includes(t);
}
const eb = (l, t, n, e, d) => Zl(() => {
  const a = n.value, U = d?.value, V = e?.value;
  if (!a || V === !1)
    return l.value;
  const {
    options: h,
    label: W,
    value: Z
  } = t.value, s = [], o = typeof V == "function", F = a.toUpperCase(), N = o ? V : (u, i) => U ? Fa(i[U], F) : i[h] ? Fa(i[W !== "children" ? W : "label"], F) : Fa(i[Z], F), Q = o ? (u) => ka(u) : (u) => u;
  return l.value.forEach((u) => {
    if (u[h]) {
      if (N(a, Q(u)))
        s.push(u);
      else {
        const c = u[h].filter((R) => N(a, Q(R)));
        c.length && s.push(j(j({}, u), {
          [h]: c
        }));
      }
      return;
    }
    N(a, Q(u)) && s.push(u);
  }), s;
}), db = (l, t) => {
  const n = bl({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  return [Zl(() => {
    const {
      values: a,
      options: U
    } = n.value, V = l.value.map((Z) => {
      var s;
      return Z.label === void 0 ? j(j({}, Z), {
        label: (s = a.get(Z.value)) === null || s === void 0 ? void 0 : s.label
      }) : Z;
    }), h = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map();
    return V.forEach((Z) => {
      h.set(Z.value, Z), W.set(Z.value, t.value.get(Z.value) || U.get(Z.value));
    }), n.value.values = h, n.value.options = W, V;
  }), (a) => t.value.get(a) || n.value.options.get(a)];
};
function Qd(l, t) {
  const {
    defaultValue: n,
    value: e = Ml()
  } = t || {};
  let d = typeof l == "function" ? l() : l;
  e.value !== void 0 && (d = at(e)), n !== void 0 && (d = typeof n == "function" ? n() : n);
  const a = Ml(d), U = Ml(d);
  it(() => {
    let h = e.value !== void 0 ? e.value : a.value;
    t.postState && (h = t.postState(h)), U.value = h;
  });
  function V(h) {
    const W = U.value;
    a.value = h, Md(U.value) !== h && t.onChange && t.onChange(h, W);
  }
  return Bl(e, () => {
    a.value = e.value;
  }), [U, V];
}
function ft(l) {
  const t = typeof l == "function" ? l() : l, n = Ml(t);
  function e(d) {
    n.value = d;
  }
  return [n, e];
}
const ab = ["inputValue"];
function MZ() {
  return j(j({}, bZ()), {
    prefixCls: String,
    id: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    // >>> Field Names
    fieldNames: Object,
    // >>> Search
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    searchValue: String,
    onSearch: Function,
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    // >>> Options
    /**
     * In Select, `false` means do nothing.
     * In TreeSelect, `false` will highlight match item.
     * It's by design.
     */
    filterOption: {
      type: [Boolean, Function],
      default: void 0
    },
    filterSort: Function,
    optionFilterProp: String,
    optionLabelProp: String,
    options: Array,
    defaultActiveFirstOption: {
      type: Boolean,
      default: void 0
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    // >>> Icon
    menuItemSelectedIcon: ol.any,
    mode: String,
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    value: ol.any,
    defaultValue: ol.any,
    onChange: Function,
    children: Array
  });
}
function ib(l) {
  return !l || typeof l != "object";
}
const sb = pl({
  compatConfig: {
    MODE: 3
  },
  name: "VcSelect",
  inheritAttrs: !1,
  props: yn(MZ(), {
    prefixCls: "vc-select",
    autoClearSearchValue: !0,
    listHeight: 200,
    listItemHeight: 20,
    dropdownMatchSelectWidth: !0
  }),
  setup(l, t) {
    let {
      expose: n,
      attrs: e,
      slots: d
    } = t;
    const a = lb(Ct(l, "id")), U = Zl(() => ri(l.mode)), V = Zl(() => !!(!l.options && l.children)), h = Zl(() => l.filterOption === void 0 && l.mode === "combobox" ? !1 : l.filterOption), W = Zl(() => z0(l.fieldNames, V.value)), [Z, s] = Qd("", {
      value: Zl(() => l.searchValue !== void 0 ? l.searchValue : l.inputValue),
      postState: (b) => b || ""
    }), o = $N(Ct(l, "options"), Ct(l, "children"), W), {
      valueOptions: F,
      labelOptions: N,
      options: Q
    } = o, u = (b) => pi(b).map((G) => {
      var J, T;
      let y, I, E, x;
      ib(G) ? y = G : (E = G.key, I = G.label, y = (J = G.value) !== null && J !== void 0 ? J : E);
      const v = F.value.get(y);
      return v && (I === void 0 && (I = v?.[l.optionLabelProp || W.value.label]), E === void 0 && (E = (T = v?.key) !== null && T !== void 0 ? T : y), x = v?.disabled), {
        label: I,
        value: y,
        key: E,
        disabled: x,
        option: v
      };
    }), [i, c] = Qd(l.defaultValue, {
      value: Ct(l, "value")
    }), R = Zl(() => {
      var b;
      const r = u(i.value);
      return l.mode === "combobox" && !(!((b = r[0]) === null || b === void 0) && b.value) ? [] : r;
    }), [m, M] = db(R, F), S = Zl(() => {
      if (!l.mode && m.value.length === 1) {
        const b = m.value[0];
        if (b.value === null && (b.label === null || b.label === void 0))
          return [];
      }
      return m.value.map((b) => {
        var r;
        return j(j({}, b), {
          label: (r = typeof b.label == "function" ? b.label() : b.label) !== null && r !== void 0 ? r : b.value
        });
      });
    }), p = Zl(() => new Set(m.value.map((b) => b.value)));
    it(() => {
      var b;
      if (l.mode === "combobox") {
        const r = (b = m.value[0]) === null || b === void 0 ? void 0 : b.value;
        r != null && s(String(r));
      }
    }, {
      flush: "post"
    });
    const Y = (b, r) => {
      const G = r ?? b;
      return {
        [W.value.value]: b,
        [W.value.label]: G
      };
    }, k = bl();
    it(() => {
      if (l.mode !== "tags") {
        k.value = Q.value;
        return;
      }
      const b = Q.value.slice(), r = (G) => F.value.has(G);
      [...m.value].sort((G, J) => G.value < J.value ? -1 : 1).forEach((G) => {
        const J = G.value;
        r(J) || b.push(Y(J, G.label));
      }), k.value = b;
    });
    const L = eb(k, W, Z, h, Ct(l, "optionFilterProp")), z = Zl(() => l.mode !== "tags" || !Z.value || L.value.some((b) => b[l.optionFilterProp || "value"] === Z.value) ? L.value : [Y(Z.value), ...L.value]), f = Zl(() => l.filterSort ? [...z.value].sort((b, r) => l.filterSort(b, r)) : z.value), K = Zl(() => WQ(f.value, {
      fieldNames: W.value,
      childrenAsData: V.value
    })), P = (b) => {
      const r = u(b);
      if (c(r), l.onChange && // Trigger event only when value changed
      (r.length !== m.value.length || r.some((G, J) => {
        var T;
        return ((T = m.value[J]) === null || T === void 0 ? void 0 : T.value) !== G?.value;
      }))) {
        const G = l.labelInValue ? r.map((T) => j(j({}, T), {
          originLabel: T.label,
          label: typeof T.label == "function" ? T.label() : T.label
        })) : r.map((T) => T.value), J = r.map((T) => ka(M(T.value)));
        l.onChange(
          // Value
          U.value ? G : G[0],
          // Option
          U.value ? J : J[0]
        );
      }
    }, [w, O] = ft(null), [el, ll] = ft(0), q = Zl(() => l.defaultActiveFirstOption !== void 0 ? l.defaultActiveFirstOption : l.mode !== "combobox"), _ = function(b, r) {
      let {
        source: G = "keyboard"
      } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      ll(r), l.backfill && l.mode === "combobox" && b !== null && G === "keyboard" && O(String(b));
    }, il = (b, r) => {
      const G = () => {
        var J;
        const T = M(b), y = T?.[W.value.label];
        return [l.labelInValue ? {
          label: typeof y == "function" ? y() : y,
          originLabel: y,
          value: b,
          key: (J = T?.key) !== null && J !== void 0 ? J : b
        } : b, ka(T)];
      };
      if (r && l.onSelect) {
        const [J, T] = G();
        l.onSelect(J, T);
      } else if (!r && l.onDeselect) {
        const [J, T] = G();
        l.onDeselect(J, T);
      }
    }, dl = (b, r) => {
      let G;
      const J = U.value ? r.selected : !0;
      J ? G = U.value ? [...m.value, b] : [b] : G = m.value.filter((T) => T.value !== b), P(G), il(b, J), l.mode === "combobox" ? O("") : (!U.value || l.autoClearSearchValue) && (s(""), O(""));
    }, tl = (b, r) => {
      P(b), (r.type === "remove" || r.type === "clear") && r.values.forEach((G) => {
        il(G.value, !1);
      });
    }, al = (b, r) => {
      var G;
      if (s(b), O(null), r.source === "submit") {
        const J = (b || "").trim();
        if (J) {
          const T = Array.from(/* @__PURE__ */ new Set([...p.value, J]));
          P(T), il(J, !0), s("");
        }
        return;
      }
      r.source !== "blur" && (l.mode === "combobox" && P(b), (G = l.onSearch) === null || G === void 0 || G.call(l, b));
    }, Ul = (b) => {
      let r = b;
      l.mode !== "tags" && (r = b.map((J) => {
        const T = N.value.get(J);
        return T?.value;
      }).filter((J) => J !== void 0));
      const G = Array.from(/* @__PURE__ */ new Set([...p.value, ...r]));
      P(G), G.forEach((J) => {
        il(J, !0);
      });
    }, cl = Zl(() => l.virtual !== !1 && l.dropdownMatchSelectWidth !== !1);
    vN(NZ(j(j({}, o), {
      flattenOptions: K,
      onActiveValue: _,
      defaultActiveFirstOption: q,
      onSelect: dl,
      menuItemSelectedIcon: Ct(l, "menuItemSelectedIcon"),
      rawValues: p,
      fieldNames: W,
      virtual: cl,
      listHeight: Ct(l, "listHeight"),
      listItemHeight: Ct(l, "listItemHeight"),
      childrenAsData: V
    }))), process.env.NODE_ENV !== "production" && it(() => {
      nb(l);
    }, {
      flush: "post"
    });
    const B = Ml();
    n({
      focus() {
        var b;
        (b = B.value) === null || b === void 0 || b.focus();
      },
      blur() {
        var b;
        (b = B.value) === null || b === void 0 || b.blur();
      },
      scrollTo(b) {
        var r;
        (r = B.value) === null || r === void 0 || r.scrollTo(b);
      }
    });
    const X = Zl(() => ut(l, [
      "id",
      "mode",
      "prefixCls",
      "backfill",
      "fieldNames",
      // Search
      "inputValue",
      "searchValue",
      "onSearch",
      "autoClearSearchValue",
      // Select
      "onSelect",
      "onDeselect",
      "dropdownMatchSelectWidth",
      // Options
      "filterOption",
      "filterSort",
      "optionFilterProp",
      "optionLabelProp",
      "options",
      "children",
      "defaultActiveFirstOption",
      "menuItemSelectedIcon",
      "virtual",
      "listHeight",
      "listItemHeight",
      // Value
      "value",
      "defaultValue",
      "labelInValue",
      "onChange"
    ]));
    return () => H(XN, Ql(Ql(Ql({}, X.value), e), {}, {
      id: a,
      prefixCls: l.prefixCls,
      ref: B,
      omitDomProps: ab,
      mode: l.mode,
      displayValues: S.value,
      onDisplayValuesChange: tl,
      searchValue: Z.value,
      onSearch: al,
      onSearchSplit: Ul,
      dropdownMatchSelectWidth: l.dropdownMatchSelectWidth,
      OptionList: HN,
      emptyOptions: !K.value.length,
      activeValue: w.value,
      activeDescendantId: `${a}_list_${el.value}`
    }), d);
  }
}), Si = () => null;
Si.isSelectOption = !0;
Si.displayName = "ASelectOption";
const Ti = () => null;
Ti.isSelectOptGroup = !0;
Ti.displayName = "ASelectOptGroup";
var cb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" }, Ub = Symbol("iconContext"), pZ = function() {
  return fl(Ub, {
    prefixCls: Ml("anticon"),
    rootClassName: Ml(""),
    csp: Ml()
  });
};
function Gi() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Zb(l, t) {
  return l && l.contains ? l.contains(t) : !1;
}
var Tc = "data-vc-order", Fb = "vc-icon-key", va = /* @__PURE__ */ new Map();
function SZ() {
  var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = l.mark;
  return t ? t.startsWith("data-") ? t : "data-".concat(t) : Fb;
}
function Ji(l) {
  if (l.attachTo)
    return l.attachTo;
  var t = document.querySelector("head");
  return t || document.body;
}
function ob(l) {
  return l === "queue" ? "prependQueue" : l ? "prepend" : "append";
}
function TZ(l) {
  return Array.from((va.get(l) || l).children).filter(function(t) {
    return t.tagName === "STYLE";
  });
}
function GZ(l) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Gi())
    return null;
  var n = t.csp, e = t.prepend, d = document.createElement("style");
  d.setAttribute(Tc, ob(e)), n && n.nonce && (d.nonce = n.nonce), d.innerHTML = l;
  var a = Ji(t), U = a.firstChild;
  if (e) {
    if (e === "queue") {
      var V = TZ(a).filter(function(h) {
        return ["prepend", "prependQueue"].includes(h.getAttribute(Tc));
      });
      if (V.length)
        return a.insertBefore(d, V[V.length - 1].nextSibling), d;
    }
    a.insertBefore(d, U);
  } else
    a.appendChild(d);
  return d;
}
function Vb(l) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = Ji(t);
  return TZ(n).find(function(e) {
    return e.getAttribute(SZ(t)) === l;
  });
}
function Qb(l, t) {
  var n = va.get(l);
  if (!n || !Zb(document, n)) {
    var e = GZ("", t), d = e.parentNode;
    va.set(l, d), l.removeChild(e);
  }
}
function Wb(l, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, e = Ji(n);
  Qb(e, n);
  var d = Vb(t, n);
  if (d)
    return n.csp && n.csp.nonce && d.nonce !== n.csp.nonce && (d.nonce = n.csp.nonce), d.innerHTML !== l && (d.innerHTML = l), d;
  var a = GZ(l, n);
  return a.setAttribute(SZ(n), t), a;
}
function Gc(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      hb(l, d, n[d]);
    });
  }
  return l;
}
function hb(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
function Rb(l, t) {
  process.env.NODE_ENV !== "production" && !l && console !== void 0 && console.error("Warning: ".concat(t));
}
function Nb(l, t) {
  Rb(l, "[@ant-design/icons-vue] ".concat(t));
}
function Jc(l) {
  return typeof l == "object" && typeof l.name == "string" && typeof l.theme == "string" && (typeof l.icon == "object" || typeof l.icon == "function");
}
function fa(l, t, n) {
  return n ? ua(l.tag, Gc({
    key: t
  }, n, l.attrs), (l.children || []).map(function(e, d) {
    return fa(e, "".concat(t, "-").concat(l.tag, "-").concat(d));
  })) : ua(l.tag, Gc({
    key: t
  }, l.attrs), (l.children || []).map(function(e, d) {
    return fa(e, "".concat(t, "-").concat(l.tag, "-").concat(d));
  }));
}
function JZ(l) {
  return Qe(l)[0];
}
function XZ(l) {
  return l ? Array.isArray(l) ? l : [l] : [];
}
var bb = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`;
function YZ(l) {
  return l && l.getRootNode && l.getRootNode();
}
function mb(l) {
  return Gi() ? YZ(l) instanceof ShadowRoot : !1;
}
function ub(l) {
  return mb(l) ? YZ(l) : null;
}
var rb = function() {
  var t = pZ(), n = t.prefixCls, e = t.csp, d = Jn(), a = bb;
  n && (a = a.replace(/anticon/g, n.value)), dt(function() {
    if (Gi()) {
      var U = d.vnode.el, V = ub(U);
      Wb(a, "@ant-design-vue-icons", {
        prepend: !0,
        csp: e.value,
        attachTo: V
      });
    }
  });
}, Mb = ["icon", "primaryColor", "secondaryColor"];
function pb(l, t) {
  if (l == null)
    return {};
  var n = Sb(l, t), e, d;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(l);
    for (d = 0; d < a.length; d++)
      e = a[d], !(t.indexOf(e) >= 0) && Object.prototype.propertyIsEnumerable.call(l, e) && (n[e] = l[e]);
  }
  return n;
}
function Sb(l, t) {
  if (l == null)
    return {};
  var n = {}, e = Object.keys(l), d, a;
  for (a = 0; a < e.length; a++)
    d = e[a], !(t.indexOf(d) >= 0) && (n[d] = l[d]);
  return n;
}
function Ae(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      Tb(l, d, n[d]);
    });
  }
  return l;
}
function Tb(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Ue = Nt({
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
});
function Gb(l) {
  var t = l.primaryColor, n = l.secondaryColor;
  Ue.primaryColor = t, Ue.secondaryColor = n || JZ(t), Ue.calculated = !!n;
}
function Jb() {
  return Ae({}, Ue);
}
var cn = function(t, n) {
  var e = Ae({}, t, n.attrs), d = e.icon, a = e.primaryColor, U = e.secondaryColor, V = pb(e, Mb), h = Ue;
  if (a && (h = {
    primaryColor: a,
    secondaryColor: U || JZ(a)
  }), Nb(Jc(d), "icon should be icon definiton, but got ".concat(d)), !Jc(d))
    return null;
  var W = d;
  return W && typeof W.icon == "function" && (W = Ae({}, W, {
    icon: W.icon(h.primaryColor, h.secondaryColor)
  })), fa(W.icon, "svg-".concat(W.name), Ae({}, V, {
    "data-icon": W.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
cn.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
cn.inheritAttrs = !1;
cn.displayName = "IconBase";
cn.getTwoToneColors = Jb;
cn.setTwoToneColors = Gb;
function Xb(l, t) {
  return zb(l) || Bb(l, t) || yb(l, t) || Yb();
}
function Yb() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function yb(l, t) {
  if (l) {
    if (typeof l == "string")
      return Xc(l, t);
    var n = Object.prototype.toString.call(l).slice(8, -1);
    if (n === "Object" && l.constructor && (n = l.constructor.name), n === "Map" || n === "Set")
      return Array.from(l);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Xc(l, t);
  }
}
function Xc(l, t) {
  (t == null || t > l.length) && (t = l.length);
  for (var n = 0, e = new Array(t); n < t; n++)
    e[n] = l[n];
  return e;
}
function Bb(l, t) {
  var n = l == null ? null : typeof Symbol < "u" && l[Symbol.iterator] || l["@@iterator"];
  if (n != null) {
    var e = [], d = !0, a = !1, U, V;
    try {
      for (n = n.call(l); !(d = (U = n.next()).done) && (e.push(U.value), !(t && e.length === t)); d = !0)
        ;
    } catch (h) {
      a = !0, V = h;
    } finally {
      try {
        !d && n.return != null && n.return();
      } finally {
        if (a)
          throw V;
      }
    }
    return e;
  }
}
function zb(l) {
  if (Array.isArray(l))
    return l;
}
function yZ(l) {
  var t = XZ(l), n = Xb(t, 2), e = n[0], d = n[1];
  return cn.setTwoToneColors({
    primaryColor: e,
    secondaryColor: d
  });
}
function Lb() {
  var l = cn.getTwoToneColors();
  return l.calculated ? [l.primaryColor, l.secondaryColor] : l.primaryColor;
}
var kb = pl({
  name: "InsertStyles",
  setup: function() {
    return rb(), function() {
      return null;
    };
  }
}), Ib = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function Db(l, t) {
  return xb(l) || Eb(l, t) || wb(l, t) || Cb();
}
function Cb() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function wb(l, t) {
  if (l) {
    if (typeof l == "string")
      return Yc(l, t);
    var n = Object.prototype.toString.call(l).slice(8, -1);
    if (n === "Object" && l.constructor && (n = l.constructor.name), n === "Map" || n === "Set")
      return Array.from(l);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return Yc(l, t);
  }
}
function Yc(l, t) {
  (t == null || t > l.length) && (t = l.length);
  for (var n = 0, e = new Array(t); n < t; n++)
    e[n] = l[n];
  return e;
}
function Eb(l, t) {
  var n = l == null ? null : typeof Symbol < "u" && l[Symbol.iterator] || l["@@iterator"];
  if (n != null) {
    var e = [], d = !0, a = !1, U, V;
    try {
      for (n = n.call(l); !(d = (U = n.next()).done) && (e.push(U.value), !(t && e.length === t)); d = !0)
        ;
    } catch (h) {
      a = !0, V = h;
    } finally {
      try {
        !d && n.return != null && n.return();
      } finally {
        if (a)
          throw V;
      }
    }
    return e;
  }
}
function xb(l) {
  if (Array.isArray(l))
    return l;
}
function yc(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      ie(l, d, n[d]);
    });
  }
  return l;
}
function ie(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
function gb(l, t) {
  if (l == null)
    return {};
  var n = jb(l, t), e, d;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(l);
    for (d = 0; d < a.length; d++)
      e = a[d], !(t.indexOf(e) >= 0) && Object.prototype.propertyIsEnumerable.call(l, e) && (n[e] = l[e]);
  }
  return n;
}
function jb(l, t) {
  if (l == null)
    return {};
  var n = {}, e = Object.keys(l), d, a;
  for (a = 0; a < e.length; a++)
    d = e[a], !(t.indexOf(d) >= 0) && (n[d] = l[d]);
  return n;
}
yZ(OF.primary);
var $l = function(t, n) {
  var e, d = yc({}, t, n.attrs), a = d.class, U = d.icon, V = d.spin, h = d.rotate, W = d.tabindex, Z = d.twoToneColor, s = d.onClick, o = gb(d, Ib), F = pZ(), N = F.prefixCls, Q = F.rootClassName, u = (e = {}, ie(e, Q.value, !!Q.value), ie(e, N.value, !0), ie(e, "".concat(N.value, "-").concat(U.name), !!U.name), ie(e, "".concat(N.value, "-spin"), !!V || U.name === "loading"), e), i = W;
  i === void 0 && s && (i = -1);
  var c = h ? {
    msTransform: "rotate(".concat(h, "deg)"),
    transform: "rotate(".concat(h, "deg)")
  } : void 0, R = XZ(Z), m = Db(R, 2), M = m[0], S = m[1];
  return H("span", yc({
    role: "img",
    "aria-label": U.name
  }, o, {
    onClick: s,
    class: [u, a],
    tabindex: i
  }), [H(cn, {
    icon: U,
    primaryColor: M,
    secondaryColor: S,
    style: c
  }, null), H(kb, null, null)]);
};
$l.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: [String, Array]
};
$l.displayName = "AntdIcon";
$l.inheritAttrs = !1;
$l.getTwoToneColor = Lb;
$l.setTwoToneColor = yZ;
function Bc(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      Ob(l, d, n[d]);
    });
  }
  return l;
}
function Ob(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Xi = function(t, n) {
  var e = Bc({}, t, n.attrs);
  return H($l, Bc({}, e, {
    icon: cb
  }), null);
};
Xi.displayName = "DownOutlined";
Xi.inheritAttrs = !1;
var vb = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" };
function zc(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      fb(l, d, n[d]);
    });
  }
  return l;
}
function fb(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var pe = function(t, n) {
  var e = zc({}, t, n.attrs);
  return H($l, zc({}, e, {
    icon: vb
  }), null);
};
pe.displayName = "LoadingOutlined";
pe.inheritAttrs = !1;
var Kb = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" };
function Lc(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      Hb(l, d, n[d]);
    });
  }
  return l;
}
function Hb(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Yi = function(t, n) {
  var e = Lc({}, t, n.attrs);
  return H($l, Lc({}, e, {
    icon: Kb
  }), null);
};
Yi.displayName = "CheckOutlined";
Yi.inheritAttrs = !1;
var Pb = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" };
function kc(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      Ab(l, d, n[d]);
    });
  }
  return l;
}
function Ab(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Id = function(t, n) {
  var e = kc({}, t, n.attrs);
  return H($l, kc({}, e, {
    icon: Pb
  }), null);
};
Id.displayName = "CloseOutlined";
Id.inheritAttrs = !1;
var $b = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" };
function Ic(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      qb(l, d, n[d]);
    });
  }
  return l;
}
function qb(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Be = function(t, n) {
  var e = Ic({}, t, n.attrs);
  return H($l, Ic({}, e, {
    icon: $b
  }), null);
};
Be.displayName = "CloseCircleFilled";
Be.inheritAttrs = !1;
var _b = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" };
function Dc(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      lm(l, d, n[d]);
    });
  }
  return l;
}
function lm(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Dd = function(t, n) {
  var e = Dc({}, t, n.attrs);
  return H($l, Dc({}, e, {
    icon: _b
  }), null);
};
Dd.displayName = "SearchOutlined";
Dd.inheritAttrs = !1;
function tm(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    loading: n,
    multiple: e,
    prefixCls: d,
    hasFeedback: a,
    feedbackIcon: U,
    showArrow: V
  } = l, h = l.suffixIcon || t.suffixIcon && t.suffixIcon(), W = l.clearIcon || t.clearIcon && t.clearIcon(), Z = l.menuItemSelectedIcon || t.menuItemSelectedIcon && t.menuItemSelectedIcon(), s = l.removeIcon || t.removeIcon && t.removeIcon(), o = W ?? H(Be, null, null), F = (i) => H(st, null, [V !== !1 && i, a && U]);
  let N = null;
  if (h !== void 0)
    N = F(h);
  else if (n)
    N = F(H(pe, {
      spin: !0
    }, null));
  else {
    const i = `${d}-suffix`;
    N = (c) => {
      let {
        open: R,
        showSearch: m
      } = c;
      return F(R && m ? H(Dd, {
        class: i
      }, null) : H(Xi, {
        class: i
      }, null));
    };
  }
  let Q = null;
  Z !== void 0 ? Q = Z : e ? Q = H(Yi, null, null) : Q = null;
  let u = null;
  return s !== void 0 ? u = s : u = H(Id, null, null), {
    clearIcon: o,
    suffixIcon: N,
    itemIcon: Q,
    removeIcon: u
  };
}
function yi(l) {
  const t = Symbol("contextKey");
  return {
    useProvide: (d, a) => {
      const U = Nt({});
      return nt(t, U), it(() => {
        j(U, d, a || {});
      }), U;
    },
    useInject: () => fl(t, l) || {}
  };
}
const Ka = Symbol("ContextProps"), Ha = Symbol("InternalContextProps"), Pa = {
  id: Zl(() => {
  }),
  onFieldBlur: () => {
  },
  onFieldChange: () => {
  },
  clearValidate: () => {
  }
}, Aa = {
  addFormItemField: () => {
  },
  removeFormItemField: () => {
  }
}, Bi = () => {
  const l = fl(Ha, Aa), t = Symbol("FormItemFieldKey"), n = Jn();
  return l.addFormItemField(t, n.type), Wt(() => {
    l.removeFormItemField(t);
  }), nt(Ha, Aa), nt(Ka, Pa), fl(Ka, Pa);
};
pl({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItemRest",
  setup(l, t) {
    let {
      slots: n
    } = t;
    return nt(Ha, Aa), nt(Ka, Pa), () => {
      var e;
      return (e = n.default) === null || e === void 0 ? void 0 : e.call(n);
    };
  }
});
const Gn = yi({}), Cc = pl({
  name: "NoFormStatus",
  setup(l, t) {
    let {
      slots: n
    } = t;
    return Gn.useProvide({}), () => {
      var e;
      return (e = n.default) === null || e === void 0 ? void 0 : e.call(n);
    };
  }
});
function On(l, t, n) {
  return Xl({
    [`${l}-status-success`]: t === "success",
    [`${l}-status-warning`]: t === "warning",
    [`${l}-status-error`]: t === "error",
    [`${l}-status-validating`]: t === "validating",
    [`${l}-has-feedback`]: n
  });
}
const Cd = (l, t) => t || l, nm = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [t]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
}, em = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [t]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${t}-space-item`]: {
        "&:empty": {
          display: "none"
        }
      }
    }
  };
}, dm = $t("Space", (l) => [em(l), nm(l)]);
var am = dZ(Object.getPrototypeOf, Object), im = "[object Object]", sm = Function.prototype, cm = Object.prototype, BZ = sm.toString, Um = cm.hasOwnProperty, Zm = BZ.call(Object);
function Fm(l) {
  if (!Sn(l) || Ln(l) != im)
    return !1;
  var t = am(l);
  if (t === null)
    return !0;
  var n = Um.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && BZ.call(n) == Zm;
}
var om = "[object Map]", Vm = "[object Set]", Qm = Object.prototype, Wm = Qm.hasOwnProperty;
function zZ(l) {
  if (l == null)
    return !0;
  if (iZ(l) && (re(l) || typeof l == "string" || typeof l.splice == "function" || Vd(l) || Ri(l) || _0(l)))
    return !l.length;
  var t = Kt(l);
  if (t == om || t == Vm)
    return !l.size;
  if (eZ(l))
    return !aZ(l).length;
  for (var n in l)
    if (Wm.call(l, n))
      return !1;
  return !0;
}
var hm = "[object Number]";
function Rm(l) {
  return typeof l == "number" || Sn(l) && Ln(l) == hm;
}
const Nm = () => ({
  compactSize: String,
  compactDirection: ol.oneOf(he("horizontal", "vertical")).def("horizontal"),
  isFirstItem: zt(),
  isLastItem: zt()
}), wd = yi(null), zi = (l, t) => {
  const n = wd.useInject(), e = Zl(() => {
    if (!n || zZ(n))
      return "";
    const {
      compactDirection: d,
      isFirstItem: a,
      isLastItem: U
    } = n, V = d === "vertical" ? "-vertical-" : "-";
    return Xl({
      [`${l.value}-compact${V}item`]: !0,
      [`${l.value}-compact${V}first-item`]: a,
      [`${l.value}-compact${V}last-item`]: U,
      [`${l.value}-compact${V}item-rtl`]: t.value === "rtl"
    });
  });
  return {
    compactSize: Zl(() => n?.compactSize),
    compactDirection: Zl(() => n?.compactDirection),
    compactItemClassnames: e
  };
}, wc = pl({
  name: "NoCompactStyle",
  setup(l, t) {
    let {
      slots: n
    } = t;
    return wd.useProvide(null), () => {
      var e;
      return (e = n.default) === null || e === void 0 ? void 0 : e.call(n);
    };
  }
}), bm = () => ({
  prefixCls: String,
  size: {
    type: String
  },
  direction: ol.oneOf(he("horizontal", "vertical")).def("horizontal"),
  align: ol.oneOf(he("start", "end", "center", "baseline")),
  block: {
    type: Boolean,
    default: void 0
  }
}), mm = pl({
  name: "CompactItem",
  props: Nm(),
  setup(l, t) {
    let {
      slots: n
    } = t;
    return wd.useProvide(l), () => {
      var e;
      return (e = n.default) === null || e === void 0 ? void 0 : e.call(n);
    };
  }
});
pl({
  name: "ASpaceCompact",
  inheritAttrs: !1,
  props: bm(),
  setup(l, t) {
    let {
      attrs: n,
      slots: e
    } = t;
    const {
      prefixCls: d,
      direction: a
    } = ht("space-compact", l), U = wd.useInject(), [V, h] = dm(d), W = Zl(() => Xl(d.value, h.value, {
      [`${d.value}-rtl`]: a.value === "rtl",
      [`${d.value}-block`]: l.block,
      [`${d.value}-vertical`]: l.direction === "vertical"
    }));
    return () => {
      var Z;
      const s = Tt(((Z = e.default) === null || Z === void 0 ? void 0 : Z.call(e)) || []);
      return s.length === 0 ? null : V(H("div", Ql(Ql({}, n), {}, {
        class: [W.value, n.class]
      }), [s.map((o, F) => {
        var N;
        const Q = o && o.key || `${d.value}-item-${F}`, u = !U || zZ(U);
        return H(mm, {
          key: Q,
          compactSize: (N = l.size) !== null && N !== void 0 ? N : "middle",
          compactDirection: l.direction,
          isFirstItem: F === 0 && (u || U?.isFirstItem),
          isLastItem: F === s.length - 1 && (u || U?.isLastItem)
        }, {
          default: () => [o]
        });
      })]));
    };
  }
});
const um = (l) => ({
  animationDuration: l,
  animationFillMode: "both"
}), rm = (l) => ({
  animationDuration: l,
  animationFillMode: "both"
}), Ed = function(l, t, n, e) {
  const a = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${a}${l}-enter,
      ${a}${l}-appear
    `]: j(j({}, um(e)), {
      animationPlayState: "paused"
    }),
    [`${a}${l}-leave`]: j(j({}, rm(e)), {
      animationPlayState: "paused"
    }),
    [`
      ${a}${l}-enter${l}-enter-active,
      ${a}${l}-appear${l}-appear-active
    `]: {
      animationName: t,
      animationPlayState: "running"
    },
    [`${a}${l}-leave${l}-leave-active`]: {
      animationName: n,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, Mm = new xl("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), pm = new xl("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
}), LZ = function(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const {
    antCls: n
  } = l, e = `${n}-fade`, d = t ? "&" : "";
  return [Ed(e, Mm, pm, l.motionDurationMid, t), {
    [`
        ${d}${e}-enter,
        ${d}${e}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${d}${e}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
}, Sm = new xl("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), Tm = new xl("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), Gm = new xl("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), Jm = new xl("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), Xm = new xl("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), Ym = new xl("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), ym = new xl("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), Bm = new xl("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), zm = {
  "move-up": {
    inKeyframes: ym,
    outKeyframes: Bm
  },
  "move-down": {
    inKeyframes: Sm,
    outKeyframes: Tm
  },
  "move-left": {
    inKeyframes: Gm,
    outKeyframes: Jm
  },
  "move-right": {
    inKeyframes: Xm,
    outKeyframes: Ym
  }
}, Ec = (l, t) => {
  const {
    antCls: n
  } = l, e = `${n}-${t}`, {
    inKeyframes: d,
    outKeyframes: a
  } = zm[t];
  return [Ed(e, d, a, l.motionDurationMid), {
    [`
        ${e}-enter,
        ${e}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: l.motionEaseOutCirc
    },
    [`${e}-leave`]: {
      animationTimingFunction: l.motionEaseInOutCirc
    }
  }];
}, kZ = new xl("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), IZ = new xl("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), DZ = new xl("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), CZ = new xl("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), Lm = new xl("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), km = new xl("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), Im = new xl("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), Dm = new xl("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), Cm = {
  "slide-up": {
    inKeyframes: kZ,
    outKeyframes: IZ
  },
  "slide-down": {
    inKeyframes: DZ,
    outKeyframes: CZ
  },
  "slide-left": {
    inKeyframes: Lm,
    outKeyframes: km
  },
  "slide-right": {
    inKeyframes: Im,
    outKeyframes: Dm
  }
}, xc = (l, t) => {
  const {
    antCls: n
  } = l, e = `${n}-${t}`, {
    inKeyframes: d,
    outKeyframes: a
  } = Cm[t];
  return [Ed(e, d, a, l.motionDurationMid), {
    [`
      ${e}-enter,
      ${e}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: l.motionEaseOutQuint
    },
    [`${e}-leave`]: {
      animationTimingFunction: l.motionEaseInQuint
    }
  }];
}, wm = new xl("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), Em = new xl("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), gc = new xl("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), jc = new xl("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), xm = new xl("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), gm = new xl("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), jm = new xl("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), Om = new xl("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), vm = new xl("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), fm = new xl("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), Km = new xl("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), Hm = new xl("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), Pm = {
  zoom: {
    inKeyframes: wm,
    outKeyframes: Em
  },
  "zoom-big": {
    inKeyframes: gc,
    outKeyframes: jc
  },
  "zoom-big-fast": {
    inKeyframes: gc,
    outKeyframes: jc
  },
  "zoom-left": {
    inKeyframes: jm,
    outKeyframes: Om
  },
  "zoom-right": {
    inKeyframes: vm,
    outKeyframes: fm
  },
  "zoom-up": {
    inKeyframes: xm,
    outKeyframes: gm
  },
  "zoom-down": {
    inKeyframes: Km,
    outKeyframes: Hm
  }
}, wZ = (l, t) => {
  const {
    antCls: n
  } = l, e = `${n}-${t}`, {
    inKeyframes: d,
    outKeyframes: a
  } = Pm[t];
  return [Ed(e, d, a, t === "zoom-big-fast" ? l.motionDurationFast : l.motionDurationMid), {
    [`
        ${e}-enter,
        ${e}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: l.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${e}-leave`]: {
      animationTimingFunction: l.motionEaseInOutCirc
    }
  }];
}, Oc = (l) => {
  const {
    controlPaddingHorizontal: t
  } = l;
  return {
    position: "relative",
    display: "block",
    minHeight: l.controlHeight,
    padding: `${(l.controlHeight - l.fontSize * l.lineHeight) / 2}px ${t}px`,
    color: l.colorText,
    fontWeight: "normal",
    fontSize: l.fontSize,
    lineHeight: l.lineHeight,
    boxSizing: "border-box"
  };
}, Am = (l) => {
  const {
    antCls: t,
    componentCls: n
  } = l, e = `${n}-item`;
  return [
    {
      [`${n}-dropdown`]: j(j({}, sn(l)), {
        position: "absolute",
        top: -9999,
        zIndex: l.zIndexPopup,
        boxSizing: "border-box",
        padding: l.paddingXXS,
        overflow: "hidden",
        fontSize: l.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: l.colorBgElevated,
        borderRadius: l.borderRadiusLG,
        outline: "none",
        boxShadow: l.boxShadowSecondary,
        [`
            &${t}-slide-up-enter${t}-slide-up-enter-active${n}-dropdown-placement-bottomLeft,
            &${t}-slide-up-appear${t}-slide-up-appear-active${n}-dropdown-placement-bottomLeft
          `]: {
          animationName: kZ
        },
        [`
            &${t}-slide-up-enter${t}-slide-up-enter-active${n}-dropdown-placement-topLeft,
            &${t}-slide-up-appear${t}-slide-up-appear-active${n}-dropdown-placement-topLeft
          `]: {
          animationName: DZ
        },
        [`&${t}-slide-up-leave${t}-slide-up-leave-active${n}-dropdown-placement-bottomLeft`]: {
          animationName: IZ
        },
        [`&${t}-slide-up-leave${t}-slide-up-leave-active${n}-dropdown-placement-topLeft`]: {
          animationName: CZ
        },
        "&-hidden": {
          display: "none"
        },
        "&-empty": {
          color: l.colorTextDisabled
        },
        // ========================= Options =========================
        [`${e}-empty`]: j(j({}, Oc(l)), {
          color: l.colorTextDisabled
        }),
        [`${e}`]: j(j({}, Oc(l)), {
          cursor: "pointer",
          transition: `background ${l.motionDurationSlow} ease`,
          borderRadius: l.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: l.colorTextDescription,
            fontSize: l.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": j({
              flex: "auto"
            }, Ud),
            "&-state": {
              flex: "none"
            },
            [`&-active:not(${e}-option-disabled)`]: {
              backgroundColor: l.controlItemBgHover
            },
            [`&-selected:not(${e}-option-disabled)`]: {
              color: l.colorText,
              fontWeight: l.fontWeightStrong,
              backgroundColor: l.controlItemBgActive,
              [`${e}-option-state`]: {
                color: l.colorPrimary
              }
            },
            "&-disabled": {
              [`&${e}-option-selected`]: {
                backgroundColor: l.colorBgContainerDisabled
              },
              color: l.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: l.controlPaddingHorizontal * 2
            }
          }
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    xc(l, "slide-up"),
    xc(l, "slide-down"),
    Ec(l, "move-up"),
    Ec(l, "move-down")
  ];
}, wn = 2;
function EZ(l) {
  let {
    controlHeightSM: t,
    controlHeight: n,
    lineWidth: e
  } = l;
  const d = (n - t) / 2 - e, a = Math.ceil(d / 2);
  return [d, a];
}
function oa(l, t) {
  const {
    componentCls: n,
    iconCls: e
  } = l, d = `${n}-selection-overflow`, a = l.controlHeightSM, [U] = EZ(l), V = t ? `${n}-${t}` : "";
  return {
    [`${n}-multiple${V}`]: {
      fontSize: l.fontSize,
      /**
       * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
       * may update to redesign with its align logic.
       */
      // =========================== Overflow ===========================
      [d]: {
        position: "relative",
        display: "flex",
        flex: "auto",
        flexWrap: "wrap",
        maxWidth: "100%",
        "&-item": {
          flex: "none",
          alignSelf: "center",
          maxWidth: "100%",
          display: "inline-flex"
        }
      },
      // ========================= Selector =========================
      [`${n}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        // Multiple is little different that horizontal is follow the vertical
        padding: `${U - wn}px ${wn * 2}px`,
        borderRadius: l.borderRadius,
        [`${n}-show-search&`]: {
          cursor: "text"
        },
        [`${n}-disabled&`]: {
          background: l.colorBgContainerDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${wn}px 0`,
          lineHeight: `${a}px`,
          content: '"\\a0"'
        }
      },
      [`
        &${n}-show-arrow ${n}-selector,
        &${n}-allow-clear ${n}-selector
      `]: {
        paddingInlineEnd: l.fontSizeIcon + l.controlPaddingHorizontal
      },
      // ======================== Selections ========================
      [`${n}-selection-item`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        height: a,
        marginTop: wn,
        marginBottom: wn,
        lineHeight: `${a - l.lineWidth * 2}px`,
        background: l.colorFillSecondary,
        border: `${l.lineWidth}px solid ${l.colorSplit}`,
        borderRadius: l.borderRadiusSM,
        cursor: "default",
        transition: `font-size ${l.motionDurationSlow}, line-height ${l.motionDurationSlow}, height ${l.motionDurationSlow}`,
        userSelect: "none",
        marginInlineEnd: wn * 2,
        paddingInlineStart: l.paddingXS,
        paddingInlineEnd: l.paddingXS / 2,
        [`${n}-disabled&`]: {
          color: l.colorTextDisabled,
          borderColor: l.colorBorder,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: l.paddingXS / 2,
          overflow: "hidden",
          whiteSpace: "pre",
          textOverflow: "ellipsis"
        },
        "&-remove": j(j({}, W0()), {
          display: "inline-block",
          color: l.colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${e}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: l.colorIconHover
          }
        })
      },
      // ========================== Input ==========================
      [`${d}-item + ${d}-item`]: {
        [`${n}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      [`${n}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: l.inputPaddingHorizontalBase - U,
        "\n          &-input,\n          &-mirror\n        ": {
          height: a,
          fontFamily: l.fontFamily,
          lineHeight: `${a}px`,
          transition: `all ${l.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${n}-selection-placeholder `]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: l.inputPaddingHorizontalBase,
        insetInlineEnd: l.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${l.motionDurationSlow}`
      }
    }
  };
}
function $m(l) {
  const {
    componentCls: t
  } = l, n = tt(l, {
    controlHeight: l.controlHeightSM,
    controlHeightSM: l.controlHeightXS,
    borderRadius: l.borderRadiusSM,
    borderRadiusSM: l.borderRadiusXS
  }), [, e] = EZ(l);
  return [
    oa(l),
    // ======================== Small ========================
    // Shared
    oa(n, "sm"),
    // Padding
    {
      [`${t}-multiple${t}-sm`]: {
        [`${t}-selection-placeholder`]: {
          insetInlineStart: l.controlPaddingHorizontalSM - l.lineWidth,
          insetInlineEnd: "auto"
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${t}-selection-search`]: {
          marginInlineStart: e
        }
      }
    },
    // ======================== Large ========================
    // Shared
    oa(tt(l, {
      fontSize: l.fontSizeLG,
      controlHeight: l.controlHeightLG,
      controlHeightSM: l.controlHeight,
      borderRadius: l.borderRadiusLG,
      borderRadiusSM: l.borderRadius
    }), "lg")
  ];
}
function Va(l, t) {
  const {
    componentCls: n,
    inputPaddingHorizontalBase: e,
    borderRadius: d
  } = l, a = l.controlHeight - l.lineWidth * 2, U = Math.ceil(l.fontSize * 1.25), V = t ? `${n}-${t}` : "";
  return {
    [`${n}-single${V}`]: {
      fontSize: l.fontSize,
      // ========================= Selector =========================
      [`${n}-selector`]: j(j({}, sn(l)), {
        display: "flex",
        borderRadius: d,
        [`${n}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: e,
          insetInlineEnd: e,
          bottom: 0,
          "&-input": {
            width: "100%"
          }
        },
        [`
          ${n}-selection-item,
          ${n}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: `${a}px`,
          transition: `all ${l.motionDurationSlow}`,
          // Firefox inline-block position calculation is not same as Chrome & Safari. Patch this:
          "@supports (-moz-appearance: meterbar)": {
            lineHeight: `${a}px`
          }
        },
        [`${n}-selection-item`]: {
          position: "relative",
          userSelect: "none"
        },
        [`${n}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${n}-selection-item:after`,
          /* For undefined value baseline align */
          `${n}-selection-placeholder:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${n}-show-arrow ${n}-selection-item,
        &${n}-show-arrow ${n}-selection-placeholder
      `]: {
        paddingInlineEnd: U
      },
      // Opacity selection if open
      [`&${n}-open ${n}-selection-item`]: {
        color: l.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${n}-customize-input)`]: {
        [`${n}-selector`]: {
          width: "100%",
          height: l.controlHeight,
          padding: `0 ${e}px`,
          [`${n}-selection-search-input`]: {
            height: a
          },
          "&:after": {
            lineHeight: `${a}px`
          }
        }
      },
      [`&${n}-customize-input`]: {
        [`${n}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${n}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${n}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${e}px`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function qm(l) {
  const {
    componentCls: t
  } = l, n = l.controlPaddingHorizontalSM - l.lineWidth;
  return [
    Va(l),
    // ======================== Small ========================
    // Shared
    Va(tt(l, {
      controlHeight: l.controlHeightSM,
      borderRadius: l.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${t}-single${t}-sm`]: {
        [`&:not(${t}-customize-input)`]: {
          [`${t}-selection-search`]: {
            insetInlineStart: n,
            insetInlineEnd: n
          },
          [`${t}-selector`]: {
            padding: `0 ${n}px`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${t}-show-arrow ${t}-selection-search`]: {
            insetInlineEnd: n + l.fontSize * 1.5
          },
          [`
            &${t}-show-arrow ${t}-selection-item,
            &${t}-show-arrow ${t}-selection-placeholder
          `]: {
            paddingInlineEnd: l.fontSize * 1.5
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    Va(tt(l, {
      controlHeight: l.controlHeightLG,
      fontSize: l.fontSizeLG,
      borderRadius: l.borderRadiusLG
    }), "lg")
  ];
}
function _m(l, t, n) {
  const {
    focusElCls: e,
    focus: d,
    borderElCls: a
  } = n, U = a ? "> *" : "", V = ["hover", d ? "focus" : null, "active"].filter(Boolean).map((h) => `&:${h} ${U}`).join(",");
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginInlineEnd: -l.lineWidth
    },
    "&-item": j(j({
      [V]: {
        zIndex: 2
      }
    }, e ? {
      [`&${e}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${U}`]: {
        zIndex: 0
      }
    })
  };
}
function lu(l, t, n) {
  const {
    borderElCls: e
  } = n, d = e ? `> ${e}` : "";
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item) ${d}`]: {
      borderRadius: 0
    },
    [`&-item:not(${t}-last-item)${t}-first-item`]: {
      [`& ${d}, &${l}-sm ${d}, &${l}-lg ${d}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${t}-first-item)${t}-last-item`]: {
      [`& ${d}, &${l}-sm ${d}, &${l}-lg ${d}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function Li(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: n
  } = l, e = `${n}-compact`;
  return {
    [e]: j(j({}, _m(l, e, t)), lu(n, e, t))
  };
}
const tu = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    position: "relative",
    backgroundColor: l.colorBgContainer,
    border: `${l.lineWidth}px ${l.lineType} ${l.colorBorder}`,
    transition: `all ${l.motionDurationMid} ${l.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${t}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit"
      }
    },
    [`${t}-disabled&`]: {
      color: l.colorTextDisabled,
      background: l.colorBgContainerDisabled,
      cursor: "not-allowed",
      [`${t}-multiple&`]: {
        background: l.colorBgContainerDisabled
      },
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, Qa = function(l, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const {
    componentCls: e,
    borderHoverColor: d,
    outlineColor: a,
    antCls: U
  } = t, V = n ? {
    [`${e}-selector`]: {
      borderColor: d
    }
  } : {};
  return {
    [l]: {
      [`&:not(${e}-disabled):not(${e}-customize-input):not(${U}-pagination-size-changer)`]: j(j({}, V), {
        [`${e}-focused& ${e}-selector`]: {
          borderColor: d,
          boxShadow: `0 0 0 ${t.controlOutlineWidth}px ${a}`,
          borderInlineEndWidth: `${t.controlLineWidth}px !important`,
          outline: 0
        },
        [`&:hover ${e}-selector`]: {
          borderColor: d,
          borderInlineEndWidth: `${t.controlLineWidth}px !important`
        }
      })
    }
  };
}, nu = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [`${t}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, eu = (l) => {
  const {
    componentCls: t,
    inputPaddingHorizontalBase: n,
    iconCls: e
  } = l;
  return {
    [t]: j(j({}, sn(l)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${t}-customize-input) ${t}-selector`]: j(j({}, tu(l)), nu(l)),
      // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
      //   ...genHoverStyle(token),
      // },
      // ======================== Selection ========================
      [`${t}-selection-item`]: j({
        flex: 1,
        fontWeight: "normal"
      }, Ud),
      // ======================= Placeholder =======================
      [`${t}-selection-placeholder`]: j(j({}, Ud), {
        flex: 1,
        color: l.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${t}-arrow`]: j(j({}, W0()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        height: l.fontSizeIcon,
        marginTop: -l.fontSizeIcon / 2,
        color: l.colorTextQuaternary,
        fontSize: l.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        [e]: {
          verticalAlign: "top",
          transition: `transform ${l.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${t}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${t}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Clear ==========================
      [`${t}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        zIndex: 1,
        display: "inline-block",
        width: l.fontSizeIcon,
        height: l.fontSizeIcon,
        marginTop: -l.fontSizeIcon / 2,
        color: l.colorTextQuaternary,
        fontSize: l.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        background: l.colorBgContainer,
        cursor: "pointer",
        opacity: 0,
        transition: `color ${l.motionDurationMid} ease, opacity ${l.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: l.colorTextTertiary
        }
      },
      "&:hover": {
        [`${t}-clear`]: {
          opacity: 1
        }
      }
    }),
    // ========================= Feedback ==========================
    [`${t}-has-feedback`]: {
      [`${t}-clear`]: {
        insetInlineEnd: n + l.fontSize + l.paddingXXS
      }
    }
  };
}, du = (l) => {
  const {
    componentCls: t
  } = l;
  return [
    {
      [t]: {
        // ==================== BorderLess ====================
        [`&-borderless ${t}-selector`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ==================== In Form ====================
        [`&${t}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    eu(l),
    // Single
    qm(l),
    // Multiple
    $m(l),
    // Dropdown
    Am(l),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${t}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==                     Status                      ==
    // =====================================================
    Qa(t, tt(l, {
      borderHoverColor: l.colorPrimaryHover,
      outlineColor: l.controlOutline
    })),
    Qa(`${t}-status-error`, tt(l, {
      borderHoverColor: l.colorErrorHover,
      outlineColor: l.colorErrorOutline
    }), !0),
    Qa(`${t}-status-warning`, tt(l, {
      borderHoverColor: l.colorWarningHover,
      outlineColor: l.colorWarningOutline
    }), !0),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Li(l, {
      borderElCls: `${t}-selector`,
      focusElCls: `${t}-focused`
    })
  ];
}, au = $t("Select", (l, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const e = tt(l, {
    rootPrefixCls: n,
    inputPaddingHorizontalBase: l.paddingSM - 1
  });
  return [du(e)];
}, (l) => ({
  zIndexPopup: l.zIndexPopupBase + 50
})), ki = () => j(j({}, ut(MZ(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {
  value: ed([Array, Object, String, Number]),
  defaultValue: ed([Array, Object, String, Number]),
  notFoundContent: ol.any,
  suffixIcon: ol.any,
  itemIcon: ol.any,
  size: Ht(),
  mode: Ht(),
  bordered: zt(!0),
  transitionName: String,
  choiceTransitionName: Ht(""),
  popupClassName: String,
  /** @deprecated Please use `popupClassName` instead */
  dropdownClassName: String,
  placement: Ht(),
  status: Ht(),
  "onUpdate:value": ln()
}), vc = "SECRET_COMBOBOX_MODE_DO_NOT_USE", wt = pl({
  compatConfig: {
    MODE: 3
  },
  name: "ASelect",
  Option: Si,
  OptGroup: Ti,
  inheritAttrs: !1,
  props: yn(ki(), {
    listHeight: 256,
    listItemHeight: 24
  }),
  SECRET_COMBOBOX_MODE_DO_NOT_USE: vc,
  slots: Object,
  setup(l, t) {
    let {
      attrs: n,
      emit: e,
      slots: d,
      expose: a
    } = t;
    const U = Ml(), V = Bi(), h = Gn.useInject(), W = Zl(() => Cd(h.status, l.status)), Z = () => {
      var dl;
      (dl = U.value) === null || dl === void 0 || dl.focus();
    }, s = () => {
      var dl;
      (dl = U.value) === null || dl === void 0 || dl.blur();
    }, o = (dl) => {
      var tl;
      (tl = U.value) === null || tl === void 0 || tl.scrollTo(dl);
    }, F = Zl(() => {
      const {
        mode: dl
      } = l;
      if (dl !== "combobox")
        return dl === vc ? "combobox" : dl;
    });
    process.env.NODE_ENV !== "production" && Zi(!l.dropdownClassName, "Select", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const {
      prefixCls: N,
      direction: Q,
      configProvider: u,
      renderEmpty: i,
      size: c,
      getPrefixCls: R,
      getPopupContainer: m,
      disabled: M,
      select: S
    } = ht("select", l), {
      compactSize: p,
      compactItemClassnames: Y
    } = zi(N, Q), k = Zl(() => p.value || c.value), L = Ge(), z = Zl(() => {
      var dl;
      return (dl = M.value) !== null && dl !== void 0 ? dl : L.value;
    }), [f, K] = au(N), P = Zl(() => R()), w = Zl(() => l.placement !== void 0 ? l.placement : Q.value === "rtl" ? "bottomRight" : "bottomLeft"), O = Zl(() => An(P.value, xR(w.value), l.transitionName)), el = Zl(() => Xl({
      [`${N.value}-lg`]: k.value === "large",
      [`${N.value}-sm`]: k.value === "small",
      [`${N.value}-rtl`]: Q.value === "rtl",
      [`${N.value}-borderless`]: !l.bordered,
      [`${N.value}-in-form-item`]: h.isFormItemInput
    }, On(N.value, W.value, h.hasFeedback), Y.value, K.value)), ll = function() {
      for (var dl = arguments.length, tl = new Array(dl), al = 0; al < dl; al++)
        tl[al] = arguments[al];
      e("update:value", tl[0]), e("change", ...tl), V.onFieldChange();
    }, q = (dl) => {
      e("blur", dl), V.onFieldBlur();
    };
    a({
      blur: s,
      focus: Z,
      scrollTo: o
    });
    const _ = Zl(() => F.value === "multiple" || F.value === "tags"), il = Zl(() => l.showArrow !== void 0 ? l.showArrow : l.loading || !(_.value || F.value === "combobox"));
    return () => {
      var dl, tl, al, Ul;
      const {
        notFoundContent: cl,
        listHeight: B = 256,
        listItemHeight: X = 24,
        popupClassName: b,
        dropdownClassName: r,
        virtual: G,
        dropdownMatchSelectWidth: J,
        id: T = V.id.value,
        placeholder: y = (dl = d.placeholder) === null || dl === void 0 ? void 0 : dl.call(d),
        showArrow: I
      } = l, {
        hasFeedback: E,
        feedbackIcon: x
      } = h;
      let v;
      cl !== void 0 ? v = cl : d.notFoundContent ? v = d.notFoundContent() : F.value === "combobox" ? v = null : v = i?.("Select") || H(M0, {
        componentName: "Select"
      }, null);
      const {
        suffixIcon: A,
        itemIcon: g,
        removeIcon: D,
        clearIcon: C
      } = tm(j(j({}, l), {
        multiple: _.value,
        prefixCls: N.value,
        hasFeedback: E,
        feedbackIcon: x,
        showArrow: il.value
      }), d), nl = ut(l, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered", "status"]), Fl = Xl(b || r, {
        [`${N.value}-dropdown-${Q.value}`]: Q.value === "rtl"
      }, K.value);
      return f(H(sb, Ql(Ql(Ql({
        ref: U,
        virtual: G,
        dropdownMatchSelectWidth: J
      }, nl), n), {}, {
        showSearch: (tl = l.showSearch) !== null && tl !== void 0 ? tl : (al = S?.value) === null || al === void 0 ? void 0 : al.showSearch,
        placeholder: y,
        listHeight: B,
        listItemHeight: X,
        mode: F.value,
        prefixCls: N.value,
        direction: Q.value,
        inputIcon: A,
        menuItemSelectedIcon: g,
        removeIcon: D,
        clearIcon: C,
        notFoundContent: v,
        class: [el.value, n.class],
        getPopupContainer: m?.value,
        dropdownClassName: Fl,
        onChange: ll,
        onBlur: q,
        id: T,
        dropdownRender: nl.dropdownRender || d.dropdownRender,
        transitionName: O.value,
        children: (Ul = d.default) === null || Ul === void 0 ? void 0 : Ul.call(d),
        tagRender: l.tagRender || d.tagRender,
        optionLabelRender: d.optionLabel,
        maxTagPlaceholder: l.maxTagPlaceholder || d.maxTagPlaceholder,
        showArrow: E || I,
        disabled: z.value
      }), {
        option: d.option
      }));
    };
  }
});
wt.install = function(l) {
  return l.component(wt.name, wt), l.component(wt.Option.displayName, wt.Option), l.component(wt.OptGroup.displayName, wt.OptGroup), l;
};
wt.Option;
wt.OptGroup;
const Wd = wt, iu = (l) => ({
  xs: `(max-width: ${l.screenXSMax}px)`,
  sm: `(min-width: ${l.screenSM}px)`,
  md: `(min-width: ${l.screenMD}px)`,
  lg: `(min-width: ${l.screenLG}px)`,
  xl: `(min-width: ${l.screenXL}px)`,
  xxl: `(min-width: ${l.screenXXL}px)`,
  xxxl: `{min-width: ${l.screenXXXL}px}`
});
function su() {
  const [, l] = Xe();
  return Zl(() => {
    const t = iu(l.value), n = /* @__PURE__ */ new Map();
    let e = -1, d = {};
    return {
      matchHandlers: {},
      dispatch(a) {
        return d = a, n.forEach((U) => U(d)), n.size >= 1;
      },
      subscribe(a) {
        return n.size || this.register(), e += 1, n.set(e, a), a(d), e;
      },
      unsubscribe(a) {
        n.delete(a), n.size || this.unregister();
      },
      unregister() {
        Object.keys(t).forEach((a) => {
          const U = t[a], V = this.matchHandlers[U];
          V?.mql.removeListener(V?.listener);
        }), n.clear();
      },
      register() {
        Object.keys(t).forEach((a) => {
          const U = t[a], V = (W) => {
            let {
              matches: Z
            } = W;
            this.dispatch(j(j({}, d), {
              [a]: Z
            }));
          }, h = window.matchMedia(U);
          h.addListener(V), this.matchHandlers[U] = {
            mql: h,
            listener: V
          }, V(h);
        });
      },
      responsiveMap: t
    };
  });
}
function cu() {
  const l = bl({});
  let t = null;
  const n = su();
  return ql(() => {
    t = n.value.subscribe((e) => {
      l.value = e;
    });
  }), Xn(() => {
    n.value.unsubscribe(t);
  }), l;
}
const Xt = {
  adjustX: 1,
  adjustY: 1
}, Yt = [0, 0], xZ = {
  left: {
    points: ["cr", "cl"],
    overflow: Xt,
    offset: [-4, 0],
    targetOffset: Yt
  },
  right: {
    points: ["cl", "cr"],
    overflow: Xt,
    offset: [4, 0],
    targetOffset: Yt
  },
  top: {
    points: ["bc", "tc"],
    overflow: Xt,
    offset: [0, -4],
    targetOffset: Yt
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: Xt,
    offset: [0, 4],
    targetOffset: Yt
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: Xt,
    offset: [0, -4],
    targetOffset: Yt
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Xt,
    offset: [-4, 0],
    targetOffset: Yt
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Xt,
    offset: [0, -4],
    targetOffset: Yt
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Xt,
    offset: [4, 0],
    targetOffset: Yt
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Xt,
    offset: [0, 4],
    targetOffset: Yt
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Xt,
    offset: [4, 0],
    targetOffset: Yt
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Xt,
    offset: [0, 4],
    targetOffset: Yt
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Xt,
    offset: [-4, 0],
    targetOffset: Yt
  }
}, Uu = {
  prefixCls: String,
  id: String,
  overlayInnerStyle: ol.any
}, Zu = pl({
  compatConfig: {
    MODE: 3
  },
  name: "TooltipContent",
  props: Uu,
  setup(l, t) {
    let {
      slots: n
    } = t;
    return () => {
      var e;
      return H("div", {
        class: `${l.prefixCls}-inner`,
        id: l.id,
        role: "tooltip",
        style: l.overlayInnerStyle
      }, [(e = n.overlay) === null || e === void 0 ? void 0 : e.call(n)]);
    };
  }
});
var Fu = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
function fc() {
}
const ou = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Tooltip",
  inheritAttrs: !1,
  props: {
    trigger: ol.any.def(["hover"]),
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: ol.string.def("right"),
    transitionName: String,
    animation: ol.any,
    afterVisibleChange: ol.func.def(() => {
    }),
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    prefixCls: ol.string.def("rc-tooltip"),
    mouseEnterDelay: ol.number.def(0.1),
    mouseLeaveDelay: ol.number.def(0.1),
    getPopupContainer: Function,
    destroyTooltipOnHide: {
      type: Boolean,
      default: !1
    },
    align: ol.object.def(() => ({})),
    arrowContent: ol.any.def(null),
    tipId: String,
    builtinPlacements: ol.object,
    overlayInnerStyle: {
      type: Object,
      default: void 0
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: Function,
    onPopupAlign: Function,
    arrow: {
      type: Boolean,
      default: !0
    }
  },
  setup(l, t) {
    let {
      slots: n,
      attrs: e,
      expose: d
    } = t;
    const a = bl(), U = () => {
      const {
        prefixCls: Z,
        tipId: s,
        overlayInnerStyle: o
      } = l;
      return [l.arrow ? H("div", {
        class: `${Z}-arrow`,
        key: "arrow"
      }, [Yo(n, l, "arrowContent")]) : null, H(Zu, {
        key: "content",
        prefixCls: Z,
        id: s,
        overlayInnerStyle: o
      }, {
        overlay: n.overlay
      })];
    };
    d({
      getPopupDomNode: () => a.value.getPopupDomNode(),
      triggerDOM: a,
      forcePopupAlign: () => {
        var Z;
        return (Z = a.value) === null || Z === void 0 ? void 0 : Z.forcePopupAlign();
      }
    });
    const h = bl(!1), W = bl(!1);
    return it(() => {
      const {
        destroyTooltipOnHide: Z
      } = l;
      if (typeof Z == "boolean")
        h.value = Z;
      else if (Z && typeof Z == "object") {
        const {
          keepParent: s
        } = Z;
        h.value = s === !0, W.value = s === !1;
      }
    }), () => {
      const {
        overlayClassName: Z,
        trigger: s,
        mouseEnterDelay: o,
        mouseLeaveDelay: F,
        overlayStyle: N,
        prefixCls: Q,
        afterVisibleChange: u,
        transitionName: i,
        animation: c,
        placement: R,
        align: m,
        destroyTooltipOnHide: M,
        defaultVisible: S
      } = l, p = Fu(l, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]), Y = j({}, p);
      l.visible !== void 0 && (Y.popupVisible = l.visible);
      const k = j(j(j({
        popupClassName: Z,
        prefixCls: Q,
        action: s,
        builtinPlacements: xZ,
        popupPlacement: R,
        popupAlign: m,
        afterPopupVisibleChange: u,
        popupTransitionName: i,
        popupAnimation: c,
        defaultPopupVisible: S,
        destroyPopupOnHide: h.value,
        autoDestroy: W.value,
        mouseLeaveDelay: F,
        popupStyle: N,
        mouseEnterDelay: o
      }, Y), e), {
        onPopupVisibleChange: l.onVisibleChange || fc,
        onPopupAlign: l.onPopupAlign || fc,
        ref: a,
        arrow: !!l.arrow,
        popup: U()
      });
      return H(FZ, k, {
        default: n.default
      });
    };
  }
}), Vu = () => ({
  trigger: [String, Array],
  open: {
    type: Boolean,
    default: void 0
  },
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  placement: String,
  color: String,
  transitionName: String,
  overlayStyle: dn(),
  overlayInnerStyle: dn(),
  overlayClassName: String,
  openClassName: String,
  prefixCls: String,
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  getPopupContainer: Function,
  /**@deprecated Please use `arrow={{ pointAtCenter: true }}` instead. */
  arrowPointAtCenter: {
    type: Boolean,
    default: void 0
  },
  arrow: {
    type: [Boolean, Object],
    default: !0
  },
  autoAdjustOverflow: {
    type: [Boolean, Object],
    default: void 0
  },
  destroyTooltipOnHide: {
    type: Boolean,
    default: void 0
  },
  align: dn(),
  builtinPlacements: dn(),
  children: Array,
  /** @deprecated Please use `onOpenChange` instead. */
  onVisibleChange: Function,
  /** @deprecated Please use `onUpdate:open` instead. */
  "onUpdate:visible": Function,
  onOpenChange: Function,
  "onUpdate:open": Function
}), Qu = {
  adjustX: 1,
  adjustY: 1
}, Kc = {
  adjustX: 0,
  adjustY: 0
}, Wu = [0, 0];
function Hc(l) {
  return typeof l == "boolean" ? l ? Qu : Kc : j(j({}, Kc), l);
}
function hu(l) {
  const {
    arrowWidth: t = 4,
    horizontalArrowShift: n = 16,
    verticalArrowShift: e = 8,
    autoAdjustOverflow: d,
    arrowPointAtCenter: a
  } = l, U = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(n + t), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(e + t)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [n + t, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(e + t)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [n + t, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, e + t]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(n + t), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, e + t]
    }
  };
  return Object.keys(U).forEach((V) => {
    U[V] = a ? j(j({}, U[V]), {
      overflow: Hc(d),
      targetOffset: Wu
    }) : j(j({}, xZ[V]), {
      overflow: Hc(d)
    }), U[V].ignoreShake = !0;
  }), U;
}
function $a() {
  let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  for (let t = 0, n = l.length; t < n; t++)
    if (l[t] !== void 0)
      return l[t];
}
const Ru = cd.map((l) => `${l}-inverse`);
function Nu(l) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [...Ru, ...cd].includes(l) : cd.includes(l);
}
function bu(l, t) {
  const n = Nu(t), e = Xl({
    [`${l}-${t}`]: t && n
  }), d = {}, a = {};
  return t && !n && (d.background = t, a["--antd-arrow-background-color"] = t), {
    className: e,
    overlayStyle: d,
    arrowStyle: a
  };
}
function Oe(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return l.map((n) => `${t}${n}`).join(",");
}
const gZ = 8;
function mu(l) {
  const t = gZ, {
    sizePopupArrow: n,
    contentRadius: e,
    borderRadiusOuter: d,
    limitVerticalRadius: a
  } = l, U = n / 2 - Math.ceil(d * (Math.sqrt(2) - 1)), V = (e > 12 ? e + 2 : 12) - U, h = a ? t - U : V;
  return {
    dropdownArrowOffset: V,
    dropdownArrowOffsetVertical: h
  };
}
function uu(l, t) {
  const {
    componentCls: n,
    sizePopupArrow: e,
    marginXXS: d,
    borderRadiusXS: a,
    borderRadiusOuter: U,
    boxShadowPopoverArrow: V
  } = l, {
    colorBg: h,
    showArrowCls: W,
    contentRadius: Z = l.borderRadiusLG,
    limitVerticalRadius: s
  } = t, {
    dropdownArrowOffsetVertical: o,
    dropdownArrowOffset: F
  } = mu({
    sizePopupArrow: e,
    contentRadius: Z,
    borderRadiusOuter: U,
    limitVerticalRadius: s
  }), N = e / 2 + d;
  return {
    [n]: {
      // ============================ Basic ============================
      [`${n}-arrow`]: [j(j({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, zV(e, a, U, h, V)), {
        "&:before": {
          background: h
        }
      })],
      // ========================== Placement ==========================
      // Here handle the arrow position and rotate stuff
      // >>>>> Top
      [[`&-placement-top ${n}-arrow`, `&-placement-topLeft ${n}-arrow`, `&-placement-topRight ${n}-arrow`].join(",")]: {
        bottom: 0,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: F
        }
      },
      [`&-placement-topRight ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: F
        }
      },
      // >>>>> Bottom
      [[`&-placement-bottom ${n}-arrow`, `&-placement-bottomLeft ${n}-arrow`, `&-placement-bottomRight ${n}-arrow`].join(",")]: {
        top: 0,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      [`&-placement-bottomLeft ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: F
        }
      },
      [`&-placement-bottomRight ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: F
        }
      },
      // >>>>> Left
      [[`&-placement-left ${n}-arrow`, `&-placement-leftTop ${n}-arrow`, `&-placement-leftBottom ${n}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: 0
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop ${n}-arrow`]: {
        top: o
      },
      [`&-placement-leftBottom ${n}-arrow`]: {
        bottom: o
      },
      // >>>>> Right
      [[`&-placement-right ${n}-arrow`, `&-placement-rightTop ${n}-arrow`, `&-placement-rightBottom ${n}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: 0
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop ${n}-arrow`]: {
        top: o
      },
      [`&-placement-rightBottom ${n}-arrow`]: {
        bottom: o
      },
      // =========================== Offset ============================
      // Offset the popover to account for the dropdown arrow
      // >>>>> Top
      [Oe(["&-placement-topLeft", "&-placement-top", "&-placement-topRight"].map((Q) => Q += ":not(&-arrow-hidden)"), W)]: {
        paddingBottom: N
      },
      // >>>>> Bottom
      [Oe(["&-placement-bottomLeft", "&-placement-bottom", "&-placement-bottomRight"].map((Q) => Q += ":not(&-arrow-hidden)"), W)]: {
        paddingTop: N
      },
      // >>>>> Left
      [Oe(["&-placement-leftTop", "&-placement-left", "&-placement-leftBottom"].map((Q) => Q += ":not(&-arrow-hidden)"), W)]: {
        paddingRight: {
          _skip_check_: !0,
          value: N
        }
      },
      // >>>>> Right
      [Oe(["&-placement-rightTop", "&-placement-right", "&-placement-rightBottom"].map((Q) => Q += ":not(&-arrow-hidden)"), W)]: {
        paddingLeft: {
          _skip_check_: !0,
          value: N
        }
      }
    }
  };
}
const ru = (l) => {
  const {
    componentCls: t,
    // ant-tooltip
    tooltipMaxWidth: n,
    tooltipColor: e,
    tooltipBg: d,
    tooltipBorderRadius: a,
    zIndexPopup: U,
    controlHeight: V,
    boxShadowSecondary: h,
    paddingSM: W,
    paddingXS: Z,
    tooltipRadiusOuter: s
  } = l;
  return [
    {
      [t]: j(j(j(j({}, sn(l)), {
        position: "absolute",
        zIndex: U,
        display: "block",
        "&": [{
          width: "max-content"
        }, {
          width: "intrinsic"
        }],
        maxWidth: n,
        visibility: "visible",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": d,
        // Wrapper for the tooltip content
        [`${t}-inner`]: {
          minWidth: V,
          minHeight: V,
          padding: `${W / 2}px ${Z}px`,
          color: e,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: d,
          borderRadius: a,
          boxShadow: h
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${t}-inner`]: {
            borderRadius: Math.min(a, gZ)
          }
        },
        [`${t}-content`]: {
          position: "relative"
        }
      }), LV(l, (o, F) => {
        let {
          darkColor: N
        } = F;
        return {
          [`&${t}-${o}`]: {
            [`${t}-inner`]: {
              backgroundColor: N
            },
            [`${t}-arrow`]: {
              "--antd-arrow-background-color": N
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    uu(tt(l, {
      borderRadiusOuter: s
    }), {
      colorBg: "var(--antd-arrow-background-color)",
      showArrowCls: "",
      contentRadius: a,
      limitVerticalRadius: !0
    }),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none"
      }
    }
  ];
}, Mu = (l, t) => $t("Tooltip", (e) => {
  if (t?.value === !1)
    return [];
  const {
    borderRadius: d,
    colorTextLightSolid: a,
    colorBgDefault: U,
    borderRadiusOuter: V
  } = e, h = tt(e, {
    // default variables
    tooltipMaxWidth: 250,
    tooltipColor: a,
    tooltipBorderRadius: d,
    tooltipBg: U,
    tooltipRadiusOuter: V > 4 ? 4 : V
  });
  return [ru(h), wZ(e, "zoom-big-fast")];
}, (e) => {
  let {
    zIndexPopupBase: d,
    colorBgSpotlight: a
  } = e;
  return {
    zIndexPopup: d + 70,
    colorBgDefault: a
  };
})(l), pu = (l, t) => {
  const n = {}, e = j({}, l);
  return t.forEach((d) => {
    l && d in l && (n[d] = l[d], delete e[d]);
  }), {
    picked: n,
    omitted: e
  };
}, Su = () => j(j({}, Vu()), {
  title: ol.any
}), Tu = pl({
  compatConfig: {
    MODE: 3
  },
  name: "ATooltip",
  inheritAttrs: !1,
  props: yn(Su(), {
    trigger: "hover",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: !1,
    autoAdjustOverflow: !0
  }),
  slots: Object,
  // emits: ['update:visible', 'visibleChange'],
  setup(l, t) {
    let {
      slots: n,
      emit: e,
      attrs: d,
      expose: a
    } = t;
    process.env.NODE_ENV !== "production" && [["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((L) => {
      let [z, f] = L;
      Je(l[z] === void 0, "Tooltip", `\`${z}\` is deprecated, please use \`${f}\` instead.`);
    });
    const {
      prefixCls: U,
      getPopupContainer: V,
      direction: h,
      rootPrefixCls: W
    } = ht("tooltip", l), Z = Zl(() => {
      var L;
      return (L = l.open) !== null && L !== void 0 ? L : l.visible;
    }), s = Ml($a([l.open, l.visible])), o = Ml();
    let F;
    Bl(Z, (L) => {
      Ol.cancel(F), F = Ol(() => {
        s.value = !!L;
      });
    });
    const N = () => {
      var L;
      const z = (L = l.title) !== null && L !== void 0 ? L : n.title;
      return !z && z !== 0;
    }, Q = (L) => {
      const z = N();
      Z.value === void 0 && (s.value = z ? !1 : L), z || (e("update:visible", L), e("visibleChange", L), e("update:open", L), e("openChange", L));
    };
    a({
      getPopupDomNode: () => o.value.getPopupDomNode(),
      open: s,
      forcePopupAlign: () => {
        var L;
        return (L = o.value) === null || L === void 0 ? void 0 : L.forcePopupAlign();
      }
    });
    const i = Zl(() => {
      var L;
      const {
        builtinPlacements: z,
        autoAdjustOverflow: f,
        arrow: K,
        arrowPointAtCenter: P
      } = l;
      let w = P;
      return typeof K == "object" && (w = (L = K.pointAtCenter) !== null && L !== void 0 ? L : P), z || hu({
        arrowPointAtCenter: w,
        autoAdjustOverflow: f
      });
    }), c = (L) => L || L === "", R = (L) => {
      const z = L.type;
      if (typeof z == "object" && L.props && ((z.__ANT_BUTTON === !0 || z === "button") && c(L.props.disabled) || z.__ANT_SWITCH === !0 && (c(L.props.disabled) || c(L.props.loading)) || z.__ANT_RADIO === !0 && c(L.props.disabled))) {
        const {
          picked: f,
          omitted: K
        } = pu(Jo(L), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), P = j(j({
          display: "inline-block"
        }, f), {
          cursor: "not-allowed",
          lineHeight: 1,
          width: L.props && L.props.block ? "100%" : void 0
        }), w = j(j({}, K), {
          pointerEvents: "none"
        }), O = bt(L, {
          style: w
        }, !0);
        return H("span", {
          style: P,
          class: `${U.value}-disabled-compatible-wrapper`
        }, [O]);
      }
      return L;
    }, m = () => {
      var L, z;
      return (L = l.title) !== null && L !== void 0 ? L : (z = n.title) === null || z === void 0 ? void 0 : z.call(n);
    }, M = (L, z) => {
      const f = i.value, K = Object.keys(f).find((P) => {
        var w, O;
        return f[P].points[0] === ((w = z.points) === null || w === void 0 ? void 0 : w[0]) && f[P].points[1] === ((O = z.points) === null || O === void 0 ? void 0 : O[1]);
      });
      if (K) {
        const P = L.getBoundingClientRect(), w = {
          top: "50%",
          left: "50%"
        };
        K.indexOf("top") >= 0 || K.indexOf("Bottom") >= 0 ? w.top = `${P.height - z.offset[1]}px` : (K.indexOf("Top") >= 0 || K.indexOf("bottom") >= 0) && (w.top = `${-z.offset[1]}px`), K.indexOf("left") >= 0 || K.indexOf("Right") >= 0 ? w.left = `${P.width - z.offset[0]}px` : (K.indexOf("right") >= 0 || K.indexOf("Left") >= 0) && (w.left = `${-z.offset[0]}px`), L.style.transformOrigin = `${w.left} ${w.top}`;
      }
    }, S = Zl(() => bu(U.value, l.color)), p = Zl(() => d["data-popover-inject"]), [Y, k] = Mu(U, Zl(() => !p.value));
    return () => {
      var L, z;
      const {
        openClassName: f,
        overlayClassName: K,
        overlayStyle: P,
        overlayInnerStyle: w
      } = l;
      let O = (z = Bn((L = n.default) === null || L === void 0 ? void 0 : L.call(n))) !== null && z !== void 0 ? z : null;
      O = O.length === 1 ? O[0] : O;
      let el = s.value;
      if (Z.value === void 0 && N() && (el = !1), !O)
        return null;
      const ll = R(Pt(O) && !Xo(O) ? O : H("span", null, [O])), q = Xl({
        [f || `${U.value}-open`]: !0,
        [ll.props && ll.props.class]: ll.props && ll.props.class
      }), _ = Xl(K, {
        [`${U.value}-rtl`]: h.value === "rtl"
      }, S.value.className, k.value), il = j(j({}, S.value.overlayStyle), w), dl = S.value.arrowStyle, tl = j(j(j({}, d), l), {
        prefixCls: U.value,
        arrow: !!l.arrow,
        getPopupContainer: V?.value,
        builtinPlacements: i.value,
        visible: el,
        ref: o,
        overlayClassName: _,
        overlayStyle: j(j({}, dl), P),
        overlayInnerStyle: il,
        onVisibleChange: Q,
        onPopupAlign: M,
        transitionName: An(W.value, "zoom-big-fast", l.transitionName)
      });
      return Y(H(ou, tl, {
        default: () => [s.value ? bt(ll, {
          class: q
        }) : ll],
        arrowContent: () => H("span", {
          class: `${U.value}-arrow-content`
        }, null),
        overlay: m
      }));
    };
  }
}), Gu = Td(Tu), Ju = (l) => {
  const {
    componentCls: t,
    colorPrimary: n
  } = l;
  return {
    [t]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${n})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${l.motionEaseOutCirc}`, `opacity 2s ${l.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        }
      }
    }
  };
}, Xu = $t("Wave", (l) => [Ju(l)]);
function Yu(l) {
  const t = (l || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return t && t[1] && t[2] && t[3] ? !(t[1] === t[2] && t[2] === t[3]) : !0;
}
function Wa(l) {
  return l && l !== "#fff" && l !== "#ffffff" && l !== "rgb(255, 255, 255)" && l !== "rgba(255, 255, 255, 1)" && Yu(l) && !/rgba\((?:\d*, ){3}0\)/.test(l) && // any transparent rgba color
  l !== "transparent";
}
function yu(l) {
  const {
    borderTopColor: t,
    borderColor: n,
    backgroundColor: e
  } = getComputedStyle(l);
  return Wa(t) ? t : Wa(n) ? n : Wa(e) ? e : null;
}
function ha(l) {
  return Number.isNaN(l) ? 0 : l;
}
const Bu = pl({
  props: {
    target: dn(),
    className: String
  },
  setup(l) {
    const t = bl(null), [n, e] = ft(null), [d, a] = ft([]), [U, V] = ft(0), [h, W] = ft(0), [Z, s] = ft(0), [o, F] = ft(0), [N, Q] = ft(!1);
    function u() {
      const {
        target: p
      } = l, Y = getComputedStyle(p);
      e(yu(p));
      const k = Y.position === "static", {
        borderLeftWidth: L,
        borderTopWidth: z
      } = Y;
      V(k ? p.offsetLeft : ha(-parseFloat(L))), W(k ? p.offsetTop : ha(-parseFloat(z))), s(p.offsetWidth), F(p.offsetHeight);
      const {
        borderTopLeftRadius: f,
        borderTopRightRadius: K,
        borderBottomLeftRadius: P,
        borderBottomRightRadius: w
      } = Y;
      a([f, K, w, P].map((O) => ha(parseFloat(O))));
    }
    let i, c, R;
    const m = () => {
      clearTimeout(R), Ol.cancel(c), i?.disconnect();
    }, M = () => {
      var p;
      const Y = (p = t.value) === null || p === void 0 ? void 0 : p.parentElement;
      Y && (XU(null, Y), Y.parentElement && Y.parentElement.removeChild(Y));
    };
    ql(() => {
      m(), R = setTimeout(() => {
        M();
      }, 5e3);
      const {
        target: p
      } = l;
      p && (c = Ol(() => {
        u(), Q(!0);
      }), typeof ResizeObserver < "u" && (i = new ResizeObserver(u), i.observe(p)));
    }), Wt(() => {
      m();
    });
    const S = (p) => {
      p.propertyName === "opacity" && M();
    };
    return () => {
      if (!N.value)
        return null;
      const p = {
        left: `${U.value}px`,
        top: `${h.value}px`,
        width: `${Z.value}px`,
        height: `${o.value}px`,
        borderRadius: d.value.map((Y) => `${Y}px`).join(" ")
      };
      return n && (p["--wave-color"] = n.value), H(Yn, {
        appear: !0,
        name: "wave-motion",
        appearFromClass: "wave-motion-appear",
        appearActiveClass: "wave-motion-appear",
        appearToClass: "wave-motion-appear wave-motion-appear-active"
      }, {
        default: () => [H("div", {
          ref: t,
          class: l.className,
          style: p,
          onTransitionend: S
        }, null)]
      });
    };
  }
});
function zu(l, t) {
  const n = document.createElement("div");
  n.style.position = "absolute", n.style.left = "0px", n.style.top = "0px", l?.insertBefore(n, l?.firstChild), XU(H(Bu, {
    target: l,
    className: t
  }, null), n);
}
function Lu(l, t, n) {
  function e() {
    var d;
    const a = en(l);
    !((d = n?.value) === null || d === void 0) && d.disabled || !a || zu(a, t.value);
  }
  return e;
}
const ku = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Wave",
  props: {
    disabled: Boolean
  },
  setup(l, t) {
    let {
      slots: n
    } = t;
    const e = Jn(), {
      prefixCls: d,
      wave: a
    } = ht("wave", l), [, U] = Xu(d), V = Lu(e, Zl(() => Xl(d.value, U.value)), a);
    let h;
    const W = () => {
      en(e).removeEventListener("click", h, !0);
    };
    return ql(() => {
      Bl(() => l.disabled, () => {
        W(), dt(() => {
          const Z = en(e);
          Z?.removeEventListener("click", h, !0), !(!Z || Z.nodeType !== 1 || l.disabled) && (h = (s) => {
            s.target.tagName === "INPUT" || !v0(s.target) || // No need wave
            !Z.getAttribute || Z.getAttribute("disabled") || Z.disabled || Z.className.includes("disabled") || Z.className.includes("-leave") || V();
          }, Z.addEventListener("click", h, !0));
        });
      }, {
        immediate: !0,
        flush: "post"
      });
    }), Wt(() => {
      W();
    }), () => {
      var Z;
      return (Z = n.default) === null || Z === void 0 ? void 0 : Z.call(n)[0];
    };
  }
}), Iu = () => ({
  prefixCls: String,
  type: String,
  htmlType: {
    type: String,
    default: "button"
  },
  shape: {
    type: String
  },
  size: {
    type: String
  },
  loading: {
    type: [Boolean, Object],
    default: () => !1
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  ghost: {
    type: Boolean,
    default: void 0
  },
  block: {
    type: Boolean,
    default: void 0
  },
  danger: {
    type: Boolean,
    default: void 0
  },
  icon: ol.any,
  href: String,
  target: String,
  title: String,
  onClick: nd(),
  onMousedown: nd()
}), Pc = (l) => {
  l && (l.style.width = "0px", l.style.opacity = "0", l.style.transform = "scale(0)");
}, Ac = (l) => {
  dt(() => {
    l && (l.style.width = `${l.scrollWidth}px`, l.style.opacity = "1", l.style.transform = "scale(1)");
  });
}, $c = (l) => {
  l && l.style && (l.style.width = null, l.style.opacity = null, l.style.transform = null);
}, Du = pl({
  compatConfig: {
    MODE: 3
  },
  name: "LoadingIcon",
  props: {
    prefixCls: String,
    loading: [Boolean, Object],
    existIcon: Boolean
  },
  setup(l) {
    return () => {
      const {
        existIcon: t,
        prefixCls: n,
        loading: e
      } = l;
      if (t)
        return H("span", {
          class: `${n}-loading-icon`
        }, [H(pe, null, null)]);
      const d = !!e;
      return H(Yn, {
        name: `${n}-loading-icon-motion`,
        onBeforeEnter: Pc,
        onEnter: Ac,
        onAfterEnter: $c,
        onBeforeLeave: Ac,
        onLeave: (a) => {
          setTimeout(() => {
            Pc(a);
          });
        },
        onAfterLeave: $c
      }, {
        default: () => [d ? H("span", {
          class: `${n}-loading-icon`
        }, [H(pe, null, null)]) : null]
      });
    };
  }
}), qc = (l, t) => ({
  // Border
  [`> span, > ${l}`]: {
    "&:not(:last-child)": {
      [`&, & > ${l}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: t
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${l}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: t
        }
      }
    }
  }
}), Cu = (l) => {
  const {
    componentCls: t,
    fontSize: n,
    lineWidth: e,
    colorPrimaryHover: d,
    colorErrorHover: a
  } = l;
  return {
    [`${t}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${t}`]: {
          "&:not(:last-child)": {
            [`&, & > ${t}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: -e,
            [`&, & > ${t}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [t]: {
          position: "relative",
          zIndex: 1,
          "&:hover,\n          &:focus,\n          &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${t}-icon-only`]: {
          fontSize: n
        }
      },
      // Border Color
      qc(`${t}-primary`, d),
      qc(`${t}-danger`, a)
    ]
  };
};
function wu(l, t) {
  return {
    // border collapse
    [`&-item:not(${t}-last-item)`]: {
      marginBottom: -l.lineWidth
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function Eu(l, t) {
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${t}-first-item:not(${t}-last-item)`]: {
      [`&, &${l}-sm, &${l}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${t}-last-item:not(${t}-first-item)`]: {
      [`&, &${l}-sm, &${l}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function xu(l) {
  const t = `${l.componentCls}-compact-vertical`;
  return {
    [t]: j(j({}, wu(l, t)), Eu(l.componentCls, t))
  };
}
const gu = (l) => {
  const {
    componentCls: t,
    iconCls: n
  } = l;
  return {
    [t]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: 400,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      backgroundColor: "transparent",
      border: `${l.lineWidth}px ${l.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${l.motionDurationMid} ${l.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      lineHeight: l.lineHeight,
      color: l.colorText,
      "> span": {
        display: "inline-block"
      },
      // Leave a space between icon and text.
      [`> ${n} + span, > span + ${n}`]: {
        marginInlineStart: l.marginXS
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": j({}, h0(l)),
      // make `btn-icon-only` not too narrow
      [`&-icon-only${t}-compact-item`]: {
        flex: "none"
      },
      // Special styles for Primary Button
      [`&-compact-item${t}-primary`]: {
        [`&:not([disabled]) + ${t}-compact-item${t}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: -l.lineWidth,
            insetInlineStart: -l.lineWidth,
            display: "inline-block",
            width: l.lineWidth,
            height: `calc(100% + ${l.lineWidth * 2}px)`,
            backgroundColor: l.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${t}-primary`]: {
          [`&:not([disabled]) + ${t}-compact-vertical-item${t}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -l.lineWidth,
              insetInlineStart: -l.lineWidth,
              display: "inline-block",
              width: `calc(100% + ${l.lineWidth * 2}px)`,
              height: l.lineWidth,
              backgroundColor: l.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, At = (l, t) => ({
  "&:not(:disabled)": {
    "&:hover": l,
    "&:active": t
  }
}), ju = (l) => ({
  minWidth: l.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), Ou = (l) => ({
  borderRadius: l.controlHeight,
  paddingInlineStart: l.controlHeight / 2,
  paddingInlineEnd: l.controlHeight / 2
}), qa = (l) => ({
  cursor: "not-allowed",
  borderColor: l.colorBorder,
  color: l.colorTextDisabled,
  backgroundColor: l.colorBgContainerDisabled,
  boxShadow: "none"
}), hd = (l, t, n, e, d, a, U) => ({
  [`&${l}-background-ghost`]: j(j({
    color: t || void 0,
    backgroundColor: "transparent",
    borderColor: n || void 0,
    boxShadow: "none"
  }, At(j({
    backgroundColor: "transparent"
  }, a), j({
    backgroundColor: "transparent"
  }, U))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: e || void 0,
      borderColor: d || void 0
    }
  })
}), Ii = (l) => ({
  "&:disabled": j({}, qa(l))
}), jZ = (l) => j({}, Ii(l)), Rd = (l) => ({
  "&:disabled": {
    cursor: "not-allowed",
    color: l.colorTextDisabled
  }
}), OZ = (l) => j(j(j(j(j({}, jZ(l)), {
  backgroundColor: l.colorBgContainer,
  borderColor: l.colorBorder,
  boxShadow: `0 ${l.controlOutlineWidth}px 0 ${l.controlTmpOutline}`
}), At({
  color: l.colorPrimaryHover,
  borderColor: l.colorPrimaryHover
}, {
  color: l.colorPrimaryActive,
  borderColor: l.colorPrimaryActive
})), hd(l.componentCls, l.colorBgContainer, l.colorBgContainer, l.colorTextDisabled, l.colorBorder)), {
  [`&${l.componentCls}-dangerous`]: j(j(j({
    color: l.colorError,
    borderColor: l.colorError
  }, At({
    color: l.colorErrorHover,
    borderColor: l.colorErrorBorderHover
  }, {
    color: l.colorErrorActive,
    borderColor: l.colorErrorActive
  })), hd(l.componentCls, l.colorError, l.colorError, l.colorTextDisabled, l.colorBorder)), Ii(l))
}), vu = (l) => j(j(j(j(j({}, jZ(l)), {
  color: l.colorTextLightSolid,
  backgroundColor: l.colorPrimary,
  boxShadow: `0 ${l.controlOutlineWidth}px 0 ${l.controlOutline}`
}), At({
  color: l.colorTextLightSolid,
  backgroundColor: l.colorPrimaryHover
}, {
  color: l.colorTextLightSolid,
  backgroundColor: l.colorPrimaryActive
})), hd(l.componentCls, l.colorPrimary, l.colorPrimary, l.colorTextDisabled, l.colorBorder, {
  color: l.colorPrimaryHover,
  borderColor: l.colorPrimaryHover
}, {
  color: l.colorPrimaryActive,
  borderColor: l.colorPrimaryActive
})), {
  [`&${l.componentCls}-dangerous`]: j(j(j({
    backgroundColor: l.colorError,
    boxShadow: `0 ${l.controlOutlineWidth}px 0 ${l.colorErrorOutline}`
  }, At({
    backgroundColor: l.colorErrorHover
  }, {
    backgroundColor: l.colorErrorActive
  })), hd(l.componentCls, l.colorError, l.colorError, l.colorTextDisabled, l.colorBorder, {
    color: l.colorErrorHover,
    borderColor: l.colorErrorHover
  }, {
    color: l.colorErrorActive,
    borderColor: l.colorErrorActive
  })), Ii(l))
}), fu = (l) => j(j({}, OZ(l)), {
  borderStyle: "dashed"
}), Ku = (l) => j(j(j({
  color: l.colorLink
}, At({
  color: l.colorLinkHover
}, {
  color: l.colorLinkActive
})), Rd(l)), {
  [`&${l.componentCls}-dangerous`]: j(j({
    color: l.colorError
  }, At({
    color: l.colorErrorHover
  }, {
    color: l.colorErrorActive
  })), Rd(l))
}), Hu = (l) => j(j(j({}, At({
  color: l.colorText,
  backgroundColor: l.colorBgTextHover
}, {
  color: l.colorText,
  backgroundColor: l.colorBgTextActive
})), Rd(l)), {
  [`&${l.componentCls}-dangerous`]: j(j({
    color: l.colorError
  }, Rd(l)), At({
    color: l.colorErrorHover,
    backgroundColor: l.colorErrorBg
  }, {
    color: l.colorErrorHover,
    backgroundColor: l.colorErrorBg
  }))
}), Pu = (l) => j(j({}, qa(l)), {
  [`&${l.componentCls}:hover`]: j({}, qa(l))
}), Au = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [`${t}-default`]: OZ(l),
    [`${t}-primary`]: vu(l),
    [`${t}-dashed`]: fu(l),
    [`${t}-link`]: Ku(l),
    [`${t}-text`]: Hu(l),
    [`${t}-disabled`]: Pu(l)
  };
}, Di = function(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls: n,
    iconCls: e,
    controlHeight: d,
    fontSize: a,
    lineHeight: U,
    lineWidth: V,
    borderRadius: h,
    buttonPaddingHorizontal: W
  } = l, Z = Math.max(0, (d - a * U) / 2 - V), s = W - V, o = `${n}-icon-only`;
  return [
    // Size
    {
      [`${n}${t}`]: {
        fontSize: a,
        height: d,
        padding: `${Z}px ${s}px`,
        borderRadius: h,
        [`&${o}`]: {
          width: d,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${n}-round`]: {
            width: "auto"
          },
          "> span": {
            transform: "scale(1.143)"
            // 14px -> 16px
          }
        },
        // Loading
        [`&${n}-loading`]: {
          opacity: l.opacityLoading,
          cursor: "default"
        },
        [`${n}-loading-icon`]: {
          transition: `width ${l.motionDurationSlow} ${l.motionEaseInOut}, opacity ${l.motionDurationSlow} ${l.motionEaseInOut}`
        },
        [`&:not(${o}) ${n}-loading-icon > ${e}`]: {
          marginInlineEnd: l.marginXS
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${n}${n}-circle${t}`]: ju(l)
    },
    {
      [`${n}${n}-round${t}`]: Ou(l)
    }
  ];
}, $u = (l) => Di(l), qu = (l) => {
  const t = tt(l, {
    controlHeight: l.controlHeightSM,
    padding: l.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: l.borderRadiusSM
  });
  return Di(t, `${l.componentCls}-sm`);
}, _u = (l) => {
  const t = tt(l, {
    controlHeight: l.controlHeightLG,
    fontSize: l.fontSizeLG,
    borderRadius: l.borderRadiusLG
  });
  return Di(t, `${l.componentCls}-lg`);
}, lr = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [t]: {
      [`&${t}-block`]: {
        width: "100%"
      }
    }
  };
}, tr = $t("Button", (l) => {
  const {
    controlTmpOutline: t,
    paddingContentHorizontal: n
  } = l, e = tt(l, {
    colorOutlineDefault: t,
    buttonPaddingHorizontal: n
  });
  return [
    // Shared
    gu(e),
    // Size
    qu(e),
    $u(e),
    _u(e),
    // Block
    lr(e),
    // Group (type, ghost, danger, disabled, loading)
    Au(e),
    // Button Group
    Cu(e),
    // Space Compact
    Li(l, {
      focus: !1
    }),
    xu(l)
  ];
}), nr = () => ({
  prefixCls: String,
  size: {
    type: String
  }
}), vZ = yi(), _a = pl({
  compatConfig: {
    MODE: 3
  },
  name: "AButtonGroup",
  props: nr(),
  setup(l, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: e,
      direction: d
    } = ht("btn-group", l), [, , a] = Xe();
    vZ.useProvide(Nt({
      size: Zl(() => l.size)
    }));
    const U = Zl(() => {
      const {
        size: V
      } = l;
      let h = "";
      switch (V) {
        case "large":
          h = "lg";
          break;
        case "small":
          h = "sm";
          break;
        case "middle":
        case void 0:
          break;
        default:
          Zi(!V, "Button.Group", "Invalid prop `size`.");
      }
      return {
        [`${e.value}`]: !0,
        [`${e.value}-${h}`]: h,
        [`${e.value}-rtl`]: d.value === "rtl",
        [a.value]: !0
      };
    });
    return () => {
      var V;
      return H("div", {
        class: U.value
      }, [Tt((V = n.default) === null || V === void 0 ? void 0 : V.call(n))]);
    };
  }
}), _c = /^[\u4e00-\u9fa5]{2}$/, lU = _c.test.bind(_c);
function ve(l) {
  return l === "text" || l === "link";
}
const Ze = pl({
  compatConfig: {
    MODE: 3
  },
  name: "AButton",
  inheritAttrs: !1,
  __ANT_BUTTON: !0,
  props: yn(Iu(), {
    type: "default"
  }),
  slots: Object,
  // emits: ['click', 'mousedown'],
  setup(l, t) {
    let {
      slots: n,
      attrs: e,
      emit: d,
      expose: a
    } = t;
    const {
      prefixCls: U,
      autoInsertSpaceInButton: V,
      direction: h,
      size: W
    } = ht("btn", l), [Z, s] = tr(U), o = vZ.useInject(), F = Ge(), N = Zl(() => {
      var w;
      return (w = l.disabled) !== null && w !== void 0 ? w : F.value;
    }), Q = bl(null), u = bl(void 0);
    let i = !1;
    const c = bl(!1), R = bl(!1), m = Zl(() => V.value !== !1), {
      compactSize: M,
      compactItemClassnames: S
    } = zi(U, h), p = Zl(() => typeof l.loading == "object" && l.loading.delay ? l.loading.delay || !0 : !!l.loading);
    Bl(p, (w) => {
      clearTimeout(u.value), typeof p.value == "number" ? u.value = setTimeout(() => {
        c.value = w;
      }, p.value) : c.value = w;
    }, {
      immediate: !0
    });
    const Y = Zl(() => {
      const {
        type: w,
        shape: O = "default",
        ghost: el,
        block: ll,
        danger: q
      } = l, _ = U.value, il = {
        large: "lg",
        small: "sm",
        middle: void 0
      }, dl = M.value || o?.size || W.value, tl = dl && il[dl] || "";
      return [S.value, {
        [s.value]: !0,
        [`${_}`]: !0,
        [`${_}-${O}`]: O !== "default" && O,
        [`${_}-${w}`]: w,
        [`${_}-${tl}`]: tl,
        [`${_}-loading`]: c.value,
        [`${_}-background-ghost`]: el && !ve(w),
        [`${_}-two-chinese-chars`]: R.value && m.value,
        [`${_}-block`]: ll,
        [`${_}-dangerous`]: !!q,
        [`${_}-rtl`]: h.value === "rtl"
      }];
    }), k = () => {
      const w = Q.value;
      if (!w || V.value === !1)
        return;
      const O = w.textContent;
      i && lU(O) ? R.value || (R.value = !0) : R.value && (R.value = !1);
    }, L = (w) => {
      if (c.value || N.value) {
        w.preventDefault();
        return;
      }
      d("click", w);
    }, z = (w) => {
      d("mousedown", w);
    }, f = (w, O) => {
      const el = O ? " " : "";
      if (w.type === JU) {
        let ll = w.children.trim();
        return lU(ll) && (ll = ll.split("").join(el)), H("span", null, [ll]);
      }
      return w;
    };
    return it(() => {
      Zi(!(l.ghost && ve(l.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
    }), ql(k), qn(k), Wt(() => {
      u.value && clearTimeout(u.value);
    }), a({
      focus: () => {
        var w;
        (w = Q.value) === null || w === void 0 || w.focus();
      },
      blur: () => {
        var w;
        (w = Q.value) === null || w === void 0 || w.blur();
      }
    }), () => {
      var w, O;
      const {
        icon: el = (w = n.icon) === null || w === void 0 ? void 0 : w.call(n)
      } = l, ll = Tt((O = n.default) === null || O === void 0 ? void 0 : O.call(n));
      i = ll.length === 1 && !el && !ve(l.type);
      const {
        type: q,
        htmlType: _,
        href: il,
        title: dl,
        target: tl
      } = l, al = c.value ? "loading" : el, Ul = j(j({}, e), {
        title: dl,
        disabled: N.value,
        class: [Y.value, e.class, {
          [`${U.value}-icon-only`]: ll.length === 0 && !!al
        }],
        onClick: L,
        onMousedown: z
      });
      N.value || delete Ul.disabled;
      const cl = el && !c.value ? el : H(Du, {
        existIcon: !!el,
        prefixCls: U.value,
        loading: !!c.value
      }, null), B = ll.map((b) => f(b, i && m.value));
      if (il !== void 0)
        return Z(H("a", Ql(Ql({}, Ul), {}, {
          href: il,
          target: tl,
          ref: Q
        }), [cl, B]));
      let X = H("button", Ql(Ql({}, Ul), {}, {
        ref: Q,
        type: _
      }), [cl, B]);
      if (!ve(q)) {
        const b = /* @__PURE__ */ function() {
          return X;
        }();
        X = H(ku, {
          ref: "wave",
          disabled: !!c.value
        }, {
          default: () => [b]
        });
      }
      return Z(X);
    };
  }
});
Ze.Group = _a;
Ze.install = function(l) {
  return l.component(Ze.name, Ze), l.component(_a.name, _a), l;
};
var er = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" };
function tU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      dr(l, d, n[d]);
    });
  }
  return l;
}
function dr(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Se = function(t, n) {
  var e = tU({}, t, n.attrs);
  return H($l, tU({}, e, {
    icon: er
  }), null);
};
Se.displayName = "RightOutlined";
Se.inheritAttrs = !1;
const ar = (l) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: l,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), Ci = (l) => ({
  borderColor: l.inputBorderHoverColor,
  borderInlineEndWidth: l.lineWidth
}), li = (l) => ({
  borderColor: l.inputBorderHoverColor,
  boxShadow: `0 0 0 ${l.controlOutlineWidth}px ${l.controlOutline}`,
  borderInlineEndWidth: l.lineWidth,
  outline: 0
}), ir = (l) => ({
  color: l.colorTextDisabled,
  backgroundColor: l.colorBgContainerDisabled,
  borderColor: l.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "&:hover": j({}, Ci(tt(l, {
    inputBorderHoverColor: l.colorBorder
  })))
}), fZ = (l) => {
  const {
    inputPaddingVerticalLG: t,
    fontSizeLG: n,
    lineHeightLG: e,
    borderRadiusLG: d,
    inputPaddingHorizontalLG: a
  } = l;
  return {
    padding: `${t}px ${a}px`,
    fontSize: n,
    lineHeight: e,
    borderRadius: d
  };
}, wi = (l) => ({
  padding: `${l.inputPaddingVerticalSM}px ${l.controlPaddingHorizontalSM - 1}px`,
  borderRadius: l.borderRadiusSM
}), KZ = (l, t) => {
  const {
    componentCls: n,
    colorError: e,
    colorWarning: d,
    colorErrorOutline: a,
    colorWarningOutline: U,
    colorErrorBorderHover: V,
    colorWarningBorderHover: h
  } = l;
  return {
    [`&-status-error:not(${t}-disabled):not(${t}-borderless)${t}`]: {
      borderColor: e,
      "&:hover": {
        borderColor: V
      },
      "&:focus, &-focused": j({}, li(tt(l, {
        inputBorderActiveColor: e,
        inputBorderHoverColor: e,
        controlOutline: a
      }))),
      [`${n}-prefix`]: {
        color: e
      }
    },
    [`&-status-warning:not(${t}-disabled):not(${t}-borderless)${t}`]: {
      borderColor: d,
      "&:hover": {
        borderColor: h
      },
      "&:focus, &-focused": j({}, li(tt(l, {
        inputBorderActiveColor: d,
        inputBorderHoverColor: d,
        controlOutline: U
      }))),
      [`${n}-prefix`]: {
        color: d
      }
    }
  };
}, Ei = (l) => j(j({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${l.inputPaddingVertical}px ${l.inputPaddingHorizontal}px`,
  color: l.colorText,
  fontSize: l.fontSize,
  lineHeight: l.lineHeight,
  backgroundColor: l.colorBgContainer,
  backgroundImage: "none",
  borderWidth: l.lineWidth,
  borderStyle: l.lineType,
  borderColor: l.colorBorder,
  borderRadius: l.borderRadius,
  transition: `all ${l.motionDurationMid}`
}, ar(l.colorTextPlaceholder)), {
  "&:hover": j({}, Ci(l)),
  "&:focus, &-focused": j({}, li(l)),
  "&-disabled, &[disabled]": j({}, ir(l)),
  "&-borderless": {
    "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
      backgroundColor: "transparent",
      border: "none",
      boxShadow: "none"
    }
  },
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    height: "auto",
    minHeight: l.controlHeight,
    lineHeight: l.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${l.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": j({}, fZ(l)),
  "&-sm": j({}, wi(l)),
  // RTL
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
}), sr = (l) => {
  const {
    componentCls: t,
    antCls: n
  } = l;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: l.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${t}, &-lg > ${t}-group-addon`]: j({}, fZ(l)),
    [`&-sm ${t}, &-sm > ${t}-group-addon`]: j({}, wi(l)),
    [`> ${t}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${t}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${l.inputPaddingHorizontal}px`,
        color: l.colorText,
        fontWeight: "normal",
        fontSize: l.fontSize,
        textAlign: "center",
        backgroundColor: l.colorFillAlter,
        border: `${l.lineWidth}px ${l.lineType} ${l.colorBorder}`,
        borderRadius: l.borderRadius,
        transition: `all ${l.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${n}-select`]: {
          margin: `-${l.inputPaddingVertical + 1}px -${l.inputPaddingHorizontal}px`,
          [`&${n}-select-single:not(${n}-select-customize-input)`]: {
            [`${n}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${l.lineWidth}px ${l.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${n}-select-selector`]: {
              color: l.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${n}-cascader-picker`]: {
          margin: `-9px -${l.inputPaddingHorizontal}px`,
          backgroundColor: "transparent",
          [`${n}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    [`${t}`]: {
      float: "inline-start",
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${t}:first-child, ${t}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}-affix-wrapper`]: {
      [`&:not(:first-child) ${t}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${t}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}:last-child, ${t}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${t}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${t}-search &`]: {
          borderStartStartRadius: l.borderRadius,
          borderEndStartRadius: l.borderRadius
        }
      },
      [`&:not(:first-child), ${t}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${t}-group-compact`]: j(j({
      display: "block"
    }, kV()), {
      [`${t}-group-addon, ${t}-group-wrap, > ${t}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: l.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        borderRadius: 0
      },
      [`& > ${t}-affix-wrapper`]: {
        display: "inline-flex"
      },
      [`& > ${n}-picker-range`]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: -l.lineWidth,
        borderInlineEndWidth: l.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${t}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${n}-select > ${n}-select-selector,
      & > ${n}-select-auto-complete ${t},
      & > ${n}-cascader-picker ${t},
      & > ${t}-group-wrapper ${t}`]: {
        borderInlineEndWidth: l.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${n}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${n}-select > ${n}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${n}-select:first-child > ${n}-select-selector,
      & > ${n}-select-auto-complete:first-child ${t},
      & > ${n}-cascader-picker:first-child ${t}`]: {
        borderStartStartRadius: l.borderRadius,
        borderEndStartRadius: l.borderRadius
      },
      [`& > *:last-child,
      & > ${n}-select:last-child > ${n}-select-selector,
      & > ${n}-cascader-picker:last-child ${t},
      & > ${n}-cascader-picker-focused:last-child ${t}`]: {
        borderInlineEndWidth: l.lineWidth,
        borderStartEndRadius: l.borderRadius,
        borderEndEndRadius: l.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${n}-select-auto-complete ${t}`]: {
        verticalAlign: "top"
      },
      [`${t}-group-wrapper + ${t}-group-wrapper`]: {
        marginInlineStart: -l.lineWidth,
        [`${t}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${t}-group-wrapper:not(:last-child)`]: {
        [`&${t}-search > ${t}-group`]: {
          [`& > ${t}-group-addon > ${t}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${t}`]: {
            borderStartStartRadius: l.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: l.borderRadius
          }
        }
      }
    }),
    [`&&-sm ${n}-btn`]: {
      fontSize: l.fontSizeSM,
      height: l.controlHeightSM,
      lineHeight: "normal"
    },
    [`&&-lg ${n}-btn`]: {
      fontSize: l.fontSizeLG,
      height: l.controlHeightLG,
      lineHeight: "normal"
    },
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&&-lg ${n}-select-single ${n}-select-selector`]: {
      height: `${l.controlHeightLG}px`,
      [`${n}-select-selection-item, ${n}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${l.controlHeightLG - 2}px`
      },
      [`${n}-select-selection-search-input`]: {
        height: `${l.controlHeightLG}px`
      }
    },
    [`&&-sm ${n}-select-single ${n}-select-selector`]: {
      height: `${l.controlHeightSM}px`,
      [`${n}-select-selection-item, ${n}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${l.controlHeightSM - 2}px`
      },
      [`${n}-select-selection-search-input`]: {
        height: `${l.controlHeightSM}px`
      }
    }
  };
}, cr = (l) => {
  const {
    componentCls: t,
    controlHeightSM: n,
    lineWidth: e
  } = l, a = (n - e * 2 - 16) / 2;
  return {
    [t]: j(j(j(j({}, sn(l)), Ei(l)), KZ(l, t)), {
      '&[type="color"]': {
        height: l.controlHeight,
        [`&${t}-lg`]: {
          height: l.controlHeightLG
        },
        [`&${t}-sm`]: {
          height: n,
          paddingTop: a,
          paddingBottom: a
        }
      }
    })
  };
}, Ur = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    // ========================= Input =========================
    [`${t}-clear-icon`]: {
      margin: 0,
      color: l.colorTextQuaternary,
      fontSize: l.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${l.motionDurationSlow}`,
      "&:hover": {
        color: l.colorTextTertiary
      },
      "&:active": {
        color: l.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${l.inputAffixPadding}px`
      }
    },
    // ======================= TextArea ========================
    "&-textarea-with-clear-btn": {
      padding: "0 !important",
      border: "0 !important",
      [`${t}-clear-icon`]: {
        position: "absolute",
        insetBlockStart: l.paddingXS,
        insetInlineEnd: l.paddingXS,
        zIndex: 1
      }
    }
  };
}, Zr = (l) => {
  const {
    componentCls: t,
    inputAffixPadding: n,
    colorTextDescription: e,
    motionDurationSlow: d,
    colorIcon: a,
    colorIconHover: U,
    iconCls: V
  } = l;
  return {
    [`${t}-affix-wrapper`]: j(j(j(j(j({}, Ei(l)), {
      display: "inline-flex",
      [`&:not(${t}-affix-wrapper-disabled):hover`]: j(j({}, Ci(l)), {
        zIndex: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${t}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> input${t}`]: {
        padding: 0,
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: l.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: e
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: l.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: n
        },
        "&-suffix": {
          marginInlineStart: n
        }
      }
    }), Ur(l)), {
      // password
      [`${V}${t}-password-icon`]: {
        color: a,
        cursor: "pointer",
        transition: `all ${d}`,
        "&:hover": {
          color: U
        }
      }
    }), KZ(l, `${t}-affix-wrapper`))
  };
}, Fr = (l) => {
  const {
    componentCls: t,
    colorError: n,
    colorSuccess: e,
    borderRadiusLG: d,
    borderRadiusSM: a
  } = l;
  return {
    [`${t}-group`]: j(j(j({}, sn(l)), sr(l)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${t}-group-addon`]: {
            borderRadius: d
          }
        },
        "&-sm": {
          [`${t}-group-addon`]: {
            borderRadius: a
          }
        },
        // Status
        "&-status-error": {
          [`${t}-group-addon`]: {
            color: n,
            borderColor: n
          }
        },
        "&-status-warning": {
          [`${t}-group-addon:last-child`]: {
            color: e,
            borderColor: e
          }
        }
      }
    })
  };
}, or = (l) => {
  const {
    componentCls: t,
    antCls: n
  } = l, e = `${t}-search`;
  return {
    [e]: {
      [`${t}`]: {
        "&:hover, &:focus": {
          borderColor: l.colorPrimaryHover,
          [`+ ${t}-group-addon ${e}-button:not(${n}-btn-primary)`]: {
            borderInlineStartColor: l.colorPrimaryHover
          }
        }
      },
      [`${t}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${t}-lg`]: {
        lineHeight: l.lineHeightLG - 2e-4
      },
      [`> ${t}-group`]: {
        [`> ${t}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${e}-button`]: {
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: l.borderRadius,
            borderEndEndRadius: l.borderRadius,
            borderEndStartRadius: 0
          },
          [`${e}-button:not(${n}-btn-primary)`]: {
            color: l.colorTextDescription,
            "&:hover": {
              color: l.colorPrimaryHover
            },
            "&:active": {
              color: l.colorPrimaryActive
            },
            [`&${n}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${e}-button`]: {
        height: l.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${e}-button`]: {
        height: l.controlHeightLG
      },
      [`&-small ${e}-button`]: {
        height: l.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${t}-compact-item`]: {
        [`&:not(${t}-compact-last-item)`]: {
          [`${t}-group-addon`]: {
            [`${t}-search-button`]: {
              marginInlineEnd: -l.lineWidth,
              borderRadius: 0
            }
          }
        },
        [`&:not(${t}-compact-first-item)`]: {
          [`${t},${t}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${t}-group-addon ${t}-search-button,
        > ${t},
        ${t}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${t}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
};
function HZ(l) {
  return tt(l, {
    inputAffixPadding: l.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((l.controlHeight - l.fontSize * l.lineHeight) / 2 * 10) / 10 - l.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((l.controlHeightLG - l.fontSizeLG * l.lineHeightLG) / 2 * 10) / 10 - l.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((l.controlHeightSM - l.fontSize * l.lineHeight) / 2 * 10) / 10 - l.lineWidth, 0),
    inputPaddingHorizontal: l.paddingSM - l.lineWidth,
    inputPaddingHorizontalSM: l.paddingXS - l.lineWidth,
    inputPaddingHorizontalLG: l.controlPaddingHorizontal - l.lineWidth,
    inputBorderHoverColor: l.colorPrimaryHover,
    inputBorderActiveColor: l.colorPrimaryHover
  });
}
const Vr = (l) => {
  const {
    componentCls: t,
    inputPaddingHorizontal: n,
    paddingLG: e
  } = l, d = `${t}-textarea`;
  return {
    [d]: {
      position: "relative",
      [`${d}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: n,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      "&-status-error,\n        &-status-warning,\n        &-status-success,\n        &-status-validating": {
        [`&${d}-has-feedback`]: {
          [`${t}`]: {
            paddingInlineEnd: e
          }
        }
      },
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${t}`]: {
          height: "100%"
        },
        "&::after": {
          color: l.colorTextDescription,
          whiteSpace: "nowrap",
          content: "attr(data-count)",
          pointerEvents: "none",
          float: "right"
        }
      },
      "&-rtl": {
        "&::after": {
          float: "left"
        }
      }
    }
  };
}, xi = $t("Input", (l) => {
  const t = HZ(l);
  return [
    cr(t),
    Vr(t),
    Zr(t),
    Fr(t),
    or(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Li(t)
  ];
});
var Qr = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, name: "left", theme: "outlined" };
function nU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      Wr(l, d, n[d]);
    });
  }
  return l;
}
function Wr(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Te = function(t, n) {
  var e = nU({}, t, n.attrs);
  return H($l, nU({}, e, {
    icon: Qr
  }), null);
};
Te.displayName = "LeftOutlined";
Te.inheritAttrs = !1;
const Fe = (l) => l != null && (Array.isArray(l) ? Bn(l).length : !0);
function gi(l) {
  return Fe(l.prefix) || Fe(l.suffix) || Fe(l.allowClear);
}
function $e(l) {
  return Fe(l.addonBefore) || Fe(l.addonAfter);
}
function ti(l) {
  return typeof l > "u" || l === null ? "" : String(l);
}
function oe(l, t, n, e) {
  if (!n)
    return;
  const d = t;
  if (t.type === "click") {
    Object.defineProperty(d, "target", {
      writable: !0
    }), Object.defineProperty(d, "currentTarget", {
      writable: !0
    });
    const a = l.cloneNode(!0);
    d.target = a, d.currentTarget = a, a.value = "", n(d);
    return;
  }
  if (e !== void 0) {
    Object.defineProperty(d, "target", {
      writable: !0
    }), Object.defineProperty(d, "currentTarget", {
      writable: !0
    }), d.target = l, d.currentTarget = l, l.value = e, n(d);
    return;
  }
  n(d);
}
function PZ(l, t) {
  if (!l)
    return;
  l.focus(t);
  const {
    cursor: n
  } = t || {};
  if (n) {
    const e = l.value.length;
    switch (n) {
      case "start":
        l.setSelectionRange(0, 0);
        break;
      case "end":
        l.setSelectionRange(e, e);
        break;
      default:
        l.setSelectionRange(0, e);
    }
  }
}
const hr = () => ({
  addonBefore: ol.any,
  addonAfter: ol.any,
  prefix: ol.any,
  suffix: ol.any,
  clearIcon: ol.any,
  affixWrapperClassName: String,
  groupClassName: String,
  wrapperClassName: String,
  inputClassName: String,
  allowClear: {
    type: Boolean,
    default: void 0
  }
}), AZ = () => j(j({}, hr()), {
  value: {
    type: [String, Number, Symbol],
    default: void 0
  },
  defaultValue: {
    type: [String, Number, Symbol],
    default: void 0
  },
  inputElement: ol.any,
  prefixCls: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  focused: {
    type: Boolean,
    default: void 0
  },
  triggerFocus: Function,
  readonly: {
    type: Boolean,
    default: void 0
  },
  handleReset: Function,
  hidden: {
    type: Boolean,
    default: void 0
  }
}), $Z = () => j(j({}, AZ()), {
  id: String,
  placeholder: {
    type: [String, Number]
  },
  autocomplete: String,
  type: Ht("text"),
  name: String,
  size: {
    type: String
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  lazy: {
    type: Boolean,
    default: !0
  },
  maxlength: Number,
  loading: {
    type: Boolean,
    default: void 0
  },
  bordered: {
    type: Boolean,
    default: void 0
  },
  showCount: {
    type: [Boolean, Object]
  },
  htmlSize: Number,
  onPressEnter: Function,
  onKeydown: Function,
  onKeyup: Function,
  onFocus: Function,
  onBlur: Function,
  onChange: Function,
  onInput: Function,
  "onUpdate:value": Function,
  onCompositionstart: Function,
  onCompositionend: Function,
  valueModifiers: Object,
  hidden: {
    type: Boolean,
    default: void 0
  },
  status: String
}), Rr = pl({
  name: "BaseInput",
  inheritAttrs: !1,
  props: AZ(),
  setup(l, t) {
    let {
      slots: n,
      attrs: e
    } = t;
    const d = Ml(), a = (V) => {
      var h;
      if (!((h = d.value) === null || h === void 0) && h.contains(V.target)) {
        const {
          triggerFocus: W
        } = l;
        W?.();
      }
    }, U = () => {
      var V;
      const {
        allowClear: h,
        value: W,
        disabled: Z,
        readonly: s,
        handleReset: o,
        suffix: F = n.suffix,
        prefixCls: N
      } = l;
      if (!h)
        return null;
      const Q = !Z && !s && W, u = `${N}-clear-icon`, i = ((V = n.clearIcon) === null || V === void 0 ? void 0 : V.call(n)) || "*";
      return H("span", {
        onClick: o,
        onMousedown: (c) => c.preventDefault(),
        class: Xl({
          [`${u}-hidden`]: !Q,
          [`${u}-has-suffix`]: !!F
        }, u),
        role: "button",
        tabindex: -1
      }, [i]);
    };
    return () => {
      var V, h;
      const {
        focused: W,
        value: Z,
        disabled: s,
        allowClear: o,
        readonly: F,
        hidden: N,
        prefixCls: Q,
        prefix: u = (V = n.prefix) === null || V === void 0 ? void 0 : V.call(n),
        suffix: i = (h = n.suffix) === null || h === void 0 ? void 0 : h.call(n),
        addonAfter: c = n.addonAfter,
        addonBefore: R = n.addonBefore,
        inputElement: m,
        affixWrapperClassName: M,
        wrapperClassName: S,
        groupClassName: p
      } = l;
      let Y = bt(m, {
        value: Z,
        hidden: N
      });
      if (gi({
        prefix: u,
        suffix: i,
        allowClear: o
      })) {
        const k = `${Q}-affix-wrapper`, L = Xl(k, {
          [`${k}-disabled`]: s,
          [`${k}-focused`]: W,
          [`${k}-readonly`]: F,
          [`${k}-input-with-clear-btn`]: i && o && Z
        }, !$e({
          addonAfter: c,
          addonBefore: R
        }) && e.class, M), z = (i || o) && H("span", {
          class: `${Q}-suffix`
        }, [U(), i]);
        Y = H("span", {
          class: L,
          style: e.style,
          hidden: !$e({
            addonAfter: c,
            addonBefore: R
          }) && N,
          onMousedown: a,
          ref: d
        }, [u && H("span", {
          class: `${Q}-prefix`
        }, [u]), bt(m, {
          style: null,
          value: Z,
          hidden: null
        }), z]);
      }
      if ($e({
        addonAfter: c,
        addonBefore: R
      })) {
        const k = `${Q}-group`, L = `${k}-addon`, z = Xl(`${Q}-wrapper`, k, S), f = Xl(`${Q}-group-wrapper`, e.class, p);
        return H("span", {
          class: f,
          style: e.style,
          hidden: N
        }, [H("span", {
          class: z
        }, [R && H("span", {
          class: L
        }, [R]), bt(Y, {
          style: null,
          hidden: null
        }), c && H("span", {
          class: L
        }, [c])])]);
      }
      return Y;
    };
  }
});
var Nr = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const br = pl({
  name: "VCInput",
  inheritAttrs: !1,
  props: $Z(),
  setup(l, t) {
    let {
      slots: n,
      attrs: e,
      expose: d,
      emit: a
    } = t;
    const U = bl(l.value === void 0 ? l.defaultValue : l.value), V = bl(!1), h = bl(), W = bl();
    Bl(() => l.value, () => {
      U.value = l.value;
    }), Bl(() => l.disabled, () => {
      l.disabled && (V.value = !1);
    });
    const Z = (p) => {
      h.value && PZ(h.value.input, p);
    }, s = () => {
      var p;
      (p = h.value.input) === null || p === void 0 || p.blur();
    }, o = (p, Y, k) => {
      var L;
      (L = h.value.input) === null || L === void 0 || L.setSelectionRange(p, Y, k);
    }, F = () => {
      var p;
      (p = h.value.input) === null || p === void 0 || p.select();
    };
    d({
      focus: Z,
      blur: s,
      input: Zl(() => {
        var p;
        return (p = h.value.input) === null || p === void 0 ? void 0 : p.input;
      }),
      stateValue: U,
      setSelectionRange: o,
      select: F
    });
    const N = (p) => {
      a("change", p);
    }, Q = (p, Y) => {
      U.value !== p && (l.value === void 0 ? U.value = p : dt(() => {
        var k;
        h.value.input.value !== U.value && ((k = W.value) === null || k === void 0 || k.$forceUpdate());
      }), dt(() => {
        Y && Y();
      }));
    }, u = (p) => {
      const {
        value: Y
      } = p.target;
      if (U.value === Y)
        return;
      const k = p.target.value;
      oe(h.value.input, p, N), Q(k);
    }, i = (p) => {
      p.keyCode === 13 && a("pressEnter", p), a("keydown", p);
    }, c = (p) => {
      V.value = !0, a("focus", p);
    }, R = (p) => {
      V.value = !1, a("blur", p);
    }, m = (p) => {
      oe(h.value.input, p, N), Q("", () => {
        Z();
      });
    }, M = () => {
      var p, Y;
      const {
        addonBefore: k = n.addonBefore,
        addonAfter: L = n.addonAfter,
        disabled: z,
        valueModifiers: f = {},
        htmlSize: K,
        autocomplete: P,
        prefixCls: w,
        inputClassName: O,
        prefix: el = (p = n.prefix) === null || p === void 0 ? void 0 : p.call(n),
        suffix: ll = (Y = n.suffix) === null || Y === void 0 ? void 0 : Y.call(n),
        allowClear: q,
        type: _ = "text"
      } = l, il = ut(l, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "size",
        "bordered",
        "htmlSize",
        "lazy",
        "showCount",
        "valueModifiers",
        "showCount",
        "affixWrapperClassName",
        "groupClassName",
        "inputClassName",
        "wrapperClassName"
      ]), dl = j(j(j({}, il), e), {
        autocomplete: P,
        onChange: u,
        onInput: u,
        onFocus: c,
        onBlur: R,
        onKeydown: i,
        class: Xl(w, {
          [`${w}-disabled`]: z
        }, O, !$e({
          addonAfter: L,
          addonBefore: k
        }) && !gi({
          prefix: el,
          suffix: ll,
          allowClear: q
        }) && e.class),
        ref: h,
        key: "ant-input",
        size: K,
        type: _,
        lazy: l.lazy
      });
      return f.lazy && delete dl.onInput, dl.autofocus || delete dl.autofocus, H(ye, ut(dl, ["size"]), null);
    }, S = () => {
      var p;
      const {
        maxlength: Y,
        suffix: k = (p = n.suffix) === null || p === void 0 ? void 0 : p.call(n),
        showCount: L,
        prefixCls: z
      } = l, f = Number(Y) > 0;
      if (k || L) {
        const K = [...ti(U.value)].length, P = typeof L == "object" ? L.formatter({
          count: K,
          maxlength: Y
        }) : `${K}${f ? ` / ${Y}` : ""}`;
        return H(st, null, [!!L && H("span", {
          class: Xl(`${z}-show-count-suffix`, {
            [`${z}-show-count-has-suffix`]: !!k
          })
        }, [P]), k]);
      }
      return null;
    };
    return ql(() => {
      process.env.NODE_ENV === "test" && l.autofocus && Z();
    }), () => {
      const {
        prefixCls: p,
        disabled: Y
      } = l, k = Nr(l, ["prefixCls", "disabled"]);
      return H(Rr, Ql(Ql(Ql({}, k), e), {}, {
        ref: W,
        prefixCls: p,
        inputElement: M(),
        handleReset: m,
        value: ti(U.value),
        focused: V.value,
        triggerFocus: Z,
        suffix: S(),
        disabled: Y
      }), n);
    };
  }
}), xd = () => ut($Z(), ["wrapperClassName", "groupClassName", "inputClassName", "affixWrapperClassName"]), qZ = () => j(j({}, ut(xd(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {
  rows: Number,
  autosize: {
    type: [Boolean, Object],
    default: void 0
  },
  autoSize: {
    type: [Boolean, Object],
    default: void 0
  },
  onResize: {
    type: Function
  },
  onCompositionstart: nd(),
  onCompositionend: nd(),
  valueModifiers: Object
});
var mr = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const Ut = pl({
  compatConfig: {
    MODE: 3
  },
  name: "AInput",
  inheritAttrs: !1,
  props: xd(),
  setup(l, t) {
    let {
      slots: n,
      attrs: e,
      expose: d,
      emit: a
    } = t;
    const U = Ml(), V = Bi(), h = Gn.useInject(), W = Zl(() => Cd(h.status, l.status)), {
      direction: Z,
      prefixCls: s,
      size: o,
      autocomplete: F
    } = ht("input", l), {
      compactSize: N,
      compactItemClassnames: Q
    } = zi(s, Z), u = Zl(() => N.value || o.value), [i, c] = xi(s), R = Ge();
    d({
      focus: (K) => {
        var P;
        (P = U.value) === null || P === void 0 || P.focus(K);
      },
      blur: () => {
        var K;
        (K = U.value) === null || K === void 0 || K.blur();
      },
      input: U,
      setSelectionRange: (K, P, w) => {
        var O;
        (O = U.value) === null || O === void 0 || O.setSelectionRange(K, P, w);
      },
      select: () => {
        var K;
        (K = U.value) === null || K === void 0 || K.select();
      }
    });
    const Y = Ml([]), k = () => {
      Y.value.push(setTimeout(() => {
        var K, P, w, O;
        !((K = U.value) === null || K === void 0) && K.input && ((P = U.value) === null || P === void 0 ? void 0 : P.input.getAttribute("type")) === "password" && (!((w = U.value) === null || w === void 0) && w.input.hasAttribute("value")) && ((O = U.value) === null || O === void 0 || O.input.removeAttribute("value"));
      }));
    };
    ql(() => {
      k();
    }), rF(() => {
      Y.value.forEach((K) => clearTimeout(K));
    }), Wt(() => {
      Y.value.forEach((K) => clearTimeout(K));
    });
    const L = (K) => {
      k(), a("blur", K), V.onFieldBlur();
    }, z = (K) => {
      k(), a("focus", K);
    }, f = (K) => {
      a("update:value", K.target.value), a("change", K), a("input", K), V.onFieldChange();
    };
    return () => {
      var K, P, w, O, el, ll;
      const {
        hasFeedback: q,
        feedbackIcon: _
      } = h, {
        allowClear: il,
        bordered: dl = !0,
        prefix: tl = (K = n.prefix) === null || K === void 0 ? void 0 : K.call(n),
        suffix: al = (P = n.suffix) === null || P === void 0 ? void 0 : P.call(n),
        addonAfter: Ul = (w = n.addonAfter) === null || w === void 0 ? void 0 : w.call(n),
        addonBefore: cl = (O = n.addonBefore) === null || O === void 0 ? void 0 : O.call(n),
        id: B = (el = V.id) === null || el === void 0 ? void 0 : el.value
      } = l, X = mr(l, ["allowClear", "bordered", "prefix", "suffix", "addonAfter", "addonBefore", "id"]), b = (q || al) && H(st, null, [al, q && _]), r = s.value, G = gi({
        prefix: tl,
        suffix: al
      }) || !!q, J = n.clearIcon || (() => H(Be, null, null));
      return i(H(br, Ql(Ql(Ql({}, e), ut(X, ["onUpdate:value", "onChange", "onInput"])), {}, {
        onChange: f,
        id: B,
        disabled: (ll = l.disabled) !== null && ll !== void 0 ? ll : R.value,
        ref: U,
        prefixCls: r,
        autocomplete: F.value,
        onBlur: L,
        onFocus: z,
        prefix: tl,
        suffix: b,
        allowClear: il,
        addonAfter: Ul && H(wc, null, {
          default: () => [H(Cc, null, {
            default: () => [Ul]
          })]
        }),
        addonBefore: cl && H(wc, null, {
          default: () => [H(Cc, null, {
            default: () => [cl]
          })]
        }),
        class: [e.class, Q.value],
        inputClassName: Xl({
          [`${r}-sm`]: u.value === "small",
          [`${r}-lg`]: u.value === "large",
          [`${r}-rtl`]: Z.value === "rtl",
          [`${r}-borderless`]: !dl
        }, !G && On(r, W.value), c.value),
        affixWrapperClassName: Xl({
          [`${r}-affix-wrapper-sm`]: u.value === "small",
          [`${r}-affix-wrapper-lg`]: u.value === "large",
          [`${r}-affix-wrapper-rtl`]: Z.value === "rtl",
          [`${r}-affix-wrapper-borderless`]: !dl
        }, On(`${r}-affix-wrapper`, W.value, q), c.value),
        wrapperClassName: Xl({
          [`${r}-group-rtl`]: Z.value === "rtl"
        }, c.value),
        groupClassName: Xl({
          [`${r}-group-wrapper-sm`]: u.value === "small",
          [`${r}-group-wrapper-lg`]: u.value === "large",
          [`${r}-group-wrapper-rtl`]: Z.value === "rtl"
        }, On(`${r}-group-wrapper`, W.value, q), c.value)
      }), j(j({}, n), {
        clearIcon: J
      })));
    };
  }
}), ur = pl({
  compatConfig: {
    MODE: 3
  },
  name: "AInputGroup",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    size: {
      type: String
    },
    compact: {
      type: Boolean,
      default: void 0
    }
  },
  setup(l, t) {
    let {
      slots: n,
      attrs: e
    } = t;
    const {
      prefixCls: d,
      direction: a,
      getPrefixCls: U
    } = ht("input-group", l), V = Gn.useInject();
    Gn.useProvide(V, {
      isFormItemInput: !1
    });
    const h = Zl(() => U("input")), [W, Z] = xi(h), s = Zl(() => {
      const o = d.value;
      return {
        [`${o}`]: !0,
        [Z.value]: !0,
        [`${o}-lg`]: l.size === "large",
        [`${o}-sm`]: l.size === "small",
        [`${o}-compact`]: l.compact,
        [`${o}-rtl`]: a.value === "rtl"
      };
    });
    return () => {
      var o;
      return W(H("span", Ql(Ql({}, e), {}, {
        class: Xl(s.value, e.class)
      }), [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]));
    };
  }
});
var rr = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const _Z = pl({
  compatConfig: {
    MODE: 3
  },
  name: "AInputSearch",
  inheritAttrs: !1,
  props: j(j({}, xd()), {
    inputPrefixCls: String,
    // 不能设置默认值 https://github.com/vueComponent/ant-design-vue/issues/1916
    enterButton: ol.any,
    onSearch: {
      type: Function
    }
  }),
  setup(l, t) {
    let {
      slots: n,
      attrs: e,
      expose: d,
      emit: a
    } = t;
    const U = bl(), V = bl(!1);
    d({
      focus: () => {
        var M;
        (M = U.value) === null || M === void 0 || M.focus();
      },
      blur: () => {
        var M;
        (M = U.value) === null || M === void 0 || M.blur();
      }
    });
    const Z = (M) => {
      a("update:value", M.target.value), M && M.target && M.type === "click" && a("search", M.target.value, M), a("change", M);
    }, s = (M) => {
      var S;
      document.activeElement === ((S = U.value) === null || S === void 0 ? void 0 : S.input) && M.preventDefault();
    }, o = (M) => {
      var S, p;
      a("search", (p = (S = U.value) === null || S === void 0 ? void 0 : S.input) === null || p === void 0 ? void 0 : p.stateValue, M);
    }, F = (M) => {
      V.value || l.loading || o(M);
    }, N = (M) => {
      V.value = !0, a("compositionstart", M);
    }, Q = (M) => {
      V.value = !1, a("compositionend", M);
    }, {
      prefixCls: u,
      getPrefixCls: i,
      direction: c,
      size: R
    } = ht("input-search", l), m = Zl(() => i("input", l.inputPrefixCls));
    return () => {
      var M, S, p, Y;
      const {
        disabled: k,
        loading: L,
        addonAfter: z = (M = n.addonAfter) === null || M === void 0 ? void 0 : M.call(n),
        suffix: f = (S = n.suffix) === null || S === void 0 ? void 0 : S.call(n)
      } = l, K = rr(l, ["disabled", "loading", "addonAfter", "suffix"]);
      let {
        enterButton: P = (Y = (p = n.enterButton) === null || p === void 0 ? void 0 : p.call(n)) !== null && Y !== void 0 ? Y : !1
      } = l;
      P = P || P === "";
      const w = typeof P == "boolean" ? H(Dd, null, null) : null, O = `${u.value}-button`, el = Array.isArray(P) ? P[0] : P;
      let ll;
      const q = el.type && Fm(el.type) && el.type.__ANT_BUTTON;
      if (q || el.tagName === "button")
        ll = bt(el, j({
          onMousedown: s,
          onClick: o,
          key: "enterButton"
        }, q ? {
          class: O,
          size: R.value
        } : {}), !1);
      else {
        const il = w && !P;
        ll = H(Ze, {
          class: O,
          type: P ? "primary" : void 0,
          size: R.value,
          disabled: k,
          key: "enterButton",
          onMousedown: s,
          onClick: o,
          loading: L,
          icon: il ? w : null
        }, {
          default: () => [il ? null : w || P]
        });
      }
      z && (ll = [ll, z]);
      const _ = Xl(u.value, {
        [`${u.value}-rtl`]: c.value === "rtl",
        [`${u.value}-${R.value}`]: !!R.value,
        [`${u.value}-with-button`]: !!P
      }, e.class);
      return H(Ut, Ql(Ql(Ql({
        ref: U
      }, ut(K, ["onUpdate:value", "onSearch", "enterButton"])), e), {}, {
        onPressEnter: F,
        onCompositionstart: N,
        onCompositionend: Q,
        size: R.value,
        prefixCls: m.value,
        addonAfter: ll,
        suffix: f,
        onChange: Z,
        class: _,
        disabled: k
      }), n);
    };
  }
}), eU = (l) => l != null && (Array.isArray(l) ? Bn(l).length : !0);
function Mr(l) {
  return eU(l.addonBefore) || eU(l.addonAfter);
}
const pr = ["text", "input"], Sr = pl({
  compatConfig: {
    MODE: 3
  },
  name: "ClearableLabeledInput",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    inputType: ol.oneOf(he("text", "input")),
    value: kt(),
    defaultValue: kt(),
    allowClear: {
      type: Boolean,
      default: void 0
    },
    element: kt(),
    handleReset: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    },
    size: {
      type: String
    },
    suffix: kt(),
    prefix: kt(),
    addonBefore: kt(),
    addonAfter: kt(),
    readonly: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: !0
    },
    triggerFocus: {
      type: Function
    },
    hidden: Boolean,
    status: String,
    hashId: String
  },
  setup(l, t) {
    let {
      slots: n,
      attrs: e
    } = t;
    const d = Gn.useInject(), a = (V) => {
      const {
        value: h,
        disabled: W,
        readonly: Z,
        handleReset: s,
        suffix: o = n.suffix
      } = l, F = !W && !Z && h, N = `${V}-clear-icon`;
      return H(Be, {
        onClick: s,
        onMousedown: (Q) => Q.preventDefault(),
        class: Xl({
          [`${N}-hidden`]: !F,
          [`${N}-has-suffix`]: !!o
        }, N),
        role: "button"
      }, null);
    }, U = (V, h) => {
      const {
        value: W,
        allowClear: Z,
        direction: s,
        bordered: o,
        hidden: F,
        status: N,
        addonAfter: Q = n.addonAfter,
        addonBefore: u = n.addonBefore,
        hashId: i
      } = l, {
        status: c,
        hasFeedback: R
      } = d;
      if (!Z)
        return bt(h, {
          value: W,
          disabled: l.disabled
        });
      const m = Xl(`${V}-affix-wrapper`, `${V}-affix-wrapper-textarea-with-clear-btn`, On(`${V}-affix-wrapper`, Cd(c, N), R), {
        [`${V}-affix-wrapper-rtl`]: s === "rtl",
        [`${V}-affix-wrapper-borderless`]: !o,
        // className will go to addon wrapper
        [`${e.class}`]: !Mr({
          addonAfter: Q,
          addonBefore: u
        }) && e.class
      }, i);
      return H("span", {
        class: m,
        style: e.style,
        hidden: F
      }, [bt(h, {
        style: null,
        value: W,
        disabled: l.disabled
      }), a(V)]);
    };
    return () => {
      var V;
      const {
        prefixCls: h,
        inputType: W,
        element: Z = (V = n.element) === null || V === void 0 ? void 0 : V.call(n)
      } = l;
      return W === pr[0] ? U(h, Z) : null;
    };
  }
}), Tr = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, Gr = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], Ra = {};
let yt;
function Jr(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = l.getAttribute("id") || l.getAttribute("data-reactid") || l.getAttribute("name");
  if (t && Ra[n])
    return Ra[n];
  const e = window.getComputedStyle(l), d = e.getPropertyValue("box-sizing") || e.getPropertyValue("-moz-box-sizing") || e.getPropertyValue("-webkit-box-sizing"), a = parseFloat(e.getPropertyValue("padding-bottom")) + parseFloat(e.getPropertyValue("padding-top")), U = parseFloat(e.getPropertyValue("border-bottom-width")) + parseFloat(e.getPropertyValue("border-top-width")), h = {
    sizingStyle: Gr.map((W) => `${W}:${e.getPropertyValue(W)}`).join(";"),
    paddingSize: a,
    borderSize: U,
    boxSizing: d
  };
  return t && n && (Ra[n] = h), h;
}
function Xr(l) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, e = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  yt || (yt = document.createElement("textarea"), yt.setAttribute("tab-index", "-1"), yt.setAttribute("aria-hidden", "true"), document.body.appendChild(yt)), l.getAttribute("wrap") ? yt.setAttribute("wrap", l.getAttribute("wrap")) : yt.removeAttribute("wrap");
  const {
    paddingSize: d,
    borderSize: a,
    boxSizing: U,
    sizingStyle: V
  } = Jr(l, t);
  yt.setAttribute("style", `${V};${Tr}`), yt.value = l.value || l.placeholder || "";
  let h, W, Z, s = yt.scrollHeight;
  if (U === "border-box" ? s += a : U === "content-box" && (s -= d), n !== null || e !== null) {
    yt.value = " ";
    const F = yt.scrollHeight - d;
    n !== null && (h = F * n, U === "border-box" && (h = h + d + a), s = Math.max(h, s)), e !== null && (W = F * e, U === "border-box" && (W = W + d + a), Z = s > W ? "" : "hidden", s = Math.min(W, s));
  }
  const o = {
    height: `${s}px`,
    overflowY: Z,
    resize: "none"
  };
  return h && (o.minHeight = `${h}px`), W && (o.maxHeight = `${W}px`), o;
}
const Na = 0, ba = 1, ma = 2, Yr = pl({
  compatConfig: {
    MODE: 3
  },
  name: "ResizableTextArea",
  inheritAttrs: !1,
  props: qZ(),
  setup(l, t) {
    let {
      attrs: n,
      emit: e,
      expose: d
    } = t, a, U;
    const V = Ml(), h = Ml({}), W = Ml(ma);
    Wt(() => {
      Ol.cancel(a), Ol.cancel(U);
    });
    const Z = () => {
      try {
        if (V.value && document.activeElement === V.value.input) {
          const S = V.value.getSelectionStart(), p = V.value.getSelectionEnd(), Y = V.value.getScrollTop();
          V.value.setSelectionRange(S, p), V.value.setScrollTop(Y);
        }
      } catch {
      }
    }, s = Ml(), o = Ml();
    it(() => {
      const S = l.autoSize || l.autosize;
      S ? (s.value = S.minRows, o.value = S.maxRows) : (s.value = void 0, o.value = void 0);
    });
    const F = Zl(() => !!(l.autoSize || l.autosize)), N = () => {
      W.value = Na;
    };
    Bl([() => l.value, s, o, F], () => {
      F.value && N();
    }, {
      immediate: !0
    });
    const Q = Ml();
    Bl([W, V], () => {
      if (V.value)
        if (W.value === Na)
          W.value = ba;
        else if (W.value === ba) {
          const S = Xr(V.value.input, !1, s.value, o.value);
          W.value = ma, Q.value = S;
        } else
          Z();
    }, {
      immediate: !0,
      flush: "post"
    });
    const u = Jn(), i = Ml(), c = () => {
      Ol.cancel(i.value);
    }, R = (S) => {
      W.value === ma && (e("resize", S), F.value && (c(), i.value = Ol(() => {
        N();
      })));
    };
    Wt(() => {
      c();
    }), d({
      resizeTextarea: () => {
        N();
      },
      textArea: Zl(() => {
        var S;
        return (S = V.value) === null || S === void 0 ? void 0 : S.input;
      }),
      instance: u
    }), Je(l.autosize === void 0, "Input.TextArea", "autosize is deprecated, please use autoSize instead.");
    const M = () => {
      const {
        prefixCls: S,
        disabled: p
      } = l, Y = ut(l, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "maxlength", "valueModifiers"]), k = Xl(S, n.class, {
        [`${S}-disabled`]: p
      }), L = F.value ? Q.value : null, z = [n.style, h.value, L], f = j(j(j({}, Y), n), {
        style: z,
        class: k
      });
      return (W.value === Na || W.value === ba) && z.push({
        overflowX: "hidden",
        overflowY: "hidden"
      }), f.autofocus || delete f.autofocus, f.rows === 0 && delete f.rows, H(Sd, {
        onResize: R,
        disabled: !F.value
      }, {
        default: () => [H(ye, Ql(Ql({}, f), {}, {
          ref: V,
          tag: "textarea"
        }), null)]
      });
    };
    return () => M();
  }
});
function lF(l, t) {
  return [...l || ""].slice(0, t).join("");
}
function dU(l, t, n, e) {
  let d = n;
  return l ? d = lF(n, e) : [...t || ""].length < n.length && [...n || ""].length > e && (d = t), d;
}
const yr = pl({
  compatConfig: {
    MODE: 3
  },
  name: "ATextarea",
  inheritAttrs: !1,
  props: qZ(),
  setup(l, t) {
    let {
      attrs: n,
      expose: e,
      emit: d
    } = t;
    const a = Bi(), U = Gn.useInject(), V = Zl(() => Cd(U.status, l.status)), h = bl(l.value === void 0 ? l.defaultValue : l.value), W = bl(), Z = bl(""), {
      prefixCls: s,
      size: o,
      direction: F
    } = ht("input", l), [N, Q] = xi(s), u = Ge(), i = Zl(() => l.showCount === "" || l.showCount || !1), c = Zl(() => Number(l.maxlength) > 0), R = bl(!1), m = bl(), M = bl(0), S = (ll) => {
      R.value = !0, m.value = Z.value, M.value = ll.currentTarget.selectionStart, d("compositionstart", ll);
    }, p = (ll) => {
      var q;
      R.value = !1;
      let _ = ll.currentTarget.value;
      if (c.value) {
        const il = M.value >= l.maxlength + 1 || M.value === ((q = m.value) === null || q === void 0 ? void 0 : q.length);
        _ = dU(il, m.value, _, l.maxlength);
      }
      _ !== Z.value && (z(_), oe(ll.currentTarget, ll, P, _)), d("compositionend", ll);
    }, Y = Jn();
    Bl(() => l.value, () => {
      var ll;
      "value" in Y.vnode.props, h.value = (ll = l.value) !== null && ll !== void 0 ? ll : "";
    });
    const k = (ll) => {
      var q;
      PZ((q = W.value) === null || q === void 0 ? void 0 : q.textArea, ll);
    }, L = () => {
      var ll, q;
      (q = (ll = W.value) === null || ll === void 0 ? void 0 : ll.textArea) === null || q === void 0 || q.blur();
    }, z = (ll, q) => {
      h.value !== ll && (l.value === void 0 ? h.value = ll : dt(() => {
        var _, il, dl;
        W.value.textArea.value !== Z.value && ((dl = (_ = W.value) === null || _ === void 0 ? void 0 : (il = _.instance).update) === null || dl === void 0 || dl.call(il));
      }), dt(() => {
        q && q();
      }));
    }, f = (ll) => {
      ll.keyCode === 13 && d("pressEnter", ll), d("keydown", ll);
    }, K = (ll) => {
      const {
        onBlur: q
      } = l;
      q?.(ll), a.onFieldBlur();
    }, P = (ll) => {
      d("update:value", ll.target.value), d("change", ll), d("input", ll), a.onFieldChange();
    }, w = (ll) => {
      oe(W.value.textArea, ll, P), z("", () => {
        k();
      });
    }, O = (ll) => {
      let q = ll.target.value;
      if (h.value !== q) {
        if (c.value) {
          const _ = ll.target, il = _.selectionStart >= l.maxlength + 1 || _.selectionStart === q.length || !_.selectionStart;
          q = dU(il, Z.value, q, l.maxlength);
        }
        oe(ll.currentTarget, ll, P, q), z(q);
      }
    }, el = () => {
      var ll, q;
      const {
        class: _
      } = n, {
        bordered: il = !0
      } = l, dl = j(j(j({}, ut(l, ["allowClear"])), n), {
        class: [{
          [`${s.value}-borderless`]: !il,
          [`${_}`]: _ && !i.value,
          [`${s.value}-sm`]: o.value === "small",
          [`${s.value}-lg`]: o.value === "large"
        }, On(s.value, V.value), Q.value],
        disabled: u.value,
        showCount: null,
        prefixCls: s.value,
        onInput: O,
        onChange: O,
        onBlur: K,
        onKeydown: f,
        onCompositionstart: S,
        onCompositionend: p
      });
      return !((ll = l.valueModifiers) === null || ll === void 0) && ll.lazy && delete dl.onInput, H(Yr, Ql(Ql({}, dl), {}, {
        id: (q = dl?.id) !== null && q !== void 0 ? q : a.id.value,
        ref: W,
        maxlength: l.maxlength,
        lazy: l.lazy
      }), null);
    };
    return e({
      focus: k,
      blur: L,
      resizableTextArea: W
    }), it(() => {
      let ll = ti(h.value);
      !R.value && c.value && (l.value === null || l.value === void 0) && (ll = lF(ll, l.maxlength)), Z.value = ll;
    }), () => {
      var ll;
      const {
        maxlength: q,
        bordered: _ = !0,
        hidden: il
      } = l, {
        style: dl,
        class: tl
      } = n, al = j(j(j({}, l), n), {
        prefixCls: s.value,
        inputType: "text",
        handleReset: w,
        direction: F.value,
        bordered: _,
        style: i.value ? void 0 : dl,
        hashId: Q.value,
        disabled: (ll = l.disabled) !== null && ll !== void 0 ? ll : u.value
      });
      let Ul = H(Sr, Ql(Ql({}, al), {}, {
        value: Z.value,
        status: l.status
      }), {
        element: el
      });
      if (i.value || U.hasFeedback) {
        const cl = [...Z.value].length;
        let B = "";
        typeof i.value == "object" ? B = i.value.formatter({
          value: Z.value,
          count: cl,
          maxlength: q
        }) : B = `${cl}${c.value ? ` / ${q}` : ""}`, Ul = H("div", {
          hidden: il,
          class: Xl(`${s.value}-textarea`, {
            [`${s.value}-textarea-rtl`]: F.value === "rtl",
            [`${s.value}-textarea-show-count`]: i.value,
            [`${s.value}-textarea-in-form-item`]: U.isFormItemInput
          }, `${s.value}-textarea-show-count`, tl, Q.value),
          style: dl,
          "data-count": typeof B != "object" ? B : void 0
        }, [Ul, U.hasFeedback && H("span", {
          class: `${s.value}-textarea-suffix`
        }, [U.feedbackIcon])]);
      }
      return N(Ul);
    };
  }
});
var Br = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" };
function aU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      zr(l, d, n[d]);
    });
  }
  return l;
}
function zr(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var gd = function(t, n) {
  var e = aU({}, t, n.attrs);
  return H($l, aU({}, e, {
    icon: Br
  }), null);
};
gd.displayName = "EyeOutlined";
gd.inheritAttrs = !1;
var Lr = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" };
function iU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      kr(l, d, n[d]);
    });
  }
  return l;
}
function kr(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var ji = function(t, n) {
  var e = iU({}, t, n.attrs);
  return H($l, iU({}, e, {
    icon: Lr
  }), null);
};
ji.displayName = "EyeInvisibleOutlined";
ji.inheritAttrs = !1;
var Ir = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const Dr = {
  click: "onClick",
  hover: "onMouseover"
}, Cr = (l) => l ? H(gd, null, null) : H(ji, null, null), wr = pl({
  compatConfig: {
    MODE: 3
  },
  name: "AInputPassword",
  inheritAttrs: !1,
  props: j(j({}, xd()), {
    prefixCls: String,
    inputPrefixCls: String,
    action: {
      type: String,
      default: "click"
    },
    visibilityToggle: {
      type: Boolean,
      default: !0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    "onUpdate:visible": Function,
    iconRender: Function
  }),
  setup(l, t) {
    let {
      slots: n,
      attrs: e,
      expose: d,
      emit: a
    } = t;
    const U = bl(!1), V = () => {
      const {
        disabled: u
      } = l;
      u || (U.value = !U.value, a("update:visible", U.value));
    };
    it(() => {
      l.visible !== void 0 && (U.value = !!l.visible);
    });
    const h = bl();
    d({
      focus: () => {
        var u;
        (u = h.value) === null || u === void 0 || u.focus();
      },
      blur: () => {
        var u;
        (u = h.value) === null || u === void 0 || u.blur();
      }
    });
    const s = (u) => {
      const {
        action: i,
        iconRender: c = n.iconRender || Cr
      } = l, R = Dr[i] || "", m = c(U.value), M = {
        [R]: V,
        class: `${u}-icon`,
        key: "passwordIcon",
        onMousedown: (S) => {
          S.preventDefault();
        },
        onMouseup: (S) => {
          S.preventDefault();
        }
      };
      return bt(Pt(m) ? m : H("span", null, [m]), M);
    }, {
      prefixCls: o,
      getPrefixCls: F
    } = ht("input-password", l), N = Zl(() => F("input", l.inputPrefixCls)), Q = () => {
      const {
        size: u,
        visibilityToggle: i
      } = l, c = Ir(l, ["size", "visibilityToggle"]), R = i && s(o.value), m = Xl(o.value, e.class, {
        [`${o.value}-${u}`]: !!u
      }), M = j(j(j({}, ut(c, ["suffix", "iconRender", "action"])), e), {
        type: U.value ? "text" : "password",
        class: m,
        prefixCls: N.value,
        suffix: R
      });
      return u && (M.size = u), H(Ut, Ql({
        ref: h
      }, M), n);
    };
    return () => Q();
  }
});
Ut.Group = ur;
Ut.Search = _Z;
Ut.TextArea = yr;
Ut.Password = wr;
Ut.install = function(l) {
  return l.component(Ut.name, Ut), l.component(Ut.Group.name, Ut.Group), l.component(Ut.Search.name, Ut.Search), l.component(Ut.TextArea.name, Ut.TextArea), l.component(Ut.Password.name, Ut.Password), l;
};
function Er() {
  const l = document.documentElement.clientWidth, t = window.innerHeight || document.documentElement.clientHeight;
  return {
    width: l,
    height: t
  };
}
function tF(l) {
  const t = l.getBoundingClientRect(), n = document.documentElement;
  return {
    left: t.left + (window.scrollX || n.scrollLeft) - (n.clientLeft || document.body.clientLeft || 0),
    top: t.top + (window.scrollY || n.scrollTop) - (n.clientTop || document.body.clientTop || 0)
  };
}
function jd() {
  return {
    keyboard: {
      type: Boolean,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    afterClose: Function,
    closable: {
      type: Boolean,
      default: void 0
    },
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    mousePosition: ol.shape({
      x: Number,
      y: Number
    }).loose,
    title: ol.any,
    footer: ol.any,
    transitionName: String,
    maskTransitionName: String,
    animation: ol.any,
    maskAnimation: ol.any,
    wrapStyle: {
      type: Object,
      default: void 0
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: String,
    wrapClassName: String,
    rootClassName: String,
    width: [String, Number],
    height: [String, Number],
    zIndex: Number,
    bodyProps: ol.any,
    maskProps: ol.any,
    wrapProps: ol.any,
    getContainer: ol.any,
    dialogStyle: {
      type: Object,
      default: void 0
    },
    dialogClass: String,
    closeIcon: ol.any,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getOpenCount: Function,
    // https://github.com/ant-design/ant-design/issues/19771
    // https://github.com/react-component/dialog/issues/95
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    onClose: Function,
    modalRender: Function
  };
}
function sU(l, t, n) {
  let e = t;
  return !e && n && (e = `${l}-${n}`), e;
}
let cU = -1;
function xr() {
  return cU += 1, cU;
}
function UU(l, t) {
  let n = l[`page${t ? "Y" : "X"}Offset`];
  const e = `scroll${t ? "Top" : "Left"}`;
  if (typeof n != "number") {
    const d = l.document;
    n = d.documentElement[e], typeof n != "number" && (n = d.body[e]);
  }
  return n;
}
function gr(l) {
  const t = l.getBoundingClientRect(), n = {
    left: t.left,
    top: t.top
  }, e = l.ownerDocument, d = e.defaultView || e.parentWindow;
  return n.left += UU(d), n.top += UU(d, !0), n;
}
const ZU = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
}, jr = pl({
  compatConfig: {
    MODE: 3
  },
  name: "DialogContent",
  inheritAttrs: !1,
  props: j(j({}, jd()), {
    motionName: String,
    ariaId: String,
    onVisibleChanged: Function,
    onMousedown: Function,
    onMouseup: Function
  }),
  setup(l, t) {
    let {
      expose: n,
      slots: e,
      attrs: d
    } = t;
    const a = Ml(), U = Ml(), V = Ml();
    n({
      focus: () => {
        var o;
        (o = a.value) === null || o === void 0 || o.focus();
      },
      changeActive: (o) => {
        const {
          activeElement: F
        } = document;
        o && F === U.value ? a.value.focus() : !o && F === a.value && U.value.focus();
      }
    });
    const h = Ml(), W = Zl(() => {
      const {
        width: o,
        height: F
      } = l, N = {};
      return o !== void 0 && (N.width = typeof o == "number" ? `${o}px` : o), F !== void 0 && (N.height = typeof F == "number" ? `${F}px` : F), h.value && (N.transformOrigin = h.value), N;
    }), Z = () => {
      dt(() => {
        if (V.value) {
          const o = gr(V.value);
          h.value = l.mousePosition ? `${l.mousePosition.x - o.left}px ${l.mousePosition.y - o.top}px` : "";
        }
      });
    }, s = (o) => {
      l.onVisibleChanged(o);
    };
    return () => {
      var o, F, N, Q;
      const {
        prefixCls: u,
        footer: i = (o = e.footer) === null || o === void 0 ? void 0 : o.call(e),
        title: c = (F = e.title) === null || F === void 0 ? void 0 : F.call(e),
        ariaId: R,
        closable: m,
        closeIcon: M = (N = e.closeIcon) === null || N === void 0 ? void 0 : N.call(e),
        onClose: S,
        bodyStyle: p,
        bodyProps: Y,
        onMousedown: k,
        onMouseup: L,
        visible: z,
        modalRender: f = e.modalRender,
        destroyOnClose: K,
        motionName: P
      } = l;
      let w;
      i && (w = H("div", {
        class: `${u}-footer`
      }, [i]));
      let O;
      c && (O = H("div", {
        class: `${u}-header`
      }, [H("div", {
        class: `${u}-title`,
        id: R
      }, [c])]));
      let el;
      m && (el = H("button", {
        type: "button",
        onClick: S,
        "aria-label": "Close",
        class: `${u}-close`
      }, [M || H("span", {
        class: `${u}-close-x`
      }, null)]));
      const ll = H("div", {
        class: `${u}-content`
      }, [el, O, H("div", Ql({
        class: `${u}-body`,
        style: p
      }, Y), [(Q = e.default) === null || Q === void 0 ? void 0 : Q.call(e)]), w]), q = Ni(P);
      return H(Yn, Ql(Ql({}, q), {}, {
        onBeforeEnter: Z,
        onAfterEnter: () => s(!0),
        onAfterLeave: () => s(!1)
      }), {
        default: () => [z || !K ? ud(H("div", Ql(Ql({}, d), {}, {
          ref: V,
          key: "dialog-element",
          role: "document",
          style: [W.value, d.style],
          class: [u, d.class],
          onMousedown: k,
          onMouseup: L
        }), [H("div", {
          tabindex: 0,
          ref: a,
          style: ZU,
          "aria-hidden": "true"
        }, null), f ? f({
          originVNode: ll
        }) : ll, H("div", {
          tabindex: 0,
          ref: U,
          style: ZU,
          "aria-hidden": "true"
        }, null)]), [[ei, z]]) : null]
      });
    };
  }
}), Or = pl({
  compatConfig: {
    MODE: 3
  },
  name: "DialogMask",
  props: {
    prefixCls: String,
    visible: Boolean,
    motionName: String,
    maskProps: Object
  },
  setup(l, t) {
    return () => {
      const {
        prefixCls: n,
        visible: e,
        maskProps: d,
        motionName: a
      } = l, U = Ni(a);
      return H(Yn, U, {
        default: () => [ud(H("div", Ql({
          class: `${n}-mask`
        }, d), null), [[ei, e]])]
      });
    };
  }
}), FU = pl({
  compatConfig: {
    MODE: 3
  },
  name: "VcDialog",
  inheritAttrs: !1,
  props: yn(j(j({}, jd()), {
    getOpenCount: Function,
    scrollLocker: Object
  }), {
    mask: !0,
    visible: !1,
    keyboard: !0,
    closable: !0,
    maskClosable: !0,
    destroyOnClose: !1,
    prefixCls: "rc-dialog",
    getOpenCount: () => null,
    focusTriggerAfterClose: !0
  }),
  setup(l, t) {
    let {
      attrs: n,
      slots: e
    } = t;
    const d = bl(), a = bl(), U = bl(), V = bl(l.visible), h = bl(`vcDialogTitle${xr()}`), W = (i) => {
      var c, R;
      if (i)
        tn(a.value, document.activeElement) || (d.value = document.activeElement, (c = U.value) === null || c === void 0 || c.focus());
      else {
        const m = V.value;
        if (V.value = !1, l.mask && d.value && l.focusTriggerAfterClose) {
          try {
            d.value.focus({
              preventScroll: !0
            });
          } catch {
          }
          d.value = null;
        }
        m && ((R = l.afterClose) === null || R === void 0 || R.call(l));
      }
    }, Z = (i) => {
      var c;
      (c = l.onClose) === null || c === void 0 || c.call(l, i);
    }, s = bl(!1), o = bl(), F = () => {
      clearTimeout(o.value), s.value = !0;
    }, N = () => {
      o.value = setTimeout(() => {
        s.value = !1;
      });
    }, Q = (i) => {
      if (!l.maskClosable)
        return null;
      s.value ? s.value = !1 : a.value === i.target && Z(i);
    }, u = (i) => {
      if (l.keyboard && i.keyCode === ul.ESC) {
        i.stopPropagation(), Z(i);
        return;
      }
      l.visible && i.keyCode === ul.TAB && U.value.changeActive(!i.shiftKey);
    };
    return Bl(() => l.visible, () => {
      l.visible && (V.value = !0);
    }, {
      flush: "post"
    }), Wt(() => {
      var i;
      clearTimeout(o.value), (i = l.scrollLocker) === null || i === void 0 || i.unLock();
    }), it(() => {
      var i, c;
      (i = l.scrollLocker) === null || i === void 0 || i.unLock(), V.value && ((c = l.scrollLocker) === null || c === void 0 || c.lock());
    }), () => {
      const {
        prefixCls: i,
        mask: c,
        visible: R,
        maskTransitionName: m,
        maskAnimation: M,
        zIndex: S,
        wrapClassName: p,
        rootClassName: Y,
        wrapStyle: k,
        closable: L,
        maskProps: z,
        maskStyle: f,
        transitionName: K,
        animation: P,
        wrapProps: w,
        title: O = e.title
      } = l, {
        style: el,
        class: ll
      } = n;
      return H("div", Ql({
        class: [`${i}-root`, Y]
      }, zd(l, {
        data: !0
      })), [H(Or, {
        prefixCls: i,
        visible: c && R,
        motionName: sU(i, m, M),
        style: j({
          zIndex: S
        }, f),
        maskProps: z
      }, null), H("div", Ql({
        tabIndex: -1,
        onKeydown: u,
        class: Xl(`${i}-wrap`, p),
        ref: a,
        onClick: Q,
        role: "dialog",
        "aria-labelledby": O ? h.value : null,
        style: j(j({
          zIndex: S
        }, k), {
          display: V.value ? null : "none"
        })
      }, w), [H(jr, Ql(Ql({}, ut(l, ["scrollLocker"])), {}, {
        style: el,
        class: ll,
        onMousedown: F,
        onMouseup: N,
        ref: U,
        closable: L,
        ariaId: h.value,
        prefixCls: i,
        visible: R,
        onClose: Z,
        onVisibleChanged: W,
        motionName: sU(i, K, P)
      }), e)])]);
    };
  }
}), vr = jd(), fr = pl({
  compatConfig: {
    MODE: 3
  },
  name: "DialogWrap",
  inheritAttrs: !1,
  props: yn(vr, {
    visible: !1
  }),
  setup(l, t) {
    let {
      attrs: n,
      slots: e
    } = t;
    const d = Ml(l.visible);
    return bi({}, {
      inTriggerContext: !1
    }), Bl(() => l.visible, () => {
      l.visible && (d.value = !0);
    }, {
      flush: "post"
    }), () => {
      const {
        visible: a,
        getContainer: U,
        forceRender: V,
        destroyOnClose: h = !1,
        afterClose: W
      } = l;
      let Z = j(j(j({}, l), n), {
        ref: "_component",
        key: "dialog"
      });
      return U === !1 ? H(FU, Ql(Ql({}, Z), {}, {
        getOpenCount: () => 2
      }), e) : !V && h && !d.value ? null : H(ZZ, {
        autoLock: !0,
        visible: a,
        forceRender: V,
        getContainer: U
      }, {
        default: (s) => (Z = j(j(j({}, Z), s), {
          afterClose: () => {
            W?.(), d.value = !1;
          }
        }), H(FU, Z, e))
      });
    };
  }
});
function Kr(l) {
  const t = Ml(null), n = Nt(j({}, l)), e = Ml([]), d = (a) => {
    t.value === null && (e.value = [], t.value = Ol(() => {
      let U;
      e.value.forEach((V) => {
        U = j(j({}, U), V);
      }), j(n, U), t.value = null;
    })), e.value.push(a);
  };
  return ql(() => {
    t.value && Ol.cancel(t.value);
  }), [n, d];
}
function oU(l, t, n, e) {
  const d = t + n, a = (n - e) / 2;
  if (n > e) {
    if (t > 0)
      return {
        [l]: a
      };
    if (t < 0 && d < e)
      return {
        [l]: -a
      };
  } else if (t < 0 || d > e)
    return {
      [l]: t < 0 ? a : -a
    };
  return {};
}
function Hr(l, t, n, e) {
  const {
    width: d,
    height: a
  } = Er();
  let U = null;
  return l <= d && t <= a ? U = {
    x: 0,
    y: 0
  } : (l > d || t > a) && (U = j(j({}, oU("x", n, l, d)), oU("y", e, t, a))), U;
}
var Pr = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const VU = Symbol("previewGroupContext"), Oi = {
  provide: (l) => {
    nt(VU, l);
  },
  inject: () => fl(VU, {
    isPreviewGroup: bl(!1),
    previewUrls: Zl(() => /* @__PURE__ */ new Map()),
    setPreviewUrls: () => {
    },
    current: Ml(null),
    setCurrent: () => {
    },
    setShowPreview: () => {
    },
    setMousePosition: () => {
    },
    registerImage: null,
    rootClassName: ""
  })
}, Ar = () => ({
  previewPrefixCls: String,
  preview: {
    type: [Boolean, Object],
    default: !0
  },
  icons: {
    type: Object,
    default: () => ({})
  }
}), $r = pl({
  compatConfig: {
    MODE: 3
  },
  name: "PreviewGroup",
  inheritAttrs: !1,
  props: Ar(),
  setup(l, t) {
    let {
      slots: n
    } = t;
    const e = Zl(() => {
      const M = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0,
        current: 0
      };
      return typeof l.preview == "object" ? aF(l.preview, M) : M;
    }), d = Nt(/* @__PURE__ */ new Map()), a = Ml(), U = Zl(() => e.value.visible), V = Zl(() => e.value.getContainer), h = (M, S) => {
      var p, Y;
      (Y = (p = e.value).onVisibleChange) === null || Y === void 0 || Y.call(p, M, S);
    }, [W, Z] = Qd(!!U.value, {
      value: U,
      onChange: h
    }), s = Ml(null), o = Zl(() => U.value !== void 0), F = Zl(() => Array.from(d.keys())), N = Zl(() => F.value[e.value.current]), Q = Zl(() => new Map(Array.from(d).filter((M) => {
      let [, {
        canPreview: S
      }] = M;
      return !!S;
    }).map((M) => {
      let [S, {
        url: p
      }] = M;
      return [S, p];
    }))), u = function(M, S) {
      let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      d.set(M, {
        url: S,
        canPreview: p
      });
    }, i = (M) => {
      a.value = M;
    }, c = (M) => {
      s.value = M;
    }, R = function(M, S) {
      let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      const Y = () => {
        d.delete(M);
      };
      return d.set(M, {
        url: S,
        canPreview: p
      }), Y;
    }, m = (M) => {
      M?.stopPropagation(), Z(!1), c(null);
    };
    return Bl(N, (M) => {
      i(M);
    }, {
      immediate: !0,
      flush: "post"
    }), it(() => {
      W.value && o.value && i(N.value);
    }, {
      flush: "post"
    }), Oi.provide({
      isPreviewGroup: bl(!0),
      previewUrls: Q,
      setPreviewUrls: u,
      current: a,
      setCurrent: i,
      setShowPreview: Z,
      setMousePosition: c,
      registerImage: R
    }), () => {
      const M = Pr(e.value, []);
      return H(st, null, [n.default && n.default(), H(eF, Ql(Ql({}, M), {}, {
        "ria-hidden": !W.value,
        visible: W.value,
        prefixCls: l.previewPrefixCls,
        onClose: m,
        mousePosition: s.value,
        src: Q.value.get(a.value),
        icons: l.icons,
        getContainer: V.value
      }), null)]);
    };
  }
}), nF = $r, Vn = {
  x: 0,
  y: 0
}, qr = j(j({}, jd()), {
  src: String,
  alt: String,
  rootClassName: String,
  icons: {
    type: Object,
    default: () => ({})
  }
}), eF = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Preview",
  inheritAttrs: !1,
  props: qr,
  emits: ["close", "afterClose"],
  setup(l, t) {
    let {
      emit: n,
      attrs: e
    } = t;
    const {
      rotateLeft: d,
      rotateRight: a,
      zoomIn: U,
      zoomOut: V,
      close: h,
      left: W,
      right: Z,
      flipX: s,
      flipY: o
    } = Nt(l.icons), F = bl(1), N = bl(0), Q = Nt({
      x: 1,
      y: 1
    }), [u, i] = Kr(Vn), c = () => n("close"), R = bl(), m = Nt({
      originX: 0,
      originY: 0,
      deltaX: 0,
      deltaY: 0
    }), M = bl(!1), S = Oi.inject(), {
      previewUrls: p,
      current: Y,
      isPreviewGroup: k,
      setCurrent: L
    } = S, z = Zl(() => p.value.size), f = Zl(() => Array.from(p.value.keys())), K = Zl(() => f.value.indexOf(Y.value)), P = Zl(() => k.value ? p.value.get(Y.value) : l.src), w = Zl(() => k.value && z.value > 1), O = bl({
      wheelDirection: 0
    }), el = () => {
      F.value = 1, N.value = 0, Q.x = 1, Q.y = 1, i(Vn), n("afterClose");
    }, ll = (x) => {
      x ? F.value += 0.5 : F.value++, i(Vn);
    }, q = (x) => {
      F.value > 1 && (x ? F.value -= 0.5 : F.value--), i(Vn);
    }, _ = () => {
      N.value += 90;
    }, il = () => {
      N.value -= 90;
    }, dl = () => {
      Q.x = -Q.x;
    }, tl = () => {
      Q.y = -Q.y;
    }, al = (x) => {
      x.preventDefault(), x.stopPropagation(), K.value > 0 && L(f.value[K.value - 1]);
    }, Ul = (x) => {
      x.preventDefault(), x.stopPropagation(), K.value < z.value - 1 && L(f.value[K.value + 1]);
    }, cl = Xl({
      [`${l.prefixCls}-moving`]: M.value
    }), B = `${l.prefixCls}-operations-operation`, X = `${l.prefixCls}-operations-icon`, b = [{
      icon: h,
      onClick: c,
      type: "close"
    }, {
      icon: U,
      onClick: () => ll(),
      type: "zoomIn"
    }, {
      icon: V,
      onClick: () => q(),
      type: "zoomOut",
      disabled: Zl(() => F.value === 1)
    }, {
      icon: a,
      onClick: _,
      type: "rotateRight"
    }, {
      icon: d,
      onClick: il,
      type: "rotateLeft"
    }, {
      icon: s,
      onClick: dl,
      type: "flipX"
    }, {
      icon: o,
      onClick: tl,
      type: "flipY"
    }], r = () => {
      if (l.visible && M.value) {
        const x = R.value.offsetWidth * F.value, v = R.value.offsetHeight * F.value, {
          left: A,
          top: g
        } = tF(R.value), D = N.value % 180 !== 0;
        M.value = !1;
        const C = Hr(D ? v : x, D ? x : v, A, g);
        C && i(j({}, C));
      }
    }, G = (x) => {
      x.button === 0 && (x.preventDefault(), x.stopPropagation(), m.deltaX = x.pageX - u.x, m.deltaY = x.pageY - u.y, m.originX = u.x, m.originY = u.y, M.value = !0);
    }, J = (x) => {
      l.visible && M.value && i({
        x: x.pageX - m.deltaX,
        y: x.pageY - m.deltaY
      });
    }, T = (x) => {
      if (!l.visible)
        return;
      x.preventDefault();
      const v = x.deltaY;
      O.value = {
        wheelDirection: v
      };
    }, y = (x) => {
      !l.visible || !w.value || (x.preventDefault(), x.keyCode === ul.LEFT ? K.value > 0 && L(f.value[K.value - 1]) : x.keyCode === ul.RIGHT && K.value < z.value - 1 && L(f.value[K.value + 1]));
    }, I = () => {
      l.visible && (F.value !== 1 && (F.value = 1), (u.x !== Vn.x || u.y !== Vn.y) && i(Vn));
    };
    let E = () => {
    };
    return ql(() => {
      Bl([() => l.visible, M], () => {
        E();
        let x, v;
        const A = It(window, "mouseup", r, !1), g = It(window, "mousemove", J, !1), D = It(window, "wheel", T, {
          passive: !1
        }), C = It(window, "keydown", y, !1);
        try {
          window.top !== window.self && (x = It(window.top, "mouseup", r, !1), v = It(window.top, "mousemove", J, !1));
        } catch (nl) {
          ii(!1, `[vc-image] ${nl}`);
        }
        E = () => {
          A.remove(), g.remove(), D.remove(), C.remove(), x && x.remove(), v && v.remove();
        };
      }, {
        flush: "post",
        immediate: !0
      }), Bl([O], () => {
        const {
          wheelDirection: x
        } = O.value;
        x > 0 ? q(!0) : x < 0 && ll(!0);
      });
    }), Xn(() => {
      E();
    }), () => {
      const {
        visible: x,
        prefixCls: v,
        rootClassName: A
      } = l;
      return H(fr, Ql(Ql({}, e), {}, {
        transitionName: l.transitionName,
        maskTransitionName: l.maskTransitionName,
        closable: !1,
        keyboard: !0,
        prefixCls: v,
        onClose: c,
        afterClose: el,
        visible: x,
        wrapClassName: cl,
        rootClassName: A,
        getContainer: l.getContainer
      }), {
        default: () => [H("div", {
          class: [`${l.prefixCls}-operations-wrapper`, A]
        }, [H("ul", {
          class: `${l.prefixCls}-operations`
        }, [b.map((g) => {
          let {
            icon: D,
            onClick: C,
            type: nl,
            disabled: Fl
          } = g;
          return H("li", {
            class: Xl(B, {
              [`${l.prefixCls}-operations-operation-disabled`]: Fl && Fl?.value
            }),
            onClick: C,
            key: nl
          }, [rd(D, {
            class: X
          })]);
        })])]), H("div", {
          class: `${l.prefixCls}-img-wrapper`,
          style: {
            transform: `translate3d(${u.x}px, ${u.y}px, 0)`
          }
        }, [H("img", {
          onMousedown: G,
          onDblclick: I,
          ref: R,
          class: `${l.prefixCls}-img`,
          src: P.value,
          alt: l.alt,
          style: {
            transform: `scale3d(${Q.x * F.value}, ${Q.y * F.value}, 1) rotate(${N.value}deg)`
          }
        }, null)]), w.value && H("div", {
          class: Xl(`${l.prefixCls}-switch-left`, {
            [`${l.prefixCls}-switch-left-disabled`]: K.value <= 0
          }),
          onClick: al
        }, [W]), w.value && H("div", {
          class: Xl(`${l.prefixCls}-switch-right`, {
            [`${l.prefixCls}-switch-right-disabled`]: K.value >= z.value - 1
          }),
          onClick: Ul
        }, [Z])]
      });
    };
  }
});
var _r = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const dF = () => ({
  src: String,
  wrapperClassName: String,
  wrapperStyle: {
    type: Object,
    default: void 0
  },
  rootClassName: String,
  prefixCls: String,
  previewPrefixCls: String,
  previewMask: {
    type: [Boolean, Function],
    default: void 0
  },
  placeholder: ol.any,
  fallback: String,
  preview: {
    type: [Boolean, Object],
    default: !0
  },
  onClick: {
    type: Function
  },
  onError: {
    type: Function
  }
}), aF = (l, t) => {
  const n = j({}, l);
  return Object.keys(t).forEach((e) => {
    l[e] === void 0 && (n[e] = t[e]);
  }), n;
};
let l2 = 0;
const iF = pl({
  compatConfig: {
    MODE: 3
  },
  name: "VcImage",
  inheritAttrs: !1,
  props: dF(),
  emits: ["click", "error"],
  setup(l, t) {
    let {
      attrs: n,
      slots: e,
      emit: d
    } = t;
    const a = Zl(() => l.prefixCls), U = Zl(() => `${a.value}-preview`), V = Zl(() => {
      const ll = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0
      };
      return typeof l.preview == "object" ? aF(l.preview, ll) : ll;
    }), h = Zl(() => {
      var ll;
      return (ll = V.value.src) !== null && ll !== void 0 ? ll : l.src;
    }), W = Zl(() => l.placeholder && l.placeholder !== !0 || e.placeholder), Z = Zl(() => V.value.visible), s = Zl(() => V.value.getContainer), o = Zl(() => Z.value !== void 0), F = (ll, q) => {
      var _, il;
      (il = (_ = V.value).onVisibleChange) === null || il === void 0 || il.call(_, ll, q);
    }, [N, Q] = Qd(!!Z.value, {
      value: Z,
      onChange: F
    }), u = Ml(W.value ? "loading" : "normal");
    Bl(() => l.src, () => {
      u.value = W.value ? "loading" : "normal";
    });
    const i = Ml(null), c = Zl(() => u.value === "error"), R = Oi.inject(), {
      isPreviewGroup: m,
      setCurrent: M,
      setShowPreview: S,
      setMousePosition: p,
      registerImage: Y
    } = R, k = Ml(l2++), L = Zl(() => l.preview && !c.value), z = () => {
      u.value = "normal";
    }, f = (ll) => {
      u.value = "error", d("error", ll);
    }, K = (ll) => {
      if (!o.value) {
        const {
          left: q,
          top: _
        } = tF(ll.target);
        m.value ? (M(k.value), p({
          x: q,
          y: _
        })) : i.value = {
          x: q,
          y: _
        };
      }
      m.value ? S(!0) : Q(!0), d("click", ll);
    }, P = () => {
      Q(!1), o.value || (i.value = null);
    }, w = Ml(null);
    Bl(() => w, () => {
      u.value === "loading" && w.value.complete && (w.value.naturalWidth || w.value.naturalHeight) && z();
    });
    let O = () => {
    };
    ql(() => {
      Bl([h, L], () => {
        if (O(), !m.value)
          return () => {
          };
        O = Y(k.value, h.value, L.value), L.value || O();
      }, {
        flush: "post",
        immediate: !0
      });
    }), Xn(() => {
      O();
    });
    const el = (ll) => Rm(ll) ? ll + "px" : ll;
    return () => {
      const {
        prefixCls: ll,
        wrapperClassName: q,
        fallback: _,
        src: il,
        placeholder: dl,
        wrapperStyle: tl,
        rootClassName: al
      } = l, {
        width: Ul,
        height: cl,
        crossorigin: B,
        decoding: X,
        alt: b,
        sizes: r,
        srcset: G,
        usemap: J,
        class: T,
        style: y
      } = n, I = V.value, {
        icons: E,
        maskClassName: x
      } = I, v = _r(I, ["icons", "maskClassName"]), A = Xl(ll, q, al, {
        [`${ll}-error`]: c.value
      }), g = c.value && _ ? _ : h.value, D = {
        crossorigin: B,
        decoding: X,
        alt: b,
        sizes: r,
        srcset: G,
        usemap: J,
        width: Ul,
        height: cl,
        class: Xl(`${ll}-img`, {
          [`${ll}-img-placeholder`]: dl === !0
        }, T),
        style: j({
          height: el(cl)
        }, y)
      };
      return H(st, null, [H("div", {
        class: A,
        onClick: L.value ? K : (C) => {
          d("click", C);
        },
        style: j({
          width: el(Ul),
          height: el(cl)
        }, tl)
      }, [H("img", Ql(Ql(Ql({}, D), c.value && _ ? {
        src: _
      } : {
        onLoad: z,
        onError: f,
        src: il
      }), {}, {
        ref: w
      }), null), u.value === "loading" && H("div", {
        "aria-hidden": "true",
        class: `${ll}-placeholder`
      }, [dl || e.placeholder && e.placeholder()]), e.previewMask && L.value && H("div", {
        class: [`${ll}-mask`, x]
      }, [e.previewMask()])]), !m.value && L.value && H(eF, Ql(Ql({}, v), {}, {
        "aria-hidden": !N.value,
        visible: N.value,
        prefixCls: U.value,
        onClose: P,
        mousePosition: i.value,
        src: g,
        alt: b,
        getContainer: s.value,
        icons: E,
        rootClassName: al
      }), null)]);
    };
  }
});
iF.PreviewGroup = nF;
const t2 = iF;
var n2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { tag: "path", attrs: { d: "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, name: "rotate-left", theme: "outlined" };
function QU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      e2(l, d, n[d]);
    });
  }
  return l;
}
function e2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var vi = function(t, n) {
  var e = QU({}, t, n.attrs);
  return H($l, QU({}, e, {
    icon: n2
  }), null);
};
vi.displayName = "RotateLeftOutlined";
vi.inheritAttrs = !1;
var d2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { tag: "path", attrs: { d: "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, name: "rotate-right", theme: "outlined" };
function WU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      a2(l, d, n[d]);
    });
  }
  return l;
}
function a2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var fi = function(t, n) {
  var e = WU({}, t, n.attrs);
  return H($l, WU({}, e, {
    icon: d2
  }), null);
};
fi.displayName = "RotateRightOutlined";
fi.inheritAttrs = !1;
var i2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-in", theme: "outlined" };
function hU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      s2(l, d, n[d]);
    });
  }
  return l;
}
function s2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Ki = function(t, n) {
  var e = hU({}, t, n.attrs);
  return H($l, hU({}, e, {
    icon: i2
  }), null);
};
Ki.displayName = "ZoomInOutlined";
Ki.inheritAttrs = !1;
var c2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-out", theme: "outlined" };
function RU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      U2(l, d, n[d]);
    });
  }
  return l;
}
function U2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Hi = function(t, n) {
  var e = RU({}, t, n.attrs);
  return H($l, RU({}, e, {
    icon: c2
  }), null);
};
Hi.displayName = "ZoomOutOutlined";
Hi.inheritAttrs = !1;
var Z2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "swap", theme: "outlined" };
function NU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      F2(l, d, n[d]);
    });
  }
  return l;
}
function F2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Nd = function(t, n) {
  var e = NU({}, t, n.attrs);
  return H($l, NU({}, e, {
    icon: Z2
  }), null);
};
Nd.displayName = "SwapOutlined";
Nd.inheritAttrs = !1;
function bU(l) {
  return {
    position: l,
    top: 0,
    insetInlineEnd: 0,
    bottom: 0,
    insetInlineStart: 0
  };
}
const o2 = (l) => {
  const {
    componentCls: t
  } = l;
  return [{
    [`${t}-root`]: {
      [`${t}${l.antCls}-zoom-enter, ${t}${l.antCls}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: l.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      [`${t}${l.antCls}-zoom-leave ${t}-content`]: {
        pointerEvents: "none"
      },
      [`${t}-mask`]: j(j({}, bU("fixed")), {
        zIndex: l.zIndexPopupBase,
        height: "100%",
        backgroundColor: l.colorBgMask,
        [`${t}-hidden`]: {
          display: "none"
        }
      }),
      [`${t}-wrap`]: j(j({}, bU("fixed")), {
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${t}-root`]: LZ(l)
  }];
}, ni = (l) => ({
  position: l || "absolute",
  inset: 0
}), V2 = (l) => {
  const {
    iconCls: t,
    motionDurationSlow: n,
    paddingXXS: e,
    marginXXS: d,
    prefixCls: a
  } = l;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "#fff",
    background: new et("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${n}`,
    [`.${a}-mask-info`]: j(j({}, Ud), {
      padding: `0 ${e}px`,
      [t]: {
        marginInlineEnd: d,
        svg: {
          verticalAlign: "baseline"
        }
      }
    })
  };
}, Q2 = (l) => {
  const {
    previewCls: t,
    modalMaskBg: n,
    paddingSM: e,
    previewOperationColorDisabled: d,
    motionDurationSlow: a
  } = l, U = new et(n).setAlpha(0.1), V = U.clone().setAlpha(0.2);
  return {
    [`${t}-operations`]: j(j({}, sn(l)), {
      display: "flex",
      flexDirection: "row-reverse",
      alignItems: "center",
      color: l.previewOperationColor,
      listStyle: "none",
      background: U.toRgbString(),
      pointerEvents: "auto",
      "&-operation": {
        marginInlineStart: e,
        padding: e,
        cursor: "pointer",
        transition: `all ${a}`,
        userSelect: "none",
        "&:hover": {
          background: V.toRgbString()
        },
        "&-disabled": {
          color: d,
          pointerEvents: "none"
        },
        "&:last-of-type": {
          marginInlineStart: 0
        }
      },
      "&-progress": {
        position: "absolute",
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%)"
      },
      "&-icon": {
        fontSize: l.previewOperationSize
      }
    })
  };
}, W2 = (l) => {
  const {
    modalMaskBg: t,
    iconCls: n,
    previewOperationColorDisabled: e,
    previewCls: d,
    zIndexPopup: a,
    motionDurationSlow: U
  } = l, V = new et(t).setAlpha(0.1), h = V.clone().setAlpha(0.2);
  return {
    [`${d}-switch-left, ${d}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: a + 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: l.imagePreviewSwitchSize,
      height: l.imagePreviewSwitchSize,
      marginTop: -l.imagePreviewSwitchSize / 2,
      color: l.previewOperationColor,
      background: V.toRgbString(),
      borderRadius: "50%",
      transform: "translateY(-50%)",
      cursor: "pointer",
      transition: `all ${U}`,
      pointerEvents: "auto",
      userSelect: "none",
      "&:hover": {
        background: h.toRgbString()
      },
      "&-disabled": {
        "&, &:hover": {
          color: e,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${n}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${n}`]: {
        fontSize: l.previewOperationSize
      }
    },
    [`${d}-switch-left`]: {
      insetInlineStart: l.marginSM
    },
    [`${d}-switch-right`]: {
      insetInlineEnd: l.marginSM
    }
  };
}, h2 = (l) => {
  const {
    motionEaseOut: t,
    previewCls: n,
    motionDurationSlow: e,
    componentCls: d
  } = l;
  return [
    {
      [`${d}-preview-root`]: {
        [n]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${n}-body`]: j(j({}, ni()), {
          overflow: "hidden"
        }),
        [`${n}-img`]: {
          maxWidth: "100%",
          maxHeight: "100%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${e} ${t} 0s`,
          userSelect: "none",
          pointerEvents: "auto",
          "&-wrapper": j(j({}, ni()), {
            transition: `transform ${e} ${t} 0s`,
            // https://github.com/ant-design/ant-design/issues/39913
            // TailwindCSS will reset img default style.
            // Let's set back.
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          })
        },
        [`${n}-moving`]: {
          [`${n}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    // Override
    {
      [`${d}-preview-root`]: {
        [`${n}-wrap`]: {
          zIndex: l.zIndexPopup
        }
      }
    },
    // Preview operations & switch
    {
      [`${d}-preview-operations-wrapper`]: {
        position: "fixed",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        zIndex: l.zIndexPopup + 1,
        width: "100%"
      },
      "&": [Q2(l), W2(l)]
    }
  ];
}, R2 = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    // ============================== image ==============================
    [t]: {
      position: "relative",
      display: "inline-block",
      [`${t}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${t}-img-placeholder`]: {
        backgroundColor: l.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${t}-mask`]: j({}, V2(l)),
      [`${t}-mask:hover`]: {
        opacity: 1
      },
      [`${t}-placeholder`]: j({}, ni())
    }
  };
}, N2 = (l) => {
  const {
    previewCls: t
  } = l;
  return {
    [`${t}-root`]: wZ(l, "zoom"),
    "&": LZ(l, !0)
  };
}, sF = $t("Image", (l) => {
  const t = `${l.componentCls}-preview`, n = tt(l, {
    previewCls: t,
    modalMaskBg: new et("#000").setAlpha(0.45).toRgbString(),
    imagePreviewSwitchSize: l.controlHeightLG
  });
  return [R2(n), h2(n), o2(tt(n, {
    componentCls: t
  })), N2(n)];
}, (l) => ({
  zIndexPopup: l.zIndexPopupBase + 80,
  previewOperationColor: new et(l.colorTextLightSolid).toRgbString(),
  previewOperationColorDisabled: new et(l.colorTextLightSolid).setAlpha(0.25).toRgbString(),
  previewOperationSize: l.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
})), cF = {
  rotateLeft: H(vi, null, null),
  rotateRight: H(fi, null, null),
  zoomIn: H(Ki, null, null),
  zoomOut: H(Hi, null, null),
  close: H(Id, null, null),
  left: H(Te, null, null),
  right: H(Se, null, null),
  flipX: H(Nd, null, null),
  flipY: H(Nd, {
    rotate: 90
  }, null)
}, b2 = () => ({
  previewPrefixCls: String,
  preview: kt()
}), m2 = pl({
  compatConfig: {
    MODE: 3
  },
  name: "AImagePreviewGroup",
  inheritAttrs: !1,
  props: b2(),
  setup(l, t) {
    let {
      attrs: n,
      slots: e
    } = t;
    const {
      prefixCls: d,
      rootPrefixCls: a
    } = ht("image", l), U = Zl(() => `${d.value}-preview`), [V, h] = sF(d), W = Zl(() => {
      const {
        preview: Z
      } = l;
      if (Z === !1)
        return Z;
      const s = typeof Z == "object" ? Z : {};
      return j(j({}, s), {
        rootClassName: h.value,
        transitionName: An(a.value, "zoom", s.transitionName),
        maskTransitionName: An(a.value, "fade", s.maskTransitionName)
      });
    });
    return () => V(H(nF, Ql(Ql({}, j(j({}, n), l)), {}, {
      preview: W.value,
      icons: cF,
      previewPrefixCls: U.value
    }), e));
  }
}), u2 = m2, Rn = pl({
  name: "AImage",
  inheritAttrs: !1,
  props: dF(),
  setup(l, t) {
    let {
      slots: n,
      attrs: e
    } = t;
    const {
      prefixCls: d,
      rootPrefixCls: a,
      configProvider: U
    } = ht("image", l), [V, h] = sF(d), W = Zl(() => {
      const {
        preview: Z
      } = l;
      if (Z === !1)
        return Z;
      const s = typeof Z == "object" ? Z : {};
      return j(j({
        icons: cF
      }, s), {
        transitionName: An(a.value, "zoom", s.transitionName),
        maskTransitionName: An(a.value, "fade", s.maskTransitionName)
      });
    });
    return () => {
      var Z, s;
      const o = ((s = (Z = U.locale) === null || Z === void 0 ? void 0 : Z.value) === null || s === void 0 ? void 0 : s.Image) || dd.Image, F = () => H("div", {
        class: `${d.value}-mask-info`
      }, [H(gd, null, null), o?.preview]), {
        previewMask: N = n.previewMask || F
      } = l;
      return V(H(t2, Ql(Ql({}, j(j(j({}, e), l), {
        prefixCls: d.value
      })), {}, {
        preview: W.value,
        rootClassName: Xl(l.rootClassName, h.value)
      }), j(j({}, n), {
        previewMask: typeof N == "function" ? N : null
      })));
    };
  }
});
Rn.PreviewGroup = u2;
Rn.install = function(l) {
  return l.component(Rn.name, Rn), l.component(Rn.PreviewGroup.name, Rn.PreviewGroup), l;
};
var r2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, name: "double-left", theme: "outlined" };
function mU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      M2(l, d, n[d]);
    });
  }
  return l;
}
function M2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var bd = function(t, n) {
  var e = mU({}, t, n.attrs);
  return H($l, mU({}, e, {
    icon: r2
  }), null);
};
bd.displayName = "DoubleLeftOutlined";
bd.inheritAttrs = !1;
var p2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, name: "double-right", theme: "outlined" };
function uU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      S2(l, d, n[d]);
    });
  }
  return l;
}
function S2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var md = function(t, n) {
  var e = uU({}, t, n.attrs);
  return H($l, uU({}, e, {
    icon: p2
  }), null);
};
md.displayName = "DoubleRightOutlined";
md.inheritAttrs = !1;
const T2 = pl({
  name: "MiniSelect",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: ki(),
  Option: Wd.Option,
  setup(l, t) {
    let {
      attrs: n,
      slots: e
    } = t;
    return () => {
      const d = j(j(j({}, l), {
        size: "small"
      }), n);
      return H(Wd, d, e);
    };
  }
}), G2 = pl({
  name: "MiddleSelect",
  inheritAttrs: !1,
  props: ki(),
  Option: Wd.Option,
  setup(l, t) {
    let {
      attrs: n,
      slots: e
    } = t;
    return () => {
      const d = j(j(j({}, l), {
        size: "middle"
      }), n);
      return H(Wd, d, e);
    };
  }
}), Qn = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Pager",
  inheritAttrs: !1,
  props: {
    rootPrefixCls: String,
    page: Number,
    active: {
      type: Boolean,
      default: void 0
    },
    last: {
      type: Boolean,
      default: void 0
    },
    locale: ol.object,
    showTitle: {
      type: Boolean,
      default: void 0
    },
    itemRender: {
      type: Function,
      default: () => {
      }
    },
    onClick: {
      type: Function
    },
    onKeypress: {
      type: Function
    }
  },
  eimt: ["click", "keypress"],
  setup(l, t) {
    let {
      emit: n,
      attrs: e
    } = t;
    const d = () => {
      n("click", l.page);
    }, a = (U) => {
      n("keypress", U, d, l.page);
    };
    return () => {
      const {
        showTitle: U,
        page: V,
        itemRender: h
      } = l, {
        class: W,
        style: Z
      } = e, s = `${l.rootPrefixCls}-item`, o = Xl(s, `${s}-${l.page}`, {
        [`${s}-active`]: l.active,
        [`${s}-disabled`]: !l.page
      }, W);
      return H("li", {
        onClick: d,
        onKeypress: a,
        title: U ? String(V) : null,
        tabindex: "0",
        class: o,
        style: Z
      }, [h({
        page: V,
        type: "page",
        originalElement: H("a", {
          rel: "nofollow"
        }, [V])
      })]);
    };
  }
}), Wn = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
}, J2 = pl({
  compatConfig: {
    MODE: 3
  },
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    changeSize: Function,
    quickGo: Function,
    selectComponentClass: ol.any,
    current: Number,
    pageSizeOptions: ol.array.def(["10", "20", "50", "100"]),
    pageSize: Number,
    buildOptionText: Function,
    locale: ol.object,
    rootPrefixCls: String,
    selectPrefixCls: String,
    goButton: ol.any
  },
  setup(l) {
    const t = Ml(""), n = Zl(() => !t.value || isNaN(t.value) ? void 0 : Number(t.value)), e = (h) => `${h.value} ${l.locale.items_per_page}`, d = (h) => {
      const {
        value: W
      } = h.target;
      t.value !== W && (t.value = W);
    }, a = (h) => {
      const {
        goButton: W,
        quickGo: Z,
        rootPrefixCls: s
      } = l;
      if (!(W || t.value === ""))
        if (h.relatedTarget && (h.relatedTarget.className.indexOf(`${s}-item-link`) >= 0 || h.relatedTarget.className.indexOf(`${s}-item`) >= 0)) {
          t.value = "";
          return;
        } else
          Z(n.value), t.value = "";
    }, U = (h) => {
      t.value !== "" && (h.keyCode === Wn.ENTER || h.type === "click") && (l.quickGo(n.value), t.value = "");
    }, V = Zl(() => {
      const {
        pageSize: h,
        pageSizeOptions: W
      } = l;
      return W.some((Z) => Z.toString() === h.toString()) ? W : W.concat([h.toString()]).sort((Z, s) => {
        const o = isNaN(Number(Z)) ? 0 : Number(Z), F = isNaN(Number(s)) ? 0 : Number(s);
        return o - F;
      });
    });
    return () => {
      const {
        rootPrefixCls: h,
        locale: W,
        changeSize: Z,
        quickGo: s,
        goButton: o,
        selectComponentClass: F,
        selectPrefixCls: N,
        pageSize: Q,
        disabled: u
      } = l, i = `${h}-options`;
      let c = null, R = null, m = null;
      if (!Z && !s)
        return null;
      if (Z && F) {
        const M = l.buildOptionText || e, S = V.value.map((p, Y) => H(F.Option, {
          key: Y,
          value: p
        }, {
          default: () => [M({
            value: p
          })]
        }));
        c = H(F, {
          disabled: u,
          prefixCls: N,
          showSearch: !1,
          class: `${i}-size-changer`,
          optionLabelProp: "children",
          value: (Q || V.value[0]).toString(),
          onChange: (p) => Z(Number(p)),
          getPopupContainer: (p) => p.parentNode
        }, {
          default: () => [S]
        });
      }
      return s && (o && (m = typeof o == "boolean" ? H("button", {
        type: "button",
        onClick: U,
        onKeyup: U,
        disabled: u,
        class: `${i}-quick-jumper-button`
      }, [W.jump_to_confirm]) : H("span", {
        onClick: U,
        onKeyup: U
      }, [o])), R = H("div", {
        class: `${i}-quick-jumper`
      }, [W.jump_to, H(ye, {
        disabled: u,
        type: "text",
        value: t.value,
        onInput: d,
        onChange: d,
        onKeyup: U,
        onBlur: a
      }, null), W.page, m])), H("li", {
        class: `${i}`
      }, [c, R]);
    };
  }
}), X2 = {
  // Options.jsx
  items_per_page: "条/页",
  jump_to: "跳至",
  jump_to_confirm: "确定",
  page: "页",
  // Pagination.jsx
  prev_page: "上一页",
  next_page: "下一页",
  prev_5: "向前 5 页",
  next_5: "向后 5 页",
  prev_3: "向前 3 页",
  next_3: "向后 3 页"
};
var Y2 = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
function y2(l) {
  return typeof l == "number" && isFinite(l) && Math.floor(l) === l;
}
function B2(l) {
  let {
    originalElement: t
  } = l;
  return t;
}
function vt(l, t, n) {
  const e = typeof l > "u" ? t.statePageSize : l;
  return Math.floor((n.total - 1) / e) + 1;
}
const z2 = pl({
  compatConfig: {
    MODE: 3
  },
  name: "Pagination",
  mixins: [cZ],
  inheritAttrs: !1,
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: ol.string.def("rc-pagination"),
    selectPrefixCls: ol.string.def("rc-select"),
    current: Number,
    defaultCurrent: ol.number.def(1),
    total: ol.number.def(0),
    pageSize: Number,
    defaultPageSize: ol.number.def(10),
    hideOnSinglePage: {
      type: Boolean,
      default: !1
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    showLessItems: {
      type: Boolean,
      default: !1
    },
    // showSizeChange: PropTypes.func.def(noop),
    selectComponentClass: ol.any,
    showPrevNextJumpers: {
      type: Boolean,
      default: !0
    },
    showQuickJumper: ol.oneOfType([ol.looseBool, ol.object]).def(!1),
    showTitle: {
      type: Boolean,
      default: !0
    },
    pageSizeOptions: ol.arrayOf(ol.oneOfType([ol.number, ol.string])),
    buildOptionText: Function,
    showTotal: Function,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: ol.object.def(X2),
    itemRender: ol.func.def(B2),
    prevIcon: ol.any,
    nextIcon: ol.any,
    jumpPrevIcon: ol.any,
    jumpNextIcon: ol.any,
    totalBoundaryShowSizeChanger: ol.number.def(50)
  },
  data() {
    const l = this.$props;
    let t = $a([this.current, this.defaultCurrent]);
    const n = $a([this.pageSize, this.defaultPageSize]);
    return t = Math.min(t, vt(n, void 0, l)), {
      stateCurrent: t,
      stateCurrentInputValue: t,
      statePageSize: n
    };
  },
  watch: {
    current(l) {
      this.setState({
        stateCurrent: l,
        stateCurrentInputValue: l
      });
    },
    pageSize(l) {
      const t = {};
      let n = this.stateCurrent;
      const e = vt(l, this.$data, this.$props);
      n = n > e ? e : n, xn(this, "current") || (t.stateCurrent = n, t.stateCurrentInputValue = n), t.statePageSize = l, this.setState(t);
    },
    stateCurrent(l, t) {
      this.$nextTick(() => {
        if (this.$refs.paginationNode) {
          const n = this.$refs.paginationNode.querySelector(`.${this.prefixCls}-item-${t}`);
          n && document.activeElement === n && n.blur();
        }
      });
    },
    total() {
      const l = {}, t = vt(this.pageSize, this.$data, this.$props);
      if (xn(this, "current")) {
        const n = Math.min(this.current, t);
        l.stateCurrent = n, l.stateCurrentInputValue = n;
      } else {
        let n = this.stateCurrent;
        n === 0 && t > 0 ? n = 1 : n = Math.min(this.stateCurrent, t), l.stateCurrent = n;
      }
      this.setState(l);
    }
  },
  methods: {
    getJumpPrevPage() {
      return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
    },
    getJumpNextPage() {
      return Math.min(vt(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ? 3 : 5));
    },
    getItemIcon(l, t) {
      const {
        prefixCls: n
      } = this.$props;
      return OU(this, l, this.$props) || H("button", {
        type: "button",
        "aria-label": t,
        class: `${n}-item-link`
      }, null);
    },
    getValidValue(l) {
      const t = l.target.value, n = vt(void 0, this.$data, this.$props), {
        stateCurrentInputValue: e
      } = this.$data;
      let d;
      return t === "" ? d = t : isNaN(Number(t)) ? d = e : t >= n ? d = n : d = Number(t), d;
    },
    isValid(l) {
      return y2(l) && l !== this.stateCurrent;
    },
    shouldDisplayQuickJumper() {
      const {
        showQuickJumper: l,
        pageSize: t,
        total: n
      } = this.$props;
      return n <= t ? !1 : l;
    },
    // calculatePage (p) {
    //   let pageSize = p
    //   if (typeof pageSize === 'undefined') {
    //     pageSize = this.statePageSize
    //   }
    //   return Math.floor((this.total - 1) / pageSize) + 1
    // },
    handleKeyDown(l) {
      (l.keyCode === Wn.ARROW_UP || l.keyCode === Wn.ARROW_DOWN) && l.preventDefault();
    },
    handleKeyUp(l) {
      const t = this.getValidValue(l), n = this.stateCurrentInputValue;
      t !== n && this.setState({
        stateCurrentInputValue: t
      }), l.keyCode === Wn.ENTER ? this.handleChange(t) : l.keyCode === Wn.ARROW_UP ? this.handleChange(t - 1) : l.keyCode === Wn.ARROW_DOWN && this.handleChange(t + 1);
    },
    changePageSize(l) {
      let t = this.stateCurrent;
      const n = t, e = vt(l, this.$data, this.$props);
      t = t > e ? e : t, e === 0 && (t = this.stateCurrent), typeof l == "number" && (xn(this, "pageSize") || this.setState({
        statePageSize: l
      }), xn(this, "current") || this.setState({
        stateCurrent: t,
        stateCurrentInputValue: t
      })), this.__emit("update:pageSize", l), t !== n && this.__emit("update:current", t), this.__emit("showSizeChange", t, l), this.__emit("change", t, l);
    },
    handleChange(l) {
      const {
        disabled: t
      } = this.$props;
      let n = l;
      if (this.isValid(n) && !t) {
        const e = vt(void 0, this.$data, this.$props);
        return n > e ? n = e : n < 1 && (n = 1), xn(this, "current") || this.setState({
          stateCurrent: n,
          stateCurrentInputValue: n
        }), this.__emit("update:current", n), this.__emit("change", n, this.statePageSize), n;
      }
      return this.stateCurrent;
    },
    prev() {
      this.hasPrev() && this.handleChange(this.stateCurrent - 1);
    },
    next() {
      this.hasNext() && this.handleChange(this.stateCurrent + 1);
    },
    jumpPrev() {
      this.handleChange(this.getJumpPrevPage());
    },
    jumpNext() {
      this.handleChange(this.getJumpNextPage());
    },
    hasPrev() {
      return this.stateCurrent > 1;
    },
    hasNext() {
      return this.stateCurrent < vt(void 0, this.$data, this.$props);
    },
    getShowSizeChanger() {
      const {
        showSizeChanger: l,
        total: t,
        totalBoundaryShowSizeChanger: n
      } = this.$props;
      return typeof l < "u" ? l : t > n;
    },
    runIfEnter(l, t) {
      if (l.key === "Enter" || l.charCode === 13) {
        l.preventDefault();
        for (var n = arguments.length, e = new Array(n > 2 ? n - 2 : 0), d = 2; d < n; d++)
          e[d - 2] = arguments[d];
        t(...e);
      }
    },
    runIfEnterPrev(l) {
      this.runIfEnter(l, this.prev);
    },
    runIfEnterNext(l) {
      this.runIfEnter(l, this.next);
    },
    runIfEnterJumpPrev(l) {
      this.runIfEnter(l, this.jumpPrev);
    },
    runIfEnterJumpNext(l) {
      this.runIfEnter(l, this.jumpNext);
    },
    handleGoTO(l) {
      (l.keyCode === Wn.ENTER || l.type === "click") && this.handleChange(this.stateCurrentInputValue);
    },
    renderPrev(l) {
      const {
        itemRender: t
      } = this.$props, n = t({
        page: l,
        type: "prev",
        originalElement: this.getItemIcon("prevIcon", "prev page")
      }), e = !this.hasPrev();
      return Pt(n) ? bt(n, e ? {
        disabled: e
      } : {}) : n;
    },
    renderNext(l) {
      const {
        itemRender: t
      } = this.$props, n = t({
        page: l,
        type: "next",
        originalElement: this.getItemIcon("nextIcon", "next page")
      }), e = !this.hasNext();
      return Pt(n) ? bt(n, e ? {
        disabled: e
      } : {}) : n;
    }
  },
  render() {
    const {
      prefixCls: l,
      disabled: t,
      hideOnSinglePage: n,
      total: e,
      locale: d,
      showQuickJumper: a,
      showLessItems: U,
      showTitle: V,
      showTotal: h,
      simple: W,
      itemRender: Z,
      showPrevNextJumpers: s,
      jumpPrevIcon: o,
      jumpNextIcon: F,
      selectComponentClass: N,
      selectPrefixCls: Q,
      pageSizeOptions: u
    } = this.$props, {
      stateCurrent: i,
      statePageSize: c
    } = this, R = jU(this.$attrs).extraAttrs, {
      class: m
    } = R, M = Y2(R, ["class"]);
    if (n === !0 && this.total <= c)
      return null;
    const S = vt(void 0, this.$data, this.$props), p = [];
    let Y = null, k = null, L = null, z = null, f = null;
    const K = a && a.goButton, P = U ? 1 : 2, w = i - 1 > 0 ? i - 1 : 0, O = i + 1 < S ? i + 1 : S, el = this.hasPrev(), ll = this.hasNext();
    if (W)
      return K && (typeof K == "boolean" ? f = H("button", {
        type: "button",
        onClick: this.handleGoTO,
        onKeyup: this.handleGoTO
      }, [d.jump_to_confirm]) : f = H("span", {
        onClick: this.handleGoTO,
        onKeyup: this.handleGoTO
      }, [K]), f = H("li", {
        title: V ? `${d.jump_to}${i}/${S}` : null,
        class: `${l}-simple-pager`
      }, [f])), H("ul", Ql({
        class: Xl(`${l} ${l}-simple`, {
          [`${l}-disabled`]: t
        }, m)
      }, M), [H("li", {
        title: V ? d.prev_page : null,
        onClick: this.prev,
        tabindex: el ? 0 : null,
        onKeypress: this.runIfEnterPrev,
        class: Xl(`${l}-prev`, {
          [`${l}-disabled`]: !el
        }),
        "aria-disabled": !el
      }, [this.renderPrev(w)]), H("li", {
        title: V ? `${i}/${S}` : null,
        class: `${l}-simple-pager`
      }, [H(ye, {
        type: "text",
        value: this.stateCurrentInputValue,
        disabled: t,
        onKeydown: this.handleKeyDown,
        onKeyup: this.handleKeyUp,
        onInput: this.handleKeyUp,
        onChange: this.handleKeyUp,
        size: "3"
      }, null), H("span", {
        class: `${l}-slash`
      }, [Ve("／")]), S]), H("li", {
        title: V ? d.next_page : null,
        onClick: this.next,
        tabindex: ll ? 0 : null,
        onKeypress: this.runIfEnterNext,
        class: Xl(`${l}-next`, {
          [`${l}-disabled`]: !ll
        }),
        "aria-disabled": !ll
      }, [this.renderNext(O)]), f]);
    if (S <= 3 + P * 2) {
      const tl = {
        locale: d,
        rootPrefixCls: l,
        showTitle: V,
        itemRender: Z,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter
      };
      S || p.push(H(Qn, Ql(Ql({}, tl), {}, {
        key: "noPager",
        page: 1,
        class: `${l}-item-disabled`
      }), null));
      for (let al = 1; al <= S; al += 1) {
        const Ul = i === al;
        p.push(H(Qn, Ql(Ql({}, tl), {}, {
          key: al,
          page: al,
          active: Ul
        }), null));
      }
    } else {
      const tl = U ? d.prev_3 : d.prev_5, al = U ? d.next_3 : d.next_5;
      s && (Y = H("li", {
        title: this.showTitle ? tl : null,
        key: "prev",
        onClick: this.jumpPrev,
        tabindex: "0",
        onKeypress: this.runIfEnterJumpPrev,
        class: Xl(`${l}-jump-prev`, {
          [`${l}-jump-prev-custom-icon`]: !!o
        })
      }, [Z({
        page: this.getJumpPrevPage(),
        type: "jump-prev",
        originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
      })]), k = H("li", {
        title: this.showTitle ? al : null,
        key: "next",
        tabindex: "0",
        onClick: this.jumpNext,
        onKeypress: this.runIfEnterJumpNext,
        class: Xl(`${l}-jump-next`, {
          [`${l}-jump-next-custom-icon`]: !!F
        })
      }, [Z({
        page: this.getJumpNextPage(),
        type: "jump-next",
        originalElement: this.getItemIcon("jumpNextIcon", "next page")
      })])), z = H(Qn, {
        locale: d,
        last: !0,
        rootPrefixCls: l,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: S,
        page: S,
        active: !1,
        showTitle: V,
        itemRender: Z
      }, null), L = H(Qn, {
        locale: d,
        rootPrefixCls: l,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: 1,
        page: 1,
        active: !1,
        showTitle: V,
        itemRender: Z
      }, null);
      let Ul = Math.max(1, i - P), cl = Math.min(i + P, S);
      i - 1 <= P && (cl = 1 + P * 2), S - i <= P && (Ul = S - P * 2);
      for (let B = Ul; B <= cl; B += 1) {
        const X = i === B;
        p.push(H(Qn, {
          locale: d,
          rootPrefixCls: l,
          onClick: this.handleChange,
          onKeypress: this.runIfEnter,
          key: B,
          page: B,
          active: X,
          showTitle: V,
          itemRender: Z
        }, null));
      }
      i - 1 >= P * 2 && i !== 3 && (p[0] = H(Qn, {
        locale: d,
        rootPrefixCls: l,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: Ul,
        page: Ul,
        class: `${l}-item-after-jump-prev`,
        active: !1,
        showTitle: this.showTitle,
        itemRender: Z
      }, null), p.unshift(Y)), S - i >= P * 2 && i !== S - 2 && (p[p.length - 1] = H(Qn, {
        locale: d,
        rootPrefixCls: l,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: cl,
        page: cl,
        class: `${l}-item-before-jump-next`,
        active: !1,
        showTitle: this.showTitle,
        itemRender: Z
      }, null), p.push(k)), Ul !== 1 && p.unshift(L), cl !== S && p.push(z);
    }
    let q = null;
    h && (q = H("li", {
      class: `${l}-total-text`
    }, [h(e, [e === 0 ? 0 : (i - 1) * c + 1, i * c > e ? e : i * c])]));
    const _ = !el || !S, il = !ll || !S, dl = this.buildOptionText || this.$slots.buildOptionText;
    return H("ul", Ql(Ql({
      unselectable: "on",
      ref: "paginationNode"
    }, M), {}, {
      class: Xl({
        [`${l}`]: !0,
        [`${l}-disabled`]: t
      }, m)
    }), [q, H("li", {
      title: V ? d.prev_page : null,
      onClick: this.prev,
      tabindex: _ ? null : 0,
      onKeypress: this.runIfEnterPrev,
      class: Xl(`${l}-prev`, {
        [`${l}-disabled`]: _
      }),
      "aria-disabled": _
    }, [this.renderPrev(w)]), p, H("li", {
      title: V ? d.next_page : null,
      onClick: this.next,
      tabindex: il ? null : 0,
      onKeypress: this.runIfEnterNext,
      class: Xl(`${l}-next`, {
        [`${l}-disabled`]: il
      }),
      "aria-disabled": il
    }, [this.renderNext(O)]), H(J2, {
      disabled: t,
      locale: d,
      rootPrefixCls: l,
      selectComponentClass: N,
      selectPrefixCls: Q,
      changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
      current: i,
      pageSize: c,
      pageSizeOptions: u,
      buildOptionText: dl || null,
      quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
      goButton: K
    }, null)]);
  }
}), L2 = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [`${t}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${t}-item-link`]: {
          color: l.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${t}-item-link`]: {
          color: l.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${t}-disabled`]: {
      cursor: "not-allowed",
      [`&${t}-mini`]: {
        [`
          &:hover ${t}-item:not(${t}-item-active),
          &:active ${t}-item:not(${t}-item-active),
          &:hover ${t}-item-link,
          &:active ${t}-item-link
        `]: {
          backgroundColor: "transparent"
        }
      },
      [`${t}-item`]: {
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: l.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: l.colorBorder,
          backgroundColor: l.paginationItemDisabledBgActive,
          "&:hover, &:active": {
            backgroundColor: l.paginationItemDisabledBgActive
          },
          a: {
            color: l.paginationItemDisabledColorActive
          }
        }
      },
      [`${t}-item-link`]: {
        color: l.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${t}-simple&`]: {
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      },
      [`${t}-simple-pager`]: {
        color: l.colorTextDisabled
      },
      [`${t}-jump-prev, ${t}-jump-next`]: {
        [`${t}-item-link-icon`]: {
          opacity: 0
        },
        [`${t}-item-ellipsis`]: {
          opacity: 1
        }
      }
    },
    [`&${t}-simple`]: {
      [`${t}-prev, ${t}-next`]: {
        [`&${t}-disabled ${t}-item-link`]: {
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      }
    }
  };
}, k2 = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [`&${t}-mini ${t}-total-text, &${t}-mini ${t}-simple-pager`]: {
      height: l.paginationItemSizeSM,
      lineHeight: `${l.paginationItemSizeSM}px`
    },
    [`&${t}-mini ${t}-item`]: {
      minWidth: l.paginationItemSizeSM,
      height: l.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${l.paginationItemSizeSM - 2}px`
    },
    [`&${t}-mini ${t}-item:not(${t}-item-active)`]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&:hover": {
        backgroundColor: l.colorBgTextHover
      },
      "&:active": {
        backgroundColor: l.colorBgTextActive
      }
    },
    [`&${t}-mini ${t}-prev, &${t}-mini ${t}-next`]: {
      minWidth: l.paginationItemSizeSM,
      height: l.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${l.paginationItemSizeSM}px`,
      [`&:hover ${t}-item-link`]: {
        backgroundColor: l.colorBgTextHover
      },
      [`&:active ${t}-item-link`]: {
        backgroundColor: l.colorBgTextActive
      },
      [`&${t}-disabled:hover ${t}-item-link`]: {
        backgroundColor: "transparent"
      }
    },
    [`
    &${t}-mini ${t}-prev ${t}-item-link,
    &${t}-mini ${t}-next ${t}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: l.paginationItemSizeSM,
        lineHeight: `${l.paginationItemSizeSM}px`
      }
    },
    [`&${t}-mini ${t}-jump-prev, &${t}-mini ${t}-jump-next`]: {
      height: l.paginationItemSizeSM,
      marginInlineEnd: 0,
      lineHeight: `${l.paginationItemSizeSM}px`
    },
    [`&${t}-mini ${t}-options`]: {
      marginInlineStart: l.paginationMiniOptionsMarginInlineStart,
      "&-size-changer": {
        top: l.paginationMiniOptionsSizeChangerTop
      },
      "&-quick-jumper": {
        height: l.paginationItemSizeSM,
        lineHeight: `${l.paginationItemSizeSM}px`,
        input: j(j({}, wi(l)), {
          width: l.paginationMiniQuickJumperInputWidth,
          height: l.controlHeightSM
        })
      }
    }
  };
}, I2 = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [`
    &${t}-simple ${t}-prev,
    &${t}-simple ${t}-next
    `]: {
      height: l.paginationItemSizeSM,
      lineHeight: `${l.paginationItemSizeSM}px`,
      verticalAlign: "top",
      [`${t}-item-link`]: {
        height: l.paginationItemSizeSM,
        backgroundColor: "transparent",
        border: 0,
        "&:hover": {
          backgroundColor: l.colorBgTextHover
        },
        "&:active": {
          backgroundColor: l.colorBgTextActive
        },
        "&::after": {
          height: l.paginationItemSizeSM,
          lineHeight: `${l.paginationItemSizeSM}px`
        }
      }
    },
    [`&${t}-simple ${t}-simple-pager`]: {
      display: "inline-block",
      height: l.paginationItemSizeSM,
      marginInlineEnd: l.marginXS,
      input: {
        boxSizing: "border-box",
        height: "100%",
        marginInlineEnd: l.marginXS,
        padding: `0 ${l.paginationItemPaddingInline}px`,
        textAlign: "center",
        backgroundColor: l.paginationItemInputBg,
        border: `${l.lineWidth}px ${l.lineType} ${l.colorBorder}`,
        borderRadius: l.borderRadius,
        outline: "none",
        transition: `border-color ${l.motionDurationMid}`,
        color: "inherit",
        "&:hover": {
          borderColor: l.colorPrimary
        },
        "&:focus": {
          borderColor: l.colorPrimaryHover,
          boxShadow: `${l.inputOutlineOffset}px 0 ${l.controlOutlineWidth}px ${l.controlOutline}`
        },
        "&[disabled]": {
          color: l.colorTextDisabled,
          backgroundColor: l.colorBgContainerDisabled,
          borderColor: l.colorBorder,
          cursor: "not-allowed"
        }
      }
    }
  };
}, D2 = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [`${t}-jump-prev, ${t}-jump-next`]: {
      outline: 0,
      [`${t}-item-container`]: {
        position: "relative",
        [`${t}-item-link-icon`]: {
          color: l.colorPrimary,
          fontSize: l.fontSizeSM,
          opacity: 0,
          transition: `all ${l.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${t}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: l.colorTextDisabled,
          fontFamily: "Arial, Helvetica, sans-serif",
          letterSpacing: l.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: l.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${l.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${t}-item-link-icon`]: {
          opacity: 1
        },
        [`${t}-item-ellipsis`]: {
          opacity: 0
        }
      },
      "&:focus-visible": j({
        [`${t}-item-link-icon`]: {
          opacity: 1
        },
        [`${t}-item-ellipsis`]: {
          opacity: 0
        }
      }, Ba(l))
    },
    [`
    ${t}-prev,
    ${t}-jump-prev,
    ${t}-jump-next
    `]: {
      marginInlineEnd: l.marginXS
    },
    [`
    ${t}-prev,
    ${t}-next,
    ${t}-jump-prev,
    ${t}-jump-next
    `]: {
      display: "inline-block",
      minWidth: l.paginationItemSize,
      height: l.paginationItemSize,
      color: l.colorText,
      fontFamily: l.paginationFontFamily,
      lineHeight: `${l.paginationItemSize}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: l.borderRadius,
      cursor: "pointer",
      transition: `all ${l.motionDurationMid}`
    },
    [`${t}-prev, ${t}-next`]: {
      fontFamily: "Arial, Helvetica, sans-serif",
      outline: 0,
      button: {
        color: l.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${t}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: l.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${l.lineWidth}px ${l.lineType} transparent`,
        borderRadius: l.borderRadius,
        outline: "none",
        transition: `all ${l.motionDurationMid}`
      },
      [`&:focus-visible ${t}-item-link`]: j({}, Ba(l)),
      [`&:hover ${t}-item-link`]: {
        backgroundColor: l.colorBgTextHover
      },
      [`&:active ${t}-item-link`]: {
        backgroundColor: l.colorBgTextActive
      },
      [`&${t}-disabled:hover`]: {
        [`${t}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${t}-slash`]: {
      marginInlineEnd: l.paginationSlashMarginInlineEnd,
      marginInlineStart: l.paginationSlashMarginInlineStart
    },
    [`${t}-options`]: {
      display: "inline-block",
      marginInlineStart: l.margin,
      verticalAlign: "middle",
      "&-size-changer.-select": {
        display: "inline-block",
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: l.controlHeight,
        marginInlineStart: l.marginXS,
        lineHeight: `${l.controlHeight}px`,
        verticalAlign: "top",
        input: j(j({}, Ei(l)), {
          width: l.controlHeightLG * 1.25,
          height: l.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: l.marginXS,
          marginInlineEnd: l.marginXS
        })
      }
    }
  };
}, C2 = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [`${t}-item`]: j(j({
      display: "inline-block",
      minWidth: l.paginationItemSize,
      height: l.paginationItemSize,
      marginInlineEnd: l.marginXS,
      fontFamily: l.paginationFontFamily,
      lineHeight: `${l.paginationItemSize - 2}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: "transparent",
      border: `${l.lineWidth}px ${l.lineType} transparent`,
      borderRadius: l.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${l.paginationItemPaddingInline}px`,
        color: l.colorText,
        transition: "none",
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${t}-item-active)`]: {
        "&:hover": {
          transition: `all ${l.motionDurationMid}`,
          backgroundColor: l.colorBgTextHover
        },
        "&:active": {
          backgroundColor: l.colorBgTextActive
        }
      }
    }, h0(l)), {
      "&-active": {
        fontWeight: l.paginationFontWeightActive,
        backgroundColor: l.paginationItemBgActive,
        borderColor: l.colorPrimary,
        a: {
          color: l.colorPrimary
        },
        "&:hover": {
          borderColor: l.colorPrimaryHover
        },
        "&:hover a": {
          color: l.colorPrimaryHover
        }
      }
    })
  };
}, w2 = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [t]: j(j(j(j(j(j(j(j({}, sn(l)), {
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${t}-total-text`]: {
        display: "inline-block",
        height: l.paginationItemSize,
        marginInlineEnd: l.marginXS,
        lineHeight: `${l.paginationItemSize - 2}px`,
        verticalAlign: "middle"
      }
    }), C2(l)), D2(l)), I2(l)), k2(l)), L2(l)), {
      // media query style
      [`@media only screen and (max-width: ${l.screenLG}px)`]: {
        [`${t}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${l.screenSM}px)`]: {
        [`${t}-options`]: {
          display: "none"
        }
      }
    }),
    // rtl style
    [`&${l.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, E2 = (l) => {
  const {
    componentCls: t
  } = l;
  return {
    [`${t}${t}-disabled`]: {
      "&, &:hover": {
        [`${t}-item-link`]: {
          borderColor: l.colorBorder
        }
      },
      "&:focus-visible": {
        [`${t}-item-link`]: {
          borderColor: l.colorBorder
        }
      },
      [`${t}-item, ${t}-item-link`]: {
        backgroundColor: l.colorBgContainerDisabled,
        borderColor: l.colorBorder,
        [`&:hover:not(${t}-item-active)`]: {
          backgroundColor: l.colorBgContainerDisabled,
          borderColor: l.colorBorder,
          a: {
            color: l.colorTextDisabled
          }
        },
        [`&${t}-item-active`]: {
          backgroundColor: l.paginationItemDisabledBgActive
        }
      },
      [`${t}-prev, ${t}-next`]: {
        "&:hover button": {
          backgroundColor: l.colorBgContainerDisabled,
          borderColor: l.colorBorder,
          color: l.colorTextDisabled
        },
        [`${t}-item-link`]: {
          backgroundColor: l.colorBgContainerDisabled,
          borderColor: l.colorBorder
        }
      }
    },
    [t]: {
      [`${t}-prev, ${t}-next`]: {
        "&:hover button": {
          borderColor: l.colorPrimaryHover,
          backgroundColor: l.paginationItemBg
        },
        [`${t}-item-link`]: {
          backgroundColor: l.paginationItemLinkBg,
          borderColor: l.colorBorder
        },
        [`&:hover ${t}-item-link`]: {
          borderColor: l.colorPrimary,
          backgroundColor: l.paginationItemBg,
          color: l.colorPrimary
        },
        [`&${t}-disabled`]: {
          [`${t}-item-link`]: {
            borderColor: l.colorBorder,
            color: l.colorTextDisabled
          }
        }
      },
      [`${t}-item`]: {
        backgroundColor: l.paginationItemBg,
        border: `${l.lineWidth}px ${l.lineType} ${l.colorBorder}`,
        [`&:hover:not(${t}-item-active)`]: {
          borderColor: l.colorPrimary,
          backgroundColor: l.paginationItemBg,
          a: {
            color: l.colorPrimary
          }
        },
        "&-active": {
          borderColor: l.colorPrimary
        }
      }
    }
  };
}, x2 = $t("Pagination", (l) => {
  const t = tt(l, {
    paginationItemSize: l.controlHeight,
    paginationFontFamily: l.fontFamily,
    paginationItemBg: l.colorBgContainer,
    paginationItemBgActive: l.colorBgContainer,
    paginationFontWeightActive: l.fontWeightStrong,
    paginationItemSizeSM: l.controlHeightSM,
    paginationItemInputBg: l.colorBgContainer,
    paginationMiniOptionsSizeChangerTop: 0,
    paginationItemDisabledBgActive: l.controlItemBgActiveDisabled,
    paginationItemDisabledColorActive: l.colorTextDisabled,
    paginationItemLinkBg: l.colorBgContainer,
    inputOutlineOffset: "0 0",
    paginationMiniOptionsMarginInlineStart: l.marginXXS / 2,
    paginationMiniQuickJumperInputWidth: l.controlHeightLG * 1.1,
    paginationItemPaddingInline: l.marginXXS * 1.5,
    paginationEllipsisLetterSpacing: l.marginXXS / 2,
    paginationSlashMarginInlineStart: l.marginXXS,
    paginationSlashMarginInlineEnd: l.marginSM,
    paginationEllipsisTextIndent: "0.13em"
    // magic for ui experience
  }, HZ(l));
  return [w2(t), l.wireframe && E2(t)];
});
var g2 = function(l, t) {
  var n = {};
  for (var e in l)
    Object.prototype.hasOwnProperty.call(l, e) && t.indexOf(e) < 0 && (n[e] = l[e]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d = 0, e = Object.getOwnPropertySymbols(l); d < e.length; d++)
      t.indexOf(e[d]) < 0 && Object.prototype.propertyIsEnumerable.call(l, e[d]) && (n[e[d]] = l[e[d]]);
  return n;
};
const j2 = () => ({
  total: Number,
  defaultCurrent: Number,
  disabled: zt(),
  current: Number,
  defaultPageSize: Number,
  pageSize: Number,
  hideOnSinglePage: zt(),
  showSizeChanger: zt(),
  pageSizeOptions: Ta(),
  buildOptionText: ln(),
  showQuickJumper: ed([Boolean, Object]),
  showTotal: ln(),
  size: Ht(),
  simple: zt(),
  locale: Object,
  prefixCls: String,
  selectPrefixCls: String,
  totalBoundaryShowSizeChanger: Number,
  selectComponentClass: String,
  itemRender: ln(),
  role: String,
  responsive: Boolean,
  showLessItems: zt(),
  onChange: ln(),
  onShowSizeChange: ln(),
  "onUpdate:current": ln(),
  "onUpdate:pageSize": ln()
}), O2 = pl({
  compatConfig: {
    MODE: 3
  },
  name: "APagination",
  inheritAttrs: !1,
  props: j2(),
  // emits: ['change', 'showSizeChange', 'update:current', 'update:pageSize'],
  setup(l, t) {
    let {
      slots: n,
      attrs: e
    } = t;
    const {
      prefixCls: d,
      configProvider: a,
      direction: U,
      size: V
    } = ht("pagination", l), [h, W] = x2(d), Z = Zl(() => a.getPrefixCls("select", l.selectPrefixCls)), s = cu(), [o] = Io("Pagination", $U, Ct(l, "locale")), F = (N) => {
      const Q = H("span", {
        class: `${N}-item-ellipsis`
      }, [Ve("•••")]), u = H("button", {
        class: `${N}-item-link`,
        type: "button",
        tabindex: -1
      }, [U.value === "rtl" ? H(Se, null, null) : H(Te, null, null)]), i = H("button", {
        class: `${N}-item-link`,
        type: "button",
        tabindex: -1
      }, [U.value === "rtl" ? H(Te, null, null) : H(Se, null, null)]), c = H("a", {
        rel: "nofollow",
        class: `${N}-item-link`
      }, [H("div", {
        class: `${N}-item-container`
      }, [U.value === "rtl" ? H(md, {
        class: `${N}-item-link-icon`
      }, null) : H(bd, {
        class: `${N}-item-link-icon`
      }, null), Q])]), R = H("a", {
        rel: "nofollow",
        class: `${N}-item-link`
      }, [H("div", {
        class: `${N}-item-container`
      }, [U.value === "rtl" ? H(bd, {
        class: `${N}-item-link-icon`
      }, null) : H(md, {
        class: `${N}-item-link-icon`
      }, null), Q])]);
      return {
        prevIcon: u,
        nextIcon: i,
        jumpPrevIcon: c,
        jumpNextIcon: R
      };
    };
    return () => {
      var N;
      const {
        itemRender: Q = n.itemRender,
        buildOptionText: u = n.buildOptionText,
        selectComponentClass: i,
        responsive: c
      } = l, R = g2(l, ["itemRender", "buildOptionText", "selectComponentClass", "responsive"]), m = V.value === "small" || !!(!((N = s.value) === null || N === void 0) && N.xs && !V.value && c), M = j(j(j(j(j({}, R), F(d.value)), {
        prefixCls: d.value,
        selectPrefixCls: Z.value,
        selectComponentClass: i || (m ? T2 : G2),
        locale: o.value,
        buildOptionText: u
      }), e), {
        class: Xl({
          [`${d.value}-mini`]: m,
          [`${d.value}-rtl`]: U.value === "rtl"
        }, e.class, W.value),
        itemRender: Q
      });
      return h(H(z2, M, null));
    };
  }
}), v2 = Td(O2);
var f2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "minus-square", theme: "outlined" };
function rU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      K2(l, d, n[d]);
    });
  }
  return l;
}
function K2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Pi = function(t, n) {
  var e = rU({}, t, n.attrs);
  return H($l, rU({}, e, {
    icon: f2
  }), null);
};
Pi.displayName = "MinusSquareOutlined";
Pi.inheritAttrs = !1;
var H2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "plus-square", theme: "outlined" };
function MU(l) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, e = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (e = e.concat(Object.getOwnPropertySymbols(n).filter(function(d) {
      return Object.getOwnPropertyDescriptor(n, d).enumerable;
    }))), e.forEach(function(d) {
      P2(l, d, n[d]);
    });
  }
  return l;
}
function P2(l, t, n) {
  return t in l ? Object.defineProperty(l, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : l[t] = n, l;
}
var Ai = function(t, n) {
  var e = MU({}, t, n.attrs);
  return H($l, MU({}, e, {
    icon: H2
  }), null);
};
Ai.displayName = "PlusSquareOutlined";
Ai.inheritAttrs = !1;
const A2 = { class: "scale-container" }, $2 = { style: { margin: "0px 10px" } }, q2 = /* @__PURE__ */ pl({
  __name: "pdfScale",
  setup(l) {
    const t = fl("containerScale"), n = (d) => {
      t.value = d;
    }, e = Zl(() => +t.value.toFixed(1));
    return (d, a) => (Vt(), mt("div", A2, [
      St("div", {
        class: qe([{ "pdf-disabled": e.value > 1.2 }, "pdf-icon"]),
        onClick: a[0] || (a[0] = () => e.value < 1.3 && n(at(t) + 0.1))
      }, [
        H(at(Ai))
      ], 2),
      St("div", $2, YU((at(t) * 100).toFixed(0)) + "%", 1),
      St("div", {
        class: qe([{ "pdf-disabled": e.value < 0.8 }, "pdf-icon"]),
        onClick: a[1] || (a[1] = () => e.value > 0.7 && n(at(t) - 0.1))
      }, [
        H(at(Pi))
      ], 2)
    ]));
  }
}), Un = (l, t) => {
  const n = l.__vccOpts || l;
  for (const [e, d] of t)
    n[e] = d;
  return n;
}, _2 = /* @__PURE__ */ Un(q2, [["__scopeId", "data-v-7b14f3d9"]]), lM = "data:image/svg+xml,%3csvg%20t='1716277325068'%20class='icon'%20viewBox='0%200%201366%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='3361'%20width='200'%20height='200'%3e%3cpath%20d='M1309.745268%200H56.12297a55.802067%2055.802067%200%200%200%200%20112.245537h1253.622298a55.802067%2055.802067%200%201%200%200-112.245537zM1309.745268%20455.877231H56.12297a55.802067%2055.802067%200%200%200%200%20112.245538h1253.622298a55.802067%2055.802067%200%201%200%200-112.245538zM1309.745268%20911.754463H56.12297a55.802067%2055.802067%200%201%200%200%20112.245537h1253.622298a55.802067%2055.802067%200%200%200%200-112.245537z'%20fill='%234D4D4D'%20p-id='3362'%3e%3c/path%3e%3c/svg%3e", tM = { class: "navigation-container" }, nM = /* @__PURE__ */ pl({
  __name: "pdfNavigation",
  setup(l) {
    const t = fl("navigationRef"), n = () => {
      t.value = !t.value;
    };
    return (e, d) => (Vt(), mt("div", tM, [
      St("img", {
        src: lM,
        onClick: n,
        alt: ""
      })
    ]));
  }
}), eM = /* @__PURE__ */ Un(nM, [["__scopeId", "data-v-0c227c63"]]), dM = "data:image/svg+xml,%3c?xml%20version='1.0'%20standalone='no'?%3e%3c!DOCTYPE%20svg%20PUBLIC%20'-//W3C//DTD%20SVG%201.1//EN'%20'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'%3e%3csvg%20t='1715927410505'%20class='icon'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='3260'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20width='200'%20height='200'%3e%3cpath%20d='M919.22%20876.82L703.05%20666.48c52.14-60.24%2083.68-138.79%2083.68-224.71%200-189.73-153.81-343.54-343.54-343.54-189.73%200-343.54%20153.81-343.54%20343.54s153.81%20343.54%20343.54%20343.54c82.2%200%20157.65-28.89%20216.78-77.04l217.42%20211.55a29.92%2029.92%200%200%200%2020.92%208.5c7.82%200%2015.62-3.04%2021.5-9.08%2011.54-11.87%2011.28-30.86-0.59-42.42zM553.53%20703.05c-34.92%2014.77-72.05%2022.26-110.35%2022.26s-75.43-7.49-110.35-22.26c-33.76-14.28-64.09-34.73-90.15-60.79-26.06-26.06-46.51-56.39-60.79-90.15-14.77-34.92-22.26-72.05-22.26-110.35s7.49-75.43%2022.26-110.35c14.28-33.76%2034.73-64.09%2060.79-90.15%2026.06-26.06%2056.39-46.51%2090.15-60.79%2034.92-14.77%2072.05-22.26%20110.35-22.26s75.43%207.49%20110.35%2022.26c33.76%2014.28%2064.09%2034.73%2090.15%2060.79%2026.06%2026.06%2046.51%2056.39%2060.79%2090.15%2014.77%2034.92%2022.26%2072.05%2022.26%20110.35s-7.49%2075.43-22.26%20110.35c-14.28%2033.76-34.73%2064.09-60.79%2090.15-26.06%2026.06-56.39%2046.52-90.15%2060.79z'%20p-id='3261'%3e%3c/path%3e%3c/svg%3e", aM = { class: "search-box" }, iM = { style: { padding: "8px" } }, sM = /* @__PURE__ */ pl({
  __name: "search",
  setup(l) {
    const t = Ml(""), n = fl("searchValue"), e = Ml(!1), d = () => {
      n.value = t.value;
    }, a = () => {
      e.value = !0;
    };
    return (U, V) => (Vt(), mt("div", aM, [
      H(at(Gu), {
        placement: "bottom",
        trigger: "click",
        open: e.value,
        "onUpdate:open": V[1] || (V[1] = (h) => e.value = h),
        color: "#fff"
      }, {
        title: ds(() => [
          St("div", iM, [
            H(at(_Z), {
              value: t.value,
              "onUpdate:value": V[0] || (V[0] = (h) => t.value = h),
              placeholder: "input search text",
              onSearch: d
            }, null, 8, ["value"])
          ])
        ]),
        default: ds(() => [
          St("img", {
            class: "search",
            onClick: a,
            src: dM,
            alt: ""
          })
        ]),
        _: 1
      }, 8, ["open"])
    ]));
  }
}), cM = /* @__PURE__ */ Un(sM, [["__scopeId", "data-v-73664595"]]), UF = (l, t = "#scrollIntIndex") => {
  const n = document.querySelector(`${t}-${l}`);
  n && n?.scrollIntoView();
};
function UM(l, t, n = 0) {
  const e = t.clientHeight, d = l.offsetTop, a = t.scrollTop - n, U = d - a;
  return U >= 0 && U <= e;
}
const ZM = { class: "tool-page" }, FM = /* @__PURE__ */ pl({
  __name: "pageNum",
  setup(l) {
    const t = Ml(1), n = fl("pdfExamplePages"), e = fl("index"), d = (a) => UF(a);
    return it(() => {
      e?.value && (t.value = e.value);
    }), (a, U) => (Vt(), mt("div", ZM, [
      H(at(v2), {
        onChange: d,
        defaultPageSize: 1,
        current: t.value,
        "onUpdate:current": U[0] || (U[0] = (V) => t.value = V),
        simple: "",
        total: at(n)
      }, null, 8, ["current", "total"])
    ]));
  }
}), oM = /* @__PURE__ */ Un(FM, [["__scopeId", "data-v-5368f9b6"]]), VM = { class: "pdf-tool-container" }, QM = { class: "tool-view" }, WM = { class: "tool-content" }, hM = /* @__PURE__ */ pl({
  __name: "pdfTool",
  setup(l) {
    return (t, n) => (Vt(), mt("div", VM, [
      St("div", QM, [
        H(eM),
        H(oM)
      ]),
      St("div", WM, [
        H(_2)
      ]),
      H(cM)
    ]));
  }
}), RM = /* @__PURE__ */ Un(hM, [["__scopeId", "data-v-b9a431c4"]]), NM = "data:image/gif;base64,R0lGODlhGAAYAPQAAP///wAAAM7Ozvr6+uDg4LCwsOjo6I6OjsjIyJycnNjY2KioqMDAwPLy8nZ2doaGhri4uGhoaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJBwAAACwAAAAAGAAYAAAFriAgjiQAQWVaDgr5POSgkoTDjFE0NoQ8iw8HQZQTDQjDn4jhSABhAAOhoTqSDg7qSUQwxEaEwwFhXHhHgzOA1xshxAnfTzotGRaHglJqkJcaVEqCgyoCBQkJBQKDDXQGDYaIioyOgYSXA36XIgYMBWRzXZoKBQUMmil0lgalLSIClgBpO0g+s26nUWddXyoEDIsACq5SsTMMDIECwUdJPw0Mzsu0qHYkw72bBmozIQAh+QQJBwAAACwAAAAAGAAYAAAFsCAgjiTAMGVaDgR5HKQwqKNxIKPjjFCk0KNXC6ATKSI7oAhxWIhezwhENTCQEoeGCdWIPEgzESGxEIgGBWstEW4QCGGAIJEoxGmGt5ZkgCRQQHkGd2CESoeIIwoMBQUMP4cNeQQGDYuNj4iSb5WJnmeGng0CDGaBlIQEJziHk3sABidDAHBgagButSKvAAoyuHuUYHgCkAZqebw0AgLBQyyzNKO3byNuoSS8x8OfwIchACH5BAkHAAAALAAAAAAYABgAAAW4ICCOJIAgZVoOBJkkpDKoo5EI43GMjNPSokXCINKJCI4HcCRIQEQvqIOhGhBHhUTDhGo4diOZyFAoKEQDxra2mAEgjghOpCgz3LTBIxJ5kgwMBShACREHZ1V4Kg1rS44pBAgMDAg/Sw0GBAQGDZGTlY+YmpyPpSQDiqYiDQoCliqZBqkGAgKIS5kEjQ21VwCyp76dBHiNvz+MR74AqSOdVwbQuo+abppo10ssjdkAnc0rf8vgl8YqIQAh+QQJBwAAACwAAAAAGAAYAAAFrCAgjiQgCGVaDgZZFCQxqKNRKGOSjMjR0qLXTyciHA7AkaLACMIAiwOC1iAxCrMToHHYjWQiA4NBEA0Q1RpWxHg4cMXxNDk4OBxNUkPAQAEXDgllKgMzQA1pSYopBgonCj9JEA8REQ8QjY+RQJOVl4ugoYssBJuMpYYjDQSliwasiQOwNakALKqsqbWvIohFm7V6rQAGP6+JQLlFg7KDQLKJrLjBKbvAor3IKiEAIfkECQcAAAAsAAAAABgAGAAABbUgII4koChlmhokw5DEoI4NQ4xFMQoJO4uuhignMiQWvxGBIQC+AJBEUyUcIRiyE6CR0CllW4HABxBURTUw4nC4FcWo5CDBRpQaCoF7VjgsyCUDYDMNZ0mHdwYEBAaGMwwHDg4HDA2KjI4qkJKUiJ6faJkiA4qAKQkRB3E0i6YpAw8RERAjA4tnBoMApCMQDhFTuySKoSKMJAq6rD4GzASiJYtgi6PUcs9Kew0xh7rNJMqIhYchACH5BAkHAAAALAAAAAAYABgAAAW0ICCOJEAQZZo2JIKQxqCOjWCMDDMqxT2LAgELkBMZCoXfyCBQiFwiRsGpku0EshNgUNAtrYPT0GQVNRBWwSKBMp98P24iISgNDAS4ipGA6JUpA2WAhDR4eWM/CAkHBwkIDYcGiTOLjY+FmZkNlCN3eUoLDmwlDW+AAwcODl5bYl8wCVYMDw5UWzBtnAANEQ8kBIM0oAAGPgcREIQnVloAChEOqARjzgAQEbczg8YkWJq8nSUhACH5BAkHAAAALAAAAAAYABgAAAWtICCOJGAYZZoOpKKQqDoORDMKwkgwtiwSBBYAJ2owGL5RgxBziQQMgkwoMkhNqAEDARPSaiMDFdDIiRSFQowMXE8Z6RdpYHWnEAWGPVkajPmARVZMPUkCBQkJBQINgwaFPoeJi4GVlQ2Qc3VJBQcLV0ptfAMJBwdcIl+FYjALQgimoGNWIhAQZA4HXSpLMQ8PIgkOSHxAQhERPw7ASTSFyCMMDqBTJL8tf3y2fCEAIfkECQcAAAAsAAAAABgAGAAABa8gII4k0DRlmg6kYZCoOg5EDBDEaAi2jLO3nEkgkMEIL4BLpBAkVy3hCTAQKGAznM0AFNFGBAbj2cA9jQixcGZAGgECBu/9HnTp+FGjjezJFAwFBQwKe2Z+KoCChHmNjVMqA21nKQwJEJRlbnUFCQlFXlpeCWcGBUACCwlrdw8RKGImBwktdyMQEQciB7oACwcIeA4RVwAODiIGvHQKERAjxyMIB5QlVSTLYLZ0sW8hACH5BAkHAAAALAAAAAAYABgAAAW0ICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWPM5wNiV0UDUIBNkdoepTfMkA7thIECiyRtUAGq8fm2O4jIBgMBA1eAZ6Knx+gHaJR4QwdCMKBxEJRggFDGgQEREPjjAMBQUKIwIRDhBDC2QNDDEKoEkDoiMHDigICGkJBS2dDA6TAAnAEAkCdQ8ORQcHTAkLcQQODLPMIgIJaCWxJMIkPIoAt3EhACH5BAkHAAAALAAAAAAYABgAAAWtICCOJNA0ZZoOpGGQrDoOBCoSxNgQsQzgMZyIlvOJdi+AS2SoyXrK4umWHM5wNiV0UN3xdLiqr+mENcWpM9TIbrsBkEck8oC0DQqBQGGIz+t3eXtob0ZTPgNrIwQJDgtGAgwCWSIMDg4HiiUIDAxFAAoODwxDBWINCEGdSTQkCQcoegADBaQ6MggHjwAFBZUFCm0HB0kJCUy9bAYHCCPGIwqmRq0jySMGmj6yRiEAIfkECQcAAAAsAAAAABgAGAAABbIgII4k0DRlmg6kYZCsOg4EKhLE2BCxDOAxnIiW84l2L4BLZKipBopW8XRLDkeCiAMyMvQAA+uON4JEIo+vqukkKQ6RhLHplVGN+LyKcXA4Dgx5DWwGDXx+gIKENnqNdzIDaiMECwcFRgQCCowiCAcHCZIlCgICVgSfCEMMnA0CXaU2YSQFoQAKUQMMqjoyAglcAAyBAAIMRUYLCUkFlybDeAYJryLNk6xGNCTQXY0juHghACH5BAkHAAAALAAAAAAYABgAAAWzICCOJNA0ZVoOAmkY5KCSSgSNBDE2hDyLjohClBMNij8RJHIQvZwEVOpIekRQJyJs5AMoHA+GMbE1lnm9EcPhOHRnhpwUl3AsknHDm5RN+v8qCAkHBwkIfw1xBAYNgoSGiIqMgJQifZUjBhAJYj95ewIJCQV7KYpzBAkLLQADCHOtOpY5PgNlAAykAEUsQ1wzCgWdCIdeArczBQVbDJ0NAqyeBb64nQAGArBTt8R8mLuyPyEAOwAAAAAAAAAAAA==", bM = (l) => (MF("data-v-02e1261c"), l = l(), pF(), l), mM = ["id"], uM = /* @__PURE__ */ bM(() => /* @__PURE__ */ St("img", {
  style: { width: "24px", "object-fit": "cover" },
  class: "loading-icon-image",
  src: NM,
  alt: ""
}, null, -1)), rM = [
  uM
], MM = /* @__PURE__ */ pl({
  __name: "pdfTarget",
  props: {
    scrollIntIndexShow: { type: Boolean, default: !0 },
    pageNum: {},
    pdfContainer: {},
    pdfJsViewer: {},
    searchValue: {},
    canvasWidth: {},
    imageRenderHeight: {},
    pdfOptions: { default: () => ({
      scale: 1.5,
      containerScale: 1
    }) }
  },
  emits: ["handleSetImageUrl", "handleIntersection"],
  setup(l, { expose: t, emit: n }) {
    const e = l, d = n;
    let a = Ml(), U = Ml(), V = Ml();
    const h = Ml(), W = Ml(), Z = Ml(!1), s = Ml(!0), o = Ml(), F = Ml(!1), N = Zl(() => (e?.canvasWidth || 100) * e.pdfOptions.containerScale), Q = Zl(() => (e?.imageRenderHeight || 100) * e.pdfOptions.containerScale), u = async (M) => {
      s.value = !1, Z.value = !0, dt(() => {
        e.pdfContainer.getPage(M).then(async (S) => {
          if (!W.value || s.value)
            return;
          const p = W.value, Y = p.getContext("2d", {
            willReadFrequently: !0,
            alpha: !1
          }), k = window.devicePixelRatio || 1, L = Y.webkitBackingStorePixelRatio || Y.mozBackingStorePixelRatio || Y.msBackingStorePixelRatio || Y.oBackingStorePixelRatio || Y.backingStorePixelRatio || 1, z = k / L, f = S.getViewport({ scale: e.pdfOptions?.scale });
          p.width = f.width * z, p.height = f.height * z, Y.setTransform(z, 0, 0, z, 0, 0);
          const K = {
            canvasContext: Y,
            viewport: f
          };
          s.value || (V.value = S, await S.render(K), U.value = f, a.value = await S.getTextContent(), Z.value = !1, e.searchValue && i(
            a.value,
            U.value,
            V.value
          ));
        });
      });
    }, i = (M, S, p) => {
      if (!M || !S || !p || !e.searchValue || F.value)
        return;
      const { TextLayerBuilder: Y } = e.pdfJsViewer, k = document.createElement("div");
      k.setAttribute("class", "textLayer");
      var L = new Y({
        textLayerDiv: k,
        pageIndex: p._pageIndex,
        viewport: S
      });
      L.setTextContentSource(M), L.render(S), h.value.appendChild(L.div), F.value = !0, dt(() => {
        h.value.querySelector(".textLayer").childNodes.forEach((K) => {
          K.innerHTML = R(
            K.textContent,
            e.searchValue
          );
        });
      });
    }, c = () => {
      d(
        "handleSetImageUrl",
        W.value?.toDataURL("image/png")
      );
    }, R = (M, S) => {
      const p = M.toLowerCase().indexOf(S.toLowerCase()), Y = p !== -1, k = Y ? p : 0;
      let L = M, z = M.substr(0, k), f = M.substr(k, S.length), K = M.substr(
        Y ? k + S.length : 0,
        M.length
      );
      return Y && S ? L = `${z}<span  class="pdf-highlight">${f}</span>${K.toLowerCase().indexOf(S.toLowerCase()) == -1 ? K : R(K, S)}` : L = `${z}${K}`, L;
    }, m = (M) => {
      const { isIntersecting: S } = M[0];
      S ? u(e.pageNum) : s.value = !0, d("handleIntersection", e.pageNum, S);
    };
    return ql(() => {
      o.value = new IntersectionObserver(m, {
        root: null
      }), o.value.observe(h.value);
    }), t({
      pdfContainerRef: h
    }), Bl(
      () => e.searchValue,
      (M) => {
        !s.value && M && i(
          a.value,
          U.value,
          V.value
        );
      }
    ), (M, S) => (Vt(), mt("div", {
      style: fd(`height:${Q.value}px;width:${N.value}px;`),
      class: qe(["pdf-Container-Ref pdfViewer", { pdfLoading: Z.value }]),
      id: `${e.scrollIntIndexShow && "scrollIntIndex-" + e.pageNum}`,
      onClick: c,
      ref_key: "pdfContainerRef",
      ref: h
    }, [
      s.value ? _e("", !0) : (Vt(), mt("canvas", {
        key: 0,
        style: fd(`height:${Q.value}px;width:${N.value}px;`),
        class: "pdf-render",
        ref_key: "pdfRender",
        ref: W
      }, null, 4)),
      Z.value ? (Vt(), mt("div", {
        key: 1,
        class: "loading-container",
        style: fd(`height:${Q.value}px;width:${N.value}px;`)
      }, rM, 4)) : _e("", !0)
    ], 14, mM));
  }
}), ZF = /* @__PURE__ */ Un(MM, [["__scopeId", "data-v-02e1261c"]]), pM = { class: "nav-container-image" }, SM = ["id", "onClick"], pU = 140, TM = /* @__PURE__ */ pl({
  __name: "pdfNavContainer",
  props: {
    navigationRef: { type: Boolean },
    pdfContainer: {},
    pdfJsViewer: {},
    canvasWidth: {},
    imageRenderHeight: {}
  },
  setup(l) {
    const t = fl("index"), n = fl("pdfExamplePages"), e = l, d = Ml(), a = Ml(0), U = Ml(1), V = Ml(0), h = Ml(), W = (o) => {
      UF(o), U.value = o;
    }, Z = () => {
      const { canvasWidth: o, imageRenderHeight: F } = e, N = o / F;
      a.value = pU / N;
    }, s = () => {
      t?.value && (U.value = t.value);
      const o = document.querySelector(`#img-canvas-${U.value}`), F = document.querySelector(".pdf-tool-container")?.clientHeight, N = document.querySelector(".nav-container-image"), Q = document.querySelector(".image-box");
      if (!d.value || !o || !N || !Q)
        return;
      let u = o.offsetTop - d.value.clientHeight;
      const i = u ? o.clientHeight : 0;
      V.value > U.value || U.value - V.value > 2 ? u = o?.offsetTop : u += i, !UM(o, d.value, F) && (d.value.scrollTop = u || 0), V.value = U.value;
    };
    return Z(), it(() => {
      t?.value && s();
    }), (o, F) => (Vt(), mt("div", {
      class: "nav-container",
      ref_key: "navContainerRef",
      ref: d
    }, [
      St("div", pM, [
        (Vt(!0), mt(st, null, yU(at(n), (N) => (Vt(), mt("div", {
          class: "image-box",
          id: `img-canvas-${N}`,
          onClick: (Q) => W(N)
        }, [
          St("div", {
            class: qe(["image-item", { "image-item-action": N === U.value }])
          }, [
            H(ZF, {
              scrollIntIndexShow: !1,
              ref_for: !0,
              ref_key: "pdfExampleList",
              ref: h,
              pdfJsViewer: e.pdfJsViewer,
              pageNum: N,
              canvasWidth: pU,
              imageRenderHeight: a.value,
              pdfOptions: { scale: 0.5, containerScale: 1 },
              pdfContainer: e.pdfContainer
            }, null, 8, ["pdfJsViewer", "pageNum", "imageRenderHeight", "pdfContainer"])
          ], 2),
          St("p", null, YU(N), 1)
        ], 8, SM))), 256))
      ])
    ], 512));
  }
}), GM = /* @__PURE__ */ Un(TM, [["__scopeId", "data-v-78b55784"]]);
var JM = {
  /***/
  976: (
    /***/
    (l, t, n) => {
      n.d(t, {
        AnnotationLayer: () => (
          /* binding */
          Ul
        ),
        FreeTextAnnotationElement: () => (
          /* binding */
          z
        ),
        InkAnnotationElement: () => (
          /* binding */
          ll
        ),
        StampAnnotationElement: () => (
          /* binding */
          tl
        )
      });
      var e = n(292), d = n(419), a = n(792);
      function U(cl) {
        return Math.floor(Math.max(0, Math.min(1, cl)) * 255).toString(16).padStart(2, "0");
      }
      function V(cl) {
        return Math.max(0, Math.min(255, 255 * cl));
      }
      class h {
        static CMYK_G([B, X, b, r]) {
          return ["G", 1 - Math.min(1, 0.3 * B + 0.59 * b + 0.11 * X + r)];
        }
        static G_CMYK([B]) {
          return ["CMYK", 0, 0, 0, 1 - B];
        }
        static G_RGB([B]) {
          return ["RGB", B, B, B];
        }
        static G_rgb([B]) {
          return B = V(B), [B, B, B];
        }
        static G_HTML([B]) {
          const X = U(B);
          return `#${X}${X}${X}`;
        }
        static RGB_G([B, X, b]) {
          return ["G", 0.3 * B + 0.59 * X + 0.11 * b];
        }
        static RGB_rgb(B) {
          return B.map(V);
        }
        static RGB_HTML(B) {
          return `#${B.map(U).join("")}`;
        }
        static T_HTML() {
          return "#00000000";
        }
        static T_rgb() {
          return [null];
        }
        static CMYK_RGB([B, X, b, r]) {
          return ["RGB", 1 - Math.min(1, B + r), 1 - Math.min(1, b + r), 1 - Math.min(1, X + r)];
        }
        static CMYK_rgb([B, X, b, r]) {
          return [V(1 - Math.min(1, B + r)), V(1 - Math.min(1, b + r)), V(1 - Math.min(1, X + r))];
        }
        static CMYK_HTML(B) {
          const X = this.CMYK_RGB(B).slice(1);
          return this.RGB_HTML(X);
        }
        static RGB_CMYK([B, X, b]) {
          const r = 1 - B, G = 1 - X, J = 1 - b, T = Math.min(r, G, J);
          return ["CMYK", r, G, J, T];
        }
      }
      var W = n(284);
      const Z = 1e3, s = 9, o = /* @__PURE__ */ new WeakSet();
      function F(cl) {
        return {
          width: cl[2] - cl[0],
          height: cl[3] - cl[1]
        };
      }
      class N {
        static create(B) {
          switch (B.data.annotationType) {
            case e.AnnotationType.LINK:
              return new u(B);
            case e.AnnotationType.TEXT:
              return new i(B);
            case e.AnnotationType.WIDGET:
              switch (B.data.fieldType) {
                case "Tx":
                  return new R(B);
                case "Btn":
                  return B.data.radioButton ? new S(B) : B.data.checkBox ? new M(B) : new p(B);
                case "Ch":
                  return new Y(B);
                case "Sig":
                  return new m(B);
              }
              return new c(B);
            case e.AnnotationType.POPUP:
              return new k(B);
            case e.AnnotationType.FREETEXT:
              return new z(B);
            case e.AnnotationType.LINE:
              return new f(B);
            case e.AnnotationType.SQUARE:
              return new K(B);
            case e.AnnotationType.CIRCLE:
              return new P(B);
            case e.AnnotationType.POLYLINE:
              return new w(B);
            case e.AnnotationType.CARET:
              return new el(B);
            case e.AnnotationType.INK:
              return new ll(B);
            case e.AnnotationType.POLYGON:
              return new O(B);
            case e.AnnotationType.HIGHLIGHT:
              return new q(B);
            case e.AnnotationType.UNDERLINE:
              return new _(B);
            case e.AnnotationType.SQUIGGLY:
              return new il(B);
            case e.AnnotationType.STRIKEOUT:
              return new dl(B);
            case e.AnnotationType.STAMP:
              return new tl(B);
            case e.AnnotationType.FILEATTACHMENT:
              return new al(B);
            default:
              return new Q(B);
          }
        }
      }
      class Q {
        #l = null;
        #t = !1;
        constructor(B, {
          isRenderable: X = !1,
          ignoreBorder: b = !1,
          createQuadrilaterals: r = !1
        } = {}) {
          this.isRenderable = X, this.data = B.data, this.layer = B.layer, this.linkService = B.linkService, this.downloadManager = B.downloadManager, this.imageResourcesPath = B.imageResourcesPath, this.renderForms = B.renderForms, this.svgFactory = B.svgFactory, this.annotationStorage = B.annotationStorage, this.enableScripting = B.enableScripting, this.hasJSActions = B.hasJSActions, this._fieldObjects = B.fieldObjects, this.parent = B.parent, X && (this.container = this._createContainer(b)), r && this._createQuadrilaterals();
        }
        static _hasPopupData({
          titleObj: B,
          contentsObj: X,
          richText: b
        }) {
          return !!(B?.str || X?.str || b?.str);
        }
        get hasPopupData() {
          return Q._hasPopupData(this.data);
        }
        updateEdited(B) {
          if (!this.container)
            return;
          this.#l ||= {
            rect: this.data.rect.slice(0)
          };
          const {
            rect: X
          } = B;
          X && this.#n(X);
        }
        resetEdited() {
          this.#l && (this.#n(this.#l.rect), this.#l = null);
        }
        #n(B) {
          const {
            container: {
              style: X
            },
            data: {
              rect: b,
              rotation: r
            },
            parent: {
              viewport: {
                rawDims: {
                  pageWidth: G,
                  pageHeight: J,
                  pageX: T,
                  pageY: y
                }
              }
            }
          } = this;
          b?.splice(0, 4, ...B);
          const {
            width: I,
            height: E
          } = F(B);
          X.left = `${100 * (B[0] - T) / G}%`, X.top = `${100 * (J - B[3] + y) / J}%`, r === 0 ? (X.width = `${100 * I / G}%`, X.height = `${100 * E / J}%`) : this.setRotation(r);
        }
        _createContainer(B) {
          const {
            data: X,
            parent: {
              page: b,
              viewport: r
            }
          } = this, G = document.createElement("section");
          G.setAttribute("data-annotation-id", X.id), this instanceof c || (G.tabIndex = Z);
          const {
            style: J
          } = G;
          if (J.zIndex = this.parent.zIndex++, X.popupRef && G.setAttribute("aria-haspopup", "dialog"), X.alternativeText && (G.title = X.alternativeText), X.noRotate && G.classList.add("norotate"), !X.rect || this instanceof k) {
            const {
              rotation: D
            } = X;
            return !X.hasOwnCanvas && D !== 0 && this.setRotation(D, G), G;
          }
          const {
            width: T,
            height: y
          } = F(X.rect);
          if (!B && X.borderStyle.width > 0) {
            J.borderWidth = `${X.borderStyle.width}px`;
            const D = X.borderStyle.horizontalCornerRadius, C = X.borderStyle.verticalCornerRadius;
            if (D > 0 || C > 0) {
              const Fl = `calc(${D}px * var(--scale-factor)) / calc(${C}px * var(--scale-factor))`;
              J.borderRadius = Fl;
            } else if (this instanceof S) {
              const Fl = `calc(${T}px * var(--scale-factor)) / calc(${y}px * var(--scale-factor))`;
              J.borderRadius = Fl;
            }
            switch (X.borderStyle.style) {
              case e.AnnotationBorderStyleType.SOLID:
                J.borderStyle = "solid";
                break;
              case e.AnnotationBorderStyleType.DASHED:
                J.borderStyle = "dashed";
                break;
              case e.AnnotationBorderStyleType.BEVELED:
                (0, e.warn)("Unimplemented border style: beveled");
                break;
              case e.AnnotationBorderStyleType.INSET:
                (0, e.warn)("Unimplemented border style: inset");
                break;
              case e.AnnotationBorderStyleType.UNDERLINE:
                J.borderBottomStyle = "solid";
                break;
            }
            const nl = X.borderColor || null;
            nl ? (this.#t = !0, J.borderColor = e.Util.makeHexColor(nl[0] | 0, nl[1] | 0, nl[2] | 0)) : J.borderWidth = 0;
          }
          const I = e.Util.normalizeRect([X.rect[0], b.view[3] - X.rect[1] + b.view[1], X.rect[2], b.view[3] - X.rect[3] + b.view[1]]), {
            pageWidth: E,
            pageHeight: x,
            pageX: v,
            pageY: A
          } = r.rawDims;
          J.left = `${100 * (I[0] - v) / E}%`, J.top = `${100 * (I[1] - A) / x}%`;
          const {
            rotation: g
          } = X;
          return X.hasOwnCanvas || g === 0 ? (J.width = `${100 * T / E}%`, J.height = `${100 * y / x}%`) : this.setRotation(g, G), G;
        }
        setRotation(B, X = this.container) {
          if (!this.data.rect)
            return;
          const {
            pageWidth: b,
            pageHeight: r
          } = this.parent.viewport.rawDims, {
            width: G,
            height: J
          } = F(this.data.rect);
          let T, y;
          B % 180 === 0 ? (T = 100 * G / b, y = 100 * J / r) : (T = 100 * J / b, y = 100 * G / r), X.style.width = `${T}%`, X.style.height = `${y}%`, X.setAttribute("data-main-rotation", (360 - B) % 360);
        }
        get _commonActions() {
          const B = (X, b, r) => {
            const G = r.detail[X], J = G[0], T = G.slice(1);
            r.target.style[b] = h[`${J}_HTML`](T), this.annotationStorage.setValue(this.data.id, {
              [b]: h[`${J}_rgb`](T)
            });
          };
          return (0, e.shadow)(this, "_commonActions", {
            display: (X) => {
              const {
                display: b
              } = X.detail, r = b % 2 === 1;
              this.container.style.visibility = r ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                noView: r,
                noPrint: b === 1 || b === 2
              });
            },
            print: (X) => {
              this.annotationStorage.setValue(this.data.id, {
                noPrint: !X.detail.print
              });
            },
            hidden: (X) => {
              const {
                hidden: b
              } = X.detail;
              this.container.style.visibility = b ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                noPrint: b,
                noView: b
              });
            },
            focus: (X) => {
              setTimeout(() => X.target.focus({
                preventScroll: !1
              }), 0);
            },
            userName: (X) => {
              X.target.title = X.detail.userName;
            },
            readonly: (X) => {
              X.target.disabled = X.detail.readonly;
            },
            required: (X) => {
              this._setRequired(X.target, X.detail.required);
            },
            bgColor: (X) => {
              B("bgColor", "backgroundColor", X);
            },
            fillColor: (X) => {
              B("fillColor", "backgroundColor", X);
            },
            fgColor: (X) => {
              B("fgColor", "color", X);
            },
            textColor: (X) => {
              B("textColor", "color", X);
            },
            borderColor: (X) => {
              B("borderColor", "borderColor", X);
            },
            strokeColor: (X) => {
              B("strokeColor", "borderColor", X);
            },
            rotation: (X) => {
              const b = X.detail.rotation;
              this.setRotation(b), this.annotationStorage.setValue(this.data.id, {
                rotation: b
              });
            }
          });
        }
        _dispatchEventFromSandbox(B, X) {
          const b = this._commonActions;
          for (const r of Object.keys(X.detail))
            (B[r] || b[r])?.(X);
        }
        _setDefaultPropertiesFromJS(B) {
          if (!this.enableScripting)
            return;
          const X = this.annotationStorage.getRawValue(this.data.id);
          if (!X)
            return;
          const b = this._commonActions;
          for (const [r, G] of Object.entries(X)) {
            const J = b[r];
            if (J) {
              const T = {
                detail: {
                  [r]: G
                },
                target: B
              };
              J(T), delete X[r];
            }
          }
        }
        _createQuadrilaterals() {
          if (!this.container)
            return;
          const {
            quadPoints: B
          } = this.data;
          if (!B)
            return;
          const [X, b, r, G] = this.data.rect;
          if (B.length === 1) {
            const [, {
              x: D,
              y: C
            }, {
              x: nl,
              y: Fl
            }] = B[0];
            if (r === D && G === C && X === nl && b === Fl)
              return;
          }
          const {
            style: J
          } = this.container;
          let T;
          if (this.#t) {
            const {
              borderColor: D,
              borderWidth: C
            } = J;
            J.borderWidth = 0, T = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${D}" stroke-width="${C}">`], this.container.classList.add("hasBorder");
          }
          const y = r - X, I = G - b, {
            svgFactory: E
          } = this, x = E.createElement("svg");
          x.classList.add("quadrilateralsContainer"), x.setAttribute("width", 0), x.setAttribute("height", 0);
          const v = E.createElement("defs");
          x.append(v);
          const A = E.createElement("clipPath"), g = `clippath_${this.data.id}`;
          A.setAttribute("id", g), A.setAttribute("clipPathUnits", "objectBoundingBox"), v.append(A);
          for (const [, {
            x: D,
            y: C
          }, {
            x: nl,
            y: Fl
          }] of B) {
            const sl = E.createElement("rect"), Vl = (nl - X) / y, Rl = (G - C) / I, Wl = (D - nl) / y, ml = (C - Fl) / I;
            sl.setAttribute("x", Vl), sl.setAttribute("y", Rl), sl.setAttribute("width", Wl), sl.setAttribute("height", ml), A.append(sl), T?.push(`<rect vector-effect="non-scaling-stroke" x="${Vl}" y="${Rl}" width="${Wl}" height="${ml}"/>`);
          }
          this.#t && (T.push("</g></svg>')"), J.backgroundImage = T.join("")), this.container.append(x), this.container.style.clipPath = `url(#${g})`;
        }
        _createPopup() {
          const {
            container: B,
            data: X
          } = this;
          B.setAttribute("aria-haspopup", "dialog");
          const b = new k({
            data: {
              color: X.color,
              titleObj: X.titleObj,
              modificationDate: X.modificationDate,
              contentsObj: X.contentsObj,
              richText: X.richText,
              parentRect: X.rect,
              borderStyle: 0,
              id: `popup_${X.id}`,
              rotation: X.rotation
            },
            parent: this.parent,
            elements: [this]
          });
          this.parent.div.append(b.render());
        }
        render() {
          (0, e.unreachable)("Abstract method `AnnotationElement.render` called");
        }
        _getElementsByName(B, X = null) {
          const b = [];
          if (this._fieldObjects) {
            const r = this._fieldObjects[B];
            if (r)
              for (const {
                page: G,
                id: J,
                exportValues: T
              } of r) {
                if (G === -1 || J === X)
                  continue;
                const y = typeof T == "string" ? T : null, I = document.querySelector(`[data-element-id="${J}"]`);
                if (I && !o.has(I)) {
                  (0, e.warn)(`_getElementsByName - element not allowed: ${J}`);
                  continue;
                }
                b.push({
                  id: J,
                  exportValue: y,
                  domElement: I
                });
              }
            return b;
          }
          for (const r of document.getElementsByName(B)) {
            const {
              exportValue: G
            } = r, J = r.getAttribute("data-element-id");
            J !== X && o.has(r) && b.push({
              id: J,
              exportValue: G,
              domElement: r
            });
          }
          return b;
        }
        show() {
          this.container && (this.container.hidden = !1), this.popup?.maybeShow();
        }
        hide() {
          this.container && (this.container.hidden = !0), this.popup?.forceHide();
        }
        getElementsToTriggerPopup() {
          return this.container;
        }
        addHighlightArea() {
          const B = this.getElementsToTriggerPopup();
          if (Array.isArray(B))
            for (const X of B)
              X.classList.add("highlightArea");
          else
            B.classList.add("highlightArea");
        }
        get _isEditable() {
          return !1;
        }
        _editOnDoubleClick() {
          if (!this._isEditable)
            return;
          const {
            annotationEditorType: B,
            data: {
              id: X
            }
          } = this;
          this.container.addEventListener("dblclick", () => {
            this.linkService.eventBus?.dispatch("switchannotationeditormode", {
              source: this,
              mode: B,
              editId: X
            });
          });
        }
      }
      class u extends Q {
        constructor(B, X = null) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !!X?.ignoreBorder,
            createQuadrilaterals: !0
          }), this.isTooltipOnly = B.data.isTooltipOnly;
        }
        render() {
          const {
            data: B,
            linkService: X
          } = this, b = document.createElement("a");
          b.setAttribute("data-element-id", B.id);
          let r = !1;
          return B.url ? (X.addLinkAttributes(b, B.url, B.newWindow), r = !0) : B.action ? (this._bindNamedAction(b, B.action), r = !0) : B.attachment ? (this.#t(b, B.attachment, B.attachmentDest), r = !0) : B.setOCGState ? (this.#n(b, B.setOCGState), r = !0) : B.dest ? (this._bindLink(b, B.dest), r = !0) : (B.actions && (B.actions.Action || B.actions["Mouse Up"] || B.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(b, B), r = !0), B.resetForm ? (this._bindResetFormAction(b, B.resetForm), r = !0) : this.isTooltipOnly && !r && (this._bindLink(b, ""), r = !0)), this.container.classList.add("linkAnnotation"), r && this.container.append(b), this.container;
        }
        #l() {
          this.container.setAttribute("data-internal-link", "");
        }
        _bindLink(B, X) {
          B.href = this.linkService.getDestinationHash(X), B.onclick = () => (X && this.linkService.goToDestination(X), !1), (X || X === "") && this.#l();
        }
        _bindNamedAction(B, X) {
          B.href = this.linkService.getAnchorUrl(""), B.onclick = () => (this.linkService.executeNamedAction(X), !1), this.#l();
        }
        #t(B, X, b = null) {
          B.href = this.linkService.getAnchorUrl(""), B.onclick = () => (this.downloadManager?.openOrDownloadData(X.content, X.filename, b), !1), this.#l();
        }
        #n(B, X) {
          B.href = this.linkService.getAnchorUrl(""), B.onclick = () => (this.linkService.executeSetOCGState(X), !1), this.#l();
        }
        _bindJSAction(B, X) {
          B.href = this.linkService.getAnchorUrl("");
          const b = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
          for (const r of Object.keys(X.actions)) {
            const G = b.get(r);
            G && (B[G] = () => (this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: X.id,
                name: r
              }
            }), !1));
          }
          B.onclick || (B.onclick = () => !1), this.#l();
        }
        _bindResetFormAction(B, X) {
          const b = B.onclick;
          if (b || (B.href = this.linkService.getAnchorUrl("")), this.#l(), !this._fieldObjects) {
            (0, e.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), b || (B.onclick = () => !1);
            return;
          }
          B.onclick = () => {
            b?.();
            const {
              fields: r,
              refs: G,
              include: J
            } = X, T = [];
            if (r.length !== 0 || G.length !== 0) {
              const E = new Set(G);
              for (const x of r) {
                const v = this._fieldObjects[x] || [];
                for (const {
                  id: A
                } of v)
                  E.add(A);
              }
              for (const x of Object.values(this._fieldObjects))
                for (const v of x)
                  E.has(v.id) === J && T.push(v);
            } else
              for (const E of Object.values(this._fieldObjects))
                T.push(...E);
            const y = this.annotationStorage, I = [];
            for (const E of T) {
              const {
                id: x
              } = E;
              switch (I.push(x), E.type) {
                case "text": {
                  const A = E.defaultValue || "";
                  y.setValue(x, {
                    value: A
                  });
                  break;
                }
                case "checkbox":
                case "radiobutton": {
                  const A = E.defaultValue === E.exportValues;
                  y.setValue(x, {
                    value: A
                  });
                  break;
                }
                case "combobox":
                case "listbox": {
                  const A = E.defaultValue || "";
                  y.setValue(x, {
                    value: A
                  });
                  break;
                }
                default:
                  continue;
              }
              const v = document.querySelector(`[data-element-id="${x}"]`);
              if (v) {
                if (!o.has(v)) {
                  (0, e.warn)(`_bindResetFormAction - element not allowed: ${x}`);
                  continue;
                }
              } else
                continue;
              v.dispatchEvent(new Event("resetform"));
            }
            return this.enableScripting && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: "app",
                ids: I,
                name: "ResetForm"
              }
            }), !1;
          };
        }
      }
      class i extends Q {
        constructor(B) {
          super(B, {
            isRenderable: !0
          });
        }
        render() {
          this.container.classList.add("textAnnotation");
          const B = document.createElement("img");
          return B.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", B.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), B.setAttribute("data-l10n-args", JSON.stringify({
            type: this.data.name
          })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(B), this.container;
        }
      }
      class c extends Q {
        render() {
          return this.container;
        }
        showElementAndHideCanvas(B) {
          this.data.hasOwnCanvas && (B.previousSibling?.nodeName === "CANVAS" && (B.previousSibling.hidden = !0), B.hidden = !1);
        }
        _getKeyModifier(B) {
          return e.FeatureTest.platform.isMac ? B.metaKey : B.ctrlKey;
        }
        _setEventListener(B, X, b, r, G) {
          b.includes("mouse") ? B.addEventListener(b, (J) => {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: this.data.id,
                name: r,
                value: G(J),
                shift: J.shiftKey,
                modifier: this._getKeyModifier(J)
              }
            });
          }) : B.addEventListener(b, (J) => {
            if (b === "blur") {
              if (!X.focused || !J.relatedTarget)
                return;
              X.focused = !1;
            } else if (b === "focus") {
              if (X.focused)
                return;
              X.focused = !0;
            }
            G && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: this.data.id,
                name: r,
                value: G(J)
              }
            });
          });
        }
        _setEventListeners(B, X, b, r) {
          for (const [G, J] of b)
            (J === "Action" || this.data.actions?.[J]) && ((J === "Focus" || J === "Blur") && (X ||= {
              focused: !1
            }), this._setEventListener(B, X, G, J, r), J === "Focus" && !this.data.actions?.Blur ? this._setEventListener(B, X, "blur", "Blur", null) : J === "Blur" && !this.data.actions?.Focus && this._setEventListener(B, X, "focus", "Focus", null));
        }
        _setBackgroundColor(B) {
          const X = this.data.backgroundColor || null;
          B.style.backgroundColor = X === null ? "transparent" : e.Util.makeHexColor(X[0], X[1], X[2]);
        }
        _setTextStyle(B) {
          const X = ["left", "center", "right"], {
            fontColor: b
          } = this.data.defaultAppearanceData, r = this.data.defaultAppearanceData.fontSize || s, G = B.style;
          let J;
          const T = 2, y = (I) => Math.round(10 * I) / 10;
          if (this.data.multiLine) {
            const I = Math.abs(this.data.rect[3] - this.data.rect[1] - T), E = Math.round(I / (e.LINE_FACTOR * r)) || 1, x = I / E;
            J = Math.min(r, y(x / e.LINE_FACTOR));
          } else {
            const I = Math.abs(this.data.rect[3] - this.data.rect[1] - T);
            J = Math.min(r, y(I / e.LINE_FACTOR));
          }
          G.fontSize = `calc(${J}px * var(--scale-factor))`, G.color = e.Util.makeHexColor(b[0], b[1], b[2]), this.data.textAlignment !== null && (G.textAlign = X[this.data.textAlignment]);
        }
        _setRequired(B, X) {
          X ? B.setAttribute("required", !0) : B.removeAttribute("required"), B.setAttribute("aria-required", X);
        }
      }
      class R extends c {
        constructor(B) {
          const X = B.renderForms || B.data.hasOwnCanvas || !B.data.hasAppearance && !!B.data.fieldValue;
          super(B, {
            isRenderable: X
          });
        }
        setPropertyOnSiblings(B, X, b, r) {
          const G = this.annotationStorage;
          for (const J of this._getElementsByName(B.name, B.id))
            J.domElement && (J.domElement[X] = b), G.setValue(J.id, {
              [r]: b
            });
        }
        render() {
          const B = this.annotationStorage, X = this.data.id;
          this.container.classList.add("textWidgetAnnotation");
          let b = null;
          if (this.renderForms) {
            const r = B.getValue(X, {
              value: this.data.fieldValue
            });
            let G = r.value || "";
            const J = B.getValue(X, {
              charLimit: this.data.maxLen
            }).charLimit;
            J && G.length > J && (G = G.slice(0, J));
            let T = r.formattedValue || this.data.textContent?.join(`
`) || null;
            T && this.data.comb && (T = T.replaceAll(/\s+/g, ""));
            const y = {
              userValue: G,
              formattedValue: T,
              lastCommittedValue: null,
              commitKey: 1,
              focused: !1
            };
            this.data.multiLine ? (b = document.createElement("textarea"), b.textContent = T ?? G, this.data.doNotScroll && (b.style.overflowY = "hidden")) : (b = document.createElement("input"), b.type = "text", b.setAttribute("value", T ?? G), this.data.doNotScroll && (b.style.overflowX = "hidden")), this.data.hasOwnCanvas && (b.hidden = !0), o.add(b), b.setAttribute("data-element-id", X), b.disabled = this.data.readOnly, b.name = this.data.fieldName, b.tabIndex = Z, this._setRequired(b, this.data.required), J && (b.maxLength = J), b.addEventListener("input", (E) => {
              B.setValue(X, {
                value: E.target.value
              }), this.setPropertyOnSiblings(b, "value", E.target.value, "value"), y.formattedValue = null;
            }), b.addEventListener("resetform", (E) => {
              const x = this.data.defaultFieldValue ?? "";
              b.value = y.userValue = x, y.formattedValue = null;
            });
            let I = (E) => {
              const {
                formattedValue: x
              } = y;
              x != null && (E.target.value = x), E.target.scrollLeft = 0;
            };
            if (this.enableScripting && this.hasJSActions) {
              b.addEventListener("focus", (x) => {
                if (y.focused)
                  return;
                const {
                  target: v
                } = x;
                y.userValue && (v.value = y.userValue), y.lastCommittedValue = v.value, y.commitKey = 1, this.data.actions?.Focus || (y.focused = !0);
              }), b.addEventListener("updatefromsandbox", (x) => {
                this.showElementAndHideCanvas(x.target);
                const v = {
                  value(A) {
                    y.userValue = A.detail.value ?? "", B.setValue(X, {
                      value: y.userValue.toString()
                    }), A.target.value = y.userValue;
                  },
                  formattedValue(A) {
                    const {
                      formattedValue: g
                    } = A.detail;
                    y.formattedValue = g, g != null && A.target !== document.activeElement && (A.target.value = g), B.setValue(X, {
                      formattedValue: g
                    });
                  },
                  selRange(A) {
                    A.target.setSelectionRange(...A.detail.selRange);
                  },
                  charLimit: (A) => {
                    const {
                      charLimit: g
                    } = A.detail, {
                      target: D
                    } = A;
                    if (g === 0) {
                      D.removeAttribute("maxLength");
                      return;
                    }
                    D.setAttribute("maxLength", g);
                    let C = y.userValue;
                    !C || C.length <= g || (C = C.slice(0, g), D.value = y.userValue = C, B.setValue(X, {
                      value: C
                    }), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: X,
                        name: "Keystroke",
                        value: C,
                        willCommit: !0,
                        commitKey: 1,
                        selStart: D.selectionStart,
                        selEnd: D.selectionEnd
                      }
                    }));
                  }
                };
                this._dispatchEventFromSandbox(v, x);
              }), b.addEventListener("keydown", (x) => {
                y.commitKey = 1;
                let v = -1;
                if (x.key === "Escape" ? v = 0 : x.key === "Enter" && !this.data.multiLine ? v = 2 : x.key === "Tab" && (y.commitKey = 3), v === -1)
                  return;
                const {
                  value: A
                } = x.target;
                y.lastCommittedValue !== A && (y.lastCommittedValue = A, y.userValue = A, this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: X,
                    name: "Keystroke",
                    value: A,
                    willCommit: !0,
                    commitKey: v,
                    selStart: x.target.selectionStart,
                    selEnd: x.target.selectionEnd
                  }
                }));
              });
              const E = I;
              I = null, b.addEventListener("blur", (x) => {
                if (!y.focused || !x.relatedTarget)
                  return;
                this.data.actions?.Blur || (y.focused = !1);
                const {
                  value: v
                } = x.target;
                y.userValue = v, y.lastCommittedValue !== v && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: X,
                    name: "Keystroke",
                    value: v,
                    willCommit: !0,
                    commitKey: y.commitKey,
                    selStart: x.target.selectionStart,
                    selEnd: x.target.selectionEnd
                  }
                }), E(x);
              }), this.data.actions?.Keystroke && b.addEventListener("beforeinput", (x) => {
                y.lastCommittedValue = null;
                const {
                  data: v,
                  target: A
                } = x, {
                  value: g,
                  selectionStart: D,
                  selectionEnd: C
                } = A;
                let nl = D, Fl = C;
                switch (x.inputType) {
                  case "deleteWordBackward": {
                    const sl = g.substring(0, D).match(/\w*[^\w]*$/);
                    sl && (nl -= sl[0].length);
                    break;
                  }
                  case "deleteWordForward": {
                    const sl = g.substring(D).match(/^[^\w]*\w*/);
                    sl && (Fl += sl[0].length);
                    break;
                  }
                  case "deleteContentBackward":
                    D === C && (nl -= 1);
                    break;
                  case "deleteContentForward":
                    D === C && (Fl += 1);
                    break;
                }
                x.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: X,
                    name: "Keystroke",
                    value: g,
                    change: v || "",
                    willCommit: !1,
                    selStart: nl,
                    selEnd: Fl
                  }
                });
              }), this._setEventListeners(b, y, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (x) => x.target.value);
            }
            if (I && b.addEventListener("blur", I), this.data.comb) {
              const x = (this.data.rect[2] - this.data.rect[0]) / J;
              b.classList.add("comb"), b.style.letterSpacing = `calc(${x}px * var(--scale-factor) - 1ch)`;
            }
          } else
            b = document.createElement("div"), b.textContent = this.data.fieldValue, b.style.verticalAlign = "middle", b.style.display = "table-cell", this.data.hasOwnCanvas && (b.hidden = !0);
          return this._setTextStyle(b), this._setBackgroundColor(b), this._setDefaultPropertiesFromJS(b), this.container.append(b), this.container;
        }
      }
      class m extends c {
        constructor(B) {
          super(B, {
            isRenderable: !!B.data.hasOwnCanvas
          });
        }
      }
      class M extends c {
        constructor(B) {
          super(B, {
            isRenderable: B.renderForms
          });
        }
        render() {
          const B = this.annotationStorage, X = this.data, b = X.id;
          let r = B.getValue(b, {
            value: X.exportValue === X.fieldValue
          }).value;
          typeof r == "string" && (r = r !== "Off", B.setValue(b, {
            value: r
          })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
          const G = document.createElement("input");
          return o.add(G), G.setAttribute("data-element-id", b), G.disabled = X.readOnly, this._setRequired(G, this.data.required), G.type = "checkbox", G.name = X.fieldName, r && G.setAttribute("checked", !0), G.setAttribute("exportValue", X.exportValue), G.tabIndex = Z, G.addEventListener("change", (J) => {
            const {
              name: T,
              checked: y
            } = J.target;
            for (const I of this._getElementsByName(T, b)) {
              const E = y && I.exportValue === X.exportValue;
              I.domElement && (I.domElement.checked = E), B.setValue(I.id, {
                value: E
              });
            }
            B.setValue(b, {
              value: y
            });
          }), G.addEventListener("resetform", (J) => {
            const T = X.defaultFieldValue || "Off";
            J.target.checked = T === X.exportValue;
          }), this.enableScripting && this.hasJSActions && (G.addEventListener("updatefromsandbox", (J) => {
            const T = {
              value(y) {
                y.target.checked = y.detail.value !== "Off", B.setValue(b, {
                  value: y.target.checked
                });
              }
            };
            this._dispatchEventFromSandbox(T, J);
          }), this._setEventListeners(G, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (J) => J.target.checked)), this._setBackgroundColor(G), this._setDefaultPropertiesFromJS(G), this.container.append(G), this.container;
        }
      }
      class S extends c {
        constructor(B) {
          super(B, {
            isRenderable: B.renderForms
          });
        }
        render() {
          this.container.classList.add("buttonWidgetAnnotation", "radioButton");
          const B = this.annotationStorage, X = this.data, b = X.id;
          let r = B.getValue(b, {
            value: X.fieldValue === X.buttonValue
          }).value;
          if (typeof r == "string" && (r = r !== X.buttonValue, B.setValue(b, {
            value: r
          })), r)
            for (const J of this._getElementsByName(X.fieldName, b))
              B.setValue(J.id, {
                value: !1
              });
          const G = document.createElement("input");
          if (o.add(G), G.setAttribute("data-element-id", b), G.disabled = X.readOnly, this._setRequired(G, this.data.required), G.type = "radio", G.name = X.fieldName, r && G.setAttribute("checked", !0), G.tabIndex = Z, G.addEventListener("change", (J) => {
            const {
              name: T,
              checked: y
            } = J.target;
            for (const I of this._getElementsByName(T, b))
              B.setValue(I.id, {
                value: !1
              });
            B.setValue(b, {
              value: y
            });
          }), G.addEventListener("resetform", (J) => {
            const T = X.defaultFieldValue;
            J.target.checked = T != null && T === X.buttonValue;
          }), this.enableScripting && this.hasJSActions) {
            const J = X.buttonValue;
            G.addEventListener("updatefromsandbox", (T) => {
              const y = {
                value: (I) => {
                  const E = J === I.detail.value;
                  for (const x of this._getElementsByName(I.target.name)) {
                    const v = E && x.id === b;
                    x.domElement && (x.domElement.checked = v), B.setValue(x.id, {
                      value: v
                    });
                  }
                }
              };
              this._dispatchEventFromSandbox(y, T);
            }), this._setEventListeners(G, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (T) => T.target.checked);
          }
          return this._setBackgroundColor(G), this._setDefaultPropertiesFromJS(G), this.container.append(G), this.container;
        }
      }
      class p extends u {
        constructor(B) {
          super(B, {
            ignoreBorder: B.data.hasAppearance
          });
        }
        render() {
          const B = super.render();
          B.classList.add("buttonWidgetAnnotation", "pushButton");
          const X = B.lastChild;
          return this.enableScripting && this.hasJSActions && X && (this._setDefaultPropertiesFromJS(X), X.addEventListener("updatefromsandbox", (b) => {
            this._dispatchEventFromSandbox({}, b);
          })), B;
        }
      }
      class Y extends c {
        constructor(B) {
          super(B, {
            isRenderable: B.renderForms
          });
        }
        render() {
          this.container.classList.add("choiceWidgetAnnotation");
          const B = this.annotationStorage, X = this.data.id, b = B.getValue(X, {
            value: this.data.fieldValue
          }), r = document.createElement("select");
          o.add(r), r.setAttribute("data-element-id", X), r.disabled = this.data.readOnly, this._setRequired(r, this.data.required), r.name = this.data.fieldName, r.tabIndex = Z;
          let G = this.data.combo && this.data.options.length > 0;
          this.data.combo || (r.size = this.data.options.length, this.data.multiSelect && (r.multiple = !0)), r.addEventListener("resetform", (E) => {
            const x = this.data.defaultFieldValue;
            for (const v of r.options)
              v.selected = v.value === x;
          });
          for (const E of this.data.options) {
            const x = document.createElement("option");
            x.textContent = E.displayValue, x.value = E.exportValue, b.value.includes(E.exportValue) && (x.setAttribute("selected", !0), G = !1), r.append(x);
          }
          let J = null;
          if (G) {
            const E = document.createElement("option");
            E.value = " ", E.setAttribute("hidden", !0), E.setAttribute("selected", !0), r.prepend(E), J = () => {
              E.remove(), r.removeEventListener("input", J), J = null;
            }, r.addEventListener("input", J);
          }
          const T = (E) => {
            const x = E ? "value" : "textContent", {
              options: v,
              multiple: A
            } = r;
            return A ? Array.prototype.filter.call(v, (g) => g.selected).map((g) => g[x]) : v.selectedIndex === -1 ? null : v[v.selectedIndex][x];
          };
          let y = T(!1);
          const I = (E) => {
            const x = E.target.options;
            return Array.prototype.map.call(x, (v) => ({
              displayValue: v.textContent,
              exportValue: v.value
            }));
          };
          return this.enableScripting && this.hasJSActions ? (r.addEventListener("updatefromsandbox", (E) => {
            const x = {
              value(v) {
                J?.();
                const A = v.detail.value, g = new Set(Array.isArray(A) ? A : [A]);
                for (const D of r.options)
                  D.selected = g.has(D.value);
                B.setValue(X, {
                  value: T(!0)
                }), y = T(!1);
              },
              multipleSelection(v) {
                r.multiple = !0;
              },
              remove(v) {
                const A = r.options, g = v.detail.remove;
                A[g].selected = !1, r.remove(g), A.length > 0 && Array.prototype.findIndex.call(A, (C) => C.selected) === -1 && (A[0].selected = !0), B.setValue(X, {
                  value: T(!0),
                  items: I(v)
                }), y = T(!1);
              },
              clear(v) {
                for (; r.length !== 0; )
                  r.remove(0);
                B.setValue(X, {
                  value: null,
                  items: []
                }), y = T(!1);
              },
              insert(v) {
                const {
                  index: A,
                  displayValue: g,
                  exportValue: D
                } = v.detail.insert, C = r.children[A], nl = document.createElement("option");
                nl.textContent = g, nl.value = D, C ? C.before(nl) : r.append(nl), B.setValue(X, {
                  value: T(!0),
                  items: I(v)
                }), y = T(!1);
              },
              items(v) {
                const {
                  items: A
                } = v.detail;
                for (; r.length !== 0; )
                  r.remove(0);
                for (const g of A) {
                  const {
                    displayValue: D,
                    exportValue: C
                  } = g, nl = document.createElement("option");
                  nl.textContent = D, nl.value = C, r.append(nl);
                }
                r.options.length > 0 && (r.options[0].selected = !0), B.setValue(X, {
                  value: T(!0),
                  items: I(v)
                }), y = T(!1);
              },
              indices(v) {
                const A = new Set(v.detail.indices);
                for (const g of v.target.options)
                  g.selected = A.has(g.index);
                B.setValue(X, {
                  value: T(!0)
                }), y = T(!1);
              },
              editable(v) {
                v.target.disabled = !v.detail.editable;
              }
            };
            this._dispatchEventFromSandbox(x, E);
          }), r.addEventListener("input", (E) => {
            const x = T(!0), v = T(!1);
            B.setValue(X, {
              value: x
            }), E.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: X,
                name: "Keystroke",
                value: y,
                change: v,
                changeEx: x,
                willCommit: !1,
                commitKey: 1,
                keyDown: !1
              }
            });
          }), this._setEventListeners(r, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (E) => E.target.value)) : r.addEventListener("input", function(E) {
            B.setValue(X, {
              value: T(!0)
            });
          }), this.data.combo && this._setTextStyle(r), this._setBackgroundColor(r), this._setDefaultPropertiesFromJS(r), this.container.append(r), this.container;
        }
      }
      class k extends Q {
        constructor(B) {
          const {
            data: X,
            elements: b
          } = B;
          super(B, {
            isRenderable: Q._hasPopupData(X)
          }), this.elements = b;
        }
        render() {
          this.container.classList.add("popupAnnotation");
          const B = new L({
            container: this.container,
            color: this.data.color,
            titleObj: this.data.titleObj,
            modificationDate: this.data.modificationDate,
            contentsObj: this.data.contentsObj,
            richText: this.data.richText,
            rect: this.data.rect,
            parentRect: this.data.parentRect || null,
            parent: this.parent,
            elements: this.elements,
            open: this.data.open
          }), X = [];
          for (const b of this.elements)
            b.popup = B, X.push(b.data.id), b.addHighlightArea();
          return this.container.setAttribute("aria-controls", X.map((b) => `${e.AnnotationPrefix}${b}`).join(",")), this.container;
        }
      }
      class L {
        #l = this.#h.bind(this);
        #t = this.#M.bind(this);
        #n = this.#m.bind(this);
        #d = this.#N.bind(this);
        #a = null;
        #e = null;
        #i = null;
        #U = null;
        #c = null;
        #Z = null;
        #o = null;
        #F = !1;
        #s = null;
        #Q = null;
        #W = null;
        #V = null;
        #R = !1;
        constructor({
          container: B,
          color: X,
          elements: b,
          titleObj: r,
          modificationDate: G,
          contentsObj: J,
          richText: T,
          parent: y,
          rect: I,
          parentRect: E,
          open: x
        }) {
          this.#e = B, this.#V = r, this.#i = J, this.#W = T, this.#Z = y, this.#a = X, this.#Q = I, this.#o = E, this.#c = b, this.#U = d.PDFDateString.toDateObject(G), this.trigger = b.flatMap((v) => v.getElementsToTriggerPopup());
          for (const v of this.trigger)
            v.addEventListener("click", this.#d), v.addEventListener("mouseenter", this.#n), v.addEventListener("mouseleave", this.#t), v.classList.add("popupTriggerArea");
          for (const v of b)
            v.container?.addEventListener("keydown", this.#l);
          this.#e.hidden = !0, x && this.#N();
        }
        render() {
          if (this.#s)
            return;
          const {
            page: {
              view: B
            },
            viewport: {
              rawDims: {
                pageWidth: X,
                pageHeight: b,
                pageX: r,
                pageY: G
              }
            }
          } = this.#Z, J = this.#s = document.createElement("div");
          if (J.className = "popup", this.#a) {
            const sl = J.style.outlineColor = e.Util.makeHexColor(...this.#a);
            CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? J.style.backgroundColor = `color-mix(in srgb, ${sl} 30%, white)` : J.style.backgroundColor = e.Util.makeHexColor(...this.#a.map((Rl) => Math.floor(0.7 * (255 - Rl) + Rl)));
          }
          const T = document.createElement("span");
          T.className = "header";
          const y = document.createElement("h1");
          if (T.append(y), {
            dir: y.dir,
            str: y.textContent
          } = this.#V, J.append(T), this.#U) {
            const sl = document.createElement("span");
            sl.classList.add("popupDate"), sl.setAttribute("data-l10n-id", "pdfjs-annotation-date-string"), sl.setAttribute("data-l10n-args", JSON.stringify({
              date: this.#U.toLocaleDateString(),
              time: this.#U.toLocaleTimeString()
            })), T.append(sl);
          }
          const I = this.#i, E = this.#W;
          if (E?.str && (!I?.str || I.str === E.str))
            W.XfaLayer.render({
              xfaHtml: E.html,
              intent: "richText",
              div: J
            }), J.lastChild.classList.add("richText", "popupContent");
          else {
            const sl = this._formatContents(I);
            J.append(sl);
          }
          let x = !!this.#o, v = x ? this.#o : this.#Q;
          for (const sl of this.#c)
            if (!v || e.Util.intersect(sl.data.rect, v) !== null) {
              v = sl.data.rect, x = !0;
              break;
            }
          const A = e.Util.normalizeRect([v[0], B[3] - v[1] + B[1], v[2], B[3] - v[3] + B[1]]), D = x ? v[2] - v[0] + 5 : 0, C = A[0] + D, nl = A[1], {
            style: Fl
          } = this.#e;
          Fl.left = `${100 * (C - r) / X}%`, Fl.top = `${100 * (nl - G) / b}%`, this.#e.append(J);
        }
        _formatContents({
          str: B,
          dir: X
        }) {
          const b = document.createElement("p");
          b.classList.add("popupContent"), b.dir = X;
          const r = B.split(/(?:\r\n?|\n)/);
          for (let G = 0, J = r.length; G < J; ++G) {
            const T = r[G];
            b.append(document.createTextNode(T)), G < J - 1 && b.append(document.createElement("br"));
          }
          return b;
        }
        #h(B) {
          B.altKey || B.shiftKey || B.ctrlKey || B.metaKey || (B.key === "Enter" || B.key === "Escape" && this.#F) && this.#N();
        }
        #N() {
          this.#F = !this.#F, this.#F ? (this.#m(), this.#e.addEventListener("click", this.#d), this.#e.addEventListener("keydown", this.#l)) : (this.#M(), this.#e.removeEventListener("click", this.#d), this.#e.removeEventListener("keydown", this.#l));
        }
        #m() {
          this.#s || this.render(), this.isVisible ? this.#F && this.#e.classList.add("focused") : (this.#e.hidden = !1, this.#e.style.zIndex = parseInt(this.#e.style.zIndex) + 1e3);
        }
        #M() {
          this.#e.classList.remove("focused"), !(this.#F || !this.isVisible) && (this.#e.hidden = !0, this.#e.style.zIndex = parseInt(this.#e.style.zIndex) - 1e3);
        }
        forceHide() {
          this.#R = this.isVisible, this.#R && (this.#e.hidden = !0);
        }
        maybeShow() {
          this.#R && (this.#R = !1, this.#e.hidden = !1);
        }
        get isVisible() {
          return this.#e.hidden === !1;
        }
      }
      class z extends Q {
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0
          }), this.textContent = B.data.textContent, this.textPosition = B.data.textPosition, this.annotationEditorType = e.AnnotationEditorType.FREETEXT;
        }
        render() {
          if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
            const B = document.createElement("div");
            B.classList.add("annotationTextContent"), B.setAttribute("role", "comment");
            for (const X of this.textContent) {
              const b = document.createElement("span");
              b.textContent = X, B.append(b);
            }
            this.container.append(B);
          }
          return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
        }
        get _isEditable() {
          return this.data.hasOwnCanvas;
        }
      }
      class f extends Q {
        #l = null;
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0
          });
        }
        render() {
          this.container.classList.add("lineAnnotation");
          const B = this.data, {
            width: X,
            height: b
          } = F(B.rect), r = this.svgFactory.create(X, b, !0), G = this.#l = this.svgFactory.createElement("svg:line");
          return G.setAttribute("x1", B.rect[2] - B.lineCoordinates[0]), G.setAttribute("y1", B.rect[3] - B.lineCoordinates[1]), G.setAttribute("x2", B.rect[2] - B.lineCoordinates[2]), G.setAttribute("y2", B.rect[3] - B.lineCoordinates[3]), G.setAttribute("stroke-width", B.borderStyle.width || 1), G.setAttribute("stroke", "transparent"), G.setAttribute("fill", "transparent"), r.append(G), this.container.append(r), !B.popupRef && this.hasPopupData && this._createPopup(), this.container;
        }
        getElementsToTriggerPopup() {
          return this.#l;
        }
        addHighlightArea() {
          this.container.classList.add("highlightArea");
        }
      }
      class K extends Q {
        #l = null;
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0
          });
        }
        render() {
          this.container.classList.add("squareAnnotation");
          const B = this.data, {
            width: X,
            height: b
          } = F(B.rect), r = this.svgFactory.create(X, b, !0), G = B.borderStyle.width, J = this.#l = this.svgFactory.createElement("svg:rect");
          return J.setAttribute("x", G / 2), J.setAttribute("y", G / 2), J.setAttribute("width", X - G), J.setAttribute("height", b - G), J.setAttribute("stroke-width", G || 1), J.setAttribute("stroke", "transparent"), J.setAttribute("fill", "transparent"), r.append(J), this.container.append(r), !B.popupRef && this.hasPopupData && this._createPopup(), this.container;
        }
        getElementsToTriggerPopup() {
          return this.#l;
        }
        addHighlightArea() {
          this.container.classList.add("highlightArea");
        }
      }
      class P extends Q {
        #l = null;
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0
          });
        }
        render() {
          this.container.classList.add("circleAnnotation");
          const B = this.data, {
            width: X,
            height: b
          } = F(B.rect), r = this.svgFactory.create(X, b, !0), G = B.borderStyle.width, J = this.#l = this.svgFactory.createElement("svg:ellipse");
          return J.setAttribute("cx", X / 2), J.setAttribute("cy", b / 2), J.setAttribute("rx", X / 2 - G / 2), J.setAttribute("ry", b / 2 - G / 2), J.setAttribute("stroke-width", G || 1), J.setAttribute("stroke", "transparent"), J.setAttribute("fill", "transparent"), r.append(J), this.container.append(r), !B.popupRef && this.hasPopupData && this._createPopup(), this.container;
        }
        getElementsToTriggerPopup() {
          return this.#l;
        }
        addHighlightArea() {
          this.container.classList.add("highlightArea");
        }
      }
      class w extends Q {
        #l = null;
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0
          }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
        }
        render() {
          this.container.classList.add(this.containerClassName);
          const B = this.data, {
            width: X,
            height: b
          } = F(B.rect), r = this.svgFactory.create(X, b, !0);
          let G = [];
          for (const T of B.vertices) {
            const y = T.x - B.rect[0], I = B.rect[3] - T.y;
            G.push(y + "," + I);
          }
          G = G.join(" ");
          const J = this.#l = this.svgFactory.createElement(this.svgElementName);
          return J.setAttribute("points", G), J.setAttribute("stroke-width", B.borderStyle.width || 1), J.setAttribute("stroke", "transparent"), J.setAttribute("fill", "transparent"), r.append(J), this.container.append(r), !B.popupRef && this.hasPopupData && this._createPopup(), this.container;
        }
        getElementsToTriggerPopup() {
          return this.#l;
        }
        addHighlightArea() {
          this.container.classList.add("highlightArea");
        }
      }
      class O extends w {
        constructor(B) {
          super(B), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
        }
      }
      class el extends Q {
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0
          });
        }
        render() {
          return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
        }
      }
      class ll extends Q {
        #l = [];
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0
          }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = e.AnnotationEditorType.INK;
        }
        render() {
          this.container.classList.add(this.containerClassName);
          const B = this.data, {
            width: X,
            height: b
          } = F(B.rect), r = this.svgFactory.create(X, b, !0);
          for (const G of B.inkLists) {
            let J = [];
            for (const y of G) {
              const I = y.x - B.rect[0], E = B.rect[3] - y.y;
              J.push(`${I},${E}`);
            }
            J = J.join(" ");
            const T = this.svgFactory.createElement(this.svgElementName);
            this.#l.push(T), T.setAttribute("points", J), T.setAttribute("stroke-width", B.borderStyle.width || 1), T.setAttribute("stroke", "transparent"), T.setAttribute("fill", "transparent"), !B.popupRef && this.hasPopupData && this._createPopup(), r.append(T);
          }
          return this.container.append(r), this.container;
        }
        getElementsToTriggerPopup() {
          return this.#l;
        }
        addHighlightArea() {
          this.container.classList.add("highlightArea");
        }
      }
      class q extends Q {
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0
          });
        }
        render() {
          return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
        }
      }
      class _ extends Q {
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0
          });
        }
        render() {
          return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
        }
      }
      class il extends Q {
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0
          });
        }
        render() {
          return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
        }
      }
      class dl extends Q {
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0,
            createQuadrilaterals: !0
          });
        }
        render() {
          return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
        }
      }
      class tl extends Q {
        constructor(B) {
          super(B, {
            isRenderable: !0,
            ignoreBorder: !0
          });
        }
        render() {
          return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
        }
      }
      class al extends Q {
        #l = null;
        constructor(B) {
          super(B, {
            isRenderable: !0
          });
          const {
            filename: X,
            content: b
          } = this.data.file;
          this.filename = (0, d.getFilenameFromUrl)(X, !0), this.content = b, this.linkService.eventBus?.dispatch("fileattachmentannotation", {
            source: this,
            filename: X,
            content: b
          });
        }
        render() {
          this.container.classList.add("fileAttachmentAnnotation");
          const {
            container: B,
            data: X
          } = this;
          let b;
          X.hasAppearance || X.fillAlpha === 0 ? b = document.createElement("div") : (b = document.createElement("img"), b.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(X.name) ? "paperclip" : "pushpin"}.svg`, X.fillAlpha && X.fillAlpha < 1 && (b.style = `filter: opacity(${Math.round(X.fillAlpha * 100)}%);`)), b.addEventListener("dblclick", this.#t.bind(this)), this.#l = b;
          const {
            isMac: r
          } = e.FeatureTest.platform;
          return B.addEventListener("keydown", (G) => {
            G.key === "Enter" && (r ? G.metaKey : G.ctrlKey) && this.#t();
          }), !X.popupRef && this.hasPopupData ? this._createPopup() : b.classList.add("popupTriggerArea"), B.append(b), B;
        }
        getElementsToTriggerPopup() {
          return this.#l;
        }
        addHighlightArea() {
          this.container.classList.add("highlightArea");
        }
        #t() {
          this.downloadManager?.openOrDownloadData(this.content, this.filename);
        }
      }
      class Ul {
        #l = null;
        #t = null;
        #n = /* @__PURE__ */ new Map();
        constructor({
          div: B,
          accessibilityManager: X,
          annotationCanvasMap: b,
          annotationEditorUIManager: r,
          page: G,
          viewport: J
        }) {
          this.div = B, this.#l = X, this.#t = b, this.page = G, this.viewport = J, this.zIndex = 0, this._annotationEditorUIManager = r;
        }
        #d(B, X) {
          const b = B.firstChild || B;
          b.id = `${e.AnnotationPrefix}${X}`, this.div.append(B), this.#l?.moveElementInDOM(this.div, B, b, !1);
        }
        async render(B) {
          const {
            annotations: X
          } = B, b = this.div;
          (0, d.setLayerDimensions)(b, this.viewport);
          const r = /* @__PURE__ */ new Map(), G = {
            data: null,
            layer: b,
            linkService: B.linkService,
            downloadManager: B.downloadManager,
            imageResourcesPath: B.imageResourcesPath || "",
            renderForms: B.renderForms !== !1,
            svgFactory: new d.DOMSVGFactory(),
            annotationStorage: B.annotationStorage || new a.AnnotationStorage(),
            enableScripting: B.enableScripting === !0,
            hasJSActions: B.hasJSActions,
            fieldObjects: B.fieldObjects,
            parent: this,
            elements: null
          };
          for (const J of X) {
            if (J.noHTML)
              continue;
            const T = J.annotationType === e.AnnotationType.POPUP;
            if (T) {
              const E = r.get(J.id);
              if (!E)
                continue;
              G.elements = E;
            } else {
              const {
                width: E,
                height: x
              } = F(J.rect);
              if (E <= 0 || x <= 0)
                continue;
            }
            G.data = J;
            const y = N.create(G);
            if (!y.isRenderable)
              continue;
            if (!T && J.popupRef) {
              const E = r.get(J.popupRef);
              E ? E.push(y) : r.set(J.popupRef, [y]);
            }
            const I = y.render();
            J.hidden && (I.style.visibility = "hidden"), this.#d(I, J.id), y.annotationEditorType > 0 && (this.#n.set(y.data.id, y), this._annotationEditorUIManager?.renderAnnotationElement(y));
          }
          this.#a();
        }
        update({
          viewport: B
        }) {
          const X = this.div;
          this.viewport = B, (0, d.setLayerDimensions)(X, {
            rotation: B.rotation
          }), this.#a(), X.hidden = !1;
        }
        #a() {
          if (!this.#t)
            return;
          const B = this.div;
          for (const [X, b] of this.#t) {
            const r = B.querySelector(`[data-annotation-id="${X}"]`);
            if (!r)
              continue;
            b.className = "annotationContent";
            const {
              firstChild: G
            } = r;
            G ? G.nodeName === "CANVAS" ? G.replaceWith(b) : G.classList.contains("annotationContent") ? G.after(b) : G.before(b) : r.append(b);
          }
          this.#t.clear();
        }
        getEditableAnnotations() {
          return Array.from(this.#n.values());
        }
        getEditableAnnotation(B) {
          return this.#n.get(B);
        }
      }
    }
  ),
  /***/
  792: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        AnnotationStorage: () => (
          /* binding */
          V
        ),
        /* harmony export */
        PrintAnnotationStorage: () => (
          /* binding */
          h
        ),
        /* harmony export */
        SerializableEmpty: () => (
          /* binding */
          U
        )
        /* harmony export */
      });
      var e = n(292), d = n(310), a = n(651);
      const U = Object.freeze({
        map: null,
        hash: "",
        transfer: void 0
      });
      class V {
        #l = !1;
        #t = /* @__PURE__ */ new Map();
        constructor() {
          this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
        }
        getValue(Z, s) {
          const o = this.#t.get(Z);
          return o === void 0 ? s : Object.assign(s, o);
        }
        getRawValue(Z) {
          return this.#t.get(Z);
        }
        remove(Z) {
          if (this.#t.delete(Z), this.#t.size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
            for (const s of this.#t.values())
              if (s instanceof d.AnnotationEditor)
                return;
            this.onAnnotationEditor(null);
          }
        }
        setValue(Z, s) {
          const o = this.#t.get(Z);
          let F = !1;
          if (o !== void 0)
            for (const [N, Q] of Object.entries(s))
              o[N] !== Q && (F = !0, o[N] = Q);
          else
            F = !0, this.#t.set(Z, s);
          F && this.#n(), s instanceof d.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(s.constructor._type);
        }
        has(Z) {
          return this.#t.has(Z);
        }
        getAll() {
          return this.#t.size > 0 ? (0, e.objectFromMap)(this.#t) : null;
        }
        setAll(Z) {
          for (const [s, o] of Object.entries(Z))
            this.setValue(s, o);
        }
        get size() {
          return this.#t.size;
        }
        #n() {
          this.#l || (this.#l = !0, typeof this.onSetModified == "function" && this.onSetModified());
        }
        resetModified() {
          this.#l && (this.#l = !1, typeof this.onResetModified == "function" && this.onResetModified());
        }
        get print() {
          return new h(this);
        }
        get serializable() {
          if (this.#t.size === 0)
            return U;
          const Z = /* @__PURE__ */ new Map(), s = new a.MurmurHash3_64(), o = [], F = /* @__PURE__ */ Object.create(null);
          let N = !1;
          for (const [Q, u] of this.#t) {
            const i = u instanceof d.AnnotationEditor ? u.serialize(!1, F) : u;
            i && (Z.set(Q, i), s.update(`${Q}:${JSON.stringify(i)}`), N ||= !!i.bitmap);
          }
          if (N)
            for (const Q of Z.values())
              Q.bitmap && o.push(Q.bitmap);
          return Z.size > 0 ? {
            map: Z,
            hash: s.hexdigest(),
            transfer: o
          } : U;
        }
        get editorStats() {
          let Z = null;
          const s = /* @__PURE__ */ new Map();
          for (const o of this.#t.values()) {
            if (!(o instanceof d.AnnotationEditor))
              continue;
            const F = o.telemetryFinalData;
            if (!F)
              continue;
            const {
              type: N
            } = F;
            s.has(N) || s.set(N, Object.getPrototypeOf(o).constructor), Z ||= /* @__PURE__ */ Object.create(null);
            const Q = Z[N] ||= /* @__PURE__ */ new Map();
            for (const [u, i] of Object.entries(F)) {
              if (u === "type")
                continue;
              let c = Q.get(u);
              c || (c = /* @__PURE__ */ new Map(), Q.set(u, c));
              const R = c.get(i) ?? 0;
              c.set(i, R + 1);
            }
          }
          for (const [o, F] of s)
            Z[o] = F.computeTelemetryFinalData(Z[o]);
          return Z;
        }
      }
      class h extends V {
        #l;
        constructor(Z) {
          super();
          const {
            map: s,
            hash: o,
            transfer: F
          } = Z.serializable, N = structuredClone(s, F ? {
            transfer: F
          } : null);
          this.#l = {
            map: N,
            hash: o,
            transfer: F
          };
        }
        get print() {
          (0, e.unreachable)("Should not call PrintAnnotationStorage.print");
        }
        get serializable() {
          return this.#l;
        }
      }
    }
  ),
  /***/
  831: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          let K = function(J) {
            if (typeof J == "string" || J instanceof URL ? J = {
              url: J
            } : (J instanceof ArrayBuffer || ArrayBuffer.isView(J)) && (J = {
              data: J
            }), typeof J != "object")
              throw new Error("Invalid parameter in getDocument, need parameter object.");
            if (!J.url && !J.data && !J.range)
              throw new Error("Invalid parameter object: need either .data, .range or .url");
            const T = new ll(), {
              docId: y
            } = T, I = J.url ? w(J.url) : null, E = J.data ? O(J.data) : null, x = J.httpHeaders || null, v = J.withCredentials === !0, A = J.password ?? null, g = J.range instanceof q ? J.range : null, D = Number.isInteger(J.rangeChunkSize) && J.rangeChunkSize > 0 ? J.rangeChunkSize : S;
            let C = J.worker instanceof al ? J.worker : null;
            const nl = J.verbosity, Fl = typeof J.docBaseUrl == "string" && !(0, V.isDataScheme)(J.docBaseUrl) ? J.docBaseUrl : null, sl = typeof J.cMapUrl == "string" ? J.cMapUrl : null, Vl = J.cMapPacked !== !1, Rl = J.CMapReaderFactory || L, Wl = typeof J.standardFontDataUrl == "string" ? J.standardFontDataUrl : null, ml = J.StandardFontDataFactory || f, rl = J.stopAtErrors !== !0, Gl = Number.isInteger(J.maxImageSize) && J.maxImageSize > -1 ? J.maxImageSize : -1, Ll = J.isEvalSupported !== !1, Cl = typeof J.isOffscreenCanvasSupported == "boolean" ? J.isOffscreenCanvasSupported : !a.isNodeJS, $ = Number.isInteger(J.canvasMaxAreaInBytes) ? J.canvasMaxAreaInBytes : -1, hl = typeof J.disableFontFace == "boolean" ? J.disableFontFace : a.isNodeJS, Tl = J.fontExtraProperties === !0, Jl = J.enableXfa === !0, yl = J.ownerDocument || globalThis.document, Il = J.disableRange === !0, gl = J.disableStream === !0, wl = J.disableAutoFetch === !0, _l = J.pdfBug === !0, lt = g ? g.length : J.length ?? NaN, ct = typeof J.useSystemFonts == "boolean" ? J.useSystemFonts : !a.isNodeJS && !hl, Nl = typeof J.useWorkerFetch == "boolean" ? J.useWorkerFetch : Rl === V.DOMCMapReaderFactory && ml === V.DOMStandardFontDataFactory && sl && Wl && (0, V.isValidFetchUrl)(sl, document.baseURI) && (0, V.isValidFetchUrl)(Wl, document.baseURI), Sl = J.canvasFactory || new k({
              ownerDocument: yl
            }), Yl = J.filterFactory || new z({
              docId: y,
              ownerDocument: yl
            }), Hl = null;
            (0, a.setVerbosityLevel)(nl);
            const vl = {
              canvasFactory: Sl,
              filterFactory: Yl
            };
            if (Nl || (vl.cMapReaderFactory = new Rl({
              baseUrl: sl,
              isCompressed: Vl
            }), vl.standardFontDataFactory = new ml({
              baseUrl: Wl
            })), !C) {
              const Pl = {
                verbosity: nl,
                port: o.GlobalWorkerOptions.workerPort
              };
              C = Pl.port ? al.fromPort(Pl) : new al(Pl), T._worker = C;
            }
            const jl = {
              docId: y,
              apiVersion: "4.2.67",
              data: E,
              password: A,
              disableAutoFetch: wl,
              rangeChunkSize: D,
              length: lt,
              docBaseUrl: Fl,
              enableXfa: Jl,
              evaluatorOptions: {
                maxImageSize: Gl,
                disableFontFace: hl,
                ignoreErrors: rl,
                isEvalSupported: Ll,
                isOffscreenCanvasSupported: Cl,
                canvasMaxAreaInBytes: $,
                fontExtraProperties: Tl,
                useSystemFonts: ct,
                cMapUrl: Nl ? sl : null,
                standardFontDataUrl: Nl ? Wl : null
              }
            }, El = {
              ignoreErrors: rl,
              disableFontFace: hl,
              fontExtraProperties: Tl,
              enableXfa: Jl,
              ownerDocument: yl,
              disableAutoFetch: wl,
              pdfBug: _l,
              styleElement: Hl
            };
            return C.promise.then(function() {
              if (T.destroyed)
                throw new Error("Loading aborted");
              const Pl = P(C, jl), Jt = new Promise(function(rt) {
                let Ft;
                g ? Ft = new u.PDFDataTransportStream(g, {
                  disableRange: Il,
                  disableStream: gl
                }) : E || (Ft = ((Dl) => a.isNodeJS ? function() {
                  return typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype;
                }() && (0, V.isValidFetchUrl)(Dl.url) ? new i.PDFFetchStream(Dl) : new R.PDFNodeStream(Dl) : (0, V.isValidFetchUrl)(Dl.url) ? new i.PDFFetchStream(Dl) : new c.PDFNetworkStream(Dl))({
                  url: I,
                  length: lt,
                  httpHeaders: x,
                  withCredentials: v,
                  rangeChunkSize: D,
                  disableRange: Il,
                  disableStream: gl
                })), rt(Ft);
              });
              return Promise.all([Pl, Jt]).then(function([rt, Ft]) {
                if (T.destroyed)
                  throw new Error("Loading aborted");
                const ot = new F.MessageHandler(y, rt, C.port), Dl = new Ul(ot, T, Ft, El, vl);
                T._transport = Dl, ot.send("Ready", null);
              });
            }).catch(T._capability.reject), T;
          }, w = function(J) {
            if (J instanceof URL)
              return J.href;
            try {
              return new URL(J, window.location).href;
            } catch {
              if (a.isNodeJS && typeof J == "string")
                return J;
            }
            throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
          }, O = function(J) {
            if (a.isNodeJS && typeof Buffer < "u" && J instanceof Buffer)
              throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
            if (J instanceof Uint8Array && J.byteLength === J.buffer.byteLength)
              return J;
            if (typeof J == "string")
              return (0, a.stringToBytes)(J);
            if (J instanceof ArrayBuffer || ArrayBuffer.isView(J) || typeof J == "object" && !isNaN(J?.length))
              return new Uint8Array(J);
            throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
          }, el = function(J) {
            return typeof J == "object" && Number.isInteger(J?.num) && J.num >= 0 && Number.isInteger(J?.gen) && J.gen >= 0;
          };
          n.d(t, {
            /* harmony export */
            PDFDataRangeTransport: () => (
              /* binding */
              q
            ),
            /* harmony export */
            PDFWorker: () => (
              /* binding */
              al
            ),
            /* harmony export */
            build: () => (
              /* binding */
              G
            ),
            /* harmony export */
            getDocument: () => (
              /* binding */
              K
            ),
            /* harmony export */
            version: () => (
              /* binding */
              r
            )
            /* harmony export */
          });
          var a = n(292), U = n(792), V = n(419), h = n(10), W = n(573), Z = n(923), s = n(814), o = n(164), F = n(178), N = n(62), Q = n(626), u = n(585), i = n(94), c = n(457), R = n(786), m = n(50), M = e([W, R]);
          [W, R] = M.then ? (await M)() : M;
          const S = 65536, p = 100, Y = 5e3, k = a.isNodeJS ? W.NodeCanvasFactory : V.DOMCanvasFactory, L = a.isNodeJS ? W.NodeCMapReaderFactory : V.DOMCMapReaderFactory, z = a.isNodeJS ? W.NodeFilterFactory : V.DOMFilterFactory, f = a.isNodeJS ? W.NodeStandardFontDataFactory : V.DOMStandardFontDataFactory;
          async function P(J, T) {
            if (J.destroyed)
              throw new Error("Worker was destroyed");
            const y = await J.messageHandler.sendWithPromise("GetDocRequest", T, T.data ? [T.data.buffer] : null);
            if (J.destroyed)
              throw new Error("Worker was destroyed");
            return y;
          }
          class ll {
            static #l = 0;
            constructor() {
              this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = `d${ll.#l++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              this.destroyed = !0;
              try {
                this._worker?.port && (this._worker._pendingDestroy = !0), await this._transport?.destroy();
              } catch (T) {
                throw this._worker?.port && delete this._worker._pendingDestroy, T;
              }
              this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          }
          class q {
            constructor(T, y, I = !1, E = null) {
              this.length = T, this.initialData = y, this.progressiveDone = I, this.contentDispositionFilename = E, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
            }
            addRangeListener(T) {
              this._rangeListeners.push(T);
            }
            addProgressListener(T) {
              this._progressListeners.push(T);
            }
            addProgressiveReadListener(T) {
              this._progressiveReadListeners.push(T);
            }
            addProgressiveDoneListener(T) {
              this._progressiveDoneListeners.push(T);
            }
            onDataRange(T, y) {
              for (const I of this._rangeListeners)
                I(T, y);
            }
            onDataProgress(T, y) {
              this._readyCapability.promise.then(() => {
                for (const I of this._progressListeners)
                  I(T, y);
              });
            }
            onDataProgressiveRead(T) {
              this._readyCapability.promise.then(() => {
                for (const y of this._progressiveReadListeners)
                  y(T);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const T of this._progressiveDoneListeners)
                  T();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(T, y) {
              (0, a.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          class _ {
            constructor(T, y) {
              this._pdfInfo = T, this._transport = y;
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get isPureXfa() {
              return (0, a.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(T) {
              return this._transport.getPage(T);
            }
            getPageIndex(T) {
              return this._transport.getPageIndex(T);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(T) {
              return this._transport.getDestination(T);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig({
              intent: T = "display"
            } = {}) {
              const {
                renderingIntent: y
              } = this._transport.getRenderingIntent(T);
              return this._transport.getOptionalContentConfig(y);
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            saveDocument() {
              return this._transport.saveDocument();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup(T = !1) {
              return this._transport.startCleanup(T || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            cachedPageNumber(T) {
              return this._transport.cachedPageNumber(T);
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          class il {
            #l = null;
            #t = !1;
            constructor(T, y, I, E = !1) {
              this._pageIndex = T, this._pageInfo = y, this._transport = I, this._stats = E ? new V.StatTimer() : null, this._pdfBug = E, this.commonObjs = I.commonObjs, this.objs = new B(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport({
              scale: T,
              rotation: y = this.rotate,
              offsetX: I = 0,
              offsetY: E = 0,
              dontFlip: x = !1
            } = {}) {
              return new V.PageViewport({
                viewBox: this.view,
                scale: T,
                rotation: y,
                offsetX: I,
                offsetY: E,
                dontFlip: x
              });
            }
            getAnnotations({
              intent: T = "display"
            } = {}) {
              const {
                renderingIntent: y
              } = this._transport.getRenderingIntent(T);
              return this._transport.getAnnotations(this._pageIndex, y);
            }
            getJSActions() {
              return this._transport.getPageJSActions(this._pageIndex);
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get isPureXfa() {
              return (0, a.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            async getXfa() {
              return this._transport._htmlForXfa?.children[this._pageIndex] || null;
            }
            render({
              canvasContext: T,
              viewport: y,
              intent: I = "display",
              annotationMode: E = a.AnnotationMode.ENABLE,
              transform: x = null,
              background: v = null,
              optionalContentConfigPromise: A = null,
              annotationCanvasMap: g = null,
              pageColors: D = null,
              printAnnotationStorage: C = null
            }) {
              this._stats?.time("Overall");
              const nl = this._transport.getRenderingIntent(I, E, C), {
                renderingIntent: Fl,
                cacheKey: sl
              } = nl;
              this.#t = !1, this.#d(), A ||= this._transport.getOptionalContentConfig(Fl);
              let Vl = this._intentStates.get(sl);
              Vl || (Vl = /* @__PURE__ */ Object.create(null), this._intentStates.set(sl, Vl)), Vl.streamReaderCancelTimeout && (clearTimeout(Vl.streamReaderCancelTimeout), Vl.streamReaderCancelTimeout = null);
              const Rl = !!(Fl & a.RenderingIntentFlag.PRINT);
              Vl.displayReadyCapability || (Vl.displayReadyCapability = Promise.withResolvers(), Vl.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats?.time("Page Request"), this._pumpOperatorList(nl));
              const Wl = (Gl) => {
                Vl.renderTasks.delete(ml), (this._maybeCleanupAfterRender || Rl) && (this.#t = !0), this.#n(!Rl), Gl ? (ml.capability.reject(Gl), this._abortOperatorList({
                  intentState: Vl,
                  reason: Gl instanceof Error ? Gl : new Error(Gl)
                })) : ml.capability.resolve(), this._stats?.timeEnd("Rendering"), this._stats?.timeEnd("Overall");
              }, ml = new b({
                callback: Wl,
                params: {
                  canvasContext: T,
                  viewport: y,
                  transform: x,
                  background: v
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: g,
                operatorList: Vl.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: this._transport.canvasFactory,
                filterFactory: this._transport.filterFactory,
                useRequestAnimationFrame: !Rl,
                pdfBug: this._pdfBug,
                pageColors: D
              });
              (Vl.renderTasks ||= /* @__PURE__ */ new Set()).add(ml);
              const rl = ml.task;
              return Promise.all([Vl.displayReadyCapability.promise, A]).then(([Gl, Ll]) => {
                if (this.destroyed) {
                  Wl();
                  return;
                }
                if (this._stats?.time("Rendering"), !(Ll.renderingIntent & Fl))
                  throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
                ml.initializeGraphics({
                  transparency: Gl,
                  optionalContentConfig: Ll
                }), ml.operatorListChanged();
              }).catch(Wl), rl;
            }
            getOperatorList({
              intent: T = "display",
              annotationMode: y = a.AnnotationMode.ENABLE,
              printAnnotationStorage: I = null
            } = {}) {
              function E() {
                v.operatorList.lastChunk && (v.opListReadCapability.resolve(v.operatorList), v.renderTasks.delete(A));
              }
              const x = this._transport.getRenderingIntent(T, y, I, !0);
              let v = this._intentStates.get(x.cacheKey);
              v || (v = /* @__PURE__ */ Object.create(null), this._intentStates.set(x.cacheKey, v));
              let A;
              return v.opListReadCapability || (A = /* @__PURE__ */ Object.create(null), A.operatorListChanged = E, v.opListReadCapability = Promise.withResolvers(), (v.renderTasks ||= /* @__PURE__ */ new Set()).add(A), v.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, this._stats?.time("Page Request"), this._pumpOperatorList(x)), v.opListReadCapability.promise;
            }
            streamTextContent({
              includeMarkedContent: T = !1,
              disableNormalization: y = !1
            } = {}) {
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                includeMarkedContent: T === !0,
                disableNormalization: y === !0
              }, {
                highWaterMark: 100,
                size(E) {
                  return E.items.length;
                }
              });
            }
            getTextContent(T = {}) {
              if (this._transport._htmlForXfa)
                return this.getXfa().then((I) => m.XfaText.textContent(I));
              const y = this.streamTextContent(T);
              return new Promise(function(I, E) {
                function x() {
                  v.read().then(function({
                    value: g,
                    done: D
                  }) {
                    if (D) {
                      I(A);
                      return;
                    }
                    Object.assign(A.styles, g.styles), A.items.push(...g.items), x();
                  }, E);
                }
                const v = y.getReader(), A = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                x();
              });
            }
            getStructTree() {
              return this._transport.getStructTree(this._pageIndex);
            }
            _destroy() {
              this.destroyed = !0;
              const T = [];
              for (const y of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: y,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !y.opListReadCapability)
                  for (const I of y.renderTasks)
                    T.push(I.completed), I.cancel();
              return this.objs.clear(), this.#t = !1, this.#d(), Promise.all(T);
            }
            cleanup(T = !1) {
              this.#t = !0;
              const y = this.#n(!1);
              return T && y && (this._stats &&= new V.StatTimer()), y;
            }
            #n(T = !1) {
              if (this.#d(), !this.#t || this.destroyed)
                return !1;
              if (T)
                return this.#l = setTimeout(() => {
                  this.#l = null, this.#n(!1);
                }, Y), !1;
              for (const {
                renderTasks: y,
                operatorList: I
              } of this._intentStates.values())
                if (y.size > 0 || !I.lastChunk)
                  return !1;
              return this._intentStates.clear(), this.objs.clear(), this.#t = !1, !0;
            }
            #d() {
              this.#l && (clearTimeout(this.#l), this.#l = null);
            }
            _startRenderPage(T, y) {
              const I = this._intentStates.get(y);
              I && (this._stats?.timeEnd("Page Request"), I.displayReadyCapability?.resolve(T));
            }
            _renderPageChunk(T, y) {
              for (let I = 0, E = T.length; I < E; I++)
                y.operatorList.fnArray.push(T.fnArray[I]), y.operatorList.argsArray.push(T.argsArray[I]);
              y.operatorList.lastChunk = T.lastChunk, y.operatorList.separateAnnots = T.separateAnnots;
              for (const I of y.renderTasks)
                I.operatorListChanged();
              T.lastChunk && this.#n(!0);
            }
            _pumpOperatorList({
              renderingIntent: T,
              cacheKey: y,
              annotationStorageSerializable: I
            }) {
              const {
                map: E,
                transfer: x
              } = I, A = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: T,
                cacheKey: y,
                annotationStorage: E
              }, x).getReader(), g = this._intentStates.get(y);
              g.streamReader = A;
              const D = () => {
                A.read().then(({
                  value: C,
                  done: nl
                }) => {
                  if (nl) {
                    g.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(C, g), D());
                }, (C) => {
                  if (g.streamReader = null, !this._transport.destroyed) {
                    if (g.operatorList) {
                      g.operatorList.lastChunk = !0;
                      for (const nl of g.renderTasks)
                        nl.operatorListChanged();
                      this.#n(!0);
                    }
                    if (g.displayReadyCapability)
                      g.displayReadyCapability.reject(C);
                    else if (g.opListReadCapability)
                      g.opListReadCapability.reject(C);
                    else
                      throw C;
                  }
                });
              };
              D();
            }
            _abortOperatorList({
              intentState: T,
              reason: y,
              force: I = !1
            }) {
              if (T.streamReader) {
                if (T.streamReaderCancelTimeout && (clearTimeout(T.streamReaderCancelTimeout), T.streamReaderCancelTimeout = null), !I) {
                  if (T.renderTasks.size > 0)
                    return;
                  if (y instanceof V.RenderingCancelledException) {
                    let E = p;
                    y.extraDelay > 0 && y.extraDelay < 1e3 && (E += y.extraDelay), T.streamReaderCancelTimeout = setTimeout(() => {
                      T.streamReaderCancelTimeout = null, this._abortOperatorList({
                        intentState: T,
                        reason: y,
                        force: !0
                      });
                    }, E);
                    return;
                  }
                }
                if (T.streamReader.cancel(new a.AbortException(y.message)).catch(() => {
                }), T.streamReader = null, !this._transport.destroyed) {
                  for (const [E, x] of this._intentStates)
                    if (x === T) {
                      this._intentStates.delete(E);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          class dl {
            #l = /* @__PURE__ */ new Set();
            #t = Promise.resolve();
            postMessage(T, y) {
              const I = {
                data: structuredClone(T, y ? {
                  transfer: y
                } : null)
              };
              this.#t.then(() => {
                for (const E of this.#l)
                  E.call(this, I);
              });
            }
            addEventListener(T, y) {
              this.#l.add(y);
            }
            removeEventListener(T, y) {
              this.#l.delete(y);
            }
            terminate() {
              this.#l.clear();
            }
          }
          const tl = {
            isWorkerDisabled: !1,
            fakeWorkerId: 0
          };
          a.isNodeJS && (tl.isWorkerDisabled = !0, o.GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs"), tl.isSameOrigin = function(J, T) {
            let y;
            try {
              if (y = new URL(J), !y.origin || y.origin === "null")
                return !1;
            } catch {
              return !1;
            }
            const I = new URL(T, y);
            return y.origin === I.origin;
          }, tl.createCDNWrapper = function(J) {
            const T = `await import("${J}");`;
            return URL.createObjectURL(new Blob([T], {
              type: "text/javascript"
            }));
          };
          class al {
            static #l;
            constructor({
              name: T = null,
              port: y = null,
              verbosity: I = (0, a.getVerbosityLevel)()
            } = {}) {
              if (this.name = T, this.destroyed = !1, this.verbosity = I, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, y) {
                if (al.#l?.has(y))
                  throw new Error("Cannot use more than one PDFWorker per port.");
                (al.#l ||= /* @__PURE__ */ new WeakMap()).set(y, this), this._initializeFromPort(y);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(T) {
              this._port = T, this._messageHandler = new F.MessageHandler("main", "worker", T), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve(), this._messageHandler.send("configure", {
                verbosity: this.verbosity
              });
            }
            _initialize() {
              if (!tl.isWorkerDisabled && !al.#t) {
                let {
                  workerSrc: T
                } = al;
                try {
                  tl.isSameOrigin(window.location.href, T) || (T = tl.createCDNWrapper(new URL(T, window.location).href));
                  const y = new Worker(T, {
                    type: "module"
                  }), I = new F.MessageHandler("main", "worker", y), E = () => {
                    y.removeEventListener("error", x), I.destroy(), y.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, x = () => {
                    this._webWorker || E();
                  };
                  y.addEventListener("error", x), I.on("test", (A) => {
                    if (y.removeEventListener("error", x), this.destroyed) {
                      E();
                      return;
                    }
                    A ? (this._messageHandler = I, this._port = y, this._webWorker = y, this._readyCapability.resolve(), I.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), I.destroy(), y.terminate());
                  }), I.on("ready", (A) => {
                    if (y.removeEventListener("error", x), this.destroyed) {
                      E();
                      return;
                    }
                    try {
                      v();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const v = () => {
                    const A = new Uint8Array();
                    I.send("test", A, [A.buffer]);
                  };
                  v();
                  return;
                } catch {
                  (0, a.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              tl.isWorkerDisabled || ((0, a.warn)("Setting up fake worker."), tl.isWorkerDisabled = !0), al._setupFakeWorkerGlobal.then((T) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const y = new dl();
                this._port = y;
                const I = `fake${tl.fakeWorkerId++}`, E = new F.MessageHandler(I + "_worker", I, y);
                T.setup(E, y);
                const x = new F.MessageHandler(I, I + "_worker", y);
                this._messageHandler = x, this._readyCapability.resolve(), x.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((T) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${T.message}".`));
              });
            }
            destroy() {
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), al.#l?.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(T) {
              if (!T?.port)
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              const y = this.#l?.get(T.port);
              if (y) {
                if (y._pendingDestroy)
                  throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                return y;
              }
              return new al(T);
            }
            static get workerSrc() {
              if (o.GlobalWorkerOptions.workerSrc)
                return o.GlobalWorkerOptions.workerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get #t() {
              try {
                return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const T = async () => this.#t ? this.#t : (await import(
                /*webpackIgnore: true*/
                this.workerSrc
              )).WorkerMessageHandler;
              return (0, a.shadow)(this, "_setupFakeWorkerGlobal", T());
            }
          }
          class Ul {
            #l = /* @__PURE__ */ new Map();
            #t = /* @__PURE__ */ new Map();
            #n = /* @__PURE__ */ new Map();
            #d = /* @__PURE__ */ new Map();
            #a = null;
            constructor(T, y, I, E, x) {
              this.messageHandler = T, this.loadingTask = y, this.commonObjs = new B(), this.fontLoader = new h.FontLoader({
                ownerDocument: E.ownerDocument,
                styleElement: E.styleElement
              }), this._params = E, this.canvasFactory = x.canvasFactory, this.filterFactory = x.filterFactory, this.cMapReaderFactory = x.cMapReaderFactory, this.standardFontDataFactory = x.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = I, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
            }
            #e(T, y = null) {
              const I = this.#l.get(T);
              if (I)
                return I;
              const E = this.messageHandler.sendWithPromise(T, y);
              return this.#l.set(T, E), E;
            }
            get annotationStorage() {
              return (0, a.shadow)(this, "annotationStorage", new U.AnnotationStorage());
            }
            getRenderingIntent(T, y = a.AnnotationMode.ENABLE, I = null, E = !1) {
              let x = a.RenderingIntentFlag.DISPLAY, v = U.SerializableEmpty;
              switch (T) {
                case "any":
                  x = a.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  x = a.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, a.warn)(`getRenderingIntent - invalid intent: ${T}`);
              }
              switch (y) {
                case a.AnnotationMode.DISABLE:
                  x += a.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case a.AnnotationMode.ENABLE:
                  break;
                case a.AnnotationMode.ENABLE_FORMS:
                  x += a.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case a.AnnotationMode.ENABLE_STORAGE:
                  x += a.RenderingIntentFlag.ANNOTATIONS_STORAGE, v = (x & a.RenderingIntentFlag.PRINT && I instanceof U.PrintAnnotationStorage ? I : this.annotationStorage).serializable;
                  break;
                default:
                  (0, a.warn)(`getRenderingIntent - invalid annotationMode: ${y}`);
              }
              return E && (x += a.RenderingIntentFlag.OPLIST), {
                renderingIntent: x,
                cacheKey: `${x}_${v.hash}`,
                annotationStorageSerializable: v
              };
            }
            destroy() {
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), this.#a?.reject(new Error("Worker was destroyed during onPassword callback"));
              const T = [];
              for (const I of this.#t.values())
                T.push(I._destroy());
              this.#t.clear(), this.#n.clear(), this.#d.clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const y = this.messageHandler.sendWithPromise("Terminate", null);
              return T.push(y), Promise.all(T).then(() => {
                this.commonObjs.clear(), this.fontLoader.clear(), this.#l.clear(), this.filterFactory.destroy(), (0, s.cleanupTextLayer)(), this._networkStream?.cancelAllRequests(new a.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: T,
                loadingTask: y
              } = this;
              T.on("GetReader", (I, E) => {
                (0, a.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (x) => {
                  this._lastProgress = {
                    loaded: x.loaded,
                    total: x.total
                  };
                }, E.onPull = () => {
                  this._fullReader.read().then(function({
                    value: x,
                    done: v
                  }) {
                    if (v) {
                      E.close();
                      return;
                    }
                    (0, a.assert)(x instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), E.enqueue(new Uint8Array(x), 1, [x]);
                  }).catch((x) => {
                    E.error(x);
                  });
                }, E.onCancel = (x) => {
                  this._fullReader.cancel(x), E.ready.catch((v) => {
                    if (!this.destroyed)
                      throw v;
                  });
                };
              }), T.on("ReaderHeadersReady", (I) => {
                const E = Promise.withResolvers(), x = this._fullReader;
                return x.headersReady.then(() => {
                  (!x.isStreamingSupported || !x.isRangeSupported) && (this._lastProgress && y.onProgress?.(this._lastProgress), x.onProgress = (v) => {
                    y.onProgress?.({
                      loaded: v.loaded,
                      total: v.total
                    });
                  }), E.resolve({
                    isStreamingSupported: x.isStreamingSupported,
                    isRangeSupported: x.isRangeSupported,
                    contentLength: x.contentLength
                  });
                }, E.reject), E.promise;
              }), T.on("GetRangeReader", (I, E) => {
                (0, a.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const x = this._networkStream.getRangeReader(I.begin, I.end);
                if (!x) {
                  E.close();
                  return;
                }
                E.onPull = () => {
                  x.read().then(function({
                    value: v,
                    done: A
                  }) {
                    if (A) {
                      E.close();
                      return;
                    }
                    (0, a.assert)(v instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), E.enqueue(new Uint8Array(v), 1, [v]);
                  }).catch((v) => {
                    E.error(v);
                  });
                }, E.onCancel = (v) => {
                  x.cancel(v), E.ready.catch((A) => {
                    if (!this.destroyed)
                      throw A;
                  });
                };
              }), T.on("GetDoc", ({
                pdfInfo: I
              }) => {
                this._numPages = I.numPages, this._htmlForXfa = I.htmlForXfa, delete I.htmlForXfa, y._capability.resolve(new _(I, this));
              }), T.on("DocException", function(I) {
                let E;
                switch (I.name) {
                  case "PasswordException":
                    E = new a.PasswordException(I.message, I.code);
                    break;
                  case "InvalidPDFException":
                    E = new a.InvalidPDFException(I.message);
                    break;
                  case "MissingPDFException":
                    E = new a.MissingPDFException(I.message);
                    break;
                  case "UnexpectedResponseException":
                    E = new a.UnexpectedResponseException(I.message, I.status);
                    break;
                  case "UnknownErrorException":
                    E = new a.UnknownErrorException(I.message, I.details);
                    break;
                  default:
                    (0, a.unreachable)("DocException - expected a valid Error.");
                }
                y._capability.reject(E);
              }), T.on("PasswordRequest", (I) => {
                if (this.#a = Promise.withResolvers(), y.onPassword) {
                  const E = (x) => {
                    x instanceof Error ? this.#a.reject(x) : this.#a.resolve({
                      password: x
                    });
                  };
                  try {
                    y.onPassword(E, I.code);
                  } catch (x) {
                    this.#a.reject(x);
                  }
                } else
                  this.#a.reject(new a.PasswordException(I.message, I.code));
                return this.#a.promise;
              }), T.on("DataLoaded", (I) => {
                y.onProgress?.({
                  loaded: I.length,
                  total: I.length
                }), this.downloadInfoCapability.resolve(I);
              }), T.on("StartRenderPage", (I) => {
                if (this.destroyed)
                  return;
                this.#t.get(I.pageIndex)._startRenderPage(I.transparency, I.cacheKey);
              }), T.on("commonobj", ([I, E, x]) => {
                if (this.destroyed || this.commonObjs.has(I))
                  return null;
                switch (E) {
                  case "Font":
                    const v = this._params;
                    if ("error" in x) {
                      const C = x.error;
                      (0, a.warn)(`Error during font loading: ${C}`), this.commonObjs.resolve(I, C);
                      break;
                    }
                    const A = v.pdfBug && globalThis.FontInspector?.enabled ? (C, nl) => globalThis.FontInspector.fontAdded(C, nl) : null, g = new h.FontFaceObject(x, {
                      disableFontFace: v.disableFontFace,
                      ignoreErrors: v.ignoreErrors,
                      inspectFont: A
                    });
                    this.fontLoader.bind(g).catch(() => T.sendWithPromise("FontFallback", {
                      id: I
                    })).finally(() => {
                      !v.fontExtraProperties && g.data && (g.data = null), this.commonObjs.resolve(I, g);
                    });
                    break;
                  case "CopyLocalImage":
                    const {
                      imageRef: D
                    } = x;
                    (0, a.assert)(D, "The imageRef must be defined.");
                    for (const C of this.#t.values())
                      for (const [, nl] of C.objs)
                        if (nl.ref === D)
                          return nl.dataLen ? (this.commonObjs.resolve(I, structuredClone(nl)), nl.dataLen) : null;
                    break;
                  case "FontPath":
                  case "Image":
                  case "Pattern":
                    this.commonObjs.resolve(I, x);
                    break;
                  default:
                    throw new Error(`Got unknown common object type ${E}`);
                }
                return null;
              }), T.on("obj", ([I, E, x, v]) => {
                if (this.destroyed)
                  return;
                const A = this.#t.get(E);
                if (!A.objs.has(I)) {
                  if (A._intentStates.size === 0) {
                    v?.bitmap?.close();
                    return;
                  }
                  switch (x) {
                    case "Image":
                      A.objs.resolve(I, v), v?.dataLen > a.MAX_IMAGE_SIZE_TO_CACHE && (A._maybeCleanupAfterRender = !0);
                      break;
                    case "Pattern":
                      A.objs.resolve(I, v);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${x}`);
                  }
                }
              }), T.on("DocProgress", (I) => {
                this.destroyed || y.onProgress?.({
                  loaded: I.loaded,
                  total: I.total
                });
              }), T.on("FetchBuiltInCMap", (I) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(I) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), T.on("FetchStandardFontData", (I) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(I) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            saveDocument() {
              this.annotationStorage.size <= 0 && (0, a.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
              const {
                map: T,
                transfer: y
              } = this.annotationStorage.serializable;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: T,
                filename: this._fullReader?.filename ?? null
              }, y).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getPage(T) {
              if (!Number.isInteger(T) || T <= 0 || T > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const y = T - 1, I = this.#n.get(y);
              if (I)
                return I;
              const E = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: y
              }).then((x) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                x.refStr && this.#d.set(x.refStr, T);
                const v = new il(y, x, this, this._params.pdfBug);
                return this.#t.set(y, v), v;
              });
              return this.#n.set(y, E), E;
            }
            getPageIndex(T) {
              return el(T) ? this.messageHandler.sendWithPromise("GetPageIndex", {
                num: T.num,
                gen: T.gen
              }) : Promise.reject(new Error("Invalid pageIndex request."));
            }
            getAnnotations(T, y) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: T,
                intent: y
              });
            }
            getFieldObjects() {
              return this.#e("GetFieldObjects");
            }
            hasJSActions() {
              return this.#e("HasJSActions");
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(T) {
              return typeof T != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: T
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getDocJSActions() {
              return this.#e("GetDocJSActions");
            }
            getPageJSActions(T) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: T
              });
            }
            getStructTree(T) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: T
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig(T) {
              return this.#e("GetOptionalContentConfig").then((y) => new Q.OptionalContentConfig(y, T));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              const T = "GetMetadata", y = this.#l.get(T);
              if (y)
                return y;
              const I = this.messageHandler.sendWithPromise(T, null).then((E) => ({
                info: E[0],
                metadata: E[1] ? new N.Metadata(E[1]) : null,
                contentDispositionFilename: this._fullReader?.filename ?? null,
                contentLength: this._fullReader?.contentLength ?? null
              }));
              return this.#l.set(T, I), I;
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup(T = !1) {
              if (!this.destroyed) {
                await this.messageHandler.sendWithPromise("Cleanup", null);
                for (const y of this.#t.values())
                  if (!y.cleanup())
                    throw new Error(`startCleanup: Page ${y.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), T || this.fontLoader.clear(), this.#l.clear(), this.filterFactory.destroy(!0), (0, s.cleanupTextLayer)();
              }
            }
            cachedPageNumber(T) {
              if (!el(T))
                return null;
              const y = T.gen === 0 ? `${T.num}R` : `${T.num}R${T.gen}`;
              return this.#d.get(y) ?? null;
            }
            get loadingParams() {
              const {
                disableAutoFetch: T,
                enableXfa: y
              } = this._params;
              return (0, a.shadow)(this, "loadingParams", {
                disableAutoFetch: T,
                enableXfa: y
              });
            }
          }
          const cl = Symbol("INITIAL_DATA");
          class B {
            #l = /* @__PURE__ */ Object.create(null);
            #t(T) {
              return this.#l[T] ||= {
                ...Promise.withResolvers(),
                data: cl
              };
            }
            get(T, y = null) {
              if (y) {
                const E = this.#t(T);
                return E.promise.then(() => y(E.data)), null;
              }
              const I = this.#l[T];
              if (!I || I.data === cl)
                throw new Error(`Requesting object that isn't resolved yet ${T}.`);
              return I.data;
            }
            has(T) {
              const y = this.#l[T];
              return !!y && y.data !== cl;
            }
            resolve(T, y = null) {
              const I = this.#t(T);
              I.data = y, I.resolve();
            }
            clear() {
              for (const T in this.#l) {
                const {
                  data: y
                } = this.#l[T];
                y?.bitmap?.close();
              }
              this.#l = /* @__PURE__ */ Object.create(null);
            }
            *[Symbol.iterator]() {
              for (const T in this.#l) {
                const {
                  data: y
                } = this.#l[T];
                y !== cl && (yield [T, y]);
              }
            }
          }
          class X {
            #l = null;
            constructor(T) {
              this.#l = T, this.onContinue = null;
            }
            get promise() {
              return this.#l.capability.promise;
            }
            cancel(T = 0) {
              this.#l.cancel(null, T);
            }
            get separateAnnots() {
              const {
                separateAnnots: T
              } = this.#l.operatorList;
              if (!T)
                return !1;
              const {
                annotationCanvasMap: y
              } = this.#l;
              return T.form || T.canvas && y?.size > 0;
            }
          }
          class b {
            static #l = /* @__PURE__ */ new WeakSet();
            constructor({
              callback: T,
              params: y,
              objs: I,
              commonObjs: E,
              annotationCanvasMap: x,
              operatorList: v,
              pageIndex: A,
              canvasFactory: g,
              filterFactory: D,
              useRequestAnimationFrame: C = !1,
              pdfBug: nl = !1,
              pageColors: Fl = null
            }) {
              this.callback = T, this.params = y, this.objs = I, this.commonObjs = E, this.annotationCanvasMap = x, this.operatorListIdx = null, this.operatorList = v, this._pageIndex = A, this.canvasFactory = g, this.filterFactory = D, this._pdfBug = nl, this.pageColors = Fl, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = C === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new X(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = y.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics({
              transparency: T = !1,
              optionalContentConfig: y
            }) {
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (b.#l.has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                b.#l.add(this._canvas);
              }
              this._pdfBug && globalThis.StepperManager?.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: I,
                viewport: E,
                transform: x,
                background: v
              } = this.params;
              this.gfx = new Z.CanvasGraphics(I, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                optionalContentConfig: y
              }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: x,
                viewport: E,
                transparency: T,
                background: v
              }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback?.();
            }
            cancel(T = null, y = 0) {
              this.running = !1, this.cancelled = !0, this.gfx?.endDrawing(), b.#l.delete(this._canvas), this.callback(T || new V.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, y));
            }
            operatorListChanged() {
              if (!this.graphicsReady) {
                this.graphicsReadyCallback ||= this._continueBound;
                return;
              }
              this.stepper?.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), b.#l.delete(this._canvas), this.callback())));
            }
          }
          const r = "4.2.67", G = "49b388101";
          d();
        } catch (S) {
          d(S);
        }
      });
    }
  ),
  /***/
  583: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        BaseCMapReaderFactory: () => (
          /* binding */
          U
        ),
        /* harmony export */
        BaseCanvasFactory: () => (
          /* binding */
          a
        ),
        /* harmony export */
        BaseFilterFactory: () => (
          /* binding */
          d
        ),
        /* harmony export */
        BaseSVGFactory: () => (
          /* binding */
          h
        ),
        /* harmony export */
        BaseStandardFontDataFactory: () => (
          /* binding */
          V
        )
        /* harmony export */
      });
      var e = n(292);
      class d {
        constructor() {
          this.constructor === d && (0, e.unreachable)("Cannot initialize BaseFilterFactory.");
        }
        addFilter(Z) {
          return "none";
        }
        addHCMFilter(Z, s) {
          return "none";
        }
        addHighlightHCMFilter(Z, s, o, F, N) {
          return "none";
        }
        destroy(Z = !1) {
        }
      }
      class a {
        constructor() {
          this.constructor === a && (0, e.unreachable)("Cannot initialize BaseCanvasFactory.");
        }
        create(Z, s) {
          if (Z <= 0 || s <= 0)
            throw new Error("Invalid canvas size");
          const o = this._createCanvas(Z, s);
          return {
            canvas: o,
            context: o.getContext("2d")
          };
        }
        reset(Z, s, o) {
          if (!Z.canvas)
            throw new Error("Canvas is not specified");
          if (s <= 0 || o <= 0)
            throw new Error("Invalid canvas size");
          Z.canvas.width = s, Z.canvas.height = o;
        }
        destroy(Z) {
          if (!Z.canvas)
            throw new Error("Canvas is not specified");
          Z.canvas.width = 0, Z.canvas.height = 0, Z.canvas = null, Z.context = null;
        }
        _createCanvas(Z, s) {
          (0, e.unreachable)("Abstract method `_createCanvas` called.");
        }
      }
      class U {
        constructor({
          baseUrl: Z = null,
          isCompressed: s = !0
        }) {
          this.constructor === U && (0, e.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = Z, this.isCompressed = s;
        }
        async fetch({
          name: Z
        }) {
          if (!this.baseUrl)
            throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
          if (!Z)
            throw new Error("CMap name must be specified.");
          const s = this.baseUrl + Z + (this.isCompressed ? ".bcmap" : ""), o = this.isCompressed ? e.CMapCompressionType.BINARY : e.CMapCompressionType.NONE;
          return this._fetchData(s, o).catch((F) => {
            throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${s}`);
          });
        }
        _fetchData(Z, s) {
          (0, e.unreachable)("Abstract method `_fetchData` called.");
        }
      }
      class V {
        constructor({
          baseUrl: Z = null
        }) {
          this.constructor === V && (0, e.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = Z;
        }
        async fetch({
          filename: Z
        }) {
          if (!this.baseUrl)
            throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
          if (!Z)
            throw new Error("Font filename must be specified.");
          const s = `${this.baseUrl}${Z}`;
          return this._fetchData(s).catch((o) => {
            throw new Error(`Unable to load font data at: ${s}`);
          });
        }
        _fetchData(Z) {
          (0, e.unreachable)("Abstract method `_fetchData` called.");
        }
      }
      class h {
        constructor() {
          this.constructor === h && (0, e.unreachable)("Cannot initialize BaseSVGFactory.");
        }
        create(Z, s, o = !1) {
          if (Z <= 0 || s <= 0)
            throw new Error("Invalid SVG dimensions");
          const F = this._createSVG("svg:svg");
          return F.setAttribute("version", "1.1"), o || (F.setAttribute("width", `${Z}px`), F.setAttribute("height", `${s}px`)), F.setAttribute("preserveAspectRatio", "none"), F.setAttribute("viewBox", `0 0 ${Z} ${s}`), F;
        }
        createElement(Z) {
          if (typeof Z != "string")
            throw new Error("Invalid SVG element type");
          return this._createSVG(Z);
        }
        _createSVG(Z) {
          (0, e.unreachable)("Abstract method `_createSVG` called.");
        }
      }
    }
  ),
  /***/
  923: (
    /***/
    (l, t, n) => {
      n.d(t, {
        CanvasGraphics: () => (
          /* binding */
          B
        )
      });
      var e = n(292), d = n(419);
      const a = {
        FILL: "Fill",
        STROKE: "Stroke",
        SHADING: "Shading"
      };
      function U(X, b) {
        if (!b)
          return;
        const r = b[2] - b[0], G = b[3] - b[1], J = new Path2D();
        J.rect(b[0], b[1], r, G), X.clip(J);
      }
      class V {
        constructor() {
          this.constructor === V && (0, e.unreachable)("Cannot initialize BaseShadingPattern.");
        }
        getPattern() {
          (0, e.unreachable)("Abstract method `getPattern` called.");
        }
      }
      class h extends V {
        constructor(b) {
          super(), this._type = b[1], this._bbox = b[2], this._colorStops = b[3], this._p0 = b[4], this._p1 = b[5], this._r0 = b[6], this._r1 = b[7], this.matrix = null;
        }
        _createGradient(b) {
          let r;
          this._type === "axial" ? r = b.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (r = b.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
          for (const G of this._colorStops)
            r.addColorStop(G[0], G[1]);
          return r;
        }
        getPattern(b, r, G, J) {
          let T;
          if (J === a.STROKE || J === a.FILL) {
            const y = r.current.getClippedPathBoundingBox(J, (0, d.getCurrentTransform)(b)) || [0, 0, 0, 0], I = Math.ceil(y[2] - y[0]) || 1, E = Math.ceil(y[3] - y[1]) || 1, x = r.cachedCanvases.getCanvas("pattern", I, E, !0), v = x.context;
            v.clearRect(0, 0, v.canvas.width, v.canvas.height), v.beginPath(), v.rect(0, 0, v.canvas.width, v.canvas.height), v.translate(-y[0], -y[1]), G = e.Util.transform(G, [1, 0, 0, 1, y[0], y[1]]), v.transform(...r.baseTransform), this.matrix && v.transform(...this.matrix), U(v, this._bbox), v.fillStyle = this._createGradient(v), v.fill(), T = b.createPattern(x.canvas, "no-repeat");
            const A = new DOMMatrix(G);
            T.setTransform(A);
          } else
            U(b, this._bbox), T = this._createGradient(b);
          return T;
        }
      }
      function W(X, b, r, G, J, T, y, I) {
        const E = b.coords, x = b.colors, v = X.data, A = X.width * 4;
        let g;
        E[r + 1] > E[G + 1] && (g = r, r = G, G = g, g = T, T = y, y = g), E[G + 1] > E[J + 1] && (g = G, G = J, J = g, g = y, y = I, I = g), E[r + 1] > E[G + 1] && (g = r, r = G, G = g, g = T, T = y, y = g);
        const D = (E[r] + b.offsetX) * b.scaleX, C = (E[r + 1] + b.offsetY) * b.scaleY, nl = (E[G] + b.offsetX) * b.scaleX, Fl = (E[G + 1] + b.offsetY) * b.scaleY, sl = (E[J] + b.offsetX) * b.scaleX, Vl = (E[J + 1] + b.offsetY) * b.scaleY;
        if (C >= Vl)
          return;
        const Rl = x[T], Wl = x[T + 1], ml = x[T + 2], rl = x[y], Gl = x[y + 1], Ll = x[y + 2], Cl = x[I], $ = x[I + 1], hl = x[I + 2], Tl = Math.round(C), Jl = Math.round(Vl);
        let yl, Il, gl, wl, _l, lt, ct, Nl;
        for (let Sl = Tl; Sl <= Jl; Sl++) {
          if (Sl < Fl) {
            const El = Sl < C ? 0 : (C - Sl) / (C - Fl);
            yl = D - (D - nl) * El, Il = Rl - (Rl - rl) * El, gl = Wl - (Wl - Gl) * El, wl = ml - (ml - Ll) * El;
          } else {
            let El;
            Sl > Vl ? El = 1 : Fl === Vl ? El = 0 : El = (Fl - Sl) / (Fl - Vl), yl = nl - (nl - sl) * El, Il = rl - (rl - Cl) * El, gl = Gl - (Gl - $) * El, wl = Ll - (Ll - hl) * El;
          }
          let Yl;
          Sl < C ? Yl = 0 : Sl > Vl ? Yl = 1 : Yl = (C - Sl) / (C - Vl), _l = D - (D - sl) * Yl, lt = Rl - (Rl - Cl) * Yl, ct = Wl - (Wl - $) * Yl, Nl = ml - (ml - hl) * Yl;
          const Hl = Math.round(Math.min(yl, _l)), vl = Math.round(Math.max(yl, _l));
          let jl = A * Sl + Hl * 4;
          for (let El = Hl; El <= vl; El++)
            Yl = (yl - El) / (yl - _l), Yl < 0 ? Yl = 0 : Yl > 1 && (Yl = 1), v[jl++] = Il - (Il - lt) * Yl | 0, v[jl++] = gl - (gl - ct) * Yl | 0, v[jl++] = wl - (wl - Nl) * Yl | 0, v[jl++] = 255;
        }
      }
      function Z(X, b, r) {
        const G = b.coords, J = b.colors;
        let T, y;
        switch (b.type) {
          case "lattice":
            const I = b.verticesPerRow, E = Math.floor(G.length / I) - 1, x = I - 1;
            for (T = 0; T < E; T++) {
              let v = T * I;
              for (let A = 0; A < x; A++, v++)
                W(X, r, G[v], G[v + 1], G[v + I], J[v], J[v + 1], J[v + I]), W(X, r, G[v + I + 1], G[v + 1], G[v + I], J[v + I + 1], J[v + 1], J[v + I]);
            }
            break;
          case "triangles":
            for (T = 0, y = G.length; T < y; T += 3)
              W(X, r, G[T], G[T + 1], G[T + 2], J[T], J[T + 1], J[T + 2]);
            break;
          default:
            throw new Error("illegal figure");
        }
      }
      class s extends V {
        constructor(b) {
          super(), this._coords = b[2], this._colors = b[3], this._figures = b[4], this._bounds = b[5], this._bbox = b[7], this._background = b[8], this.matrix = null;
        }
        _createMeshCanvas(b, r, G) {
          const I = Math.floor(this._bounds[0]), E = Math.floor(this._bounds[1]), x = Math.ceil(this._bounds[2]) - I, v = Math.ceil(this._bounds[3]) - E, A = Math.min(Math.ceil(Math.abs(x * b[0] * 1.1)), 3e3), g = Math.min(Math.ceil(Math.abs(v * b[1] * 1.1)), 3e3), D = x / A, C = v / g, nl = {
            coords: this._coords,
            colors: this._colors,
            offsetX: -I,
            offsetY: -E,
            scaleX: 1 / D,
            scaleY: 1 / C
          }, Fl = A + 2 * 2, sl = g + 2 * 2, Vl = G.getCanvas("mesh", Fl, sl, !1), Rl = Vl.context, Wl = Rl.createImageData(A, g);
          if (r) {
            const rl = Wl.data;
            for (let Gl = 0, Ll = rl.length; Gl < Ll; Gl += 4)
              rl[Gl] = r[0], rl[Gl + 1] = r[1], rl[Gl + 2] = r[2], rl[Gl + 3] = 255;
          }
          for (const rl of this._figures)
            Z(Wl, rl, nl);
          return Rl.putImageData(Wl, 2, 2), {
            canvas: Vl.canvas,
            offsetX: I - 2 * D,
            offsetY: E - 2 * C,
            scaleX: D,
            scaleY: C
          };
        }
        getPattern(b, r, G, J) {
          U(b, this._bbox);
          let T;
          if (J === a.SHADING)
            T = e.Util.singularValueDecompose2dScale((0, d.getCurrentTransform)(b));
          else if (T = e.Util.singularValueDecompose2dScale(r.baseTransform), this.matrix) {
            const I = e.Util.singularValueDecompose2dScale(this.matrix);
            T = [T[0] * I[0], T[1] * I[1]];
          }
          const y = this._createMeshCanvas(T, J === a.SHADING ? null : this._background, r.cachedCanvases);
          return J !== a.SHADING && (b.setTransform(...r.baseTransform), this.matrix && b.transform(...this.matrix)), b.translate(y.offsetX, y.offsetY), b.scale(y.scaleX, y.scaleY), b.createPattern(y.canvas, "no-repeat");
        }
      }
      class o extends V {
        getPattern() {
          return "hotpink";
        }
      }
      function F(X) {
        switch (X[0]) {
          case "RadialAxial":
            return new h(X);
          case "Mesh":
            return new s(X);
          case "Dummy":
            return new o();
        }
        throw new Error(`Unknown IR type: ${X[0]}`);
      }
      const N = {
        COLORED: 1,
        UNCOLORED: 2
      };
      class Q {
        static MAX_PATTERN_SIZE = 3e3;
        constructor(b, r, G, J, T) {
          this.operatorList = b[2], this.matrix = b[3] || [1, 0, 0, 1, 0, 0], this.bbox = b[4], this.xstep = b[5], this.ystep = b[6], this.paintType = b[7], this.tilingType = b[8], this.color = r, this.ctx = G, this.canvasGraphicsFactory = J, this.baseTransform = T;
        }
        createPatternCanvas(b) {
          const r = this.operatorList, G = this.bbox, J = this.xstep, T = this.ystep, y = this.paintType, I = this.tilingType, E = this.color, x = this.canvasGraphicsFactory;
          (0, e.info)("TilingType: " + I);
          const v = G[0], A = G[1], g = G[2], D = G[3], C = e.Util.singularValueDecompose2dScale(this.matrix), nl = e.Util.singularValueDecompose2dScale(this.baseTransform), Fl = [C[0] * nl[0], C[1] * nl[1]], sl = this.getSizeAndScale(J, this.ctx.canvas.width, Fl[0]), Vl = this.getSizeAndScale(T, this.ctx.canvas.height, Fl[1]), Rl = b.cachedCanvases.getCanvas("pattern", sl.size, Vl.size, !0), Wl = Rl.context, ml = x.createCanvasGraphics(Wl);
          ml.groupLevel = b.groupLevel, this.setFillAndStrokeStyleToContext(ml, y, E);
          let rl = v, Gl = A, Ll = g, Cl = D;
          return v < 0 && (rl = 0, Ll += Math.abs(v)), A < 0 && (Gl = 0, Cl += Math.abs(A)), Wl.translate(-(sl.scale * rl), -(Vl.scale * Gl)), ml.transform(sl.scale, 0, 0, Vl.scale, 0, 0), Wl.save(), this.clipBbox(ml, rl, Gl, Ll, Cl), ml.baseTransform = (0, d.getCurrentTransform)(ml.ctx), ml.executeOperatorList(r), ml.endDrawing(), {
            canvas: Rl.canvas,
            scaleX: sl.scale,
            scaleY: Vl.scale,
            offsetX: rl,
            offsetY: Gl
          };
        }
        getSizeAndScale(b, r, G) {
          b = Math.abs(b);
          const J = Math.max(Q.MAX_PATTERN_SIZE, r);
          let T = Math.ceil(b * G);
          return T >= J ? T = J : G = T / b, {
            scale: G,
            size: T
          };
        }
        clipBbox(b, r, G, J, T) {
          const y = J - r, I = T - G;
          b.ctx.rect(r, G, y, I), b.current.updateRectMinMax((0, d.getCurrentTransform)(b.ctx), [r, G, J, T]), b.clip(), b.endPath();
        }
        setFillAndStrokeStyleToContext(b, r, G) {
          const J = b.ctx, T = b.current;
          switch (r) {
            case N.COLORED:
              const y = this.ctx;
              J.fillStyle = y.fillStyle, J.strokeStyle = y.strokeStyle, T.fillColor = y.fillStyle, T.strokeColor = y.strokeStyle;
              break;
            case N.UNCOLORED:
              const I = e.Util.makeHexColor(G[0], G[1], G[2]);
              J.fillStyle = I, J.strokeStyle = I, T.fillColor = I, T.strokeColor = I;
              break;
            default:
              throw new e.FormatError(`Unsupported paint type: ${r}`);
          }
        }
        getPattern(b, r, G, J) {
          let T = G;
          J !== a.SHADING && (T = e.Util.transform(T, r.baseTransform), this.matrix && (T = e.Util.transform(T, this.matrix)));
          const y = this.createPatternCanvas(r);
          let I = new DOMMatrix(T);
          I = I.translate(y.offsetX, y.offsetY), I = I.scale(1 / y.scaleX, 1 / y.scaleY);
          const E = b.createPattern(y.canvas, "repeat");
          return E.setTransform(I), E;
        }
      }
      function u({
        src: X,
        srcPos: b = 0,
        dest: r,
        width: G,
        height: J,
        nonBlackColor: T = 4294967295,
        inverseDecode: y = !1
      }) {
        const I = e.FeatureTest.isLittleEndian ? 4278190080 : 255, [E, x] = y ? [T, I] : [I, T], v = G >> 3, A = G & 7, g = X.length;
        r = new Uint32Array(r.buffer);
        let D = 0;
        for (let C = 0; C < J; C++) {
          for (const Fl = b + v; b < Fl; b++) {
            const sl = b < g ? X[b] : 255;
            r[D++] = sl & 128 ? x : E, r[D++] = sl & 64 ? x : E, r[D++] = sl & 32 ? x : E, r[D++] = sl & 16 ? x : E, r[D++] = sl & 8 ? x : E, r[D++] = sl & 4 ? x : E, r[D++] = sl & 2 ? x : E, r[D++] = sl & 1 ? x : E;
          }
          if (A === 0)
            continue;
          const nl = b < g ? X[b++] : 255;
          for (let Fl = 0; Fl < A; Fl++)
            r[D++] = nl & 1 << 7 - Fl ? x : E;
        }
        return {
          srcPos: b,
          destPos: D
        };
      }
      const i = 16, c = 100, R = 4096, m = 15, M = 10, S = 1e3, p = 16;
      function Y(X, b) {
        if (X._removeMirroring)
          throw new Error("Context is already forwarding operations.");
        X.__originalSave = X.save, X.__originalRestore = X.restore, X.__originalRotate = X.rotate, X.__originalScale = X.scale, X.__originalTranslate = X.translate, X.__originalTransform = X.transform, X.__originalSetTransform = X.setTransform, X.__originalResetTransform = X.resetTransform, X.__originalClip = X.clip, X.__originalMoveTo = X.moveTo, X.__originalLineTo = X.lineTo, X.__originalBezierCurveTo = X.bezierCurveTo, X.__originalRect = X.rect, X.__originalClosePath = X.closePath, X.__originalBeginPath = X.beginPath, X._removeMirroring = () => {
          X.save = X.__originalSave, X.restore = X.__originalRestore, X.rotate = X.__originalRotate, X.scale = X.__originalScale, X.translate = X.__originalTranslate, X.transform = X.__originalTransform, X.setTransform = X.__originalSetTransform, X.resetTransform = X.__originalResetTransform, X.clip = X.__originalClip, X.moveTo = X.__originalMoveTo, X.lineTo = X.__originalLineTo, X.bezierCurveTo = X.__originalBezierCurveTo, X.rect = X.__originalRect, X.closePath = X.__originalClosePath, X.beginPath = X.__originalBeginPath, delete X._removeMirroring;
        }, X.save = function() {
          b.save(), this.__originalSave();
        }, X.restore = function() {
          b.restore(), this.__originalRestore();
        }, X.translate = function(G, J) {
          b.translate(G, J), this.__originalTranslate(G, J);
        }, X.scale = function(G, J) {
          b.scale(G, J), this.__originalScale(G, J);
        }, X.transform = function(G, J, T, y, I, E) {
          b.transform(G, J, T, y, I, E), this.__originalTransform(G, J, T, y, I, E);
        }, X.setTransform = function(G, J, T, y, I, E) {
          b.setTransform(G, J, T, y, I, E), this.__originalSetTransform(G, J, T, y, I, E);
        }, X.resetTransform = function() {
          b.resetTransform(), this.__originalResetTransform();
        }, X.rotate = function(G) {
          b.rotate(G), this.__originalRotate(G);
        }, X.clip = function(G) {
          b.clip(G), this.__originalClip(G);
        }, X.moveTo = function(r, G) {
          b.moveTo(r, G), this.__originalMoveTo(r, G);
        }, X.lineTo = function(r, G) {
          b.lineTo(r, G), this.__originalLineTo(r, G);
        }, X.bezierCurveTo = function(r, G, J, T, y, I) {
          b.bezierCurveTo(r, G, J, T, y, I), this.__originalBezierCurveTo(r, G, J, T, y, I);
        }, X.rect = function(r, G, J, T) {
          b.rect(r, G, J, T), this.__originalRect(r, G, J, T);
        }, X.closePath = function() {
          b.closePath(), this.__originalClosePath();
        }, X.beginPath = function() {
          b.beginPath(), this.__originalBeginPath();
        };
      }
      class k {
        constructor(b) {
          this.canvasFactory = b, this.cache = /* @__PURE__ */ Object.create(null);
        }
        getCanvas(b, r, G) {
          let J;
          return this.cache[b] !== void 0 ? (J = this.cache[b], this.canvasFactory.reset(J, r, G)) : (J = this.canvasFactory.create(r, G), this.cache[b] = J), J;
        }
        delete(b) {
          delete this.cache[b];
        }
        clear() {
          for (const b in this.cache) {
            const r = this.cache[b];
            this.canvasFactory.destroy(r), delete this.cache[b];
          }
        }
      }
      function L(X, b, r, G, J, T, y, I, E, x) {
        const [v, A, g, D, C, nl] = (0, d.getCurrentTransform)(X);
        if (A === 0 && g === 0) {
          const Vl = y * v + C, Rl = Math.round(Vl), Wl = I * D + nl, ml = Math.round(Wl), rl = (y + E) * v + C, Gl = Math.abs(Math.round(rl) - Rl) || 1, Ll = (I + x) * D + nl, Cl = Math.abs(Math.round(Ll) - ml) || 1;
          return X.setTransform(Math.sign(v), 0, 0, Math.sign(D), Rl, ml), X.drawImage(b, r, G, J, T, 0, 0, Gl, Cl), X.setTransform(v, A, g, D, C, nl), [Gl, Cl];
        }
        if (v === 0 && D === 0) {
          const Vl = I * g + C, Rl = Math.round(Vl), Wl = y * A + nl, ml = Math.round(Wl), rl = (I + x) * g + C, Gl = Math.abs(Math.round(rl) - Rl) || 1, Ll = (y + E) * A + nl, Cl = Math.abs(Math.round(Ll) - ml) || 1;
          return X.setTransform(0, Math.sign(A), Math.sign(g), 0, Rl, ml), X.drawImage(b, r, G, J, T, 0, 0, Cl, Gl), X.setTransform(v, A, g, D, C, nl), [Cl, Gl];
        }
        X.drawImage(b, r, G, J, T, y, I, E, x);
        const Fl = Math.hypot(v, A), sl = Math.hypot(g, D);
        return [Fl * E, sl * x];
      }
      function z(X) {
        const {
          width: b,
          height: r
        } = X;
        if (b > S || r > S)
          return null;
        const G = 1e3, J = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), T = b + 1;
        let y = new Uint8Array(T * (r + 1)), I, E, x;
        const v = b + 7 & -8;
        let A = new Uint8Array(v * r), g = 0;
        for (const sl of X.data) {
          let Vl = 128;
          for (; Vl > 0; )
            A[g++] = sl & Vl ? 0 : 255, Vl >>= 1;
        }
        let D = 0;
        for (g = 0, A[g] !== 0 && (y[0] = 1, ++D), E = 1; E < b; E++)
          A[g] !== A[g + 1] && (y[E] = A[g] ? 2 : 1, ++D), g++;
        for (A[g] !== 0 && (y[E] = 2, ++D), I = 1; I < r; I++) {
          g = I * v, x = I * T, A[g - v] !== A[g] && (y[x] = A[g] ? 1 : 8, ++D);
          let sl = (A[g] ? 4 : 0) + (A[g - v] ? 8 : 0);
          for (E = 1; E < b; E++)
            sl = (sl >> 2) + (A[g + 1] ? 4 : 0) + (A[g - v + 1] ? 8 : 0), J[sl] && (y[x + E] = J[sl], ++D), g++;
          if (A[g - v] !== A[g] && (y[x + E] = A[g] ? 2 : 4, ++D), D > G)
            return null;
        }
        for (g = v * (r - 1), x = I * T, A[g] !== 0 && (y[x] = 8, ++D), E = 1; E < b; E++)
          A[g] !== A[g + 1] && (y[x + E] = A[g] ? 4 : 8, ++D), g++;
        if (A[g] !== 0 && (y[x + E] = 4, ++D), D > G)
          return null;
        const C = new Int32Array([0, T, -1, 0, -T, 0, 0, 0, 1]), nl = new Path2D();
        for (I = 0; D && I <= r; I++) {
          let sl = I * T;
          const Vl = sl + b;
          for (; sl < Vl && !y[sl]; )
            sl++;
          if (sl === Vl)
            continue;
          nl.moveTo(sl % T, I);
          const Rl = sl;
          let Wl = y[sl];
          do {
            const ml = C[Wl];
            do
              sl += ml;
            while (!y[sl]);
            const rl = y[sl];
            rl !== 5 && rl !== 10 ? (Wl = rl, y[sl] = 0) : (Wl = rl & 51 * Wl >> 4, y[sl] &= Wl >> 2 | Wl << 2), nl.lineTo(sl % T, sl / T | 0), y[sl] || --D;
          } while (Rl !== sl);
          --I;
        }
        return A = null, y = null, function(sl) {
          sl.save(), sl.scale(1 / b, -1 / r), sl.translate(0, -r), sl.fill(nl), sl.beginPath(), sl.restore();
        };
      }
      class f {
        constructor(b, r) {
          this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = e.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = e.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = e.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, b, r]);
        }
        clone() {
          const b = Object.create(this);
          return b.clipBox = this.clipBox.slice(), b;
        }
        setCurrentPoint(b, r) {
          this.x = b, this.y = r;
        }
        updatePathMinMax(b, r, G) {
          [r, G] = e.Util.applyTransform([r, G], b), this.minX = Math.min(this.minX, r), this.minY = Math.min(this.minY, G), this.maxX = Math.max(this.maxX, r), this.maxY = Math.max(this.maxY, G);
        }
        updateRectMinMax(b, r) {
          const G = e.Util.applyTransform(r, b), J = e.Util.applyTransform(r.slice(2), b), T = e.Util.applyTransform([r[0], r[3]], b), y = e.Util.applyTransform([r[2], r[1]], b);
          this.minX = Math.min(this.minX, G[0], J[0], T[0], y[0]), this.minY = Math.min(this.minY, G[1], J[1], T[1], y[1]), this.maxX = Math.max(this.maxX, G[0], J[0], T[0], y[0]), this.maxY = Math.max(this.maxY, G[1], J[1], T[1], y[1]);
        }
        updateScalingPathMinMax(b, r) {
          e.Util.scaleMinMax(b, r), this.minX = Math.min(this.minX, r[0]), this.minY = Math.min(this.minY, r[1]), this.maxX = Math.max(this.maxX, r[2]), this.maxY = Math.max(this.maxY, r[3]);
        }
        updateCurvePathMinMax(b, r, G, J, T, y, I, E, x, v) {
          const A = e.Util.bezierBoundingBox(r, G, J, T, y, I, E, x, v);
          v || this.updateRectMinMax(b, A);
        }
        getPathBoundingBox(b = a.FILL, r = null) {
          const G = [this.minX, this.minY, this.maxX, this.maxY];
          if (b === a.STROKE) {
            r || (0, e.unreachable)("Stroke bounding box must include transform.");
            const J = e.Util.singularValueDecompose2dScale(r), T = J[0] * this.lineWidth / 2, y = J[1] * this.lineWidth / 2;
            G[0] -= T, G[1] -= y, G[2] += T, G[3] += y;
          }
          return G;
        }
        updateClipFromPath() {
          const b = e.Util.intersect(this.clipBox, this.getPathBoundingBox());
          this.startNewPathAndClipBox(b || [0, 0, 0, 0]);
        }
        isEmptyClip() {
          return this.minX === 1 / 0;
        }
        startNewPathAndClipBox(b) {
          this.clipBox = b, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
        }
        getClippedPathBoundingBox(b = a.FILL, r = null) {
          return e.Util.intersect(this.clipBox, this.getPathBoundingBox(b, r));
        }
      }
      function K(X, b) {
        if (typeof ImageData < "u" && b instanceof ImageData) {
          X.putImageData(b, 0, 0);
          return;
        }
        const r = b.height, G = b.width, J = r % p, T = (r - J) / p, y = J === 0 ? T : T + 1, I = X.createImageData(G, p);
        let E = 0, x;
        const v = b.data, A = I.data;
        let g, D, C, nl;
        if (b.kind === e.ImageKind.GRAYSCALE_1BPP) {
          const Fl = v.byteLength, sl = new Uint32Array(A.buffer, 0, A.byteLength >> 2), Vl = sl.length, Rl = G + 7 >> 3, Wl = 4294967295, ml = e.FeatureTest.isLittleEndian ? 4278190080 : 255;
          for (g = 0; g < y; g++) {
            for (C = g < T ? p : J, x = 0, D = 0; D < C; D++) {
              const rl = Fl - E;
              let Gl = 0;
              const Ll = rl > Rl ? G : rl * 8 - 7, Cl = Ll & -8;
              let $ = 0, hl = 0;
              for (; Gl < Cl; Gl += 8)
                hl = v[E++], sl[x++] = hl & 128 ? Wl : ml, sl[x++] = hl & 64 ? Wl : ml, sl[x++] = hl & 32 ? Wl : ml, sl[x++] = hl & 16 ? Wl : ml, sl[x++] = hl & 8 ? Wl : ml, sl[x++] = hl & 4 ? Wl : ml, sl[x++] = hl & 2 ? Wl : ml, sl[x++] = hl & 1 ? Wl : ml;
              for (; Gl < Ll; Gl++)
                $ === 0 && (hl = v[E++], $ = 128), sl[x++] = hl & $ ? Wl : ml, $ >>= 1;
            }
            for (; x < Vl; )
              sl[x++] = 0;
            X.putImageData(I, 0, g * p);
          }
        } else if (b.kind === e.ImageKind.RGBA_32BPP) {
          for (D = 0, nl = G * p * 4, g = 0; g < T; g++)
            A.set(v.subarray(E, E + nl)), E += nl, X.putImageData(I, 0, D), D += p;
          g < y && (nl = G * J * 4, A.set(v.subarray(E, E + nl)), X.putImageData(I, 0, D));
        } else if (b.kind === e.ImageKind.RGB_24BPP)
          for (C = p, nl = G * C, g = 0; g < y; g++) {
            for (g >= T && (C = J, nl = G * C), x = 0, D = nl; D--; )
              A[x++] = v[E++], A[x++] = v[E++], A[x++] = v[E++], A[x++] = 255;
            X.putImageData(I, 0, g * p);
          }
        else
          throw new Error(`bad image kind: ${b.kind}`);
      }
      function P(X, b) {
        if (b.bitmap) {
          X.drawImage(b.bitmap, 0, 0);
          return;
        }
        const r = b.height, G = b.width, J = r % p, T = (r - J) / p, y = J === 0 ? T : T + 1, I = X.createImageData(G, p);
        let E = 0;
        const x = b.data, v = I.data;
        for (let A = 0; A < y; A++) {
          const g = A < T ? p : J;
          ({
            srcPos: E
          } = u({
            src: x,
            srcPos: E,
            dest: v,
            width: G,
            height: g,
            nonBlackColor: 0
          })), X.putImageData(I, 0, A * p);
        }
      }
      function w(X, b) {
        const r = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
        for (const G of r)
          X[G] !== void 0 && (b[G] = X[G]);
        X.setLineDash !== void 0 && (b.setLineDash(X.getLineDash()), b.lineDashOffset = X.lineDashOffset);
      }
      function O(X) {
        if (X.strokeStyle = X.fillStyle = "#000000", X.fillRule = "nonzero", X.globalAlpha = 1, X.lineWidth = 1, X.lineCap = "butt", X.lineJoin = "miter", X.miterLimit = 10, X.globalCompositeOperation = "source-over", X.font = "10px sans-serif", X.setLineDash !== void 0 && (X.setLineDash([]), X.lineDashOffset = 0), !e.isNodeJS) {
          const {
            filter: b
          } = X;
          b !== "none" && b !== "" && (X.filter = "none");
        }
      }
      function el(X, b, r, G) {
        const J = X.length;
        for (let T = 3; T < J; T += 4) {
          const y = X[T];
          if (y === 0)
            X[T - 3] = b, X[T - 2] = r, X[T - 1] = G;
          else if (y < 255) {
            const I = 255 - y;
            X[T - 3] = X[T - 3] * y + b * I >> 8, X[T - 2] = X[T - 2] * y + r * I >> 8, X[T - 1] = X[T - 1] * y + G * I >> 8;
          }
        }
      }
      function ll(X, b, r) {
        const G = X.length, J = 1 / 255;
        for (let T = 3; T < G; T += 4) {
          const y = r ? r[X[T]] : X[T];
          b[T] = b[T] * y * J | 0;
        }
      }
      function q(X, b, r) {
        const G = X.length;
        for (let J = 3; J < G; J += 4) {
          const T = X[J - 3] * 77 + X[J - 2] * 152 + X[J - 1] * 28;
          b[J] = r ? b[J] * r[T >> 8] >> 8 : b[J] * T >> 16;
        }
      }
      function _(X, b, r, G, J, T, y, I, E, x, v) {
        const A = !!T, g = A ? T[0] : 0, D = A ? T[1] : 0, C = A ? T[2] : 0, nl = J === "Luminosity" ? q : ll, sl = Math.min(G, Math.ceil(1048576 / r));
        for (let Vl = 0; Vl < G; Vl += sl) {
          const Rl = Math.min(sl, G - Vl), Wl = X.getImageData(I - x, Vl + (E - v), r, Rl), ml = b.getImageData(I, Vl + E, r, Rl);
          A && el(Wl.data, g, D, C), nl(Wl.data, ml.data, y), b.putImageData(ml, I, Vl + E);
        }
      }
      function il(X, b, r, G) {
        const J = G[0], T = G[1], y = G[2] - J, I = G[3] - T;
        y === 0 || I === 0 || (_(b.context, r, y, I, b.subtype, b.backdrop, b.transferMap, J, T, b.offsetX, b.offsetY), X.save(), X.globalAlpha = 1, X.globalCompositeOperation = "source-over", X.setTransform(1, 0, 0, 1, 0, 0), X.drawImage(r.canvas, 0, 0), X.restore());
      }
      function dl(X, b) {
        if (b)
          return !0;
        const r = e.Util.singularValueDecompose2dScale(X);
        r[0] = Math.fround(r[0]), r[1] = Math.fround(r[1]);
        const G = Math.fround((globalThis.devicePixelRatio || 1) * d.PixelsPerInch.PDF_TO_CSS_UNITS);
        return r[0] <= G && r[1] <= G;
      }
      const tl = ["butt", "round", "square"], al = ["miter", "round", "bevel"], Ul = {}, cl = {};
      class B {
        constructor(b, r, G, J, T, {
          optionalContentConfig: y,
          markedContentStack: I = null
        }, E, x) {
          this.ctx = b, this.current = new f(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = r, this.objs = G, this.canvasFactory = J, this.filterFactory = T, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = I || [], this.optionalContentConfig = y, this.cachedCanvases = new k(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = E, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = x, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
        }
        getObject(b, r = null) {
          return typeof b == "string" ? b.startsWith("g_") ? this.commonObjs.get(b) : this.objs.get(b) : r;
        }
        beginDrawing({
          transform: b,
          viewport: r,
          transparency: G = !1,
          background: J = null
        }) {
          const T = this.ctx.canvas.width, y = this.ctx.canvas.height, I = this.ctx.fillStyle;
          if (this.ctx.fillStyle = J || "#ffffff", this.ctx.fillRect(0, 0, T, y), this.ctx.fillStyle = I, G) {
            const E = this.cachedCanvases.getCanvas("transparent", T, y);
            this.compositeCtx = this.ctx, this.transparentCanvas = E.canvas, this.ctx = E.context, this.ctx.save(), this.ctx.transform(...(0, d.getCurrentTransform)(this.compositeCtx));
          }
          this.ctx.save(), O(this.ctx), b && (this.ctx.transform(...b), this.outputScaleX = b[0], this.outputScaleY = b[0]), this.ctx.transform(...r.transform), this.viewportScale = r.scale, this.baseTransform = (0, d.getCurrentTransform)(this.ctx);
        }
        executeOperatorList(b, r, G, J) {
          const T = b.argsArray, y = b.fnArray;
          let I = r || 0;
          const E = T.length;
          if (E === I)
            return I;
          const x = E - I > M && typeof G == "function", v = x ? Date.now() + m : 0;
          let A = 0;
          const g = this.commonObjs, D = this.objs;
          let C;
          for (; ; ) {
            if (J !== void 0 && I === J.nextBreakPoint)
              return J.breakIt(I, G), I;
            if (C = y[I], C !== e.OPS.dependency)
              this[C].apply(this, T[I]);
            else
              for (const nl of T[I]) {
                const Fl = nl.startsWith("g_") ? g : D;
                if (!Fl.has(nl))
                  return Fl.get(nl, G), I;
              }
            if (I++, I === E)
              return I;
            if (x && ++A > M) {
              if (Date.now() > v)
                return G(), I;
              A = 0;
            }
          }
        }
        #l() {
          for (; this.stateStack.length || this.inSMaskMode; )
            this.restore();
          this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
        }
        endDrawing() {
          this.#l(), this.cachedCanvases.clear(), this.cachedPatterns.clear();
          for (const b of this._cachedBitmapsMap.values()) {
            for (const r of b.values())
              typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement && (r.width = r.height = 0);
            b.clear();
          }
          this._cachedBitmapsMap.clear(), this.#t();
        }
        #t() {
          if (this.pageColors) {
            const b = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
            if (b !== "none") {
              const r = this.ctx.filter;
              this.ctx.filter = b, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = r;
            }
          }
        }
        _scaleImage(b, r) {
          const G = b.width, J = b.height;
          let T = Math.max(Math.hypot(r[0], r[1]), 1), y = Math.max(Math.hypot(r[2], r[3]), 1), I = G, E = J, x = "prescale1", v, A;
          for (; T > 2 && I > 1 || y > 2 && E > 1; ) {
            let g = I, D = E;
            T > 2 && I > 1 && (g = I >= 16384 ? Math.floor(I / 2) - 1 || 1 : Math.ceil(I / 2), T /= I / g), y > 2 && E > 1 && (D = E >= 16384 ? Math.floor(E / 2) - 1 || 1 : Math.ceil(E) / 2, y /= E / D), v = this.cachedCanvases.getCanvas(x, g, D), A = v.context, A.clearRect(0, 0, g, D), A.drawImage(b, 0, 0, I, E, 0, 0, g, D), b = v.canvas, I = g, E = D, x = x === "prescale1" ? "prescale2" : "prescale1";
          }
          return {
            img: b,
            paintWidth: I,
            paintHeight: E
          };
        }
        _createMaskCanvas(b) {
          const r = this.ctx, {
            width: G,
            height: J
          } = b, T = this.current.fillColor, y = this.current.patternFill, I = (0, d.getCurrentTransform)(r);
          let E, x, v, A;
          if ((b.bitmap || b.data) && b.count > 1) {
            const Ll = b.bitmap || b.data.buffer;
            x = JSON.stringify(y ? I : [I.slice(0, 4), T]), E = this._cachedBitmapsMap.get(Ll), E || (E = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(Ll, E));
            const Cl = E.get(x);
            if (Cl && !y) {
              const $ = Math.round(Math.min(I[0], I[2]) + I[4]), hl = Math.round(Math.min(I[1], I[3]) + I[5]);
              return {
                canvas: Cl,
                offsetX: $,
                offsetY: hl
              };
            }
            v = Cl;
          }
          v || (A = this.cachedCanvases.getCanvas("maskCanvas", G, J), P(A.context, b));
          let g = e.Util.transform(I, [1 / G, 0, 0, -1 / J, 0, 0]);
          g = e.Util.transform(g, [1, 0, 0, 1, 0, -J]);
          const [D, C, nl, Fl] = e.Util.getAxialAlignedBoundingBox([0, 0, G, J], g), sl = Math.round(nl - D) || 1, Vl = Math.round(Fl - C) || 1, Rl = this.cachedCanvases.getCanvas("fillCanvas", sl, Vl), Wl = Rl.context, ml = D, rl = C;
          Wl.translate(-ml, -rl), Wl.transform(...g), v || (v = this._scaleImage(A.canvas, (0, d.getCurrentTransformInverse)(Wl)), v = v.img, E && y && E.set(x, v)), Wl.imageSmoothingEnabled = dl((0, d.getCurrentTransform)(Wl), b.interpolate), L(Wl, v, 0, 0, v.width, v.height, 0, 0, G, J), Wl.globalCompositeOperation = "source-in";
          const Gl = e.Util.transform((0, d.getCurrentTransformInverse)(Wl), [1, 0, 0, 1, -ml, -rl]);
          return Wl.fillStyle = y ? T.getPattern(r, this, Gl, a.FILL) : T, Wl.fillRect(0, 0, G, J), E && !y && (this.cachedCanvases.delete("fillCanvas"), E.set(x, Rl.canvas)), {
            canvas: Rl.canvas,
            offsetX: Math.round(ml),
            offsetY: Math.round(rl)
          };
        }
        setLineWidth(b) {
          b !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = b, this.ctx.lineWidth = b;
        }
        setLineCap(b) {
          this.ctx.lineCap = tl[b];
        }
        setLineJoin(b) {
          this.ctx.lineJoin = al[b];
        }
        setMiterLimit(b) {
          this.ctx.miterLimit = b;
        }
        setDash(b, r) {
          const G = this.ctx;
          G.setLineDash !== void 0 && (G.setLineDash(b), G.lineDashOffset = r);
        }
        setRenderingIntent(b) {
        }
        setFlatness(b) {
        }
        setGState(b) {
          for (const [r, G] of b)
            switch (r) {
              case "LW":
                this.setLineWidth(G);
                break;
              case "LC":
                this.setLineCap(G);
                break;
              case "LJ":
                this.setLineJoin(G);
                break;
              case "ML":
                this.setMiterLimit(G);
                break;
              case "D":
                this.setDash(G[0], G[1]);
                break;
              case "RI":
                this.setRenderingIntent(G);
                break;
              case "FL":
                this.setFlatness(G);
                break;
              case "Font":
                this.setFont(G[0], G[1]);
                break;
              case "CA":
                this.current.strokeAlpha = G;
                break;
              case "ca":
                this.current.fillAlpha = G, this.ctx.globalAlpha = G;
                break;
              case "BM":
                this.ctx.globalCompositeOperation = G;
                break;
              case "SMask":
                this.current.activeSMask = G ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                break;
              case "TR":
                this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(G);
                break;
            }
        }
        get inSMaskMode() {
          return !!this.suspendedCtx;
        }
        checkSMaskState() {
          const b = this.inSMaskMode;
          this.current.activeSMask && !b ? this.beginSMaskMode() : !this.current.activeSMask && b && this.endSMaskMode();
        }
        beginSMaskMode() {
          if (this.inSMaskMode)
            throw new Error("beginSMaskMode called while already in smask mode");
          const b = this.ctx.canvas.width, r = this.ctx.canvas.height, G = "smaskGroupAt" + this.groupLevel, J = this.cachedCanvases.getCanvas(G, b, r);
          this.suspendedCtx = this.ctx, this.ctx = J.context;
          const T = this.ctx;
          T.setTransform(...(0, d.getCurrentTransform)(this.suspendedCtx)), w(this.suspendedCtx, T), Y(T, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
        }
        endSMaskMode() {
          if (!this.inSMaskMode)
            throw new Error("endSMaskMode called while not in smask mode");
          this.ctx._removeMirroring(), w(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
        }
        compose(b) {
          if (!this.current.activeSMask)
            return;
          b ? (b[0] = Math.floor(b[0]), b[1] = Math.floor(b[1]), b[2] = Math.ceil(b[2]), b[3] = Math.ceil(b[3])) : b = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
          const r = this.current.activeSMask, G = this.suspendedCtx;
          il(G, r, this.ctx, b), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
        }
        save() {
          this.inSMaskMode ? (w(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
          const b = this.current;
          this.stateStack.push(b), this.current = b.clone();
        }
        restore() {
          this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), w(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
        }
        transform(b, r, G, J, T, y) {
          this.ctx.transform(b, r, G, J, T, y), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
        }
        constructPath(b, r, G) {
          const J = this.ctx, T = this.current;
          let y = T.x, I = T.y, E, x;
          const v = (0, d.getCurrentTransform)(J), A = v[0] === 0 && v[3] === 0 || v[1] === 0 && v[2] === 0, g = A ? G.slice(0) : null;
          for (let D = 0, C = 0, nl = b.length; D < nl; D++)
            switch (b[D] | 0) {
              case e.OPS.rectangle:
                y = r[C++], I = r[C++];
                const Fl = r[C++], sl = r[C++], Vl = y + Fl, Rl = I + sl;
                J.moveTo(y, I), Fl === 0 || sl === 0 ? J.lineTo(Vl, Rl) : (J.lineTo(Vl, I), J.lineTo(Vl, Rl), J.lineTo(y, Rl)), A || T.updateRectMinMax(v, [y, I, Vl, Rl]), J.closePath();
                break;
              case e.OPS.moveTo:
                y = r[C++], I = r[C++], J.moveTo(y, I), A || T.updatePathMinMax(v, y, I);
                break;
              case e.OPS.lineTo:
                y = r[C++], I = r[C++], J.lineTo(y, I), A || T.updatePathMinMax(v, y, I);
                break;
              case e.OPS.curveTo:
                E = y, x = I, y = r[C + 4], I = r[C + 5], J.bezierCurveTo(r[C], r[C + 1], r[C + 2], r[C + 3], y, I), T.updateCurvePathMinMax(v, E, x, r[C], r[C + 1], r[C + 2], r[C + 3], y, I, g), C += 6;
                break;
              case e.OPS.curveTo2:
                E = y, x = I, J.bezierCurveTo(y, I, r[C], r[C + 1], r[C + 2], r[C + 3]), T.updateCurvePathMinMax(v, E, x, y, I, r[C], r[C + 1], r[C + 2], r[C + 3], g), y = r[C + 2], I = r[C + 3], C += 4;
                break;
              case e.OPS.curveTo3:
                E = y, x = I, y = r[C + 2], I = r[C + 3], J.bezierCurveTo(r[C], r[C + 1], y, I, y, I), T.updateCurvePathMinMax(v, E, x, r[C], r[C + 1], y, I, y, I, g), C += 4;
                break;
              case e.OPS.closePath:
                J.closePath();
                break;
            }
          A && T.updateScalingPathMinMax(v, g), T.setCurrentPoint(y, I);
        }
        closePath() {
          this.ctx.closePath();
        }
        stroke(b = !0) {
          const r = this.ctx, G = this.current.strokeColor;
          r.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof G == "object" && G?.getPattern ? (r.save(), r.strokeStyle = G.getPattern(r, this, (0, d.getCurrentTransformInverse)(r), a.STROKE), this.rescaleAndStroke(!1), r.restore()) : this.rescaleAndStroke(!0)), b && this.consumePath(this.current.getClippedPathBoundingBox()), r.globalAlpha = this.current.fillAlpha;
        }
        closeStroke() {
          this.closePath(), this.stroke();
        }
        fill(b = !0) {
          const r = this.ctx, G = this.current.fillColor, J = this.current.patternFill;
          let T = !1;
          J && (r.save(), r.fillStyle = G.getPattern(r, this, (0, d.getCurrentTransformInverse)(r), a.FILL), T = !0);
          const y = this.current.getClippedPathBoundingBox();
          this.contentVisible && y !== null && (this.pendingEOFill ? (r.fill("evenodd"), this.pendingEOFill = !1) : r.fill()), T && r.restore(), b && this.consumePath(y);
        }
        eoFill() {
          this.pendingEOFill = !0, this.fill();
        }
        fillStroke() {
          this.fill(!1), this.stroke(!1), this.consumePath();
        }
        eoFillStroke() {
          this.pendingEOFill = !0, this.fillStroke();
        }
        closeFillStroke() {
          this.closePath(), this.fillStroke();
        }
        closeEOFillStroke() {
          this.pendingEOFill = !0, this.closePath(), this.fillStroke();
        }
        endPath() {
          this.consumePath();
        }
        clip() {
          this.pendingClip = Ul;
        }
        eoClip() {
          this.pendingClip = cl;
        }
        beginText() {
          this.current.textMatrix = e.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
        }
        endText() {
          const b = this.pendingTextPaths, r = this.ctx;
          if (b === void 0) {
            r.beginPath();
            return;
          }
          r.save(), r.beginPath();
          for (const G of b)
            r.setTransform(...G.transform), r.translate(G.x, G.y), G.addToPath(r, G.fontSize);
          r.restore(), r.clip(), r.beginPath(), delete this.pendingTextPaths;
        }
        setCharSpacing(b) {
          this.current.charSpacing = b;
        }
        setWordSpacing(b) {
          this.current.wordSpacing = b;
        }
        setHScale(b) {
          this.current.textHScale = b / 100;
        }
        setLeading(b) {
          this.current.leading = -b;
        }
        setFont(b, r) {
          const G = this.commonObjs.get(b), J = this.current;
          if (!G)
            throw new Error(`Can't find font for ${b}`);
          if (J.fontMatrix = G.fontMatrix || e.FONT_IDENTITY_MATRIX, (J.fontMatrix[0] === 0 || J.fontMatrix[3] === 0) && (0, e.warn)("Invalid font matrix for font " + b), r < 0 ? (r = -r, J.fontDirection = -1) : J.fontDirection = 1, this.current.font = G, this.current.fontSize = r, G.isType3Font)
            return;
          const T = G.loadedName || "sans-serif", y = G.systemFontInfo?.css || `"${T}", ${G.fallbackName}`;
          let I = "normal";
          G.black ? I = "900" : G.bold && (I = "bold");
          const E = G.italic ? "italic" : "normal";
          let x = r;
          r < i ? x = i : r > c && (x = c), this.current.fontSizeScale = r / x, this.ctx.font = `${E} ${I} ${x}px ${y}`;
        }
        setTextRenderingMode(b) {
          this.current.textRenderingMode = b;
        }
        setTextRise(b) {
          this.current.textRise = b;
        }
        moveText(b, r) {
          this.current.x = this.current.lineX += b, this.current.y = this.current.lineY += r;
        }
        setLeadingMoveText(b, r) {
          this.setLeading(-r), this.moveText(b, r);
        }
        setTextMatrix(b, r, G, J, T, y) {
          this.current.textMatrix = [b, r, G, J, T, y], this.current.textMatrixScale = Math.hypot(b, r), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
        }
        nextLine() {
          this.moveText(0, this.current.leading);
        }
        paintChar(b, r, G, J) {
          const T = this.ctx, y = this.current, I = y.font, E = y.textRenderingMode, x = y.fontSize / y.fontSizeScale, v = E & e.TextRenderingMode.FILL_STROKE_MASK, A = !!(E & e.TextRenderingMode.ADD_TO_PATH_FLAG), g = y.patternFill && !I.missingFile;
          let D;
          (I.disableFontFace || A || g) && (D = I.getPathGenerator(this.commonObjs, b)), I.disableFontFace || g ? (T.save(), T.translate(r, G), T.beginPath(), D(T, x), J && T.setTransform(...J), (v === e.TextRenderingMode.FILL || v === e.TextRenderingMode.FILL_STROKE) && T.fill(), (v === e.TextRenderingMode.STROKE || v === e.TextRenderingMode.FILL_STROKE) && T.stroke(), T.restore()) : ((v === e.TextRenderingMode.FILL || v === e.TextRenderingMode.FILL_STROKE) && T.fillText(b, r, G), (v === e.TextRenderingMode.STROKE || v === e.TextRenderingMode.FILL_STROKE) && T.strokeText(b, r, G)), A && (this.pendingTextPaths ||= []).push({
            transform: (0, d.getCurrentTransform)(T),
            x: r,
            y: G,
            fontSize: x,
            addToPath: D
          });
        }
        get isFontSubpixelAAEnabled() {
          const {
            context: b
          } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
          b.scale(1.5, 1), b.fillText("I", 0, 10);
          const r = b.getImageData(0, 0, 10, 10).data;
          let G = !1;
          for (let J = 3; J < r.length; J += 4)
            if (r[J] > 0 && r[J] < 255) {
              G = !0;
              break;
            }
          return (0, e.shadow)(this, "isFontSubpixelAAEnabled", G);
        }
        showText(b) {
          const r = this.current, G = r.font;
          if (G.isType3Font)
            return this.showType3Text(b);
          const J = r.fontSize;
          if (J === 0)
            return;
          const T = this.ctx, y = r.fontSizeScale, I = r.charSpacing, E = r.wordSpacing, x = r.fontDirection, v = r.textHScale * x, A = b.length, g = G.vertical, D = g ? 1 : -1, C = G.defaultVMetrics, nl = J * r.fontMatrix[0], Fl = r.textRenderingMode === e.TextRenderingMode.FILL && !G.disableFontFace && !r.patternFill;
          T.save(), T.transform(...r.textMatrix), T.translate(r.x, r.y + r.textRise), x > 0 ? T.scale(v, -1) : T.scale(v, 1);
          let sl;
          if (r.patternFill) {
            T.save();
            const rl = r.fillColor.getPattern(T, this, (0, d.getCurrentTransformInverse)(T), a.FILL);
            sl = (0, d.getCurrentTransform)(T), T.restore(), T.fillStyle = rl;
          }
          let Vl = r.lineWidth;
          const Rl = r.textMatrixScale;
          if (Rl === 0 || Vl === 0) {
            const rl = r.textRenderingMode & e.TextRenderingMode.FILL_STROKE_MASK;
            (rl === e.TextRenderingMode.STROKE || rl === e.TextRenderingMode.FILL_STROKE) && (Vl = this.getSinglePixelWidth());
          } else
            Vl /= Rl;
          if (y !== 1 && (T.scale(y, y), Vl /= y), T.lineWidth = Vl, G.isInvalidPDFjsFont) {
            const rl = [];
            let Gl = 0;
            for (const Ll of b)
              rl.push(Ll.unicode), Gl += Ll.width;
            T.fillText(rl.join(""), 0, 0), r.x += Gl * nl * v, T.restore(), this.compose();
            return;
          }
          let Wl = 0, ml;
          for (ml = 0; ml < A; ++ml) {
            const rl = b[ml];
            if (typeof rl == "number") {
              Wl += D * rl * J / 1e3;
              continue;
            }
            let Gl = !1;
            const Ll = (rl.isSpace ? E : 0) + I, Cl = rl.fontChar, $ = rl.accent;
            let hl, Tl, Jl = rl.width;
            if (g) {
              const Il = rl.vmetric || C, gl = -(rl.vmetric ? Il[1] : Jl * 0.5) * nl, wl = Il[2] * nl;
              Jl = Il ? -Il[0] : Jl, hl = gl / y, Tl = (Wl + wl) / y;
            } else
              hl = Wl / y, Tl = 0;
            if (G.remeasure && Jl > 0) {
              const Il = T.measureText(Cl).width * 1e3 / J * y;
              if (Jl < Il && this.isFontSubpixelAAEnabled) {
                const gl = Jl / Il;
                Gl = !0, T.save(), T.scale(gl, 1), hl /= gl;
              } else
                Jl !== Il && (hl += (Jl - Il) / 2e3 * J / y);
            }
            if (this.contentVisible && (rl.isInFont || G.missingFile)) {
              if (Fl && !$)
                T.fillText(Cl, hl, Tl);
              else if (this.paintChar(Cl, hl, Tl, sl), $) {
                const Il = hl + J * $.offset.x / y, gl = Tl - J * $.offset.y / y;
                this.paintChar($.fontChar, Il, gl, sl);
              }
            }
            const yl = g ? Jl * nl - Ll * x : Jl * nl + Ll * x;
            Wl += yl, Gl && T.restore();
          }
          g ? r.y -= Wl : r.x += Wl * v, T.restore(), this.compose();
        }
        showType3Text(b) {
          const r = this.ctx, G = this.current, J = G.font, T = G.fontSize, y = G.fontDirection, I = J.vertical ? 1 : -1, E = G.charSpacing, x = G.wordSpacing, v = G.textHScale * y, A = G.fontMatrix || e.FONT_IDENTITY_MATRIX, g = b.length, D = G.textRenderingMode === e.TextRenderingMode.INVISIBLE;
          let C, nl, Fl, sl;
          if (!(D || T === 0)) {
            for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, r.save(), r.transform(...G.textMatrix), r.translate(G.x, G.y), r.scale(v, y), C = 0; C < g; ++C) {
              if (nl = b[C], typeof nl == "number") {
                sl = I * nl * T / 1e3, this.ctx.translate(sl, 0), G.x += sl * v;
                continue;
              }
              const Vl = (nl.isSpace ? x : 0) + E, Rl = J.charProcOperatorList[nl.operatorListId];
              if (!Rl) {
                (0, e.warn)(`Type3 character "${nl.operatorListId}" is not available.`);
                continue;
              }
              this.contentVisible && (this.processingType3 = nl, this.save(), r.scale(T, T), r.transform(...A), this.executeOperatorList(Rl), this.restore()), Fl = e.Util.applyTransform([nl.width, 0], A)[0] * T + Vl, r.translate(Fl, 0), G.x += Fl * v;
            }
            r.restore(), this.processingType3 = null;
          }
        }
        setCharWidth(b, r) {
        }
        setCharWidthAndBounds(b, r, G, J, T, y) {
          this.ctx.rect(G, J, T - G, y - J), this.ctx.clip(), this.endPath();
        }
        getColorN_Pattern(b) {
          let r;
          if (b[0] === "TilingPattern") {
            const G = b[1], J = this.baseTransform || (0, d.getCurrentTransform)(this.ctx), T = {
              createCanvasGraphics: (y) => new B(y, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                optionalContentConfig: this.optionalContentConfig,
                markedContentStack: this.markedContentStack
              })
            };
            r = new Q(b, G, this.ctx, T, J);
          } else
            r = this._getPattern(b[1], b[2]);
          return r;
        }
        setStrokeColorN() {
          this.current.strokeColor = this.getColorN_Pattern(arguments);
        }
        setFillColorN() {
          this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
        }
        setStrokeRGBColor(b, r, G) {
          const J = e.Util.makeHexColor(b, r, G);
          this.ctx.strokeStyle = J, this.current.strokeColor = J;
        }
        setFillRGBColor(b, r, G) {
          const J = e.Util.makeHexColor(b, r, G);
          this.ctx.fillStyle = J, this.current.fillColor = J, this.current.patternFill = !1;
        }
        _getPattern(b, r = null) {
          let G;
          return this.cachedPatterns.has(b) ? G = this.cachedPatterns.get(b) : (G = F(this.getObject(b)), this.cachedPatterns.set(b, G)), r && (G.matrix = r), G;
        }
        shadingFill(b) {
          if (!this.contentVisible)
            return;
          const r = this.ctx;
          this.save();
          const G = this._getPattern(b);
          r.fillStyle = G.getPattern(r, this, (0, d.getCurrentTransformInverse)(r), a.SHADING);
          const J = (0, d.getCurrentTransformInverse)(r);
          if (J) {
            const {
              width: T,
              height: y
            } = r.canvas, [I, E, x, v] = e.Util.getAxialAlignedBoundingBox([0, 0, T, y], J);
            this.ctx.fillRect(I, E, x - I, v - E);
          } else
            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
          this.compose(this.current.getClippedPathBoundingBox()), this.restore();
        }
        beginInlineImage() {
          (0, e.unreachable)("Should not call beginInlineImage");
        }
        beginImageData() {
          (0, e.unreachable)("Should not call beginImageData");
        }
        paintFormXObjectBegin(b, r) {
          if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(b) && b.length === 6 && this.transform(...b), this.baseTransform = (0, d.getCurrentTransform)(this.ctx), r)) {
            const G = r[2] - r[0], J = r[3] - r[1];
            this.ctx.rect(r[0], r[1], G, J), this.current.updateRectMinMax((0, d.getCurrentTransform)(this.ctx), r), this.clip(), this.endPath();
          }
        }
        paintFormXObjectEnd() {
          this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
        }
        beginGroup(b) {
          if (!this.contentVisible)
            return;
          this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
          const r = this.ctx;
          b.isolated || (0, e.info)("TODO: Support non-isolated groups."), b.knockout && (0, e.warn)("Knockout groups not supported.");
          const G = (0, d.getCurrentTransform)(r);
          if (b.matrix && r.transform(...b.matrix), !b.bbox)
            throw new Error("Bounding box is required.");
          let J = e.Util.getAxialAlignedBoundingBox(b.bbox, (0, d.getCurrentTransform)(r));
          const T = [0, 0, r.canvas.width, r.canvas.height];
          J = e.Util.intersect(J, T) || [0, 0, 0, 0];
          const y = Math.floor(J[0]), I = Math.floor(J[1]);
          let E = Math.max(Math.ceil(J[2]) - y, 1), x = Math.max(Math.ceil(J[3]) - I, 1), v = 1, A = 1;
          E > R && (v = E / R, E = R), x > R && (A = x / R, x = R), this.current.startNewPathAndClipBox([0, 0, E, x]);
          let g = "groupAt" + this.groupLevel;
          b.smask && (g += "_smask_" + this.smaskCounter++ % 2);
          const D = this.cachedCanvases.getCanvas(g, E, x), C = D.context;
          C.scale(1 / v, 1 / A), C.translate(-y, -I), C.transform(...G), b.smask ? this.smaskStack.push({
            canvas: D.canvas,
            context: C,
            offsetX: y,
            offsetY: I,
            scaleX: v,
            scaleY: A,
            subtype: b.smask.subtype,
            backdrop: b.smask.backdrop,
            transferMap: b.smask.transferMap || null,
            startTransformInverse: null
          }) : (r.setTransform(1, 0, 0, 1, 0, 0), r.translate(y, I), r.scale(v, A), r.save()), w(r, C), this.ctx = C, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(r), this.groupLevel++;
        }
        endGroup(b) {
          if (!this.contentVisible)
            return;
          this.groupLevel--;
          const r = this.ctx, G = this.groupStack.pop();
          if (this.ctx = G, this.ctx.imageSmoothingEnabled = !1, b.smask)
            this.tempSMask = this.smaskStack.pop(), this.restore();
          else {
            this.ctx.restore();
            const J = (0, d.getCurrentTransform)(this.ctx);
            this.restore(), this.ctx.save(), this.ctx.setTransform(...J);
            const T = e.Util.getAxialAlignedBoundingBox([0, 0, r.canvas.width, r.canvas.height], J);
            this.ctx.drawImage(r.canvas, 0, 0), this.ctx.restore(), this.compose(T);
          }
        }
        beginAnnotation(b, r, G, J, T) {
          if (this.#l(), O(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(r) && r.length === 4) {
            const y = r[2] - r[0], I = r[3] - r[1];
            if (T && this.annotationCanvasMap) {
              G = G.slice(), G[4] -= r[0], G[5] -= r[1], r = r.slice(), r[0] = r[1] = 0, r[2] = y, r[3] = I;
              const [E, x] = e.Util.singularValueDecompose2dScale((0, d.getCurrentTransform)(this.ctx)), {
                viewportScale: v
              } = this, A = Math.ceil(y * this.outputScaleX * v), g = Math.ceil(I * this.outputScaleY * v);
              this.annotationCanvas = this.canvasFactory.create(A, g);
              const {
                canvas: D,
                context: C
              } = this.annotationCanvas;
              this.annotationCanvasMap.set(b, D), this.annotationCanvas.savedCtx = this.ctx, this.ctx = C, this.ctx.save(), this.ctx.setTransform(E, 0, 0, -x, 0, I * x), O(this.ctx);
            } else
              O(this.ctx), this.ctx.rect(r[0], r[1], y, I), this.ctx.clip(), this.endPath();
          }
          this.current = new f(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...G), this.transform(...J);
        }
        endAnnotation() {
          this.annotationCanvas && (this.ctx.restore(), this.#t(), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
        }
        paintImageMaskXObject(b) {
          if (!this.contentVisible)
            return;
          const r = b.count;
          b = this.getObject(b.data, b), b.count = r;
          const G = this.ctx, J = this.processingType3;
          if (J && (J.compiled === void 0 && (J.compiled = z(b)), J.compiled)) {
            J.compiled(G);
            return;
          }
          const T = this._createMaskCanvas(b), y = T.canvas;
          G.save(), G.setTransform(1, 0, 0, 1, 0, 0), G.drawImage(y, T.offsetX, T.offsetY), G.restore(), this.compose();
        }
        paintImageMaskXObjectRepeat(b, r, G = 0, J = 0, T, y) {
          if (!this.contentVisible)
            return;
          b = this.getObject(b.data, b);
          const I = this.ctx;
          I.save();
          const E = (0, d.getCurrentTransform)(I);
          I.transform(r, G, J, T, 0, 0);
          const x = this._createMaskCanvas(b);
          I.setTransform(1, 0, 0, 1, x.offsetX - E[4], x.offsetY - E[5]);
          for (let v = 0, A = y.length; v < A; v += 2) {
            const g = e.Util.transform(E, [r, G, J, T, y[v], y[v + 1]]), [D, C] = e.Util.applyTransform([0, 0], g);
            I.drawImage(x.canvas, D, C);
          }
          I.restore(), this.compose();
        }
        paintImageMaskXObjectGroup(b) {
          if (!this.contentVisible)
            return;
          const r = this.ctx, G = this.current.fillColor, J = this.current.patternFill;
          for (const T of b) {
            const {
              data: y,
              width: I,
              height: E,
              transform: x
            } = T, v = this.cachedCanvases.getCanvas("maskCanvas", I, E), A = v.context;
            A.save();
            const g = this.getObject(y, T);
            P(A, g), A.globalCompositeOperation = "source-in", A.fillStyle = J ? G.getPattern(A, this, (0, d.getCurrentTransformInverse)(r), a.FILL) : G, A.fillRect(0, 0, I, E), A.restore(), r.save(), r.transform(...x), r.scale(1, -1), L(r, v.canvas, 0, 0, I, E, 0, -1, 1, 1), r.restore();
          }
          this.compose();
        }
        paintImageXObject(b) {
          if (!this.contentVisible)
            return;
          const r = this.getObject(b);
          if (!r) {
            (0, e.warn)("Dependent image isn't ready yet");
            return;
          }
          this.paintInlineImageXObject(r);
        }
        paintImageXObjectRepeat(b, r, G, J) {
          if (!this.contentVisible)
            return;
          const T = this.getObject(b);
          if (!T) {
            (0, e.warn)("Dependent image isn't ready yet");
            return;
          }
          const y = T.width, I = T.height, E = [];
          for (let x = 0, v = J.length; x < v; x += 2)
            E.push({
              transform: [r, 0, 0, G, J[x], J[x + 1]],
              x: 0,
              y: 0,
              w: y,
              h: I
            });
          this.paintInlineImageXObjectGroup(T, E);
        }
        applyTransferMapsToCanvas(b) {
          return this.current.transferMaps !== "none" && (b.filter = this.current.transferMaps, b.drawImage(b.canvas, 0, 0), b.filter = "none"), b.canvas;
        }
        applyTransferMapsToBitmap(b) {
          if (this.current.transferMaps === "none")
            return b.bitmap;
          const {
            bitmap: r,
            width: G,
            height: J
          } = b, T = this.cachedCanvases.getCanvas("inlineImage", G, J), y = T.context;
          return y.filter = this.current.transferMaps, y.drawImage(r, 0, 0), y.filter = "none", T.canvas;
        }
        paintInlineImageXObject(b) {
          if (!this.contentVisible)
            return;
          const r = b.width, G = b.height, J = this.ctx;
          if (this.save(), !e.isNodeJS) {
            const {
              filter: I
            } = J;
            I !== "none" && I !== "" && (J.filter = "none");
          }
          J.scale(1 / r, -1 / G);
          let T;
          if (b.bitmap)
            T = this.applyTransferMapsToBitmap(b);
          else if (typeof HTMLElement == "function" && b instanceof HTMLElement || !b.data)
            T = b;
          else {
            const E = this.cachedCanvases.getCanvas("inlineImage", r, G).context;
            K(E, b), T = this.applyTransferMapsToCanvas(E);
          }
          const y = this._scaleImage(T, (0, d.getCurrentTransformInverse)(J));
          J.imageSmoothingEnabled = dl((0, d.getCurrentTransform)(J), b.interpolate), L(J, y.img, 0, 0, y.paintWidth, y.paintHeight, 0, -G, r, G), this.compose(), this.restore();
        }
        paintInlineImageXObjectGroup(b, r) {
          if (!this.contentVisible)
            return;
          const G = this.ctx;
          let J;
          if (b.bitmap)
            J = b.bitmap;
          else {
            const T = b.width, y = b.height, E = this.cachedCanvases.getCanvas("inlineImage", T, y).context;
            K(E, b), J = this.applyTransferMapsToCanvas(E);
          }
          for (const T of r)
            G.save(), G.transform(...T.transform), G.scale(1, -1), L(G, J, T.x, T.y, T.w, T.h, 0, -1, 1, 1), G.restore();
          this.compose();
        }
        paintSolidColorImageMask() {
          this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
        }
        markPoint(b) {
        }
        markPointProps(b, r) {
        }
        beginMarkedContent(b) {
          this.markedContentStack.push({
            visible: !0
          });
        }
        beginMarkedContentProps(b, r) {
          b === "OC" ? this.markedContentStack.push({
            visible: this.optionalContentConfig.isVisible(r)
          }) : this.markedContentStack.push({
            visible: !0
          }), this.contentVisible = this.isContentVisible();
        }
        endMarkedContent() {
          this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
        }
        beginCompat() {
        }
        endCompat() {
        }
        consumePath(b) {
          const r = this.current.isEmptyClip();
          this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(b);
          const G = this.ctx;
          this.pendingClip && (r || (this.pendingClip === cl ? G.clip("evenodd") : G.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), G.beginPath();
        }
        getSinglePixelWidth() {
          if (!this._cachedGetSinglePixelWidth) {
            const b = (0, d.getCurrentTransform)(this.ctx);
            if (b[1] === 0 && b[2] === 0)
              this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(b[0]), Math.abs(b[3]));
            else {
              const r = Math.abs(b[0] * b[3] - b[2] * b[1]), G = Math.hypot(b[0], b[2]), J = Math.hypot(b[1], b[3]);
              this._cachedGetSinglePixelWidth = Math.max(G, J) / r;
            }
          }
          return this._cachedGetSinglePixelWidth;
        }
        getScaleForStroking() {
          if (this._cachedScaleForStroking[0] === -1) {
            const {
              lineWidth: b
            } = this.current, {
              a: r,
              b: G,
              c: J,
              d: T
            } = this.ctx.getTransform();
            let y, I;
            if (G === 0 && J === 0) {
              const E = Math.abs(r), x = Math.abs(T);
              if (E === x)
                if (b === 0)
                  y = I = 1 / E;
                else {
                  const v = E * b;
                  y = I = v < 1 ? 1 / v : 1;
                }
              else if (b === 0)
                y = 1 / E, I = 1 / x;
              else {
                const v = E * b, A = x * b;
                y = v < 1 ? 1 / v : 1, I = A < 1 ? 1 / A : 1;
              }
            } else {
              const E = Math.abs(r * T - G * J), x = Math.hypot(r, G), v = Math.hypot(J, T);
              if (b === 0)
                y = v / E, I = x / E;
              else {
                const A = b * E;
                y = v > A ? v / A : 1, I = x > A ? x / A : 1;
              }
            }
            this._cachedScaleForStroking[0] = y, this._cachedScaleForStroking[1] = I;
          }
          return this._cachedScaleForStroking;
        }
        rescaleAndStroke(b) {
          const {
            ctx: r
          } = this, {
            lineWidth: G
          } = this.current, [J, T] = this.getScaleForStroking();
          if (r.lineWidth = G || 1, J === 1 && T === 1) {
            r.stroke();
            return;
          }
          const y = r.getLineDash();
          if (b && r.save(), r.scale(J, T), y.length > 0) {
            const I = Math.max(J, T);
            r.setLineDash(y.map((E) => E / I)), r.lineDashOffset /= I;
          }
          r.stroke(), b && r.restore();
        }
        isContentVisible() {
          for (let b = this.markedContentStack.length - 1; b >= 0; b--)
            if (!this.markedContentStack[b].visible)
              return !1;
          return !0;
        }
      }
      for (const X in e.OPS)
        B.prototype[X] !== void 0 && (B.prototype[e.OPS[X]] = B.prototype[X]);
    }
  ),
  /***/
  419: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        DOMCMapReaderFactory: () => (
          /* binding */
          Z
        ),
        /* harmony export */
        DOMCanvasFactory: () => (
          /* binding */
          h
        ),
        /* harmony export */
        DOMFilterFactory: () => (
          /* binding */
          V
        ),
        /* harmony export */
        DOMSVGFactory: () => (
          /* binding */
          o
        ),
        /* harmony export */
        DOMStandardFontDataFactory: () => (
          /* binding */
          s
        ),
        /* harmony export */
        PDFDateString: () => (
          /* binding */
          p
        ),
        /* harmony export */
        PageViewport: () => (
          /* binding */
          F
        ),
        /* harmony export */
        PixelsPerInch: () => (
          /* binding */
          U
        ),
        /* harmony export */
        RenderingCancelledException: () => (
          /* binding */
          N
        ),
        /* harmony export */
        StatTimer: () => (
          /* binding */
          R
        ),
        /* harmony export */
        fetchData: () => (
          /* binding */
          W
        ),
        /* harmony export */
        getColorValues: () => (
          /* binding */
          L
        ),
        /* harmony export */
        getCurrentTransform: () => (
          /* binding */
          z
        ),
        /* harmony export */
        getCurrentTransformInverse: () => (
          /* binding */
          f
        ),
        /* harmony export */
        getFilenameFromUrl: () => (
          /* binding */
          i
        ),
        /* harmony export */
        getPdfFilenameFromUrl: () => (
          /* binding */
          c
        ),
        /* harmony export */
        getRGB: () => (
          /* binding */
          k
        ),
        /* harmony export */
        getXfaPageViewport: () => (
          /* binding */
          Y
        ),
        /* harmony export */
        isDataScheme: () => (
          /* binding */
          Q
        ),
        /* harmony export */
        isPdfFile: () => (
          /* binding */
          u
        ),
        /* harmony export */
        isValidFetchUrl: () => (
          /* binding */
          m
        ),
        /* harmony export */
        noContextMenu: () => (
          /* binding */
          M
        ),
        /* harmony export */
        setLayerDimensions: () => (
          /* binding */
          K
        )
        /* harmony export */
      });
      var e = n(583), d = n(292);
      const a = "http://www.w3.org/2000/svg";
      class U {
        static CSS = 96;
        static PDF = 72;
        static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
      }
      class V extends e.BaseFilterFactory {
        #l;
        #t;
        #n;
        #d;
        #a;
        #e = 0;
        constructor({
          docId: w,
          ownerDocument: O = globalThis.document
        } = {}) {
          super(), this.#n = w, this.#d = O;
        }
        get #i() {
          return this.#l ||= /* @__PURE__ */ new Map();
        }
        get #U() {
          return this.#a ||= /* @__PURE__ */ new Map();
        }
        get #c() {
          if (!this.#t) {
            const w = this.#d.createElement("div"), {
              style: O
            } = w;
            O.visibility = "hidden", O.contain = "strict", O.width = O.height = 0, O.position = "absolute", O.top = O.left = 0, O.zIndex = -1;
            const el = this.#d.createElementNS(a, "svg");
            el.setAttribute("width", 0), el.setAttribute("height", 0), this.#t = this.#d.createElementNS(a, "defs"), w.append(el), el.append(this.#t), this.#d.body.append(w);
          }
          return this.#t;
        }
        addFilter(w) {
          if (!w)
            return "none";
          let O = this.#i.get(w);
          if (O)
            return O;
          let el, ll, q, _;
          if (w.length === 1) {
            const al = w[0], Ul = new Array(256);
            for (let cl = 0; cl < 256; cl++)
              Ul[cl] = al[cl] / 255;
            _ = el = ll = q = Ul.join(",");
          } else {
            const [al, Ul, cl] = w, B = new Array(256), X = new Array(256), b = new Array(256);
            for (let r = 0; r < 256; r++)
              B[r] = al[r] / 255, X[r] = Ul[r] / 255, b[r] = cl[r] / 255;
            el = B.join(","), ll = X.join(","), q = b.join(","), _ = `${el}${ll}${q}`;
          }
          if (O = this.#i.get(_), O)
            return this.#i.set(w, O), O;
          const il = `g_${this.#n}_transfer_map_${this.#e++}`, dl = `url(#${il})`;
          this.#i.set(w, dl), this.#i.set(_, dl);
          const tl = this.#o(il);
          return this.#s(el, ll, q, tl), dl;
        }
        addHCMFilter(w, O) {
          const el = `${w}-${O}`, ll = "base";
          let q = this.#U.get(ll);
          if (q?.key === el || (q ? (q.filter?.remove(), q.key = el, q.url = "none", q.filter = null) : (q = {
            key: el,
            url: "none",
            filter: null
          }, this.#U.set(ll, q)), !w || !O))
            return q.url;
          const _ = this.#Q(w);
          w = d.Util.makeHexColor(..._);
          const il = this.#Q(O);
          if (O = d.Util.makeHexColor(...il), this.#c.style.color = "", w === "#000000" && O === "#ffffff" || w === O)
            return q.url;
          const dl = new Array(256);
          for (let B = 0; B <= 255; B++) {
            const X = B / 255;
            dl[B] = X <= 0.03928 ? X / 12.92 : ((X + 0.055) / 1.055) ** 2.4;
          }
          const tl = dl.join(","), al = `g_${this.#n}_hcm_filter`, Ul = q.filter = this.#o(al);
          this.#s(tl, tl, tl, Ul), this.#Z(Ul);
          const cl = (B, X) => {
            const b = _[B] / 255, r = il[B] / 255, G = new Array(X + 1);
            for (let J = 0; J <= X; J++)
              G[J] = b + J / X * (r - b);
            return G.join(",");
          };
          return this.#s(cl(0, 5), cl(1, 5), cl(2, 5), Ul), q.url = `url(#${al})`, q.url;
        }
        addHighlightHCMFilter(w, O, el, ll, q) {
          const _ = `${O}-${el}-${ll}-${q}`;
          let il = this.#U.get(w);
          if (il?.key === _ || (il ? (il.filter?.remove(), il.key = _, il.url = "none", il.filter = null) : (il = {
            key: _,
            url: "none",
            filter: null
          }, this.#U.set(w, il)), !O || !el))
            return il.url;
          const [dl, tl] = [O, el].map(this.#Q.bind(this));
          let al = Math.round(0.2126 * dl[0] + 0.7152 * dl[1] + 0.0722 * dl[2]), Ul = Math.round(0.2126 * tl[0] + 0.7152 * tl[1] + 0.0722 * tl[2]), [cl, B] = [ll, q].map(this.#Q.bind(this));
          Ul < al && ([al, Ul, cl, B] = [Ul, al, B, cl]), this.#c.style.color = "";
          const X = (G, J, T) => {
            const y = new Array(256), I = (Ul - al) / T, E = G / 255, x = (J - G) / (255 * T);
            let v = 0;
            for (let A = 0; A <= T; A++) {
              const g = Math.round(al + A * I), D = E + A * x;
              for (let C = v; C <= g; C++)
                y[C] = D;
              v = g + 1;
            }
            for (let A = v; A < 256; A++)
              y[A] = y[v - 1];
            return y.join(",");
          }, b = `g_${this.#n}_hcm_${w}_filter`, r = il.filter = this.#o(b);
          return this.#Z(r), this.#s(X(cl[0], B[0], 5), X(cl[1], B[1], 5), X(cl[2], B[2], 5), r), il.url = `url(#${b})`, il.url;
        }
        destroy(w = !1) {
          w && this.#U.size !== 0 || (this.#t && (this.#t.parentNode.parentNode.remove(), this.#t = null), this.#l && (this.#l.clear(), this.#l = null), this.#e = 0);
        }
        #Z(w) {
          const O = this.#d.createElementNS(a, "feColorMatrix");
          O.setAttribute("type", "matrix"), O.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), w.append(O);
        }
        #o(w) {
          const O = this.#d.createElementNS(a, "filter");
          return O.setAttribute("color-interpolation-filters", "sRGB"), O.setAttribute("id", w), this.#c.append(O), O;
        }
        #F(w, O, el) {
          const ll = this.#d.createElementNS(a, O);
          ll.setAttribute("type", "discrete"), ll.setAttribute("tableValues", el), w.append(ll);
        }
        #s(w, O, el, ll) {
          const q = this.#d.createElementNS(a, "feComponentTransfer");
          ll.append(q), this.#F(q, "feFuncR", w), this.#F(q, "feFuncG", O), this.#F(q, "feFuncB", el);
        }
        #Q(w) {
          return this.#c.style.color = w, k(getComputedStyle(this.#c).getPropertyValue("color"));
        }
      }
      class h extends e.BaseCanvasFactory {
        constructor({
          ownerDocument: w = globalThis.document
        } = {}) {
          super(), this._document = w;
        }
        _createCanvas(w, O) {
          const el = this._document.createElement("canvas");
          return el.width = w, el.height = O, el;
        }
      }
      async function W(P, w = "text") {
        if (m(P, document.baseURI)) {
          const O = await fetch(P);
          if (!O.ok)
            throw new Error(O.statusText);
          switch (w) {
            case "arraybuffer":
              return O.arrayBuffer();
            case "blob":
              return O.blob();
            case "json":
              return O.json();
          }
          return O.text();
        }
        return new Promise((O, el) => {
          const ll = new XMLHttpRequest();
          ll.open("GET", P, !0), ll.responseType = w, ll.onreadystatechange = () => {
            if (ll.readyState === XMLHttpRequest.DONE) {
              if (ll.status === 200 || ll.status === 0) {
                switch (w) {
                  case "arraybuffer":
                  case "blob":
                  case "json":
                    O(ll.response);
                    return;
                }
                O(ll.responseText);
                return;
              }
              el(new Error(ll.statusText));
            }
          }, ll.send(null);
        });
      }
      class Z extends e.BaseCMapReaderFactory {
        _fetchData(w, O) {
          return W(w, this.isCompressed ? "arraybuffer" : "text").then((el) => ({
            cMapData: el instanceof ArrayBuffer ? new Uint8Array(el) : (0, d.stringToBytes)(el),
            compressionType: O
          }));
        }
      }
      class s extends e.BaseStandardFontDataFactory {
        _fetchData(w) {
          return W(w, "arraybuffer").then((O) => new Uint8Array(O));
        }
      }
      class o extends e.BaseSVGFactory {
        _createSVG(w) {
          return document.createElementNS(a, w);
        }
      }
      class F {
        constructor({
          viewBox: w,
          scale: O,
          rotation: el,
          offsetX: ll = 0,
          offsetY: q = 0,
          dontFlip: _ = !1
        }) {
          this.viewBox = w, this.scale = O, this.rotation = el, this.offsetX = ll, this.offsetY = q;
          const il = (w[2] + w[0]) / 2, dl = (w[3] + w[1]) / 2;
          let tl, al, Ul, cl;
          switch (el %= 360, el < 0 && (el += 360), el) {
            case 180:
              tl = -1, al = 0, Ul = 0, cl = 1;
              break;
            case 90:
              tl = 0, al = 1, Ul = 1, cl = 0;
              break;
            case 270:
              tl = 0, al = -1, Ul = -1, cl = 0;
              break;
            case 0:
              tl = 1, al = 0, Ul = 0, cl = -1;
              break;
            default:
              throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
          }
          _ && (Ul = -Ul, cl = -cl);
          let B, X, b, r;
          tl === 0 ? (B = Math.abs(dl - w[1]) * O + ll, X = Math.abs(il - w[0]) * O + q, b = (w[3] - w[1]) * O, r = (w[2] - w[0]) * O) : (B = Math.abs(il - w[0]) * O + ll, X = Math.abs(dl - w[1]) * O + q, b = (w[2] - w[0]) * O, r = (w[3] - w[1]) * O), this.transform = [tl * O, al * O, Ul * O, cl * O, B - tl * O * il - Ul * O * dl, X - al * O * il - cl * O * dl], this.width = b, this.height = r;
        }
        get rawDims() {
          const {
            viewBox: w
          } = this;
          return (0, d.shadow)(this, "rawDims", {
            pageWidth: w[2] - w[0],
            pageHeight: w[3] - w[1],
            pageX: w[0],
            pageY: w[1]
          });
        }
        clone({
          scale: w = this.scale,
          rotation: O = this.rotation,
          offsetX: el = this.offsetX,
          offsetY: ll = this.offsetY,
          dontFlip: q = !1
        } = {}) {
          return new F({
            viewBox: this.viewBox.slice(),
            scale: w,
            rotation: O,
            offsetX: el,
            offsetY: ll,
            dontFlip: q
          });
        }
        convertToViewportPoint(w, O) {
          return d.Util.applyTransform([w, O], this.transform);
        }
        convertToViewportRectangle(w) {
          const O = d.Util.applyTransform([w[0], w[1]], this.transform), el = d.Util.applyTransform([w[2], w[3]], this.transform);
          return [O[0], O[1], el[0], el[1]];
        }
        convertToPdfPoint(w, O) {
          return d.Util.applyInverseTransform([w, O], this.transform);
        }
      }
      class N extends d.BaseException {
        constructor(w, O = 0) {
          super(w, "RenderingCancelledException"), this.extraDelay = O;
        }
      }
      function Q(P) {
        const w = P.length;
        let O = 0;
        for (; O < w && P[O].trim() === ""; )
          O++;
        return P.substring(O, O + 5).toLowerCase() === "data:";
      }
      function u(P) {
        return typeof P == "string" && /\.pdf$/i.test(P);
      }
      function i(P, w = !1) {
        return w || ([P] = P.split(/[#?]/, 1)), P.substring(P.lastIndexOf("/") + 1);
      }
      function c(P, w = "document.pdf") {
        if (typeof P != "string")
          return w;
        if (Q(P))
          return (0, d.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), w;
        const O = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, el = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, ll = O.exec(P);
        let q = el.exec(ll[1]) || el.exec(ll[2]) || el.exec(ll[3]);
        if (q && (q = q[0], q.includes("%")))
          try {
            q = el.exec(decodeURIComponent(q))[0];
          } catch {
          }
        return q || w;
      }
      class R {
        started = /* @__PURE__ */ Object.create(null);
        times = [];
        time(w) {
          w in this.started && (0, d.warn)(`Timer is already running for ${w}`), this.started[w] = Date.now();
        }
        timeEnd(w) {
          w in this.started || (0, d.warn)(`Timer has not been started for ${w}`), this.times.push({
            name: w,
            start: this.started[w],
            end: Date.now()
          }), delete this.started[w];
        }
        toString() {
          const w = [];
          let O = 0;
          for (const {
            name: el
          } of this.times)
            O = Math.max(el.length, O);
          for (const {
            name: el,
            start: ll,
            end: q
          } of this.times)
            w.push(`${el.padEnd(O)} ${q - ll}ms
`);
          return w.join("");
        }
      }
      function m(P, w) {
        try {
          const {
            protocol: O
          } = w ? new URL(P, w) : new URL(P);
          return O === "http:" || O === "https:";
        } catch {
          return !1;
        }
      }
      function M(P) {
        P.preventDefault();
      }
      let S;
      class p {
        static toDateObject(w) {
          if (!w || typeof w != "string")
            return null;
          S ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
          const O = S.exec(w);
          if (!O)
            return null;
          const el = parseInt(O[1], 10);
          let ll = parseInt(O[2], 10);
          ll = ll >= 1 && ll <= 12 ? ll - 1 : 0;
          let q = parseInt(O[3], 10);
          q = q >= 1 && q <= 31 ? q : 1;
          let _ = parseInt(O[4], 10);
          _ = _ >= 0 && _ <= 23 ? _ : 0;
          let il = parseInt(O[5], 10);
          il = il >= 0 && il <= 59 ? il : 0;
          let dl = parseInt(O[6], 10);
          dl = dl >= 0 && dl <= 59 ? dl : 0;
          const tl = O[7] || "Z";
          let al = parseInt(O[8], 10);
          al = al >= 0 && al <= 23 ? al : 0;
          let Ul = parseInt(O[9], 10) || 0;
          return Ul = Ul >= 0 && Ul <= 59 ? Ul : 0, tl === "-" ? (_ += al, il += Ul) : tl === "+" && (_ -= al, il -= Ul), new Date(Date.UTC(el, ll, q, _, il, dl));
        }
      }
      function Y(P, {
        scale: w = 1,
        rotation: O = 0
      }) {
        const {
          width: el,
          height: ll
        } = P.attributes.style, q = [0, 0, parseInt(el), parseInt(ll)];
        return new F({
          viewBox: q,
          scale: w,
          rotation: O
        });
      }
      function k(P) {
        if (P.startsWith("#")) {
          const w = parseInt(P.slice(1), 16);
          return [(w & 16711680) >> 16, (w & 65280) >> 8, w & 255];
        }
        return P.startsWith("rgb(") ? P.slice(4, -1).split(",").map((w) => parseInt(w)) : P.startsWith("rgba(") ? P.slice(5, -1).split(",").map((w) => parseInt(w)).slice(0, 3) : ((0, d.warn)(`Not a valid color format: "${P}"`), [0, 0, 0]);
      }
      function L(P) {
        const w = document.createElement("span");
        w.style.visibility = "hidden", document.body.append(w);
        for (const O of P.keys()) {
          w.style.color = O;
          const el = window.getComputedStyle(w).color;
          P.set(O, k(el));
        }
        w.remove();
      }
      function z(P) {
        const {
          a: w,
          b: O,
          c: el,
          d: ll,
          e: q,
          f: _
        } = P.getTransform();
        return [w, O, el, ll, q, _];
      }
      function f(P) {
        const {
          a: w,
          b: O,
          c: el,
          d: ll,
          e: q,
          f: _
        } = P.getTransform().invertSelf();
        return [w, O, el, ll, q, _];
      }
      function K(P, w, O = !1, el = !0) {
        if (w instanceof F) {
          const {
            pageWidth: ll,
            pageHeight: q
          } = w.rawDims, {
            style: _
          } = P, il = d.FeatureTest.isCSSRoundSupported, dl = `var(--scale-factor) * ${ll}px`, tl = `var(--scale-factor) * ${q}px`, al = il ? `round(${dl}, 1px)` : `calc(${dl})`, Ul = il ? `round(${tl}, 1px)` : `calc(${tl})`;
          !O || w.rotation % 180 === 0 ? (_.width = al, _.height = Ul) : (_.width = Ul, _.height = al);
        }
        el && P.setAttribute("data-main-rotation", w.rotation);
      }
    }
  ),
  /***/
  47: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        DrawLayer: () => (
          /* binding */
          a
        )
        /* harmony export */
      });
      var e = n(419), d = n(292);
      class a {
        #l = null;
        #t = 0;
        #n = /* @__PURE__ */ new Map();
        #d = /* @__PURE__ */ new Map();
        constructor({
          pageIndex: V
        }) {
          this.pageIndex = V;
        }
        setParent(V) {
          if (!this.#l) {
            this.#l = V;
            return;
          }
          if (this.#l !== V) {
            if (this.#n.size > 0)
              for (const h of this.#n.values())
                h.remove(), V.append(h);
            this.#l = V;
          }
        }
        static get _svgFactory() {
          return (0, d.shadow)(this, "_svgFactory", new e.DOMSVGFactory());
        }
        static #a(V, {
          x: h = 0,
          y: W = 0,
          width: Z = 1,
          height: s = 1
        } = {}) {
          const {
            style: o
          } = V;
          o.top = `${100 * W}%`, o.left = `${100 * h}%`, o.width = `${100 * Z}%`, o.height = `${100 * s}%`;
        }
        #e(V) {
          const h = a._svgFactory.create(1, 1, !0);
          return this.#l.append(h), h.setAttribute("aria-hidden", !0), a.#a(h, V), h;
        }
        #i(V, h) {
          const W = a._svgFactory.createElement("clipPath");
          V.append(W);
          const Z = `clip_${h}`;
          W.setAttribute("id", Z), W.setAttribute("clipPathUnits", "objectBoundingBox");
          const s = a._svgFactory.createElement("use");
          return W.append(s), s.setAttribute("href", `#${h}`), s.classList.add("clip"), Z;
        }
        highlight(V, h, W, Z = !1) {
          const s = this.#t++, o = this.#e(V.box);
          o.classList.add("highlight"), V.free && o.classList.add("free");
          const F = a._svgFactory.createElement("defs");
          o.append(F);
          const N = a._svgFactory.createElement("path");
          F.append(N);
          const Q = `path_p${this.pageIndex}_${s}`;
          N.setAttribute("id", Q), N.setAttribute("d", V.toSVGPath()), Z && this.#d.set(s, N);
          const u = this.#i(F, Q), i = a._svgFactory.createElement("use");
          return o.append(i), o.setAttribute("fill", h), o.setAttribute("fill-opacity", W), i.setAttribute("href", `#${Q}`), this.#n.set(s, o), {
            id: s,
            clipPathId: `url(#${u})`
          };
        }
        highlightOutline(V) {
          const h = this.#t++, W = this.#e(V.box);
          W.classList.add("highlightOutline");
          const Z = a._svgFactory.createElement("defs");
          W.append(Z);
          const s = a._svgFactory.createElement("path");
          Z.append(s);
          const o = `path_p${this.pageIndex}_${h}`;
          s.setAttribute("id", o), s.setAttribute("d", V.toSVGPath()), s.setAttribute("vector-effect", "non-scaling-stroke");
          let F;
          if (V.free) {
            W.classList.add("free");
            const u = a._svgFactory.createElement("mask");
            Z.append(u), F = `mask_p${this.pageIndex}_${h}`, u.setAttribute("id", F), u.setAttribute("maskUnits", "objectBoundingBox");
            const i = a._svgFactory.createElement("rect");
            u.append(i), i.setAttribute("width", "1"), i.setAttribute("height", "1"), i.setAttribute("fill", "white");
            const c = a._svgFactory.createElement("use");
            u.append(c), c.setAttribute("href", `#${o}`), c.setAttribute("stroke", "none"), c.setAttribute("fill", "black"), c.setAttribute("fill-rule", "nonzero"), c.classList.add("mask");
          }
          const N = a._svgFactory.createElement("use");
          W.append(N), N.setAttribute("href", `#${o}`), F && N.setAttribute("mask", `url(#${F})`);
          const Q = N.cloneNode();
          return W.append(Q), N.classList.add("mainOutline"), Q.classList.add("secondaryOutline"), this.#n.set(h, W), h;
        }
        finalizeLine(V, h) {
          const W = this.#d.get(V);
          this.#d.delete(V), this.updateBox(V, h.box), W.setAttribute("d", h.toSVGPath());
        }
        updateLine(V, h) {
          this.#n.get(V).firstChild.firstChild.setAttribute("d", h.toSVGPath());
        }
        removeFreeHighlight(V) {
          this.remove(V), this.#d.delete(V);
        }
        updatePath(V, h) {
          this.#d.get(V).setAttribute("d", h.toSVGPath());
        }
        updateBox(V, h) {
          a.#a(this.#n.get(V), h);
        }
        show(V, h) {
          this.#n.get(V).classList.toggle("hidden", !h);
        }
        rotate(V, h) {
          this.#n.get(V).setAttribute("data-main-rotation", h);
        }
        changeColor(V, h) {
          this.#n.get(V).setAttribute("fill", h);
        }
        changeOpacity(V, h) {
          this.#n.get(V).setAttribute("fill-opacity", h);
        }
        addClass(V, h) {
          this.#n.get(V).classList.add(h);
        }
        removeClass(V, h) {
          this.#n.get(V).classList.remove(h);
        }
        remove(V) {
          this.#l !== null && (this.#n.get(V).remove(), this.#n.delete(V));
        }
        destroy() {
          this.#l = null;
          for (const V of this.#n.values())
            V.remove();
          this.#n.clear();
        }
      }
    }
  ),
  /***/
  731: (
    /***/
    (l, t, n) => {
      n.d(t, {
        AnnotationEditorLayer: () => (
          /* binding */
          Q
        )
      });
      var e = n(292), d = n(310), a = n(830), U = n(976);
      const V = /\r\n?|\n/g;
      class h extends d.AnnotationEditor {
        #l = this.editorDivBlur.bind(this);
        #t = this.editorDivFocus.bind(this);
        #n = this.editorDivInput.bind(this);
        #d = this.editorDivKeydown.bind(this);
        #a = this.editorDivPaste.bind(this);
        #e;
        #i = "";
        #U = `${this.id}-editor`;
        #c;
        #Z = null;
        static _freeTextDefaultContent = "";
        static _internalPadding = 0;
        static _defaultColor = null;
        static _defaultFontSize = 10;
        static get _keyboardManager() {
          const i = h.prototype, c = (M) => M.isEmpty(), R = a.AnnotationEditorUIManager.TRANSLATE_SMALL, m = a.AnnotationEditorUIManager.TRANSLATE_BIG;
          return (0, e.shadow)(this, "_keyboardManager", new a.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], i.commitOrRemove, {
            bubbles: !0
          }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], i.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], i._translateEmpty, {
            args: [-R, 0],
            checker: c
          }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], i._translateEmpty, {
            args: [-m, 0],
            checker: c
          }], [["ArrowRight", "mac+ArrowRight"], i._translateEmpty, {
            args: [R, 0],
            checker: c
          }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], i._translateEmpty, {
            args: [m, 0],
            checker: c
          }], [["ArrowUp", "mac+ArrowUp"], i._translateEmpty, {
            args: [0, -R],
            checker: c
          }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], i._translateEmpty, {
            args: [0, -m],
            checker: c
          }], [["ArrowDown", "mac+ArrowDown"], i._translateEmpty, {
            args: [0, R],
            checker: c
          }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], i._translateEmpty, {
            args: [0, m],
            checker: c
          }]]));
        }
        static _type = "freetext";
        static _editorType = e.AnnotationEditorType.FREETEXT;
        constructor(i) {
          super({
            ...i,
            name: "freeTextEditor"
          }), this.#e = i.color || h._defaultColor || d.AnnotationEditor._defaultLineColor, this.#c = i.fontSize || h._defaultFontSize;
        }
        static initialize(i, c) {
          d.AnnotationEditor.initialize(i, c, {
            strings: ["pdfjs-free-text-default-content"]
          });
          const R = getComputedStyle(document.documentElement);
          this._internalPadding = parseFloat(R.getPropertyValue("--freetext-padding"));
        }
        static updateDefaultParams(i, c) {
          switch (i) {
            case e.AnnotationEditorParamsType.FREETEXT_SIZE:
              h._defaultFontSize = c;
              break;
            case e.AnnotationEditorParamsType.FREETEXT_COLOR:
              h._defaultColor = c;
              break;
          }
        }
        updateParams(i, c) {
          switch (i) {
            case e.AnnotationEditorParamsType.FREETEXT_SIZE:
              this.#o(c);
              break;
            case e.AnnotationEditorParamsType.FREETEXT_COLOR:
              this.#F(c);
              break;
          }
        }
        static get defaultPropertiesToUpdate() {
          return [[e.AnnotationEditorParamsType.FREETEXT_SIZE, h._defaultFontSize], [e.AnnotationEditorParamsType.FREETEXT_COLOR, h._defaultColor || d.AnnotationEditor._defaultLineColor]];
        }
        get propertiesToUpdate() {
          return [[e.AnnotationEditorParamsType.FREETEXT_SIZE, this.#c], [e.AnnotationEditorParamsType.FREETEXT_COLOR, this.#e]];
        }
        #o(i) {
          const c = (m) => {
            this.editorDiv.style.fontSize = `calc(${m}px * var(--scale-factor))`, this.translate(0, -(m - this.#c) * this.parentScale), this.#c = m, this.#Q();
          }, R = this.#c;
          this.addCommands({
            cmd: c.bind(this, i),
            undo: c.bind(this, R),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: e.AnnotationEditorParamsType.FREETEXT_SIZE,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }
        #F(i) {
          const c = (m) => {
            this.#e = this.editorDiv.style.color = m;
          }, R = this.#e;
          this.addCommands({
            cmd: c.bind(this, i),
            undo: c.bind(this, R),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: e.AnnotationEditorParamsType.FREETEXT_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }
        _translateEmpty(i, c) {
          this._uiManager.translateSelectedEditors(i, c, !0);
        }
        getInitialTranslation() {
          const i = this.parentScale;
          return [-h._internalPadding * i, -(h._internalPadding + this.#c) * i];
        }
        rebuild() {
          this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
        }
        enableEditMode() {
          this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(e.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", this.#d), this.editorDiv.addEventListener("focus", this.#t), this.editorDiv.addEventListener("blur", this.#l), this.editorDiv.addEventListener("input", this.#n), this.editorDiv.addEventListener("paste", this.#a));
        }
        disableEditMode() {
          this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", this.#U), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", this.#d), this.editorDiv.removeEventListener("focus", this.#t), this.editorDiv.removeEventListener("blur", this.#l), this.editorDiv.removeEventListener("input", this.#n), this.editorDiv.removeEventListener("paste", this.#a), this.div.focus({
            preventScroll: !0
          }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
        }
        focusin(i) {
          this._focusEventsAllowed && (super.focusin(i), i.target !== this.editorDiv && this.editorDiv.focus());
        }
        onceAdded() {
          this.width || (this.enableEditMode(), this.editorDiv.focus(), this._initialOptions?.isCentered && this.center(), this._initialOptions = null);
        }
        isEmpty() {
          return !this.editorDiv || this.editorDiv.innerText.trim() === "";
        }
        remove() {
          this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
        }
        #s() {
          const i = [];
          this.editorDiv.normalize();
          for (const c of this.editorDiv.childNodes)
            i.push(h.#W(c));
          return i.join(`
`);
        }
        #Q() {
          const [i, c] = this.parentDimensions;
          let R;
          if (this.isAttachedToDOM)
            R = this.div.getBoundingClientRect();
          else {
            const {
              currentLayer: m,
              div: M
            } = this, S = M.style.display, p = M.classList.contains("hidden");
            M.classList.remove("hidden"), M.style.display = "hidden", m.div.append(this.div), R = M.getBoundingClientRect(), M.remove(), M.style.display = S, M.classList.toggle("hidden", p);
          }
          this.rotation % 180 === this.parentRotation % 180 ? (this.width = R.width / i, this.height = R.height / c) : (this.width = R.height / i, this.height = R.width / c), this.fixAndSetPosition();
        }
        commit() {
          if (!this.isInEditMode())
            return;
          super.commit(), this.disableEditMode();
          const i = this.#i, c = this.#i = this.#s().trimEnd();
          if (i === c)
            return;
          const R = (m) => {
            if (this.#i = m, !m) {
              this.remove();
              return;
            }
            this.#V(), this._uiManager.rebuild(this), this.#Q();
          };
          this.addCommands({
            cmd: () => {
              R(c);
            },
            undo: () => {
              R(i);
            },
            mustExec: !1
          }), this.#Q();
        }
        shouldGetKeyboardEvents() {
          return this.isInEditMode();
        }
        enterInEditMode() {
          this.enableEditMode(), this.editorDiv.focus();
        }
        dblclick(i) {
          this.enterInEditMode();
        }
        keydown(i) {
          i.target === this.div && i.key === "Enter" && (this.enterInEditMode(), i.preventDefault());
        }
        editorDivKeydown(i) {
          h._keyboardManager.exec(this, i);
        }
        editorDivFocus(i) {
          this.isEditing = !0;
        }
        editorDivBlur(i) {
          this.isEditing = !1;
        }
        editorDivInput(i) {
          this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
        }
        disableEditing() {
          this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
        }
        enableEditing() {
          this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
        }
        render() {
          if (this.div)
            return this.div;
          let i, c;
          this.width && (i = this.x, c = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", this.#U), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text"), this.enableEditing(), d.AnnotationEditor._l10nPromise.get("pdfjs-free-text-default-content").then((m) => this.editorDiv?.setAttribute("default-content", m)), this.editorDiv.contentEditable = !0;
          const {
            style: R
          } = this.editorDiv;
          if (R.fontSize = `calc(${this.#c}px * var(--scale-factor))`, R.color = this.#e, this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, a.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
            const [m, M] = this.parentDimensions;
            if (this.annotationElementId) {
              const {
                position: S
              } = this.#Z;
              let [p, Y] = this.getInitialTranslation();
              [p, Y] = this.pageTranslationToScreen(p, Y);
              const [k, L] = this.pageDimensions, [z, f] = this.pageTranslation;
              let K, P;
              switch (this.rotation) {
                case 0:
                  K = i + (S[0] - z) / k, P = c + this.height - (S[1] - f) / L;
                  break;
                case 90:
                  K = i + (S[0] - z) / k, P = c - (S[1] - f) / L, [p, Y] = [Y, -p];
                  break;
                case 180:
                  K = i - this.width + (S[0] - z) / k, P = c - (S[1] - f) / L, [p, Y] = [-p, -Y];
                  break;
                case 270:
                  K = i + (S[0] - z - this.height * L) / k, P = c + (S[1] - f - this.width * k) / L, [p, Y] = [-Y, p];
                  break;
              }
              this.setAt(K * m, P * M, p, Y);
            } else
              this.setAt(i * m, c * M, this.width * m, this.height * M);
            this.#V(), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
          } else
            this._isDraggable = !1, this.editorDiv.contentEditable = !0;
          return this.div;
        }
        static #W(i) {
          return (i.nodeType === Node.TEXT_NODE ? i.nodeValue : i.innerText).replaceAll(V, "");
        }
        editorDivPaste(i) {
          const c = i.clipboardData || window.clipboardData, {
            types: R
          } = c;
          if (R.length === 1 && R[0] === "text/plain")
            return;
          i.preventDefault();
          const m = h.#h(c.getData("text") || "").replaceAll(V, `
`);
          if (!m)
            return;
          const M = window.getSelection();
          if (!M.rangeCount)
            return;
          this.editorDiv.normalize(), M.deleteFromDocument();
          const S = M.getRangeAt(0);
          if (!m.includes(`
`)) {
            S.insertNode(document.createTextNode(m)), this.editorDiv.normalize(), M.collapseToStart();
            return;
          }
          const {
            startContainer: p,
            startOffset: Y
          } = S, k = [], L = [];
          if (p.nodeType === Node.TEXT_NODE) {
            const K = p.parentElement;
            if (L.push(p.nodeValue.slice(Y).replaceAll(V, "")), K !== this.editorDiv) {
              let P = k;
              for (const w of this.editorDiv.childNodes) {
                if (w === K) {
                  P = L;
                  continue;
                }
                P.push(h.#W(w));
              }
            }
            k.push(p.nodeValue.slice(0, Y).replaceAll(V, ""));
          } else if (p === this.editorDiv) {
            let K = k, P = 0;
            for (const w of this.editorDiv.childNodes)
              P++ === Y && (K = L), K.push(h.#W(w));
          }
          this.#i = `${k.join(`
`)}${m}${L.join(`
`)}`, this.#V();
          const z = new Range();
          let f = k.reduce((K, P) => K + P.length, 0);
          for (const {
            firstChild: K
          } of this.editorDiv.childNodes)
            if (K.nodeType === Node.TEXT_NODE) {
              const P = K.nodeValue.length;
              if (f <= P) {
                z.setStart(K, f), z.setEnd(K, f);
                break;
              }
              f -= P;
            }
          M.removeAllRanges(), M.addRange(z);
        }
        #V() {
          if (this.editorDiv.replaceChildren(), !!this.#i)
            for (const i of this.#i.split(`
`)) {
              const c = document.createElement("div");
              c.append(i ? document.createTextNode(i) : document.createElement("br")), this.editorDiv.append(c);
            }
        }
        #R() {
          return this.#i.replaceAll(" ", " ");
        }
        static #h(i) {
          return i.replaceAll(" ", " ");
        }
        get contentDiv() {
          return this.editorDiv;
        }
        static deserialize(i, c, R) {
          let m = null;
          if (i instanceof U.FreeTextAnnotationElement) {
            const {
              data: {
                defaultAppearanceData: {
                  fontSize: S,
                  fontColor: p
                },
                rect: Y,
                rotation: k,
                id: L
              },
              textContent: z,
              textPosition: f,
              parent: {
                page: {
                  pageNumber: K
                }
              }
            } = i;
            if (!z || z.length === 0)
              return null;
            m = i = {
              annotationType: e.AnnotationEditorType.FREETEXT,
              color: Array.from(p),
              fontSize: S,
              value: z.join(`
`),
              position: f,
              pageIndex: K - 1,
              rect: Y.slice(0),
              rotation: k,
              id: L,
              deleted: !1
            };
          }
          const M = super.deserialize(i, c, R);
          return M.#c = i.fontSize, M.#e = e.Util.makeHexColor(...i.color), M.#i = h.#h(i.value), M.annotationElementId = i.id || null, M.#Z = m, M;
        }
        serialize(i = !1) {
          if (this.isEmpty())
            return null;
          if (this.deleted)
            return {
              pageIndex: this.pageIndex,
              id: this.annotationElementId,
              deleted: !0
            };
          const c = h._internalPadding * this.parentScale, R = this.getRect(c, c), m = d.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#e), M = {
            annotationType: e.AnnotationEditorType.FREETEXT,
            color: m,
            fontSize: this.#c,
            value: this.#R(),
            pageIndex: this.pageIndex,
            rect: R,
            rotation: this.rotation,
            structTreeParentId: this._structTreeParentId
          };
          return i ? M : this.annotationElementId && !this.#N(M) ? null : (M.id = this.annotationElementId, M);
        }
        #N(i) {
          const {
            value: c,
            fontSize: R,
            color: m,
            pageIndex: M
          } = this.#Z;
          return this._hasBeenMoved || i.value !== c || i.fontSize !== R || i.color.some((S, p) => S !== m[p]) || i.pageIndex !== M;
        }
        renderAnnotationElement(i) {
          const c = super.renderAnnotationElement(i);
          if (this.deleted)
            return c;
          const {
            style: R
          } = c;
          R.fontSize = `calc(${this.#c}px * var(--scale-factor))`, R.color = this.#e, c.replaceChildren();
          for (const M of this.#i.split(`
`)) {
            const S = document.createElement("div");
            S.append(M ? document.createTextNode(M) : document.createElement("br")), c.append(S);
          }
          const m = h._internalPadding * this.parentScale;
          return i.updateEdited({
            rect: this.getRect(m, m)
          }), c;
        }
        resetAnnotationElement(i) {
          super.resetAnnotationElement(i), i.resetEdited();
        }
      }
      var W = n(61), Z = n(259), s = n(419);
      class o extends d.AnnotationEditor {
        #l = null;
        #t = 0;
        #n;
        #d = null;
        #a = null;
        #e = null;
        #i = null;
        #U = 0;
        #c = null;
        #Z = null;
        #o = null;
        #F = !1;
        #s = this.#S.bind(this);
        #Q = null;
        #W;
        #V = null;
        #R = "";
        #h;
        #N = "";
        static _defaultColor = null;
        static _defaultOpacity = 1;
        static _defaultThickness = 12;
        static _l10nPromise;
        static _type = "highlight";
        static _editorType = e.AnnotationEditorType.HIGHLIGHT;
        static _freeHighlightId = -1;
        static _freeHighlight = null;
        static _freeHighlightClipId = "";
        static get _keyboardManager() {
          const i = o.prototype;
          return (0, e.shadow)(this, "_keyboardManager", new a.KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], i._moveCaret, {
            args: [0]
          }], [["ArrowRight", "mac+ArrowRight"], i._moveCaret, {
            args: [1]
          }], [["ArrowUp", "mac+ArrowUp"], i._moveCaret, {
            args: [2]
          }], [["ArrowDown", "mac+ArrowDown"], i._moveCaret, {
            args: [3]
          }]]));
        }
        constructor(i) {
          super({
            ...i,
            name: "highlightEditor"
          }), this.color = i.color || o._defaultColor, this.#h = i.thickness || o._defaultThickness, this.#W = i.opacity || o._defaultOpacity, this.#n = i.boxes || null, this.#N = i.methodOfCreation || "", this.#R = i.text || "", this._isDraggable = !1, i.highlightId > -1 ? (this.#F = !0, this.#M(i), this.#b()) : (this.#l = i.anchorNode, this.#t = i.anchorOffset, this.#i = i.focusNode, this.#U = i.focusOffset, this.#m(), this.#b(), this.rotate(this.rotation));
        }
        get telemetryInitialData() {
          return {
            action: "added",
            type: this.#F ? "free_highlight" : "highlight",
            color: this._uiManager.highlightColorNames.get(this.color),
            thickness: this.#h,
            methodOfCreation: this.#N
          };
        }
        get telemetryFinalData() {
          return {
            type: "highlight",
            color: this._uiManager.highlightColorNames.get(this.color)
          };
        }
        static computeTelemetryFinalData(i) {
          return {
            numberOfColors: i.get("color").size
          };
        }
        #m() {
          const i = new W.Outliner(this.#n, 1e-3);
          this.#Z = i.getOutlines(), {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height
          } = this.#Z.box;
          const c = new W.Outliner(this.#n, 25e-4, 1e-3, this._uiManager.direction === "ltr");
          this.#e = c.getOutlines();
          const {
            lastPoint: R
          } = this.#e.box;
          this.#Q = [(R[0] - this.x) / this.width, (R[1] - this.y) / this.height];
        }
        #M({
          highlightOutlines: i,
          highlightId: c,
          clipPathId: R
        }) {
          this.#Z = i;
          const m = 1.5;
          if (this.#e = i.getNewOutline(this.#h / 2 + m, 25e-4), c >= 0)
            this.#o = c, this.#d = R, this.parent.drawLayer.finalizeLine(c, i), this.#V = this.parent.drawLayer.highlightOutline(this.#e);
          else if (this.parent) {
            const L = this.parent.viewport.rotation;
            this.parent.drawLayer.updateLine(this.#o, i), this.parent.drawLayer.updateBox(this.#o, o.#p(this.#Z.box, (L - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(this.#V, this.#e), this.parent.drawLayer.updateBox(this.#V, o.#p(this.#e.box, L));
          }
          const {
            x: M,
            y: S,
            width: p,
            height: Y
          } = i.box;
          switch (this.rotation) {
            case 0:
              this.x = M, this.y = S, this.width = p, this.height = Y;
              break;
            case 90: {
              const [L, z] = this.parentDimensions;
              this.x = S, this.y = 1 - M, this.width = p * z / L, this.height = Y * L / z;
              break;
            }
            case 180:
              this.x = 1 - M, this.y = 1 - S, this.width = p, this.height = Y;
              break;
            case 270: {
              const [L, z] = this.parentDimensions;
              this.x = 1 - S, this.y = M, this.width = p * z / L, this.height = Y * L / z;
              break;
            }
          }
          const {
            lastPoint: k
          } = this.#e.box;
          this.#Q = [(k[0] - M) / p, (k[1] - S) / Y];
        }
        static initialize(i, c) {
          d.AnnotationEditor.initialize(i, c), o._defaultColor ||= c.highlightColors?.values().next().value || "#fff066";
        }
        static updateDefaultParams(i, c) {
          switch (i) {
            case e.AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
              o._defaultColor = c;
              break;
            case e.AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
              o._defaultThickness = c;
              break;
          }
        }
        translateInPage(i, c) {
        }
        get toolbarPosition() {
          return this.#Q;
        }
        updateParams(i, c) {
          switch (i) {
            case e.AnnotationEditorParamsType.HIGHLIGHT_COLOR:
              this.#T(c);
              break;
            case e.AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
              this.#G(c);
              break;
          }
        }
        static get defaultPropertiesToUpdate() {
          return [[e.AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR, o._defaultColor], [e.AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, o._defaultThickness]];
        }
        get propertiesToUpdate() {
          return [[e.AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || o._defaultColor], [e.AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#h || o._defaultThickness], [e.AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#F]];
        }
        #T(i) {
          const c = (m) => {
            this.color = m, this.parent?.drawLayer.changeColor(this.#o, m), this.#a?.updateColor(m);
          }, R = this.color;
          this.addCommands({
            cmd: c.bind(this, i),
            undo: c.bind(this, R),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: e.AnnotationEditorParamsType.HIGHLIGHT_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
          }), this._reportTelemetry({
            action: "color_changed",
            color: this._uiManager.highlightColorNames.get(i)
          }, !0);
        }
        #G(i) {
          const c = this.#h, R = (m) => {
            this.#h = m, this.#X(m);
          };
          this.addCommands({
            cmd: R.bind(this, i),
            undo: R.bind(this, c),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: e.AnnotationEditorParamsType.INK_THICKNESS,
            overwriteIfSameType: !0,
            keepUndo: !0
          }), this._reportTelemetry({
            action: "thickness_changed",
            thickness: i
          }, !0);
        }
        async addEditToolbar() {
          const i = await super.addEditToolbar();
          return i ? (this._uiManager.highlightColors && (this.#a = new Z.ColorPicker({
            editor: this
          }), i.addColorPicker(this.#a)), i) : null;
        }
        disableEditing() {
          super.disableEditing(), this.div.classList.toggle("disabled", !0);
        }
        enableEditing() {
          super.enableEditing(), this.div.classList.toggle("disabled", !1);
        }
        fixAndSetPosition() {
          return super.fixAndSetPosition(this.#J());
        }
        getBaseTranslation() {
          return [0, 0];
        }
        getRect(i, c) {
          return super.getRect(i, c, this.#J());
        }
        onceAdded() {
          this.parent.addUndoableEditor(this), this.div.focus();
        }
        remove() {
          this.#u(), this._reportTelemetry({
            action: "deleted"
          }), super.remove();
        }
        rebuild() {
          this.parent && (super.rebuild(), this.div !== null && (this.#b(), this.isAttachedToDOM || this.parent.add(this)));
        }
        setParent(i) {
          let c = !1;
          this.parent && !i ? this.#u() : i && (this.#b(i), c = !this.parent && this.div?.classList.contains("selectedEditor")), super.setParent(i), this.show(this._isVisible), c && this.select();
        }
        #X(i) {
          if (!this.#F)
            return;
          this.#M({
            highlightOutlines: this.#Z.getNewOutline(i / 2)
          }), this.fixAndSetPosition();
          const [c, R] = this.parentDimensions;
          this.setDims(this.width * c, this.height * R);
        }
        #u() {
          this.#o === null || !this.parent || (this.parent.drawLayer.remove(this.#o), this.#o = null, this.parent.drawLayer.remove(this.#V), this.#V = null);
        }
        #b(i = this.parent) {
          this.#o === null && ({
            id: this.#o,
            clipPathId: this.#d
          } = i.drawLayer.highlight(this.#Z, this.color, this.#W), this.#V = i.drawLayer.highlightOutline(this.#e), this.#c && (this.#c.style.clipPath = this.#d));
        }
        static #p({
          x: i,
          y: c,
          width: R,
          height: m
        }, M) {
          switch (M) {
            case 90:
              return {
                x: 1 - c - m,
                y: i,
                width: m,
                height: R
              };
            case 180:
              return {
                x: 1 - i - R,
                y: 1 - c - m,
                width: R,
                height: m
              };
            case 270:
              return {
                x: c,
                y: 1 - i - R,
                width: m,
                height: R
              };
          }
          return {
            x: i,
            y: c,
            width: R,
            height: m
          };
        }
        rotate(i) {
          const {
            drawLayer: c
          } = this.parent;
          let R;
          this.#F ? (i = (i - this.rotation + 360) % 360, R = o.#p(this.#Z.box, i)) : R = o.#p(this, i), c.rotate(this.#o, i), c.rotate(this.#V, i), c.updateBox(this.#o, R), c.updateBox(this.#V, o.#p(this.#e.box, i));
        }
        render() {
          if (this.div)
            return this.div;
          const i = super.render();
          this.#R && (i.setAttribute("aria-label", this.#R), i.setAttribute("role", "mark")), this.#F ? i.classList.add("free") : this.div.addEventListener("keydown", this.#s);
          const c = this.#c = document.createElement("div");
          i.append(c), c.setAttribute("aria-hidden", "true"), c.className = "internal", c.style.clipPath = this.#d;
          const [R, m] = this.parentDimensions;
          return this.setDims(this.width * R, this.height * m), (0, a.bindEvents)(this, this.#c, ["pointerover", "pointerleave"]), this.enableEditing(), i;
        }
        pointerover() {
          this.parent.drawLayer.addClass(this.#V, "hovered");
        }
        pointerleave() {
          this.parent.drawLayer.removeClass(this.#V, "hovered");
        }
        #S(i) {
          o._keyboardManager.exec(this, i);
        }
        _moveCaret(i) {
          switch (this.parent.unselect(this), i) {
            case 0:
            case 2:
              this.#r(!0);
              break;
            case 1:
            case 3:
              this.#r(!1);
              break;
          }
        }
        #r(i) {
          if (!this.#l)
            return;
          const c = window.getSelection();
          i ? c.setPosition(this.#l, this.#t) : c.setPosition(this.#i, this.#U);
        }
        select() {
          super.select(), this.#V && (this.parent?.drawLayer.removeClass(this.#V, "hovered"), this.parent?.drawLayer.addClass(this.#V, "selected"));
        }
        unselect() {
          super.unselect(), this.#V && (this.parent?.drawLayer.removeClass(this.#V, "selected"), this.#F || this.#r(!1));
        }
        get _mustFixPosition() {
          return !this.#F;
        }
        show(i = this._isVisible) {
          super.show(i), this.parent && (this.parent.drawLayer.show(this.#o, i), this.parent.drawLayer.show(this.#V, i));
        }
        #J() {
          return this.#F ? this.rotation : 0;
        }
        #z() {
          if (this.#F)
            return null;
          const [i, c] = this.pageDimensions, R = this.#n, m = new Array(R.length * 8);
          let M = 0;
          for (const {
            x: S,
            y: p,
            width: Y,
            height: k
          } of R) {
            const L = S * i, z = (1 - p - k) * c;
            m[M] = m[M + 4] = L, m[M + 1] = m[M + 3] = z, m[M + 2] = m[M + 6] = L + Y * i, m[M + 5] = m[M + 7] = z + k * c, M += 8;
          }
          return m;
        }
        #Y(i) {
          return this.#Z.serialize(i, this.#J());
        }
        static startHighlighting(i, c, {
          target: R,
          x: m,
          y: M
        }) {
          const {
            x: S,
            y: p,
            width: Y,
            height: k
          } = R.getBoundingClientRect(), L = (P) => {
            this.#L(i, P);
          }, z = {
            capture: !0,
            passive: !1
          }, f = (P) => {
            P.preventDefault(), P.stopPropagation();
          }, K = (P) => {
            R.removeEventListener("pointermove", L), window.removeEventListener("blur", K), window.removeEventListener("pointerup", K), window.removeEventListener("pointerdown", f, z), window.removeEventListener("contextmenu", s.noContextMenu), this.#B(i, P);
          };
          window.addEventListener("blur", K), window.addEventListener("pointerup", K), window.addEventListener("pointerdown", f, z), window.addEventListener("contextmenu", s.noContextMenu), R.addEventListener("pointermove", L), this._freeHighlight = new W.FreeOutliner({
            x: m,
            y: M
          }, [S, p, Y, k], i.scale, this._defaultThickness / 2, c, 1e-3), {
            id: this._freeHighlightId,
            clipPathId: this._freeHighlightClipId
          } = i.drawLayer.highlight(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0);
        }
        static #L(i, c) {
          this._freeHighlight.add(c) && i.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
        }
        static #B(i, c) {
          this._freeHighlight.isEmpty() ? i.drawLayer.removeFreeHighlight(this._freeHighlightId) : i.createAndAddNewEditor(c, !1, {
            highlightId: this._freeHighlightId,
            highlightOutlines: this._freeHighlight.getOutlines(),
            clipPathId: this._freeHighlightClipId,
            methodOfCreation: "main_toolbar"
          }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
        }
        static deserialize(i, c, R) {
          const m = super.deserialize(i, c, R), {
            rect: [M, S, p, Y],
            color: k,
            quadPoints: L
          } = i;
          m.color = e.Util.makeHexColor(...k), m.#W = i.opacity;
          const [z, f] = m.pageDimensions;
          m.width = (p - M) / z, m.height = (Y - S) / f;
          const K = m.#n = [];
          for (let P = 0; P < L.length; P += 8)
            K.push({
              x: (L[4] - p) / z,
              y: (Y - (1 - L[P + 5])) / f,
              width: (L[P + 2] - L[P]) / z,
              height: (L[P + 5] - L[P + 1]) / f
            });
          return m.#m(), m;
        }
        serialize(i = !1) {
          if (this.isEmpty() || i)
            return null;
          const c = this.getRect(0, 0), R = d.AnnotationEditor._colorManager.convert(this.color);
          return {
            annotationType: e.AnnotationEditorType.HIGHLIGHT,
            color: R,
            opacity: this.#W,
            thickness: this.#h,
            quadPoints: this.#z(),
            outlines: this.#Y(c),
            pageIndex: this.pageIndex,
            rect: c,
            rotation: this.#J(),
            structTreeParentId: this._structTreeParentId
          };
        }
        static canCreateNewEmptyEditor() {
          return !1;
        }
      }
      class F extends d.AnnotationEditor {
        #l = 0;
        #t = 0;
        #n = this.canvasPointermove.bind(this);
        #d = this.canvasPointerleave.bind(this);
        #a = this.canvasPointerup.bind(this);
        #e = this.canvasPointerdown.bind(this);
        #i = null;
        #U = new Path2D();
        #c = !1;
        #Z = !1;
        #o = !1;
        #F = null;
        #s = 0;
        #Q = 0;
        #W = null;
        static _defaultColor = null;
        static _defaultOpacity = 1;
        static _defaultThickness = 1;
        static _type = "ink";
        static _editorType = e.AnnotationEditorType.INK;
        constructor(i) {
          super({
            ...i,
            name: "inkEditor"
          }), this.color = i.color || null, this.thickness = i.thickness || null, this.opacity = i.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
        }
        static initialize(i, c) {
          d.AnnotationEditor.initialize(i, c);
        }
        static updateDefaultParams(i, c) {
          switch (i) {
            case e.AnnotationEditorParamsType.INK_THICKNESS:
              F._defaultThickness = c;
              break;
            case e.AnnotationEditorParamsType.INK_COLOR:
              F._defaultColor = c;
              break;
            case e.AnnotationEditorParamsType.INK_OPACITY:
              F._defaultOpacity = c / 100;
              break;
          }
        }
        updateParams(i, c) {
          switch (i) {
            case e.AnnotationEditorParamsType.INK_THICKNESS:
              this.#V(c);
              break;
            case e.AnnotationEditorParamsType.INK_COLOR:
              this.#R(c);
              break;
            case e.AnnotationEditorParamsType.INK_OPACITY:
              this.#h(c);
              break;
          }
        }
        static get defaultPropertiesToUpdate() {
          return [[e.AnnotationEditorParamsType.INK_THICKNESS, F._defaultThickness], [e.AnnotationEditorParamsType.INK_COLOR, F._defaultColor || d.AnnotationEditor._defaultLineColor], [e.AnnotationEditorParamsType.INK_OPACITY, Math.round(F._defaultOpacity * 100)]];
        }
        get propertiesToUpdate() {
          return [[e.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || F._defaultThickness], [e.AnnotationEditorParamsType.INK_COLOR, this.color || F._defaultColor || d.AnnotationEditor._defaultLineColor], [e.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? F._defaultOpacity))]];
        }
        #V(i) {
          const c = (m) => {
            this.thickness = m, this.#I();
          }, R = this.thickness;
          this.addCommands({
            cmd: c.bind(this, i),
            undo: c.bind(this, R),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: e.AnnotationEditorParamsType.INK_THICKNESS,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }
        #R(i) {
          const c = (m) => {
            this.color = m, this.#S();
          }, R = this.color;
          this.addCommands({
            cmd: c.bind(this, i),
            undo: c.bind(this, R),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: e.AnnotationEditorParamsType.INK_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }
        #h(i) {
          const c = (m) => {
            this.opacity = m, this.#S();
          };
          i /= 100;
          const R = this.opacity;
          this.addCommands({
            cmd: c.bind(this, i),
            undo: c.bind(this, R),
            post: this._uiManager.updateUI.bind(this._uiManager, this),
            mustExec: !0,
            type: e.AnnotationEditorParamsType.INK_OPACITY,
            overwriteIfSameType: !0,
            keepUndo: !0
          });
        }
        rebuild() {
          this.parent && (super.rebuild(), this.div !== null && (this.canvas || (this.#J(), this.#z()), this.isAttachedToDOM || (this.parent.add(this), this.#Y()), this.#I()));
        }
        remove() {
          this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, this.#i && (clearTimeout(this.#i), this.#i = null), this.#F.disconnect(), this.#F = null, super.remove());
        }
        setParent(i) {
          !this.parent && i ? this._uiManager.removeShouldRescale(this) : this.parent && i === null && this._uiManager.addShouldRescale(this), super.setParent(i);
        }
        onScaleChanging() {
          const [i, c] = this.parentDimensions, R = this.width * i, m = this.height * c;
          this.setDimensions(R, m);
        }
        enableEditMode() {
          this.#c || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", this.#e));
        }
        disableEditMode() {
          !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", this.#e));
        }
        onceAdded() {
          this._isDraggable = !this.isEmpty();
        }
        isEmpty() {
          return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
        }
        #N() {
          const {
            parentRotation: i,
            parentDimensions: [c, R]
          } = this;
          switch (i) {
            case 90:
              return [0, R, R, c];
            case 180:
              return [c, R, c, R];
            case 270:
              return [c, 0, R, c];
            default:
              return [0, 0, c, R];
          }
        }
        #m() {
          const {
            ctx: i,
            color: c,
            opacity: R,
            thickness: m,
            parentScale: M,
            scaleFactor: S
          } = this;
          i.lineWidth = m * M / S, i.lineCap = "round", i.lineJoin = "round", i.miterLimit = 10, i.strokeStyle = `${c}${(0, a.opacityToHex)(R)}`;
        }
        #M(i, c) {
          this.canvas.addEventListener("contextmenu", s.noContextMenu), this.canvas.addEventListener("pointerleave", this.#d), this.canvas.addEventListener("pointermove", this.#n), this.canvas.addEventListener("pointerup", this.#a), this.canvas.removeEventListener("pointerdown", this.#e), this.isEditing = !0, this.#o || (this.#o = !0, this.#Y(), this.thickness ||= F._defaultThickness, this.color ||= F._defaultColor || d.AnnotationEditor._defaultLineColor, this.opacity ??= F._defaultOpacity), this.currentPath.push([i, c]), this.#Z = !1, this.#m(), this.#W = () => {
            this.#u(), this.#W && window.requestAnimationFrame(this.#W);
          }, window.requestAnimationFrame(this.#W);
        }
        #T(i, c) {
          const [R, m] = this.currentPath.at(-1);
          if (this.currentPath.length > 1 && i === R && c === m)
            return;
          const M = this.currentPath;
          let S = this.#U;
          if (M.push([i, c]), this.#Z = !0, M.length <= 2) {
            S.moveTo(...M[0]), S.lineTo(i, c);
            return;
          }
          M.length === 3 && (this.#U = S = new Path2D(), S.moveTo(...M[0])), this.#b(S, ...M.at(-3), ...M.at(-2), i, c);
        }
        #G() {
          if (this.currentPath.length === 0)
            return;
          const i = this.currentPath.at(-1);
          this.#U.lineTo(...i);
        }
        #X(i, c) {
          this.#W = null, i = Math.min(Math.max(i, 0), this.canvas.width), c = Math.min(Math.max(c, 0), this.canvas.height), this.#T(i, c), this.#G();
          let R;
          if (this.currentPath.length !== 1)
            R = this.#p();
          else {
            const Y = [i, c];
            R = [[Y, Y.slice(), Y.slice(), Y]];
          }
          const m = this.#U, M = this.currentPath;
          this.currentPath = [], this.#U = new Path2D();
          const S = () => {
            this.allRawPaths.push(M), this.paths.push(R), this.bezierPath2D.push(m), this._uiManager.rebuild(this);
          }, p = () => {
            this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (this.#J(), this.#z()), this.#I());
          };
          this.addCommands({
            cmd: S,
            undo: p,
            mustExec: !0
          });
        }
        #u() {
          if (!this.#Z)
            return;
          this.#Z = !1;
          const i = Math.ceil(this.thickness * this.parentScale), c = this.currentPath.slice(-3), R = c.map((S) => S[0]), m = c.map((S) => S[1]);
          Math.min(...R) - i, Math.max(...R) + i, Math.min(...m) - i, Math.max(...m) + i;
          const {
            ctx: M
          } = this;
          M.save(), M.clearRect(0, 0, this.canvas.width, this.canvas.height);
          for (const S of this.bezierPath2D)
            M.stroke(S);
          M.stroke(this.#U), M.restore();
        }
        #b(i, c, R, m, M, S, p) {
          const Y = (c + m) / 2, k = (R + M) / 2, L = (m + S) / 2, z = (M + p) / 2;
          i.bezierCurveTo(Y + 2 * (m - Y) / 3, k + 2 * (M - k) / 3, L + 2 * (m - L) / 3, z + 2 * (M - z) / 3, L, z);
        }
        #p() {
          const i = this.currentPath;
          if (i.length <= 2)
            return [[i[0], i[0], i.at(-1), i.at(-1)]];
          const c = [];
          let R, [m, M] = i[0];
          for (R = 1; R < i.length - 2; R++) {
            const [f, K] = i[R], [P, w] = i[R + 1], O = (f + P) / 2, el = (K + w) / 2, ll = [m + 2 * (f - m) / 3, M + 2 * (K - M) / 3], q = [O + 2 * (f - O) / 3, el + 2 * (K - el) / 3];
            c.push([[m, M], ll, q, [O, el]]), [m, M] = [O, el];
          }
          const [S, p] = i[R], [Y, k] = i[R + 1], L = [m + 2 * (S - m) / 3, M + 2 * (p - M) / 3], z = [Y + 2 * (S - Y) / 3, k + 2 * (p - k) / 3];
          return c.push([[m, M], L, z, [Y, k]]), c;
        }
        #S() {
          if (this.isEmpty()) {
            this.#B();
            return;
          }
          this.#m();
          const {
            canvas: i,
            ctx: c
          } = this;
          c.setTransform(1, 0, 0, 1, 0, 0), c.clearRect(0, 0, i.width, i.height), this.#B();
          for (const R of this.bezierPath2D)
            c.stroke(R);
        }
        commit() {
          this.#c || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), this.#c = !0, this.div.classList.add("disabled"), this.#I(!0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
            preventScroll: !0
          }));
        }
        focusin(i) {
          this._focusEventsAllowed && (super.focusin(i), this.enableEditMode());
        }
        canvasPointerdown(i) {
          i.button !== 0 || !this.isInEditMode() || this.#c || (this.setInForeground(), i.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({
            preventScroll: !0
          }), this.#M(i.offsetX, i.offsetY));
        }
        canvasPointermove(i) {
          i.preventDefault(), this.#T(i.offsetX, i.offsetY);
        }
        canvasPointerup(i) {
          i.preventDefault(), this.#r(i);
        }
        canvasPointerleave(i) {
          this.#r(i);
        }
        #r(i) {
          this.canvas.removeEventListener("pointerleave", this.#d), this.canvas.removeEventListener("pointermove", this.#n), this.canvas.removeEventListener("pointerup", this.#a), this.canvas.addEventListener("pointerdown", this.#e), this.#i && clearTimeout(this.#i), this.#i = setTimeout(() => {
            this.#i = null, this.canvas.removeEventListener("contextmenu", s.noContextMenu);
          }, 10), this.#X(i.offsetX, i.offsetY), this.addToAnnotationStorage(), this.setInBackground();
        }
        #J() {
          this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
        }
        #z() {
          this.#F = new ResizeObserver((i) => {
            const c = i[0].contentRect;
            c.width && c.height && this.setDimensions(c.width, c.height);
          }), this.#F.observe(this.div);
        }
        get isResizable() {
          return !this.isEmpty() && this.#c;
        }
        render() {
          if (this.div)
            return this.div;
          let i, c;
          this.width && (i = this.x, c = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
          const [R, m, M, S] = this.#N();
          if (this.setAt(R, m, 0, 0), this.setDims(M, S), this.#J(), this.width) {
            const [p, Y] = this.parentDimensions;
            this.setAspectRatio(this.width * p, this.height * Y), this.setAt(i * p, c * Y, this.width * p, this.height * Y), this.#o = !0, this.#Y(), this.setDims(this.width * p, this.height * Y), this.#S(), this.div.classList.add("disabled");
          } else
            this.div.classList.add("editing"), this.enableEditMode();
          return this.#z(), this.div;
        }
        #Y() {
          if (!this.#o)
            return;
          const [i, c] = this.parentDimensions;
          this.canvas.width = Math.ceil(this.width * i), this.canvas.height = Math.ceil(this.height * c), this.#B();
        }
        setDimensions(i, c) {
          const R = Math.round(i), m = Math.round(c);
          if (this.#s === R && this.#Q === m)
            return;
          this.#s = R, this.#Q = m, this.canvas.style.visibility = "hidden";
          const [M, S] = this.parentDimensions;
          this.width = i / M, this.height = c / S, this.fixAndSetPosition(), this.#c && this.#L(i, c), this.#Y(), this.#S(), this.canvas.style.visibility = "visible", this.fixDims();
        }
        #L(i, c) {
          const R = this.#w(), m = (i - R) / this.#t, M = (c - R) / this.#l;
          this.scaleFactor = Math.min(m, M);
        }
        #B() {
          const i = this.#w() / 2;
          this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + i, this.translationY * this.scaleFactor + i);
        }
        static #k(i) {
          const c = new Path2D();
          for (let R = 0, m = i.length; R < m; R++) {
            const [M, S, p, Y] = i[R];
            R === 0 && c.moveTo(...M), c.bezierCurveTo(S[0], S[1], p[0], p[1], Y[0], Y[1]);
          }
          return c;
        }
        static #x(i, c, R) {
          const [m, M, S, p] = c;
          switch (R) {
            case 0:
              for (let Y = 0, k = i.length; Y < k; Y += 2)
                i[Y] += m, i[Y + 1] = p - i[Y + 1];
              break;
            case 90:
              for (let Y = 0, k = i.length; Y < k; Y += 2) {
                const L = i[Y];
                i[Y] = i[Y + 1] + m, i[Y + 1] = L + M;
              }
              break;
            case 180:
              for (let Y = 0, k = i.length; Y < k; Y += 2)
                i[Y] = S - i[Y], i[Y + 1] += M;
              break;
            case 270:
              for (let Y = 0, k = i.length; Y < k; Y += 2) {
                const L = i[Y];
                i[Y] = S - i[Y + 1], i[Y + 1] = p - L;
              }
              break;
            default:
              throw new Error("Invalid rotation");
          }
          return i;
        }
        static #O(i, c, R) {
          const [m, M, S, p] = c;
          switch (R) {
            case 0:
              for (let Y = 0, k = i.length; Y < k; Y += 2)
                i[Y] -= m, i[Y + 1] = p - i[Y + 1];
              break;
            case 90:
              for (let Y = 0, k = i.length; Y < k; Y += 2) {
                const L = i[Y];
                i[Y] = i[Y + 1] - M, i[Y + 1] = L - m;
              }
              break;
            case 180:
              for (let Y = 0, k = i.length; Y < k; Y += 2)
                i[Y] = S - i[Y], i[Y + 1] -= M;
              break;
            case 270:
              for (let Y = 0, k = i.length; Y < k; Y += 2) {
                const L = i[Y];
                i[Y] = p - i[Y + 1], i[Y + 1] = S - L;
              }
              break;
            default:
              throw new Error("Invalid rotation");
          }
          return i;
        }
        #v(i, c, R, m) {
          const M = [], S = this.thickness / 2, p = i * c + S, Y = i * R + S;
          for (const k of this.paths) {
            const L = [], z = [];
            for (let f = 0, K = k.length; f < K; f++) {
              const [P, w, O, el] = k[f];
              if (P[0] === el[0] && P[1] === el[1] && K === 1) {
                const cl = i * P[0] + p, B = i * P[1] + Y;
                L.push(cl, B), z.push(cl, B);
                break;
              }
              const ll = i * P[0] + p, q = i * P[1] + Y, _ = i * w[0] + p, il = i * w[1] + Y, dl = i * O[0] + p, tl = i * O[1] + Y, al = i * el[0] + p, Ul = i * el[1] + Y;
              f === 0 && (L.push(ll, q), z.push(ll, q)), L.push(_, il, dl, tl, al, Ul), z.push(_, il), f === K - 1 && z.push(al, Ul);
            }
            M.push({
              bezier: F.#x(L, m, this.rotation),
              points: F.#x(z, m, this.rotation)
            });
          }
          return M;
        }
        #g() {
          let i = 1 / 0, c = -1 / 0, R = 1 / 0, m = -1 / 0;
          for (const M of this.paths)
            for (const [S, p, Y, k] of M) {
              const L = e.Util.bezierBoundingBox(...S, ...p, ...Y, ...k);
              i = Math.min(i, L[0]), R = Math.min(R, L[1]), c = Math.max(c, L[2]), m = Math.max(m, L[3]);
            }
          return [i, R, c, m];
        }
        #w() {
          return this.#c ? Math.ceil(this.thickness * this.parentScale) : 0;
        }
        #I(i = !1) {
          if (this.isEmpty())
            return;
          if (!this.#c) {
            this.#S();
            return;
          }
          const c = this.#g(), R = this.#w();
          this.#t = Math.max(d.AnnotationEditor.MIN_SIZE, c[2] - c[0]), this.#l = Math.max(d.AnnotationEditor.MIN_SIZE, c[3] - c[1]);
          const m = Math.ceil(R + this.#t * this.scaleFactor), M = Math.ceil(R + this.#l * this.scaleFactor), [S, p] = this.parentDimensions;
          this.width = m / S, this.height = M / p, this.setAspectRatio(m, M);
          const Y = this.translationX, k = this.translationY;
          this.translationX = -c[0], this.translationY = -c[1], this.#Y(), this.#S(), this.#s = m, this.#Q = M, this.setDims(m, M);
          const L = i ? R / this.scaleFactor / 2 : 0;
          this.translate(Y - this.translationX - L, k - this.translationY - L);
        }
        static deserialize(i, c, R) {
          if (i instanceof U.InkAnnotationElement)
            return null;
          const m = super.deserialize(i, c, R);
          m.thickness = i.thickness, m.color = e.Util.makeHexColor(...i.color), m.opacity = i.opacity;
          const [M, S] = m.pageDimensions, p = m.width * M, Y = m.height * S, k = m.parentScale, L = i.thickness / 2;
          m.#c = !0, m.#s = Math.round(p), m.#Q = Math.round(Y);
          const {
            paths: z,
            rect: f,
            rotation: K
          } = i;
          for (let {
            bezier: w
          } of z) {
            w = F.#O(w, f, K);
            const O = [];
            m.paths.push(O);
            let el = k * (w[0] - L), ll = k * (w[1] - L);
            for (let _ = 2, il = w.length; _ < il; _ += 6) {
              const dl = k * (w[_] - L), tl = k * (w[_ + 1] - L), al = k * (w[_ + 2] - L), Ul = k * (w[_ + 3] - L), cl = k * (w[_ + 4] - L), B = k * (w[_ + 5] - L);
              O.push([[el, ll], [dl, tl], [al, Ul], [cl, B]]), el = cl, ll = B;
            }
            const q = this.#k(O);
            m.bezierPath2D.push(q);
          }
          const P = m.#g();
          return m.#t = Math.max(d.AnnotationEditor.MIN_SIZE, P[2] - P[0]), m.#l = Math.max(d.AnnotationEditor.MIN_SIZE, P[3] - P[1]), m.#L(p, Y), m;
        }
        serialize() {
          if (this.isEmpty())
            return null;
          const i = this.getRect(0, 0), c = d.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
          return {
            annotationType: e.AnnotationEditorType.INK,
            color: c,
            thickness: this.thickness,
            opacity: this.opacity,
            paths: this.#v(this.scaleFactor / this.parentScale, this.translationX, this.translationY, i),
            pageIndex: this.pageIndex,
            rect: i,
            rotation: this.rotation,
            structTreeParentId: this._structTreeParentId
          };
        }
      }
      class N extends d.AnnotationEditor {
        #l = null;
        #t = null;
        #n = null;
        #d = null;
        #a = null;
        #e = "";
        #i = null;
        #U = null;
        #c = null;
        #Z = !1;
        #o = !1;
        static _type = "stamp";
        static _editorType = e.AnnotationEditorType.STAMP;
        constructor(i) {
          super({
            ...i,
            name: "stampEditor"
          }), this.#d = i.bitmapUrl, this.#a = i.bitmapFile;
        }
        static initialize(i, c) {
          d.AnnotationEditor.initialize(i, c);
        }
        static get supportedTypes() {
          const i = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
          return (0, e.shadow)(this, "supportedTypes", i.map((c) => `image/${c}`));
        }
        static get supportedTypesStr() {
          return (0, e.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
        }
        static isHandlingMimeForPasting(i) {
          return this.supportedTypes.includes(i);
        }
        static paste(i, c) {
          c.pasteEditor(e.AnnotationEditorType.STAMP, {
            bitmapFile: i.getAsFile()
          });
        }
        #F(i, c = !1) {
          if (!i) {
            this.remove();
            return;
          }
          this.#l = i.bitmap, c || (this.#t = i.id, this.#Z = i.isSvg), i.file && (this.#e = i.file.name), this.#W();
        }
        #s() {
          this.#n = null, this._uiManager.enableWaiting(!1), this.#i && this.div.focus();
        }
        #Q() {
          if (this.#t) {
            this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(this.#t).then((c) => this.#F(c, !0)).finally(() => this.#s());
            return;
          }
          if (this.#d) {
            const c = this.#d;
            this.#d = null, this._uiManager.enableWaiting(!0), this.#n = this._uiManager.imageManager.getFromUrl(c).then((R) => this.#F(R)).finally(() => this.#s());
            return;
          }
          if (this.#a) {
            const c = this.#a;
            this.#a = null, this._uiManager.enableWaiting(!0), this.#n = this._uiManager.imageManager.getFromFile(c).then((R) => this.#F(R)).finally(() => this.#s());
            return;
          }
          const i = document.createElement("input");
          i.type = "file", i.accept = N.supportedTypesStr, this.#n = new Promise((c) => {
            i.addEventListener("change", async () => {
              if (!i.files || i.files.length === 0)
                this.remove();
              else {
                this._uiManager.enableWaiting(!0);
                const R = await this._uiManager.imageManager.getFromFile(i.files[0]);
                this.#F(R);
              }
              c();
            }), i.addEventListener("cancel", () => {
              this.remove(), c();
            });
          }).finally(() => this.#s()), i.click();
        }
        remove() {
          this.#t && (this.#l = null, this._uiManager.imageManager.deleteId(this.#t), this.#i?.remove(), this.#i = null, this.#U?.disconnect(), this.#U = null, this.#c && (clearTimeout(this.#c), this.#c = null)), super.remove();
        }
        rebuild() {
          if (!this.parent) {
            this.#t && this.#Q();
            return;
          }
          super.rebuild(), this.div !== null && (this.#t && this.#i === null && this.#Q(), this.isAttachedToDOM || this.parent.add(this));
        }
        onceAdded() {
          this._isDraggable = !0, this.div.focus();
        }
        isEmpty() {
          return !(this.#n || this.#l || this.#d || this.#a || this.#t);
        }
        get isResizable() {
          return !0;
        }
        render() {
          if (this.div)
            return this.div;
          let i, c;
          if (this.width && (i = this.x, c = this.y), super.render(), this.div.hidden = !0, this.addAltTextButton(), this.#l ? this.#W() : this.#Q(), this.width) {
            const [R, m] = this.parentDimensions;
            this.setAt(i * R, c * m, this.width * R, this.height * m);
          }
          return this.div;
        }
        #W() {
          const {
            div: i
          } = this;
          let {
            width: c,
            height: R
          } = this.#l;
          const [m, M] = this.pageDimensions, S = 0.75;
          if (this.width)
            c = this.width * m, R = this.height * M;
          else if (c > S * m || R > S * M) {
            const L = Math.min(S * m / c, S * M / R);
            c *= L, R *= L;
          }
          const [p, Y] = this.parentDimensions;
          this.setDims(c * p / m, R * Y / M), this._uiManager.enableWaiting(!1);
          const k = this.#i = document.createElement("canvas");
          i.append(k), i.hidden = !1, this.#h(c, R), this.#m(), this.#o || (this.parent.addUndoableEditor(this), this.#o = !0), this._reportTelemetry({
            action: "inserted_image"
          }), this.#e && k.setAttribute("aria-label", this.#e);
        }
        #V(i, c) {
          const [R, m] = this.parentDimensions;
          this.width = i / R, this.height = c / m, this.setDims(i, c), this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, this.#c !== null && clearTimeout(this.#c);
          const M = 200;
          this.#c = setTimeout(() => {
            this.#c = null, this.#h(i, c);
          }, M);
        }
        #R(i, c) {
          const {
            width: R,
            height: m
          } = this.#l;
          let M = R, S = m, p = this.#l;
          for (; M > 2 * i || S > 2 * c; ) {
            const Y = M, k = S;
            M > 2 * i && (M = M >= 16384 ? Math.floor(M / 2) - 1 : Math.ceil(M / 2)), S > 2 * c && (S = S >= 16384 ? Math.floor(S / 2) - 1 : Math.ceil(S / 2));
            const L = new OffscreenCanvas(M, S);
            L.getContext("2d").drawImage(p, 0, 0, Y, k, 0, 0, M, S), p = L.transferToImageBitmap();
          }
          return p;
        }
        #h(i, c) {
          i = Math.ceil(i), c = Math.ceil(c);
          const R = this.#i;
          if (!R || R.width === i && R.height === c)
            return;
          R.width = i, R.height = c;
          const m = this.#Z ? this.#l : this.#R(i, c);
          if (this._uiManager.hasMLManager && !this.hasAltText()) {
            const S = new OffscreenCanvas(i, c);
            S.getContext("2d").drawImage(m, 0, 0, m.width, m.height, 0, 0, i, c), S.convertToBlob().then((Y) => {
              const k = new FileReader();
              k.onload = () => {
                const L = k.result;
                this._uiManager.mlGuess({
                  service: "image-to-text",
                  request: {
                    imageData: L
                  }
                }).then((z) => {
                  const f = z?.output || "";
                  this.parent && f && !this.hasAltText() && (this.altTextData = {
                    altText: f,
                    decorative: !1
                  });
                });
              }, k.readAsDataURL(Y);
            });
          }
          const M = R.getContext("2d");
          M.filter = this._uiManager.hcmFilter, M.drawImage(m, 0, 0, m.width, m.height, 0, 0, i, c);
        }
        getImageForAltText() {
          return this.#i;
        }
        #N(i) {
          if (i) {
            if (this.#Z) {
              const m = this._uiManager.imageManager.getSvgUrl(this.#t);
              if (m)
                return m;
            }
            const c = document.createElement("canvas");
            return {
              width: c.width,
              height: c.height
            } = this.#l, c.getContext("2d").drawImage(this.#l, 0, 0), c.toDataURL();
          }
          if (this.#Z) {
            const [c, R] = this.pageDimensions, m = Math.round(this.width * c * s.PixelsPerInch.PDF_TO_CSS_UNITS), M = Math.round(this.height * R * s.PixelsPerInch.PDF_TO_CSS_UNITS), S = new OffscreenCanvas(m, M);
            return S.getContext("2d").drawImage(this.#l, 0, 0, this.#l.width, this.#l.height, 0, 0, m, M), S.transferToImageBitmap();
          }
          return structuredClone(this.#l);
        }
        #m() {
          this.#U = new ResizeObserver((i) => {
            const c = i[0].contentRect;
            c.width && c.height && this.#V(c.width, c.height);
          }), this.#U.observe(this.div);
        }
        static deserialize(i, c, R) {
          if (i instanceof U.StampAnnotationElement)
            return null;
          const m = super.deserialize(i, c, R), {
            rect: M,
            bitmapUrl: S,
            bitmapId: p,
            isSvg: Y,
            accessibilityData: k
          } = i;
          p && R.imageManager.isValidId(p) ? m.#t = p : m.#d = S, m.#Z = Y;
          const [L, z] = m.pageDimensions;
          return m.width = (M[2] - M[0]) / L, m.height = (M[3] - M[1]) / z, k && (m.altTextData = k), m;
        }
        serialize(i = !1, c = null) {
          if (this.isEmpty())
            return null;
          const R = {
            annotationType: e.AnnotationEditorType.STAMP,
            bitmapId: this.#t,
            pageIndex: this.pageIndex,
            rect: this.getRect(0, 0),
            rotation: this.rotation,
            isSvg: this.#Z,
            structTreeParentId: this._structTreeParentId
          };
          if (i)
            return R.bitmapUrl = this.#N(!0), R.accessibilityData = this.altTextData, R;
          const {
            decorative: m,
            altText: M
          } = this.altTextData;
          if (!m && M && (R.accessibilityData = {
            type: "Figure",
            alt: M
          }), c === null)
            return R;
          c.stamps ||= /* @__PURE__ */ new Map();
          const S = this.#Z ? (R.rect[2] - R.rect[0]) * (R.rect[3] - R.rect[1]) : null;
          if (!c.stamps.has(this.#t))
            c.stamps.set(this.#t, {
              area: S,
              serialized: R
            }), R.bitmap = this.#N(!1);
          else if (this.#Z) {
            const p = c.stamps.get(this.#t);
            S > p.area && (p.area = S, p.serialized.bitmap.close(), p.serialized.bitmap = this.#N(!1));
          }
          return R;
        }
      }
      class Q {
        #l;
        #t = !1;
        #n = null;
        #d = null;
        #a = null;
        #e = null;
        #i = null;
        #U = /* @__PURE__ */ new Map();
        #c = !1;
        #Z = !1;
        #o = !1;
        #F = null;
        #s;
        static _initialized = !1;
        static #Q = new Map([h, F, N, o].map((i) => [i._editorType, i]));
        constructor({
          uiManager: i,
          pageIndex: c,
          div: R,
          accessibilityManager: m,
          annotationLayer: M,
          drawLayer: S,
          textLayer: p,
          viewport: Y,
          l10n: k
        }) {
          const L = [...Q.#Q.values()];
          if (!Q._initialized) {
            Q._initialized = !0;
            for (const z of L)
              z.initialize(k, i);
          }
          i.registerEditorTypes(L), this.#s = i, this.pageIndex = c, this.div = R, this.#l = m, this.#n = M, this.viewport = Y, this.#F = p, this.drawLayer = S, this.#s.addLayer(this);
        }
        get isEmpty() {
          return this.#U.size === 0;
        }
        get isInvisible() {
          return this.isEmpty && this.#s.getMode() === e.AnnotationEditorType.NONE;
        }
        updateToolbar(i) {
          this.#s.updateToolbar(i);
        }
        updateMode(i = this.#s.getMode()) {
          switch (this.#N(), i) {
            case e.AnnotationEditorType.NONE:
              this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
              return;
            case e.AnnotationEditorType.INK:
              this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick();
              break;
            case e.AnnotationEditorType.HIGHLIGHT:
              this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
              break;
            default:
              this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
          }
          this.toggleAnnotationLayerPointerEvents(!1);
          const {
            classList: c
          } = this.div;
          for (const R of Q.#Q.values())
            c.toggle(`${R._type}Editing`, i === R._editorType);
          this.div.hidden = !1;
        }
        hasTextLayer(i) {
          return i === this.#F?.div;
        }
        addInkEditorIfNeeded(i) {
          if (this.#s.getMode() !== e.AnnotationEditorType.INK)
            return;
          if (!i) {
            for (const R of this.#U.values())
              if (R.isEmpty()) {
                R.setInBackground();
                return;
              }
          }
          this.createAndAddNewEditor({
            offsetX: 0,
            offsetY: 0
          }, !1).setInBackground();
        }
        setEditingState(i) {
          this.#s.setEditingState(i);
        }
        addCommands(i) {
          this.#s.addCommands(i);
        }
        togglePointerEvents(i = !1) {
          this.div.classList.toggle("disabled", !i);
        }
        toggleAnnotationLayerPointerEvents(i = !1) {
          this.#n?.div.classList.toggle("disabled", !i);
        }
        enable() {
          this.div.tabIndex = 0, this.togglePointerEvents(!0);
          const i = /* @__PURE__ */ new Set();
          for (const R of this.#U.values())
            R.enableEditing(), R.show(!0), R.annotationElementId && (this.#s.removeChangedExistingAnnotation(R), i.add(R.annotationElementId));
          if (!this.#n)
            return;
          const c = this.#n.getEditableAnnotations();
          for (const R of c) {
            if (R.hide(), this.#s.isDeletedAnnotationElement(R.data.id) || i.has(R.data.id))
              continue;
            const m = this.deserialize(R);
            m && (this.addOrRebuild(m), m.enableEditing());
          }
        }
        disable() {
          this.#o = !0, this.div.tabIndex = -1, this.togglePointerEvents(!1);
          const i = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
          for (const m of this.#U.values())
            if (m.disableEditing(), !!m.annotationElementId) {
              if (m.serialize() !== null) {
                i.set(m.annotationElementId, m);
                continue;
              } else
                c.set(m.annotationElementId, m);
              this.getEditableAnnotation(m.annotationElementId)?.show(), m.remove();
            }
          if (this.#n) {
            const m = this.#n.getEditableAnnotations();
            for (const M of m) {
              const {
                id: S
              } = M.data;
              if (this.#s.isDeletedAnnotationElement(S))
                continue;
              let p = c.get(S);
              if (p) {
                p.resetAnnotationElement(M), p.show(!1), M.show();
                continue;
              }
              p = i.get(S), p && (this.#s.addChangedExistingAnnotation(p), p.renderAnnotationElement(M), p.show(!1)), M.show();
            }
          }
          this.#N(), this.isEmpty && (this.div.hidden = !0);
          const {
            classList: R
          } = this.div;
          for (const m of Q.#Q.values())
            R.remove(`${m._type}Editing`);
          this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), this.#o = !1;
        }
        getEditableAnnotation(i) {
          return this.#n?.getEditableAnnotation(i) || null;
        }
        setActiveEditor(i) {
          this.#s.getActive() !== i && this.#s.setActiveEditor(i);
        }
        enableTextSelection() {
          this.div.tabIndex = -1, this.#F?.div && !this.#e && (this.#e = this.#W.bind(this), this.#F.div.addEventListener("pointerdown", this.#e), this.#F.div.classList.add("highlighting"));
        }
        disableTextSelection() {
          this.div.tabIndex = 0, this.#F?.div && this.#e && (this.#F.div.removeEventListener("pointerdown", this.#e), this.#e = null, this.#F.div.classList.remove("highlighting"));
        }
        #W(i) {
          if (this.#s.unselectAll(), i.target === this.#F.div) {
            const {
              isMac: c
            } = e.FeatureTest.platform;
            if (i.button !== 0 || i.ctrlKey && c)
              return;
            this.#s.showAllEditors("highlight", !0, !0), this.#F.div.classList.add("free"), o.startHighlighting(this, this.#s.direction === "ltr", i), this.#F.div.addEventListener("pointerup", () => {
              this.#F.div.classList.remove("free");
            }, {
              once: !0
            }), i.preventDefault();
          }
        }
        enableClick() {
          this.#a || (this.#a = this.pointerdown.bind(this), this.#d = this.pointerup.bind(this), this.div.addEventListener("pointerdown", this.#a), this.div.addEventListener("pointerup", this.#d));
        }
        disableClick() {
          this.#a && (this.div.removeEventListener("pointerdown", this.#a), this.div.removeEventListener("pointerup", this.#d), this.#a = null, this.#d = null);
        }
        attach(i) {
          this.#U.set(i.id, i);
          const {
            annotationElementId: c
          } = i;
          c && this.#s.isDeletedAnnotationElement(c) && this.#s.removeDeletedAnnotationElement(i);
        }
        detach(i) {
          this.#U.delete(i.id), this.#l?.removePointerInTextLayer(i.contentDiv), !this.#o && i.annotationElementId && this.#s.addDeletedAnnotationElement(i);
        }
        remove(i) {
          this.detach(i), this.#s.removeEditor(i), i.div.remove(), i.isAttachedToDOM = !1, this.#Z || this.addInkEditorIfNeeded(!1);
        }
        changeParent(i) {
          i.parent !== this && (i.parent && i.annotationElementId && (this.#s.addDeletedAnnotationElement(i.annotationElementId), d.AnnotationEditor.deleteAnnotationElement(i), i.annotationElementId = null), this.attach(i), i.parent?.detach(i), i.setParent(this), i.div && i.isAttachedToDOM && (i.div.remove(), this.div.append(i.div)));
        }
        add(i) {
          if (!(i.parent === this && i.isAttachedToDOM)) {
            if (this.changeParent(i), this.#s.addEditor(i), this.attach(i), !i.isAttachedToDOM) {
              const c = i.render();
              this.div.append(c), i.isAttachedToDOM = !0;
            }
            i.fixAndSetPosition(), i.onceAdded(), this.#s.addToAnnotationStorage(i), i._reportTelemetry(i.telemetryInitialData);
          }
        }
        moveEditorInDOM(i) {
          if (!i.isAttachedToDOM)
            return;
          const {
            activeElement: c
          } = document;
          i.div.contains(c) && !this.#i && (i._focusEventsAllowed = !1, this.#i = setTimeout(() => {
            this.#i = null, i.div.contains(document.activeElement) ? i._focusEventsAllowed = !0 : (i.div.addEventListener("focusin", () => {
              i._focusEventsAllowed = !0;
            }, {
              once: !0
            }), c.focus());
          }, 0)), i._structTreeParentId = this.#l?.moveElementInDOM(this.div, i.div, i.contentDiv, !0);
        }
        addOrRebuild(i) {
          i.needsToBeRebuilt() ? (i.parent ||= this, i.rebuild(), i.show()) : this.add(i);
        }
        addUndoableEditor(i) {
          const c = () => i._uiManager.rebuild(i), R = () => {
            i.remove();
          };
          this.addCommands({
            cmd: c,
            undo: R,
            mustExec: !1
          });
        }
        getNextId() {
          return this.#s.getId();
        }
        get #V() {
          return Q.#Q.get(this.#s.getMode());
        }
        #R(i) {
          const c = this.#V;
          return c ? new c.prototype.constructor(i) : null;
        }
        canCreateNewEmptyEditor() {
          return this.#V?.canCreateNewEmptyEditor();
        }
        pasteEditor(i, c) {
          this.#s.updateToolbar(i), this.#s.updateMode(i);
          const {
            offsetX: R,
            offsetY: m
          } = this.#h(), M = this.getNextId(), S = this.#R({
            parent: this,
            id: M,
            x: R,
            y: m,
            uiManager: this.#s,
            isCentered: !0,
            ...c
          });
          S && this.add(S);
        }
        deserialize(i) {
          return Q.#Q.get(i.annotationType ?? i.annotationEditorType)?.deserialize(i, this, this.#s) || null;
        }
        createAndAddNewEditor(i, c, R = {}) {
          const m = this.getNextId(), M = this.#R({
            parent: this,
            id: m,
            x: i.offsetX,
            y: i.offsetY,
            uiManager: this.#s,
            isCentered: c,
            ...R
          });
          return M && this.add(M), M;
        }
        #h() {
          const {
            x: i,
            y: c,
            width: R,
            height: m
          } = this.div.getBoundingClientRect(), M = Math.max(0, i), S = Math.max(0, c), p = Math.min(window.innerWidth, i + R), Y = Math.min(window.innerHeight, c + m), k = (M + p) / 2 - i, L = (S + Y) / 2 - c, [z, f] = this.viewport.rotation % 180 === 0 ? [k, L] : [L, k];
          return {
            offsetX: z,
            offsetY: f
          };
        }
        addNewEditor() {
          this.createAndAddNewEditor(this.#h(), !0);
        }
        setSelected(i) {
          this.#s.setSelected(i);
        }
        toggleSelected(i) {
          this.#s.toggleSelected(i);
        }
        isSelected(i) {
          return this.#s.isSelected(i);
        }
        unselect(i) {
          this.#s.unselect(i);
        }
        pointerup(i) {
          const {
            isMac: c
          } = e.FeatureTest.platform;
          if (!(i.button !== 0 || i.ctrlKey && c) && i.target === this.div && this.#c) {
            if (this.#c = !1, !this.#t) {
              this.#t = !0;
              return;
            }
            if (this.#s.getMode() === e.AnnotationEditorType.STAMP) {
              this.#s.unselectAll();
              return;
            }
            this.createAndAddNewEditor(i, !1);
          }
        }
        pointerdown(i) {
          if (this.#s.getMode() === e.AnnotationEditorType.HIGHLIGHT && this.enableTextSelection(), this.#c) {
            this.#c = !1;
            return;
          }
          const {
            isMac: c
          } = e.FeatureTest.platform;
          if (i.button !== 0 || i.ctrlKey && c || i.target !== this.div)
            return;
          this.#c = !0;
          const R = this.#s.getActive();
          this.#t = !R || R.isEmpty();
        }
        findNewParent(i, c, R) {
          const m = this.#s.findParent(c, R);
          return m === null || m === this ? !1 : (m.changeParent(i), !0);
        }
        destroy() {
          this.#s.getActive()?.parent === this && (this.#s.commitOrRemove(), this.#s.setActiveEditor(null)), this.#i && (clearTimeout(this.#i), this.#i = null);
          for (const i of this.#U.values())
            this.#l?.removePointerInTextLayer(i.contentDiv), i.setParent(null), i.isAttachedToDOM = !1, i.div.remove();
          this.div = null, this.#U.clear(), this.#s.removeLayer(this);
        }
        #N() {
          this.#Z = !0;
          for (const i of this.#U.values())
            i.isEmpty() && i.remove();
          this.#Z = !1;
        }
        render({
          viewport: i
        }) {
          this.viewport = i, (0, s.setLayerDimensions)(this.div, i);
          for (const c of this.#s.getEditors(this.pageIndex))
            this.add(c), c.rebuild();
          this.updateMode();
        }
        update({
          viewport: i
        }) {
          this.#s.commitOrRemove(), this.#N();
          const c = this.viewport.rotation, R = i.rotation;
          if (this.viewport = i, (0, s.setLayerDimensions)(this.div, {
            rotation: R
          }), c !== R)
            for (const m of this.#U.values())
              m.rotate(R);
          this.addInkEditorIfNeeded(!1);
        }
        get pageDimensions() {
          const {
            pageWidth: i,
            pageHeight: c
          } = this.viewport.rawDims;
          return [i, c];
        }
        get scale() {
          return this.#s.viewParameters.realScale;
        }
      }
    }
  ),
  /***/
  259: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        ColorPicker: () => (
          /* binding */
          U
        )
        /* harmony export */
      });
      var e = n(292), d = n(830), a = n(419);
      class U {
        #l = this.#W.bind(this);
        #t = this.#R.bind(this);
        #n = null;
        #d = null;
        #a;
        #e = null;
        #i = !1;
        #U = !1;
        #c = null;
        #Z;
        #o = null;
        #F;
        static get _keyboardManager() {
          return (0, e.shadow)(this, "_keyboardManager", new d.KeyboardManager([[["Escape", "mac+Escape"], U.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], U.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], U.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], U.prototype._moveToPrevious], [["Home", "mac+Home"], U.prototype._moveToBeginning], [["End", "mac+End"], U.prototype._moveToEnd]]));
        }
        constructor({
          editor: h = null,
          uiManager: W = null
        }) {
          h ? (this.#U = !1, this.#F = e.AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.#c = h) : (this.#U = !0, this.#F = e.AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR), this.#o = h?._uiManager || W, this.#Z = this.#o._eventBus, this.#a = h?.color || this.#o?.highlightColors.values().next().value || "#FFFF98";
        }
        renderButton() {
          const h = this.#n = document.createElement("button");
          h.className = "colorPicker", h.tabIndex = "0", h.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), h.setAttribute("aria-haspopup", !0), h.addEventListener("click", this.#V.bind(this)), h.addEventListener("keydown", this.#l);
          const W = this.#d = document.createElement("span");
          return W.className = "swatch", W.setAttribute("aria-hidden", !0), W.style.backgroundColor = this.#a, h.append(W), h;
        }
        renderMainDropdown() {
          const h = this.#e = this.#s();
          return h.setAttribute("aria-orientation", "horizontal"), h.setAttribute("aria-labelledby", "highlightColorPickerLabel"), h;
        }
        #s() {
          const h = document.createElement("div");
          h.addEventListener("contextmenu", a.noContextMenu), h.className = "dropdown", h.role = "listbox", h.setAttribute("aria-multiselectable", !1), h.setAttribute("aria-orientation", "vertical"), h.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
          for (const [W, Z] of this.#o.highlightColors) {
            const s = document.createElement("button");
            s.tabIndex = "0", s.role = "option", s.setAttribute("data-color", Z), s.title = W, s.setAttribute("data-l10n-id", `pdfjs-editor-colorpicker-${W}`);
            const o = document.createElement("span");
            s.append(o), o.className = "swatch", o.style.backgroundColor = Z, s.setAttribute("aria-selected", Z === this.#a), s.addEventListener("click", this.#Q.bind(this, Z)), h.append(s);
          }
          return h.addEventListener("keydown", this.#l), h;
        }
        #Q(h, W) {
          W.stopPropagation(), this.#Z.dispatch("switchannotationeditorparams", {
            source: this,
            type: this.#F,
            value: h
          });
        }
        _colorSelectFromKeyboard(h) {
          if (h.target === this.#n) {
            this.#V(h);
            return;
          }
          const W = h.target.getAttribute("data-color");
          W && this.#Q(W, h);
        }
        _moveToNext(h) {
          if (!this.#h) {
            this.#V(h);
            return;
          }
          if (h.target === this.#n) {
            this.#e.firstChild?.focus();
            return;
          }
          h.target.nextSibling?.focus();
        }
        _moveToPrevious(h) {
          if (h.target === this.#e?.firstChild || h.target === this.#n) {
            this.#h && this._hideDropdownFromKeyboard();
            return;
          }
          this.#h || this.#V(h), h.target.previousSibling?.focus();
        }
        _moveToBeginning(h) {
          if (!this.#h) {
            this.#V(h);
            return;
          }
          this.#e.firstChild?.focus();
        }
        _moveToEnd(h) {
          if (!this.#h) {
            this.#V(h);
            return;
          }
          this.#e.lastChild?.focus();
        }
        #W(h) {
          U._keyboardManager.exec(this, h);
        }
        #V(h) {
          if (this.#h) {
            this.hideDropdown();
            return;
          }
          if (this.#i = h.detail === 0, window.addEventListener("pointerdown", this.#t), this.#e) {
            this.#e.classList.remove("hidden");
            return;
          }
          const W = this.#e = this.#s();
          this.#n.append(W);
        }
        #R(h) {
          this.#e?.contains(h.target) || this.hideDropdown();
        }
        hideDropdown() {
          this.#e?.classList.add("hidden"), window.removeEventListener("pointerdown", this.#t);
        }
        get #h() {
          return this.#e && !this.#e.classList.contains("hidden");
        }
        _hideDropdownFromKeyboard() {
          if (!this.#U) {
            if (!this.#h) {
              this.#c?.unselect();
              return;
            }
            this.hideDropdown(), this.#n.focus({
              preventScroll: !0,
              focusVisible: this.#i
            });
          }
        }
        updateColor(h) {
          if (this.#d && (this.#d.style.backgroundColor = h), !this.#e)
            return;
          const W = this.#o.highlightColors.values();
          for (const Z of this.#e.children)
            Z.setAttribute("aria-selected", W.next().value === h);
        }
        destroy() {
          this.#n?.remove(), this.#n = null, this.#d = null, this.#e?.remove(), this.#e = null;
        }
      }
    }
  ),
  /***/
  310: (
    /***/
    (l, t, n) => {
      n.d(t, {
        AnnotationEditor: () => (
          /* binding */
          h
        )
      });
      var e = n(830), d = n(292), a = n(419);
      class U {
        #l = "";
        #t = !1;
        #n = null;
        #d = null;
        #a = null;
        #e = !1;
        #i = null;
        static _l10nPromise = null;
        constructor(s) {
          this.#i = s;
        }
        static initialize(s) {
          U._l10nPromise ||= s;
        }
        async render() {
          const s = this.#n = document.createElement("button");
          s.className = "altText";
          const o = await U._l10nPromise.get("pdfjs-editor-alt-text-button-label");
          s.textContent = o, s.setAttribute("aria-label", o), s.tabIndex = "0", s.addEventListener("contextmenu", a.noContextMenu), s.addEventListener("pointerdown", (N) => N.stopPropagation());
          const F = (N) => {
            N.preventDefault(), this.#i._uiManager.editAltText(this.#i);
          };
          return s.addEventListener("click", F, {
            capture: !0
          }), s.addEventListener("keydown", (N) => {
            N.target === s && N.key === "Enter" && (this.#e = !0, F(N));
          }), await this.#U(), s;
        }
        finish() {
          this.#n && (this.#n.focus({
            focusVisible: this.#e
          }), this.#e = !1);
        }
        isEmpty() {
          return !this.#l && !this.#t;
        }
        get data() {
          return {
            altText: this.#l,
            decorative: this.#t
          };
        }
        set data({
          altText: s,
          decorative: o
        }) {
          this.#l === s && this.#t === o || (this.#l = s, this.#t = o, this.#U());
        }
        toggle(s = !1) {
          this.#n && (!s && this.#a && (clearTimeout(this.#a), this.#a = null), this.#n.disabled = !s);
        }
        destroy() {
          this.#n?.remove(), this.#n = null, this.#d = null;
        }
        async #U() {
          const s = this.#n;
          if (!s)
            return;
          if (!this.#l && !this.#t) {
            s.classList.remove("done"), this.#d?.remove();
            return;
          }
          s.classList.add("done"), U._l10nPromise.get("pdfjs-editor-alt-text-edit-button-label").then((N) => {
            s.setAttribute("aria-label", N);
          });
          let o = this.#d;
          if (!o) {
            this.#d = o = document.createElement("span"), o.className = "tooltip", o.setAttribute("role", "tooltip");
            const N = o.id = `alt-text-tooltip-${this.#i.id}`;
            s.setAttribute("aria-describedby", N);
            const Q = 100;
            s.addEventListener("mouseenter", () => {
              this.#a = setTimeout(() => {
                this.#a = null, this.#d.classList.add("show"), this.#i._reportTelemetry({
                  action: "alt_text_tooltip"
                });
              }, Q);
            }), s.addEventListener("mouseleave", () => {
              this.#a && (clearTimeout(this.#a), this.#a = null), this.#d?.classList.remove("show");
            });
          }
          o.innerText = this.#t ? await U._l10nPromise.get("pdfjs-editor-alt-text-decorative-tooltip") : this.#l, o.parentNode || s.append(o), this.#i.getImageForAltText()?.setAttribute("aria-describedby", o.id);
        }
      }
      var V = n(362);
      class h {
        #l = null;
        #t = null;
        #n = !1;
        #d = !1;
        #a = null;
        #e = null;
        #i = this.focusin.bind(this);
        #U = this.focusout.bind(this);
        #c = null;
        #Z = "";
        #o = !1;
        #F = null;
        #s = !1;
        #Q = !1;
        #W = !1;
        #V = null;
        #R = 0;
        #h = 0;
        #N = null;
        _initialOptions = /* @__PURE__ */ Object.create(null);
        _isVisible = !0;
        _uiManager = null;
        _focusEventsAllowed = !0;
        _l10nPromise = null;
        #m = !1;
        #M = h._zIndex++;
        static _borderLineWidth = -1;
        static _colorManager = new e.ColorManager();
        static _zIndex = 1;
        static _telemetryTimeout = 1e3;
        static get _resizerKeyboardManager() {
          const s = h.prototype._resizeWithKeyboard, o = e.AnnotationEditorUIManager.TRANSLATE_SMALL, F = e.AnnotationEditorUIManager.TRANSLATE_BIG;
          return (0, d.shadow)(this, "_resizerKeyboardManager", new e.KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], s, {
            args: [-o, 0]
          }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], s, {
            args: [-F, 0]
          }], [["ArrowRight", "mac+ArrowRight"], s, {
            args: [o, 0]
          }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], s, {
            args: [F, 0]
          }], [["ArrowUp", "mac+ArrowUp"], s, {
            args: [0, -o]
          }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], s, {
            args: [0, -F]
          }], [["ArrowDown", "mac+ArrowDown"], s, {
            args: [0, o]
          }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], s, {
            args: [0, F]
          }], [["Escape", "mac+Escape"], h.prototype._stopResizingWithKeyboard]]));
        }
        constructor(s) {
          this.constructor === h && (0, d.unreachable)("Cannot initialize AnnotationEditor."), this.parent = s.parent, this.id = s.id, this.width = this.height = null, this.pageIndex = s.parent.pageIndex, this.name = s.name, this.div = null, this._uiManager = s.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = s.isCentered, this._structTreeParentId = null;
          const {
            rotation: o,
            rawDims: {
              pageWidth: F,
              pageHeight: N,
              pageX: Q,
              pageY: u
            }
          } = this.parent.viewport;
          this.rotation = o, this.pageRotation = (360 + o - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [F, N], this.pageTranslation = [Q, u];
          const [i, c] = this.parentDimensions;
          this.x = s.x / i, this.y = s.y / c, this.isAttachedToDOM = !1, this.deleted = !1;
        }
        get editorType() {
          return Object.getPrototypeOf(this).constructor._type;
        }
        static get _defaultLineColor() {
          return (0, d.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
        }
        static deleteAnnotationElement(s) {
          const o = new W({
            id: s.parent.getNextId(),
            parent: s.parent,
            uiManager: s._uiManager
          });
          o.annotationElementId = s.annotationElementId, o.deleted = !0, o._uiManager.addToAnnotationStorage(o);
        }
        static initialize(s, o, F) {
          if (h._l10nPromise ||= new Map(["pdfjs-editor-alt-text-button-label", "pdfjs-editor-alt-text-edit-button-label", "pdfjs-editor-alt-text-decorative-tooltip", "pdfjs-editor-resizer-label-topLeft", "pdfjs-editor-resizer-label-topMiddle", "pdfjs-editor-resizer-label-topRight", "pdfjs-editor-resizer-label-middleRight", "pdfjs-editor-resizer-label-bottomRight", "pdfjs-editor-resizer-label-bottomMiddle", "pdfjs-editor-resizer-label-bottomLeft", "pdfjs-editor-resizer-label-middleLeft"].map((Q) => [Q, s.get(Q.replaceAll(/([A-Z])/g, (u) => `-${u.toLowerCase()}`))])), F?.strings)
            for (const Q of F.strings)
              h._l10nPromise.set(Q, s.get(Q));
          if (h._borderLineWidth !== -1)
            return;
          const N = getComputedStyle(document.documentElement);
          h._borderLineWidth = parseFloat(N.getPropertyValue("--outline-width")) || 0;
        }
        static updateDefaultParams(s, o) {
        }
        static get defaultPropertiesToUpdate() {
          return [];
        }
        static isHandlingMimeForPasting(s) {
          return !1;
        }
        static paste(s, o) {
          (0, d.unreachable)("Not implemented");
        }
        get propertiesToUpdate() {
          return [];
        }
        get _isDraggable() {
          return this.#m;
        }
        set _isDraggable(s) {
          this.#m = s, this.div?.classList.toggle("draggable", s);
        }
        get isEnterHandled() {
          return !0;
        }
        center() {
          const [s, o] = this.pageDimensions;
          switch (this.parentRotation) {
            case 90:
              this.x -= this.height * o / (s * 2), this.y += this.width * s / (o * 2);
              break;
            case 180:
              this.x += this.width / 2, this.y += this.height / 2;
              break;
            case 270:
              this.x += this.height * o / (s * 2), this.y -= this.width * s / (o * 2);
              break;
            default:
              this.x -= this.width / 2, this.y -= this.height / 2;
              break;
          }
          this.fixAndSetPosition();
        }
        addCommands(s) {
          this._uiManager.addCommands(s);
        }
        get currentLayer() {
          return this._uiManager.currentLayer;
        }
        setInBackground() {
          this.div.style.zIndex = 0;
        }
        setInForeground() {
          this.div.style.zIndex = this.#M;
        }
        setParent(s) {
          s !== null ? (this.pageIndex = s.pageIndex, this.pageDimensions = s.pageDimensions) : this.#k(), this.parent = s;
        }
        focusin(s) {
          this._focusEventsAllowed && (this.#o ? this.#o = !1 : this.parent.setSelected(this));
        }
        focusout(s) {
          !this._focusEventsAllowed || !this.isAttachedToDOM || s.relatedTarget?.closest(`#${this.id}`) || (s.preventDefault(), this.parent?.isMultipleSelection || this.commitOrRemove());
        }
        commitOrRemove() {
          this.isEmpty() ? this.remove() : this.commit();
        }
        commit() {
          this.addToAnnotationStorage();
        }
        addToAnnotationStorage() {
          this._uiManager.addToAnnotationStorage(this);
        }
        setAt(s, o, F, N) {
          const [Q, u] = this.parentDimensions;
          [F, N] = this.screenToPageTranslation(F, N), this.x = (s + F) / Q, this.y = (o + N) / u, this.fixAndSetPosition();
        }
        #T([s, o], F, N) {
          [F, N] = this.screenToPageTranslation(F, N), this.x += F / s, this.y += N / o, this.fixAndSetPosition();
        }
        translate(s, o) {
          this.#T(this.parentDimensions, s, o);
        }
        translateInPage(s, o) {
          this.#F ||= [this.x, this.y], this.#T(this.pageDimensions, s, o), this.div.scrollIntoView({
            block: "nearest"
          });
        }
        drag(s, o) {
          this.#F ||= [this.x, this.y];
          const [F, N] = this.parentDimensions;
          if (this.x += s / F, this.y += o / N, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
            const {
              x: R,
              y: m
            } = this.div.getBoundingClientRect();
            this.parent.findNewParent(this, R, m) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
          }
          let {
            x: Q,
            y: u
          } = this;
          const [i, c] = this.getBaseTranslation();
          Q += i, u += c, this.div.style.left = `${(100 * Q).toFixed(2)}%`, this.div.style.top = `${(100 * u).toFixed(2)}%`, this.div.scrollIntoView({
            block: "nearest"
          });
        }
        get _hasBeenMoved() {
          return !!this.#F && (this.#F[0] !== this.x || this.#F[1] !== this.y);
        }
        getBaseTranslation() {
          const [s, o] = this.parentDimensions, {
            _borderLineWidth: F
          } = h, N = F / s, Q = F / o;
          switch (this.rotation) {
            case 90:
              return [-N, Q];
            case 180:
              return [N, Q];
            case 270:
              return [N, -Q];
            default:
              return [-N, -Q];
          }
        }
        get _mustFixPosition() {
          return !0;
        }
        fixAndSetPosition(s = this.rotation) {
          const [o, F] = this.pageDimensions;
          let {
            x: N,
            y: Q,
            width: u,
            height: i
          } = this;
          if (u *= o, i *= F, N *= o, Q *= F, this._mustFixPosition)
            switch (s) {
              case 0:
                N = Math.max(0, Math.min(o - u, N)), Q = Math.max(0, Math.min(F - i, Q));
                break;
              case 90:
                N = Math.max(0, Math.min(o - i, N)), Q = Math.min(F, Math.max(u, Q));
                break;
              case 180:
                N = Math.min(o, Math.max(u, N)), Q = Math.min(F, Math.max(i, Q));
                break;
              case 270:
                N = Math.min(o, Math.max(i, N)), Q = Math.max(0, Math.min(F - u, Q));
                break;
            }
          this.x = N /= o, this.y = Q /= F;
          const [c, R] = this.getBaseTranslation();
          N += c, Q += R;
          const {
            style: m
          } = this.div;
          m.left = `${(100 * N).toFixed(2)}%`, m.top = `${(100 * Q).toFixed(2)}%`, this.moveInDOM();
        }
        static #G(s, o, F) {
          switch (F) {
            case 90:
              return [o, -s];
            case 180:
              return [-s, -o];
            case 270:
              return [-o, s];
            default:
              return [s, o];
          }
        }
        screenToPageTranslation(s, o) {
          return h.#G(s, o, this.parentRotation);
        }
        pageTranslationToScreen(s, o) {
          return h.#G(s, o, 360 - this.parentRotation);
        }
        #X(s) {
          switch (s) {
            case 90: {
              const [o, F] = this.pageDimensions;
              return [0, -o / F, F / o, 0];
            }
            case 180:
              return [-1, 0, 0, -1];
            case 270: {
              const [o, F] = this.pageDimensions;
              return [0, o / F, -F / o, 0];
            }
            default:
              return [1, 0, 0, 1];
          }
        }
        get parentScale() {
          return this._uiManager.viewParameters.realScale;
        }
        get parentRotation() {
          return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
        }
        get parentDimensions() {
          const {
            parentScale: s,
            pageDimensions: [o, F]
          } = this, N = o * s, Q = F * s;
          return d.FeatureTest.isCSSRoundSupported ? [Math.round(N), Math.round(Q)] : [N, Q];
        }
        setDims(s, o) {
          const [F, N] = this.parentDimensions;
          this.div.style.width = `${(100 * s / F).toFixed(2)}%`, this.#d || (this.div.style.height = `${(100 * o / N).toFixed(2)}%`);
        }
        fixDims() {
          const {
            style: s
          } = this.div, {
            height: o,
            width: F
          } = s, N = F.endsWith("%"), Q = !this.#d && o.endsWith("%");
          if (N && Q)
            return;
          const [u, i] = this.parentDimensions;
          N || (s.width = `${(100 * parseFloat(F) / u).toFixed(2)}%`), !this.#d && !Q && (s.height = `${(100 * parseFloat(o) / i).toFixed(2)}%`);
        }
        getInitialTranslation() {
          return [0, 0];
        }
        #u() {
          if (this.#a)
            return;
          this.#a = document.createElement("div"), this.#a.classList.add("resizers");
          const s = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
          for (const o of s) {
            const F = document.createElement("div");
            this.#a.append(F), F.classList.add("resizer", o), F.setAttribute("data-resizer-name", o), F.addEventListener("pointerdown", this.#b.bind(this, o)), F.addEventListener("contextmenu", a.noContextMenu), F.tabIndex = -1;
          }
          this.div.prepend(this.#a);
        }
        #b(s, o) {
          o.preventDefault();
          const {
            isMac: F
          } = d.FeatureTest.platform;
          if (o.button !== 0 || o.ctrlKey && F)
            return;
          this.#t?.toggle(!1);
          const N = this.#S.bind(this, s), Q = this._isDraggable;
          this._isDraggable = !1;
          const u = {
            passive: !0,
            capture: !0
          };
          this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", N, u), window.addEventListener("contextmenu", a.noContextMenu);
          const i = this.x, c = this.y, R = this.width, m = this.height, M = this.parent.div.style.cursor, S = this.div.style.cursor;
          this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(o.target).cursor;
          const p = () => {
            this.parent.togglePointerEvents(!0), this.#t?.toggle(!0), this._isDraggable = Q, window.removeEventListener("pointerup", p), window.removeEventListener("blur", p), window.removeEventListener("pointermove", N, u), window.removeEventListener("contextmenu", a.noContextMenu), this.parent.div.style.cursor = M, this.div.style.cursor = S, this.#p(i, c, R, m);
          };
          window.addEventListener("pointerup", p), window.addEventListener("blur", p);
        }
        #p(s, o, F, N) {
          const Q = this.x, u = this.y, i = this.width, c = this.height;
          Q === s && u === o && i === F && c === N || this.addCommands({
            cmd: () => {
              this.width = i, this.height = c, this.x = Q, this.y = u;
              const [R, m] = this.parentDimensions;
              this.setDims(R * i, m * c), this.fixAndSetPosition();
            },
            undo: () => {
              this.width = F, this.height = N, this.x = s, this.y = o;
              const [R, m] = this.parentDimensions;
              this.setDims(R * F, m * N), this.fixAndSetPosition();
            },
            mustExec: !0
          });
        }
        #S(s, o) {
          const [F, N] = this.parentDimensions, Q = this.x, u = this.y, i = this.width, c = this.height, R = h.MIN_SIZE / F, m = h.MIN_SIZE / N, M = (B) => Math.round(B * 1e4) / 1e4, S = this.#X(this.rotation), p = (B, X) => [S[0] * B + S[2] * X, S[1] * B + S[3] * X], Y = this.#X(360 - this.rotation), k = (B, X) => [Y[0] * B + Y[2] * X, Y[1] * B + Y[3] * X];
          let L, z, f = !1, K = !1;
          switch (s) {
            case "topLeft":
              f = !0, L = (B, X) => [0, 0], z = (B, X) => [B, X];
              break;
            case "topMiddle":
              L = (B, X) => [B / 2, 0], z = (B, X) => [B / 2, X];
              break;
            case "topRight":
              f = !0, L = (B, X) => [B, 0], z = (B, X) => [0, X];
              break;
            case "middleRight":
              K = !0, L = (B, X) => [B, X / 2], z = (B, X) => [0, X / 2];
              break;
            case "bottomRight":
              f = !0, L = (B, X) => [B, X], z = (B, X) => [0, 0];
              break;
            case "bottomMiddle":
              L = (B, X) => [B / 2, X], z = (B, X) => [B / 2, 0];
              break;
            case "bottomLeft":
              f = !0, L = (B, X) => [0, X], z = (B, X) => [B, 0];
              break;
            case "middleLeft":
              K = !0, L = (B, X) => [0, X / 2], z = (B, X) => [B, X / 2];
              break;
          }
          const P = L(i, c), w = z(i, c);
          let O = p(...w);
          const el = M(Q + O[0]), ll = M(u + O[1]);
          let q = 1, _ = 1, [il, dl] = this.screenToPageTranslation(o.movementX, o.movementY);
          if ([il, dl] = k(il / F, dl / N), f) {
            const B = Math.hypot(i, c);
            q = _ = Math.max(Math.min(Math.hypot(w[0] - P[0] - il, w[1] - P[1] - dl) / B, 1 / i, 1 / c), R / i, m / c);
          } else
            K ? q = Math.max(R, Math.min(1, Math.abs(w[0] - P[0] - il))) / i : _ = Math.max(m, Math.min(1, Math.abs(w[1] - P[1] - dl))) / c;
          const tl = M(i * q), al = M(c * _);
          O = p(...z(tl, al));
          const Ul = el - O[0], cl = ll - O[1];
          this.width = tl, this.height = al, this.x = Ul, this.y = cl, this.setDims(F * tl, N * al), this.fixAndSetPosition();
        }
        altTextFinish() {
          this.#t?.finish();
        }
        async addEditToolbar() {
          return this.#c || this.#Q ? this.#c : (this.#c = new V.EditorToolbar(this), this.div.append(this.#c.render()), this.#t && this.#c.addAltTextButton(await this.#t.render()), this.#c);
        }
        removeEditToolbar() {
          this.#c && (this.#c.remove(), this.#c = null, this.#t?.destroy());
        }
        getClientDimensions() {
          return this.div.getBoundingClientRect();
        }
        async addAltTextButton() {
          this.#t || (U.initialize(h._l10nPromise), this.#t = new U(this), await this.addEditToolbar());
        }
        get altTextData() {
          return this.#t?.data;
        }
        set altTextData(s) {
          this.#t && (this.#t.data = s);
        }
        hasAltText() {
          return !this.#t?.isEmpty();
        }
        render() {
          this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = this.#n ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground(), this.div.addEventListener("focusin", this.#i), this.div.addEventListener("focusout", this.#U);
          const [s, o] = this.parentDimensions;
          this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * o / s).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * s / o).toFixed(2)}%`);
          const [F, N] = this.getInitialTranslation();
          return this.translate(F, N), (0, e.bindEvents)(this, this.div, ["pointerdown"]), this.div;
        }
        pointerdown(s) {
          const {
            isMac: o
          } = d.FeatureTest.platform;
          if (s.button !== 0 || s.ctrlKey && o) {
            s.preventDefault();
            return;
          }
          if (this.#o = !0, this._isDraggable) {
            this.#J(s);
            return;
          }
          this.#r(s);
        }
        #r(s) {
          const {
            isMac: o
          } = d.FeatureTest.platform;
          s.ctrlKey && !o || s.shiftKey || s.metaKey && o ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
        }
        #J(s) {
          const o = this._uiManager.isSelected(this);
          this._uiManager.setUpDragSession();
          let F, N;
          o && (this.div.classList.add("moving"), F = {
            passive: !0,
            capture: !0
          }, this.#R = s.clientX, this.#h = s.clientY, N = (u) => {
            const {
              clientX: i,
              clientY: c
            } = u, [R, m] = this.screenToPageTranslation(i - this.#R, c - this.#h);
            this.#R = i, this.#h = c, this._uiManager.dragSelectedEditors(R, m);
          }, window.addEventListener("pointermove", N, F));
          const Q = () => {
            window.removeEventListener("pointerup", Q), window.removeEventListener("blur", Q), o && (this.div.classList.remove("moving"), window.removeEventListener("pointermove", N, F)), this.#o = !1, this._uiManager.endDragSession() || this.#r(s);
          };
          window.addEventListener("pointerup", Q), window.addEventListener("blur", Q);
        }
        moveInDOM() {
          this.#V && clearTimeout(this.#V), this.#V = setTimeout(() => {
            this.#V = null, this.parent?.moveEditorInDOM(this);
          }, 0);
        }
        _setParentAndPosition(s, o, F) {
          s.changeParent(this), this.x = o, this.y = F, this.fixAndSetPosition();
        }
        getRect(s, o, F = this.rotation) {
          const N = this.parentScale, [Q, u] = this.pageDimensions, [i, c] = this.pageTranslation, R = s / N, m = o / N, M = this.x * Q, S = this.y * u, p = this.width * Q, Y = this.height * u;
          switch (F) {
            case 0:
              return [M + R + i, u - S - m - Y + c, M + R + p + i, u - S - m + c];
            case 90:
              return [M + m + i, u - S + R + c, M + m + Y + i, u - S + R + p + c];
            case 180:
              return [M - R - p + i, u - S + m + c, M - R + i, u - S + m + Y + c];
            case 270:
              return [M - m - Y + i, u - S - R - p + c, M - m + i, u - S - R + c];
            default:
              throw new Error("Invalid rotation");
          }
        }
        getRectInCurrentCoords(s, o) {
          const [F, N, Q, u] = s, i = Q - F, c = u - N;
          switch (this.rotation) {
            case 0:
              return [F, o - u, i, c];
            case 90:
              return [F, o - N, c, i];
            case 180:
              return [Q, o - N, i, c];
            case 270:
              return [Q, o - u, c, i];
            default:
              throw new Error("Invalid rotation");
          }
        }
        onceAdded() {
        }
        isEmpty() {
          return !1;
        }
        enableEditMode() {
          this.#Q = !0;
        }
        disableEditMode() {
          this.#Q = !1;
        }
        isInEditMode() {
          return this.#Q;
        }
        shouldGetKeyboardEvents() {
          return this.#W;
        }
        needsToBeRebuilt() {
          return this.div && !this.isAttachedToDOM;
        }
        rebuild() {
          this.div?.addEventListener("focusin", this.#i), this.div?.addEventListener("focusout", this.#U);
        }
        rotate(s) {
        }
        serialize(s = !1, o = null) {
          (0, d.unreachable)("An editor must be serializable");
        }
        static deserialize(s, o, F) {
          const N = new this.prototype.constructor({
            parent: o,
            id: o.getNextId(),
            uiManager: F
          });
          N.rotation = s.rotation;
          const [Q, u] = N.pageDimensions, [i, c, R, m] = N.getRectInCurrentCoords(s.rect, u);
          return N.x = i / Q, N.y = c / u, N.width = R / Q, N.height = m / u, N;
        }
        get hasBeenModified() {
          return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
        }
        remove() {
          if (this.div.removeEventListener("focusin", this.#i), this.div.removeEventListener("focusout", this.#U), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), this.#V && (clearTimeout(this.#V), this.#V = null), this.#k(), this.removeEditToolbar(), this.#N) {
            for (const s of this.#N.values())
              clearTimeout(s);
            this.#N = null;
          }
          this.parent = null;
        }
        get isResizable() {
          return !1;
        }
        makeResizable() {
          this.isResizable && (this.#u(), this.#a.classList.remove("hidden"), (0, e.bindEvents)(this, this.div, ["keydown"]));
        }
        get toolbarPosition() {
          return null;
        }
        keydown(s) {
          if (!this.isResizable || s.target !== this.div || s.key !== "Enter")
            return;
          this._uiManager.setSelected(this), this.#e = {
            savedX: this.x,
            savedY: this.y,
            savedWidth: this.width,
            savedHeight: this.height
          };
          const o = this.#a.children;
          if (!this.#l) {
            this.#l = Array.from(o);
            const u = this.#z.bind(this), i = this.#Y.bind(this);
            for (const c of this.#l) {
              const R = c.getAttribute("data-resizer-name");
              c.setAttribute("role", "spinbutton"), c.addEventListener("keydown", u), c.addEventListener("blur", i), c.addEventListener("focus", this.#L.bind(this, R)), h._l10nPromise.get(`pdfjs-editor-resizer-label-${R}`).then((m) => c.setAttribute("aria-label", m));
            }
          }
          const F = this.#l[0];
          let N = 0;
          for (const u of o) {
            if (u === F)
              break;
            N++;
          }
          const Q = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#l.length / 4);
          if (Q !== N) {
            if (Q < N)
              for (let i = 0; i < N - Q; i++)
                this.#a.append(this.#a.firstChild);
            else if (Q > N)
              for (let i = 0; i < Q - N; i++)
                this.#a.firstChild.before(this.#a.lastChild);
            let u = 0;
            for (const i of o) {
              const R = this.#l[u++].getAttribute("data-resizer-name");
              h._l10nPromise.get(`pdfjs-editor-resizer-label-${R}`).then((m) => i.setAttribute("aria-label", m));
            }
          }
          this.#B(0), this.#W = !0, this.#a.firstChild.focus({
            focusVisible: !0
          }), s.preventDefault(), s.stopImmediatePropagation();
        }
        #z(s) {
          h._resizerKeyboardManager.exec(this, s);
        }
        #Y(s) {
          this.#W && s.relatedTarget?.parentNode !== this.#a && this.#k();
        }
        #L(s) {
          this.#Z = this.#W ? s : "";
        }
        #B(s) {
          if (this.#l)
            for (const o of this.#l)
              o.tabIndex = s;
        }
        _resizeWithKeyboard(s, o) {
          this.#W && this.#S(this.#Z, {
            movementX: s,
            movementY: o
          });
        }
        #k() {
          if (this.#W = !1, this.#B(-1), this.#e) {
            const {
              savedX: s,
              savedY: o,
              savedWidth: F,
              savedHeight: N
            } = this.#e;
            this.#p(s, o, F, N), this.#e = null;
          }
        }
        _stopResizingWithKeyboard() {
          this.#k(), this.div.focus();
        }
        select() {
          if (this.makeResizable(), this.div?.classList.add("selectedEditor"), !this.#c) {
            this.addEditToolbar().then(() => {
              this.div?.classList.contains("selectedEditor") && this.#c?.show();
            });
            return;
          }
          this.#c?.show();
        }
        unselect() {
          this.#a?.classList.add("hidden"), this.div?.classList.remove("selectedEditor"), this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
            preventScroll: !0
          }), this.#c?.hide();
        }
        updateParams(s, o) {
        }
        disableEditing() {
        }
        enableEditing() {
        }
        enterInEditMode() {
        }
        getImageForAltText() {
          return null;
        }
        get contentDiv() {
          return this.div;
        }
        get isEditing() {
          return this.#s;
        }
        set isEditing(s) {
          this.#s = s, this.parent && (s ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
        }
        setAspectRatio(s, o) {
          this.#d = !0;
          const F = s / o, {
            style: N
          } = this.div;
          N.aspectRatio = F, N.height = "auto";
        }
        static get MIN_SIZE() {
          return 16;
        }
        static canCreateNewEmptyEditor() {
          return !0;
        }
        get telemetryInitialData() {
          return {
            action: "added"
          };
        }
        get telemetryFinalData() {
          return null;
        }
        _reportTelemetry(s, o = !1) {
          if (o) {
            this.#N ||= /* @__PURE__ */ new Map();
            const {
              action: F
            } = s;
            let N = this.#N.get(F);
            N && clearTimeout(N), N = setTimeout(() => {
              this._reportTelemetry(s), this.#N.delete(F), this.#N.size === 0 && (this.#N = null);
            }, h._telemetryTimeout), this.#N.set(F, N);
            return;
          }
          s.type ||= this.editorType, this._uiManager._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: s
            }
          });
        }
        show(s = this._isVisible) {
          this.div.classList.toggle("hidden", !s), this._isVisible = s;
        }
        enable() {
          this.div && (this.div.tabIndex = 0), this.#n = !1;
        }
        disable() {
          this.div && (this.div.tabIndex = -1), this.#n = !0;
        }
        renderAnnotationElement(s) {
          let o = s.container.querySelector(".annotationContent");
          if (!o)
            o = document.createElement("div"), o.classList.add("annotationContent", this.editorType), s.container.prepend(o);
          else if (o.nodeName === "CANVAS") {
            const F = o;
            o = document.createElement("div"), o.classList.add("annotationContent", this.editorType), F.before(o);
          }
          return o;
        }
        resetAnnotationElement(s) {
          const {
            firstChild: o
          } = s.container;
          o.nodeName === "DIV" && o.classList.contains("annotationContent") && o.remove();
        }
      }
      class W extends h {
        constructor(s) {
          super(s), this.annotationElementId = s.annotationElementId, this.deleted = !0;
        }
        serialize() {
          return {
            id: this.annotationElementId,
            deleted: !0,
            pageIndex: this.pageIndex
          };
        }
      }
    }
  ),
  /***/
  61: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        FreeOutliner: () => (
          /* binding */
          V
        ),
        /* harmony export */
        Outliner: () => (
          /* binding */
          d
        )
        /* harmony export */
      });
      var e = n(292);
      class d {
        #l;
        #t = [];
        #n = [];
        constructor(Z, s = 0, o = 0, F = !0) {
          let N = 1 / 0, Q = -1 / 0, u = 1 / 0, i = -1 / 0;
          const R = 10 ** -4;
          for (const {
            x: L,
            y: z,
            width: f,
            height: K
          } of Z) {
            const P = Math.floor((L - s) / R) * R, w = Math.ceil((L + f + s) / R) * R, O = Math.floor((z - s) / R) * R, el = Math.ceil((z + K + s) / R) * R, ll = [P, O, el, !0], q = [w, O, el, !1];
            this.#t.push(ll, q), N = Math.min(N, P), Q = Math.max(Q, w), u = Math.min(u, O), i = Math.max(i, el);
          }
          const m = Q - N + 2 * o, M = i - u + 2 * o, S = N - o, p = u - o, Y = this.#t.at(F ? -1 : -2), k = [Y[0], Y[2]];
          for (const L of this.#t) {
            const [z, f, K] = L;
            L[0] = (z - S) / m, L[1] = (f - p) / M, L[2] = (K - p) / M;
          }
          this.#l = {
            x: S,
            y: p,
            width: m,
            height: M,
            lastPoint: k
          };
        }
        getOutlines() {
          this.#t.sort((s, o) => s[0] - o[0] || s[1] - o[1] || s[2] - o[2]);
          const Z = [];
          for (const s of this.#t)
            s[3] ? (Z.push(...this.#U(s)), this.#e(s)) : (this.#i(s), Z.push(...this.#U(s)));
          return this.#d(Z);
        }
        #d(Z) {
          const s = [], o = /* @__PURE__ */ new Set();
          for (const Q of Z) {
            const [u, i, c] = Q;
            s.push([u, i, Q], [u, c, Q]);
          }
          s.sort((Q, u) => Q[1] - u[1] || Q[0] - u[0]);
          for (let Q = 0, u = s.length; Q < u; Q += 2) {
            const i = s[Q][2], c = s[Q + 1][2];
            i.push(c), c.push(i), o.add(i), o.add(c);
          }
          const F = [];
          let N;
          for (; o.size > 0; ) {
            const Q = o.values().next().value;
            let [u, i, c, R, m] = Q;
            o.delete(Q);
            let M = u, S = i;
            for (N = [u, c], F.push(N); ; ) {
              let p;
              if (o.has(R))
                p = R;
              else if (o.has(m))
                p = m;
              else
                break;
              o.delete(p), [u, i, c, R, m] = p, M !== u && (N.push(M, S, u, S === i ? i : c), M = u), S = S === i ? c : i;
            }
            N.push(M, S);
          }
          return new U(F, this.#l);
        }
        #a(Z) {
          const s = this.#n;
          let o = 0, F = s.length - 1;
          for (; o <= F; ) {
            const N = o + F >> 1, Q = s[N][0];
            if (Q === Z)
              return N;
            Q < Z ? o = N + 1 : F = N - 1;
          }
          return F + 1;
        }
        #e([, Z, s]) {
          const o = this.#a(Z);
          this.#n.splice(o, 0, [Z, s]);
        }
        #i([, Z, s]) {
          const o = this.#a(Z);
          for (let F = o; F < this.#n.length; F++) {
            const [N, Q] = this.#n[F];
            if (N !== Z)
              break;
            if (N === Z && Q === s) {
              this.#n.splice(F, 1);
              return;
            }
          }
          for (let F = o - 1; F >= 0; F--) {
            const [N, Q] = this.#n[F];
            if (N !== Z)
              break;
            if (N === Z && Q === s) {
              this.#n.splice(F, 1);
              return;
            }
          }
        }
        #U(Z) {
          const [s, o, F] = Z, N = [[s, o, F]], Q = this.#a(F);
          for (let u = 0; u < Q; u++) {
            const [i, c] = this.#n[u];
            for (let R = 0, m = N.length; R < m; R++) {
              const [, M, S] = N[R];
              if (!(c <= M || S <= i)) {
                if (M >= i) {
                  if (S > c)
                    N[R][1] = c;
                  else {
                    if (m === 1)
                      return [];
                    N.splice(R, 1), R--, m--;
                  }
                  continue;
                }
                N[R][2] = i, S > c && N.push([s, c, S]);
              }
            }
          }
          return N;
        }
      }
      class a {
        toSVGPath() {
          throw new Error("Abstract method `toSVGPath` must be implemented.");
        }
        get box() {
          throw new Error("Abstract getter `box` must be implemented.");
        }
        serialize(Z, s) {
          throw new Error("Abstract method `serialize` must be implemented.");
        }
        get free() {
          return this instanceof h;
        }
      }
      class U extends a {
        #l;
        #t;
        constructor(Z, s) {
          super(), this.#t = Z, this.#l = s;
        }
        toSVGPath() {
          const Z = [];
          for (const s of this.#t) {
            let [o, F] = s;
            Z.push(`M${o} ${F}`);
            for (let N = 2; N < s.length; N += 2) {
              const Q = s[N], u = s[N + 1];
              Q === o ? (Z.push(`V${u}`), F = u) : u === F && (Z.push(`H${Q}`), o = Q);
            }
            Z.push("Z");
          }
          return Z.join(" ");
        }
        serialize([Z, s, o, F], N) {
          const Q = [], u = o - Z, i = F - s;
          for (const c of this.#t) {
            const R = new Array(c.length);
            for (let m = 0; m < c.length; m += 2)
              R[m] = Z + c[m] * u, R[m + 1] = F - c[m + 1] * i;
            Q.push(R);
          }
          return Q;
        }
        get box() {
          return this.#l;
        }
      }
      class V {
        #l;
        #t = [];
        #n;
        #d;
        #a = [];
        #e = new Float64Array(18);
        #i;
        #U;
        #c;
        #Z;
        #o;
        #F;
        #s = [];
        static #Q = 8;
        static #W = 2;
        static #V = V.#Q + V.#W;
        constructor({
          x: Z,
          y: s
        }, o, F, N, Q, u = 0) {
          this.#l = o, this.#F = N * F, this.#d = Q, this.#e.set([NaN, NaN, NaN, NaN, Z, s], 6), this.#n = u, this.#Z = V.#Q * F, this.#c = V.#V * F, this.#o = F, this.#s.push(Z, s);
        }
        get free() {
          return !0;
        }
        isEmpty() {
          return isNaN(this.#e[8]);
        }
        #R() {
          const Z = this.#e.subarray(4, 6), s = this.#e.subarray(16, 18), [o, F, N, Q] = this.#l;
          return [(this.#i + (Z[0] - s[0]) / 2 - o) / N, (this.#U + (Z[1] - s[1]) / 2 - F) / Q, (this.#i + (s[0] - Z[0]) / 2 - o) / N, (this.#U + (s[1] - Z[1]) / 2 - F) / Q];
        }
        add({
          x: Z,
          y: s
        }) {
          this.#i = Z, this.#U = s;
          const [o, F, N, Q] = this.#l;
          let [u, i, c, R] = this.#e.subarray(8, 12);
          const m = Z - c, M = s - R, S = Math.hypot(m, M);
          if (S < this.#c)
            return !1;
          const p = S - this.#Z, Y = p / S, k = Y * m, L = Y * M;
          let z = u, f = i;
          u = c, i = R, c += k, R += L, this.#s?.push(Z, s);
          const K = -L / p, P = k / p, w = K * this.#F, O = P * this.#F;
          return this.#e.set(this.#e.subarray(2, 8), 0), this.#e.set([c + w, R + O], 4), this.#e.set(this.#e.subarray(14, 18), 12), this.#e.set([c - w, R - O], 16), isNaN(this.#e[6]) ? (this.#a.length === 0 && (this.#e.set([u + w, i + O], 2), this.#a.push(NaN, NaN, NaN, NaN, (u + w - o) / N, (i + O - F) / Q), this.#e.set([u - w, i - O], 14), this.#t.push(NaN, NaN, NaN, NaN, (u - w - o) / N, (i - O - F) / Q)), this.#e.set([z, f, u, i, c, R], 6), !this.isEmpty()) : (this.#e.set([z, f, u, i, c, R], 6), Math.abs(Math.atan2(f - i, z - u) - Math.atan2(L, k)) < Math.PI / 2 ? ([u, i, c, R] = this.#e.subarray(2, 6), this.#a.push(NaN, NaN, NaN, NaN, ((u + c) / 2 - o) / N, ((i + R) / 2 - F) / Q), [u, i, z, f] = this.#e.subarray(14, 18), this.#t.push(NaN, NaN, NaN, NaN, ((z + u) / 2 - o) / N, ((f + i) / 2 - F) / Q), !0) : ([z, f, u, i, c, R] = this.#e.subarray(0, 6), this.#a.push(((z + 5 * u) / 6 - o) / N, ((f + 5 * i) / 6 - F) / Q, ((5 * u + c) / 6 - o) / N, ((5 * i + R) / 6 - F) / Q, ((u + c) / 2 - o) / N, ((i + R) / 2 - F) / Q), [c, R, u, i, z, f] = this.#e.subarray(12, 18), this.#t.push(((z + 5 * u) / 6 - o) / N, ((f + 5 * i) / 6 - F) / Q, ((5 * u + c) / 6 - o) / N, ((5 * i + R) / 6 - F) / Q, ((u + c) / 2 - o) / N, ((i + R) / 2 - F) / Q), !0));
        }
        toSVGPath() {
          if (this.isEmpty())
            return "";
          const Z = this.#a, s = this.#t, o = this.#e.subarray(4, 6), F = this.#e.subarray(16, 18), [N, Q, u, i] = this.#l, [c, R, m, M] = this.#R();
          if (isNaN(this.#e[6]) && !this.isEmpty())
            return `M${(this.#e[2] - N) / u} ${(this.#e[3] - Q) / i} L${(this.#e[4] - N) / u} ${(this.#e[5] - Q) / i} L${c} ${R} L${m} ${M} L${(this.#e[16] - N) / u} ${(this.#e[17] - Q) / i} L${(this.#e[14] - N) / u} ${(this.#e[15] - Q) / i} Z`;
          const S = [];
          S.push(`M${Z[4]} ${Z[5]}`);
          for (let p = 6; p < Z.length; p += 6)
            isNaN(Z[p]) ? S.push(`L${Z[p + 4]} ${Z[p + 5]}`) : S.push(`C${Z[p]} ${Z[p + 1]} ${Z[p + 2]} ${Z[p + 3]} ${Z[p + 4]} ${Z[p + 5]}`);
          S.push(`L${(o[0] - N) / u} ${(o[1] - Q) / i} L${c} ${R} L${m} ${M} L${(F[0] - N) / u} ${(F[1] - Q) / i}`);
          for (let p = s.length - 6; p >= 6; p -= 6)
            isNaN(s[p]) ? S.push(`L${s[p + 4]} ${s[p + 5]}`) : S.push(`C${s[p]} ${s[p + 1]} ${s[p + 2]} ${s[p + 3]} ${s[p + 4]} ${s[p + 5]}`);
          return S.push(`L${s[4]} ${s[5]} Z`), S.join(" ");
        }
        getOutlines() {
          const Z = this.#a, s = this.#t, o = this.#e, F = o.subarray(4, 6), N = o.subarray(16, 18), [Q, u, i, c] = this.#l, R = new Float64Array((this.#s?.length ?? 0) + 2);
          for (let L = 0, z = R.length - 2; L < z; L += 2)
            R[L] = (this.#s[L] - Q) / i, R[L + 1] = (this.#s[L + 1] - u) / c;
          R[R.length - 2] = (this.#i - Q) / i, R[R.length - 1] = (this.#U - u) / c;
          const [m, M, S, p] = this.#R();
          if (isNaN(o[6]) && !this.isEmpty()) {
            const L = new Float64Array(36);
            return L.set([NaN, NaN, NaN, NaN, (o[2] - Q) / i, (o[3] - u) / c, NaN, NaN, NaN, NaN, (o[4] - Q) / i, (o[5] - u) / c, NaN, NaN, NaN, NaN, m, M, NaN, NaN, NaN, NaN, S, p, NaN, NaN, NaN, NaN, (o[16] - Q) / i, (o[17] - u) / c, NaN, NaN, NaN, NaN, (o[14] - Q) / i, (o[15] - u) / c], 0), new h(L, R, this.#l, this.#o, this.#n, this.#d);
          }
          const Y = new Float64Array(this.#a.length + 24 + this.#t.length);
          let k = Z.length;
          for (let L = 0; L < k; L += 2) {
            if (isNaN(Z[L])) {
              Y[L] = Y[L + 1] = NaN;
              continue;
            }
            Y[L] = Z[L], Y[L + 1] = Z[L + 1];
          }
          Y.set([NaN, NaN, NaN, NaN, (F[0] - Q) / i, (F[1] - u) / c, NaN, NaN, NaN, NaN, m, M, NaN, NaN, NaN, NaN, S, p, NaN, NaN, NaN, NaN, (N[0] - Q) / i, (N[1] - u) / c], k), k += 24;
          for (let L = s.length - 6; L >= 6; L -= 6)
            for (let z = 0; z < 6; z += 2) {
              if (isNaN(s[L + z])) {
                Y[k] = Y[k + 1] = NaN, k += 2;
                continue;
              }
              Y[k] = s[L + z], Y[k + 1] = s[L + z + 1], k += 2;
            }
          return Y.set([NaN, NaN, NaN, NaN, s[4], s[5]], k), new h(Y, R, this.#l, this.#o, this.#n, this.#d);
        }
      }
      class h extends a {
        #l;
        #t = null;
        #n;
        #d;
        #a;
        #e;
        #i;
        constructor(Z, s, o, F, N, Q) {
          super(), this.#i = Z, this.#a = s, this.#l = o, this.#e = F, this.#n = N, this.#d = Q, this.#Z(Q);
          const {
            x: u,
            y: i,
            width: c,
            height: R
          } = this.#t;
          for (let m = 0, M = Z.length; m < M; m += 2)
            Z[m] = (Z[m] - u) / c, Z[m + 1] = (Z[m + 1] - i) / R;
          for (let m = 0, M = s.length; m < M; m += 2)
            s[m] = (s[m] - u) / c, s[m + 1] = (s[m + 1] - i) / R;
        }
        toSVGPath() {
          const Z = [`M${this.#i[4]} ${this.#i[5]}`];
          for (let s = 6, o = this.#i.length; s < o; s += 6) {
            if (isNaN(this.#i[s])) {
              Z.push(`L${this.#i[s + 4]} ${this.#i[s + 5]}`);
              continue;
            }
            Z.push(`C${this.#i[s]} ${this.#i[s + 1]} ${this.#i[s + 2]} ${this.#i[s + 3]} ${this.#i[s + 4]} ${this.#i[s + 5]}`);
          }
          return Z.push("Z"), Z.join(" ");
        }
        serialize([Z, s, o, F], N) {
          const Q = o - Z, u = F - s;
          let i, c;
          switch (N) {
            case 0:
              i = this.#U(this.#i, Z, F, Q, -u), c = this.#U(this.#a, Z, F, Q, -u);
              break;
            case 90:
              i = this.#c(this.#i, Z, s, Q, u), c = this.#c(this.#a, Z, s, Q, u);
              break;
            case 180:
              i = this.#U(this.#i, o, s, -Q, u), c = this.#U(this.#a, o, s, -Q, u);
              break;
            case 270:
              i = this.#c(this.#i, o, F, -Q, -u), c = this.#c(this.#a, o, F, -Q, -u);
              break;
          }
          return {
            outline: Array.from(i),
            points: [Array.from(c)]
          };
        }
        #U(Z, s, o, F, N) {
          const Q = new Float64Array(Z.length);
          for (let u = 0, i = Z.length; u < i; u += 2)
            Q[u] = s + Z[u] * F, Q[u + 1] = o + Z[u + 1] * N;
          return Q;
        }
        #c(Z, s, o, F, N) {
          const Q = new Float64Array(Z.length);
          for (let u = 0, i = Z.length; u < i; u += 2)
            Q[u] = s + Z[u + 1] * F, Q[u + 1] = o + Z[u] * N;
          return Q;
        }
        #Z(Z) {
          const s = this.#i;
          let o = s[4], F = s[5], N = o, Q = F, u = o, i = F, c = o, R = F;
          const m = Z ? Math.max : Math.min;
          for (let k = 6, L = s.length; k < L; k += 6) {
            if (isNaN(s[k]))
              N = Math.min(N, s[k + 4]), Q = Math.min(Q, s[k + 5]), u = Math.max(u, s[k + 4]), i = Math.max(i, s[k + 5]), R < s[k + 5] ? (c = s[k + 4], R = s[k + 5]) : R === s[k + 5] && (c = m(c, s[k + 4]));
            else {
              const z = e.Util.bezierBoundingBox(o, F, ...s.slice(k, k + 6));
              N = Math.min(N, z[0]), Q = Math.min(Q, z[1]), u = Math.max(u, z[2]), i = Math.max(i, z[3]), R < z[3] ? (c = z[2], R = z[3]) : R === z[3] && (c = m(c, z[2]));
            }
            o = s[k + 4], F = s[k + 5];
          }
          const M = N - this.#n, S = Q - this.#n, p = u - N + 2 * this.#n, Y = i - Q + 2 * this.#n;
          this.#t = {
            x: M,
            y: S,
            width: p,
            height: Y,
            lastPoint: [c, R]
          };
        }
        get box() {
          return this.#t;
        }
        getNewOutline(Z, s) {
          const {
            x: o,
            y: F,
            width: N,
            height: Q
          } = this.#t, [u, i, c, R] = this.#l, m = N * c, M = Q * R, S = o * c + u, p = F * R + i, Y = new V({
            x: this.#a[0] * m + S,
            y: this.#a[1] * M + p
          }, this.#l, this.#e, Z, this.#d, s ?? this.#n);
          for (let k = 2; k < this.#a.length; k += 2)
            Y.add({
              x: this.#a[k] * m + S,
              y: this.#a[k + 1] * M + p
            });
          return Y.getOutlines();
        }
      }
    }
  ),
  /***/
  362: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        EditorToolbar: () => (
          /* binding */
          d
        ),
        /* harmony export */
        HighlightToolbar: () => (
          /* binding */
          a
        )
        /* harmony export */
      });
      var e = n(419);
      class d {
        #l = null;
        #t = null;
        #n;
        #d = null;
        constructor(V) {
          this.#n = V;
        }
        render() {
          const V = this.#l = document.createElement("div");
          V.className = "editToolbar", V.setAttribute("role", "toolbar"), V.addEventListener("contextmenu", e.noContextMenu), V.addEventListener("pointerdown", d.#a);
          const h = this.#d = document.createElement("div");
          h.className = "buttons", V.append(h);
          const W = this.#n.toolbarPosition;
          if (W) {
            const {
              style: Z
            } = V, s = this.#n._uiManager.direction === "ltr" ? 1 - W[0] : W[0];
            Z.insetInlineEnd = `${100 * s}%`, Z.top = `calc(${100 * W[1]}% + var(--editor-toolbar-vert-offset))`;
          }
          return this.#c(), V;
        }
        static #a(V) {
          V.stopPropagation();
        }
        #e(V) {
          this.#n._focusEventsAllowed = !1, V.preventDefault(), V.stopPropagation();
        }
        #i(V) {
          this.#n._focusEventsAllowed = !0, V.preventDefault(), V.stopPropagation();
        }
        #U(V) {
          V.addEventListener("focusin", this.#e.bind(this), {
            capture: !0
          }), V.addEventListener("focusout", this.#i.bind(this), {
            capture: !0
          }), V.addEventListener("contextmenu", e.noContextMenu);
        }
        hide() {
          this.#l.classList.add("hidden"), this.#t?.hideDropdown();
        }
        show() {
          this.#l.classList.remove("hidden");
        }
        #c() {
          const V = document.createElement("button");
          V.className = "delete", V.tabIndex = 0, V.setAttribute("data-l10n-id", `pdfjs-editor-remove-${this.#n.editorType}-button`), this.#U(V), V.addEventListener("click", (h) => {
            this.#n._uiManager.delete();
          }), this.#d.append(V);
        }
        get #Z() {
          const V = document.createElement("div");
          return V.className = "divider", V;
        }
        addAltTextButton(V) {
          this.#U(V), this.#d.prepend(V, this.#Z);
        }
        addColorPicker(V) {
          this.#t = V;
          const h = V.renderButton();
          this.#U(h), this.#d.prepend(h, this.#Z);
        }
        remove() {
          this.#l.remove(), this.#t?.destroy(), this.#t = null;
        }
      }
      class a {
        #l = null;
        #t = null;
        #n;
        constructor(V) {
          this.#n = V;
        }
        #d() {
          const V = this.#t = document.createElement("div");
          V.className = "editToolbar", V.setAttribute("role", "toolbar"), V.addEventListener("contextmenu", e.noContextMenu);
          const h = this.#l = document.createElement("div");
          return h.className = "buttons", V.append(h), this.#e(), V;
        }
        #a(V, h) {
          let W = 0, Z = 0;
          for (const s of V) {
            const o = s.y + s.height;
            if (o < W)
              continue;
            const F = s.x + (h ? s.width : 0);
            if (o > W) {
              Z = F, W = o;
              continue;
            }
            h ? F > Z && (Z = F) : F < Z && (Z = F);
          }
          return [h ? 1 - Z : Z, W];
        }
        show(V, h, W) {
          const [Z, s] = this.#a(h, W), {
            style: o
          } = this.#t ||= this.#d();
          V.append(this.#t), o.insetInlineEnd = `${100 * Z}%`, o.top = `calc(${100 * s}% + var(--editor-toolbar-vert-offset))`;
        }
        hide() {
          this.#t.remove();
        }
        #e() {
          const V = document.createElement("button");
          V.className = "highlightButton", V.tabIndex = 0, V.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
          const h = document.createElement("span");
          V.append(h), h.className = "visuallyHidden", h.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label"), V.addEventListener("contextmenu", e.noContextMenu), V.addEventListener("click", () => {
            this.#n.highlightSelection("floating_button");
          }), this.#l.append(V);
        }
      }
    }
  ),
  /***/
  830: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        AnnotationEditorUIManager: () => (
          /* binding */
          F
        ),
        /* harmony export */
        ColorManager: () => (
          /* binding */
          o
        ),
        /* harmony export */
        KeyboardManager: () => (
          /* binding */
          s
        ),
        /* harmony export */
        bindEvents: () => (
          /* binding */
          U
        ),
        /* harmony export */
        opacityToHex: () => (
          /* binding */
          V
        )
        /* harmony export */
      });
      var e = n(292), d = n(419), a = n(362);
      function U(N, Q, u) {
        for (const i of u)
          Q.addEventListener(i, N[i].bind(N));
      }
      function V(N) {
        return Math.round(Math.min(255, Math.max(1, 255 * N))).toString(16).padStart(2, "0");
      }
      class h {
        #l = 0;
        constructor() {
        }
        get id() {
          return `${e.AnnotationEditorPrefix}${this.#l++}`;
        }
      }
      class W {
        #l = (0, e.getUuid)();
        #t = 0;
        #n = null;
        static get _isSVGFittingCanvas() {
          const Q = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', i = new OffscreenCanvas(1, 3).getContext("2d"), c = new Image();
          c.src = Q;
          const R = c.decode().then(() => (i.drawImage(c, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(i.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
          return (0, e.shadow)(this, "_isSVGFittingCanvas", R);
        }
        async #d(Q, u) {
          this.#n ||= /* @__PURE__ */ new Map();
          let i = this.#n.get(Q);
          if (i === null)
            return null;
          if (i?.bitmap)
            return i.refCounter += 1, i;
          try {
            i ||= {
              bitmap: null,
              id: `image_${this.#l}_${this.#t++}`,
              refCounter: 0,
              isSvg: !1
            };
            let c;
            if (typeof u == "string" ? (i.url = u, c = await (0, d.fetchData)(u, "blob")) : c = i.file = u, c.type === "image/svg+xml") {
              const R = W._isSVGFittingCanvas, m = new FileReader(), M = new Image(), S = new Promise((p, Y) => {
                M.onload = () => {
                  i.bitmap = M, i.isSvg = !0, p();
                }, m.onload = async () => {
                  const k = i.svgUrl = m.result;
                  M.src = await R ? `${k}#svgView(preserveAspectRatio(none))` : k;
                }, M.onerror = m.onerror = Y;
              });
              m.readAsDataURL(c), await S;
            } else
              i.bitmap = await createImageBitmap(c);
            i.refCounter = 1;
          } catch (c) {
            console.error(c), i = null;
          }
          return this.#n.set(Q, i), i && this.#n.set(i.id, i), i;
        }
        async getFromFile(Q) {
          const {
            lastModified: u,
            name: i,
            size: c,
            type: R
          } = Q;
          return this.#d(`${u}_${i}_${c}_${R}`, Q);
        }
        async getFromUrl(Q) {
          return this.#d(Q, Q);
        }
        async getFromId(Q) {
          this.#n ||= /* @__PURE__ */ new Map();
          const u = this.#n.get(Q);
          return u ? u.bitmap ? (u.refCounter += 1, u) : u.file ? this.getFromFile(u.file) : this.getFromUrl(u.url) : null;
        }
        getSvgUrl(Q) {
          const u = this.#n.get(Q);
          return u?.isSvg ? u.svgUrl : null;
        }
        deleteId(Q) {
          this.#n ||= /* @__PURE__ */ new Map();
          const u = this.#n.get(Q);
          u && (u.refCounter -= 1, u.refCounter === 0 && (u.bitmap = null));
        }
        isValidId(Q) {
          return Q.startsWith(`image_${this.#l}_`);
        }
      }
      class Z {
        #l = [];
        #t = !1;
        #n;
        #d = -1;
        constructor(Q = 128) {
          this.#n = Q;
        }
        add({
          cmd: Q,
          undo: u,
          post: i,
          mustExec: c,
          type: R = NaN,
          overwriteIfSameType: m = !1,
          keepUndo: M = !1
        }) {
          if (c && Q(), this.#t)
            return;
          const S = {
            cmd: Q,
            undo: u,
            post: i,
            type: R
          };
          if (this.#d === -1) {
            this.#l.length > 0 && (this.#l.length = 0), this.#d = 0, this.#l.push(S);
            return;
          }
          if (m && this.#l[this.#d].type === R) {
            M && (S.undo = this.#l[this.#d].undo), this.#l[this.#d] = S;
            return;
          }
          const p = this.#d + 1;
          p === this.#n ? this.#l.splice(0, 1) : (this.#d = p, p < this.#l.length && this.#l.splice(p)), this.#l.push(S);
        }
        undo() {
          if (this.#d === -1)
            return;
          this.#t = !0;
          const {
            undo: Q,
            post: u
          } = this.#l[this.#d];
          Q(), u?.(), this.#t = !1, this.#d -= 1;
        }
        redo() {
          if (this.#d < this.#l.length - 1) {
            this.#d += 1, this.#t = !0;
            const {
              cmd: Q,
              post: u
            } = this.#l[this.#d];
            Q(), u?.(), this.#t = !1;
          }
        }
        hasSomethingToUndo() {
          return this.#d !== -1;
        }
        hasSomethingToRedo() {
          return this.#d < this.#l.length - 1;
        }
        destroy() {
          this.#l = null;
        }
      }
      class s {
        constructor(Q) {
          this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
          const {
            isMac: u
          } = e.FeatureTest.platform;
          for (const [i, c, R = {}] of Q)
            for (const m of i) {
              const M = m.startsWith("mac+");
              u && M ? (this.callbacks.set(m.slice(4), {
                callback: c,
                options: R
              }), this.allKeys.add(m.split("+").at(-1))) : !u && !M && (this.callbacks.set(m, {
                callback: c,
                options: R
              }), this.allKeys.add(m.split("+").at(-1)));
            }
        }
        #l(Q) {
          Q.altKey && this.buffer.push("alt"), Q.ctrlKey && this.buffer.push("ctrl"), Q.metaKey && this.buffer.push("meta"), Q.shiftKey && this.buffer.push("shift"), this.buffer.push(Q.key);
          const u = this.buffer.join("+");
          return this.buffer.length = 0, u;
        }
        exec(Q, u) {
          if (!this.allKeys.has(u.key))
            return;
          const i = this.callbacks.get(this.#l(u));
          if (!i)
            return;
          const {
            callback: c,
            options: {
              bubbles: R = !1,
              args: m = [],
              checker: M = null
            }
          } = i;
          M && !M(Q, u) || (c.bind(Q, ...m, u)(), R || (u.stopPropagation(), u.preventDefault()));
        }
      }
      class o {
        static _colorsMapping = /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
        get _colors() {
          const Q = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
          return (0, d.getColorValues)(Q), (0, e.shadow)(this, "_colors", Q);
        }
        convert(Q) {
          const u = (0, d.getRGB)(Q);
          if (!window.matchMedia("(forced-colors: active)").matches)
            return u;
          for (const [i, c] of this._colors)
            if (c.every((R, m) => R === u[m]))
              return o._colorsMapping.get(i);
          return u;
        }
        getHexCode(Q) {
          const u = this._colors.get(Q);
          return u ? e.Util.makeHexColor(...u) : Q;
        }
      }
      class F {
        #l = null;
        #t = /* @__PURE__ */ new Map();
        #n = /* @__PURE__ */ new Map();
        #d = null;
        #a = null;
        #e = null;
        #i = new Z();
        #U = 0;
        #c = /* @__PURE__ */ new Set();
        #Z = null;
        #o = null;
        #F = /* @__PURE__ */ new Set();
        #s = !1;
        #Q = null;
        #W = null;
        #V = null;
        #R = !1;
        #h = null;
        #N = new h();
        #m = !1;
        #M = !1;
        #T = null;
        #G = null;
        #X = null;
        #u = e.AnnotationEditorType.NONE;
        #b = /* @__PURE__ */ new Set();
        #p = null;
        #S = null;
        #r = null;
        #J = this.blur.bind(this);
        #z = this.focus.bind(this);
        #Y = this.copy.bind(this);
        #L = this.cut.bind(this);
        #B = this.paste.bind(this);
        #k = this.keydown.bind(this);
        #x = this.keyup.bind(this);
        #O = this.onEditingAction.bind(this);
        #v = this.onPageChanging.bind(this);
        #g = this.onScaleChanging.bind(this);
        #w = this.#al.bind(this);
        #I = this.onRotationChanging.bind(this);
        #P = {
          isEditing: !1,
          isEmpty: !0,
          hasSomethingToUndo: !1,
          hasSomethingToRedo: !1,
          hasSelectedEditor: !1,
          hasSelectedText: !1
        };
        #j = [0, 0];
        #D = null;
        #E = null;
        #A = null;
        static TRANSLATE_SMALL = 1;
        static TRANSLATE_BIG = 10;
        static get _keyboardManager() {
          const Q = F.prototype, u = (m) => m.#E.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && m.hasSomethingToControl(), i = (m, {
            target: M
          }) => {
            if (M instanceof HTMLInputElement) {
              const {
                type: S
              } = M;
              return S !== "text" && S !== "number";
            }
            return !0;
          }, c = this.TRANSLATE_SMALL, R = this.TRANSLATE_BIG;
          return (0, e.shadow)(this, "_keyboardManager", new s([[["ctrl+a", "mac+meta+a"], Q.selectAll, {
            checker: i
          }], [["ctrl+z", "mac+meta+z"], Q.undo, {
            checker: i
          }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], Q.redo, {
            checker: i
          }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], Q.delete, {
            checker: i
          }], [["Enter", "mac+Enter"], Q.addNewEditorFromKeyboard, {
            checker: (m, {
              target: M
            }) => !(M instanceof HTMLButtonElement) && m.#E.contains(M) && !m.isEnterHandled
          }], [[" ", "mac+ "], Q.addNewEditorFromKeyboard, {
            checker: (m, {
              target: M
            }) => !(M instanceof HTMLButtonElement) && m.#E.contains(document.activeElement)
          }], [["Escape", "mac+Escape"], Q.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], Q.translateSelectedEditors, {
            args: [-c, 0],
            checker: u
          }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], Q.translateSelectedEditors, {
            args: [-R, 0],
            checker: u
          }], [["ArrowRight", "mac+ArrowRight"], Q.translateSelectedEditors, {
            args: [c, 0],
            checker: u
          }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], Q.translateSelectedEditors, {
            args: [R, 0],
            checker: u
          }], [["ArrowUp", "mac+ArrowUp"], Q.translateSelectedEditors, {
            args: [0, -c],
            checker: u
          }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], Q.translateSelectedEditors, {
            args: [0, -R],
            checker: u
          }], [["ArrowDown", "mac+ArrowDown"], Q.translateSelectedEditors, {
            args: [0, c],
            checker: u
          }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], Q.translateSelectedEditors, {
            args: [0, R],
            checker: u
          }]]));
        }
        constructor(Q, u, i, c, R, m, M, S, p) {
          this.#E = Q, this.#A = u, this.#d = i, this._eventBus = c, this._eventBus._on("editingaction", this.#O), this._eventBus._on("pagechanging", this.#v), this._eventBus._on("scalechanging", this.#g), this._eventBus._on("rotationchanging", this.#I), this.#il(), this.#q(), this.#a = R.annotationStorage, this.#Q = R.filterFactory, this.#S = m, this.#V = M || null, this.#s = S, this.#X = p || null, this.viewParameters = {
            realScale: d.PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: 0
          }, this.isShiftKeyDown = !1;
        }
        destroy() {
          this.#_(), this.#$(), this._eventBus._off("editingaction", this.#O), this._eventBus._off("pagechanging", this.#v), this._eventBus._off("scalechanging", this.#g), this._eventBus._off("rotationchanging", this.#I);
          for (const Q of this.#n.values())
            Q.destroy();
          this.#n.clear(), this.#t.clear(), this.#F.clear(), this.#l = null, this.#b.clear(), this.#i.destroy(), this.#d?.destroy(), this.#h?.hide(), this.#h = null, this.#W && (clearTimeout(this.#W), this.#W = null), this.#D && (clearTimeout(this.#D), this.#D = null), this.#sl();
        }
        async mlGuess(Q) {
          return this.#X?.guess(Q) || null;
        }
        get hasMLManager() {
          return !!this.#X;
        }
        get hcmFilter() {
          return (0, e.shadow)(this, "hcmFilter", this.#S ? this.#Q.addHCMFilter(this.#S.foreground, this.#S.background) : "none");
        }
        get direction() {
          return (0, e.shadow)(this, "direction", getComputedStyle(this.#E).direction);
        }
        get highlightColors() {
          return (0, e.shadow)(this, "highlightColors", this.#V ? new Map(this.#V.split(",").map((Q) => Q.split("=").map((u) => u.trim()))) : null);
        }
        get highlightColorNames() {
          return (0, e.shadow)(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (Q) => Q.reverse())) : null);
        }
        setMainHighlightColorPicker(Q) {
          this.#G = Q;
        }
        editAltText(Q) {
          this.#d?.editAltText(this, Q);
        }
        onPageChanging({
          pageNumber: Q
        }) {
          this.#U = Q - 1;
        }
        focusMainContainer() {
          this.#E.focus();
        }
        findParent(Q, u) {
          for (const i of this.#n.values()) {
            const {
              x: c,
              y: R,
              width: m,
              height: M
            } = i.div.getBoundingClientRect();
            if (Q >= c && Q <= c + m && u >= R && u <= R + M)
              return i;
          }
          return null;
        }
        disableUserSelect(Q = !1) {
          this.#A.classList.toggle("noUserSelect", Q);
        }
        addShouldRescale(Q) {
          this.#F.add(Q);
        }
        removeShouldRescale(Q) {
          this.#F.delete(Q);
        }
        onScaleChanging({
          scale: Q
        }) {
          this.commitOrRemove(), this.viewParameters.realScale = Q * d.PixelsPerInch.PDF_TO_CSS_UNITS;
          for (const u of this.#F)
            u.onScaleChanging();
        }
        onRotationChanging({
          pagesRotation: Q
        }) {
          this.commitOrRemove(), this.viewParameters.rotation = Q;
        }
        #K({
          anchorNode: Q
        }) {
          return Q.nodeType === Node.TEXT_NODE ? Q.parentElement : Q;
        }
        highlightSelection(Q = "") {
          const u = document.getSelection();
          if (!u || u.isCollapsed)
            return;
          const {
            anchorNode: i,
            anchorOffset: c,
            focusNode: R,
            focusOffset: m
          } = u, M = u.toString(), p = this.#K(u).closest(".textLayer"), Y = this.getSelectionBoxes(p);
          if (Y) {
            u.empty(), this.#u === e.AnnotationEditorType.NONE && (this._eventBus.dispatch("showannotationeditorui", {
              source: this,
              mode: e.AnnotationEditorType.HIGHLIGHT
            }), this.showAllEditors("highlight", !0, !0));
            for (const k of this.#n.values())
              if (k.hasTextLayer(p)) {
                k.createAndAddNewEditor({
                  x: 0,
                  y: 0
                }, !1, {
                  methodOfCreation: Q,
                  boxes: Y,
                  anchorNode: i,
                  anchorOffset: c,
                  focusNode: R,
                  focusOffset: m,
                  text: M
                });
                break;
              }
          }
        }
        #dl() {
          const Q = document.getSelection();
          if (!Q || Q.isCollapsed)
            return;
          const i = this.#K(Q).closest(".textLayer"), c = this.getSelectionBoxes(i);
          c && (this.#h ||= new a.HighlightToolbar(this), this.#h.show(i, c, this.direction === "ltr"));
        }
        addToAnnotationStorage(Q) {
          !Q.isEmpty() && this.#a && !this.#a.has(Q.id) && this.#a.setValue(Q.id, Q);
        }
        #al() {
          const Q = document.getSelection();
          if (!Q || Q.isCollapsed) {
            this.#p && (this.#h?.hide(), this.#p = null, this.#y({
              hasSelectedText: !1
            }));
            return;
          }
          const {
            anchorNode: u
          } = Q;
          if (u === this.#p)
            return;
          if (!this.#K(Q).closest(".textLayer")) {
            this.#p && (this.#h?.hide(), this.#p = null, this.#y({
              hasSelectedText: !1
            }));
            return;
          }
          if (this.#h?.hide(), this.#p = u, this.#y({
            hasSelectedText: !0
          }), !(this.#u !== e.AnnotationEditorType.HIGHLIGHT && this.#u !== e.AnnotationEditorType.NONE) && (this.#u === e.AnnotationEditorType.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), this.#R = this.isShiftKeyDown, !this.isShiftKeyDown)) {
            const R = (m) => {
              m.type === "pointerup" && m.button !== 0 || (window.removeEventListener("pointerup", R), window.removeEventListener("blur", R), m.type === "pointerup" && this.#H("main_toolbar"));
            };
            window.addEventListener("pointerup", R), window.addEventListener("blur", R);
          }
        }
        #H(Q = "") {
          this.#u === e.AnnotationEditorType.HIGHLIGHT ? this.highlightSelection(Q) : this.#s && this.#dl();
        }
        #il() {
          document.addEventListener("selectionchange", this.#w);
        }
        #sl() {
          document.removeEventListener("selectionchange", this.#w);
        }
        #cl() {
          window.addEventListener("focus", this.#z), window.addEventListener("blur", this.#J);
        }
        #$() {
          window.removeEventListener("focus", this.#z), window.removeEventListener("blur", this.#J);
        }
        blur() {
          if (this.isShiftKeyDown = !1, this.#R && (this.#R = !1, this.#H("main_toolbar")), !this.hasSelection)
            return;
          const {
            activeElement: Q
          } = document;
          for (const u of this.#b)
            if (u.div.contains(Q)) {
              this.#T = [u, Q], u._focusEventsAllowed = !1;
              break;
            }
        }
        focus() {
          if (!this.#T)
            return;
          const [Q, u] = this.#T;
          this.#T = null, u.addEventListener("focusin", () => {
            Q._focusEventsAllowed = !0;
          }, {
            once: !0
          }), u.focus();
        }
        #q() {
          window.addEventListener("keydown", this.#k), window.addEventListener("keyup", this.#x);
        }
        #_() {
          window.removeEventListener("keydown", this.#k), window.removeEventListener("keyup", this.#x);
        }
        #ll() {
          document.addEventListener("copy", this.#Y), document.addEventListener("cut", this.#L), document.addEventListener("paste", this.#B);
        }
        #tl() {
          document.removeEventListener("copy", this.#Y), document.removeEventListener("cut", this.#L), document.removeEventListener("paste", this.#B);
        }
        addEditListeners() {
          this.#q(), this.#ll();
        }
        removeEditListeners() {
          this.#_(), this.#tl();
        }
        copy(Q) {
          if (Q.preventDefault(), this.#l?.commitOrRemove(), !this.hasSelection)
            return;
          const u = [];
          for (const i of this.#b) {
            const c = i.serialize(!0);
            c && u.push(c);
          }
          u.length !== 0 && Q.clipboardData.setData("application/pdfjs", JSON.stringify(u));
        }
        cut(Q) {
          this.copy(Q), this.delete();
        }
        paste(Q) {
          Q.preventDefault();
          const {
            clipboardData: u
          } = Q;
          for (const R of u.items)
            for (const m of this.#o)
              if (m.isHandlingMimeForPasting(R.type)) {
                m.paste(R, this.currentLayer);
                return;
              }
          let i = u.getData("application/pdfjs");
          if (!i)
            return;
          try {
            i = JSON.parse(i);
          } catch (R) {
            (0, e.warn)(`paste: "${R.message}".`);
            return;
          }
          if (!Array.isArray(i))
            return;
          this.unselectAll();
          const c = this.currentLayer;
          try {
            const R = [];
            for (const S of i) {
              const p = c.deserialize(S);
              if (!p)
                return;
              R.push(p);
            }
            const m = () => {
              for (const S of R)
                this.#nl(S);
              this.#el(R);
            }, M = () => {
              for (const S of R)
                S.remove();
            };
            this.addCommands({
              cmd: m,
              undo: M,
              mustExec: !0
            });
          } catch (R) {
            (0, e.warn)(`paste: "${R.message}".`);
          }
        }
        keydown(Q) {
          !this.isShiftKeyDown && Q.key === "Shift" && (this.isShiftKeyDown = !0), this.#u !== e.AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard && F._keyboardManager.exec(this, Q);
        }
        keyup(Q) {
          this.isShiftKeyDown && Q.key === "Shift" && (this.isShiftKeyDown = !1, this.#R && (this.#R = !1, this.#H("main_toolbar")));
        }
        onEditingAction({
          name: Q
        }) {
          switch (Q) {
            case "undo":
            case "redo":
            case "delete":
            case "selectAll":
              this[Q]();
              break;
            case "highlightSelection":
              this.highlightSelection("context_menu");
              break;
          }
        }
        #y(Q) {
          Object.entries(Q).some(([i, c]) => this.#P[i] !== c) && (this._eventBus.dispatch("annotationeditorstateschanged", {
            source: this,
            details: Object.assign(this.#P, Q)
          }), this.#u === e.AnnotationEditorType.HIGHLIGHT && Q.hasSelectedEditor === !1 && this.#C([[e.AnnotationEditorParamsType.HIGHLIGHT_FREE, !0]]));
        }
        #C(Q) {
          this._eventBus.dispatch("annotationeditorparamschanged", {
            source: this,
            details: Q
          });
        }
        setEditingState(Q) {
          Q ? (this.#cl(), this.#ll(), this.#y({
            isEditing: this.#u !== e.AnnotationEditorType.NONE,
            isEmpty: this.#f(),
            hasSomethingToUndo: this.#i.hasSomethingToUndo(),
            hasSomethingToRedo: this.#i.hasSomethingToRedo(),
            hasSelectedEditor: !1
          })) : (this.#$(), this.#tl(), this.#y({
            isEditing: !1
          }), this.disableUserSelect(!1));
        }
        registerEditorTypes(Q) {
          if (!this.#o) {
            this.#o = Q;
            for (const u of this.#o)
              this.#C(u.defaultPropertiesToUpdate);
          }
        }
        getId() {
          return this.#N.id;
        }
        get currentLayer() {
          return this.#n.get(this.#U);
        }
        getLayer(Q) {
          return this.#n.get(Q);
        }
        get currentPageIndex() {
          return this.#U;
        }
        addLayer(Q) {
          this.#n.set(Q.pageIndex, Q), this.#m ? Q.enable() : Q.disable();
        }
        removeLayer(Q) {
          this.#n.delete(Q.pageIndex);
        }
        updateMode(Q, u = null, i = !1) {
          if (this.#u !== Q) {
            if (this.#u = Q, Q === e.AnnotationEditorType.NONE) {
              this.setEditingState(!1), this.#Zl();
              return;
            }
            this.setEditingState(!0), this.#Ul(), this.unselectAll();
            for (const c of this.#n.values())
              c.updateMode(Q);
            if (!u && i) {
              this.addNewEditorFromKeyboard();
              return;
            }
            if (u) {
              for (const c of this.#t.values())
                if (c.annotationElementId === u) {
                  this.setSelected(c), c.enterInEditMode();
                  break;
                }
            }
          }
        }
        addNewEditorFromKeyboard() {
          this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
        }
        updateToolbar(Q) {
          Q !== this.#u && this._eventBus.dispatch("switchannotationeditormode", {
            source: this,
            mode: Q
          });
        }
        updateParams(Q, u) {
          if (this.#o) {
            switch (Q) {
              case e.AnnotationEditorParamsType.CREATE:
                this.currentLayer.addNewEditor();
                return;
              case e.AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:
                this.#G?.updateColor(u);
                break;
              case e.AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
                this._eventBus.dispatch("reporttelemetry", {
                  source: this,
                  details: {
                    type: "editing",
                    data: {
                      type: "highlight",
                      action: "toggle_visibility"
                    }
                  }
                }), (this.#r ||= /* @__PURE__ */ new Map()).set(Q, u), this.showAllEditors("highlight", u);
                break;
            }
            for (const i of this.#b)
              i.updateParams(Q, u);
            for (const i of this.#o)
              i.updateDefaultParams(Q, u);
          }
        }
        showAllEditors(Q, u, i = !1) {
          for (const R of this.#t.values())
            R.editorType === Q && R.show(u);
          (this.#r?.get(e.AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? !0) !== u && this.#C([[e.AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, u]]);
        }
        enableWaiting(Q = !1) {
          if (this.#M !== Q) {
            this.#M = Q;
            for (const u of this.#n.values())
              Q ? u.disableClick() : u.enableClick(), u.div.classList.toggle("waiting", Q);
          }
        }
        #Ul() {
          if (!this.#m) {
            this.#m = !0;
            for (const Q of this.#n.values())
              Q.enable();
            for (const Q of this.#t.values())
              Q.enable();
          }
        }
        #Zl() {
          if (this.unselectAll(), this.#m) {
            this.#m = !1;
            for (const Q of this.#n.values())
              Q.disable();
            for (const Q of this.#t.values())
              Q.disable();
          }
        }
        getEditors(Q) {
          const u = [];
          for (const i of this.#t.values())
            i.pageIndex === Q && u.push(i);
          return u;
        }
        getEditor(Q) {
          return this.#t.get(Q);
        }
        addEditor(Q) {
          this.#t.set(Q.id, Q);
        }
        removeEditor(Q) {
          Q.div.contains(document.activeElement) && (this.#W && clearTimeout(this.#W), this.#W = setTimeout(() => {
            this.focusMainContainer(), this.#W = null;
          }, 0)), this.#t.delete(Q.id), this.unselect(Q), (!Q.annotationElementId || !this.#c.has(Q.annotationElementId)) && this.#a?.remove(Q.id);
        }
        addDeletedAnnotationElement(Q) {
          this.#c.add(Q.annotationElementId), this.addChangedExistingAnnotation(Q), Q.deleted = !0;
        }
        isDeletedAnnotationElement(Q) {
          return this.#c.has(Q);
        }
        removeDeletedAnnotationElement(Q) {
          this.#c.delete(Q.annotationElementId), this.removeChangedExistingAnnotation(Q), Q.deleted = !1;
        }
        #nl(Q) {
          const u = this.#n.get(Q.pageIndex);
          u ? u.addOrRebuild(Q) : (this.addEditor(Q), this.addToAnnotationStorage(Q));
        }
        setActiveEditor(Q) {
          this.#l !== Q && (this.#l = Q, Q && this.#C(Q.propertiesToUpdate));
        }
        get #Fl() {
          let Q = null;
          for (Q of this.#b)
            ;
          return Q;
        }
        updateUI(Q) {
          this.#Fl === Q && this.#C(Q.propertiesToUpdate);
        }
        toggleSelected(Q) {
          if (this.#b.has(Q)) {
            this.#b.delete(Q), Q.unselect(), this.#y({
              hasSelectedEditor: this.hasSelection
            });
            return;
          }
          this.#b.add(Q), Q.select(), this.#C(Q.propertiesToUpdate), this.#y({
            hasSelectedEditor: !0
          });
        }
        setSelected(Q) {
          for (const u of this.#b)
            u !== Q && u.unselect();
          this.#b.clear(), this.#b.add(Q), Q.select(), this.#C(Q.propertiesToUpdate), this.#y({
            hasSelectedEditor: !0
          });
        }
        isSelected(Q) {
          return this.#b.has(Q);
        }
        get firstSelectedEditor() {
          return this.#b.values().next().value;
        }
        unselect(Q) {
          Q.unselect(), this.#b.delete(Q), this.#y({
            hasSelectedEditor: this.hasSelection
          });
        }
        get hasSelection() {
          return this.#b.size !== 0;
        }
        get isEnterHandled() {
          return this.#b.size === 1 && this.firstSelectedEditor.isEnterHandled;
        }
        undo() {
          this.#i.undo(), this.#y({
            hasSomethingToUndo: this.#i.hasSomethingToUndo(),
            hasSomethingToRedo: !0,
            isEmpty: this.#f()
          });
        }
        redo() {
          this.#i.redo(), this.#y({
            hasSomethingToUndo: !0,
            hasSomethingToRedo: this.#i.hasSomethingToRedo(),
            isEmpty: this.#f()
          });
        }
        addCommands(Q) {
          this.#i.add(Q), this.#y({
            hasSomethingToUndo: !0,
            hasSomethingToRedo: !1,
            isEmpty: this.#f()
          });
        }
        #f() {
          if (this.#t.size === 0)
            return !0;
          if (this.#t.size === 1)
            for (const Q of this.#t.values())
              return Q.isEmpty();
          return !1;
        }
        delete() {
          if (this.commitOrRemove(), !this.hasSelection)
            return;
          const Q = [...this.#b], u = () => {
            for (const c of Q)
              c.remove();
          }, i = () => {
            for (const c of Q)
              this.#nl(c);
          };
          this.addCommands({
            cmd: u,
            undo: i,
            mustExec: !0
          });
        }
        commitOrRemove() {
          this.#l?.commitOrRemove();
        }
        hasSomethingToControl() {
          return this.#l || this.hasSelection;
        }
        #el(Q) {
          for (const u of this.#b)
            u.unselect();
          this.#b.clear();
          for (const u of Q)
            u.isEmpty() || (this.#b.add(u), u.select());
          this.#y({
            hasSelectedEditor: this.hasSelection
          });
        }
        selectAll() {
          for (const Q of this.#b)
            Q.commit();
          this.#el(this.#t.values());
        }
        unselectAll() {
          if (!(this.#l && (this.#l.commitOrRemove(), this.#u !== e.AnnotationEditorType.NONE)) && this.hasSelection) {
            for (const Q of this.#b)
              Q.unselect();
            this.#b.clear(), this.#y({
              hasSelectedEditor: !1
            });
          }
        }
        translateSelectedEditors(Q, u, i = !1) {
          if (i || this.commitOrRemove(), !this.hasSelection)
            return;
          this.#j[0] += Q, this.#j[1] += u;
          const [c, R] = this.#j, m = [...this.#b], M = 1e3;
          this.#D && clearTimeout(this.#D), this.#D = setTimeout(() => {
            this.#D = null, this.#j[0] = this.#j[1] = 0, this.addCommands({
              cmd: () => {
                for (const S of m)
                  this.#t.has(S.id) && S.translateInPage(c, R);
              },
              undo: () => {
                for (const S of m)
                  this.#t.has(S.id) && S.translateInPage(-c, -R);
              },
              mustExec: !1
            });
          }, M);
          for (const S of m)
            S.translateInPage(Q, u);
        }
        setUpDragSession() {
          if (this.hasSelection) {
            this.disableUserSelect(!0), this.#Z = /* @__PURE__ */ new Map();
            for (const Q of this.#b)
              this.#Z.set(Q, {
                savedX: Q.x,
                savedY: Q.y,
                savedPageIndex: Q.pageIndex,
                newX: 0,
                newY: 0,
                newPageIndex: -1
              });
          }
        }
        endDragSession() {
          if (!this.#Z)
            return !1;
          this.disableUserSelect(!1);
          const Q = this.#Z;
          this.#Z = null;
          let u = !1;
          for (const [{
            x: c,
            y: R,
            pageIndex: m
          }, M] of Q)
            M.newX = c, M.newY = R, M.newPageIndex = m, u ||= c !== M.savedX || R !== M.savedY || m !== M.savedPageIndex;
          if (!u)
            return !1;
          const i = (c, R, m, M) => {
            if (this.#t.has(c.id)) {
              const S = this.#n.get(M);
              S ? c._setParentAndPosition(S, R, m) : (c.pageIndex = M, c.x = R, c.y = m);
            }
          };
          return this.addCommands({
            cmd: () => {
              for (const [c, {
                newX: R,
                newY: m,
                newPageIndex: M
              }] of Q)
                i(c, R, m, M);
            },
            undo: () => {
              for (const [c, {
                savedX: R,
                savedY: m,
                savedPageIndex: M
              }] of Q)
                i(c, R, m, M);
            },
            mustExec: !0
          }), !0;
        }
        dragSelectedEditors(Q, u) {
          if (this.#Z)
            for (const i of this.#Z.keys())
              i.drag(Q, u);
        }
        rebuild(Q) {
          if (Q.parent === null) {
            const u = this.getLayer(Q.pageIndex);
            u ? (u.changeParent(Q), u.addOrRebuild(Q)) : (this.addEditor(Q), this.addToAnnotationStorage(Q), Q.rebuild());
          } else
            Q.parent.addOrRebuild(Q);
        }
        get isEditorHandlingKeyboard() {
          return this.getActive()?.shouldGetKeyboardEvents() || this.#b.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
        }
        isActive(Q) {
          return this.#l === Q;
        }
        getActive() {
          return this.#l;
        }
        getMode() {
          return this.#u;
        }
        get imageManager() {
          return (0, e.shadow)(this, "imageManager", new W());
        }
        getSelectionBoxes(Q) {
          if (!Q)
            return null;
          const u = document.getSelection();
          for (let p = 0, Y = u.rangeCount; p < Y; p++)
            if (!Q.contains(u.getRangeAt(p).commonAncestorContainer))
              return null;
          const {
            x: i,
            y: c,
            width: R,
            height: m
          } = Q.getBoundingClientRect();
          let M;
          switch (Q.getAttribute("data-main-rotation")) {
            case "90":
              M = (p, Y, k, L) => ({
                x: (Y - c) / m,
                y: 1 - (p + k - i) / R,
                width: L / m,
                height: k / R
              });
              break;
            case "180":
              M = (p, Y, k, L) => ({
                x: 1 - (p + k - i) / R,
                y: 1 - (Y + L - c) / m,
                width: k / R,
                height: L / m
              });
              break;
            case "270":
              M = (p, Y, k, L) => ({
                x: 1 - (Y + L - c) / m,
                y: (p - i) / R,
                width: L / m,
                height: k / R
              });
              break;
            default:
              M = (p, Y, k, L) => ({
                x: (p - i) / R,
                y: (Y - c) / m,
                width: k / R,
                height: L / m
              });
              break;
          }
          const S = [];
          for (let p = 0, Y = u.rangeCount; p < Y; p++) {
            const k = u.getRangeAt(p);
            if (!k.collapsed)
              for (const {
                x: L,
                y: z,
                width: f,
                height: K
              } of k.getClientRects())
                f === 0 || K === 0 || S.push(M(L, z, f, K));
          }
          return S.length === 0 ? null : S;
        }
        addChangedExistingAnnotation({
          annotationElementId: Q,
          id: u
        }) {
          (this.#e ||= /* @__PURE__ */ new Map()).set(Q, u);
        }
        removeChangedExistingAnnotation({
          annotationElementId: Q
        }) {
          this.#e?.delete(Q);
        }
        renderAnnotationElement(Q) {
          const u = this.#e?.get(Q.data.id);
          if (!u)
            return;
          const i = this.#a.getRawValue(u);
          i && (this.#u === e.AnnotationEditorType.NONE && !i.hasBeenModified || i.renderAnnotationElement(Q));
        }
      }
    }
  ),
  /***/
  94: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        PDFFetchStream: () => (
          /* binding */
          h
        )
        /* harmony export */
      });
      var e = n(292), d = n(490);
      function a(s, o, F) {
        return {
          method: "GET",
          headers: s,
          signal: F.signal,
          mode: "cors",
          credentials: o ? "include" : "same-origin",
          redirect: "follow"
        };
      }
      function U(s) {
        const o = new Headers();
        for (const F in s) {
          const N = s[F];
          N !== void 0 && o.append(F, N);
        }
        return o;
      }
      function V(s) {
        return s instanceof Uint8Array ? s.buffer : s instanceof ArrayBuffer ? s : ((0, e.warn)(`getArrayBuffer - unexpected data format: ${s}`), new Uint8Array(s).buffer);
      }
      class h {
        constructor(o) {
          this.source = o, this.isHttp = /^https?:/i.test(o.url), this.httpHeaders = this.isHttp && o.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
        }
        get _progressiveDataLength() {
          return this._fullRequestReader?._loaded ?? 0;
        }
        getFullReader() {
          return (0, e.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new W(this), this._fullRequestReader;
        }
        getRangeReader(o, F) {
          if (F <= this._progressiveDataLength)
            return null;
          const N = new Z(this, o, F);
          return this._rangeRequestReaders.push(N), N;
        }
        cancelAllRequests(o) {
          this._fullRequestReader?.cancel(o);
          for (const F of this._rangeRequestReaders.slice(0))
            F.cancel(o);
        }
      }
      class W {
        constructor(o) {
          this._stream = o, this._reader = null, this._loaded = 0, this._filename = null;
          const F = o.source;
          this._withCredentials = F.withCredentials || !1, this._contentLength = F.length, this._headersCapability = Promise.withResolvers(), this._disableRange = F.disableRange || !1, this._rangeChunkSize = F.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !F.disableStream, this._isRangeSupported = !F.disableRange, this._headers = U(this._stream.httpHeaders);
          const N = F.url;
          fetch(N, a(this._headers, this._withCredentials, this._abortController)).then((Q) => {
            if (!(0, d.validateResponseStatus)(Q.status))
              throw (0, d.createResponseStatusError)(Q.status, N);
            this._reader = Q.body.getReader(), this._headersCapability.resolve();
            const u = (R) => Q.headers.get(R), {
              allowRangeRequests: i,
              suggestedLength: c
            } = (0, d.validateRangeRequestCapabilities)({
              getResponseHeader: u,
              isHttp: this._stream.isHttp,
              rangeChunkSize: this._rangeChunkSize,
              disableRange: this._disableRange
            });
            this._isRangeSupported = i, this._contentLength = c || this._contentLength, this._filename = (0, d.extractFilenameFromHeader)(u), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new e.AbortException("Streaming is disabled."));
          }).catch(this._headersCapability.reject), this.onProgress = null;
        }
        get headersReady() {
          return this._headersCapability.promise;
        }
        get filename() {
          return this._filename;
        }
        get contentLength() {
          return this._contentLength;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        async read() {
          await this._headersCapability.promise;
          const {
            value: o,
            done: F
          } = await this._reader.read();
          return F ? {
            value: o,
            done: F
          } : (this._loaded += o.byteLength, this.onProgress?.({
            loaded: this._loaded,
            total: this._contentLength
          }), {
            value: V(o),
            done: !1
          });
        }
        cancel(o) {
          this._reader?.cancel(o), this._abortController.abort();
        }
      }
      class Z {
        constructor(o, F, N) {
          this._stream = o, this._reader = null, this._loaded = 0;
          const Q = o.source;
          this._withCredentials = Q.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !Q.disableStream, this._abortController = new AbortController(), this._headers = U(this._stream.httpHeaders), this._headers.append("Range", `bytes=${F}-${N - 1}`);
          const u = Q.url;
          fetch(u, a(this._headers, this._withCredentials, this._abortController)).then((i) => {
            if (!(0, d.validateResponseStatus)(i.status))
              throw (0, d.createResponseStatusError)(i.status, u);
            this._readCapability.resolve(), this._reader = i.body.getReader();
          }).catch(this._readCapability.reject), this.onProgress = null;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        async read() {
          await this._readCapability.promise;
          const {
            value: o,
            done: F
          } = await this._reader.read();
          return F ? {
            value: o,
            done: F
          } : (this._loaded += o.byteLength, this.onProgress?.({
            loaded: this._loaded
          }), {
            value: V(o),
            done: !1
          });
        }
        cancel(o) {
          this._reader?.cancel(o), this._abortController.abort();
        }
      }
    }
  ),
  /***/
  10: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        FontFaceObject: () => (
          /* binding */
          a
        ),
        /* harmony export */
        FontLoader: () => (
          /* binding */
          d
        )
        /* harmony export */
      });
      var e = n(292);
      class d {
        #l = /* @__PURE__ */ new Set();
        constructor({
          ownerDocument: V = globalThis.document,
          styleElement: h = null
        }) {
          this._document = V, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
        }
        addNativeFontFace(V) {
          this.nativeFontFaces.add(V), this._document.fonts.add(V);
        }
        removeNativeFontFace(V) {
          this.nativeFontFaces.delete(V), this._document.fonts.delete(V);
        }
        insertRule(V) {
          this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
          const h = this.styleElement.sheet;
          h.insertRule(V, h.cssRules.length);
        }
        clear() {
          for (const V of this.nativeFontFaces)
            this._document.fonts.delete(V);
          this.nativeFontFaces.clear(), this.#l.clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
        }
        async loadSystemFont({
          systemFontInfo: V,
          _inspectFont: h
        }) {
          if (!(!V || this.#l.has(V.loadedName))) {
            if ((0, e.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
              const {
                loadedName: W,
                src: Z,
                style: s
              } = V, o = new FontFace(W, Z, s);
              this.addNativeFontFace(o);
              try {
                await o.load(), this.#l.add(W), h?.(V);
              } catch {
                (0, e.warn)(`Cannot load system font: ${V.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(o);
              }
              return;
            }
            (0, e.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
          }
        }
        async bind(V) {
          if (V.attached || V.missingFile && !V.systemFontInfo)
            return;
          if (V.attached = !0, V.systemFontInfo) {
            await this.loadSystemFont(V);
            return;
          }
          if (this.isFontLoadingAPISupported) {
            const W = V.createNativeFontFace();
            if (W) {
              this.addNativeFontFace(W);
              try {
                await W.loaded;
              } catch (Z) {
                throw (0, e.warn)(`Failed to load font '${W.family}': '${Z}'.`), V.disableFontFace = !0, Z;
              }
            }
            return;
          }
          const h = V.createFontFaceRule();
          if (h) {
            if (this.insertRule(h), this.isSyncFontLoadingSupported)
              return;
            await new Promise((W) => {
              const Z = this._queueLoadingCallback(W);
              this._prepareFontLoadEvent(V, Z);
            });
          }
        }
        get isFontLoadingAPISupported() {
          const V = !!this._document?.fonts;
          return (0, e.shadow)(this, "isFontLoadingAPISupported", V);
        }
        get isSyncFontLoadingSupported() {
          let V = !1;
          return (e.isNodeJS || typeof navigator < "u" && typeof navigator?.userAgent == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (V = !0), (0, e.shadow)(this, "isSyncFontLoadingSupported", V);
        }
        _queueLoadingCallback(V) {
          function h() {
            for ((0, e.assert)(!Z.done, "completeRequest() cannot be called twice."), Z.done = !0; W.length > 0 && W[0].done; ) {
              const s = W.shift();
              setTimeout(s.callback, 0);
            }
          }
          const {
            loadingRequests: W
          } = this, Z = {
            done: !1,
            complete: h,
            callback: V
          };
          return W.push(Z), Z;
        }
        get _loadTestFont() {
          const V = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
          return (0, e.shadow)(this, "_loadTestFont", V);
        }
        _prepareFontLoadEvent(V, h) {
          function W(L, z) {
            return L.charCodeAt(z) << 24 | L.charCodeAt(z + 1) << 16 | L.charCodeAt(z + 2) << 8 | L.charCodeAt(z + 3) & 255;
          }
          function Z(L, z, f, K) {
            const P = L.substring(0, z), w = L.substring(z + f);
            return P + K + w;
          }
          let s, o;
          const F = this._document.createElement("canvas");
          F.width = 1, F.height = 1;
          const N = F.getContext("2d");
          let Q = 0;
          function u(L, z) {
            if (++Q > 30) {
              (0, e.warn)("Load test font never loaded."), z();
              return;
            }
            if (N.font = "30px " + L, N.fillText(".", 0, 20), N.getImageData(0, 0, 1, 1).data[3] > 0) {
              z();
              return;
            }
            setTimeout(u.bind(null, L, z));
          }
          const i = `lt${Date.now()}${this.loadTestFontId++}`;
          let c = this._loadTestFont;
          c = Z(c, 976, i.length, i);
          const m = 16, M = 1482184792;
          let S = W(c, m);
          for (s = 0, o = i.length - 3; s < o; s += 4)
            S = S - M + W(i, s) | 0;
          s < i.length && (S = S - M + W(i + "XXX", s) | 0), c = Z(c, m, 4, (0, e.string32)(S));
          const p = `url(data:font/opentype;base64,${btoa(c)});`, Y = `@font-face {font-family:"${i}";src:${p}}`;
          this.insertRule(Y);
          const k = this._document.createElement("div");
          k.style.visibility = "hidden", k.style.width = k.style.height = "10px", k.style.position = "absolute", k.style.top = k.style.left = "0px";
          for (const L of [V.loadedName, i]) {
            const z = this._document.createElement("span");
            z.textContent = "Hi", z.style.fontFamily = L, k.append(z);
          }
          this._document.body.append(k), u(i, () => {
            k.remove(), h.complete();
          });
        }
      }
      class a {
        constructor(V, {
          disableFontFace: h = !1,
          ignoreErrors: W = !1,
          inspectFont: Z = null
        }) {
          this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
          for (const s in V)
            this[s] = V[s];
          this.disableFontFace = h === !0, this.ignoreErrors = W === !0, this._inspectFont = Z;
        }
        createNativeFontFace() {
          if (!this.data || this.disableFontFace)
            return null;
          let V;
          if (!this.cssFontInfo)
            V = new FontFace(this.loadedName, this.data, {});
          else {
            const h = {
              weight: this.cssFontInfo.fontWeight
            };
            this.cssFontInfo.italicAngle && (h.style = `oblique ${this.cssFontInfo.italicAngle}deg`), V = new FontFace(this.cssFontInfo.fontFamily, this.data, h);
          }
          return this._inspectFont?.(this), V;
        }
        createFontFaceRule() {
          if (!this.data || this.disableFontFace)
            return null;
          const V = (0, e.bytesToString)(this.data), h = `url(data:${this.mimetype};base64,${btoa(V)});`;
          let W;
          if (!this.cssFontInfo)
            W = `@font-face {font-family:"${this.loadedName}";src:${h}}`;
          else {
            let Z = `font-weight: ${this.cssFontInfo.fontWeight};`;
            this.cssFontInfo.italicAngle && (Z += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), W = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${Z}src:${h}}`;
          }
          return this._inspectFont?.(this, h), W;
        }
        getPathGenerator(V, h) {
          if (this.compiledGlyphs[h] !== void 0)
            return this.compiledGlyphs[h];
          let W;
          try {
            W = V.get(this.loadedName + "_path_" + h);
          } catch (s) {
            if (!this.ignoreErrors)
              throw s;
            (0, e.warn)(`getPathGenerator - ignoring character: "${s}".`);
          }
          if (!Array.isArray(W) || W.length === 0)
            return this.compiledGlyphs[h] = function(s, o) {
            };
          const Z = [];
          for (let s = 0, o = W.length; s < o; )
            switch (W[s++]) {
              case e.FontRenderOps.BEZIER_CURVE_TO:
                {
                  const [F, N, Q, u, i, c] = W.slice(s, s + 6);
                  Z.push((R) => R.bezierCurveTo(F, N, Q, u, i, c)), s += 6;
                }
                break;
              case e.FontRenderOps.MOVE_TO:
                {
                  const [F, N] = W.slice(s, s + 2);
                  Z.push((Q) => Q.moveTo(F, N)), s += 2;
                }
                break;
              case e.FontRenderOps.LINE_TO:
                {
                  const [F, N] = W.slice(s, s + 2);
                  Z.push((Q) => Q.lineTo(F, N)), s += 2;
                }
                break;
              case e.FontRenderOps.QUADRATIC_CURVE_TO:
                {
                  const [F, N, Q, u] = W.slice(s, s + 4);
                  Z.push((i) => i.quadraticCurveTo(F, N, Q, u)), s += 4;
                }
                break;
              case e.FontRenderOps.RESTORE:
                Z.push((F) => F.restore());
                break;
              case e.FontRenderOps.SAVE:
                Z.push((F) => F.save());
                break;
              case e.FontRenderOps.SCALE:
                (0, e.assert)(Z.length === 2, "Scale command is only valid at the third position.");
                break;
              case e.FontRenderOps.TRANSFORM:
                {
                  const [F, N, Q, u, i, c] = W.slice(s, s + 6);
                  Z.push((R) => R.transform(F, N, Q, u, i, c)), s += 6;
                }
                break;
              case e.FontRenderOps.TRANSLATE:
                {
                  const [F, N] = W.slice(s, s + 2);
                  Z.push((Q) => Q.translate(F, N)), s += 2;
                }
                break;
            }
          return this.compiledGlyphs[h] = function(o, F) {
            Z[0](o), Z[1](o), o.scale(F, -F);
            for (let N = 2, Q = Z.length; N < Q; N++)
              Z[N](o);
          };
        }
      }
    }
  ),
  /***/
  62: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        Metadata: () => (
          /* binding */
          d
        )
        /* harmony export */
      });
      var e = n(292);
      class d {
        #l;
        #t;
        constructor({
          parsedData: U,
          rawData: V
        }) {
          this.#l = U, this.#t = V;
        }
        getRaw() {
          return this.#t;
        }
        get(U) {
          return this.#l.get(U) ?? null;
        }
        getAll() {
          return (0, e.objectFromMap)(this.#l);
        }
        has(U) {
          return this.#l.has(U);
        }
      }
    }
  ),
  /***/
  457: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        PDFNetworkStream: () => (
          /* binding */
          W
        )
        /* harmony export */
      });
      var e = n(292), d = n(490);
      const a = 200, U = 206;
      function V(o) {
        const F = o.response;
        return typeof F != "string" ? F : (0, e.stringToBytes)(F).buffer;
      }
      class h {
        constructor(F, N = {}) {
          this.url = F, this.isHttp = /^https?:/i.test(F), this.httpHeaders = this.isHttp && N.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = N.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
        }
        requestRange(F, N, Q) {
          const u = {
            begin: F,
            end: N
          };
          for (const i in Q)
            u[i] = Q[i];
          return this.request(u);
        }
        requestFull(F) {
          return this.request(F);
        }
        request(F) {
          const N = new XMLHttpRequest(), Q = this.currXhrId++, u = this.pendingRequests[Q] = {
            xhr: N
          };
          N.open("GET", this.url), N.withCredentials = this.withCredentials;
          for (const i in this.httpHeaders) {
            const c = this.httpHeaders[i];
            c !== void 0 && N.setRequestHeader(i, c);
          }
          return this.isHttp && "begin" in F && "end" in F ? (N.setRequestHeader("Range", `bytes=${F.begin}-${F.end - 1}`), u.expectedStatus = U) : u.expectedStatus = a, N.responseType = "arraybuffer", F.onError && (N.onerror = function(i) {
            F.onError(N.status);
          }), N.onreadystatechange = this.onStateChange.bind(this, Q), N.onprogress = this.onProgress.bind(this, Q), u.onHeadersReceived = F.onHeadersReceived, u.onDone = F.onDone, u.onError = F.onError, u.onProgress = F.onProgress, N.send(null), Q;
        }
        onProgress(F, N) {
          const Q = this.pendingRequests[F];
          Q && Q.onProgress?.(N);
        }
        onStateChange(F, N) {
          const Q = this.pendingRequests[F];
          if (!Q)
            return;
          const u = Q.xhr;
          if (u.readyState >= 2 && Q.onHeadersReceived && (Q.onHeadersReceived(), delete Q.onHeadersReceived), u.readyState !== 4 || !(F in this.pendingRequests))
            return;
          if (delete this.pendingRequests[F], u.status === 0 && this.isHttp) {
            Q.onError?.(u.status);
            return;
          }
          const i = u.status || a;
          if (!(i === a && Q.expectedStatus === U) && i !== Q.expectedStatus) {
            Q.onError?.(u.status);
            return;
          }
          const R = V(u);
          if (i === U) {
            const m = u.getResponseHeader("Content-Range"), M = /bytes (\d+)-(\d+)\/(\d+)/.exec(m);
            Q.onDone({
              begin: parseInt(M[1], 10),
              chunk: R
            });
          } else
            R ? Q.onDone({
              begin: 0,
              chunk: R
            }) : Q.onError?.(u.status);
        }
        getRequestXhr(F) {
          return this.pendingRequests[F].xhr;
        }
        isPendingRequest(F) {
          return F in this.pendingRequests;
        }
        abortRequest(F) {
          const N = this.pendingRequests[F].xhr;
          delete this.pendingRequests[F], N.abort();
        }
      }
      class W {
        constructor(F) {
          this._source = F, this._manager = new h(F.url, {
            httpHeaders: F.httpHeaders,
            withCredentials: F.withCredentials
          }), this._rangeChunkSize = F.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
        }
        _onRangeRequestReaderClosed(F) {
          const N = this._rangeRequestReaders.indexOf(F);
          N >= 0 && this._rangeRequestReaders.splice(N, 1);
        }
        getFullReader() {
          return (0, e.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new Z(this._manager, this._source), this._fullRequestReader;
        }
        getRangeReader(F, N) {
          const Q = new s(this._manager, F, N);
          return Q.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(Q), Q;
        }
        cancelAllRequests(F) {
          this._fullRequestReader?.cancel(F);
          for (const N of this._rangeRequestReaders.slice(0))
            N.cancel(F);
        }
      }
      class Z {
        constructor(F, N) {
          this._manager = F;
          const Q = {
            onHeadersReceived: this._onHeadersReceived.bind(this),
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
          };
          this._url = N.url, this._fullRequestId = F.requestFull(Q), this._headersReceivedCapability = Promise.withResolvers(), this._disableRange = N.disableRange || !1, this._contentLength = N.length, this._rangeChunkSize = N.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
        }
        _onHeadersReceived() {
          const F = this._fullRequestId, N = this._manager.getRequestXhr(F), Q = (c) => N.getResponseHeader(c), {
            allowRangeRequests: u,
            suggestedLength: i
          } = (0, d.validateRangeRequestCapabilities)({
            getResponseHeader: Q,
            isHttp: this._manager.isHttp,
            rangeChunkSize: this._rangeChunkSize,
            disableRange: this._disableRange
          });
          u && (this._isRangeSupported = !0), this._contentLength = i || this._contentLength, this._filename = (0, d.extractFilenameFromHeader)(Q), this._isRangeSupported && this._manager.abortRequest(F), this._headersReceivedCapability.resolve();
        }
        _onDone(F) {
          if (F && (this._requests.length > 0 ? this._requests.shift().resolve({
            value: F.chunk,
            done: !1
          }) : this._cachedChunks.push(F.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
            for (const N of this._requests)
              N.resolve({
                value: void 0,
                done: !0
              });
            this._requests.length = 0;
          }
        }
        _onError(F) {
          this._storedError = (0, d.createResponseStatusError)(F, this._url), this._headersReceivedCapability.reject(this._storedError);
          for (const N of this._requests)
            N.reject(this._storedError);
          this._requests.length = 0, this._cachedChunks.length = 0;
        }
        _onProgress(F) {
          this.onProgress?.({
            loaded: F.loaded,
            total: F.lengthComputable ? F.total : this._contentLength
          });
        }
        get filename() {
          return this._filename;
        }
        get isRangeSupported() {
          return this._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._isStreamingSupported;
        }
        get contentLength() {
          return this._contentLength;
        }
        get headersReady() {
          return this._headersReceivedCapability.promise;
        }
        async read() {
          if (this._storedError)
            throw this._storedError;
          if (this._cachedChunks.length > 0)
            return {
              value: this._cachedChunks.shift(),
              done: !1
            };
          if (this._done)
            return {
              value: void 0,
              done: !0
            };
          const F = Promise.withResolvers();
          return this._requests.push(F), F.promise;
        }
        cancel(F) {
          this._done = !0, this._headersReceivedCapability.reject(F);
          for (const N of this._requests)
            N.resolve({
              value: void 0,
              done: !0
            });
          this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
        }
      }
      class s {
        constructor(F, N, Q) {
          this._manager = F;
          const u = {
            onDone: this._onDone.bind(this),
            onError: this._onError.bind(this),
            onProgress: this._onProgress.bind(this)
          };
          this._url = F.url, this._requestId = F.requestRange(N, Q, u), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
        }
        _close() {
          this.onClosed?.(this);
        }
        _onDone(F) {
          const N = F.chunk;
          this._requests.length > 0 ? this._requests.shift().resolve({
            value: N,
            done: !1
          }) : this._queuedChunk = N, this._done = !0;
          for (const Q of this._requests)
            Q.resolve({
              value: void 0,
              done: !0
            });
          this._requests.length = 0, this._close();
        }
        _onError(F) {
          this._storedError = (0, d.createResponseStatusError)(F, this._url);
          for (const N of this._requests)
            N.reject(this._storedError);
          this._requests.length = 0, this._queuedChunk = null;
        }
        _onProgress(F) {
          this.isStreamingSupported || this.onProgress?.({
            loaded: F.loaded
          });
        }
        get isStreamingSupported() {
          return !1;
        }
        async read() {
          if (this._storedError)
            throw this._storedError;
          if (this._queuedChunk !== null) {
            const N = this._queuedChunk;
            return this._queuedChunk = null, {
              value: N,
              done: !1
            };
          }
          if (this._done)
            return {
              value: void 0,
              done: !0
            };
          const F = Promise.withResolvers();
          return this._requests.push(F), F.promise;
        }
        cancel(F) {
          this._done = !0;
          for (const N of this._requests)
            N.resolve({
              value: void 0,
              done: !0
            });
          this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
        }
      }
    }
  ),
  /***/
  490: (
    /***/
    (l, t, n) => {
      n.d(t, {
        createResponseStatusError: () => (
          /* binding */
          h
        ),
        extractFilenameFromHeader: () => (
          /* binding */
          V
        ),
        validateRangeRequestCapabilities: () => (
          /* binding */
          U
        ),
        validateResponseStatus: () => (
          /* binding */
          W
        )
      });
      var e = n(292);
      function d(Z) {
        let s = !0, o = F("filename\\*", "i").exec(Z);
        if (o) {
          o = o[1];
          let m = i(o);
          return m = unescape(m), m = c(m), m = R(m), Q(m);
        }
        if (o = u(Z), o) {
          const m = R(o);
          return Q(m);
        }
        if (o = F("filename", "i").exec(Z), o) {
          o = o[1];
          let m = i(o);
          return m = R(m), Q(m);
        }
        function F(m, M) {
          return new RegExp("(?:^|;)\\s*" + m + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', M);
        }
        function N(m, M) {
          if (m) {
            if (!/^[\x00-\xFF]+$/.test(M))
              return M;
            try {
              const S = new TextDecoder(m, {
                fatal: !0
              }), p = (0, e.stringToBytes)(M);
              M = S.decode(p), s = !1;
            } catch {
            }
          }
          return M;
        }
        function Q(m) {
          return s && /[\x80-\xff]/.test(m) && (m = N("utf-8", m), s && (m = N("iso-8859-1", m))), m;
        }
        function u(m) {
          const M = [];
          let S;
          const p = F("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
          for (; (S = p.exec(m)) !== null; ) {
            let [, k, L, z] = S;
            if (k = parseInt(k, 10), k in M) {
              if (k === 0)
                break;
              continue;
            }
            M[k] = [L, z];
          }
          const Y = [];
          for (let k = 0; k < M.length && k in M; ++k) {
            let [L, z] = M[k];
            z = i(z), L && (z = unescape(z), k === 0 && (z = c(z))), Y.push(z);
          }
          return Y.join("");
        }
        function i(m) {
          if (m.startsWith('"')) {
            const M = m.slice(1).split('\\"');
            for (let S = 0; S < M.length; ++S) {
              const p = M[S].indexOf('"');
              p !== -1 && (M[S] = M[S].slice(0, p), M.length = S + 1), M[S] = M[S].replaceAll(/\\(.)/g, "$1");
            }
            m = M.join('"');
          }
          return m;
        }
        function c(m) {
          const M = m.indexOf("'");
          if (M === -1)
            return m;
          const S = m.slice(0, M), Y = m.slice(M + 1).replace(/^[^']*'/, "");
          return N(S, Y);
        }
        function R(m) {
          return !m.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(m) ? m : m.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(M, S, p, Y) {
            if (p === "q" || p === "Q")
              return Y = Y.replaceAll("_", " "), Y = Y.replaceAll(/=([0-9a-fA-F]{2})/g, function(k, L) {
                return String.fromCharCode(parseInt(L, 16));
              }), N(S, Y);
            try {
              Y = atob(Y);
            } catch {
            }
            return N(S, Y);
          });
        }
        return "";
      }
      var a = n(419);
      function U({
        getResponseHeader: Z,
        isHttp: s,
        rangeChunkSize: o,
        disableRange: F
      }) {
        const N = {
          allowRangeRequests: !1,
          suggestedLength: void 0
        }, Q = parseInt(Z("Content-Length"), 10);
        return !Number.isInteger(Q) || (N.suggestedLength = Q, Q <= 2 * o) || F || !s || Z("Accept-Ranges") !== "bytes" || (Z("Content-Encoding") || "identity") !== "identity" || (N.allowRangeRequests = !0), N;
      }
      function V(Z) {
        const s = Z("Content-Disposition");
        if (s) {
          let o = d(s);
          if (o.includes("%"))
            try {
              o = decodeURIComponent(o);
            } catch {
            }
          if ((0, a.isPdfFile)(o))
            return o;
        }
        return null;
      }
      function h(Z, s) {
        return Z === 404 || Z === 0 && s.startsWith("file:") ? new e.MissingPDFException('Missing PDF "' + s + '".') : new e.UnexpectedResponseException(`Unexpected server response (${Z}) while retrieving PDF "${s}".`, Z);
      }
      function W(Z) {
        return Z === 200 || Z === 206;
      }
    }
  ),
  /***/
  786: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          let o = function(M) {
            const S = Z.parse(M);
            return S.protocol === "file:" || S.host ? S : /^[a-z]:[/\\]/i.test(M) ? Z.parse(`file:///${M}`) : (S.host || (S.protocol = "file:"), S);
          }, u = function(M, S) {
            return {
              protocol: M.protocol,
              auth: M.auth,
              host: M.hostname,
              port: M.port,
              path: M.path,
              method: "GET",
              headers: S
            };
          };
          n.d(t, {
            /* harmony export */
            PDFNodeStream: () => (
              /* binding */
              F
            )
            /* harmony export */
          });
          var a = n(292), U = n(490);
          let V, h, W, Z;
          a.isNodeJS && (V = await import(
            /*webpackIgnore: true*/
            "./__vite-browser-external-DYxpcVy9.js"
          ), h = await import(
            /*webpackIgnore: true*/
            "./__vite-browser-external-DYxpcVy9.js"
          ), W = await import(
            /*webpackIgnore: true*/
            "./__vite-browser-external-DYxpcVy9.js"
          ), Z = await import(
            /*webpackIgnore: true*/
            "./__vite-browser-external-DYxpcVy9.js"
          ));
          const s = /^file:\/\/\/[a-zA-Z]:\//;
          class F {
            constructor(S) {
              this.source = S, this.url = o(S.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && S.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              return this._fullRequestReader?._loaded ?? 0;
            }
            getFullReader() {
              return (0, a.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new R(this) : new i(this), this._fullRequestReader;
            }
            getRangeReader(S, p) {
              if (p <= this._progressiveDataLength)
                return null;
              const Y = this.isFsUrl ? new m(this, S, p) : new c(this, S, p);
              return this._rangeRequestReaders.push(Y), Y;
            }
            cancelAllRequests(S) {
              this._fullRequestReader?.cancel(S);
              for (const p of this._rangeRequestReaders.slice(0))
                p.cancel(S);
            }
          }
          class N {
            constructor(S) {
              this._url = S.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const p = S.source;
              this._contentLength = p.length, this._loaded = 0, this._filename = null, this._disableRange = p.disableRange || !1, this._rangeChunkSize = p.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !p.disableStream, this._isRangeSupported = !p.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const S = this._readableStream.read();
              return S === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += S.length, this.onProgress?.({
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(S).buffer,
                done: !1
              });
            }
            cancel(S) {
              if (!this._readableStream) {
                this._error(S);
                return;
              }
              this._readableStream.destroy(S);
            }
            _error(S) {
              this._storedError = S, this._readCapability.resolve();
            }
            _setReadableStream(S) {
              this._readableStream = S, S.on("readable", () => {
                this._readCapability.resolve();
              }), S.on("end", () => {
                S.destroy(), this._done = !0, this._readCapability.resolve();
              }), S.on("error", (p) => {
                this._error(p);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new a.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class Q {
            constructor(S) {
              this._url = S.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
              const p = S.source;
              this._isStreamingSupported = !p.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const S = this._readableStream.read();
              return S === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += S.length, this.onProgress?.({
                loaded: this._loaded
              }), {
                value: new Uint8Array(S).buffer,
                done: !1
              });
            }
            cancel(S) {
              if (!this._readableStream) {
                this._error(S);
                return;
              }
              this._readableStream.destroy(S);
            }
            _error(S) {
              this._storedError = S, this._readCapability.resolve();
            }
            _setReadableStream(S) {
              this._readableStream = S, S.on("readable", () => {
                this._readCapability.resolve();
              }), S.on("end", () => {
                S.destroy(), this._done = !0, this._readCapability.resolve();
              }), S.on("error", (p) => {
                this._error(p);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class i extends N {
            constructor(S) {
              super(S);
              const p = (Y) => {
                if (Y.statusCode === 404) {
                  const f = new a.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = f, this._headersCapability.reject(f);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(Y);
                const k = (f) => this._readableStream.headers[f.toLowerCase()], {
                  allowRangeRequests: L,
                  suggestedLength: z
                } = (0, U.validateRangeRequestCapabilities)({
                  getResponseHeader: k,
                  isHttp: S.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = L, this._contentLength = z || this._contentLength, this._filename = (0, U.extractFilenameFromHeader)(k);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = h.request(u(this._url, S.httpHeaders), p) : this._request = W.request(u(this._url, S.httpHeaders), p), this._request.on("error", (Y) => {
                this._storedError = Y, this._headersCapability.reject(Y);
              }), this._request.end();
            }
          }
          class c extends Q {
            constructor(S, p, Y) {
              super(S), this._httpHeaders = {};
              for (const L in S.httpHeaders) {
                const z = S.httpHeaders[L];
                z !== void 0 && (this._httpHeaders[L] = z);
              }
              this._httpHeaders.Range = `bytes=${p}-${Y - 1}`;
              const k = (L) => {
                if (L.statusCode === 404) {
                  const z = new a.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = z;
                  return;
                }
                this._setReadableStream(L);
              };
              this._request = null, this._url.protocol === "http:" ? this._request = h.request(u(this._url, this._httpHeaders), k) : this._request = W.request(u(this._url, this._httpHeaders), k), this._request.on("error", (L) => {
                this._storedError = L;
              }), this._request.end();
            }
          }
          class R extends N {
            constructor(S) {
              super(S);
              let p = decodeURIComponent(this._url.path);
              s.test(this._url.href) && (p = p.replace(/^\//, "")), V.promises.lstat(p).then((Y) => {
                this._contentLength = Y.size, this._setReadableStream(V.createReadStream(p)), this._headersCapability.resolve();
              }, (Y) => {
                Y.code === "ENOENT" && (Y = new a.MissingPDFException(`Missing PDF "${p}".`)), this._storedError = Y, this._headersCapability.reject(Y);
              });
            }
          }
          class m extends Q {
            constructor(S, p, Y) {
              super(S);
              let k = decodeURIComponent(this._url.path);
              s.test(this._url.href) && (k = k.replace(/^\//, "")), this._setReadableStream(V.createReadStream(k, {
                start: p,
                end: Y - 1
              }));
            }
          }
          d();
        } catch (V) {
          d(V);
        }
      }, 1);
    }
  ),
  /***/
  573: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            NodeCMapReaderFactory: () => (
              /* binding */
              F
            ),
            /* harmony export */
            NodeCanvasFactory: () => (
              /* binding */
              o
            ),
            /* harmony export */
            NodeFilterFactory: () => (
              /* binding */
              s
            ),
            /* harmony export */
            NodeStandardFontDataFactory: () => (
              /* binding */
              N
            )
            /* harmony export */
          });
          var a = n(583), U = n(292);
          let V, h, W;
          if (U.isNodeJS) {
            V = await import(
              /*webpackIgnore: true*/
              "./__vite-browser-external-DYxpcVy9.js"
            );
            try {
              h = await import(
                /*webpackIgnore: true*/
                "./__vite-browser-external-DYxpcVy9.js"
              );
            } catch {
            }
            try {
              W = await import(
                /*webpackIgnore: true*/
                "./index-V38oYatP.js"
              );
            } catch {
            }
          }
          const Z = function(Q) {
            return V.promises.readFile(Q).then((u) => new Uint8Array(u));
          };
          class s extends a.BaseFilterFactory {
          }
          class o extends a.BaseCanvasFactory {
            _createCanvas(u, i) {
              return h.createCanvas(u, i);
            }
          }
          class F extends a.BaseCMapReaderFactory {
            _fetchData(u, i) {
              return Z(u).then((c) => ({
                cMapData: c,
                compressionType: i
              }));
            }
          }
          class N extends a.BaseStandardFontDataFactory {
            _fetchData(u) {
              return Z(u);
            }
          }
          d();
        } catch (V) {
          d(V);
        }
      }, 1);
    }
  ),
  /***/
  626: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        OptionalContentConfig: () => (
          /* binding */
          V
        )
        /* harmony export */
      });
      var e = n(292), d = n(651);
      const a = Symbol("INTERNAL");
      class U {
        #l = !1;
        #t = !1;
        #n = !1;
        #d = !0;
        constructor(W, {
          name: Z,
          intent: s,
          usage: o
        }) {
          this.#l = !!(W & e.RenderingIntentFlag.DISPLAY), this.#t = !!(W & e.RenderingIntentFlag.PRINT), this.name = Z, this.intent = s, this.usage = o;
        }
        get visible() {
          if (this.#n)
            return this.#d;
          if (!this.#d)
            return !1;
          const {
            print: W,
            view: Z
          } = this.usage;
          return this.#l ? Z?.viewState !== "OFF" : this.#t ? W?.printState !== "OFF" : !0;
        }
        _setVisible(W, Z, s = !1) {
          W !== a && (0, e.unreachable)("Internal method `_setVisible` called."), this.#n = s, this.#d = Z;
        }
      }
      class V {
        #l = null;
        #t = /* @__PURE__ */ new Map();
        #n = null;
        #d = null;
        constructor(W, Z = e.RenderingIntentFlag.DISPLAY) {
          if (this.renderingIntent = Z, this.name = null, this.creator = null, W !== null) {
            this.name = W.name, this.creator = W.creator, this.#d = W.order;
            for (const s of W.groups)
              this.#t.set(s.id, new U(Z, s));
            if (W.baseState === "OFF")
              for (const s of this.#t.values())
                s._setVisible(a, !1);
            for (const s of W.on)
              this.#t.get(s)._setVisible(a, !0);
            for (const s of W.off)
              this.#t.get(s)._setVisible(a, !1);
            this.#n = this.getHash();
          }
        }
        #a(W) {
          const Z = W.length;
          if (Z < 2)
            return !0;
          const s = W[0];
          for (let o = 1; o < Z; o++) {
            const F = W[o];
            let N;
            if (Array.isArray(F))
              N = this.#a(F);
            else if (this.#t.has(F))
              N = this.#t.get(F).visible;
            else
              return (0, e.warn)(`Optional content group not found: ${F}`), !0;
            switch (s) {
              case "And":
                if (!N)
                  return !1;
                break;
              case "Or":
                if (N)
                  return !0;
                break;
              case "Not":
                return !N;
              default:
                return !0;
            }
          }
          return s === "And";
        }
        isVisible(W) {
          if (this.#t.size === 0)
            return !0;
          if (!W)
            return (0, e.info)("Optional content group not defined."), !0;
          if (W.type === "OCG")
            return this.#t.has(W.id) ? this.#t.get(W.id).visible : ((0, e.warn)(`Optional content group not found: ${W.id}`), !0);
          if (W.type === "OCMD") {
            if (W.expression)
              return this.#a(W.expression);
            if (!W.policy || W.policy === "AnyOn") {
              for (const Z of W.ids) {
                if (!this.#t.has(Z))
                  return (0, e.warn)(`Optional content group not found: ${Z}`), !0;
                if (this.#t.get(Z).visible)
                  return !0;
              }
              return !1;
            } else if (W.policy === "AllOn") {
              for (const Z of W.ids) {
                if (!this.#t.has(Z))
                  return (0, e.warn)(`Optional content group not found: ${Z}`), !0;
                if (!this.#t.get(Z).visible)
                  return !1;
              }
              return !0;
            } else if (W.policy === "AnyOff") {
              for (const Z of W.ids) {
                if (!this.#t.has(Z))
                  return (0, e.warn)(`Optional content group not found: ${Z}`), !0;
                if (!this.#t.get(Z).visible)
                  return !0;
              }
              return !1;
            } else if (W.policy === "AllOff") {
              for (const Z of W.ids) {
                if (!this.#t.has(Z))
                  return (0, e.warn)(`Optional content group not found: ${Z}`), !0;
                if (this.#t.get(Z).visible)
                  return !1;
              }
              return !0;
            }
            return (0, e.warn)(`Unknown optional content policy ${W.policy}.`), !0;
          }
          return (0, e.warn)(`Unknown group type ${W.type}.`), !0;
        }
        setVisibility(W, Z = !0) {
          const s = this.#t.get(W);
          if (!s) {
            (0, e.warn)(`Optional content group not found: ${W}`);
            return;
          }
          s._setVisible(a, !!Z, !0), this.#l = null;
        }
        setOCGState({
          state: W,
          preserveRB: Z
        }) {
          let s;
          for (const o of W) {
            switch (o) {
              case "ON":
              case "OFF":
              case "Toggle":
                s = o;
                continue;
            }
            const F = this.#t.get(o);
            if (F)
              switch (s) {
                case "ON":
                  F._setVisible(a, !0);
                  break;
                case "OFF":
                  F._setVisible(a, !1);
                  break;
                case "Toggle":
                  F._setVisible(a, !F.visible);
                  break;
              }
          }
          this.#l = null;
        }
        get hasInitialVisibility() {
          return this.#n === null || this.getHash() === this.#n;
        }
        getOrder() {
          return this.#t.size ? this.#d ? this.#d.slice() : [...this.#t.keys()] : null;
        }
        getGroups() {
          return this.#t.size > 0 ? (0, e.objectFromMap)(this.#t) : null;
        }
        getGroup(W) {
          return this.#t.get(W) || null;
        }
        getHash() {
          if (this.#l !== null)
            return this.#l;
          const W = new d.MurmurHash3_64();
          for (const [Z, s] of this.#t)
            W.update(`${Z}:${s.visible}`);
          return this.#l = W.hexdigest();
        }
      }
    }
  ),
  /***/
  814: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        cleanupTextLayer: () => (
          /* binding */
          s
        ),
        /* harmony export */
        renderTextLayer: () => (
          /* binding */
          i
        ),
        /* harmony export */
        updateTextLayer: () => (
          /* binding */
          c
        )
        /* harmony export */
      });
      var e = n(292), d = n(419);
      const a = 1e5, U = 30, V = 0.8, h = /* @__PURE__ */ new Map();
      let W = null;
      function Z() {
        if (!W) {
          const R = document.createElement("canvas");
          R.className = "hiddenCanvasElement", document.body.append(R), W = R.getContext("2d", {
            alpha: !1
          });
        }
        return W;
      }
      function s() {
        W?.canvas.remove(), W = null;
      }
      function o(R) {
        const m = h.get(R);
        if (m)
          return m;
        const M = Z(), S = M.font;
        M.canvas.width = M.canvas.height = U, M.font = `${U}px ${R}`;
        const p = M.measureText("");
        let Y = p.fontBoundingBoxAscent, k = Math.abs(p.fontBoundingBoxDescent);
        if (Y) {
          const z = Y / (Y + k);
          return h.set(R, z), M.canvas.width = M.canvas.height = 0, M.font = S, z;
        }
        M.strokeStyle = "red", M.clearRect(0, 0, U, U), M.strokeText("g", 0, 0);
        let L = M.getImageData(0, 0, U, U).data;
        k = 0;
        for (let z = L.length - 1 - 3; z >= 0; z -= 4)
          if (L[z] > 0) {
            k = Math.ceil(z / 4 / U);
            break;
          }
        M.clearRect(0, 0, U, U), M.strokeText("A", 0, U), L = M.getImageData(0, 0, U, U).data, Y = 0;
        for (let z = 0, f = L.length; z < f; z += 4)
          if (L[z] > 0) {
            Y = U - Math.floor(z / 4 / U);
            break;
          }
        if (M.canvas.width = M.canvas.height = 0, M.font = S, Y) {
          const z = Y / (Y + k);
          return h.set(R, z), z;
        }
        return h.set(R, V), V;
      }
      function F(R, m, M) {
        const S = document.createElement("span"), p = {
          angle: 0,
          canvasWidth: 0,
          hasText: m.str !== "",
          hasEOL: m.hasEOL,
          fontSize: 0
        };
        R._textDivs.push(S);
        const Y = e.Util.transform(R._transform, m.transform);
        let k = Math.atan2(Y[1], Y[0]);
        const L = M[m.fontName];
        L.vertical && (k += Math.PI / 2);
        const z = R._fontInspectorEnabled && L.fontSubstitution || L.fontFamily, f = Math.hypot(Y[2], Y[3]), K = f * o(z);
        let P, w;
        k === 0 ? (P = Y[4], w = Y[5] - K) : (P = Y[4] + K * Math.sin(k), w = Y[5] - K * Math.cos(k));
        const O = "calc(var(--scale-factor)*", el = S.style;
        R._container === R._rootContainer ? (el.left = `${(100 * P / R._pageWidth).toFixed(2)}%`, el.top = `${(100 * w / R._pageHeight).toFixed(2)}%`) : (el.left = `${O}${P.toFixed(2)}px)`, el.top = `${O}${w.toFixed(2)}px)`), el.fontSize = `${O}${f.toFixed(2)}px)`, el.fontFamily = z, p.fontSize = f, S.setAttribute("role", "presentation"), S.textContent = m.str, S.dir = m.dir, R._fontInspectorEnabled && (S.dataset.fontName = L.fontSubstitutionLoadedName || m.fontName), k !== 0 && (p.angle = k * (180 / Math.PI));
        let ll = !1;
        if (m.str.length > 1)
          ll = !0;
        else if (m.str !== " " && m.transform[0] !== m.transform[3]) {
          const q = Math.abs(m.transform[0]), _ = Math.abs(m.transform[3]);
          q !== _ && Math.max(q, _) / Math.min(q, _) > 1.5 && (ll = !0);
        }
        ll && (p.canvasWidth = L.vertical ? m.height : m.width), R._textDivProperties.set(S, p), R._isReadableStream && R._layoutText(S);
      }
      function N(R) {
        const {
          div: m,
          scale: M,
          properties: S,
          ctx: p,
          prevFontSize: Y,
          prevFontFamily: k
        } = R, {
          style: L
        } = m;
        let z = "";
        if (S.canvasWidth !== 0 && S.hasText) {
          const {
            fontFamily: f
          } = L, {
            canvasWidth: K,
            fontSize: P
          } = S;
          (Y !== P || k !== f) && (p.font = `${P * M}px ${f}`, R.prevFontSize = P, R.prevFontFamily = f);
          const {
            width: w
          } = p.measureText(m.textContent);
          w > 0 && (z = `scaleX(${K * M / w})`);
        }
        S.angle !== 0 && (z = `rotate(${S.angle}deg) ${z}`), z.length > 0 && (L.transform = z);
      }
      function Q(R) {
        if (R._canceled)
          return;
        const m = R._textDivs, M = R._capability;
        if (m.length > a) {
          M.resolve();
          return;
        }
        if (!R._isReadableStream)
          for (const p of m)
            R._layoutText(p);
        M.resolve();
      }
      class u {
        constructor({
          textContentSource: m,
          container: M,
          viewport: S,
          textDivs: p,
          textDivProperties: Y,
          textContentItemsStr: k
        }) {
          this._textContentSource = m, this._isReadableStream = m instanceof ReadableStream, this._container = this._rootContainer = M, this._textDivs = p || [], this._textContentItemsStr = k || [], this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled, this._reader = null, this._textDivProperties = Y || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = Promise.withResolvers(), this._layoutTextParams = {
            prevFontSize: null,
            prevFontFamily: null,
            div: null,
            scale: S.scale * (globalThis.devicePixelRatio || 1),
            properties: null,
            ctx: Z()
          };
          const {
            pageWidth: L,
            pageHeight: z,
            pageX: f,
            pageY: K
          } = S.rawDims;
          this._transform = [1, 0, 0, -1, -f, K + z], this._pageWidth = L, this._pageHeight = z, (0, d.setLayerDimensions)(M, S), this._capability.promise.finally(() => {
            this._layoutTextParams = null;
          }).catch(() => {
          });
        }
        get promise() {
          return this._capability.promise;
        }
        cancel() {
          this._canceled = !0, this._reader && (this._reader.cancel(new e.AbortException("TextLayer task cancelled.")).catch(() => {
          }), this._reader = null), this._capability.reject(new e.AbortException("TextLayer task cancelled."));
        }
        _processItems(m, M) {
          for (const S of m) {
            if (S.str === void 0) {
              if (S.type === "beginMarkedContentProps" || S.type === "beginMarkedContent") {
                const p = this._container;
                this._container = document.createElement("span"), this._container.classList.add("markedContent"), S.id !== null && this._container.setAttribute("id", `${S.id}`), p.append(this._container);
              } else
                S.type === "endMarkedContent" && (this._container = this._container.parentNode);
              continue;
            }
            this._textContentItemsStr.push(S.str), F(this, S, M);
          }
        }
        _layoutText(m) {
          const M = this._layoutTextParams.properties = this._textDivProperties.get(m);
          if (this._layoutTextParams.div = m, N(this._layoutTextParams), M.hasText && this._container.append(m), M.hasEOL) {
            const S = document.createElement("br");
            S.setAttribute("role", "presentation"), this._container.append(S);
          }
        }
        _render() {
          const {
            promise: m,
            resolve: M,
            reject: S
          } = Promise.withResolvers();
          let p = /* @__PURE__ */ Object.create(null);
          if (this._isReadableStream) {
            const Y = () => {
              this._reader.read().then(({
                value: k,
                done: L
              }) => {
                if (L) {
                  M();
                  return;
                }
                Object.assign(p, k.styles), this._processItems(k.items, p), Y();
              }, S);
            };
            this._reader = this._textContentSource.getReader(), Y();
          } else if (this._textContentSource) {
            const {
              items: Y,
              styles: k
            } = this._textContentSource;
            this._processItems(Y, k), M();
          } else
            throw new Error('No "textContentSource" parameter specified.');
          m.then(() => {
            p = null, Q(this);
          }, this._capability.reject);
        }
      }
      function i(R) {
        const m = new u(R);
        return m._render(), m;
      }
      function c({
        container: R,
        viewport: m,
        textDivs: M,
        textDivProperties: S,
        mustRotate: p = !0,
        mustRescale: Y = !0
      }) {
        if (p && (0, d.setLayerDimensions)(R, {
          rotation: m.rotation
        }), Y) {
          const k = Z(), z = {
            prevFontSize: null,
            prevFontFamily: null,
            div: null,
            scale: m.scale * (globalThis.devicePixelRatio || 1),
            properties: null,
            ctx: k
          };
          for (const f of M)
            z.properties = S.get(f), z.div = f, N(z);
        }
      }
    }
  ),
  /***/
  585: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        PDFDataTransportStream: () => (
          /* binding */
          a
        )
        /* harmony export */
      });
      var e = n(292), d = n(419);
      class a {
        constructor(W, {
          disableRange: Z = !1,
          disableStream: s = !1
        }) {
          (0, e.assert)(W, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
          const {
            length: o,
            initialData: F,
            progressiveDone: N,
            contentDispositionFilename: Q
          } = W;
          if (this._queuedChunks = [], this._progressiveDone = N, this._contentDispositionFilename = Q, F?.length > 0) {
            const u = F instanceof Uint8Array && F.byteLength === F.buffer.byteLength ? F.buffer : new Uint8Array(F).buffer;
            this._queuedChunks.push(u);
          }
          this._pdfDataRangeTransport = W, this._isStreamingSupported = !s, this._isRangeSupported = !Z, this._contentLength = o, this._fullRequestReader = null, this._rangeReaders = [], W.addRangeListener((u, i) => {
            this._onReceiveData({
              begin: u,
              chunk: i
            });
          }), W.addProgressListener((u, i) => {
            this._onProgress({
              loaded: u,
              total: i
            });
          }), W.addProgressiveReadListener((u) => {
            this._onReceiveData({
              chunk: u
            });
          }), W.addProgressiveDoneListener(() => {
            this._onProgressiveDone();
          }), W.transportReady();
        }
        _onReceiveData({
          begin: W,
          chunk: Z
        }) {
          const s = Z instanceof Uint8Array && Z.byteLength === Z.buffer.byteLength ? Z.buffer : new Uint8Array(Z).buffer;
          if (W === void 0)
            this._fullRequestReader ? this._fullRequestReader._enqueue(s) : this._queuedChunks.push(s);
          else {
            const o = this._rangeReaders.some(function(F) {
              return F._begin !== W ? !1 : (F._enqueue(s), !0);
            });
            (0, e.assert)(o, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
          }
        }
        get _progressiveDataLength() {
          return this._fullRequestReader?._loaded ?? 0;
        }
        _onProgress(W) {
          W.total === void 0 ? this._rangeReaders[0]?.onProgress?.({
            loaded: W.loaded
          }) : this._fullRequestReader?.onProgress?.({
            loaded: W.loaded,
            total: W.total
          });
        }
        _onProgressiveDone() {
          this._fullRequestReader?.progressiveDone(), this._progressiveDone = !0;
        }
        _removeRangeReader(W) {
          const Z = this._rangeReaders.indexOf(W);
          Z >= 0 && this._rangeReaders.splice(Z, 1);
        }
        getFullReader() {
          (0, e.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
          const W = this._queuedChunks;
          return this._queuedChunks = null, new U(this, W, this._progressiveDone, this._contentDispositionFilename);
        }
        getRangeReader(W, Z) {
          if (Z <= this._progressiveDataLength)
            return null;
          const s = new V(this, W, Z);
          return this._pdfDataRangeTransport.requestDataRange(W, Z), this._rangeReaders.push(s), s;
        }
        cancelAllRequests(W) {
          this._fullRequestReader?.cancel(W);
          for (const Z of this._rangeReaders.slice(0))
            Z.cancel(W);
          this._pdfDataRangeTransport.abort();
        }
      }
      class U {
        constructor(W, Z, s = !1, o = null) {
          this._stream = W, this._done = s || !1, this._filename = (0, d.isPdfFile)(o) ? o : null, this._queuedChunks = Z || [], this._loaded = 0;
          for (const F of this._queuedChunks)
            this._loaded += F.byteLength;
          this._requests = [], this._headersReady = Promise.resolve(), W._fullRequestReader = this, this.onProgress = null;
        }
        _enqueue(W) {
          this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
            value: W,
            done: !1
          }) : this._queuedChunks.push(W), this._loaded += W.byteLength);
        }
        get headersReady() {
          return this._headersReady;
        }
        get filename() {
          return this._filename;
        }
        get isRangeSupported() {
          return this._stream._isRangeSupported;
        }
        get isStreamingSupported() {
          return this._stream._isStreamingSupported;
        }
        get contentLength() {
          return this._stream._contentLength;
        }
        async read() {
          if (this._queuedChunks.length > 0)
            return {
              value: this._queuedChunks.shift(),
              done: !1
            };
          if (this._done)
            return {
              value: void 0,
              done: !0
            };
          const W = Promise.withResolvers();
          return this._requests.push(W), W.promise;
        }
        cancel(W) {
          this._done = !0;
          for (const Z of this._requests)
            Z.resolve({
              value: void 0,
              done: !0
            });
          this._requests.length = 0;
        }
        progressiveDone() {
          this._done || (this._done = !0);
        }
      }
      class V {
        constructor(W, Z, s) {
          this._stream = W, this._begin = Z, this._end = s, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
        }
        _enqueue(W) {
          if (!this._done) {
            if (this._requests.length === 0)
              this._queuedChunk = W;
            else {
              this._requests.shift().resolve({
                value: W,
                done: !1
              });
              for (const s of this._requests)
                s.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            this._done = !0, this._stream._removeRangeReader(this);
          }
        }
        get isStreamingSupported() {
          return !1;
        }
        async read() {
          if (this._queuedChunk) {
            const Z = this._queuedChunk;
            return this._queuedChunk = null, {
              value: Z,
              done: !1
            };
          }
          if (this._done)
            return {
              value: void 0,
              done: !0
            };
          const W = Promise.withResolvers();
          return this._requests.push(W), W.promise;
        }
        cancel(W) {
          this._done = !0;
          for (const Z of this._requests)
            Z.resolve({
              value: void 0,
              done: !0
            });
          this._requests.length = 0, this._stream._removeRangeReader(this);
        }
      }
    }
  ),
  /***/
  164: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        GlobalWorkerOptions: () => (
          /* binding */
          e
        )
        /* harmony export */
      });
      class e {
        static #l = null;
        static #t = "";
        static get workerPort() {
          return this.#l;
        }
        static set workerPort(a) {
          if (!(typeof Worker < "u" && a instanceof Worker) && a !== null)
            throw new Error("Invalid `workerPort` type.");
          this.#l = a;
        }
        static get workerSrc() {
          return this.#t;
        }
        static set workerSrc(a) {
          if (typeof a != "string")
            throw new Error("Invalid `workerSrc` type.");
          this.#t = a;
        }
      }
    }
  ),
  /***/
  284: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        XfaLayer: () => (
          /* binding */
          d
        )
        /* harmony export */
      });
      var e = n(50);
      class d {
        static setupStorage(U, V, h, W, Z) {
          const s = W.getValue(V, {
            value: null
          });
          switch (h.name) {
            case "textarea":
              if (s.value !== null && (U.textContent = s.value), Z === "print")
                break;
              U.addEventListener("input", (o) => {
                W.setValue(V, {
                  value: o.target.value
                });
              });
              break;
            case "input":
              if (h.attributes.type === "radio" || h.attributes.type === "checkbox") {
                if (s.value === h.attributes.xfaOn ? U.setAttribute("checked", !0) : s.value === h.attributes.xfaOff && U.removeAttribute("checked"), Z === "print")
                  break;
                U.addEventListener("change", (o) => {
                  W.setValue(V, {
                    value: o.target.checked ? o.target.getAttribute("xfaOn") : o.target.getAttribute("xfaOff")
                  });
                });
              } else {
                if (s.value !== null && U.setAttribute("value", s.value), Z === "print")
                  break;
                U.addEventListener("input", (o) => {
                  W.setValue(V, {
                    value: o.target.value
                  });
                });
              }
              break;
            case "select":
              if (s.value !== null) {
                U.setAttribute("value", s.value);
                for (const o of h.children)
                  o.attributes.value === s.value ? o.attributes.selected = !0 : o.attributes.hasOwnProperty("selected") && delete o.attributes.selected;
              }
              U.addEventListener("input", (o) => {
                const F = o.target.options, N = F.selectedIndex === -1 ? "" : F[F.selectedIndex].value;
                W.setValue(V, {
                  value: N
                });
              });
              break;
          }
        }
        static setAttributes({
          html: U,
          element: V,
          storage: h = null,
          intent: W,
          linkService: Z
        }) {
          const {
            attributes: s
          } = V, o = U instanceof HTMLAnchorElement;
          s.type === "radio" && (s.name = `${s.name}-${W}`);
          for (const [F, N] of Object.entries(s))
            if (N != null)
              switch (F) {
                case "class":
                  N.length && U.setAttribute(F, N.join(" "));
                  break;
                case "dataId":
                  break;
                case "id":
                  U.setAttribute("data-element-id", N);
                  break;
                case "style":
                  Object.assign(U.style, N);
                  break;
                case "textContent":
                  U.textContent = N;
                  break;
                default:
                  (!o || F !== "href" && F !== "newWindow") && U.setAttribute(F, N);
              }
          o && Z.addLinkAttributes(U, s.href, s.newWindow), h && s.dataId && this.setupStorage(U, s.dataId, V, h);
        }
        static render(U) {
          const V = U.annotationStorage, h = U.linkService, W = U.xfaHtml, Z = U.intent || "display", s = document.createElement(W.name);
          W.attributes && this.setAttributes({
            html: s,
            element: W,
            intent: Z,
            linkService: h
          });
          const o = Z !== "richText", F = U.div;
          if (F.append(s), U.viewport) {
            const u = `matrix(${U.viewport.transform.join(",")})`;
            F.style.transform = u;
          }
          o && F.setAttribute("class", "xfaLayer xfaFont");
          const N = [];
          if (W.children.length === 0) {
            if (W.value) {
              const u = document.createTextNode(W.value);
              s.append(u), o && e.XfaText.shouldBuildText(W.name) && N.push(u);
            }
            return {
              textDivs: N
            };
          }
          const Q = [[W, -1, s]];
          for (; Q.length > 0; ) {
            const [u, i, c] = Q.at(-1);
            if (i + 1 === u.children.length) {
              Q.pop();
              continue;
            }
            const R = u.children[++Q.at(-1)[1]];
            if (R === null)
              continue;
            const {
              name: m
            } = R;
            if (m === "#text") {
              const S = document.createTextNode(R.value);
              N.push(S), c.append(S);
              continue;
            }
            const M = R?.attributes?.xmlns ? document.createElementNS(R.attributes.xmlns, m) : document.createElement(m);
            if (c.append(M), R.attributes && this.setAttributes({
              html: M,
              element: R,
              storage: V,
              intent: Z,
              linkService: h
            }), R.children?.length > 0)
              Q.push([R, -1, M]);
            else if (R.value) {
              const S = document.createTextNode(R.value);
              o && e.XfaText.shouldBuildText(m) && N.push(S), M.append(S);
            }
          }
          for (const u of F.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
            u.setAttribute("readOnly", !0);
          return {
            textDivs: N
          };
        }
        static update(U) {
          const V = `matrix(${U.viewport.transform.join(",")})`;
          U.div.style.transform = V, U.div.hidden = !1;
        }
      }
    }
  ),
  /***/
  50: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        XfaText: () => (
          /* binding */
          e
        )
        /* harmony export */
      });
      class e {
        static textContent(a) {
          const U = [], V = {
            items: U,
            styles: /* @__PURE__ */ Object.create(null)
          };
          function h(W) {
            if (!W)
              return;
            let Z = null;
            const s = W.name;
            if (s === "#text")
              Z = W.value;
            else if (e.shouldBuildText(s))
              W?.attributes?.textContent ? Z = W.attributes.textContent : W.value && (Z = W.value);
            else
              return;
            if (Z !== null && U.push({
              str: Z
            }), !!W.children)
              for (const o of W.children)
                h(o);
          }
          return h(a), V;
        }
        static shouldBuildText(a) {
          return !(a === "textarea" || a === "input" || a === "option" || a === "select");
        }
      }
    }
  ),
  /***/
  228: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            AbortException: () => (
              /* reexport safe */
              a.AbortException
            ),
            /* harmony export */
            AnnotationEditorLayer: () => (
              /* reexport safe */
              W.AnnotationEditorLayer
            ),
            /* harmony export */
            AnnotationEditorParamsType: () => (
              /* reexport safe */
              a.AnnotationEditorParamsType
            ),
            /* harmony export */
            AnnotationEditorType: () => (
              /* reexport safe */
              a.AnnotationEditorType
            ),
            /* harmony export */
            AnnotationEditorUIManager: () => (
              /* reexport safe */
              Z.AnnotationEditorUIManager
            ),
            /* harmony export */
            AnnotationLayer: () => (
              /* reexport safe */
              s.AnnotationLayer
            ),
            /* harmony export */
            AnnotationMode: () => (
              /* reexport safe */
              a.AnnotationMode
            ),
            /* harmony export */
            CMapCompressionType: () => (
              /* reexport safe */
              a.CMapCompressionType
            ),
            /* harmony export */
            ColorPicker: () => (
              /* reexport safe */
              o.ColorPicker
            ),
            /* harmony export */
            DOMSVGFactory: () => (
              /* reexport safe */
              V.DOMSVGFactory
            ),
            /* harmony export */
            DrawLayer: () => (
              /* reexport safe */
              F.DrawLayer
            ),
            /* harmony export */
            FeatureTest: () => (
              /* reexport safe */
              a.FeatureTest
            ),
            /* harmony export */
            GlobalWorkerOptions: () => (
              /* reexport safe */
              N.GlobalWorkerOptions
            ),
            /* harmony export */
            ImageKind: () => (
              /* reexport safe */
              a.ImageKind
            ),
            /* harmony export */
            InvalidPDFException: () => (
              /* reexport safe */
              a.InvalidPDFException
            ),
            /* harmony export */
            MissingPDFException: () => (
              /* reexport safe */
              a.MissingPDFException
            ),
            /* harmony export */
            OPS: () => (
              /* reexport safe */
              a.OPS
            ),
            /* harmony export */
            Outliner: () => (
              /* reexport safe */
              Q.Outliner
            ),
            /* harmony export */
            PDFDataRangeTransport: () => (
              /* reexport safe */
              U.PDFDataRangeTransport
            ),
            /* harmony export */
            PDFDateString: () => (
              /* reexport safe */
              V.PDFDateString
            ),
            /* harmony export */
            PDFWorker: () => (
              /* reexport safe */
              U.PDFWorker
            ),
            /* harmony export */
            PasswordResponses: () => (
              /* reexport safe */
              a.PasswordResponses
            ),
            /* harmony export */
            PermissionFlag: () => (
              /* reexport safe */
              a.PermissionFlag
            ),
            /* harmony export */
            PixelsPerInch: () => (
              /* reexport safe */
              V.PixelsPerInch
            ),
            /* harmony export */
            RenderingCancelledException: () => (
              /* reexport safe */
              V.RenderingCancelledException
            ),
            /* harmony export */
            UnexpectedResponseException: () => (
              /* reexport safe */
              a.UnexpectedResponseException
            ),
            /* harmony export */
            Util: () => (
              /* reexport safe */
              a.Util
            ),
            /* harmony export */
            VerbosityLevel: () => (
              /* reexport safe */
              a.VerbosityLevel
            ),
            /* harmony export */
            XfaLayer: () => (
              /* reexport safe */
              u.XfaLayer
            ),
            /* harmony export */
            build: () => (
              /* reexport safe */
              U.build
            ),
            /* harmony export */
            createValidAbsoluteUrl: () => (
              /* reexport safe */
              a.createValidAbsoluteUrl
            ),
            /* harmony export */
            fetchData: () => (
              /* reexport safe */
              V.fetchData
            ),
            /* harmony export */
            getDocument: () => (
              /* reexport safe */
              U.getDocument
            ),
            /* harmony export */
            getFilenameFromUrl: () => (
              /* reexport safe */
              V.getFilenameFromUrl
            ),
            /* harmony export */
            getPdfFilenameFromUrl: () => (
              /* reexport safe */
              V.getPdfFilenameFromUrl
            ),
            /* harmony export */
            getXfaPageViewport: () => (
              /* reexport safe */
              V.getXfaPageViewport
            ),
            /* harmony export */
            isDataScheme: () => (
              /* reexport safe */
              V.isDataScheme
            ),
            /* harmony export */
            isPdfFile: () => (
              /* reexport safe */
              V.isPdfFile
            ),
            /* harmony export */
            noContextMenu: () => (
              /* reexport safe */
              V.noContextMenu
            ),
            /* harmony export */
            normalizeUnicode: () => (
              /* reexport safe */
              a.normalizeUnicode
            ),
            /* harmony export */
            renderTextLayer: () => (
              /* reexport safe */
              h.renderTextLayer
            ),
            /* harmony export */
            setLayerDimensions: () => (
              /* reexport safe */
              V.setLayerDimensions
            ),
            /* harmony export */
            shadow: () => (
              /* reexport safe */
              a.shadow
            ),
            /* harmony export */
            updateTextLayer: () => (
              /* reexport safe */
              h.updateTextLayer
            ),
            /* harmony export */
            version: () => (
              /* reexport safe */
              U.version
            )
            /* harmony export */
          });
          var a = n(292), U = n(831), V = n(419), h = n(814), W = n(731), Z = n(830), s = n(976), o = n(259), F = n(47), N = n(164), Q = n(61), u = n(284), i = e([U]);
          U = (i.then ? (await i)() : i)[0];
          const c = "4.2.67", R = "49b388101";
          d();
        } catch (c) {
          d(c);
        }
      });
    }
  ),
  /***/
  178: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        MessageHandler: () => (
          /* binding */
          V
        )
        /* harmony export */
      });
      var e = n(292);
      const d = {
        UNKNOWN: 0,
        DATA: 1,
        ERROR: 2
      }, a = {
        UNKNOWN: 0,
        CANCEL: 1,
        CANCEL_COMPLETE: 2,
        CLOSE: 3,
        ENQUEUE: 4,
        ERROR: 5,
        PULL: 6,
        PULL_COMPLETE: 7,
        START_COMPLETE: 8
      };
      function U(h) {
        switch (h instanceof Error || typeof h == "object" && h !== null || (0, e.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), h.name) {
          case "AbortException":
            return new e.AbortException(h.message);
          case "MissingPDFException":
            return new e.MissingPDFException(h.message);
          case "PasswordException":
            return new e.PasswordException(h.message, h.code);
          case "UnexpectedResponseException":
            return new e.UnexpectedResponseException(h.message, h.status);
          case "UnknownErrorException":
            return new e.UnknownErrorException(h.message, h.details);
          default:
            return new e.UnknownErrorException(h.message, h.toString());
        }
      }
      class V {
        constructor(W, Z, s) {
          this.sourceName = W, this.targetName = Z, this.comObj = s, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (o) => {
            const F = o.data;
            if (F.targetName !== this.sourceName)
              return;
            if (F.stream) {
              this.#t(F);
              return;
            }
            if (F.callback) {
              const Q = F.callbackId, u = this.callbackCapabilities[Q];
              if (!u)
                throw new Error(`Cannot resolve callback ${Q}`);
              if (delete this.callbackCapabilities[Q], F.callback === d.DATA)
                u.resolve(F.data);
              else if (F.callback === d.ERROR)
                u.reject(U(F.reason));
              else
                throw new Error("Unexpected callback case");
              return;
            }
            const N = this.actionHandler[F.action];
            if (!N)
              throw new Error(`Unknown action from worker: ${F.action}`);
            if (F.callbackId) {
              const Q = this.sourceName, u = F.sourceName;
              new Promise(function(i) {
                i(N(F.data));
              }).then(function(i) {
                s.postMessage({
                  sourceName: Q,
                  targetName: u,
                  callback: d.DATA,
                  callbackId: F.callbackId,
                  data: i
                });
              }, function(i) {
                s.postMessage({
                  sourceName: Q,
                  targetName: u,
                  callback: d.ERROR,
                  callbackId: F.callbackId,
                  reason: U(i)
                });
              });
              return;
            }
            if (F.streamId) {
              this.#l(F);
              return;
            }
            N(F.data);
          }, s.addEventListener("message", this._onComObjOnMessage);
        }
        on(W, Z) {
          const s = this.actionHandler;
          if (s[W])
            throw new Error(`There is already an actionName called "${W}"`);
          s[W] = Z;
        }
        send(W, Z, s) {
          this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: W,
            data: Z
          }, s);
        }
        sendWithPromise(W, Z, s) {
          const o = this.callbackId++, F = Promise.withResolvers();
          this.callbackCapabilities[o] = F;
          try {
            this.comObj.postMessage({
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: W,
              callbackId: o,
              data: Z
            }, s);
          } catch (N) {
            F.reject(N);
          }
          return F.promise;
        }
        sendWithStream(W, Z, s, o) {
          const F = this.streamId++, N = this.sourceName, Q = this.targetName, u = this.comObj;
          return new ReadableStream({
            start: (i) => {
              const c = Promise.withResolvers();
              return this.streamControllers[F] = {
                controller: i,
                startCall: c,
                pullCall: null,
                cancelCall: null,
                isClosed: !1
              }, u.postMessage({
                sourceName: N,
                targetName: Q,
                action: W,
                streamId: F,
                data: Z,
                desiredSize: i.desiredSize
              }, o), c.promise;
            },
            pull: (i) => {
              const c = Promise.withResolvers();
              return this.streamControllers[F].pullCall = c, u.postMessage({
                sourceName: N,
                targetName: Q,
                stream: a.PULL,
                streamId: F,
                desiredSize: i.desiredSize
              }), c.promise;
            },
            cancel: (i) => {
              (0, e.assert)(i instanceof Error, "cancel must have a valid reason");
              const c = Promise.withResolvers();
              return this.streamControllers[F].cancelCall = c, this.streamControllers[F].isClosed = !0, u.postMessage({
                sourceName: N,
                targetName: Q,
                stream: a.CANCEL,
                streamId: F,
                reason: U(i)
              }), c.promise;
            }
          }, s);
        }
        #l(W) {
          const Z = W.streamId, s = this.sourceName, o = W.sourceName, F = this.comObj, N = this, Q = this.actionHandler[W.action], u = {
            enqueue(i, c = 1, R) {
              if (this.isCancelled)
                return;
              const m = this.desiredSize;
              this.desiredSize -= c, m > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), F.postMessage({
                sourceName: s,
                targetName: o,
                stream: a.ENQUEUE,
                streamId: Z,
                chunk: i
              }, R);
            },
            close() {
              this.isCancelled || (this.isCancelled = !0, F.postMessage({
                sourceName: s,
                targetName: o,
                stream: a.CLOSE,
                streamId: Z
              }), delete N.streamSinks[Z]);
            },
            error(i) {
              (0, e.assert)(i instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, F.postMessage({
                sourceName: s,
                targetName: o,
                stream: a.ERROR,
                streamId: Z,
                reason: U(i)
              }));
            },
            sinkCapability: Promise.withResolvers(),
            onPull: null,
            onCancel: null,
            isCancelled: !1,
            desiredSize: W.desiredSize,
            ready: null
          };
          u.sinkCapability.resolve(), u.ready = u.sinkCapability.promise, this.streamSinks[Z] = u, new Promise(function(i) {
            i(Q(W.data, u));
          }).then(function() {
            F.postMessage({
              sourceName: s,
              targetName: o,
              stream: a.START_COMPLETE,
              streamId: Z,
              success: !0
            });
          }, function(i) {
            F.postMessage({
              sourceName: s,
              targetName: o,
              stream: a.START_COMPLETE,
              streamId: Z,
              reason: U(i)
            });
          });
        }
        #t(W) {
          const Z = W.streamId, s = this.sourceName, o = W.sourceName, F = this.comObj, N = this.streamControllers[Z], Q = this.streamSinks[Z];
          switch (W.stream) {
            case a.START_COMPLETE:
              W.success ? N.startCall.resolve() : N.startCall.reject(U(W.reason));
              break;
            case a.PULL_COMPLETE:
              W.success ? N.pullCall.resolve() : N.pullCall.reject(U(W.reason));
              break;
            case a.PULL:
              if (!Q) {
                F.postMessage({
                  sourceName: s,
                  targetName: o,
                  stream: a.PULL_COMPLETE,
                  streamId: Z,
                  success: !0
                });
                break;
              }
              Q.desiredSize <= 0 && W.desiredSize > 0 && Q.sinkCapability.resolve(), Q.desiredSize = W.desiredSize, new Promise(function(u) {
                u(Q.onPull?.());
              }).then(function() {
                F.postMessage({
                  sourceName: s,
                  targetName: o,
                  stream: a.PULL_COMPLETE,
                  streamId: Z,
                  success: !0
                });
              }, function(u) {
                F.postMessage({
                  sourceName: s,
                  targetName: o,
                  stream: a.PULL_COMPLETE,
                  streamId: Z,
                  reason: U(u)
                });
              });
              break;
            case a.ENQUEUE:
              if ((0, e.assert)(N, "enqueue should have stream controller"), N.isClosed)
                break;
              N.controller.enqueue(W.chunk);
              break;
            case a.CLOSE:
              if ((0, e.assert)(N, "close should have stream controller"), N.isClosed)
                break;
              N.isClosed = !0, N.controller.close(), this.#n(N, Z);
              break;
            case a.ERROR:
              (0, e.assert)(N, "error should have stream controller"), N.controller.error(U(W.reason)), this.#n(N, Z);
              break;
            case a.CANCEL_COMPLETE:
              W.success ? N.cancelCall.resolve() : N.cancelCall.reject(U(W.reason)), this.#n(N, Z);
              break;
            case a.CANCEL:
              if (!Q)
                break;
              new Promise(function(u) {
                u(Q.onCancel?.(U(W.reason)));
              }).then(function() {
                F.postMessage({
                  sourceName: s,
                  targetName: o,
                  stream: a.CANCEL_COMPLETE,
                  streamId: Z,
                  success: !0
                });
              }, function(u) {
                F.postMessage({
                  sourceName: s,
                  targetName: o,
                  stream: a.CANCEL_COMPLETE,
                  streamId: Z,
                  reason: U(u)
                });
              }), Q.sinkCapability.reject(U(W.reason)), Q.isCancelled = !0, delete this.streamSinks[Z];
              break;
            default:
              throw new Error("Unexpected stream case");
          }
        }
        async #n(W, Z) {
          await Promise.allSettled([W.startCall?.promise, W.pullCall?.promise, W.cancelCall?.promise]), delete this.streamControllers[Z];
        }
        destroy() {
          this.comObj.removeEventListener("message", this._onComObjOnMessage);
        }
      }
    }
  ),
  /***/
  651: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        MurmurHash3_64: () => (
          /* binding */
          U
        )
        /* harmony export */
      });
      const e = 3285377520, d = 4294901760, a = 65535;
      class U {
        constructor(h) {
          this.h1 = h ? h & 4294967295 : e, this.h2 = h ? h & 4294967295 : e;
        }
        update(h) {
          let W, Z;
          if (typeof h == "string") {
            W = new Uint8Array(h.length * 2), Z = 0;
            for (let S = 0, p = h.length; S < p; S++) {
              const Y = h.charCodeAt(S);
              Y <= 255 ? W[Z++] = Y : (W[Z++] = Y >>> 8, W[Z++] = Y & 255);
            }
          } else if (ArrayBuffer.isView(h))
            W = h.slice(), Z = W.byteLength;
          else
            throw new Error("Invalid data format, must be a string or TypedArray.");
          const s = Z >> 2, o = Z - s * 4, F = new Uint32Array(W.buffer, 0, s);
          let N = 0, Q = 0, u = this.h1, i = this.h2;
          const c = 3432918353, R = 461845907, m = c & a, M = R & a;
          for (let S = 0; S < s; S++)
            S & 1 ? (N = F[S], N = N * c & d | N * m & a, N = N << 15 | N >>> 17, N = N * R & d | N * M & a, u ^= N, u = u << 13 | u >>> 19, u = u * 5 + 3864292196) : (Q = F[S], Q = Q * c & d | Q * m & a, Q = Q << 15 | Q >>> 17, Q = Q * R & d | Q * M & a, i ^= Q, i = i << 13 | i >>> 19, i = i * 5 + 3864292196);
          switch (N = 0, o) {
            case 3:
              N ^= W[s * 4 + 2] << 16;
            case 2:
              N ^= W[s * 4 + 1] << 8;
            case 1:
              N ^= W[s * 4], N = N * c & d | N * m & a, N = N << 15 | N >>> 17, N = N * R & d | N * M & a, s & 1 ? u ^= N : i ^= N;
          }
          this.h1 = u, this.h2 = i;
        }
        hexdigest() {
          let h = this.h1, W = this.h2;
          return h ^= W >>> 1, h = h * 3981806797 & d | h * 36045 & a, W = W * 4283543511 & d | ((W << 16 | h >>> 16) * 2950163797 & d) >>> 16, h ^= W >>> 1, h = h * 444984403 & d | h * 60499 & a, W = W * 3301882366 & d | ((W << 16 | h >>> 16) * 3120437893 & d) >>> 16, h ^= W >>> 1, (h >>> 0).toString(16).padStart(8, "0") + (W >>> 0).toString(16).padStart(8, "0");
        }
      }
    }
  ),
  /***/
  292: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        AbortException: () => (
          /* binding */
          tl
        ),
        /* harmony export */
        AnnotationBorderStyleType: () => (
          /* binding */
          i
        ),
        /* harmony export */
        AnnotationEditorParamsType: () => (
          /* binding */
          o
        ),
        /* harmony export */
        AnnotationEditorPrefix: () => (
          /* binding */
          Z
        ),
        /* harmony export */
        AnnotationEditorType: () => (
          /* binding */
          s
        ),
        /* harmony export */
        AnnotationMode: () => (
          /* binding */
          W
        ),
        /* harmony export */
        AnnotationPrefix: () => (
          /* binding */
          v
        ),
        /* harmony export */
        AnnotationType: () => (
          /* binding */
          u
        ),
        /* harmony export */
        BaseException: () => (
          /* binding */
          O
        ),
        /* harmony export */
        CMapCompressionType: () => (
          /* binding */
          R
        ),
        /* harmony export */
        FONT_IDENTITY_MATRIX: () => (
          /* binding */
          a
        ),
        /* harmony export */
        FeatureTest: () => (
          /* binding */
          r
        ),
        /* harmony export */
        FontRenderOps: () => (
          /* binding */
          A
        ),
        /* harmony export */
        FormatError: () => (
          /* binding */
          dl
        ),
        /* harmony export */
        IDENTITY_MATRIX: () => (
          /* binding */
          d
        ),
        /* harmony export */
        ImageKind: () => (
          /* binding */
          Q
        ),
        /* harmony export */
        InvalidPDFException: () => (
          /* binding */
          q
        ),
        /* harmony export */
        LINE_FACTOR: () => (
          /* binding */
          V
        ),
        /* harmony export */
        MAX_IMAGE_SIZE_TO_CACHE: () => (
          /* binding */
          U
        ),
        /* harmony export */
        MissingPDFException: () => (
          /* binding */
          _
        ),
        /* harmony export */
        OPS: () => (
          /* binding */
          m
        ),
        /* harmony export */
        PasswordException: () => (
          /* binding */
          el
        ),
        /* harmony export */
        PasswordResponses: () => (
          /* binding */
          M
        ),
        /* harmony export */
        PermissionFlag: () => (
          /* binding */
          F
        ),
        /* harmony export */
        RenderingIntentFlag: () => (
          /* binding */
          h
        ),
        /* harmony export */
        TextRenderingMode: () => (
          /* binding */
          N
        ),
        /* harmony export */
        UnexpectedResponseException: () => (
          /* binding */
          il
        ),
        /* harmony export */
        UnknownErrorException: () => (
          /* binding */
          ll
        ),
        /* harmony export */
        Util: () => (
          /* binding */
          J
        ),
        /* harmony export */
        VerbosityLevel: () => (
          /* binding */
          c
        ),
        /* harmony export */
        assert: () => (
          /* binding */
          f
        ),
        /* harmony export */
        bytesToString: () => (
          /* binding */
          al
        ),
        /* harmony export */
        createValidAbsoluteUrl: () => (
          /* binding */
          P
        ),
        /* harmony export */
        getUuid: () => (
          /* binding */
          x
        ),
        /* harmony export */
        getVerbosityLevel: () => (
          /* binding */
          Y
        ),
        /* harmony export */
        info: () => (
          /* binding */
          k
        ),
        /* harmony export */
        isNodeJS: () => (
          /* binding */
          e
        ),
        /* harmony export */
        normalizeUnicode: () => (
          /* binding */
          E
        ),
        /* harmony export */
        objectFromMap: () => (
          /* binding */
          B
        ),
        /* harmony export */
        setVerbosityLevel: () => (
          /* binding */
          p
        ),
        /* harmony export */
        shadow: () => (
          /* binding */
          w
        ),
        /* harmony export */
        string32: () => (
          /* binding */
          cl
        ),
        /* harmony export */
        stringToBytes: () => (
          /* binding */
          Ul
        ),
        /* harmony export */
        unreachable: () => (
          /* binding */
          z
        ),
        /* harmony export */
        warn: () => (
          /* binding */
          L
        )
        /* harmony export */
      });
      const e = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), d = [1, 0, 0, 1, 0, 0], a = [1e-3, 0, 0, 1e-3, 0, 0], U = 1e7, V = 1.35, h = {
        ANY: 1,
        DISPLAY: 2,
        PRINT: 4,
        SAVE: 8,
        ANNOTATIONS_FORMS: 16,
        ANNOTATIONS_STORAGE: 32,
        ANNOTATIONS_DISABLE: 64,
        OPLIST: 256
      }, W = {
        DISABLE: 0,
        ENABLE: 1,
        ENABLE_FORMS: 2,
        ENABLE_STORAGE: 3
      }, Z = "pdfjs_internal_editor_", s = {
        DISABLE: -1,
        NONE: 0,
        FREETEXT: 3,
        HIGHLIGHT: 9,
        STAMP: 13,
        INK: 15
      }, o = {
        RESIZE: 1,
        CREATE: 2,
        FREETEXT_SIZE: 11,
        FREETEXT_COLOR: 12,
        FREETEXT_OPACITY: 13,
        INK_COLOR: 21,
        INK_THICKNESS: 22,
        INK_OPACITY: 23,
        HIGHLIGHT_COLOR: 31,
        HIGHLIGHT_DEFAULT_COLOR: 32,
        HIGHLIGHT_THICKNESS: 33,
        HIGHLIGHT_FREE: 34,
        HIGHLIGHT_SHOW_ALL: 35
      }, F = {
        PRINT: 4,
        MODIFY_CONTENTS: 8,
        COPY: 16,
        MODIFY_ANNOTATIONS: 32,
        FILL_INTERACTIVE_FORMS: 256,
        COPY_FOR_ACCESSIBILITY: 512,
        ASSEMBLE: 1024,
        PRINT_HIGH_QUALITY: 2048
      }, N = {
        FILL: 0,
        STROKE: 1,
        FILL_STROKE: 2,
        INVISIBLE: 3,
        FILL_ADD_TO_PATH: 4,
        STROKE_ADD_TO_PATH: 5,
        FILL_STROKE_ADD_TO_PATH: 6,
        ADD_TO_PATH: 7,
        FILL_STROKE_MASK: 3,
        ADD_TO_PATH_FLAG: 4
      }, Q = {
        GRAYSCALE_1BPP: 1,
        RGB_24BPP: 2,
        RGBA_32BPP: 3
      }, u = {
        TEXT: 1,
        LINK: 2,
        FREETEXT: 3,
        LINE: 4,
        SQUARE: 5,
        CIRCLE: 6,
        POLYGON: 7,
        POLYLINE: 8,
        HIGHLIGHT: 9,
        UNDERLINE: 10,
        SQUIGGLY: 11,
        STRIKEOUT: 12,
        STAMP: 13,
        CARET: 14,
        INK: 15,
        POPUP: 16,
        FILEATTACHMENT: 17,
        SOUND: 18,
        MOVIE: 19,
        WIDGET: 20,
        SCREEN: 21,
        PRINTERMARK: 22,
        TRAPNET: 23,
        WATERMARK: 24,
        THREED: 25,
        REDACT: 26
      }, i = {
        SOLID: 1,
        DASHED: 2,
        BEVELED: 3,
        INSET: 4,
        UNDERLINE: 5
      }, c = {
        ERRORS: 0,
        WARNINGS: 1,
        INFOS: 5
      }, R = {
        NONE: 0,
        BINARY: 1
      }, m = {
        dependency: 1,
        setLineWidth: 2,
        setLineCap: 3,
        setLineJoin: 4,
        setMiterLimit: 5,
        setDash: 6,
        setRenderingIntent: 7,
        setFlatness: 8,
        setGState: 9,
        save: 10,
        restore: 11,
        transform: 12,
        moveTo: 13,
        lineTo: 14,
        curveTo: 15,
        curveTo2: 16,
        curveTo3: 17,
        closePath: 18,
        rectangle: 19,
        stroke: 20,
        closeStroke: 21,
        fill: 22,
        eoFill: 23,
        fillStroke: 24,
        eoFillStroke: 25,
        closeFillStroke: 26,
        closeEOFillStroke: 27,
        endPath: 28,
        clip: 29,
        eoClip: 30,
        beginText: 31,
        endText: 32,
        setCharSpacing: 33,
        setWordSpacing: 34,
        setHScale: 35,
        setLeading: 36,
        setFont: 37,
        setTextRenderingMode: 38,
        setTextRise: 39,
        moveText: 40,
        setLeadingMoveText: 41,
        setTextMatrix: 42,
        nextLine: 43,
        showText: 44,
        showSpacedText: 45,
        nextLineShowText: 46,
        nextLineSetSpacingShowText: 47,
        setCharWidth: 48,
        setCharWidthAndBounds: 49,
        setStrokeColorSpace: 50,
        setFillColorSpace: 51,
        setStrokeColor: 52,
        setStrokeColorN: 53,
        setFillColor: 54,
        setFillColorN: 55,
        setStrokeGray: 56,
        setFillGray: 57,
        setStrokeRGBColor: 58,
        setFillRGBColor: 59,
        setStrokeCMYKColor: 60,
        setFillCMYKColor: 61,
        shadingFill: 62,
        beginInlineImage: 63,
        beginImageData: 64,
        endInlineImage: 65,
        paintXObject: 66,
        markPoint: 67,
        markPointProps: 68,
        beginMarkedContent: 69,
        beginMarkedContentProps: 70,
        endMarkedContent: 71,
        beginCompat: 72,
        endCompat: 73,
        paintFormXObjectBegin: 74,
        paintFormXObjectEnd: 75,
        beginGroup: 76,
        endGroup: 77,
        beginAnnotation: 80,
        endAnnotation: 81,
        paintImageMaskXObject: 83,
        paintImageMaskXObjectGroup: 84,
        paintImageXObject: 85,
        paintInlineImageXObject: 86,
        paintInlineImageXObjectGroup: 87,
        paintImageXObjectRepeat: 88,
        paintImageMaskXObjectRepeat: 89,
        paintSolidColorImageMask: 90,
        constructPath: 91
      }, M = {
        NEED_PASSWORD: 1,
        INCORRECT_PASSWORD: 2
      };
      let S = c.WARNINGS;
      function p(g) {
        Number.isInteger(g) && (S = g);
      }
      function Y() {
        return S;
      }
      function k(g) {
        S >= c.INFOS && console.log(`Info: ${g}`);
      }
      function L(g) {
        S >= c.WARNINGS && console.log(`Warning: ${g}`);
      }
      function z(g) {
        throw new Error(g);
      }
      function f(g, D) {
        g || z(D);
      }
      function K(g) {
        switch (g?.protocol) {
          case "http:":
          case "https:":
          case "ftp:":
          case "mailto:":
          case "tel:":
            return !0;
          default:
            return !1;
        }
      }
      function P(g, D = null, C = null) {
        if (!g)
          return null;
        try {
          if (C && typeof g == "string" && (C.addDefaultProtocol && g.startsWith("www.") && g.match(/\./g)?.length >= 2 && (g = `http://${g}`), C.tryConvertEncoding))
            try {
              g = T(g);
            } catch {
            }
          const nl = D ? new URL(g, D) : new URL(g);
          if (K(nl))
            return nl;
        } catch {
        }
        return null;
      }
      function w(g, D, C, nl = !1) {
        return Object.defineProperty(g, D, {
          value: C,
          enumerable: !nl,
          configurable: !0,
          writable: !1
        }), C;
      }
      const O = function() {
        function D(C, nl) {
          this.constructor === D && z("Cannot initialize BaseException."), this.message = C, this.name = nl;
        }
        return D.prototype = new Error(), D.constructor = D, D;
      }();
      class el extends O {
        constructor(D, C) {
          super(D, "PasswordException"), this.code = C;
        }
      }
      class ll extends O {
        constructor(D, C) {
          super(D, "UnknownErrorException"), this.details = C;
        }
      }
      class q extends O {
        constructor(D) {
          super(D, "InvalidPDFException");
        }
      }
      class _ extends O {
        constructor(D) {
          super(D, "MissingPDFException");
        }
      }
      class il extends O {
        constructor(D, C) {
          super(D, "UnexpectedResponseException"), this.status = C;
        }
      }
      class dl extends O {
        constructor(D) {
          super(D, "FormatError");
        }
      }
      class tl extends O {
        constructor(D) {
          super(D, "AbortException");
        }
      }
      function al(g) {
        (typeof g != "object" || g?.length === void 0) && z("Invalid argument for bytesToString");
        const D = g.length, C = 8192;
        if (D < C)
          return String.fromCharCode.apply(null, g);
        const nl = [];
        for (let Fl = 0; Fl < D; Fl += C) {
          const sl = Math.min(Fl + C, D), Vl = g.subarray(Fl, sl);
          nl.push(String.fromCharCode.apply(null, Vl));
        }
        return nl.join("");
      }
      function Ul(g) {
        typeof g != "string" && z("Invalid argument for stringToBytes");
        const D = g.length, C = new Uint8Array(D);
        for (let nl = 0; nl < D; ++nl)
          C[nl] = g.charCodeAt(nl) & 255;
        return C;
      }
      function cl(g) {
        return String.fromCharCode(g >> 24 & 255, g >> 16 & 255, g >> 8 & 255, g & 255);
      }
      function B(g) {
        const D = /* @__PURE__ */ Object.create(null);
        for (const [C, nl] of g)
          D[C] = nl;
        return D;
      }
      function X() {
        const g = new Uint8Array(4);
        return g[0] = 1, new Uint32Array(g.buffer, 0, 1)[0] === 1;
      }
      function b() {
        try {
          return new Function(""), !0;
        } catch {
          return !1;
        }
      }
      class r {
        static get isLittleEndian() {
          return w(this, "isLittleEndian", X());
        }
        static get isEvalSupported() {
          return w(this, "isEvalSupported", b());
        }
        static get isOffscreenCanvasSupported() {
          return w(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
        }
        static get platform() {
          return typeof navigator < "u" && typeof navigator?.platform == "string" ? w(this, "platform", {
            isMac: navigator.platform.includes("Mac")
          }) : w(this, "platform", {
            isMac: !1
          });
        }
        static get isCSSRoundSupported() {
          return w(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
        }
      }
      const G = Array.from(Array(256).keys(), (g) => g.toString(16).padStart(2, "0"));
      class J {
        static makeHexColor(D, C, nl) {
          return `#${G[D]}${G[C]}${G[nl]}`;
        }
        static scaleMinMax(D, C) {
          let nl;
          D[0] ? (D[0] < 0 && (nl = C[0], C[0] = C[2], C[2] = nl), C[0] *= D[0], C[2] *= D[0], D[3] < 0 && (nl = C[1], C[1] = C[3], C[3] = nl), C[1] *= D[3], C[3] *= D[3]) : (nl = C[0], C[0] = C[1], C[1] = nl, nl = C[2], C[2] = C[3], C[3] = nl, D[1] < 0 && (nl = C[1], C[1] = C[3], C[3] = nl), C[1] *= D[1], C[3] *= D[1], D[2] < 0 && (nl = C[0], C[0] = C[2], C[2] = nl), C[0] *= D[2], C[2] *= D[2]), C[0] += D[4], C[1] += D[5], C[2] += D[4], C[3] += D[5];
        }
        static transform(D, C) {
          return [D[0] * C[0] + D[2] * C[1], D[1] * C[0] + D[3] * C[1], D[0] * C[2] + D[2] * C[3], D[1] * C[2] + D[3] * C[3], D[0] * C[4] + D[2] * C[5] + D[4], D[1] * C[4] + D[3] * C[5] + D[5]];
        }
        static applyTransform(D, C) {
          const nl = D[0] * C[0] + D[1] * C[2] + C[4], Fl = D[0] * C[1] + D[1] * C[3] + C[5];
          return [nl, Fl];
        }
        static applyInverseTransform(D, C) {
          const nl = C[0] * C[3] - C[1] * C[2], Fl = (D[0] * C[3] - D[1] * C[2] + C[2] * C[5] - C[4] * C[3]) / nl, sl = (-D[0] * C[1] + D[1] * C[0] + C[4] * C[1] - C[5] * C[0]) / nl;
          return [Fl, sl];
        }
        static getAxialAlignedBoundingBox(D, C) {
          const nl = this.applyTransform(D, C), Fl = this.applyTransform(D.slice(2, 4), C), sl = this.applyTransform([D[0], D[3]], C), Vl = this.applyTransform([D[2], D[1]], C);
          return [Math.min(nl[0], Fl[0], sl[0], Vl[0]), Math.min(nl[1], Fl[1], sl[1], Vl[1]), Math.max(nl[0], Fl[0], sl[0], Vl[0]), Math.max(nl[1], Fl[1], sl[1], Vl[1])];
        }
        static inverseTransform(D) {
          const C = D[0] * D[3] - D[1] * D[2];
          return [D[3] / C, -D[1] / C, -D[2] / C, D[0] / C, (D[2] * D[5] - D[4] * D[3]) / C, (D[4] * D[1] - D[5] * D[0]) / C];
        }
        static singularValueDecompose2dScale(D) {
          const C = [D[0], D[2], D[1], D[3]], nl = D[0] * C[0] + D[1] * C[2], Fl = D[0] * C[1] + D[1] * C[3], sl = D[2] * C[0] + D[3] * C[2], Vl = D[2] * C[1] + D[3] * C[3], Rl = (nl + Vl) / 2, Wl = Math.sqrt((nl + Vl) ** 2 - 4 * (nl * Vl - sl * Fl)) / 2, ml = Rl + Wl || 1, rl = Rl - Wl || 1;
          return [Math.sqrt(ml), Math.sqrt(rl)];
        }
        static normalizeRect(D) {
          const C = D.slice(0);
          return D[0] > D[2] && (C[0] = D[2], C[2] = D[0]), D[1] > D[3] && (C[1] = D[3], C[3] = D[1]), C;
        }
        static intersect(D, C) {
          const nl = Math.max(Math.min(D[0], D[2]), Math.min(C[0], C[2])), Fl = Math.min(Math.max(D[0], D[2]), Math.max(C[0], C[2]));
          if (nl > Fl)
            return null;
          const sl = Math.max(Math.min(D[1], D[3]), Math.min(C[1], C[3])), Vl = Math.min(Math.max(D[1], D[3]), Math.max(C[1], C[3]));
          return sl > Vl ? null : [nl, sl, Fl, Vl];
        }
        static #l(D, C, nl, Fl, sl, Vl, Rl, Wl, ml, rl) {
          if (ml <= 0 || ml >= 1)
            return;
          const Gl = 1 - ml, Ll = ml * ml, Cl = Ll * ml, $ = Gl * (Gl * (Gl * D + 3 * ml * C) + 3 * Ll * nl) + Cl * Fl, hl = Gl * (Gl * (Gl * sl + 3 * ml * Vl) + 3 * Ll * Rl) + Cl * Wl;
          rl[0] = Math.min(rl[0], $), rl[1] = Math.min(rl[1], hl), rl[2] = Math.max(rl[2], $), rl[3] = Math.max(rl[3], hl);
        }
        static #t(D, C, nl, Fl, sl, Vl, Rl, Wl, ml, rl, Gl, Ll) {
          if (Math.abs(ml) < 1e-12) {
            Math.abs(rl) >= 1e-12 && this.#l(D, C, nl, Fl, sl, Vl, Rl, Wl, -Gl / rl, Ll);
            return;
          }
          const Cl = rl ** 2 - 4 * Gl * ml;
          if (Cl < 0)
            return;
          const $ = Math.sqrt(Cl), hl = 2 * ml;
          this.#l(D, C, nl, Fl, sl, Vl, Rl, Wl, (-rl + $) / hl, Ll), this.#l(D, C, nl, Fl, sl, Vl, Rl, Wl, (-rl - $) / hl, Ll);
        }
        static bezierBoundingBox(D, C, nl, Fl, sl, Vl, Rl, Wl, ml) {
          return ml ? (ml[0] = Math.min(ml[0], D, Rl), ml[1] = Math.min(ml[1], C, Wl), ml[2] = Math.max(ml[2], D, Rl), ml[3] = Math.max(ml[3], C, Wl)) : ml = [Math.min(D, Rl), Math.min(C, Wl), Math.max(D, Rl), Math.max(C, Wl)], this.#t(D, nl, sl, Rl, C, Fl, Vl, Wl, 3 * (-D + 3 * (nl - sl) + Rl), 6 * (D - 2 * nl + sl), 3 * (nl - D), ml), this.#t(D, nl, sl, Rl, C, Fl, Vl, Wl, 3 * (-C + 3 * (Fl - Vl) + Wl), 6 * (C - 2 * Fl + Vl), 3 * (Fl - C), ml), ml;
        }
      }
      function T(g) {
        return decodeURIComponent(escape(g));
      }
      let y = null, I = null;
      function E(g) {
        return y || (y = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, I = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), g.replaceAll(y, (D, C, nl) => C ? C.normalize("NFKC") : I.get(nl));
      }
      function x() {
        if (typeof crypto < "u" && typeof crypto?.randomUUID == "function")
          return crypto.randomUUID();
        const g = new Uint8Array(32);
        if (typeof crypto < "u" && typeof crypto?.getRandomValues == "function")
          crypto.getRandomValues(g);
        else
          for (let D = 0; D < 32; D++)
            g[D] = Math.floor(Math.random() * 255);
        return al(g);
      }
      const v = "pdfjs_internal_id_", A = {
        BEZIER_CURVE_TO: 0,
        MOVE_TO: 1,
        LINE_TO: 2,
        QUADRATIC_CURVE_TO: 3,
        RESTORE: 4,
        SAVE: 5,
        SCALE: 6,
        TRANSFORM: 7,
        TRANSLATE: 8
      };
    }
  )
  /******/
}, SU = {};
function un(l) {
  var t = SU[l];
  if (t !== void 0)
    return t.exports;
  var n = SU[l] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  return JM[l](n, n.exports, un), n.exports;
}
(() => {
  var l = typeof Symbol == "function" ? Symbol("webpack queues") : "__webpack_queues__", t = typeof Symbol == "function" ? Symbol("webpack exports") : "__webpack_exports__", n = typeof Symbol == "function" ? Symbol("webpack error") : "__webpack_error__", e = (a) => {
    a && a.d < 1 && (a.d = 1, a.forEach((U) => U.r--), a.forEach((U) => U.r-- ? U.r++ : U()));
  }, d = (a) => a.map((U) => {
    if (U !== null && typeof U == "object") {
      if (U[l])
        return U;
      if (U.then) {
        var V = [];
        V.d = 0, U.then((Z) => {
          h[t] = Z, e(V);
        }, (Z) => {
          h[n] = Z, e(V);
        });
        var h = {};
        return h[l] = (Z) => Z(V), h;
      }
    }
    var W = {};
    return W[l] = (Z) => {
    }, W[t] = U, W;
  });
  un.a = (a, U, V) => {
    var h;
    V && ((h = []).d = -1);
    var W = /* @__PURE__ */ new Set(), Z = a.exports, s, o, F, N = new Promise((Q, u) => {
      F = u, o = Q;
    });
    N[t] = Z, N[l] = (Q) => (h && Q(h), W.forEach(Q), N.catch((u) => {
    })), a.exports = N, U((Q) => {
      s = d(Q);
      var u, i = () => s.map((R) => {
        if (R[n])
          throw R[n];
        return R[t];
      }), c = new Promise((R) => {
        u = () => R(i), u.r = 0;
        var m = (M) => M !== h && !W.has(M) && (W.add(M), M && !M.d && (u.r++, M.push(u)));
        s.map((M) => M[l](m));
      });
      return u.r ? c : i();
    }, (Q) => (Q ? F(N[n] = Q) : o(Z), e(h))), h && h.d < 0 && (h.d = 0);
  };
})();
un.d = (l, t) => {
  for (var n in t)
    un.o(t, n) && !un.o(l, n) && Object.defineProperty(l, n, { enumerable: !0, get: t[n] });
};
un.o = (l, t) => Object.prototype.hasOwnProperty.call(l, t);
var zl = un(228);
zl = globalThis.pdfjsLib = await (globalThis.pdfjsLibPromise = zl);
zl.AbortException;
zl.AnnotationEditorLayer;
zl.AnnotationEditorParamsType;
zl.AnnotationEditorType;
zl.AnnotationEditorUIManager;
zl.AnnotationLayer;
zl.AnnotationMode;
zl.CMapCompressionType;
zl.ColorPicker;
zl.DOMSVGFactory;
zl.DrawLayer;
zl.FeatureTest;
var XM = zl.GlobalWorkerOptions;
zl.ImageKind;
zl.InvalidPDFException;
zl.MissingPDFException;
zl.OPS;
zl.Outliner;
zl.PDFDataRangeTransport;
zl.PDFDateString;
zl.PDFWorker;
zl.PasswordResponses;
zl.PermissionFlag;
zl.PixelsPerInch;
zl.RenderingCancelledException;
zl.UnexpectedResponseException;
zl.Util;
zl.VerbosityLevel;
zl.XfaLayer;
zl.build;
zl.createValidAbsoluteUrl;
zl.fetchData;
var YM = zl.getDocument;
zl.getFilenameFromUrl;
zl.getPdfFilenameFromUrl;
zl.getXfaPageViewport;
zl.isDataScheme;
zl.isPdfFile;
zl.noContextMenu;
zl.normalizeUnicode;
zl.renderTextLayer;
zl.setLayerDimensions;
zl.shadow;
zl.updateTextLayer;
zl.version;
var yM = {
  /***/
  588: (
    /***/
    (l, t, n) => {
      n.d(t, {
        FluentBundle: () => (
          /* reexport */
          K
        ),
        FluentResource: () => (
          /* reexport */
          v
        )
      });
      class e {
        constructor(D) {
          this.value = D;
        }
        valueOf() {
          return this.value;
        }
      }
      class d extends e {
        constructor(D = "???") {
          super(D);
        }
        toString(D) {
          return `{${this.value}}`;
        }
      }
      class a extends e {
        constructor(D, C = {}) {
          super(D), this.opts = C;
        }
        toString(D) {
          try {
            return D.memoizeIntlObject(Intl.NumberFormat, this.opts).format(this.value);
          } catch (C) {
            return D.reportError(C), this.value.toString(10);
          }
        }
      }
      class U extends e {
        constructor(D, C = {}) {
          super(D), this.opts = C;
        }
        toString(D) {
          try {
            return D.memoizeIntlObject(Intl.DateTimeFormat, this.opts).format(this.value);
          } catch (C) {
            return D.reportError(C), new Date(this.value).toISOString();
          }
        }
      }
      const V = 100, h = "⁨", W = "⁩";
      function Z(g, D, C) {
        if (C === D || C instanceof a && D instanceof a && C.value === D.value)
          return !0;
        if (D instanceof a && typeof C == "string") {
          let nl = g.memoizeIntlObject(Intl.PluralRules, D.opts).select(D.value);
          if (C === nl)
            return !0;
        }
        return !1;
      }
      function s(g, D, C) {
        return D[C] ? m(g, D[C].value) : (g.reportError(new RangeError("No default")), new d());
      }
      function o(g, D) {
        const C = [], nl = /* @__PURE__ */ Object.create(null);
        for (const Fl of D)
          Fl.type === "narg" ? nl[Fl.name] = F(g, Fl.value) : C.push(F(g, Fl));
        return {
          positional: C,
          named: nl
        };
      }
      function F(g, D) {
        switch (D.type) {
          case "str":
            return D.value;
          case "num":
            return new a(D.value, {
              minimumFractionDigits: D.precision
            });
          case "var":
            return N(g, D);
          case "mesg":
            return Q(g, D);
          case "term":
            return u(g, D);
          case "func":
            return i(g, D);
          case "select":
            return c(g, D);
          default:
            return new d();
        }
      }
      function N(g, {
        name: D
      }) {
        let C;
        if (g.params)
          if (Object.prototype.hasOwnProperty.call(g.params, D))
            C = g.params[D];
          else
            return new d(`$${D}`);
        else if (g.args && Object.prototype.hasOwnProperty.call(g.args, D))
          C = g.args[D];
        else
          return g.reportError(new ReferenceError(`Unknown variable: $${D}`)), new d(`$${D}`);
        if (C instanceof e)
          return C;
        switch (typeof C) {
          case "string":
            return C;
          case "number":
            return new a(C);
          case "object":
            if (C instanceof Date)
              return new U(C.getTime());
          default:
            return g.reportError(new TypeError(`Variable type not supported: $${D}, ${typeof C}`)), new d(`$${D}`);
        }
      }
      function Q(g, {
        name: D,
        attr: C
      }) {
        const nl = g.bundle._messages.get(D);
        if (!nl)
          return g.reportError(new ReferenceError(`Unknown message: ${D}`)), new d(D);
        if (C) {
          const Fl = nl.attributes[C];
          return Fl ? m(g, Fl) : (g.reportError(new ReferenceError(`Unknown attribute: ${C}`)), new d(`${D}.${C}`));
        }
        return nl.value ? m(g, nl.value) : (g.reportError(new ReferenceError(`No value: ${D}`)), new d(D));
      }
      function u(g, {
        name: D,
        attr: C,
        args: nl
      }) {
        const Fl = `-${D}`, sl = g.bundle._terms.get(Fl);
        if (!sl)
          return g.reportError(new ReferenceError(`Unknown term: ${Fl}`)), new d(Fl);
        if (C) {
          const Rl = sl.attributes[C];
          if (Rl) {
            g.params = o(g, nl).named;
            const Wl = m(g, Rl);
            return g.params = null, Wl;
          }
          return g.reportError(new ReferenceError(`Unknown attribute: ${C}`)), new d(`${Fl}.${C}`);
        }
        g.params = o(g, nl).named;
        const Vl = m(g, sl.value);
        return g.params = null, Vl;
      }
      function i(g, {
        name: D,
        args: C
      }) {
        let nl = g.bundle._functions[D];
        if (!nl)
          return g.reportError(new ReferenceError(`Unknown function: ${D}()`)), new d(`${D}()`);
        if (typeof nl != "function")
          return g.reportError(new TypeError(`Function ${D}() is not callable`)), new d(`${D}()`);
        try {
          let Fl = o(g, C);
          return nl(Fl.positional, Fl.named);
        } catch (Fl) {
          return g.reportError(Fl), new d(`${D}()`);
        }
      }
      function c(g, {
        selector: D,
        variants: C,
        star: nl
      }) {
        let Fl = F(g, D);
        if (Fl instanceof d)
          return s(g, C, nl);
        for (const sl of C) {
          const Vl = F(g, sl.key);
          if (Z(g, Fl, Vl))
            return m(g, sl.value);
        }
        return s(g, C, nl);
      }
      function R(g, D) {
        if (g.dirty.has(D))
          return g.reportError(new RangeError("Cyclic reference")), new d();
        g.dirty.add(D);
        const C = [], nl = g.bundle._useIsolating && D.length > 1;
        for (const Fl of D) {
          if (typeof Fl == "string") {
            C.push(g.bundle._transform(Fl));
            continue;
          }
          if (g.placeables++, g.placeables > V)
            throw g.dirty.delete(D), new RangeError(`Too many placeables expanded: ${g.placeables}, max allowed is ${V}`);
          nl && C.push(h), C.push(F(g, Fl).toString(g)), nl && C.push(W);
        }
        return g.dirty.delete(D), C.join("");
      }
      function m(g, D) {
        return typeof D == "string" ? g.bundle._transform(D) : R(g, D);
      }
      class M {
        constructor(D, C, nl) {
          this.dirty = /* @__PURE__ */ new WeakSet(), this.params = null, this.placeables = 0, this.bundle = D, this.errors = C, this.args = nl;
        }
        reportError(D) {
          if (!this.errors || !(D instanceof Error))
            throw D;
          this.errors.push(D);
        }
        memoizeIntlObject(D, C) {
          let nl = this.bundle._intls.get(D);
          nl || (nl = {}, this.bundle._intls.set(D, nl));
          let Fl = JSON.stringify(C);
          return nl[Fl] || (nl[Fl] = new D(this.bundle.locales, C)), nl[Fl];
        }
      }
      function S(g, D) {
        const C = /* @__PURE__ */ Object.create(null);
        for (const [nl, Fl] of Object.entries(g))
          D.includes(nl) && (C[nl] = Fl.valueOf());
        return C;
      }
      const p = ["unitDisplay", "currencyDisplay", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits"];
      function Y(g, D) {
        let C = g[0];
        if (C instanceof d)
          return new d(`NUMBER(${C.valueOf()})`);
        if (C instanceof a)
          return new a(C.valueOf(), {
            ...C.opts,
            ...S(D, p)
          });
        if (C instanceof U)
          return new a(C.valueOf(), {
            ...S(D, p)
          });
        throw new TypeError("Invalid argument to NUMBER");
      }
      const k = ["dateStyle", "timeStyle", "fractionalSecondDigits", "dayPeriod", "hour12", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName"];
      function L(g, D) {
        let C = g[0];
        if (C instanceof d)
          return new d(`DATETIME(${C.valueOf()})`);
        if (C instanceof U)
          return new U(C.valueOf(), {
            ...C.opts,
            ...S(D, k)
          });
        if (C instanceof a)
          return new U(C.valueOf(), {
            ...S(D, k)
          });
        throw new TypeError("Invalid argument to DATETIME");
      }
      const z = /* @__PURE__ */ new Map();
      function f(g) {
        const D = Array.isArray(g) ? g.join(" ") : g;
        let C = z.get(D);
        return C === void 0 && (C = /* @__PURE__ */ new Map(), z.set(D, C)), C;
      }
      class K {
        constructor(D, {
          functions: C,
          useIsolating: nl = !0,
          transform: Fl = (sl) => sl
        } = {}) {
          this._terms = /* @__PURE__ */ new Map(), this._messages = /* @__PURE__ */ new Map(), this.locales = Array.isArray(D) ? D : [D], this._functions = {
            NUMBER: Y,
            DATETIME: L,
            ...C
          }, this._useIsolating = nl, this._transform = Fl, this._intls = f(D);
        }
        hasMessage(D) {
          return this._messages.has(D);
        }
        getMessage(D) {
          return this._messages.get(D);
        }
        addResource(D, {
          allowOverrides: C = !1
        } = {}) {
          const nl = [];
          for (let Fl = 0; Fl < D.body.length; Fl++) {
            let sl = D.body[Fl];
            if (sl.id.startsWith("-")) {
              if (C === !1 && this._terms.has(sl.id)) {
                nl.push(new Error(`Attempt to override an existing term: "${sl.id}"`));
                continue;
              }
              this._terms.set(sl.id, sl);
            } else {
              if (C === !1 && this._messages.has(sl.id)) {
                nl.push(new Error(`Attempt to override an existing message: "${sl.id}"`));
                continue;
              }
              this._messages.set(sl.id, sl);
            }
          }
          return nl;
        }
        formatPattern(D, C = null, nl = null) {
          if (typeof D == "string")
            return this._transform(D);
          let Fl = new M(this, nl, C);
          try {
            return R(Fl, D).toString(Fl);
          } catch (sl) {
            if (Fl.errors && sl instanceof Error)
              return Fl.errors.push(sl), new d().toString(Fl);
            throw sl;
          }
        }
      }
      const P = /^(-?[a-zA-Z][\w-]*) *= */gm, w = /\.([a-zA-Z][\w-]*) *= */y, O = /\*?\[/y, el = /(-?[0-9]+(?:\.([0-9]+))?)/y, ll = /([a-zA-Z][\w-]*)/y, q = /([$-])?([a-zA-Z][\w-]*)(?:\.([a-zA-Z][\w-]*))?/y, _ = /^[A-Z][A-Z0-9_-]*$/, il = /([^{}\n\r]+)/y, dl = /([^\\"\n\r]*)/y, tl = /\\([\\"])/y, al = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{6})/y, Ul = /^\n+/, cl = / +$/, B = / *\r?\n/g, X = /( *)$/, b = /{\s*/y, r = /\s*}/y, G = /\[\s*/y, J = /\s*] */y, T = /\s*\(\s*/y, y = /\s*->\s*/y, I = /\s*:\s*/y, E = /\s*,?\s*/y, x = /\s+/y;
      class v {
        constructor(D) {
          this.body = [], P.lastIndex = 0;
          let C = 0;
          for (; ; ) {
            let Nl = P.exec(D);
            if (Nl === null)
              break;
            C = P.lastIndex;
            try {
              this.body.push(Wl(Nl[1]));
            } catch (Sl) {
              if (Sl instanceof SyntaxError)
                continue;
              throw Sl;
            }
          }
          function nl(Nl) {
            return Nl.lastIndex = C, Nl.test(D);
          }
          function Fl(Nl, Sl) {
            if (D[C] === Nl)
              return C++, !0;
            if (Sl)
              throw new Sl(`Expected ${Nl}`);
            return !1;
          }
          function sl(Nl, Sl) {
            if (nl(Nl))
              return C = Nl.lastIndex, !0;
            if (Sl)
              throw new Sl(`Expected ${Nl.toString()}`);
            return !1;
          }
          function Vl(Nl) {
            Nl.lastIndex = C;
            let Sl = Nl.exec(D);
            if (Sl === null)
              throw new SyntaxError(`Expected ${Nl.toString()}`);
            return C = Nl.lastIndex, Sl;
          }
          function Rl(Nl) {
            return Vl(Nl)[1];
          }
          function Wl(Nl) {
            let Sl = rl(), Yl = ml();
            if (Sl === null && Object.keys(Yl).length === 0)
              throw new SyntaxError("Expected message value or attributes");
            return {
              id: Nl,
              value: Sl,
              attributes: Yl
            };
          }
          function ml() {
            let Nl = /* @__PURE__ */ Object.create(null);
            for (; nl(w); ) {
              let Sl = Rl(w), Yl = rl();
              if (Yl === null)
                throw new SyntaxError("Expected attribute value");
              Nl[Sl] = Yl;
            }
            return Nl;
          }
          function rl() {
            let Nl;
            if (nl(il) && (Nl = Rl(il)), D[C] === "{" || D[C] === "}")
              return Gl(Nl ? [Nl] : [], 1 / 0);
            let Sl = _l();
            return Sl ? Nl ? Gl([Nl, Sl], Sl.length) : (Sl.value = lt(Sl.value, Ul), Gl([Sl], Sl.length)) : Nl ? lt(Nl, cl) : null;
          }
          function Gl(Nl = [], Sl) {
            for (; ; ) {
              if (nl(il)) {
                Nl.push(Rl(il));
                continue;
              }
              if (D[C] === "{") {
                Nl.push(Ll());
                continue;
              }
              if (D[C] === "}")
                throw new SyntaxError("Unbalanced closing brace");
              let jl = _l();
              if (jl) {
                Nl.push(jl), Sl = Math.min(Sl, jl.length);
                continue;
              }
              break;
            }
            let Yl = Nl.length - 1, Hl = Nl[Yl];
            typeof Hl == "string" && (Nl[Yl] = lt(Hl, cl));
            let vl = [];
            for (let jl of Nl)
              jl instanceof A && (jl = jl.value.slice(0, jl.value.length - Sl)), jl && vl.push(jl);
            return vl;
          }
          function Ll() {
            sl(b, SyntaxError);
            let Nl = Cl();
            if (sl(r))
              return Nl;
            if (sl(y)) {
              let Sl = Tl();
              return sl(r, SyntaxError), {
                type: "select",
                selector: Nl,
                ...Sl
              };
            }
            throw new SyntaxError("Unclosed placeable");
          }
          function Cl() {
            if (D[C] === "{")
              return Ll();
            if (nl(q)) {
              let [, Nl, Sl, Yl = null] = Vl(q);
              if (Nl === "$")
                return {
                  type: "var",
                  name: Sl
                };
              if (sl(T)) {
                let Hl = $();
                if (Nl === "-")
                  return {
                    type: "term",
                    name: Sl,
                    attr: Yl,
                    args: Hl
                  };
                if (_.test(Sl))
                  return {
                    type: "func",
                    name: Sl,
                    args: Hl
                  };
                throw new SyntaxError("Function names must be all upper-case");
              }
              return Nl === "-" ? {
                type: "term",
                name: Sl,
                attr: Yl,
                args: []
              } : {
                type: "mesg",
                name: Sl,
                attr: Yl
              };
            }
            return yl();
          }
          function $() {
            let Nl = [];
            for (; ; ) {
              switch (D[C]) {
                case ")":
                  return C++, Nl;
                case void 0:
                  throw new SyntaxError("Unclosed argument list");
              }
              Nl.push(hl()), sl(E);
            }
          }
          function hl() {
            let Nl = Cl();
            return Nl.type !== "mesg" ? Nl : sl(I) ? {
              type: "narg",
              name: Nl.name,
              value: yl()
            } : Nl;
          }
          function Tl() {
            let Nl = [], Sl = 0, Yl;
            for (; nl(O); ) {
              Fl("*") && (Yl = Sl);
              let Hl = Jl(), vl = rl();
              if (vl === null)
                throw new SyntaxError("Expected variant value");
              Nl[Sl++] = {
                key: Hl,
                value: vl
              };
            }
            if (Sl === 0)
              return null;
            if (Yl === void 0)
              throw new SyntaxError("Expected default variant");
            return {
              variants: Nl,
              star: Yl
            };
          }
          function Jl() {
            sl(G, SyntaxError);
            let Nl;
            return nl(el) ? Nl = Il() : Nl = {
              type: "str",
              value: Rl(ll)
            }, sl(J, SyntaxError), Nl;
          }
          function yl() {
            if (nl(el))
              return Il();
            if (D[C] === '"')
              return gl();
            throw new SyntaxError("Invalid expression");
          }
          function Il() {
            let [, Nl, Sl = ""] = Vl(el), Yl = Sl.length;
            return {
              type: "num",
              value: parseFloat(Nl),
              precision: Yl
            };
          }
          function gl() {
            Fl('"', SyntaxError);
            let Nl = "";
            for (; ; ) {
              if (Nl += Rl(dl), D[C] === "\\") {
                Nl += wl();
                continue;
              }
              if (Fl('"'))
                return {
                  type: "str",
                  value: Nl
                };
              throw new SyntaxError("Unclosed string literal");
            }
          }
          function wl() {
            if (nl(tl))
              return Rl(tl);
            if (nl(al)) {
              let [, Nl, Sl] = Vl(al), Yl = parseInt(Nl || Sl, 16);
              return Yl <= 55295 || 57344 <= Yl ? String.fromCodePoint(Yl) : "�";
            }
            throw new SyntaxError("Unknown escape sequence");
          }
          function _l() {
            let Nl = C;
            switch (sl(x), D[C]) {
              case ".":
              case "[":
              case "*":
              case "}":
              case void 0:
                return !1;
              case "{":
                return ct(D.slice(Nl, C));
            }
            return D[C - 1] === " " ? ct(D.slice(Nl, C)) : !1;
          }
          function lt(Nl, Sl) {
            return Nl.replace(Sl, "");
          }
          function ct(Nl) {
            let Sl = Nl.replace(B, `
`), Yl = X.exec(Nl)[1].length;
            return new A(Sl, Yl);
          }
        }
      }
      class A {
        constructor(D, C) {
          this.value = D, this.length = C;
        }
      }
    }
  ),
  /***/
  273: (
    /***/
    (l, t, n) => {
      n.d(t, {
        DOMLocalization: () => (
          /* reexport */
          k
        )
      });
      const e = /<|&#?\w+;/, d = {
        "http://www.w3.org/1999/xhtml": ["em", "strong", "small", "s", "cite", "q", "dfn", "abbr", "data", "time", "code", "var", "samp", "kbd", "sub", "sup", "i", "b", "u", "mark", "bdi", "bdo", "span", "br", "wbr"]
      }, a = {
        "http://www.w3.org/1999/xhtml": {
          global: ["title", "aria-label", "aria-valuetext"],
          a: ["download"],
          area: ["download", "alt"],
          input: ["alt", "placeholder"],
          menuitem: ["label"],
          menu: ["label"],
          optgroup: ["label"],
          option: ["label"],
          track: ["label"],
          img: ["alt"],
          textarea: ["placeholder"],
          th: ["abbr"]
        },
        "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul": {
          global: ["accesskey", "aria-label", "aria-valuetext", "label", "title", "tooltiptext"],
          description: ["value"],
          key: ["key", "keycode"],
          label: ["value"],
          textbox: ["placeholder", "value"]
        }
      };
      function U(L, z) {
        const {
          value: f
        } = z;
        if (typeof f == "string")
          if (L.localName === "title" && L.namespaceURI === "http://www.w3.org/1999/xhtml")
            L.textContent = f;
          else if (!e.test(f))
            L.textContent = f;
          else {
            const K = L.ownerDocument.createElementNS("http://www.w3.org/1999/xhtml", "template");
            K.innerHTML = f, V(K.content, L);
          }
        W(z, L);
      }
      function V(L, z) {
        for (const f of L.childNodes)
          if (f.nodeType !== f.TEXT_NODE) {
            if (f.hasAttribute("data-l10n-name")) {
              const K = Z(z, f);
              L.replaceChild(K, f);
              continue;
            }
            if (F(f)) {
              const K = s(f);
              L.replaceChild(K, f);
              continue;
            }
            console.warn(`An element of forbidden type "${f.localName}" was found in the translation. Only safe text-level elements and elements with data-l10n-name are allowed.`), L.replaceChild(o(f), f);
          }
        z.textContent = "", z.appendChild(L);
      }
      function h(L, z) {
        if (!L)
          return !1;
        for (let f of L)
          if (f.name === z)
            return !0;
        return !1;
      }
      function W(L, z) {
        const f = z.hasAttribute("data-l10n-attrs") ? z.getAttribute("data-l10n-attrs").split(",").map((K) => K.trim()) : null;
        for (const K of Array.from(z.attributes))
          N(K.name, z, f) && !h(L.attributes, K.name) && z.removeAttribute(K.name);
        if (L.attributes)
          for (const K of Array.from(L.attributes))
            N(K.name, z, f) && z.getAttribute(K.name) !== K.value && z.setAttribute(K.name, K.value);
      }
      function Z(L, z) {
        const f = z.getAttribute("data-l10n-name"), K = L.querySelector(`[data-l10n-name="${f}"]`);
        if (!K)
          return console.warn(`An element named "${f}" wasn't found in the source.`), o(z);
        if (K.localName !== z.localName)
          return console.warn(`An element named "${f}" was found in the translation but its type ${z.localName} didn't match the element found in the source (${K.localName}).`), o(z);
        L.removeChild(K);
        const P = K.cloneNode(!1);
        return Q(z, P);
      }
      function s(L) {
        const z = L.ownerDocument.createElement(L.localName);
        return Q(L, z);
      }
      function o(L) {
        return L.ownerDocument.createTextNode(L.textContent);
      }
      function F(L) {
        const z = d[L.namespaceURI];
        return z && z.includes(L.localName);
      }
      function N(L, z, f = null) {
        if (f && f.includes(L))
          return !0;
        const K = a[z.namespaceURI];
        if (!K)
          return !1;
        const P = L.toLowerCase(), w = z.localName;
        if (K.global.includes(P))
          return !0;
        if (!K[w])
          return !1;
        if (K[w].includes(P))
          return !0;
        if (z.namespaceURI === "http://www.w3.org/1999/xhtml" && w === "input" && P === "value") {
          const O = z.type.toLowerCase();
          if (O === "submit" || O === "button" || O === "reset")
            return !0;
        }
        return !1;
      }
      function Q(L, z) {
        return z.textContent = L.textContent, W(L, z), z;
      }
      class u extends Array {
        static from(z) {
          return z instanceof this ? z : new this(z);
        }
      }
      class i extends u {
        constructor(z) {
          if (super(), Symbol.asyncIterator in Object(z))
            this.iterator = z[Symbol.asyncIterator]();
          else if (Symbol.iterator in Object(z))
            this.iterator = z[Symbol.iterator]();
          else
            throw new TypeError("Argument must implement the iteration protocol.");
        }
        [Symbol.asyncIterator]() {
          const z = this;
          let f = 0;
          return {
            async next() {
              return z.length <= f && z.push(z.iterator.next()), z[f++];
            }
          };
        }
        async touchNext(z = 1) {
          let f = 0;
          for (; f++ < z; ) {
            const K = this[this.length - 1];
            if (K && (await K).done)
              break;
            this.push(this.iterator.next());
          }
          return this[this.length - 1];
        }
      }
      class c {
        constructor(z = [], f) {
          this.resourceIds = z, this.generateBundles = f, this.onChange(!0);
        }
        addResourceIds(z, f = !1) {
          return this.resourceIds.push(...z), this.onChange(f), this.resourceIds.length;
        }
        removeResourceIds(z) {
          return this.resourceIds = this.resourceIds.filter((f) => !z.includes(f)), this.onChange(), this.resourceIds.length;
        }
        async formatWithFallback(z, f) {
          const K = [];
          let P = !1;
          for await (const w of this.bundles) {
            P = !0;
            const O = M(f, w, z, K);
            if (O.size === 0)
              break;
            if (typeof console < "u") {
              const el = w.locales[0], ll = Array.from(O).join(", ");
              console.warn(`[fluent] Missing translations in ${el}: ${ll}`);
            }
          }
          return !P && typeof console < "u" && console.warn(`[fluent] Request for keys failed because no resource bundles got generated.
  keys: ${JSON.stringify(z)}.
  resourceIds: ${JSON.stringify(this.resourceIds)}.`), K;
        }
        formatMessages(z) {
          return this.formatWithFallback(z, m);
        }
        formatValues(z) {
          return this.formatWithFallback(z, R);
        }
        async formatValue(z, f) {
          const [K] = await this.formatValues([{
            id: z,
            args: f
          }]);
          return K;
        }
        handleEvent() {
          this.onChange();
        }
        onChange(z = !1) {
          this.bundles = i.from(this.generateBundles(this.resourceIds)), z && this.bundles.touchNext(2);
        }
      }
      function R(L, z, f, K) {
        return f.value ? L.formatPattern(f.value, K, z) : null;
      }
      function m(L, z, f, K) {
        const P = {
          value: null,
          attributes: null
        };
        f.value && (P.value = L.formatPattern(f.value, K, z));
        let w = Object.keys(f.attributes);
        if (w.length > 0) {
          P.attributes = new Array(w.length);
          for (let [O, el] of w.entries()) {
            let ll = L.formatPattern(f.attributes[el], K, z);
            P.attributes[O] = {
              name: el,
              value: ll
            };
          }
        }
        return P;
      }
      function M(L, z, f, K) {
        const P = [], w = /* @__PURE__ */ new Set();
        return f.forEach(({
          id: O,
          args: el
        }, ll) => {
          if (K[ll] !== void 0)
            return;
          let q = z.getMessage(O);
          if (q) {
            if (P.length = 0, K[ll] = L(z, P, q, el), P.length > 0 && typeof console < "u") {
              const _ = z.locales[0], il = P.join(", ");
              console.warn(`[fluent][resolver] errors in ${_}/${O}: ${il}.`);
            }
          } else
            w.add(O);
        }), w;
      }
      const S = "data-l10n-id", p = "data-l10n-args", Y = `[${S}]`;
      class k extends c {
        constructor(z, f) {
          super(z, f), this.roots = /* @__PURE__ */ new Set(), this.pendingrAF = null, this.pendingElements = /* @__PURE__ */ new Set(), this.windowElement = null, this.mutationObserver = null, this.observerConfig = {
            attributes: !0,
            characterData: !1,
            childList: !0,
            subtree: !0,
            attributeFilter: [S, p]
          };
        }
        onChange(z = !1) {
          super.onChange(z), this.roots && this.translateRoots();
        }
        setAttributes(z, f, K) {
          return z.setAttribute(S, f), K ? z.setAttribute(p, JSON.stringify(K)) : z.removeAttribute(p), z;
        }
        getAttributes(z) {
          return {
            id: z.getAttribute(S),
            args: JSON.parse(z.getAttribute(p) || null)
          };
        }
        connectRoot(z) {
          for (const f of this.roots)
            if (f === z || f.contains(z) || z.contains(f))
              throw new Error("Cannot add a root that overlaps with existing root.");
          if (this.windowElement) {
            if (this.windowElement !== z.ownerDocument.defaultView)
              throw new Error(`Cannot connect a root:
          DOMLocalization already has a root from a different window.`);
          } else
            this.windowElement = z.ownerDocument.defaultView, this.mutationObserver = new this.windowElement.MutationObserver((f) => this.translateMutations(f));
          this.roots.add(z), this.mutationObserver.observe(z, this.observerConfig);
        }
        disconnectRoot(z) {
          return this.roots.delete(z), this.pauseObserving(), this.roots.size === 0 ? (this.mutationObserver = null, this.windowElement = null, this.pendingrAF = null, this.pendingElements.clear(), !0) : (this.resumeObserving(), !1);
        }
        translateRoots() {
          const z = Array.from(this.roots);
          return Promise.all(z.map((f) => this.translateFragment(f)));
        }
        pauseObserving() {
          this.mutationObserver && (this.translateMutations(this.mutationObserver.takeRecords()), this.mutationObserver.disconnect());
        }
        resumeObserving() {
          if (this.mutationObserver)
            for (const z of this.roots)
              this.mutationObserver.observe(z, this.observerConfig);
        }
        translateMutations(z) {
          for (const f of z)
            switch (f.type) {
              case "attributes":
                f.target.hasAttribute("data-l10n-id") && this.pendingElements.add(f.target);
                break;
              case "childList":
                for (const K of f.addedNodes)
                  if (K.nodeType === K.ELEMENT_NODE)
                    if (K.childElementCount)
                      for (const P of this.getTranslatables(K))
                        this.pendingElements.add(P);
                    else
                      K.hasAttribute(S) && this.pendingElements.add(K);
                break;
            }
          this.pendingElements.size > 0 && this.pendingrAF === null && (this.pendingrAF = this.windowElement.requestAnimationFrame(() => {
            this.translateElements(Array.from(this.pendingElements)), this.pendingElements.clear(), this.pendingrAF = null;
          }));
        }
        translateFragment(z) {
          return this.translateElements(this.getTranslatables(z));
        }
        async translateElements(z) {
          if (!z.length)
            return;
          const f = z.map(this.getKeysForElement), K = await this.formatMessages(f);
          return this.applyTranslations(z, K);
        }
        applyTranslations(z, f) {
          this.pauseObserving();
          for (let K = 0; K < z.length; K++)
            f[K] !== void 0 && U(z[K], f[K]);
          this.resumeObserving();
        }
        getTranslatables(z) {
          const f = Array.from(z.querySelectorAll(Y));
          return typeof z.hasAttribute == "function" && z.hasAttribute(S) && f.push(z), f;
        }
        getKeysForElement(z) {
          return {
            id: z.getAttribute(S),
            args: JSON.parse(z.getAttribute(p) || null)
          };
        }
      }
    }
  ),
  /***/
  283: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            AnnotationEditorLayerBuilder: () => (
              /* binding */
              h
            )
            /* harmony export */
          });
          var a = n(603), U = n(410), V = e([a, U]);
          [a, U] = V.then ? (await V)() : V;
          class h {
            #l = null;
            #t = null;
            #n = null;
            #d = null;
            #a;
            constructor(Z) {
              this.pdfPage = Z.pdfPage, this.accessibilityManager = Z.accessibilityManager, this.l10n = Z.l10n, this.l10n ||= new U.GenericL10n(), this.annotationEditorLayer = null, this.div = null, this._cancelled = !1, this.#a = Z.uiManager, this.#l = Z.annotationLayer || null, this.#d = Z.textLayer || null, this.#t = Z.drawLayer || null, this.#n = Z.onAppend || null;
            }
            async render(Z, s = "display") {
              if (s !== "display" || this._cancelled)
                return;
              const o = Z.clone({
                dontFlip: !0
              });
              if (this.div) {
                this.annotationEditorLayer.update({
                  viewport: o
                }), this.show();
                return;
              }
              const F = this.div = document.createElement("div");
              F.className = "annotationEditorLayer", F.hidden = !0, F.dir = this.#a.direction, this.#n?.(F), this.annotationEditorLayer = new a.AnnotationEditorLayer({
                uiManager: this.#a,
                div: F,
                accessibilityManager: this.accessibilityManager,
                pageIndex: this.pdfPage.pageNumber - 1,
                l10n: this.l10n,
                viewport: o,
                annotationLayer: this.#l,
                textLayer: this.#d,
                drawLayer: this.#t
              });
              const N = {
                viewport: o,
                div: F,
                annotations: null,
                intent: s
              };
              this.annotationEditorLayer.render(N), this.show();
            }
            cancel() {
              this._cancelled = !0, this.div && this.annotationEditorLayer.destroy();
            }
            hide() {
              this.div && (this.div.hidden = !0);
            }
            show() {
              !this.div || this.annotationEditorLayer.isInvisible || (this.div.hidden = !1);
            }
          }
          d();
        } catch (h) {
          d(h);
        }
      });
    }
  ),
  /***/
  707: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            AnnotationLayerBuilder: () => (
              /* binding */
              h
            )
            /* harmony export */
          });
          var a = n(603), U = n(256), V = e([a]);
          a = (V.then ? (await V)() : V)[0];
          class h {
            #l = null;
            #t = null;
            constructor({
              pdfPage: Z,
              linkService: s,
              downloadManager: o,
              annotationStorage: F = null,
              imageResourcesPath: N = "",
              renderForms: Q = !0,
              enableScripting: u = !1,
              hasJSActionsPromise: i = null,
              fieldObjectsPromise: c = null,
              annotationCanvasMap: R = null,
              accessibilityManager: m = null,
              annotationEditorUIManager: M = null,
              onAppend: S = null
            }) {
              this.pdfPage = Z, this.linkService = s, this.downloadManager = o, this.imageResourcesPath = N, this.renderForms = Q, this.annotationStorage = F, this.enableScripting = u, this._hasJSActionsPromise = i || Promise.resolve(!1), this._fieldObjectsPromise = c || Promise.resolve(null), this._annotationCanvasMap = R, this._accessibilityManager = m, this._annotationEditorUIManager = M, this.#l = S, this.annotationLayer = null, this.div = null, this._cancelled = !1, this._eventBus = s.eventBus;
            }
            async render(Z, s = "display") {
              if (this.div) {
                if (this._cancelled || !this.annotationLayer)
                  return;
                this.annotationLayer.update({
                  viewport: Z.clone({
                    dontFlip: !0
                  })
                });
                return;
              }
              const [o, F, N] = await Promise.all([this.pdfPage.getAnnotations({
                intent: s
              }), this._hasJSActionsPromise, this._fieldObjectsPromise]);
              if (this._cancelled)
                return;
              const Q = this.div = document.createElement("div");
              if (Q.className = "annotationLayer", this.#l?.(Q), o.length === 0) {
                this.hide();
                return;
              }
              this.annotationLayer = new a.AnnotationLayer({
                div: Q,
                accessibilityManager: this._accessibilityManager,
                annotationCanvasMap: this._annotationCanvasMap,
                annotationEditorUIManager: this._annotationEditorUIManager,
                page: this.pdfPage,
                viewport: Z.clone({
                  dontFlip: !0
                })
              }), await this.annotationLayer.render({
                annotations: o,
                imageResourcesPath: this.imageResourcesPath,
                renderForms: this.renderForms,
                linkService: this.linkService,
                downloadManager: this.downloadManager,
                annotationStorage: this.annotationStorage,
                enableScripting: this.enableScripting,
                hasJSActions: F,
                fieldObjects: N
              }), this.linkService.isInPresentationMode && this.#n(U.PresentationModeState.FULLSCREEN), this.#t || (this.#t = new AbortController(), this._eventBus?._on("presentationmodechanged", (u) => {
                this.#n(u.state);
              }, {
                signal: this.#t.signal
              }));
            }
            cancel() {
              this._cancelled = !0, this.#t?.abort(), this.#t = null;
            }
            hide() {
              this.div && (this.div.hidden = !0);
            }
            #n(Z) {
              if (!this.div)
                return;
              let s = !1;
              switch (Z) {
                case U.PresentationModeState.FULLSCREEN:
                  s = !0;
                  break;
                case U.PresentationModeState.NORMAL:
                  break;
                default:
                  return;
              }
              for (const o of this.div.childNodes)
                o.hasAttribute("data-internal-link") || (o.inert = s);
            }
          }
          d();
        } catch (h) {
          d(h);
        }
      });
    }
  ),
  /***/
  840: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        AppOptions: () => (
          /* binding */
          V
        )
        /* harmony export */
      });
      {
        var e = /* @__PURE__ */ Object.create(null);
        const h = navigator.userAgent || "", W = navigator.platform || "", Z = navigator.maxTouchPoints || 1, s = /Android/.test(h), o = /\b(iPad|iPhone|iPod)(?=;)/.test(h) || W === "MacIntel" && Z > 1;
        (function() {
          (o || s) && (e.maxCanvasPixels = 5242880);
        })();
      }
      const d = {
        BROWSER: 1,
        VIEWER: 2,
        API: 4,
        WORKER: 8,
        PREFERENCE: 128
      }, a = {
        canvasMaxAreaInBytes: {
          value: -1,
          kind: d.BROWSER + d.API
        },
        isInAutomation: {
          value: !1,
          kind: d.BROWSER
        },
        supportsCaretBrowsingMode: {
          value: !1,
          kind: d.BROWSER
        },
        supportsDocumentFonts: {
          value: !0,
          kind: d.BROWSER
        },
        supportsIntegratedFind: {
          value: !1,
          kind: d.BROWSER
        },
        supportsMouseWheelZoomCtrlKey: {
          value: !0,
          kind: d.BROWSER
        },
        supportsMouseWheelZoomMetaKey: {
          value: !0,
          kind: d.BROWSER
        },
        supportsPinchToZoom: {
          value: !0,
          kind: d.BROWSER
        },
        annotationEditorMode: {
          value: 0,
          kind: d.VIEWER + d.PREFERENCE
        },
        annotationMode: {
          value: 2,
          kind: d.VIEWER + d.PREFERENCE
        },
        cursorToolOnLoad: {
          value: 0,
          kind: d.VIEWER + d.PREFERENCE
        },
        debuggerSrc: {
          value: "./debugger.mjs",
          kind: d.VIEWER
        },
        defaultZoomDelay: {
          value: 400,
          kind: d.VIEWER + d.PREFERENCE
        },
        defaultZoomValue: {
          value: "",
          kind: d.VIEWER + d.PREFERENCE
        },
        disableHistory: {
          value: !1,
          kind: d.VIEWER
        },
        disablePageLabels: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        enableHighlightEditor: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        enableHighlightFloatingButton: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        enableML: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        enablePermissions: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        enablePrintAutoRotate: {
          value: !0,
          kind: d.VIEWER + d.PREFERENCE
        },
        enableScripting: {
          value: !0,
          kind: d.VIEWER + d.PREFERENCE
        },
        enableStampEditor: {
          value: !0,
          kind: d.VIEWER + d.PREFERENCE
        },
        externalLinkRel: {
          value: "noopener noreferrer nofollow",
          kind: d.VIEWER
        },
        externalLinkTarget: {
          value: 0,
          kind: d.VIEWER + d.PREFERENCE
        },
        highlightEditorColors: {
          value: "yellow=#FFFF98,green=#53FFBC,blue=#80EBFF,pink=#FFCBE6,red=#FF4F5F",
          kind: d.VIEWER + d.PREFERENCE
        },
        historyUpdateUrl: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        ignoreDestinationZoom: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        imageResourcesPath: {
          value: "./images/",
          kind: d.VIEWER
        },
        maxCanvasPixels: {
          value: 2 ** 25,
          kind: d.VIEWER
        },
        forcePageColors: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        pageColorsBackground: {
          value: "Canvas",
          kind: d.VIEWER + d.PREFERENCE
        },
        pageColorsForeground: {
          value: "CanvasText",
          kind: d.VIEWER + d.PREFERENCE
        },
        pdfBugEnabled: {
          value: !1,
          kind: d.VIEWER + d.PREFERENCE
        },
        printResolution: {
          value: 150,
          kind: d.VIEWER
        },
        sidebarViewOnLoad: {
          value: -1,
          kind: d.VIEWER + d.PREFERENCE
        },
        scrollModeOnLoad: {
          value: -1,
          kind: d.VIEWER + d.PREFERENCE
        },
        spreadModeOnLoad: {
          value: -1,
          kind: d.VIEWER + d.PREFERENCE
        },
        textLayerMode: {
          value: 1,
          kind: d.VIEWER + d.PREFERENCE
        },
        viewOnLoad: {
          value: 0,
          kind: d.VIEWER + d.PREFERENCE
        },
        cMapPacked: {
          value: !0,
          kind: d.API
        },
        cMapUrl: {
          value: "../web/cmaps/",
          kind: d.API
        },
        disableAutoFetch: {
          value: !1,
          kind: d.API + d.PREFERENCE
        },
        disableFontFace: {
          value: !1,
          kind: d.API + d.PREFERENCE
        },
        disableRange: {
          value: !1,
          kind: d.API + d.PREFERENCE
        },
        disableStream: {
          value: !1,
          kind: d.API + d.PREFERENCE
        },
        docBaseUrl: {
          value: "",
          kind: d.API
        },
        enableXfa: {
          value: !0,
          kind: d.API + d.PREFERENCE
        },
        fontExtraProperties: {
          value: !1,
          kind: d.API
        },
        isEvalSupported: {
          value: !0,
          kind: d.API
        },
        isOffscreenCanvasSupported: {
          value: !0,
          kind: d.API
        },
        maxImageSize: {
          value: -1,
          kind: d.API
        },
        pdfBug: {
          value: !1,
          kind: d.API
        },
        standardFontDataUrl: {
          value: "../web/standard_fonts/",
          kind: d.API
        },
        verbosity: {
          value: 1,
          kind: d.API
        },
        workerPort: {
          value: null,
          kind: d.WORKER
        },
        workerSrc: {
          value: "../build/pdf.worker.mjs",
          kind: d.WORKER
        }
      };
      a.defaultUrl = {
        value: "compressed.tracemonkey-pldi-09.pdf",
        kind: d.VIEWER
      }, a.sandboxBundleSrc = {
        value: "../build/pdf.sandbox.mjs",
        kind: d.VIEWER
      }, a.viewerCssTheme = {
        value: 0,
        kind: d.VIEWER + d.PREFERENCE
      }, a.disablePreferences = {
        value: !1,
        kind: d.VIEWER
      }, a.locale = {
        value: navigator.language || "en-US",
        kind: d.VIEWER
      };
      const U = /* @__PURE__ */ Object.create(null);
      for (const h in e)
        U[h] = e[h];
      class V {
        constructor() {
          throw new Error("Cannot initialize AppOptions.");
        }
        static get(W) {
          return U[W] ?? a[W]?.value ?? void 0;
        }
        static getAll(W = null, Z = !1) {
          const s = /* @__PURE__ */ Object.create(null);
          for (const o in a) {
            const F = a[o];
            W && !(W & F.kind) || (s[o] = Z ? F.value : U[o] ?? F.value);
          }
          return s;
        }
        static set(W, Z) {
          U[W] = Z;
        }
        static setAll(W, Z = !1) {
          if (Z) {
            if (this.get("disablePreferences"))
              return;
            for (const s in U)
              if (e[s] === void 0) {
                console.warn('setAll: The Preferences may override manually set AppOptions; please use the "disablePreferences"-option in order to prevent that.');
                break;
              }
          }
          for (const s in W)
            U[s] = W[s];
        }
        static remove(W) {
          delete U[W];
          const Z = e[W];
          Z !== void 0 && (U[W] = Z);
        }
      }
    }
  ),
  /***/
  544: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          let V = function(W, Z) {
            const s = document.createElement("a");
            if (!s.click)
              throw new Error('DownloadManager: "a.click()" is not supported.');
            s.href = W, s.target = "_parent", "download" in s && (s.download = Z), (document.body || document.documentElement).append(s), s.click(), s.remove();
          };
          n.d(t, {
            /* harmony export */
            DownloadManager: () => (
              /* binding */
              h
            )
            /* harmony export */
          });
          var a = n(603), U = e([a]);
          a = (U.then ? (await U)() : U)[0];
          class h {
            #l = /* @__PURE__ */ new WeakMap();
            downloadUrl(Z, s, o) {
              if (!(0, a.createValidAbsoluteUrl)(Z, "http://example.com")) {
                console.error(`downloadUrl - not a valid URL: ${Z}`);
                return;
              }
              V(Z + "#pdfjs.action=download", s);
            }
            downloadData(Z, s, o) {
              const F = URL.createObjectURL(new Blob([Z], {
                type: o
              }));
              V(F, s);
            }
            openOrDownloadData(Z, s, o = null) {
              const N = (0, a.isPdfFile)(s) ? "application/pdf" : "";
              return this.downloadData(Z, s, N), !1;
            }
            download(Z, s, o, F) {
              const N = URL.createObjectURL(Z);
              V(N, o);
            }
          }
          d();
        } catch (V) {
          d(V);
        }
      });
    }
  ),
  /***/
  88: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            DrawLayerBuilder: () => (
              /* binding */
              V
            )
            /* harmony export */
          });
          var a = n(603), U = e([a]);
          a = (U.then ? (await U)() : U)[0];
          class V {
            #l = null;
            constructor(W) {
              this.pageIndex = W.pageIndex;
            }
            async render(W = "display") {
              W !== "display" || this.#l || this._cancelled || (this.#l = new a.DrawLayer({
                pageIndex: this.pageIndex
              }));
            }
            cancel() {
              this._cancelled = !0, this.#l && (this.#l.destroy(), this.#l = null);
            }
            setParent(W) {
              this.#l?.setParent(W);
            }
            getDrawLayer() {
              return this.#l;
            }
          }
          d();
        } catch (V) {
          d(V);
        }
      });
    }
  ),
  /***/
  656: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        EventBus: () => (
          /* binding */
          a
        ),
        /* harmony export */
        waitOnEventOrTimeout: () => (
          /* binding */
          d
        )
        /* harmony export */
      });
      const e = {
        EVENT: "event",
        TIMEOUT: "timeout"
      };
      async function d({
        target: U,
        name: V,
        delay: h = 0
      }) {
        if (typeof U != "object" || !(V && typeof V == "string") || !(Number.isInteger(h) && h >= 0))
          throw new Error("waitOnEventOrTimeout - invalid parameters.");
        const {
          promise: W,
          resolve: Z
        } = Promise.withResolvers(), s = new AbortController();
        function o(Q) {
          s.abort(), clearTimeout(N), Z(Q);
        }
        const F = U instanceof a ? "_on" : "addEventListener";
        U[F](V, o.bind(null, e.EVENT), {
          signal: s.signal
        });
        const N = setTimeout(o.bind(null, e.TIMEOUT), h);
        return W;
      }
      class a {
        #l = /* @__PURE__ */ Object.create(null);
        on(V, h, W = null) {
          this._on(V, h, {
            external: !0,
            once: W?.once,
            signal: W?.signal
          });
        }
        off(V, h, W = null) {
          this._off(V, h);
        }
        dispatch(V, h) {
          const W = this.#l[V];
          if (!W || W.length === 0)
            return;
          let Z;
          for (const {
            listener: s,
            external: o,
            once: F
          } of W.slice(0)) {
            if (F && this._off(V, s), o) {
              (Z ||= []).push(s);
              continue;
            }
            s(h);
          }
          if (Z) {
            for (const s of Z)
              s(h);
            Z = null;
          }
        }
        _on(V, h, W = null) {
          let Z = null;
          if (W?.signal instanceof AbortSignal) {
            const {
              signal: o
            } = W;
            if (o.aborted) {
              console.error("Cannot use an `aborted` signal.");
              return;
            }
            const F = () => this._off(V, h);
            Z = () => o.removeEventListener("abort", F), o.addEventListener("abort", F);
          }
          (this.#l[V] ||= []).push({
            listener: h,
            external: W?.external === !0,
            once: W?.once === !0,
            rmAbort: Z
          });
        }
        _off(V, h, W = null) {
          const Z = this.#l[V];
          if (Z)
            for (let s = 0, o = Z.length; s < o; s++) {
              const F = Z[s];
              if (F.listener === h) {
                F.rmAbort?.(), Z.splice(s, 1);
                return;
              }
            }
        }
      }
    }
  ),
  /***/
  289: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            GenericScripting: () => (
              /* binding */
              h
            ),
            /* harmony export */
            docProperties: () => (
              /* binding */
              V
            )
            /* harmony export */
          });
          var a = n(603), U = e([a]);
          a = (U.then ? (await U)() : U)[0];
          async function V(W) {
            const Z = "", s = Z.split("#", 1)[0];
            let {
              info: o,
              metadata: F,
              contentDispositionFilename: N,
              contentLength: Q
            } = await W.getMetadata();
            if (!Q) {
              const {
                length: u
              } = await W.getDownloadInfo();
              Q = u;
            }
            return {
              ...o,
              baseURL: s,
              filesize: Q,
              filename: N || (0, a.getPdfFilenameFromUrl)(Z),
              metadata: F?.getRaw(),
              authors: F?.get("dc:creator"),
              numPages: W.numPages,
              URL: Z
            };
          }
          class h {
            constructor(Z) {
              this._ready = new Promise((s, o) => {
                import(
                  /*webpackIgnore: true*/
                  Z
                ).then((N) => {
                  s(N.QuickJSSandbox());
                }).catch(o);
              });
            }
            async createSandbox(Z) {
              (await this._ready).create(Z);
            }
            async dispatchEventInSandbox(Z) {
              const s = await this._ready;
              setTimeout(() => s.dispatchEvent(Z), 0);
            }
            async destroySandbox() {
              (await this._ready).nukeSandbox();
            }
          }
          d();
        } catch (V) {
          d(V);
        }
      });
    }
  ),
  /***/
  410: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          let Z = function(o, F) {
            const N = new a.FluentResource(F), Q = new a.FluentBundle(o), u = Q.addResource(N);
            return u.length && console.error("L10n errors", u), Q;
          };
          n.d(t, {
            /* harmony export */
            GenericL10n: () => (
              /* binding */
              s
            )
            /* harmony export */
          });
          var a = n(588), U = n(273), V = n(603), h = n(693), W = e([V]);
          V = (W.then ? (await W)() : W)[0];
          class s extends h.L10n {
            constructor(F) {
              super({
                lang: F
              });
              const N = F ? s.#l.bind(s, "en-us", this.getLanguage()) : s.#d.bind(s, this.getLanguage());
              this._setL10n(new U.DOMLocalization([], N));
            }
            static async *#l(F, N) {
              const {
                baseURL: Q,
                paths: u
              } = await this.#n(), i = [N];
              if (F !== N) {
                const c = N.split("-", 1)[0];
                c !== N && i.push(c), i.push(F);
              }
              for (const c of i) {
                const R = await this.#t(c, Q, u);
                R && (yield R), c === "en-us" && (yield this.#a(c));
              }
            }
            static async #t(F, N, Q) {
              const u = Q[F];
              if (!u)
                return null;
              const i = new URL(u, N), c = await (0, V.fetchData)(i, "text");
              return Z(F, c);
            }
            static async #n() {
              try {
                const {
                  href: F
                } = document.querySelector('link[type="application/l10n"]'), N = await (0, V.fetchData)(F, "json");
                return {
                  baseURL: F.replace(/[^/]*$/, "") || "./",
                  paths: N
                };
              } catch {
              }
              return {
                baseURL: "./",
                paths: /* @__PURE__ */ Object.create(null)
              };
            }
            static async *#d(F) {
              yield this.#a(F);
            }
            static async #a(F) {
              return Z(F, `pdfjs-previous-button =
    .title = Previous Page
pdfjs-previous-button-label = Previous
pdfjs-next-button =
    .title = Next Page
pdfjs-next-button-label = Next
pdfjs-page-input =
    .title = Page
pdfjs-of-pages = of { $pagesCount }
pdfjs-page-of-pages = ({ $pageNumber } of { $pagesCount })
pdfjs-zoom-out-button =
    .title = Zoom Out
pdfjs-zoom-out-button-label = Zoom Out
pdfjs-zoom-in-button =
    .title = Zoom In
pdfjs-zoom-in-button-label = Zoom In
pdfjs-zoom-select =
    .title = Zoom
pdfjs-presentation-mode-button =
    .title = Switch to Presentation Mode
pdfjs-presentation-mode-button-label = Presentation Mode
pdfjs-open-file-button =
    .title = Open File
pdfjs-open-file-button-label = Open
pdfjs-print-button =
    .title = Print
pdfjs-print-button-label = Print
pdfjs-save-button =
    .title = Save
pdfjs-save-button-label = Save
pdfjs-download-button =
    .title = Download
pdfjs-download-button-label = Download
pdfjs-bookmark-button =
    .title = Current Page (View URL from Current Page)
pdfjs-bookmark-button-label = Current Page
pdfjs-tools-button =
    .title = Tools
pdfjs-tools-button-label = Tools
pdfjs-first-page-button =
    .title = Go to First Page
pdfjs-first-page-button-label = Go to First Page
pdfjs-last-page-button =
    .title = Go to Last Page
pdfjs-last-page-button-label = Go to Last Page
pdfjs-page-rotate-cw-button =
    .title = Rotate Clockwise
pdfjs-page-rotate-cw-button-label = Rotate Clockwise
pdfjs-page-rotate-ccw-button =
    .title = Rotate Counterclockwise
pdfjs-page-rotate-ccw-button-label = Rotate Counterclockwise
pdfjs-cursor-text-select-tool-button =
    .title = Enable Text Selection Tool
pdfjs-cursor-text-select-tool-button-label = Text Selection Tool
pdfjs-cursor-hand-tool-button =
    .title = Enable Hand Tool
pdfjs-cursor-hand-tool-button-label = Hand Tool
pdfjs-scroll-page-button =
    .title = Use Page Scrolling
pdfjs-scroll-page-button-label = Page Scrolling
pdfjs-scroll-vertical-button =
    .title = Use Vertical Scrolling
pdfjs-scroll-vertical-button-label = Vertical Scrolling
pdfjs-scroll-horizontal-button =
    .title = Use Horizontal Scrolling
pdfjs-scroll-horizontal-button-label = Horizontal Scrolling
pdfjs-scroll-wrapped-button =
    .title = Use Wrapped Scrolling
pdfjs-scroll-wrapped-button-label = Wrapped Scrolling
pdfjs-spread-none-button =
    .title = Do not join page spreads
pdfjs-spread-none-button-label = No Spreads
pdfjs-spread-odd-button =
    .title = Join page spreads starting with odd-numbered pages
pdfjs-spread-odd-button-label = Odd Spreads
pdfjs-spread-even-button =
    .title = Join page spreads starting with even-numbered pages
pdfjs-spread-even-button-label = Even Spreads
pdfjs-document-properties-button =
    .title = Document Properties…
pdfjs-document-properties-button-label = Document Properties…
pdfjs-document-properties-file-name = File name:
pdfjs-document-properties-file-size = File size:
pdfjs-document-properties-kb = { $size_kb } KB ({ $size_b } bytes)
pdfjs-document-properties-mb = { $size_mb } MB ({ $size_b } bytes)
pdfjs-document-properties-title = Title:
pdfjs-document-properties-author = Author:
pdfjs-document-properties-subject = Subject:
pdfjs-document-properties-keywords = Keywords:
pdfjs-document-properties-creation-date = Creation Date:
pdfjs-document-properties-modification-date = Modification Date:
pdfjs-document-properties-date-string = { $date }, { $time }
pdfjs-document-properties-creator = Creator:
pdfjs-document-properties-producer = PDF Producer:
pdfjs-document-properties-version = PDF Version:
pdfjs-document-properties-page-count = Page Count:
pdfjs-document-properties-page-size = Page Size:
pdfjs-document-properties-page-size-unit-inches = in
pdfjs-document-properties-page-size-unit-millimeters = mm
pdfjs-document-properties-page-size-orientation-portrait = portrait
pdfjs-document-properties-page-size-orientation-landscape = landscape
pdfjs-document-properties-page-size-name-a-three = A3
pdfjs-document-properties-page-size-name-a-four = A4
pdfjs-document-properties-page-size-name-letter = Letter
pdfjs-document-properties-page-size-name-legal = Legal
pdfjs-document-properties-page-size-dimension-string = { $width } × { $height } { $unit } ({ $orientation })
pdfjs-document-properties-page-size-dimension-name-string = { $width } × { $height } { $unit } ({ $name }, { $orientation })
pdfjs-document-properties-linearized = Fast Web View:
pdfjs-document-properties-linearized-yes = Yes
pdfjs-document-properties-linearized-no = No
pdfjs-document-properties-close-button = Close
pdfjs-print-progress-message = Preparing document for printing…
pdfjs-print-progress-percent = { $progress }%
pdfjs-print-progress-close-button = Cancel
pdfjs-printing-not-supported = Warning: Printing is not fully supported by this browser.
pdfjs-printing-not-ready = Warning: The PDF is not fully loaded for printing.
pdfjs-toggle-sidebar-button =
    .title = Toggle Sidebar
pdfjs-toggle-sidebar-notification-button =
    .title = Toggle Sidebar (document contains outline/attachments/layers)
pdfjs-toggle-sidebar-button-label = Toggle Sidebar
pdfjs-document-outline-button =
    .title = Show Document Outline (double-click to expand/collapse all items)
pdfjs-document-outline-button-label = Document Outline
pdfjs-attachments-button =
    .title = Show Attachments
pdfjs-attachments-button-label = Attachments
pdfjs-layers-button =
    .title = Show Layers (double-click to reset all layers to the default state)
pdfjs-layers-button-label = Layers
pdfjs-thumbs-button =
    .title = Show Thumbnails
pdfjs-thumbs-button-label = Thumbnails
pdfjs-current-outline-item-button =
    .title = Find Current Outline Item
pdfjs-current-outline-item-button-label = Current Outline Item
pdfjs-findbar-button =
    .title = Find in Document
pdfjs-findbar-button-label = Find
pdfjs-additional-layers = Additional Layers
pdfjs-thumb-page-title =
    .title = Page { $page }
pdfjs-thumb-page-canvas =
    .aria-label = Thumbnail of Page { $page }
pdfjs-find-input =
    .title = Find
    .placeholder = Find in document…
pdfjs-find-previous-button =
    .title = Find the previous occurrence of the phrase
pdfjs-find-previous-button-label = Previous
pdfjs-find-next-button =
    .title = Find the next occurrence of the phrase
pdfjs-find-next-button-label = Next
pdfjs-find-highlight-checkbox = Highlight All
pdfjs-find-match-case-checkbox-label = Match Case
pdfjs-find-match-diacritics-checkbox-label = Match Diacritics
pdfjs-find-entire-word-checkbox-label = Whole Words
pdfjs-find-reached-top = Reached top of document, continued from bottom
pdfjs-find-reached-bottom = Reached end of document, continued from top
pdfjs-find-match-count =
    { $total ->
        [one] { $current } of { $total } match
       *[other] { $current } of { $total } matches
    }
pdfjs-find-match-count-limit =
    { $limit ->
        [one] More than { $limit } match
       *[other] More than { $limit } matches
    }
pdfjs-find-not-found = Phrase not found
pdfjs-page-scale-width = Page Width
pdfjs-page-scale-fit = Page Fit
pdfjs-page-scale-auto = Automatic Zoom
pdfjs-page-scale-actual = Actual Size
pdfjs-page-scale-percent = { $scale }%
pdfjs-page-landmark =
    .aria-label = Page { $page }
pdfjs-loading-error = An error occurred while loading the PDF.
pdfjs-invalid-file-error = Invalid or corrupted PDF file.
pdfjs-missing-file-error = Missing PDF file.
pdfjs-unexpected-response-error = Unexpected server response.
pdfjs-rendering-error = An error occurred while rendering the page.
pdfjs-annotation-date-string = { $date }, { $time }
pdfjs-text-annotation-type =
    .alt = [{ $type } Annotation]
pdfjs-password-label = Enter the password to open this PDF file.
pdfjs-password-invalid = Invalid password. Please try again.
pdfjs-password-ok-button = OK
pdfjs-password-cancel-button = Cancel
pdfjs-web-fonts-disabled = Web fonts are disabled: unable to use embedded PDF fonts.
pdfjs-editor-free-text-button =
    .title = Text
pdfjs-editor-free-text-button-label = Text
pdfjs-editor-ink-button =
    .title = Draw
pdfjs-editor-ink-button-label = Draw
pdfjs-editor-stamp-button =
    .title = Add or edit images
pdfjs-editor-stamp-button-label = Add or edit images
pdfjs-editor-highlight-button =
    .title = Highlight
pdfjs-editor-highlight-button-label = Highlight
pdfjs-highlight-floating-button1 =
    .title = Highlight
    .aria-label = Highlight
pdfjs-highlight-floating-button-label = Highlight
pdfjs-editor-remove-ink-button =
    .title = Remove drawing
pdfjs-editor-remove-freetext-button =
    .title = Remove text
pdfjs-editor-remove-stamp-button =
    .title = Remove image
pdfjs-editor-remove-highlight-button =
    .title = Remove highlight
pdfjs-editor-free-text-color-input = Color
pdfjs-editor-free-text-size-input = Size
pdfjs-editor-ink-color-input = Color
pdfjs-editor-ink-thickness-input = Thickness
pdfjs-editor-ink-opacity-input = Opacity
pdfjs-editor-stamp-add-image-button =
    .title = Add image
pdfjs-editor-stamp-add-image-button-label = Add image
pdfjs-editor-free-highlight-thickness-input = Thickness
pdfjs-editor-free-highlight-thickness-title =
    .title = Change thickness when highlighting items other than text
pdfjs-free-text =
    .aria-label = Text Editor
pdfjs-free-text-default-content = Start typing…
pdfjs-ink =
    .aria-label = Draw Editor
pdfjs-ink-canvas =
    .aria-label = User-created image
pdfjs-editor-alt-text-button-label = Alt text
pdfjs-editor-alt-text-edit-button-label = Edit alt text
pdfjs-editor-alt-text-dialog-label = Choose an option
pdfjs-editor-alt-text-dialog-description = Alt text (alternative text) helps when people can’t see the image or when it doesn’t load.
pdfjs-editor-alt-text-add-description-label = Add a description
pdfjs-editor-alt-text-add-description-description = Aim for 1-2 sentences that describe the subject, setting, or actions.
pdfjs-editor-alt-text-mark-decorative-label = Mark as decorative
pdfjs-editor-alt-text-mark-decorative-description = This is used for ornamental images, like borders or watermarks.
pdfjs-editor-alt-text-cancel-button = Cancel
pdfjs-editor-alt-text-save-button = Save
pdfjs-editor-alt-text-decorative-tooltip = Marked as decorative
pdfjs-editor-alt-text-textarea =
    .placeholder = For example, “A young man sits down at a table to eat a meal”
pdfjs-editor-resizer-label-top-left = Top left corner — resize
pdfjs-editor-resizer-label-top-middle = Top middle — resize
pdfjs-editor-resizer-label-top-right = Top right corner — resize
pdfjs-editor-resizer-label-middle-right = Middle right — resize
pdfjs-editor-resizer-label-bottom-right = Bottom right corner — resize
pdfjs-editor-resizer-label-bottom-middle = Bottom middle — resize
pdfjs-editor-resizer-label-bottom-left = Bottom left corner — resize
pdfjs-editor-resizer-label-middle-left = Middle left — resize
pdfjs-editor-highlight-colorpicker-label = Highlight color
pdfjs-editor-colorpicker-button =
    .title = Change color
pdfjs-editor-colorpicker-dropdown =
    .aria-label = Color choices
pdfjs-editor-colorpicker-yellow =
    .title = Yellow
pdfjs-editor-colorpicker-green =
    .title = Green
pdfjs-editor-colorpicker-blue =
    .title = Blue
pdfjs-editor-colorpicker-pink =
    .title = Pink
pdfjs-editor-colorpicker-red =
    .title = Red
pdfjs-editor-highlight-show-all-button-label = Show all
pdfjs-editor-highlight-show-all-button =
    .title = Show all`);
            }
          }
          d();
        } catch (Z) {
          d(Z);
        }
      });
    }
  ),
  /***/
  693: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        L10n: () => (
          /* binding */
          e
        )
        /* harmony export */
      });
      class e {
        #l;
        #t;
        #n;
        constructor({
          lang: a,
          isRTL: U
        }, V = null) {
          this.#t = e.#d(a), this.#n = V, this.#l = U ?? e.#a(this.#t) ? "rtl" : "ltr";
        }
        _setL10n(a) {
          this.#n = a;
        }
        getLanguage() {
          return this.#t;
        }
        getDirection() {
          return this.#l;
        }
        async get(a, U = null, V) {
          return Array.isArray(a) ? (a = a.map((Z) => ({
            id: Z
          })), (await this.#n.formatMessages(a)).map((Z) => Z.value)) : (await this.#n.formatMessages([{
            id: a,
            args: U
          }]))?.[0].value || V;
        }
        async translate(a) {
          try {
            this.#n.connectRoot(a), await this.#n.translateRoots();
          } catch {
          }
        }
        pause() {
          this.#n.pauseObserving();
        }
        resume() {
          this.#n.resumeObserving();
        }
        static #d(a) {
          return a = a?.toLowerCase() || "en-us", {
            en: "en-us",
            es: "es-es",
            fy: "fy-nl",
            ga: "ga-ie",
            gu: "gu-in",
            hi: "hi-in",
            hy: "hy-am",
            nb: "nb-no",
            ne: "ne-np",
            nn: "nn-no",
            pa: "pa-in",
            pt: "pt-pt",
            sv: "sv-se",
            zh: "zh-cn"
          }[a] || a;
        }
        static #a(a) {
          const U = a.split("-", 1)[0];
          return ["ar", "he", "fa", "ps", "ur"].includes(U);
        }
      }
    }
  ),
  /***/
  814: (
    /***/
    (l, t, n) => {
      n.d(t, {
        FindState: () => (
          /* binding */
          c
        ),
        PDFFindController: () => (
          /* binding */
          il
        )
      });
      var e = n(256);
      const d = {
        SPACE: 0,
        ALPHA_LETTER: 1,
        PUNCT: 2,
        HAN_LETTER: 3,
        KATAKANA_LETTER: 4,
        HIRAGANA_LETTER: 5,
        HALFWIDTH_KATAKANA_LETTER: 6,
        THAI_LETTER: 7
      };
      function a(dl) {
        return dl < 11904;
      }
      function U(dl) {
        return (dl & 65408) === 0;
      }
      function V(dl) {
        return dl >= 97 && dl <= 122 || dl >= 65 && dl <= 90;
      }
      function h(dl) {
        return dl >= 48 && dl <= 57;
      }
      function W(dl) {
        return dl === 32 || dl === 9 || dl === 13 || dl === 10;
      }
      function Z(dl) {
        return dl >= 13312 && dl <= 40959 || dl >= 63744 && dl <= 64255;
      }
      function s(dl) {
        return dl >= 12448 && dl <= 12543;
      }
      function o(dl) {
        return dl >= 12352 && dl <= 12447;
      }
      function F(dl) {
        return dl >= 65376 && dl <= 65439;
      }
      function N(dl) {
        return (dl & 65408) === 3584;
      }
      function Q(dl) {
        return a(dl) ? U(dl) ? W(dl) ? d.SPACE : V(dl) || h(dl) || dl === 95 ? d.ALPHA_LETTER : d.PUNCT : N(dl) ? d.THAI_LETTER : dl === 160 ? d.SPACE : d.ALPHA_LETTER : Z(dl) ? d.HAN_LETTER : s(dl) ? d.KATAKANA_LETTER : o(dl) ? d.HIRAGANA_LETTER : F(dl) ? d.HALFWIDTH_KATAKANA_LETTER : d.ALPHA_LETTER;
      }
      let u;
      function i() {
        return u ||= " ¨ª¯²-µ¸-º¼-¾Ĳ-ĳĿ-ŀŉſǄ-ǌǱ-ǳʰ-ʸ˘-˝ˠ-ˤʹͺ;΄-΅·ϐ-ϖϰ-ϲϴ-ϵϹևٵ-ٸक़-य़ড়-ঢ়য়ਲ਼ਸ਼ਖ਼-ਜ਼ਫ਼ଡ଼-ଢ଼ำຳໜ-ໝ༌གྷཌྷདྷབྷཛྷཀྵჼᴬ-ᴮᴰ-ᴺᴼ-ᵍᵏ-ᵪᵸᶛ-ᶿẚ-ẛάέήίόύώΆ᾽-῁ΈΉ῍-῏ΐΊ῝-῟ΰΎ῭-`ΌΏ´-῾ - ‑‗․-… ″-‴‶-‷‼‾⁇-⁉⁗ ⁰-ⁱ⁴-₎ₐ-ₜ₨℀-℃℅-ℇ℉-ℓℕ-№ℙ-ℝ℠-™ℤΩℨK-ℭℯ-ℱℳ-ℹ℻-⅀ⅅ-ⅉ⅐-ⅿ↉∬-∭∯-∰〈-〉①-⓪⨌⩴-⩶⫝̸ⱼ-ⱽⵯ⺟⻳⼀-⿕　〶〸-〺゛-゜ゟヿㄱ-ㆎ㆒-㆟㈀-㈞㈠-㉇㉐-㉾㊀-㏿ꚜ-ꚝꝰꟲ-ꟴꟸ-ꟹꭜ-ꭟꭩ豈-嗀塚晴凞-羽蘒諸逸-都飯-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-זּטּ-לּמּנּ-סּףּ-פּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-﷼︐-︙︰-﹄﹇-﹒﹔-﹦﹨-﹫ﹰ-ﹲﹴﹶ-ﻼ！-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ￠-￦", u;
      }
      const c = {
        FOUND: 0,
        NOT_FOUND: 1,
        WRAPPED: 2,
        PENDING: 3
      }, R = 250, m = -50, M = -400, S = {
        "‐": "-",
        "‘": "'",
        "’": "'",
        "‚": "'",
        "‛": "'",
        "“": '"',
        "”": '"',
        "„": '"',
        "‟": '"',
        "¼": "1/4",
        "½": "1/2",
        "¾": "3/4"
      }, p = /* @__PURE__ */ new Set([12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642, 3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968, 3956]);
      let Y;
      const k = /\p{M}+/gu, L = /([.*+?^${}()|[\]\\])|(\p{P})|(\s+)|(\p{M})|(\p{L})/gu, z = /([^\p{M}])\p{M}*$/u, f = /^\p{M}*([^\p{M}])/u, K = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g, P = /* @__PURE__ */ new Map(), w = "[\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f]", O = /* @__PURE__ */ new Map();
      let el = null, ll = null;
      function q(dl) {
        const tl = [];
        let al;
        for (; (al = K.exec(dl)) !== null; ) {
          let {
            index: I
          } = al;
          for (const E of al[0]) {
            let x = P.get(E);
            x || (x = E.normalize("NFD").length, P.set(E, x)), tl.push([x, I++]);
          }
        }
        let Ul;
        if (tl.length === 0 && el)
          Ul = el;
        else if (tl.length > 0 && ll)
          Ul = ll;
        else {
          const I = Object.keys(S).join(""), E = i(), A = `([${I}])|([${E}])|((?:゙|゚)\\n)|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|((?:\\p{Ideographic}|[぀-ヿ])\\n)|(\\n)`;
          tl.length === 0 ? Ul = el = new RegExp(A + "|(\\u0000)", "gum") : Ul = ll = new RegExp(A + `|(${w})`, "gum");
        }
        const cl = [];
        for (; (al = k.exec(dl)) !== null; )
          cl.push([al[0].length, al.index]);
        let B = dl.normalize("NFD");
        const X = [[0, 0]];
        let b = 0, r = 0, G = 0, J = 0, T = 0, y = !1;
        return B = B.replace(Ul, (I, E, x, v, A, g, D, C, nl, Fl) => {
          if (Fl -= J, E) {
            const sl = S[E], Vl = sl.length;
            for (let Rl = 1; Rl < Vl; Rl++)
              X.push([Fl - G + Rl, G - Rl]);
            return G -= Vl - 1, sl;
          }
          if (x) {
            let sl = O.get(x);
            sl || (sl = x.normalize("NFKC"), O.set(x, sl));
            const Vl = sl.length;
            for (let Rl = 1; Rl < Vl; Rl++)
              X.push([Fl - G + Rl, G - Rl]);
            return G -= Vl - 1, sl;
          }
          if (v)
            return y = !0, Fl + T === cl[b]?.[1] ? ++b : (X.push([Fl - 1 - G + 1, G - 1]), G -= 1, J += 1), X.push([Fl - G + 1, G]), J += 1, T += 1, v.charAt(0);
          if (A) {
            const sl = A.endsWith(`
`), Vl = sl ? A.length - 2 : A.length;
            y = !0;
            let Rl = Vl;
            Fl + T === cl[b]?.[1] && (Rl -= cl[b][0], ++b);
            for (let Wl = 1; Wl <= Rl; Wl++)
              X.push([Fl - 1 - G + Wl, G - Wl]);
            return G -= Rl, J += Rl, sl ? (Fl += Vl - 1, X.push([Fl - G + 1, 1 + G]), G += 1, J += 1, T += 1, A.slice(0, Vl)) : A;
          }
          if (g) {
            const sl = g.length - 2;
            return X.push([Fl - G + sl, 1 + G]), G += 1, J += 1, T += 1, g.slice(0, -2);
          }
          if (D) {
            const sl = D.length - 1;
            return X.push([Fl - G + sl, G]), J += 1, T += 1, D.slice(0, -1);
          }
          if (C)
            return X.push([Fl - G + 1, G - 1]), G -= 1, J += 1, T += 1, " ";
          if (Fl + T === tl[r]?.[1]) {
            const sl = tl[r][0] - 1;
            ++r;
            for (let Vl = 1; Vl <= sl; Vl++)
              X.push([Fl - (G - Vl), G - Vl]);
            G -= sl, J += sl;
          }
          return nl;
        }), X.push([B.length, G]), [B, X, y];
      }
      function _(dl, tl, al) {
        if (!dl)
          return [tl, al];
        const Ul = tl, cl = tl + al - 1;
        let B = (0, e.binarySearchFirstItem)(dl, (J) => J[0] >= Ul);
        dl[B][0] > Ul && --B;
        let X = (0, e.binarySearchFirstItem)(dl, (J) => J[0] >= cl, B);
        dl[X][0] > cl && --X;
        const b = Ul + dl[B][1], G = cl + dl[X][1] + 1 - b;
        return [b, G];
      }
      class il {
        #l = null;
        #t = !0;
        #n = 0;
        constructor({
          linkService: tl,
          eventBus: al,
          updateMatchesCountOnProgress: Ul = !0
        }) {
          this._linkService = tl, this._eventBus = al, this.#t = Ul, this.onIsPageVisible = null, this.#a(), al._on("find", this.#d.bind(this)), al._on("findbarclose", this.#m.bind(this));
        }
        get highlightMatches() {
          return this._highlightMatches;
        }
        get pageMatches() {
          return this._pageMatches;
        }
        get pageMatchesLength() {
          return this._pageMatchesLength;
        }
        get selected() {
          return this._selected;
        }
        get state() {
          return this.#l;
        }
        setDocument(tl) {
          this._pdfDocument && this.#a(), tl && (this._pdfDocument = tl, this._firstPageCapability.resolve());
        }
        #d(tl) {
          if (!tl)
            return;
          const al = this._pdfDocument, {
            type: Ul
          } = tl;
          (this.#l === null || this.#i(tl)) && (this._dirtyMatch = !0), this.#l = tl, Ul !== "highlightallchange" && this.#G(c.PENDING), this._firstPageCapability.promise.then(() => {
            if (!this._pdfDocument || al && this._pdfDocument !== al)
              return;
            this.#F();
            const cl = !this._highlightMatches, B = !!this._findTimeout;
            this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), Ul ? this._dirtyMatch ? this.#W() : Ul === "again" ? (this.#W(), cl && this.#l.highlightAll && this.#Q()) : Ul === "highlightallchange" ? (B ? this.#W() : this._highlightMatches = !0, this.#Q()) : this.#W() : this._findTimeout = setTimeout(() => {
              this.#W(), this._findTimeout = null;
            }, R);
          });
        }
        scrollMatchIntoView({
          element: tl = null,
          selectedLeft: al = 0,
          pageIndex: Ul = -1,
          matchIndex: cl = -1
        }) {
          if (!this._scrollMatches || !tl)
            return;
          if (cl === -1 || cl !== this._selected.matchIdx)
            return;
          if (Ul === -1 || Ul !== this._selected.pageIdx)
            return;
          this._scrollMatches = !1;
          const B = {
            top: m,
            left: al + M
          };
          (0, e.scrollIntoView)(tl, B, !0);
        }
        #a() {
          this._highlightMatches = !1, this._scrollMatches = !1, this._pdfDocument = null, this._pageMatches = [], this._pageMatchesLength = [], this.#n = 0, this.#l = null, this._selected = {
            pageIdx: -1,
            matchIdx: -1
          }, this._offset = {
            pageIdx: null,
            matchIdx: null,
            wrapped: !1
          }, this._extractTextPromises = [], this._pageContents = [], this._pageDiffs = [], this._hasDiacritics = [], this._matchesCountTotal = 0, this._pagesToSearch = null, this._pendingFindMatches = /* @__PURE__ */ new Set(), this._resumePageIdx = null, this._dirtyMatch = !1, clearTimeout(this._findTimeout), this._findTimeout = null, this._firstPageCapability = Promise.withResolvers();
        }
        get #e() {
          const {
            query: tl
          } = this.#l;
          return typeof tl == "string" ? (tl !== this._rawQuery && (this._rawQuery = tl, [this._normalizedQuery] = q(tl)), this._normalizedQuery) : (tl || []).filter((al) => !!al).map((al) => q(al)[0]);
        }
        #i(tl) {
          const al = tl.query, Ul = this.#l.query, cl = typeof al;
          if (cl !== typeof Ul)
            return !0;
          if (cl === "string") {
            if (al !== Ul)
              return !0;
          } else if (JSON.stringify(al) !== JSON.stringify(Ul))
            return !0;
          switch (tl.type) {
            case "again":
              const X = this._selected.pageIdx + 1, b = this._linkService;
              return X >= 1 && X <= b.pagesCount && X !== b.page && !(this.onIsPageVisible?.(X) ?? !0);
            case "highlightallchange":
              return !1;
          }
          return !0;
        }
        #U(tl, al, Ul) {
          let cl = tl.slice(0, al).match(z);
          if (cl) {
            const B = tl.charCodeAt(al), X = cl[1].charCodeAt(0);
            if (Q(B) === Q(X))
              return !1;
          }
          if (cl = tl.slice(al + Ul).match(f), cl) {
            const B = tl.charCodeAt(al + Ul - 1), X = cl[1].charCodeAt(0);
            if (Q(B) === Q(X))
              return !1;
          }
          return !0;
        }
        #c(tl, al, Ul, cl) {
          const B = this._pageMatches[Ul] = [], X = this._pageMatchesLength[Ul] = [];
          if (!tl)
            return;
          const b = this._pageDiffs[Ul];
          let r;
          for (; (r = tl.exec(cl)) !== null; ) {
            if (al && !this.#U(cl, r.index, r[0].length))
              continue;
            const [G, J] = _(b, r.index, r[0].length);
            J && (B.push(G), X.push(J));
          }
        }
        #Z(tl, al) {
          const {
            matchDiacritics: Ul
          } = this.#l;
          let cl = !1;
          tl = tl.replaceAll(L, (X, b, r, G, J, T) => b ? `[ ]*\\${b}[ ]*` : r ? `[ ]*${r}[ ]*` : G ? "[ ]+" : Ul ? J || T : J ? p.has(J.charCodeAt(0)) ? J : "" : al ? (cl = !0, `${T}\\p{M}*`) : T);
          const B = "[ ]*";
          return tl.endsWith(B) && (tl = tl.slice(0, tl.length - B.length)), Ul && al && (Y ||= String.fromCharCode(...p), cl = !0, tl = `${tl}(?=[${Y}]|[^\\p{M}]|$)`), [cl, tl];
        }
        #o(tl) {
          let al = this.#e;
          if (al.length === 0)
            return;
          const {
            caseSensitive: Ul,
            entireWord: cl
          } = this.#l, B = this._pageContents[tl], X = this._hasDiacritics[tl];
          let b = !1;
          typeof al == "string" ? [b, al] = this.#Z(al, X) : al = al.sort().reverse().map((J) => {
            const [T, y] = this.#Z(J, X);
            return b ||= T, `(${y})`;
          }).join("|");
          const r = `g${b ? "u" : ""}${Ul ? "" : "i"}`;
          al = al ? new RegExp(al, r) : null, this.#c(al, cl, tl, B), this.#l.highlightAll && this.#s(tl), this._resumePageIdx === tl && (this._resumePageIdx = null, this.#R());
          const G = this._pageMatches[tl].length;
          this._matchesCountTotal += G, this.#t ? G > 0 && this.#T() : ++this.#n === this._linkService.pagesCount && this.#T();
        }
        #F() {
          if (this._extractTextPromises.length > 0)
            return;
          let tl = Promise.resolve();
          const al = {
            disableNormalization: !0
          };
          for (let Ul = 0, cl = this._linkService.pagesCount; Ul < cl; Ul++) {
            const {
              promise: B,
              resolve: X
            } = Promise.withResolvers();
            this._extractTextPromises[Ul] = B, tl = tl.then(() => this._pdfDocument.getPage(Ul + 1).then((b) => b.getTextContent(al)).then((b) => {
              const r = [];
              for (const G of b.items)
                r.push(G.str), G.hasEOL && r.push(`
`);
              [this._pageContents[Ul], this._pageDiffs[Ul], this._hasDiacritics[Ul]] = q(r.join("")), X();
            }, (b) => {
              console.error(`Unable to get text content for page ${Ul + 1}`, b), this._pageContents[Ul] = "", this._pageDiffs[Ul] = null, this._hasDiacritics[Ul] = !1, X();
            }));
          }
        }
        #s(tl) {
          this._scrollMatches && this._selected.pageIdx === tl && (this._linkService.page = tl + 1), this._eventBus.dispatch("updatetextlayermatches", {
            source: this,
            pageIndex: tl
          });
        }
        #Q() {
          this._eventBus.dispatch("updatetextlayermatches", {
            source: this,
            pageIndex: -1
          });
        }
        #W() {
          const tl = this.#l.findPrevious, al = this._linkService.page - 1, Ul = this._linkService.pagesCount;
          if (this._highlightMatches = !0, this._dirtyMatch) {
            this._dirtyMatch = !1, this._selected.pageIdx = this._selected.matchIdx = -1, this._offset.pageIdx = al, this._offset.matchIdx = null, this._offset.wrapped = !1, this._resumePageIdx = null, this._pageMatches.length = 0, this._pageMatchesLength.length = 0, this.#n = 0, this._matchesCountTotal = 0, this.#Q();
            for (let X = 0; X < Ul; X++)
              this._pendingFindMatches.has(X) || (this._pendingFindMatches.add(X), this._extractTextPromises[X].then(() => {
                this._pendingFindMatches.delete(X), this.#o(X);
              }));
          }
          if (this.#e.length === 0) {
            this.#G(c.FOUND);
            return;
          }
          if (this._resumePageIdx)
            return;
          const B = this._offset;
          if (this._pagesToSearch = Ul, B.matchIdx !== null) {
            const X = this._pageMatches[B.pageIdx].length;
            if (!tl && B.matchIdx + 1 < X || tl && B.matchIdx > 0) {
              B.matchIdx = tl ? B.matchIdx - 1 : B.matchIdx + 1, this.#N(!0);
              return;
            }
            this.#h(tl);
          }
          this.#R();
        }
        #V(tl) {
          const al = this._offset, Ul = tl.length, cl = this.#l.findPrevious;
          return Ul ? (al.matchIdx = cl ? Ul - 1 : 0, this.#N(!0), !0) : (this.#h(cl), al.wrapped && (al.matchIdx = null, this._pagesToSearch < 0) ? (this.#N(!1), !0) : !1);
        }
        #R() {
          this._resumePageIdx !== null && console.error("There can only be one pending page.");
          let tl = null;
          do {
            const al = this._offset.pageIdx;
            if (tl = this._pageMatches[al], !tl) {
              this._resumePageIdx = al;
              break;
            }
          } while (!this.#V(tl));
        }
        #h(tl) {
          const al = this._offset, Ul = this._linkService.pagesCount;
          al.pageIdx = tl ? al.pageIdx - 1 : al.pageIdx + 1, al.matchIdx = null, this._pagesToSearch--, (al.pageIdx >= Ul || al.pageIdx < 0) && (al.pageIdx = tl ? Ul - 1 : 0, al.wrapped = !0);
        }
        #N(tl = !1) {
          let al = c.NOT_FOUND;
          const Ul = this._offset.wrapped;
          if (this._offset.wrapped = !1, tl) {
            const cl = this._selected.pageIdx;
            this._selected.pageIdx = this._offset.pageIdx, this._selected.matchIdx = this._offset.matchIdx, al = Ul ? c.WRAPPED : c.FOUND, cl !== -1 && cl !== this._selected.pageIdx && this.#s(cl);
          }
          this.#G(al, this.#l.findPrevious), this._selected.pageIdx !== -1 && (this._scrollMatches = !0, this.#s(this._selected.pageIdx));
        }
        #m(tl) {
          const al = this._pdfDocument;
          this._firstPageCapability.promise.then(() => {
            !this._pdfDocument || al && this._pdfDocument !== al || (this._findTimeout && (clearTimeout(this._findTimeout), this._findTimeout = null), this._resumePageIdx && (this._resumePageIdx = null, this._dirtyMatch = !0), this.#G(c.FOUND), this._highlightMatches = !1, this.#Q());
          });
        }
        #M() {
          const {
            pageIdx: tl,
            matchIdx: al
          } = this._selected;
          let Ul = 0, cl = this._matchesCountTotal;
          if (al !== -1) {
            for (let B = 0; B < tl; B++)
              Ul += this._pageMatches[B]?.length || 0;
            Ul += al + 1;
          }
          return (Ul < 1 || Ul > cl) && (Ul = cl = 0), {
            current: Ul,
            total: cl
          };
        }
        #T() {
          this._eventBus.dispatch("updatefindmatchescount", {
            source: this,
            matchesCount: this.#M()
          });
        }
        #G(tl, al = !1) {
          !this.#t && (this.#n !== this._linkService.pagesCount || tl === c.PENDING) || this._eventBus.dispatch("updatefindcontrolstate", {
            source: this,
            state: tl,
            previous: al,
            matchesCount: this.#M(),
            rawQuery: this.#l?.query ?? null
          });
        }
      }
    }
  ),
  /***/
  543: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        PDFHistory: () => (
          /* binding */
          W
        )
        /* harmony export */
      });
      var e = n(256), d = n(656);
      const a = 1e3, U = 50, V = 1e3;
      function h() {
        return document.location.hash;
      }
      class W {
        #l = null;
        constructor({
          linkService: F,
          eventBus: N
        }) {
          this.linkService = F, this.eventBus = N, this._initialized = !1, this._fingerprint = "", this.reset(), this.eventBus._on("pagesinit", () => {
            this._isPagesLoaded = !1, this.eventBus._on("pagesloaded", (Q) => {
              this._isPagesLoaded = !!Q.pagesCount;
            }, {
              once: !0
            });
          });
        }
        initialize({
          fingerprint: F,
          resetHistory: N = !1,
          updateUrl: Q = !1
        }) {
          if (!F || typeof F != "string") {
            console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
            return;
          }
          this._initialized && this.reset();
          const u = this._fingerprint !== "" && this._fingerprint !== F;
          this._fingerprint = F, this._updateUrl = Q === !0, this._initialized = !0, this.#o();
          const i = window.history.state;
          if (this._popStateInProgress = !1, this._blockHashChange = 0, this._currentHash = h(), this._numPositionUpdates = 0, this._uid = this._maxUid = 0, this._destination = null, this._position = null, !this.#a(i, !0) || N) {
            const {
              hash: R,
              page: m,
              rotation: M
            } = this.#i(!0);
            if (!R || u || N) {
              this.#t(null, !0);
              return;
            }
            this.#t({
              hash: R,
              page: m,
              rotation: M
            }, !0);
            return;
          }
          const c = i.destination;
          this.#e(c, i.uid, !0), c.rotation !== void 0 && (this._initialRotation = c.rotation), c.dest ? (this._initialBookmark = JSON.stringify(c.dest), this._destination.page = null) : c.hash ? this._initialBookmark = c.hash : c.page && (this._initialBookmark = `page=${c.page}`);
        }
        reset() {
          this._initialized && (this.#Z(), this._initialized = !1, this.#F()), this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._initialBookmark = null, this._initialRotation = null;
        }
        push({
          namedDest: F = null,
          explicitDest: N,
          pageNumber: Q
        }) {
          if (!this._initialized)
            return;
          if (F && typeof F != "string") {
            console.error(`PDFHistory.push: "${F}" is not a valid namedDest parameter.`);
            return;
          } else if (Array.isArray(N)) {
            if (!this.#d(Q) && (Q !== null || this._destination)) {
              console.error(`PDFHistory.push: "${Q}" is not a valid pageNumber parameter.`);
              return;
            }
          } else {
            console.error(`PDFHistory.push: "${N}" is not a valid explicitDest parameter.`);
            return;
          }
          const u = F || JSON.stringify(N);
          if (!u)
            return;
          let i = !1;
          if (this._destination && (Z(this._destination.hash, u) || s(this._destination.dest, N))) {
            if (this._destination.page)
              return;
            i = !0;
          }
          this._popStateInProgress && !i || (this.#t({
            dest: N,
            hash: u,
            page: Q,
            rotation: this.linkService.rotation
          }, i), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
            this._popStateInProgress = !1;
          })));
        }
        pushPage(F) {
          if (this._initialized) {
            if (!this.#d(F)) {
              console.error(`PDFHistory.pushPage: "${F}" is not a valid page number.`);
              return;
            }
            this._destination?.page !== F && (this._popStateInProgress || (this.#t({
              dest: null,
              hash: `page=${F}`,
              page: F,
              rotation: this.linkService.rotation
            }), this._popStateInProgress || (this._popStateInProgress = !0, Promise.resolve().then(() => {
              this._popStateInProgress = !1;
            }))));
          }
        }
        pushCurrentPosition() {
          !this._initialized || this._popStateInProgress || this.#n();
        }
        back() {
          if (!this._initialized || this._popStateInProgress)
            return;
          const F = window.history.state;
          this.#a(F) && F.uid > 0 && window.history.back();
        }
        forward() {
          if (!this._initialized || this._popStateInProgress)
            return;
          const F = window.history.state;
          this.#a(F) && F.uid < this._maxUid && window.history.forward();
        }
        get popStateInProgress() {
          return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
        }
        get initialBookmark() {
          return this._initialized ? this._initialBookmark : null;
        }
        get initialRotation() {
          return this._initialized ? this._initialRotation : null;
        }
        #t(F, N = !1) {
          const Q = N || !this._destination, u = {
            fingerprint: this._fingerprint,
            uid: Q ? this._uid : this._uid + 1,
            destination: F
          };
          this.#e(F, u.uid);
          let i;
          if (this._updateUrl && F?.hash) {
            const c = document.location.href.split("#", 1)[0];
            c.startsWith("file://") || (i = `${c}#${F.hash}`);
          }
          Q ? window.history.replaceState(u, "", i) : window.history.pushState(u, "", i);
        }
        #n(F = !1) {
          if (!this._position)
            return;
          let N = this._position;
          if (F && (N = Object.assign(/* @__PURE__ */ Object.create(null), this._position), N.temporary = !0), !this._destination) {
            this.#t(N);
            return;
          }
          if (this._destination.temporary) {
            this.#t(N, !0);
            return;
          }
          if (this._destination.hash === N.hash || !this._destination.page && this._numPositionUpdates <= U)
            return;
          let Q = !1;
          if (this._destination.page >= N.first && this._destination.page <= N.page) {
            if (this._destination.dest !== void 0 || !this._destination.first)
              return;
            Q = !0;
          }
          this.#t(N, Q);
        }
        #d(F) {
          return Number.isInteger(F) && F > 0 && F <= this.linkService.pagesCount;
        }
        #a(F, N = !1) {
          if (!F)
            return !1;
          if (F.fingerprint !== this._fingerprint)
            if (N) {
              if (typeof F.fingerprint != "string" || F.fingerprint.length !== this._fingerprint.length)
                return !1;
              const [Q] = performance.getEntriesByType("navigation");
              if (Q?.type !== "reload")
                return !1;
            } else
              return !1;
          return !(!Number.isInteger(F.uid) || F.uid < 0 || F.destination === null || typeof F.destination != "object");
        }
        #e(F, N, Q = !1) {
          this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), Q && F?.temporary && delete F.temporary, this._destination = F, this._uid = N, this._maxUid = Math.max(this._maxUid, N), this._numPositionUpdates = 0;
        }
        #i(F = !1) {
          const N = unescape(h()).substring(1), Q = (0, e.parseQueryString)(N), u = Q.get("nameddest") || "";
          let i = Q.get("page") | 0;
          return (!this.#d(i) || F && u.length > 0) && (i = null), {
            hash: N,
            page: i,
            rotation: this.linkService.rotation
          };
        }
        #U({
          location: F
        }) {
          this._updateViewareaTimeout && (clearTimeout(this._updateViewareaTimeout), this._updateViewareaTimeout = null), this._position = {
            hash: F.pdfOpenParams.substring(1),
            page: this.linkService.page,
            first: F.pageNumber,
            rotation: F.rotation
          }, !this._popStateInProgress && (this._isPagesLoaded && this._destination && !this._destination.page && this._numPositionUpdates++, this._updateViewareaTimeout = setTimeout(() => {
            this._popStateInProgress || this.#n(!0), this._updateViewareaTimeout = null;
          }, V));
        }
        #c({
          state: F
        }) {
          const N = h(), Q = this._currentHash !== N;
          if (this._currentHash = N, !F) {
            this._uid++;
            const {
              hash: i,
              page: c,
              rotation: R
            } = this.#i();
            this.#t({
              hash: i,
              page: c,
              rotation: R
            }, !0);
            return;
          }
          if (!this.#a(F))
            return;
          this._popStateInProgress = !0, Q && (this._blockHashChange++, (0, d.waitOnEventOrTimeout)({
            target: window,
            name: "hashchange",
            delay: a
          }).then(() => {
            this._blockHashChange--;
          }));
          const u = F.destination;
          this.#e(u, F.uid, !0), (0, e.isValidRotation)(u.rotation) && (this.linkService.rotation = u.rotation), u.dest ? this.linkService.goToDestination(u.dest) : u.hash ? this.linkService.setHash(u.hash) : u.page && (this.linkService.page = u.page), Promise.resolve().then(() => {
            this._popStateInProgress = !1;
          });
        }
        #Z() {
          (!this._destination || this._destination.temporary) && this.#n();
        }
        #o() {
          if (this.#l)
            return;
          this.#l = new AbortController();
          const {
            signal: F
          } = this.#l;
          this.eventBus._on("updateviewarea", this.#U.bind(this), {
            signal: F
          }), window.addEventListener("popstate", this.#c.bind(this), {
            signal: F
          }), window.addEventListener("pagehide", this.#Z.bind(this), {
            signal: F
          });
        }
        #F() {
          this.#l?.abort(), this.#l = null;
        }
      }
      function Z(o, F) {
        return typeof o != "string" || typeof F != "string" ? !1 : o === F || (0, e.parseQueryString)(o).get("nameddest") === F;
      }
      function s(o, F) {
        function N(Q, u) {
          if (typeof Q != typeof u || Array.isArray(Q) || Array.isArray(u))
            return !1;
          if (Q !== null && typeof Q == "object" && u !== null) {
            if (Object.keys(Q).length !== Object.keys(u).length)
              return !1;
            for (const i in Q)
              if (!N(Q[i], u[i]))
                return !1;
            return !0;
          }
          return Q === u || Number.isNaN(Q) && Number.isNaN(u);
        }
        if (!(Array.isArray(o) && Array.isArray(F)) || o.length !== F.length)
          return !1;
        for (let Q = 0, u = o.length; Q < u; Q++)
          if (!N(o[Q], F[Q]))
            return !1;
        return !0;
      }
    }
  ),
  /***/
  787: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        LinkTarget: () => (
          /* binding */
          a
        ),
        /* harmony export */
        PDFLinkService: () => (
          /* binding */
          U
        ),
        /* harmony export */
        SimpleLinkService: () => (
          /* binding */
          V
        )
        /* harmony export */
      });
      var e = n(256);
      const d = "noopener noreferrer nofollow", a = {
        NONE: 0,
        SELF: 1,
        BLANK: 2,
        PARENT: 3,
        TOP: 4
      };
      class U {
        externalLinkEnabled = !0;
        constructor({
          eventBus: W,
          externalLinkTarget: Z = null,
          externalLinkRel: s = null,
          ignoreDestinationZoom: o = !1
        } = {}) {
          this.eventBus = W, this.externalLinkTarget = Z, this.externalLinkRel = s, this._ignoreDestinationZoom = o, this.baseUrl = null, this.pdfDocument = null, this.pdfViewer = null, this.pdfHistory = null;
        }
        setDocument(W, Z = null) {
          this.baseUrl = Z, this.pdfDocument = W;
        }
        setViewer(W) {
          this.pdfViewer = W;
        }
        setHistory(W) {
          this.pdfHistory = W;
        }
        get pagesCount() {
          return this.pdfDocument ? this.pdfDocument.numPages : 0;
        }
        get page() {
          return this.pdfDocument ? this.pdfViewer.currentPageNumber : 1;
        }
        set page(W) {
          this.pdfDocument && (this.pdfViewer.currentPageNumber = W);
        }
        get rotation() {
          return this.pdfDocument ? this.pdfViewer.pagesRotation : 0;
        }
        set rotation(W) {
          this.pdfDocument && (this.pdfViewer.pagesRotation = W);
        }
        get isInPresentationMode() {
          return this.pdfDocument ? this.pdfViewer.isInPresentationMode : !1;
        }
        async goToDestination(W) {
          if (!this.pdfDocument)
            return;
          let Z, s, o;
          if (typeof W == "string" ? (Z = W, s = await this.pdfDocument.getDestination(W)) : (Z = null, s = await W), !Array.isArray(s)) {
            console.error(`goToDestination: "${s}" is not a valid destination array, for dest="${W}".`);
            return;
          }
          const [F] = s;
          if (F && typeof F == "object") {
            if (o = this.pdfDocument.cachedPageNumber(F), !o)
              try {
                o = await this.pdfDocument.getPageIndex(F) + 1;
              } catch {
                console.error(`goToDestination: "${F}" is not a valid page reference, for dest="${W}".`);
                return;
              }
          } else
            Number.isInteger(F) && (o = F + 1);
          if (!o || o < 1 || o > this.pagesCount) {
            console.error(`goToDestination: "${o}" is not a valid page number, for dest="${W}".`);
            return;
          }
          this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.push({
            namedDest: Z,
            explicitDest: s,
            pageNumber: o
          })), this.pdfViewer.scrollPageIntoView({
            pageNumber: o,
            destArray: s,
            ignoreDestinationZoom: this._ignoreDestinationZoom
          });
        }
        goToPage(W) {
          if (!this.pdfDocument)
            return;
          const Z = typeof W == "string" && this.pdfViewer.pageLabelToPageNumber(W) || W | 0;
          if (!(Number.isInteger(Z) && Z > 0 && Z <= this.pagesCount)) {
            console.error(`PDFLinkService.goToPage: "${W}" is not a valid page.`);
            return;
          }
          this.pdfHistory && (this.pdfHistory.pushCurrentPosition(), this.pdfHistory.pushPage(Z)), this.pdfViewer.scrollPageIntoView({
            pageNumber: Z
          });
        }
        addLinkAttributes(W, Z, s = !1) {
          if (!Z || typeof Z != "string")
            throw new Error('A valid "url" parameter must provided.');
          const o = s ? a.BLANK : this.externalLinkTarget, F = this.externalLinkRel;
          this.externalLinkEnabled ? W.href = W.title = Z : (W.href = "", W.title = `Disabled: ${Z}`, W.onclick = () => !1);
          let N = "";
          switch (o) {
            case a.NONE:
              break;
            case a.SELF:
              N = "_self";
              break;
            case a.BLANK:
              N = "_blank";
              break;
            case a.PARENT:
              N = "_parent";
              break;
            case a.TOP:
              N = "_top";
              break;
          }
          W.target = N, W.rel = typeof F == "string" ? F : d;
        }
        getDestinationHash(W) {
          if (typeof W == "string") {
            if (W.length > 0)
              return this.getAnchorUrl("#" + escape(W));
          } else if (Array.isArray(W)) {
            const Z = JSON.stringify(W);
            if (Z.length > 0)
              return this.getAnchorUrl("#" + escape(Z));
          }
          return this.getAnchorUrl("");
        }
        getAnchorUrl(W) {
          return this.baseUrl ? this.baseUrl + W : W;
        }
        setHash(W) {
          if (!this.pdfDocument)
            return;
          let Z, s;
          if (W.includes("=")) {
            const o = (0, e.parseQueryString)(W);
            if (o.has("search")) {
              const F = o.get("search").replaceAll('"', ""), N = o.get("phrase") === "true";
              this.eventBus.dispatch("findfromurlhash", {
                source: this,
                query: N ? F : F.match(/\S+/g)
              });
            }
            if (o.has("page") && (Z = o.get("page") | 0 || 1), o.has("zoom")) {
              const F = o.get("zoom").split(","), N = F[0], Q = parseFloat(N);
              N.includes("Fit") ? N === "Fit" || N === "FitB" ? s = [null, {
                name: N
              }] : N === "FitH" || N === "FitBH" || N === "FitV" || N === "FitBV" ? s = [null, {
                name: N
              }, F.length > 1 ? F[1] | 0 : null] : N === "FitR" ? F.length !== 5 ? console.error('PDFLinkService.setHash: Not enough parameters for "FitR".') : s = [null, {
                name: N
              }, F[1] | 0, F[2] | 0, F[3] | 0, F[4] | 0] : console.error(`PDFLinkService.setHash: "${N}" is not a valid zoom value.`) : s = [null, {
                name: "XYZ"
              }, F.length > 1 ? F[1] | 0 : null, F.length > 2 ? F[2] | 0 : null, Q ? Q / 100 : N];
            }
            s ? this.pdfViewer.scrollPageIntoView({
              pageNumber: Z || this.page,
              destArray: s,
              allowNegativeOffset: !0
            }) : Z && (this.page = Z), o.has("pagemode") && this.eventBus.dispatch("pagemode", {
              source: this,
              mode: o.get("pagemode")
            }), o.has("nameddest") && this.goToDestination(o.get("nameddest"));
            return;
          }
          s = unescape(W);
          try {
            s = JSON.parse(s), Array.isArray(s) || (s = s.toString());
          } catch {
          }
          if (typeof s == "string" || U.#l(s)) {
            this.goToDestination(s);
            return;
          }
          console.error(`PDFLinkService.setHash: "${unescape(W)}" is not a valid destination.`);
        }
        executeNamedAction(W) {
          if (this.pdfDocument) {
            switch (W) {
              case "GoBack":
                this.pdfHistory?.back();
                break;
              case "GoForward":
                this.pdfHistory?.forward();
                break;
              case "NextPage":
                this.pdfViewer.nextPage();
                break;
              case "PrevPage":
                this.pdfViewer.previousPage();
                break;
              case "LastPage":
                this.page = this.pagesCount;
                break;
              case "FirstPage":
                this.page = 1;
                break;
            }
            this.eventBus.dispatch("namedaction", {
              source: this,
              action: W
            });
          }
        }
        async executeSetOCGState(W) {
          if (!this.pdfDocument)
            return;
          const Z = this.pdfDocument, s = await this.pdfViewer.optionalContentConfigPromise;
          Z === this.pdfDocument && (s.setOCGState(W), this.pdfViewer.optionalContentConfigPromise = Promise.resolve(s));
        }
        static #l(W) {
          if (!Array.isArray(W) || W.length < 2)
            return !1;
          const [Z, s, ...o] = W;
          if (!(typeof Z == "object" && Number.isInteger(Z?.num) && Number.isInteger(Z?.gen)) && !Number.isInteger(Z) || !(typeof s == "object" && typeof s?.name == "string"))
            return !1;
          let F = !0;
          switch (s.name) {
            case "XYZ":
              if (o.length !== 3)
                return !1;
              break;
            case "Fit":
            case "FitB":
              return o.length === 0;
            case "FitH":
            case "FitBH":
            case "FitV":
            case "FitBV":
              if (o.length !== 1)
                return !1;
              break;
            case "FitR":
              if (o.length !== 4)
                return !1;
              F = !1;
              break;
            default:
              return !1;
          }
          for (const N of o)
            if (!(typeof N == "number" || F && N === null))
              return !1;
          return !0;
        }
      }
      class V extends U {
        setDocument(W, Z = null) {
        }
      }
    }
  ),
  /***/
  966: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            PDFPageView: () => (
              /* binding */
              M
            )
            /* harmony export */
          });
          var a = n(603), U = n(256), V = n(283), h = n(707), W = n(840), Z = n(88), s = n(410), o = n(787), F = n(698), N = n(860), Q = n(27), u = n(765), i = n(973), c = e([a, V, h, Z, s, u, i]);
          [a, V, h, Z, s, u, i] = c.then ? (await c)() : c;
          const R = {
            annotationEditorUIManager: null,
            annotationStorage: null,
            downloadManager: null,
            enableScripting: !1,
            fieldObjectsPromise: null,
            findController: null,
            hasJSActionsPromise: null,
            get linkService() {
              return new o.SimpleLinkService();
            }
          }, m = /* @__PURE__ */ new Map([["canvasWrapper", 0], ["textLayer", 1], ["annotationLayer", 2], ["annotationEditorLayer", 3], ["xfaLayer", 3]]);
          class M {
            #l = a.AnnotationMode.ENABLE_FORMS;
            #t = !1;
            #n = null;
            #d = null;
            #a = null;
            #e = null;
            #i = U.RenderingStates.INITIAL;
            #U = U.TextLayerMode.ENABLE;
            #c = {
              directDrawing: !0,
              initialOptionalContent: !0,
              regularAnnotations: !0
            };
            #Z = /* @__PURE__ */ new WeakMap();
            #o = [null, null, null, null];
            constructor(p) {
              const Y = p.container, k = p.defaultViewport;
              this.id = p.id, this.renderingId = "page" + this.id, this.#n = p.layerProperties || R, this.pdfPage = null, this.pageLabel = null, this.rotation = 0, this.scale = p.scale || U.DEFAULT_SCALE, this.viewport = k, this.pdfPageRotate = k.rotation, this._optionalContentConfigPromise = p.optionalContentConfigPromise || null, this.#U = p.textLayerMode ?? U.TextLayerMode.ENABLE, this.#l = p.annotationMode ?? a.AnnotationMode.ENABLE_FORMS, this.imageResourcesPath = p.imageResourcesPath || "", this.maxCanvasPixels = p.maxCanvasPixels ?? W.AppOptions.get("maxCanvasPixels"), this.pageColors = p.pageColors || null, this.eventBus = p.eventBus, this.renderingQueue = p.renderingQueue, this.l10n = p.l10n, this.l10n ||= new s.GenericL10n(), this.renderTask = null, this.resume = null, this._isStandalone = !this.renderingQueue?.hasViewer(), this._container = Y, this._annotationCanvasMap = null, this.annotationLayer = null, this.annotationEditorLayer = null, this.textLayer = null, this.zoomLayer = null, this.xfaLayer = null, this.structTreeLayer = null, this.drawLayer = null;
              const L = document.createElement("div");
              if (L.className = "page", L.setAttribute("data-page-number", this.id), L.setAttribute("role", "region"), L.setAttribute("data-l10n-id", "pdfjs-page-landmark"), L.setAttribute("data-l10n-args", JSON.stringify({
                page: this.id
              })), this.div = L, this.#s(), Y?.append(L), this._isStandalone) {
                Y?.style.setProperty("--scale-factor", this.scale * a.PixelsPerInch.PDF_TO_CSS_UNITS);
                const {
                  optionalContentConfigPromise: z
                } = p;
                z && z.then((f) => {
                  z === this._optionalContentConfigPromise && (this.#c.initialOptionalContent = f.hasInitialVisibility);
                }), p.l10n || this.l10n.translate(this.div);
              }
            }
            #F(p, Y) {
              const k = m.get(Y), L = this.#o[k];
              if (this.#o[k] = p, L) {
                L.replaceWith(p);
                return;
              }
              for (let z = k - 1; z >= 0; z--) {
                const f = this.#o[z];
                if (f) {
                  f.after(p);
                  return;
                }
              }
              this.div.prepend(p);
            }
            get renderingState() {
              return this.#i;
            }
            set renderingState(p) {
              if (p !== this.#i)
                switch (this.#i = p, this.#d && (clearTimeout(this.#d), this.#d = null), p) {
                  case U.RenderingStates.PAUSED:
                    this.div.classList.remove("loading");
                    break;
                  case U.RenderingStates.RUNNING:
                    this.div.classList.add("loadingIcon"), this.#d = setTimeout(() => {
                      this.div.classList.add("loading"), this.#d = null;
                    }, 0);
                    break;
                  case U.RenderingStates.INITIAL:
                  case U.RenderingStates.FINISHED:
                    this.div.classList.remove("loadingIcon", "loading");
                    break;
                }
            }
            #s() {
              const {
                viewport: p
              } = this;
              if (this.pdfPage) {
                if (this.#a === p.rotation)
                  return;
                this.#a = p.rotation;
              }
              (0, a.setLayerDimensions)(this.div, p, !0, !1);
            }
            setPdfPage(p) {
              this._isStandalone && (this.pageColors?.foreground === "CanvasText" || this.pageColors?.background === "Canvas") && (this._container?.style.setProperty("--hcm-highlight-filter", p.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), this._container?.style.setProperty("--hcm-highlight-selected-filter", p.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "Highlight"))), this.pdfPage = p, this.pdfPageRotate = p.rotate;
              const Y = (this.rotation + this.pdfPageRotate) % 360;
              this.viewport = p.getViewport({
                scale: this.scale * a.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: Y
              }), this.#s(), this.reset();
            }
            destroy() {
              this.reset(), this.pdfPage?.cleanup();
            }
            get _textHighlighter() {
              return (0, a.shadow)(this, "_textHighlighter", new Q.TextHighlighter({
                pageIndex: this.id - 1,
                eventBus: this.eventBus,
                findController: this.#n.findController
              }));
            }
            async #Q() {
              let p = null;
              try {
                await this.annotationLayer.render(this.viewport, "display");
              } catch (Y) {
                console.error(`#renderAnnotationLayer: "${Y}".`), p = Y;
              } finally {
                this.eventBus.dispatch("annotationlayerrendered", {
                  source: this,
                  pageNumber: this.id,
                  error: p
                });
              }
            }
            async #W() {
              let p = null;
              try {
                await this.annotationEditorLayer.render(this.viewport, "display");
              } catch (Y) {
                console.error(`#renderAnnotationEditorLayer: "${Y}".`), p = Y;
              } finally {
                this.eventBus.dispatch("annotationeditorlayerrendered", {
                  source: this,
                  pageNumber: this.id,
                  error: p
                });
              }
            }
            async #V() {
              try {
                await this.drawLayer.render("display");
              } catch (p) {
                console.error(`#renderDrawLayer: "${p}".`);
              }
            }
            async #R() {
              let p = null;
              try {
                const Y = await this.xfaLayer.render(this.viewport, "display");
                Y?.textDivs && this._textHighlighter && this.#m(Y.textDivs);
              } catch (Y) {
                console.error(`#renderXfaLayer: "${Y}".`), p = Y;
              } finally {
                this.xfaLayer?.div && (this.l10n.pause(), this.#F(this.xfaLayer.div, "xfaLayer"), this.l10n.resume()), this.eventBus.dispatch("xfalayerrendered", {
                  source: this,
                  pageNumber: this.id,
                  error: p
                });
              }
            }
            async #h() {
              const {
                pdfPage: p,
                textLayer: Y,
                viewport: k
              } = this;
              if (!Y)
                return;
              let L = null;
              try {
                if (!Y.renderingDone) {
                  const z = p.streamTextContent({
                    includeMarkedContent: !0,
                    disableNormalization: !0
                  });
                  Y.setTextContentSource(z);
                }
                await Y.render(k);
              } catch (z) {
                if (z instanceof a.AbortException)
                  return;
                console.error(`#renderTextLayer: "${z}".`), L = z;
              }
              this.eventBus.dispatch("textlayerrendered", {
                source: this,
                pageNumber: this.id,
                numTextDivs: Y.numTextDivs,
                error: L
              }), this.#N();
            }
            async #N() {
              if (!this.textLayer)
                return;
              this.structTreeLayer ||= new F.StructTreeLayerBuilder();
              const p = await (this.structTreeLayer.renderingDone ? null : this.pdfPage.getStructTree()), Y = this.structTreeLayer?.render(p);
              Y && (this.l10n.pause(), this.canvas?.append(Y), this.l10n.resume()), this.structTreeLayer?.show();
            }
            async #m(p) {
              const Y = await this.pdfPage.getTextContent(), k = [];
              for (const L of Y.items)
                k.push(L.str);
              this._textHighlighter.setTextMapping(p, k), this._textHighlighter.enable();
            }
            _resetZoomLayer(p = !1) {
              if (!this.zoomLayer)
                return;
              const Y = this.zoomLayer.firstChild;
              this.#Z.delete(Y), Y.width = 0, Y.height = 0, p && this.zoomLayer.remove(), this.zoomLayer = null;
            }
            reset({
              keepZoomLayer: p = !1,
              keepAnnotationLayer: Y = !1,
              keepAnnotationEditorLayer: k = !1,
              keepXfaLayer: L = !1,
              keepTextLayer: z = !1
            } = {}) {
              this.cancelRendering({
                keepAnnotationLayer: Y,
                keepAnnotationEditorLayer: k,
                keepXfaLayer: L,
                keepTextLayer: z
              }), this.renderingState = U.RenderingStates.INITIAL;
              const f = this.div, K = f.childNodes, P = p && this.zoomLayer || null, w = Y && this.annotationLayer?.div || null, O = k && this.annotationEditorLayer?.div || null, el = L && this.xfaLayer?.div || null, ll = z && this.textLayer?.div || null;
              for (let q = K.length - 1; q >= 0; q--) {
                const _ = K[q];
                switch (_) {
                  case P:
                  case w:
                  case O:
                  case el:
                  case ll:
                    continue;
                }
                _.remove();
                const il = this.#o.indexOf(_);
                il >= 0 && (this.#o[il] = null);
              }
              f.removeAttribute("data-loaded"), w && this.annotationLayer.hide(), O && this.annotationEditorLayer.hide(), el && this.xfaLayer.hide(), ll && this.textLayer.hide(), this.structTreeLayer?.hide(), P || (this.canvas && (this.#Z.delete(this.canvas), this.canvas.width = 0, this.canvas.height = 0, delete this.canvas), this._resetZoomLayer());
            }
            update({
              scale: p = 0,
              rotation: Y = null,
              optionalContentConfigPromise: k = null,
              drawingDelay: L = -1
            }) {
              this.scale = p || this.scale, typeof Y == "number" && (this.rotation = Y), k instanceof Promise && (this._optionalContentConfigPromise = k, k.then((f) => {
                k === this._optionalContentConfigPromise && (this.#c.initialOptionalContent = f.hasInitialVisibility);
              })), this.#c.directDrawing = !0;
              const z = (this.rotation + this.pdfPageRotate) % 360;
              if (this.viewport = this.viewport.clone({
                scale: this.scale * a.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: z
              }), this.#s(), this._isStandalone && this._container?.style.setProperty("--scale-factor", this.viewport.scale), this.canvas) {
                let f = !1;
                if (this.#t) {
                  if (this.maxCanvasPixels === 0)
                    f = !0;
                  else if (this.maxCanvasPixels > 0) {
                    const {
                      width: P,
                      height: w
                    } = this.viewport, {
                      sx: O,
                      sy: el
                    } = this.outputScale;
                    f = (Math.floor(P) * O | 0) * (Math.floor(w) * el | 0) > this.maxCanvasPixels;
                  }
                }
                const K = !f && L >= 0 && L < 1e3;
                if (K || f) {
                  if (K && this.renderingState !== U.RenderingStates.FINISHED && (this.cancelRendering({
                    keepZoomLayer: !0,
                    keepAnnotationLayer: !0,
                    keepAnnotationEditorLayer: !0,
                    keepXfaLayer: !0,
                    keepTextLayer: !0,
                    cancelExtraDelay: L
                  }), this.renderingState = U.RenderingStates.FINISHED, this.#c.directDrawing = !1), this.cssTransform({
                    target: this.canvas,
                    redrawAnnotationLayer: !0,
                    redrawAnnotationEditorLayer: !0,
                    redrawXfaLayer: !0,
                    redrawTextLayer: !K,
                    hideTextLayer: K
                  }), K)
                    return;
                  this.eventBus.dispatch("pagerendered", {
                    source: this,
                    pageNumber: this.id,
                    cssTransform: !0,
                    timestamp: performance.now(),
                    error: this.#e
                  });
                  return;
                }
                !this.zoomLayer && !this.canvas.hidden && (this.zoomLayer = this.canvas.parentNode, this.zoomLayer.style.position = "absolute");
              }
              this.zoomLayer && this.cssTransform({
                target: this.zoomLayer.firstChild
              }), this.reset({
                keepZoomLayer: !0,
                keepAnnotationLayer: !0,
                keepAnnotationEditorLayer: !0,
                keepXfaLayer: !0,
                keepTextLayer: !0
              });
            }
            cancelRendering({
              keepAnnotationLayer: p = !1,
              keepAnnotationEditorLayer: Y = !1,
              keepXfaLayer: k = !1,
              keepTextLayer: L = !1,
              cancelExtraDelay: z = 0
            } = {}) {
              this.renderTask && (this.renderTask.cancel(z), this.renderTask = null), this.resume = null, this.textLayer && (!L || !this.textLayer.div) && (this.textLayer.cancel(), this.textLayer = null), this.structTreeLayer && !this.textLayer && (this.structTreeLayer = null), this.annotationLayer && (!p || !this.annotationLayer.div) && (this.annotationLayer.cancel(), this.annotationLayer = null, this._annotationCanvasMap = null), this.annotationEditorLayer && (!Y || !this.annotationEditorLayer.div) && (this.drawLayer && (this.drawLayer.cancel(), this.drawLayer = null), this.annotationEditorLayer.cancel(), this.annotationEditorLayer = null), this.xfaLayer && (!k || !this.xfaLayer.div) && (this.xfaLayer.cancel(), this.xfaLayer = null, this._textHighlighter?.disable());
            }
            cssTransform({
              target: p,
              redrawAnnotationLayer: Y = !1,
              redrawAnnotationEditorLayer: k = !1,
              redrawXfaLayer: L = !1,
              redrawTextLayer: z = !1,
              hideTextLayer: f = !1
            }) {
              if (!p.hasAttribute("zooming")) {
                p.setAttribute("zooming", !0);
                const {
                  style: P
                } = p;
                P.width = P.height = "";
              }
              const K = this.#Z.get(p);
              if (this.viewport !== K) {
                const P = this.viewport.rotation - K.rotation, w = Math.abs(P);
                let O = 1, el = 1;
                if (w === 90 || w === 270) {
                  const {
                    width: ll,
                    height: q
                  } = this.viewport;
                  O = q / ll, el = ll / q;
                }
                p.style.transform = `rotate(${P}deg) scale(${O}, ${el})`;
              }
              Y && this.annotationLayer && this.#Q(), k && this.annotationEditorLayer && (this.drawLayer && this.#V(), this.#W()), L && this.xfaLayer && this.#R(), this.textLayer && (f ? (this.textLayer.hide(), this.structTreeLayer?.hide()) : z && this.#h());
            }
            get width() {
              return this.viewport.width;
            }
            get height() {
              return this.viewport.height;
            }
            getPagePoint(p, Y) {
              return this.viewport.convertToPdfPoint(p, Y);
            }
            async #M(p, Y = null) {
              if (p === this.renderTask && (this.renderTask = null), Y instanceof a.RenderingCancelledException) {
                this.#e = null;
                return;
              }
              if (this.#e = Y, this.renderingState = U.RenderingStates.FINISHED, this._resetZoomLayer(!0), this.#c.regularAnnotations = !p.separateAnnots, this.eventBus.dispatch("pagerendered", {
                source: this,
                pageNumber: this.id,
                cssTransform: !1,
                timestamp: performance.now(),
                error: this.#e
              }), Y)
                throw Y;
            }
            async draw() {
              this.renderingState !== U.RenderingStates.INITIAL && (console.error("Must be in new state before drawing"), this.reset());
              const {
                div: p,
                l10n: Y,
                pageColors: k,
                pdfPage: L,
                viewport: z
              } = this;
              if (!L)
                throw this.renderingState = U.RenderingStates.FINISHED, new Error("pdfPage is not loaded");
              this.renderingState = U.RenderingStates.RUNNING;
              const f = document.createElement("div");
              if (f.classList.add("canvasWrapper"), f.setAttribute("aria-hidden", !0), this.#F(f, "canvasWrapper"), !this.textLayer && this.#U !== U.TextLayerMode.DISABLE && !L.isPureXfa && (this._accessibilityManager ||= new N.TextAccessibilityManager(), this.textLayer = new u.TextLayerBuilder({
                highlighter: this._textHighlighter,
                accessibilityManager: this._accessibilityManager,
                enablePermissions: this.#U === U.TextLayerMode.ENABLE_PERMISSIONS,
                onAppend: (X) => {
                  this.l10n.pause(), this.#F(X, "textLayer"), this.l10n.resume();
                }
              })), !this.annotationLayer && this.#l !== a.AnnotationMode.DISABLE) {
                const {
                  annotationStorage: X,
                  annotationEditorUIManager: b,
                  downloadManager: r,
                  enableScripting: G,
                  fieldObjectsPromise: J,
                  hasJSActionsPromise: T,
                  linkService: y
                } = this.#n;
                this._annotationCanvasMap ||= /* @__PURE__ */ new Map(), this.annotationLayer = new h.AnnotationLayerBuilder({
                  pdfPage: L,
                  annotationStorage: X,
                  imageResourcesPath: this.imageResourcesPath,
                  renderForms: this.#l === a.AnnotationMode.ENABLE_FORMS,
                  linkService: y,
                  downloadManager: r,
                  enableScripting: G,
                  hasJSActionsPromise: T,
                  fieldObjectsPromise: J,
                  annotationCanvasMap: this._annotationCanvasMap,
                  accessibilityManager: this._accessibilityManager,
                  annotationEditorUIManager: b,
                  onAppend: (I) => {
                    this.#F(I, "annotationLayer");
                  }
                });
              }
              const K = (X) => {
                if (ll?.(!1), this.renderingQueue && !this.renderingQueue.isHighestPriority(this)) {
                  this.renderingState = U.RenderingStates.PAUSED, this.resume = () => {
                    this.renderingState = U.RenderingStates.RUNNING, X();
                  };
                  return;
                }
                X();
              }, {
                width: P,
                height: w
              } = z, O = document.createElement("canvas");
              O.setAttribute("role", "presentation"), O.hidden = !0;
              const el = !!(k?.background && k?.foreground);
              let ll = (X) => {
                (!el || X) && (O.hidden = !1, ll = null);
              };
              f.append(O), this.canvas = O;
              const q = O.getContext("2d", {
                alpha: !1
              }), _ = this.outputScale = new U.OutputScale();
              if (this.maxCanvasPixels === 0) {
                const X = 1 / this.scale;
                _.sx *= X, _.sy *= X, this.#t = !0;
              } else if (this.maxCanvasPixels > 0) {
                const X = P * w, b = Math.sqrt(this.maxCanvasPixels / X);
                _.sx > b || _.sy > b ? (_.sx = b, _.sy = b, this.#t = !0) : this.#t = !1;
              }
              const il = (0, U.approximateFraction)(_.sx), dl = (0, U.approximateFraction)(_.sy);
              O.width = (0, U.roundToDivide)(P * _.sx, il[0]), O.height = (0, U.roundToDivide)(w * _.sy, dl[0]);
              const {
                style: tl
              } = O;
              tl.width = (0, U.roundToDivide)(P, il[1]) + "px", tl.height = (0, U.roundToDivide)(w, dl[1]) + "px", this.#Z.set(O, z);
              const al = _.scaled ? [_.sx, 0, 0, _.sy, 0, 0] : null, Ul = {
                canvasContext: q,
                transform: al,
                viewport: z,
                annotationMode: this.#l,
                optionalContentConfigPromise: this._optionalContentConfigPromise,
                annotationCanvasMap: this._annotationCanvasMap,
                pageColors: k
              }, cl = this.renderTask = this.pdfPage.render(Ul);
              cl.onContinue = K;
              const B = cl.promise.then(async () => {
                ll?.(!0), await this.#M(cl), this.#h(), this.annotationLayer && await this.#Q();
                const {
                  annotationEditorUIManager: X
                } = this.#n;
                X && (this.drawLayer ||= new Z.DrawLayerBuilder({
                  pageIndex: this.id
                }), await this.#V(), this.drawLayer.setParent(f), this.annotationEditorLayer || (this.annotationEditorLayer = new V.AnnotationEditorLayerBuilder({
                  uiManager: X,
                  pdfPage: L,
                  l10n: Y,
                  accessibilityManager: this._accessibilityManager,
                  annotationLayer: this.annotationLayer?.annotationLayer,
                  textLayer: this.textLayer,
                  drawLayer: this.drawLayer.getDrawLayer(),
                  onAppend: (b) => {
                    this.#F(b, "annotationEditorLayer");
                  }
                })), this.#W());
              }, (X) => (X instanceof a.RenderingCancelledException || ll?.(!0), this.#M(cl, X)));
              if (L.isPureXfa) {
                if (!this.xfaLayer) {
                  const {
                    annotationStorage: X,
                    linkService: b
                  } = this.#n;
                  this.xfaLayer = new i.XfaLayerBuilder({
                    pdfPage: L,
                    annotationStorage: X,
                    linkService: b
                  });
                }
                this.#R();
              }
              return p.setAttribute("data-loaded", !0), this.eventBus.dispatch("pagerender", {
                source: this,
                pageNumber: this.id
              }), B;
            }
            setPageLabel(p) {
              this.pageLabel = typeof p == "string" ? p : null, this.div.setAttribute("data-l10n-args", JSON.stringify({
                page: this.pageLabel ?? this.id
              })), this.pageLabel !== null ? this.div.setAttribute("data-page-label", this.pageLabel) : this.div.removeAttribute("data-page-label");
            }
            get thumbnailCanvas() {
              const {
                directDrawing: p,
                initialOptionalContent: Y,
                regularAnnotations: k
              } = this.#c;
              return p && Y && k ? this.canvas : null;
            }
          }
          d();
        } catch (R) {
          d(R);
        }
      });
    }
  ),
  /***/
  615: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            PDFRenderingQueue: () => (
              /* binding */
              W
            )
            /* harmony export */
          });
          var a = n(603), U = n(256), V = e([a]);
          a = (V.then ? (await V)() : V)[0];
          const h = 3e4;
          class W {
            constructor() {
              this.pdfViewer = null, this.pdfThumbnailViewer = null, this.onIdle = null, this.highestPriorityPage = null, this.idleTimeout = null, this.printing = !1, this.isThumbnailViewEnabled = !1, Object.defineProperty(this, "hasViewer", {
                value: () => !!this.pdfViewer
              });
            }
            setViewer(s) {
              this.pdfViewer = s;
            }
            setThumbnailViewer(s) {
              this.pdfThumbnailViewer = s;
            }
            isHighestPriority(s) {
              return this.highestPriorityPage === s.renderingId;
            }
            renderHighestPriority(s) {
              this.idleTimeout && (clearTimeout(this.idleTimeout), this.idleTimeout = null), !this.pdfViewer.forceRendering(s) && (this.isThumbnailViewEnabled && this.pdfThumbnailViewer?.forceRendering() || this.printing || this.onIdle && (this.idleTimeout = setTimeout(this.onIdle.bind(this), h)));
            }
            getHighestPriority(s, o, F, N = !1) {
              const Q = s.views, u = Q.length;
              if (u === 0)
                return null;
              for (let M = 0; M < u; M++) {
                const S = Q[M].view;
                if (!this.isViewFinished(S))
                  return S;
              }
              const i = s.first.id, c = s.last.id;
              if (c - i + 1 > u) {
                const M = s.ids;
                for (let S = 1, p = c - i; S < p; S++) {
                  const Y = F ? i + S : c - S;
                  if (M.has(Y))
                    continue;
                  const k = o[Y - 1];
                  if (!this.isViewFinished(k))
                    return k;
                }
              }
              let R = F ? c : i - 2, m = o[R];
              return m && !this.isViewFinished(m) || N && (R += F ? 1 : -1, m = o[R], m && !this.isViewFinished(m)) ? m : null;
            }
            isViewFinished(s) {
              return s.renderingState === U.RenderingStates.FINISHED;
            }
            renderView(s) {
              switch (s.renderingState) {
                case U.RenderingStates.FINISHED:
                  return !1;
                case U.RenderingStates.PAUSED:
                  this.highestPriorityPage = s.renderingId, s.resume();
                  break;
                case U.RenderingStates.RUNNING:
                  this.highestPriorityPage = s.renderingId;
                  break;
                case U.RenderingStates.INITIAL:
                  this.highestPriorityPage = s.renderingId, s.draw().finally(() => {
                    this.renderHighestPriority();
                  }).catch((o) => {
                    o instanceof a.RenderingCancelledException || console.error(`renderView: "${o}"`);
                  });
                  break;
              }
              return !0;
            }
          }
          d();
        } catch (h) {
          d(h);
        }
      });
    }
  ),
  /***/
  371: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            PDFScriptingManager: () => (
              /* binding */
              h
            )
            /* harmony export */
          });
          var a = n(289), U = n(942), V = e([a, U]);
          [a, U] = V.then ? (await V)() : V;
          class h extends U.PDFScriptingManager {
            constructor(Z) {
              Z.externalServices || window.addEventListener("updatefromsandbox", (s) => {
                Z.eventBus.dispatch("updatefromsandbox", {
                  source: window,
                  detail: s.detail
                });
              }), Z.externalServices ||= {
                createScripting: () => new a.GenericScripting(Z.sandboxBundleSrc)
              }, Z.docProperties ||= (s) => (0, a.docProperties)(s), super(Z);
            }
          }
          d();
        } catch (h) {
          d(h);
        }
      });
    }
  ),
  /***/
  942: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            PDFScriptingManager: () => (
              /* binding */
              h
            )
            /* harmony export */
          });
          var a = n(256), U = n(603), V = e([U]);
          U = (V.then ? (await V)() : V)[0];
          class h {
            #l = null;
            #t = null;
            #n = null;
            #d = null;
            #a = null;
            #e = null;
            #i = null;
            #U = null;
            #c = !1;
            #Z = null;
            #o = null;
            constructor({
              eventBus: Z,
              externalServices: s = null,
              docProperties: o = null
            }) {
              this.#a = Z, this.#e = s, this.#n = o;
            }
            setViewer(Z) {
              this.#U = Z;
            }
            async setDocument(Z) {
              if (this.#i && await this.#V(), this.#i = Z, !Z)
                return;
              const [s, o, F] = await Promise.all([Z.getFieldObjects(), Z.getCalculationOrderIds(), Z.getJSActions()]);
              if (!s && !F) {
                await this.#V();
                return;
              }
              if (Z !== this.#i)
                return;
              try {
                this.#Z = this.#W();
              } catch (u) {
                console.error(`setDocument: "${u.message}".`), await this.#V();
                return;
              }
              const N = this.#a;
              this.#d = new AbortController();
              const {
                signal: Q
              } = this.#d;
              N._on("updatefromsandbox", (u) => {
                u?.source === window && this.#F(u.detail);
              }, {
                signal: Q
              }), N._on("dispatcheventinsandbox", (u) => {
                this.#Z?.dispatchEventInSandbox(u.detail);
              }, {
                signal: Q
              }), N._on("pagechanging", ({
                pageNumber: u,
                previous: i
              }) => {
                u !== i && (this.#Q(i), this.#s(u));
              }, {
                signal: Q
              }), N._on("pagerendered", ({
                pageNumber: u
              }) => {
                this._pageOpenPending.has(u) && u === this.#U.currentPageNumber && this.#s(u);
              }, {
                signal: Q
              }), N._on("pagesdestroy", async () => {
                await this.#Q(this.#U.currentPageNumber), await this.#Z?.dispatchEventInSandbox({
                  id: "doc",
                  name: "WillClose"
                }), this.#l?.resolve();
              }, {
                signal: Q
              });
              try {
                const u = await this.#n(Z);
                if (Z !== this.#i)
                  return;
                await this.#Z.createSandbox({
                  objects: s,
                  calculationOrder: o,
                  appInfo: {
                    platform: navigator.platform,
                    language: navigator.language
                  },
                  docInfo: {
                    ...u,
                    actions: F
                  }
                }), N.dispatch("sandboxcreated", {
                  source: this
                });
              } catch (u) {
                console.error(`setDocument: "${u.message}".`), await this.#V();
                return;
              }
              await this.#Z?.dispatchEventInSandbox({
                id: "doc",
                name: "Open"
              }), await this.#s(this.#U.currentPageNumber, !0), Promise.resolve().then(() => {
                Z === this.#i && (this.#c = !0);
              });
            }
            async dispatchWillSave() {
              return this.#Z?.dispatchEventInSandbox({
                id: "doc",
                name: "WillSave"
              });
            }
            async dispatchDidSave() {
              return this.#Z?.dispatchEventInSandbox({
                id: "doc",
                name: "DidSave"
              });
            }
            async dispatchWillPrint() {
              if (this.#Z) {
                await this.#o?.promise, this.#o = Promise.withResolvers();
                try {
                  await this.#Z.dispatchEventInSandbox({
                    id: "doc",
                    name: "WillPrint"
                  });
                } catch (Z) {
                  throw this.#o.resolve(), this.#o = null, Z;
                }
                await this.#o.promise;
              }
            }
            async dispatchDidPrint() {
              return this.#Z?.dispatchEventInSandbox({
                id: "doc",
                name: "DidPrint"
              });
            }
            get destroyPromise() {
              return this.#t?.promise || null;
            }
            get ready() {
              return this.#c;
            }
            get _pageOpenPending() {
              return (0, U.shadow)(this, "_pageOpenPending", /* @__PURE__ */ new Set());
            }
            get _visitedPages() {
              return (0, U.shadow)(this, "_visitedPages", /* @__PURE__ */ new Map());
            }
            async #F(Z) {
              const s = this.#U, o = s.isInPresentationMode || s.isChangingPresentationMode, {
                id: F,
                siblings: N,
                command: Q,
                value: u
              } = Z;
              if (!F) {
                switch (Q) {
                  case "clear":
                    console.clear();
                    break;
                  case "error":
                    console.error(u);
                    break;
                  case "layout":
                    if (!o) {
                      const c = (0, a.apiPageLayoutToViewerModes)(u);
                      s.spreadMode = c.spreadMode;
                    }
                    break;
                  case "page-num":
                    s.currentPageNumber = u + 1;
                    break;
                  case "print":
                    await s.pagesPromise, this.#a.dispatch("print", {
                      source: this
                    });
                    break;
                  case "println":
                    console.log(u);
                    break;
                  case "zoom":
                    o || (s.currentScaleValue = u);
                    break;
                  case "SaveAs":
                    this.#a.dispatch("download", {
                      source: this
                    });
                    break;
                  case "FirstPage":
                    s.currentPageNumber = 1;
                    break;
                  case "LastPage":
                    s.currentPageNumber = s.pagesCount;
                    break;
                  case "NextPage":
                    s.nextPage();
                    break;
                  case "PrevPage":
                    s.previousPage();
                    break;
                  case "ZoomViewIn":
                    o || s.increaseScale();
                    break;
                  case "ZoomViewOut":
                    o || s.decreaseScale();
                    break;
                  case "WillPrintFinished":
                    this.#o?.resolve(), this.#o = null;
                    break;
                }
                return;
              }
              if (o && Z.focus)
                return;
              delete Z.id, delete Z.siblings;
              const i = N ? [F, ...N] : [F];
              for (const c of i) {
                const R = document.querySelector(`[data-element-id="${c}"]`);
                R ? R.dispatchEvent(new CustomEvent("updatefromsandbox", {
                  detail: Z
                })) : this.#i?.annotationStorage.setValue(c, Z);
              }
            }
            async #s(Z, s = !1) {
              const o = this.#i, F = this._visitedPages;
              if (s && (this.#l = Promise.withResolvers()), !this.#l)
                return;
              const N = this.#U.getPageView(Z - 1);
              if (N?.renderingState !== a.RenderingStates.FINISHED) {
                this._pageOpenPending.add(Z);
                return;
              }
              this._pageOpenPending.delete(Z);
              const Q = (async () => {
                const u = await (F.has(Z) ? null : N.pdfPage?.getJSActions());
                o === this.#i && await this.#Z?.dispatchEventInSandbox({
                  id: "page",
                  name: "PageOpen",
                  pageNumber: Z,
                  actions: u
                });
              })();
              F.set(Z, Q);
            }
            async #Q(Z) {
              const s = this.#i, o = this._visitedPages;
              if (!this.#l || this._pageOpenPending.has(Z))
                return;
              const F = o.get(Z);
              F && (o.set(Z, null), await F, s === this.#i && await this.#Z?.dispatchEventInSandbox({
                id: "page",
                name: "PageClose",
                pageNumber: Z
              }));
            }
            #W() {
              if (this.#t = Promise.withResolvers(), this.#Z)
                throw new Error("#initScripting: Scripting already exists.");
              return this.#e.createScripting();
            }
            async #V() {
              if (!this.#Z) {
                this.#i = null, this.#t?.resolve();
                return;
              }
              this.#l && (await Promise.race([this.#l.promise, new Promise((Z) => {
                setTimeout(Z, 1e3);
              })]).catch(() => {
              }), this.#l = null), this.#i = null;
              try {
                await this.#Z.destroySandbox();
              } catch {
              }
              this.#o?.reject(new Error("Scripting destroyed.")), this.#o = null, this.#d?.abort(), this.#d = null, this._pageOpenPending.clear(), this._visitedPages.clear(), this.#Z = null, this.#c = !1, this.#t?.resolve();
            }
          }
          d();
        } catch (h) {
          d(h);
        }
      });
    }
  ),
  /***/
  838: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            PDFSinglePageViewer: () => (
              /* binding */
              h
            )
            /* harmony export */
          });
          var a = n(256), U = n(285), V = e([U]);
          U = (V.then ? (await V)() : V)[0];
          class h extends U.PDFViewer {
            _resetView() {
              super._resetView(), this._scrollMode = a.ScrollMode.PAGE, this._spreadMode = a.SpreadMode.NONE;
            }
            set scrollMode(Z) {
            }
            _updateScrollMode() {
            }
            set spreadMode(Z) {
            }
            _updateSpreadMode() {
            }
          }
          d();
        } catch (h) {
          d(h);
        }
      });
    }
  ),
  /***/
  624: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            AnnotationLayerBuilder: () => (
              /* reexport safe */
              h.AnnotationLayerBuilder
            ),
            /* harmony export */
            DownloadManager: () => (
              /* reexport safe */
              W.DownloadManager
            ),
            /* harmony export */
            EventBus: () => (
              /* reexport safe */
              Z.EventBus
            ),
            /* harmony export */
            FindState: () => (
              /* reexport safe */
              a.FindState
            ),
            /* harmony export */
            GenericL10n: () => (
              /* reexport safe */
              s.GenericL10n
            ),
            /* harmony export */
            LinkTarget: () => (
              /* reexport safe */
              U.LinkTarget
            ),
            /* harmony export */
            PDFFindController: () => (
              /* reexport safe */
              a.PDFFindController
            ),
            /* harmony export */
            PDFHistory: () => (
              /* reexport safe */
              o.PDFHistory
            ),
            /* harmony export */
            PDFLinkService: () => (
              /* reexport safe */
              U.PDFLinkService
            ),
            /* harmony export */
            PDFPageView: () => (
              /* reexport safe */
              F.PDFPageView
            ),
            /* harmony export */
            PDFScriptingManager: () => (
              /* reexport safe */
              N.PDFScriptingManager
            ),
            /* harmony export */
            PDFSinglePageViewer: () => (
              /* reexport safe */
              Q.PDFSinglePageViewer
            ),
            /* harmony export */
            PDFViewer: () => (
              /* reexport safe */
              u.PDFViewer
            ),
            /* harmony export */
            ProgressBar: () => (
              /* reexport safe */
              V.ProgressBar
            ),
            /* harmony export */
            RenderingStates: () => (
              /* reexport safe */
              V.RenderingStates
            ),
            /* harmony export */
            ScrollMode: () => (
              /* reexport safe */
              V.ScrollMode
            ),
            /* harmony export */
            SimpleLinkService: () => (
              /* reexport safe */
              U.SimpleLinkService
            ),
            /* harmony export */
            SpreadMode: () => (
              /* reexport safe */
              V.SpreadMode
            ),
            /* harmony export */
            StructTreeLayerBuilder: () => (
              /* reexport safe */
              i.StructTreeLayerBuilder
            ),
            /* harmony export */
            TextLayerBuilder: () => (
              /* reexport safe */
              c.TextLayerBuilder
            ),
            /* harmony export */
            XfaLayerBuilder: () => (
              /* reexport safe */
              R.XfaLayerBuilder
            ),
            /* harmony export */
            parseQueryString: () => (
              /* reexport safe */
              V.parseQueryString
            )
            /* harmony export */
          });
          var a = n(814), U = n(787), V = n(256), h = n(707), W = n(544), Z = n(656), s = n(410), o = n(543), F = n(966), N = n(371), Q = n(838), u = n(285), i = n(698), c = n(765), R = n(973), m = e([h, W, s, F, N, Q, u, c, R]);
          [h, W, s, F, N, Q, u, c, R] = m.then ? (await m)() : m;
          const M = "4.2.67", S = "49b388101";
          d();
        } catch (M) {
          d(M);
        }
      });
    }
  ),
  /***/
  285: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          let N = function(i) {
            return Object.values(a.AnnotationEditorType).includes(i) && i !== a.AnnotationEditorType.DISABLE;
          };
          n.d(t, {
            /* harmony export */
            PDFViewer: () => (
              /* binding */
              u
            )
            /* harmony export */
          });
          var a = n(603), U = n(256), V = n(410), h = n(966), W = n(615), Z = n(787), s = e([a, V, h, W]);
          [a, V, h, W] = s.then ? (await s)() : s;
          const o = 10, F = {
            FORCE_SCROLL_MODE_PAGE: 15e3,
            FORCE_LAZY_PAGE_INIT: 7500,
            PAUSE_EAGER_PAGE_INIT: 250
          };
          class Q {
            #l = /* @__PURE__ */ new Set();
            #t = 0;
            constructor(c) {
              this.#t = c;
            }
            push(c) {
              const R = this.#l;
              R.has(c) && R.delete(c), R.add(c), R.size > this.#t && this.#n();
            }
            resize(c, R = null) {
              this.#t = c;
              const m = this.#l;
              if (R) {
                const M = m.size;
                let S = 1;
                for (const p of m)
                  if (R.has(p.id) && (m.delete(p), m.add(p)), ++S > M)
                    break;
              }
              for (; m.size > this.#t; )
                this.#n();
            }
            has(c) {
              return this.#l.has(c);
            }
            [Symbol.iterator]() {
              return this.#l.keys();
            }
            #n() {
              const c = this.#l.keys().next().value;
              c?.destroy(), this.#l.delete(c);
            }
          }
          class u {
            #l = null;
            #t = null;
            #n = null;
            #d = a.AnnotationEditorType.NONE;
            #a = null;
            #e = a.AnnotationMode.ENABLE_FORMS;
            #i = null;
            #U = null;
            #c = !1;
            #Z = !1;
            #o = null;
            #F = !1;
            #s = null;
            #Q = !1;
            #W = 0;
            #V = new ResizeObserver(this.#B.bind(this));
            #R = null;
            #h = null;
            #N = null;
            #m = U.TextLayerMode.ENABLE;
            constructor(c) {
              const R = "4.2.67";
              if (a.version !== R)
                throw new Error(`The API version "${a.version}" does not match the Viewer version "${R}".`);
              if (this.container = c.container, this.viewer = c.viewer || c.container.firstElementChild, this.container?.tagName !== "DIV" || this.viewer?.tagName !== "DIV")
                throw new Error("Invalid `container` and/or `viewer` option.");
              if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute")
                throw new Error("The `container` must be absolutely positioned.");
              this.#V.observe(this.container), this.eventBus = c.eventBus, this.linkService = c.linkService || new Z.SimpleLinkService(), this.downloadManager = c.downloadManager || null, this.findController = c.findController || null, this.#t = c.altTextManager || null, this.findController && (this.findController.onIsPageVisible = (m) => this._getVisiblePages().ids.has(m)), this._scriptingManager = c.scriptingManager || null, this.#m = c.textLayerMode ?? U.TextLayerMode.ENABLE, this.#e = c.annotationMode ?? a.AnnotationMode.ENABLE_FORMS, this.#d = c.annotationEditorMode ?? a.AnnotationEditorType.NONE, this.#n = c.annotationEditorHighlightColors || null, this.#c = c.enableHighlightFloatingButton === !0, this.imageResourcesPath = c.imageResourcesPath || "", this.enablePrintAutoRotate = c.enablePrintAutoRotate || !1, this.removePageBorders = c.removePageBorders || !1, this.maxCanvasPixels = c.maxCanvasPixels, this.l10n = c.l10n, this.l10n ||= new V.GenericL10n(), this.#Z = c.enablePermissions || !1, this.pageColors = c.pageColors || null, this.#o = c.mlManager || null, this.defaultRenderingQueue = !c.renderingQueue, this.defaultRenderingQueue ? (this.renderingQueue = new W.PDFRenderingQueue(), this.renderingQueue.setViewer(this)) : this.renderingQueue = c.renderingQueue, this.scroll = (0, U.watchScroll)(this.container, this._scrollUpdate.bind(this)), this.presentationModeState = U.PresentationModeState.UNKNOWN, this._onBeforeDraw = this._onAfterDraw = null, this._resetView(), this.removePageBorders && this.viewer.classList.add("removePageBorders"), this.#L(), this.eventBus._on("thumbnailrendered", ({
                pageNumber: m,
                pdfPage: M
              }) => {
                const S = this._pages[m - 1];
                this.#l.has(S) || M?.cleanup();
              }), c.l10n || this.l10n.translate(this.container);
            }
            get pagesCount() {
              return this._pages.length;
            }
            getPageView(c) {
              return this._pages[c];
            }
            getCachedPageViews() {
              return new Set(this.#l);
            }
            get pageViewsReady() {
              return this._pages.every((c) => c?.pdfPage);
            }
            get renderForms() {
              return this.#e === a.AnnotationMode.ENABLE_FORMS;
            }
            get enableScripting() {
              return !!this._scriptingManager;
            }
            get currentPageNumber() {
              return this._currentPageNumber;
            }
            set currentPageNumber(c) {
              if (!Number.isInteger(c))
                throw new Error("Invalid page number.");
              this.pdfDocument && (this._setCurrentPageNumber(c, !0) || console.error(`currentPageNumber: "${c}" is not a valid page.`));
            }
            _setCurrentPageNumber(c, R = !1) {
              if (this._currentPageNumber === c)
                return R && this.#J(), !0;
              if (!(0 < c && c <= this.pagesCount))
                return !1;
              const m = this._currentPageNumber;
              return this._currentPageNumber = c, this.eventBus.dispatch("pagechanging", {
                source: this,
                pageNumber: c,
                pageLabel: this._pageLabels?.[c - 1] ?? null,
                previous: m
              }), R && this.#J(), !0;
            }
            get currentPageLabel() {
              return this._pageLabels?.[this._currentPageNumber - 1] ?? null;
            }
            set currentPageLabel(c) {
              if (!this.pdfDocument)
                return;
              let R = c | 0;
              if (this._pageLabels) {
                const m = this._pageLabels.indexOf(c);
                m >= 0 && (R = m + 1);
              }
              this._setCurrentPageNumber(R, !0) || console.error(`currentPageLabel: "${c}" is not a valid page.`);
            }
            get currentScale() {
              return this._currentScale !== U.UNKNOWN_SCALE ? this._currentScale : U.DEFAULT_SCALE;
            }
            set currentScale(c) {
              if (isNaN(c))
                throw new Error("Invalid numeric scale.");
              this.pdfDocument && this.#r(c, {
                noScroll: !1
              });
            }
            get currentScaleValue() {
              return this._currentScaleValue;
            }
            set currentScaleValue(c) {
              this.pdfDocument && this.#r(c, {
                noScroll: !1
              });
            }
            get pagesRotation() {
              return this._pagesRotation;
            }
            set pagesRotation(c) {
              if (!(0, U.isValidRotation)(c))
                throw new Error("Invalid pages rotation angle.");
              if (!this.pdfDocument || (c %= 360, c < 0 && (c += 360), this._pagesRotation === c))
                return;
              this._pagesRotation = c;
              const R = this._currentPageNumber;
              this.refresh(!0, {
                rotation: c
              }), this._currentScaleValue && this.#r(this._currentScaleValue, {
                noScroll: !0
              }), this.eventBus.dispatch("rotationchanging", {
                source: this,
                pagesRotation: c,
                pageNumber: R
              }), this.defaultRenderingQueue && this.update();
            }
            get firstPagePromise() {
              return this.pdfDocument ? this._firstPageCapability.promise : null;
            }
            get onePageRendered() {
              return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
            }
            get pagesPromise() {
              return this.pdfDocument ? this._pagesCapability.promise : null;
            }
            get _layerProperties() {
              const c = this;
              return (0, a.shadow)(this, "_layerProperties", {
                get annotationEditorUIManager() {
                  return c.#a;
                },
                get annotationStorage() {
                  return c.pdfDocument?.annotationStorage;
                },
                get downloadManager() {
                  return c.downloadManager;
                },
                get enableScripting() {
                  return !!c._scriptingManager;
                },
                get fieldObjectsPromise() {
                  return c.pdfDocument?.getFieldObjects();
                },
                get findController() {
                  return c.findController;
                },
                get hasJSActionsPromise() {
                  return c.pdfDocument?.hasJSActions();
                },
                get linkService() {
                  return c.linkService;
                }
              });
            }
            #M(c) {
              const R = {
                annotationEditorMode: this.#d,
                annotationMode: this.#e,
                textLayerMode: this.#m
              };
              return c && (!c.includes(a.PermissionFlag.COPY) && this.#m === U.TextLayerMode.ENABLE && (R.textLayerMode = U.TextLayerMode.ENABLE_PERMISSIONS), c.includes(a.PermissionFlag.MODIFY_CONTENTS) || (R.annotationEditorMode = a.AnnotationEditorType.DISABLE), !c.includes(a.PermissionFlag.MODIFY_ANNOTATIONS) && !c.includes(a.PermissionFlag.FILL_INTERACTIVE_FORMS) && this.#e === a.AnnotationMode.ENABLE_FORMS && (R.annotationMode = a.AnnotationMode.ENABLE)), R;
            }
            async #T() {
              if (document.visibilityState === "hidden" || !this.container.offsetParent || this._getVisiblePages().views.length === 0)
                return;
              const c = new Promise((R) => {
                this.#h = () => {
                  document.visibilityState === "hidden" && R();
                }, document.addEventListener("visibilitychange", this.#h);
              });
              await Promise.race([this._onePageRenderedCapability.promise, c]), document.removeEventListener("visibilitychange", this.#h), this.#h = null;
            }
            async getAllText() {
              const c = [], R = [];
              for (let m = 1, M = this.pdfDocument.numPages; m <= M; ++m) {
                if (this.#Q)
                  return null;
                R.length = 0;
                const S = await this.pdfDocument.getPage(m), {
                  items: p
                } = await S.getTextContent();
                for (const Y of p)
                  Y.str && R.push(Y.str), Y.hasEOL && R.push(`
`);
                c.push((0, U.removeNullCharacters)(R.join("")));
              }
              return c.join(`
`);
            }
            #G(c, R) {
              const m = document.getSelection(), {
                focusNode: M,
                anchorNode: S
              } = m;
              if (S && M && m.containsNode(this.#s)) {
                if (this.#F || c === U.TextLayerMode.ENABLE_PERMISSIONS) {
                  R.preventDefault(), R.stopPropagation();
                  return;
                }
                this.#F = !0;
                const p = this.container.style.cursor;
                this.container.style.cursor = "wait";
                const Y = (k) => this.#Q = k.key === "Escape";
                window.addEventListener("keydown", Y), this.getAllText().then(async (k) => {
                  k !== null && await navigator.clipboard.writeText(k);
                }).catch((k) => {
                  console.warn(`Something goes wrong when extracting the text: ${k.message}`);
                }).finally(() => {
                  this.#F = !1, this.#Q = !1, window.removeEventListener("keydown", Y), this.container.style.cursor = p;
                }), R.preventDefault(), R.stopPropagation();
              }
            }
            setDocument(c) {
              if (this.pdfDocument && (this.eventBus.dispatch("pagesdestroy", {
                source: this
              }), this._cancelRendering(), this._resetView(), this.findController?.setDocument(null), this._scriptingManager?.setDocument(null), this.#a && (this.#a.destroy(), this.#a = null)), this.pdfDocument = c, !c)
                return;
              const R = c.numPages, m = c.getPage(1), M = c.getOptionalContentConfig({
                intent: "display"
              }), S = this.#Z ? c.getPermissions() : Promise.resolve();
              if (R > F.FORCE_SCROLL_MODE_PAGE) {
                console.warn("Forcing PAGE-scrolling for performance reasons, given the length of the document.");
                const p = this._scrollMode = U.ScrollMode.PAGE;
                this.eventBus.dispatch("scrollmodechanged", {
                  source: this,
                  mode: p
                });
              }
              this._pagesCapability.promise.then(() => {
                this.eventBus.dispatch("pagesloaded", {
                  source: this,
                  pagesCount: R
                });
              }, () => {
              }), this._onBeforeDraw = (p) => {
                const Y = this._pages[p.pageNumber - 1];
                Y && this.#l.push(Y);
              }, this.eventBus._on("pagerender", this._onBeforeDraw), this._onAfterDraw = (p) => {
                p.cssTransform || (this._onePageRenderedCapability.resolve({
                  timestamp: p.timestamp
                }), this.eventBus._off("pagerendered", this._onAfterDraw), this._onAfterDraw = null);
              }, this.eventBus._on("pagerendered", this._onAfterDraw), Promise.all([m, S]).then(([p, Y]) => {
                if (c !== this.pdfDocument)
                  return;
                this._firstPageCapability.resolve(p), this._optionalContentConfigPromise = M;
                const {
                  annotationEditorMode: k,
                  annotationMode: L,
                  textLayerMode: z
                } = this.#M(Y);
                if (z !== U.TextLayerMode.DISABLE) {
                  const w = this.#s = document.createElement("div");
                  w.id = "hiddenCopyElement", this.viewer.before(w);
                }
                if (k !== a.AnnotationEditorType.DISABLE) {
                  const w = k;
                  c.isPureXfa ? console.warn("Warning: XFA-editing is not implemented.") : N(w) ? (this.#a = new a.AnnotationEditorUIManager(this.container, this.viewer, this.#t, this.eventBus, c, this.pageColors, this.#n, this.#c, this.#o), this.eventBus.dispatch("annotationeditoruimanager", {
                    source: this,
                    uiManager: this.#a
                  }), w !== a.AnnotationEditorType.NONE && this.#a.updateMode(w)) : console.error(`Invalid AnnotationEditor mode: ${w}`);
                }
                const f = this._scrollMode === U.ScrollMode.PAGE ? null : this.viewer, K = this.currentScale, P = p.getViewport({
                  scale: K * a.PixelsPerInch.PDF_TO_CSS_UNITS
                });
                this.viewer.style.setProperty("--scale-factor", P.scale), (this.pageColors?.foreground === "CanvasText" || this.pageColors?.background === "Canvas") && (this.viewer.style.setProperty("--hcm-highlight-filter", c.filterFactory.addHighlightHCMFilter("highlight", "CanvasText", "Canvas", "HighlightText", "Highlight")), this.viewer.style.setProperty("--hcm-highlight-selected-filter", c.filterFactory.addHighlightHCMFilter("highlight_selected", "CanvasText", "Canvas", "HighlightText", "ButtonText")));
                for (let w = 1; w <= R; ++w) {
                  const O = new h.PDFPageView({
                    container: f,
                    eventBus: this.eventBus,
                    id: w,
                    scale: K,
                    defaultViewport: P.clone(),
                    optionalContentConfigPromise: M,
                    renderingQueue: this.renderingQueue,
                    textLayerMode: z,
                    annotationMode: L,
                    imageResourcesPath: this.imageResourcesPath,
                    maxCanvasPixels: this.maxCanvasPixels,
                    pageColors: this.pageColors,
                    l10n: this.l10n,
                    layerProperties: this._layerProperties
                  });
                  this._pages.push(O);
                }
                this._pages[0]?.setPdfPage(p), this._scrollMode === U.ScrollMode.PAGE ? this.#X() : this._spreadMode !== U.SpreadMode.NONE && this._updateSpreadMode(), this.#T().then(async () => {
                  if (this.findController?.setDocument(c), this._scriptingManager?.setDocument(c), this.#s && (this.#U = this.#G.bind(this, z), document.addEventListener("copy", this.#U)), this.#a && this.eventBus.dispatch("annotationeditormodechanged", {
                    source: this,
                    mode: this.#d
                  }), c.loadingParams.disableAutoFetch || R > F.FORCE_LAZY_PAGE_INIT) {
                    this._pagesCapability.resolve();
                    return;
                  }
                  let w = R - 1;
                  if (w <= 0) {
                    this._pagesCapability.resolve();
                    return;
                  }
                  for (let O = 2; O <= R; ++O) {
                    const el = c.getPage(O).then((ll) => {
                      const q = this._pages[O - 1];
                      q.pdfPage || q.setPdfPage(ll), --w === 0 && this._pagesCapability.resolve();
                    }, (ll) => {
                      console.error(`Unable to get page ${O} to initialize viewer`, ll), --w === 0 && this._pagesCapability.resolve();
                    });
                    O % F.PAUSE_EAGER_PAGE_INIT === 0 && await el;
                  }
                }), this.eventBus.dispatch("pagesinit", {
                  source: this
                }), c.getMetadata().then(({
                  info: w
                }) => {
                  c === this.pdfDocument && w.Language && (this.viewer.lang = w.Language);
                }), this.defaultRenderingQueue && this.update();
              }).catch((p) => {
                console.error("Unable to initialize viewer", p), this._pagesCapability.reject(p);
              });
            }
            setPageLabels(c) {
              if (this.pdfDocument) {
                c ? Array.isArray(c) && this.pdfDocument.numPages === c.length ? this._pageLabels = c : (this._pageLabels = null, console.error("setPageLabels: Invalid page labels.")) : this._pageLabels = null;
                for (let R = 0, m = this._pages.length; R < m; R++)
                  this._pages[R].setPageLabel(this._pageLabels?.[R] ?? null);
              }
            }
            _resetView() {
              this._pages = [], this._currentPageNumber = 1, this._currentScale = U.UNKNOWN_SCALE, this._currentScaleValue = null, this._pageLabels = null, this.#l = new Q(o), this._location = null, this._pagesRotation = 0, this._optionalContentConfigPromise = null, this._firstPageCapability = Promise.withResolvers(), this._onePageRenderedCapability = Promise.withResolvers(), this._pagesCapability = Promise.withResolvers(), this._scrollMode = U.ScrollMode.VERTICAL, this._previousScrollMode = U.ScrollMode.UNKNOWN, this._spreadMode = U.SpreadMode.NONE, this.#R = {
                previousPageNumber: 1,
                scrollDown: !0,
                pages: []
              }, this._onBeforeDraw && (this.eventBus._off("pagerender", this._onBeforeDraw), this._onBeforeDraw = null), this._onAfterDraw && (this.eventBus._off("pagerendered", this._onAfterDraw), this._onAfterDraw = null), this.#h && (document.removeEventListener("visibilitychange", this.#h), this.#h = null), this.viewer.textContent = "", this._updateScrollMode(), this.viewer.removeAttribute("lang"), this.#s && (document.removeEventListener("copy", this.#U), this.#U = null, this.#s.remove(), this.#s = null);
            }
            #X() {
              if (this._scrollMode !== U.ScrollMode.PAGE)
                throw new Error("#ensurePageViewVisible: Invalid scrollMode value.");
              const c = this._currentPageNumber, R = this.#R, m = this.viewer;
              if (m.textContent = "", R.pages.length = 0, this._spreadMode === U.SpreadMode.NONE && !this.isInPresentationMode) {
                const M = this._pages[c - 1];
                m.append(M.div), R.pages.push(M);
              } else {
                const M = /* @__PURE__ */ new Set(), S = this._spreadMode - 1;
                S === -1 ? M.add(c - 1) : c % 2 !== S ? (M.add(c - 1), M.add(c)) : (M.add(c - 2), M.add(c - 1));
                const p = document.createElement("div");
                if (p.className = "spread", this.isInPresentationMode) {
                  const Y = document.createElement("div");
                  Y.className = "dummyPage", p.append(Y);
                }
                for (const Y of M) {
                  const k = this._pages[Y];
                  k && (p.append(k.div), R.pages.push(k));
                }
                m.append(p);
              }
              R.scrollDown = c >= R.previousPageNumber, R.previousPageNumber = c;
            }
            _scrollUpdate() {
              this.pagesCount !== 0 && this.update();
            }
            #u(c, R = null) {
              const {
                div: m,
                id: M
              } = c;
              if (this._currentPageNumber !== M && this._setCurrentPageNumber(M), this._scrollMode === U.ScrollMode.PAGE && (this.#X(), this.update()), !R && !this.isInPresentationMode) {
                const S = m.offsetLeft + m.clientLeft, p = S + m.clientWidth, {
                  scrollLeft: Y,
                  clientWidth: k
                } = this.container;
                (this._scrollMode === U.ScrollMode.HORIZONTAL || S < Y || p > Y + k) && (R = {
                  left: 0,
                  top: 0
                });
              }
              (0, U.scrollIntoView)(m, R), !this._currentScaleValue && this._location && (this._location = null);
            }
            #b(c) {
              return c === this._currentScale || Math.abs(c - this._currentScale) < 1e-15;
            }
            #p(c, R, {
              noScroll: m = !1,
              preset: M = !1,
              drawingDelay: S = -1
            }) {
              if (this._currentScaleValue = R.toString(), this.#b(c)) {
                M && this.eventBus.dispatch("scalechanging", {
                  source: this,
                  scale: c,
                  presetValue: R
                });
                return;
              }
              this.viewer.style.setProperty("--scale-factor", c * a.PixelsPerInch.PDF_TO_CSS_UNITS);
              const p = S >= 0 && S < 1e3;
              if (this.refresh(!0, {
                scale: c,
                drawingDelay: p ? S : -1
              }), p && (this.#N = setTimeout(() => {
                this.#N = null, this.refresh();
              }, S)), this._currentScale = c, !m) {
                let Y = this._currentPageNumber, k;
                this._location && !(this.isInPresentationMode || this.isChangingPresentationMode) && (Y = this._location.pageNumber, k = [null, {
                  name: "XYZ"
                }, this._location.left, this._location.top, null]), this.scrollPageIntoView({
                  pageNumber: Y,
                  destArray: k,
                  allowNegativeOffset: !0
                });
              }
              this.eventBus.dispatch("scalechanging", {
                source: this,
                scale: c,
                presetValue: M ? R : void 0
              }), this.defaultRenderingQueue && this.update();
            }
            get #S() {
              return this._spreadMode !== U.SpreadMode.NONE && this._scrollMode !== U.ScrollMode.HORIZONTAL ? 2 : 1;
            }
            #r(c, R) {
              let m = parseFloat(c);
              if (m > 0)
                R.preset = !1, this.#p(m, c, R);
              else {
                const M = this._pages[this._currentPageNumber - 1];
                if (!M)
                  return;
                let S = U.SCROLLBAR_PADDING, p = U.VERTICAL_PADDING;
                this.isInPresentationMode ? (S = p = 4, this._spreadMode !== U.SpreadMode.NONE && (S *= 2)) : this.removePageBorders ? S = p = 0 : this._scrollMode === U.ScrollMode.HORIZONTAL && ([S, p] = [p, S]);
                const Y = (this.container.clientWidth - S) / M.width * M.scale / this.#S, k = (this.container.clientHeight - p) / M.height * M.scale;
                switch (c) {
                  case "page-actual":
                    m = 1;
                    break;
                  case "page-width":
                    m = Y;
                    break;
                  case "page-height":
                    m = k;
                    break;
                  case "page-fit":
                    m = Math.min(Y, k);
                    break;
                  case "auto":
                    const L = (0, U.isPortraitOrientation)(M) ? Y : Math.min(k, Y);
                    m = Math.min(U.MAX_AUTO_SCALE, L);
                    break;
                  default:
                    console.error(`#setScale: "${c}" is an unknown zoom value.`);
                    return;
                }
                R.preset = !0, this.#p(m, c, R);
              }
            }
            #J() {
              const c = this._pages[this._currentPageNumber - 1];
              this.isInPresentationMode && this.#r(this._currentScaleValue, {
                noScroll: !0
              }), this.#u(c);
            }
            pageLabelToPageNumber(c) {
              if (!this._pageLabels)
                return null;
              const R = this._pageLabels.indexOf(c);
              return R < 0 ? null : R + 1;
            }
            scrollPageIntoView({
              pageNumber: c,
              destArray: R = null,
              allowNegativeOffset: m = !1,
              ignoreDestinationZoom: M = !1
            }) {
              if (!this.pdfDocument)
                return;
              const S = Number.isInteger(c) && this._pages[c - 1];
              if (!S) {
                console.error(`scrollPageIntoView: "${c}" is not a valid pageNumber parameter.`);
                return;
              }
              if (this.isInPresentationMode || !R) {
                this._setCurrentPageNumber(c, !0);
                return;
              }
              let p = 0, Y = 0, k = 0, L = 0, z, f;
              const K = S.rotation % 180 !== 0, P = (K ? S.height : S.width) / S.scale / a.PixelsPerInch.PDF_TO_CSS_UNITS, w = (K ? S.width : S.height) / S.scale / a.PixelsPerInch.PDF_TO_CSS_UNITS;
              let O = 0;
              switch (R[1].name) {
                case "XYZ":
                  p = R[2], Y = R[3], O = R[4], p = p !== null ? p : 0, Y = Y !== null ? Y : w;
                  break;
                case "Fit":
                case "FitB":
                  O = "page-fit";
                  break;
                case "FitH":
                case "FitBH":
                  Y = R[2], O = "page-width", Y === null && this._location ? (p = this._location.left, Y = this._location.top) : (typeof Y != "number" || Y < 0) && (Y = w);
                  break;
                case "FitV":
                case "FitBV":
                  p = R[2], k = P, L = w, O = "page-height";
                  break;
                case "FitR":
                  p = R[2], Y = R[3], k = R[4] - p, L = R[5] - Y;
                  let _ = U.SCROLLBAR_PADDING, il = U.VERTICAL_PADDING;
                  this.removePageBorders && (_ = il = 0), z = (this.container.clientWidth - _) / k / a.PixelsPerInch.PDF_TO_CSS_UNITS, f = (this.container.clientHeight - il) / L / a.PixelsPerInch.PDF_TO_CSS_UNITS, O = Math.min(Math.abs(z), Math.abs(f));
                  break;
                default:
                  console.error(`scrollPageIntoView: "${R[1].name}" is not a valid destination type.`);
                  return;
              }
              if (M || (O && O !== this._currentScale ? this.currentScaleValue = O : this._currentScale === U.UNKNOWN_SCALE && (this.currentScaleValue = U.DEFAULT_SCALE_VALUE)), O === "page-fit" && !R[4]) {
                this.#u(S);
                return;
              }
              const el = [S.viewport.convertToViewportPoint(p, Y), S.viewport.convertToViewportPoint(p + k, Y + L)];
              let ll = Math.min(el[0][0], el[1][0]), q = Math.min(el[0][1], el[1][1]);
              m || (ll = Math.max(ll, 0), q = Math.max(q, 0)), this.#u(S, {
                left: ll,
                top: q
              });
            }
            _updateLocation(c) {
              const R = this._currentScale, m = this._currentScaleValue, M = parseFloat(m) === R ? Math.round(R * 1e4) / 100 : m, S = c.id, p = this._pages[S - 1], Y = this.container, k = p.getPagePoint(Y.scrollLeft - c.x, Y.scrollTop - c.y), L = Math.round(k[0]), z = Math.round(k[1]);
              let f = `#page=${S}`;
              this.isInPresentationMode || (f += `&zoom=${M},${L},${z}`), this._location = {
                pageNumber: S,
                scale: M,
                top: z,
                left: L,
                rotation: this._pagesRotation,
                pdfOpenParams: f
              };
            }
            update() {
              const c = this._getVisiblePages(), R = c.views, m = R.length;
              if (m === 0)
                return;
              const M = Math.max(o, 2 * m + 1);
              this.#l.resize(M, c.ids), this.renderingQueue.renderHighestPriority(c);
              const S = this._spreadMode === U.SpreadMode.NONE && (this._scrollMode === U.ScrollMode.PAGE || this._scrollMode === U.ScrollMode.VERTICAL), p = this._currentPageNumber;
              let Y = !1;
              for (const k of R) {
                if (k.percent < 100)
                  break;
                if (k.id === p && S) {
                  Y = !0;
                  break;
                }
              }
              this._setCurrentPageNumber(Y ? p : R[0].id), this._updateLocation(c.first), this.eventBus.dispatch("updateviewarea", {
                source: this,
                location: this._location
              });
            }
            containsElement(c) {
              return this.container.contains(c);
            }
            focus() {
              this.container.focus();
            }
            get _isContainerRtl() {
              return getComputedStyle(this.container).direction === "rtl";
            }
            get isInPresentationMode() {
              return this.presentationModeState === U.PresentationModeState.FULLSCREEN;
            }
            get isChangingPresentationMode() {
              return this.presentationModeState === U.PresentationModeState.CHANGING;
            }
            get isHorizontalScrollbarEnabled() {
              return this.isInPresentationMode ? !1 : this.container.scrollWidth > this.container.clientWidth;
            }
            get isVerticalScrollbarEnabled() {
              return this.isInPresentationMode ? !1 : this.container.scrollHeight > this.container.clientHeight;
            }
            _getVisiblePages() {
              const c = this._scrollMode === U.ScrollMode.PAGE ? this.#R.pages : this._pages, R = this._scrollMode === U.ScrollMode.HORIZONTAL, m = R && this._isContainerRtl;
              return (0, U.getVisibleElements)({
                scrollEl: this.container,
                views: c,
                sortByVisibility: !0,
                horizontal: R,
                rtl: m
              });
            }
            cleanup() {
              for (const c of this._pages)
                c.renderingState !== U.RenderingStates.FINISHED && c.reset();
            }
            _cancelRendering() {
              for (const c of this._pages)
                c.cancelRendering();
            }
            async #z(c) {
              if (c.pdfPage)
                return c.pdfPage;
              try {
                const R = await this.pdfDocument.getPage(c.id);
                return c.pdfPage || c.setPdfPage(R), R;
              } catch (R) {
                return console.error("Unable to get page for page view", R), null;
              }
            }
            #Y(c) {
              if (c.first?.id === 1)
                return !0;
              if (c.last?.id === this.pagesCount)
                return !1;
              switch (this._scrollMode) {
                case U.ScrollMode.PAGE:
                  return this.#R.scrollDown;
                case U.ScrollMode.HORIZONTAL:
                  return this.scroll.right;
              }
              return this.scroll.down;
            }
            forceRendering(c) {
              const R = c || this._getVisiblePages(), m = this.#Y(R), M = this._spreadMode !== U.SpreadMode.NONE && this._scrollMode !== U.ScrollMode.HORIZONTAL, S = this.renderingQueue.getHighestPriority(R, this._pages, m, M);
              return S ? (this.#z(S).then(() => {
                this.renderingQueue.renderView(S);
              }), !0) : !1;
            }
            get hasEqualPageSizes() {
              const c = this._pages[0];
              for (let R = 1, m = this._pages.length; R < m; ++R) {
                const M = this._pages[R];
                if (M.width !== c.width || M.height !== c.height)
                  return !1;
              }
              return !0;
            }
            getPagesOverview() {
              let c;
              return this._pages.map((R) => {
                const m = R.pdfPage.getViewport({
                  scale: 1
                }), M = (0, U.isPortraitOrientation)(m);
                if (c === void 0)
                  c = M;
                else if (this.enablePrintAutoRotate && M !== c)
                  return {
                    width: m.height,
                    height: m.width,
                    rotation: (m.rotation - 90) % 360
                  };
                return {
                  width: m.width,
                  height: m.height,
                  rotation: m.rotation
                };
              });
            }
            get optionalContentConfigPromise() {
              return this.pdfDocument ? this._optionalContentConfigPromise ? this._optionalContentConfigPromise : (console.error("optionalContentConfigPromise: Not initialized yet."), this.pdfDocument.getOptionalContentConfig({
                intent: "display"
              })) : Promise.resolve(null);
            }
            set optionalContentConfigPromise(c) {
              if (!(c instanceof Promise))
                throw new Error(`Invalid optionalContentConfigPromise: ${c}`);
              this.pdfDocument && this._optionalContentConfigPromise && (this._optionalContentConfigPromise = c, this.refresh(!1, {
                optionalContentConfigPromise: c
              }), this.eventBus.dispatch("optionalcontentconfigchanged", {
                source: this,
                promise: c
              }));
            }
            get scrollMode() {
              return this._scrollMode;
            }
            set scrollMode(c) {
              if (this._scrollMode !== c) {
                if (!(0, U.isValidScrollMode)(c))
                  throw new Error(`Invalid scroll mode: ${c}`);
                this.pagesCount > F.FORCE_SCROLL_MODE_PAGE || (this._previousScrollMode = this._scrollMode, this._scrollMode = c, this.eventBus.dispatch("scrollmodechanged", {
                  source: this,
                  mode: c
                }), this._updateScrollMode(this._currentPageNumber));
              }
            }
            _updateScrollMode(c = null) {
              const R = this._scrollMode, m = this.viewer;
              m.classList.toggle("scrollHorizontal", R === U.ScrollMode.HORIZONTAL), m.classList.toggle("scrollWrapped", R === U.ScrollMode.WRAPPED), !(!this.pdfDocument || !c) && (R === U.ScrollMode.PAGE ? this.#X() : this._previousScrollMode === U.ScrollMode.PAGE && this._updateSpreadMode(), this._currentScaleValue && isNaN(this._currentScaleValue) && this.#r(this._currentScaleValue, {
                noScroll: !0
              }), this._setCurrentPageNumber(c, !0), this.update());
            }
            get spreadMode() {
              return this._spreadMode;
            }
            set spreadMode(c) {
              if (this._spreadMode !== c) {
                if (!(0, U.isValidSpreadMode)(c))
                  throw new Error(`Invalid spread mode: ${c}`);
                this._spreadMode = c, this.eventBus.dispatch("spreadmodechanged", {
                  source: this,
                  mode: c
                }), this._updateSpreadMode(this._currentPageNumber);
              }
            }
            _updateSpreadMode(c = null) {
              if (!this.pdfDocument)
                return;
              const R = this.viewer, m = this._pages;
              if (this._scrollMode === U.ScrollMode.PAGE)
                this.#X();
              else if (R.textContent = "", this._spreadMode === U.SpreadMode.NONE)
                for (const M of this._pages)
                  R.append(M.div);
              else {
                const M = this._spreadMode - 1;
                let S = null;
                for (let p = 0, Y = m.length; p < Y; ++p)
                  S === null ? (S = document.createElement("div"), S.className = "spread", R.append(S)) : p % 2 === M && (S = S.cloneNode(!1), R.append(S)), S.append(m[p].div);
              }
              c && (this._currentScaleValue && isNaN(this._currentScaleValue) && this.#r(this._currentScaleValue, {
                noScroll: !0
              }), this._setCurrentPageNumber(c, !0), this.update());
            }
            _getPageAdvance(c, R = !1) {
              switch (this._scrollMode) {
                case U.ScrollMode.WRAPPED: {
                  const {
                    views: m
                  } = this._getVisiblePages(), M = /* @__PURE__ */ new Map();
                  for (const {
                    id: S,
                    y: p,
                    percent: Y,
                    widthPercent: k
                  } of m) {
                    if (Y === 0 || k < 100)
                      continue;
                    let L = M.get(p);
                    L || M.set(p, L ||= []), L.push(S);
                  }
                  for (const S of M.values()) {
                    const p = S.indexOf(c);
                    if (p === -1)
                      continue;
                    const Y = S.length;
                    if (Y === 1)
                      break;
                    if (R)
                      for (let k = p - 1, L = 0; k >= L; k--) {
                        const z = S[k], f = S[k + 1] - 1;
                        if (z < f)
                          return c - f;
                      }
                    else
                      for (let k = p + 1, L = Y; k < L; k++) {
                        const z = S[k], f = S[k - 1] + 1;
                        if (z > f)
                          return f - c;
                      }
                    if (R) {
                      const k = S[0];
                      if (k < c)
                        return c - k + 1;
                    } else {
                      const k = S[Y - 1];
                      if (k > c)
                        return k - c + 1;
                    }
                    break;
                  }
                  break;
                }
                case U.ScrollMode.HORIZONTAL:
                  break;
                case U.ScrollMode.PAGE:
                case U.ScrollMode.VERTICAL: {
                  if (this._spreadMode === U.SpreadMode.NONE)
                    break;
                  const m = this._spreadMode - 1;
                  if (R && c % 2 !== m)
                    break;
                  if (!R && c % 2 === m)
                    break;
                  const {
                    views: M
                  } = this._getVisiblePages(), S = R ? c - 1 : c + 1;
                  for (const {
                    id: p,
                    percent: Y,
                    widthPercent: k
                  } of M)
                    if (p === S) {
                      if (Y > 0 && k === 100)
                        return 2;
                      break;
                    }
                  break;
                }
              }
              return 1;
            }
            nextPage() {
              const c = this._currentPageNumber, R = this.pagesCount;
              if (c >= R)
                return !1;
              const m = this._getPageAdvance(c, !1) || 1;
              return this.currentPageNumber = Math.min(c + m, R), !0;
            }
            previousPage() {
              const c = this._currentPageNumber;
              if (c <= 1)
                return !1;
              const R = this._getPageAdvance(c, !0) || 1;
              return this.currentPageNumber = Math.max(c - R, 1), !0;
            }
            increaseScale({
              drawingDelay: c,
              scaleFactor: R,
              steps: m
            } = {}) {
              if (!this.pdfDocument)
                return;
              let M = this._currentScale;
              if (R > 1)
                M = Math.round(M * R * 100) / 100;
              else {
                m ??= 1;
                do
                  M = Math.ceil((M * U.DEFAULT_SCALE_DELTA).toFixed(2) * 10) / 10;
                while (--m > 0 && M < U.MAX_SCALE);
              }
              this.#r(Math.min(U.MAX_SCALE, M), {
                noScroll: !1,
                drawingDelay: c
              });
            }
            decreaseScale({
              drawingDelay: c,
              scaleFactor: R,
              steps: m
            } = {}) {
              if (!this.pdfDocument)
                return;
              let M = this._currentScale;
              if (R > 0 && R < 1)
                M = Math.round(M * R * 100) / 100;
              else {
                m ??= 1;
                do
                  M = Math.floor((M / U.DEFAULT_SCALE_DELTA).toFixed(2) * 10) / 10;
                while (--m > 0 && M > U.MIN_SCALE);
              }
              this.#r(Math.max(U.MIN_SCALE, M), {
                noScroll: !1,
                drawingDelay: c
              });
            }
            #L(c = this.container.clientHeight) {
              c !== this.#W && (this.#W = c, U.docStyle.setProperty("--viewer-container-height", `${c}px`));
            }
            #B(c) {
              for (const R of c)
                if (R.target === this.container) {
                  this.#L(Math.floor(R.borderBoxSize[0].blockSize)), this.#i = null;
                  break;
                }
            }
            get containerTopLeft() {
              return this.#i ||= [this.container.offsetTop, this.container.offsetLeft];
            }
            get annotationEditorMode() {
              return this.#a ? this.#d : a.AnnotationEditorType.DISABLE;
            }
            set annotationEditorMode({
              mode: c,
              editId: R = null,
              isFromKeyboard: m = !1
            }) {
              if (!this.#a)
                throw new Error("The AnnotationEditor is not enabled.");
              if (this.#d !== c) {
                if (!N(c))
                  throw new Error(`Invalid AnnotationEditor mode: ${c}`);
                this.pdfDocument && (this.#d = c, this.eventBus.dispatch("annotationeditormodechanged", {
                  source: this,
                  mode: c
                }), this.#a.updateMode(c, R, m));
              }
            }
            set annotationEditorParams({
              type: c,
              value: R
            }) {
              if (!this.#a)
                throw new Error("The AnnotationEditor is not enabled.");
              this.#a.updateParams(c, R);
            }
            refresh(c = !1, R = /* @__PURE__ */ Object.create(null)) {
              if (this.pdfDocument) {
                for (const m of this._pages)
                  m.update(R);
                this.#N !== null && (clearTimeout(this.#N), this.#N = null), c || this.update();
              }
            }
          }
          d();
        } catch (o) {
          d(o);
        }
      });
    }
  ),
  /***/
  603: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            AbortException: () => (
              /* binding */
              a
            ),
            /* harmony export */
            AnnotationEditorLayer: () => (
              /* binding */
              U
            ),
            /* harmony export */
            AnnotationEditorType: () => (
              /* binding */
              h
            ),
            /* harmony export */
            AnnotationEditorUIManager: () => (
              /* binding */
              W
            ),
            /* harmony export */
            AnnotationLayer: () => (
              /* binding */
              Z
            ),
            /* harmony export */
            AnnotationMode: () => (
              /* binding */
              s
            ),
            /* harmony export */
            DrawLayer: () => (
              /* binding */
              i
            ),
            /* harmony export */
            PermissionFlag: () => (
              /* binding */
              dl
            ),
            /* harmony export */
            PixelsPerInch: () => (
              /* binding */
              tl
            ),
            /* harmony export */
            RenderingCancelledException: () => (
              /* binding */
              al
            ),
            /* harmony export */
            XfaLayer: () => (
              /* binding */
              T
            ),
            /* harmony export */
            createValidAbsoluteUrl: () => (
              /* binding */
              Q
            ),
            /* harmony export */
            fetchData: () => (
              /* binding */
              R
            ),
            /* harmony export */
            getPdfFilenameFromUrl: () => (
              /* binding */
              S
            ),
            /* harmony export */
            isPdfFile: () => (
              /* binding */
              f
            ),
            /* harmony export */
            normalizeUnicode: () => (
              /* binding */
              w
            ),
            /* harmony export */
            renderTextLayer: () => (
              /* binding */
              Ul
            ),
            /* harmony export */
            setLayerDimensions: () => (
              /* binding */
              cl
            ),
            /* harmony export */
            shadow: () => (
              /* binding */
              B
            ),
            /* harmony export */
            updateTextLayer: () => (
              /* binding */
              b
            ),
            /* harmony export */
            version: () => (
              /* binding */
              J
            )
            /* harmony export */
          }), globalThis.pdfjsLib || await globalThis.pdfjsLibPromise;
          const {
            AbortException: a,
            AnnotationEditorLayer: U,
            AnnotationEditorParamsType: V,
            AnnotationEditorType: h,
            AnnotationEditorUIManager: W,
            AnnotationLayer: Z,
            AnnotationMode: s,
            build: o,
            CMapCompressionType: F,
            ColorPicker: N,
            createValidAbsoluteUrl: Q,
            DOMSVGFactory: u,
            DrawLayer: i,
            FeatureTest: c,
            fetchData: R,
            getDocument: m,
            getFilenameFromUrl: M,
            getPdfFilenameFromUrl: S,
            getXfaPageViewport: p,
            GlobalWorkerOptions: Y,
            ImageKind: k,
            InvalidPDFException: L,
            isDataScheme: z,
            isPdfFile: f,
            MissingPDFException: K,
            noContextMenu: P,
            normalizeUnicode: w,
            OPS: O,
            Outliner: el,
            PasswordResponses: ll,
            PDFDataRangeTransport: q,
            PDFDateString: _,
            PDFWorker: il,
            PermissionFlag: dl,
            PixelsPerInch: tl,
            RenderingCancelledException: al,
            renderTextLayer: Ul,
            setLayerDimensions: cl,
            shadow: B,
            UnexpectedResponseException: X,
            updateTextLayer: b,
            Util: r,
            VerbosityLevel: G,
            version: J,
            XfaLayer: T
          } = globalThis.pdfjsLib;
          d();
        } catch (a) {
          d(a);
        }
      }, 1);
    }
  ),
  /***/
  698: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        StructTreeLayerBuilder: () => (
          /* binding */
          U
        )
        /* harmony export */
      });
      var e = n(256);
      const d = {
        Document: null,
        DocumentFragment: null,
        Part: "group",
        Sect: "group",
        Div: "group",
        Aside: "note",
        NonStruct: "none",
        P: null,
        H: "heading",
        Title: null,
        FENote: "note",
        Sub: "group",
        Lbl: null,
        Span: null,
        Em: null,
        Strong: null,
        Link: "link",
        Annot: "note",
        Form: "form",
        Ruby: null,
        RB: null,
        RT: null,
        RP: null,
        Warichu: null,
        WT: null,
        WP: null,
        L: "list",
        LI: "listitem",
        LBody: null,
        Table: "table",
        TR: "row",
        TH: "columnheader",
        TD: "cell",
        THead: "columnheader",
        TBody: null,
        TFoot: null,
        Caption: null,
        Figure: "figure",
        Formula: null,
        Artifact: null
      }, a = /^H(\d+)$/;
      class U {
        #l = void 0;
        get renderingDone() {
          return this.#l !== void 0;
        }
        render(h) {
          if (this.#l !== void 0)
            return this.#l;
          const W = this.#n(h);
          return W?.classList.add("structTree"), this.#l = W;
        }
        hide() {
          this.#l && !this.#l.hidden && (this.#l.hidden = !0);
        }
        show() {
          this.#l?.hidden && (this.#l.hidden = !1);
        }
        #t(h, W) {
          const {
            alt: Z,
            id: s,
            lang: o
          } = h;
          Z !== void 0 && W.setAttribute("aria-label", (0, e.removeNullCharacters)(Z)), s !== void 0 && W.setAttribute("aria-owns", s), o !== void 0 && W.setAttribute("lang", (0, e.removeNullCharacters)(o, !0));
        }
        #n(h) {
          if (!h)
            return null;
          const W = document.createElement("span");
          if ("role" in h) {
            const {
              role: Z
            } = h, s = Z.match(a);
            s ? (W.setAttribute("role", "heading"), W.setAttribute("aria-level", s[1])) : d[Z] && W.setAttribute("role", d[Z]);
          }
          if (this.#t(h, W), h.children)
            if (h.children.length === 1 && "id" in h.children[0])
              this.#t(h.children[0], W);
            else
              for (const Z of h.children)
                W.append(this.#n(Z));
          return W;
        }
      }
    }
  ),
  /***/
  860: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        TextAccessibilityManager: () => (
          /* binding */
          d
        )
        /* harmony export */
      });
      var e = n(256);
      class d {
        #l = !1;
        #t = null;
        #n = /* @__PURE__ */ new Map();
        #d = /* @__PURE__ */ new Map();
        setTextMapping(U) {
          this.#t = U;
        }
        static #a(U, V) {
          const h = U.getBoundingClientRect(), W = V.getBoundingClientRect();
          if (h.width === 0 && h.height === 0)
            return 1;
          if (W.width === 0 && W.height === 0)
            return -1;
          const Z = h.y, s = h.y + h.height, o = h.y + h.height / 2, F = W.y, N = W.y + W.height, Q = W.y + W.height / 2;
          if (o <= F && Q >= s)
            return -1;
          if (Q <= Z && o >= N)
            return 1;
          const u = h.x + h.width / 2, i = W.x + W.width / 2;
          return u - i;
        }
        enable() {
          if (this.#l)
            throw new Error("TextAccessibilityManager is already enabled.");
          if (!this.#t)
            throw new Error("Text divs and strings have not been set.");
          if (this.#l = !0, this.#t = this.#t.slice(), this.#t.sort(d.#a), this.#n.size > 0) {
            const U = this.#t;
            for (const [V, h] of this.#n) {
              if (!document.getElementById(V)) {
                this.#n.delete(V);
                continue;
              }
              this.#e(V, U[h]);
            }
          }
          for (const [U, V] of this.#d)
            this.addPointerInTextLayer(U, V);
          this.#d.clear();
        }
        disable() {
          this.#l && (this.#d.clear(), this.#t = null, this.#l = !1);
        }
        removePointerInTextLayer(U) {
          if (!this.#l) {
            this.#d.delete(U);
            return;
          }
          const V = this.#t;
          if (!V || V.length === 0)
            return;
          const {
            id: h
          } = U, W = this.#n.get(h);
          if (W === void 0)
            return;
          const Z = V[W];
          this.#n.delete(h);
          let s = Z.getAttribute("aria-owns");
          s?.includes(h) && (s = s.split(" ").filter((o) => o !== h).join(" "), s ? Z.setAttribute("aria-owns", s) : (Z.removeAttribute("aria-owns"), Z.setAttribute("role", "presentation")));
        }
        #e(U, V) {
          const h = V.getAttribute("aria-owns");
          h?.includes(U) || V.setAttribute("aria-owns", h ? `${h} ${U}` : U), V.removeAttribute("role");
        }
        addPointerInTextLayer(U, V) {
          const {
            id: h
          } = U;
          if (!h)
            return null;
          if (!this.#l)
            return this.#d.set(U, V), null;
          V && this.removePointerInTextLayer(U);
          const W = this.#t;
          if (!W || W.length === 0)
            return null;
          const Z = (0, e.binarySearchFirstItem)(W, (N) => d.#a(U, N) < 0), s = Math.max(0, Z - 1), o = W[s];
          this.#e(h, o), this.#n.set(h, s);
          const F = o.parentNode;
          return F?.classList.contains("markedContent") ? F.id : null;
        }
        moveElementInDOM(U, V, h, W) {
          const Z = this.addPointerInTextLayer(h, W);
          if (!U.hasChildNodes())
            return U.append(V), Z;
          const s = Array.from(U.childNodes).filter((N) => N !== V);
          if (s.length === 0)
            return Z;
          const o = h || V, F = (0, e.binarySearchFirstItem)(s, (N) => d.#a(o, N) < 0);
          return F === 0 ? s[0].before(V) : s[F - 1].after(V), Z;
        }
      }
    }
  ),
  /***/
  27: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        TextHighlighter: () => (
          /* binding */
          e
        )
        /* harmony export */
      });
      class e {
        #l = null;
        constructor({
          findController: a,
          eventBus: U,
          pageIndex: V
        }) {
          this.findController = a, this.matches = [], this.eventBus = U, this.pageIdx = V, this.textDivs = null, this.textContentItemsStr = null, this.enabled = !1;
        }
        setTextMapping(a, U) {
          this.textDivs = a, this.textContentItemsStr = U;
        }
        enable() {
          if (!this.textDivs || !this.textContentItemsStr)
            throw new Error("Text divs and strings have not been set.");
          if (this.enabled)
            throw new Error("TextHighlighter is already enabled.");
          this.enabled = !0, this.#l || (this.#l = new AbortController(), this.eventBus._on("updatetextlayermatches", (a) => {
            (a.pageIndex === this.pageIdx || a.pageIndex === -1) && this._updateMatches();
          }, {
            signal: this.#l.signal
          })), this._updateMatches();
        }
        disable() {
          this.enabled && (this.enabled = !1, this.#l?.abort(), this.#l = null, this._updateMatches(!0));
        }
        _convertMatches(a, U) {
          if (!a)
            return [];
          const {
            textContentItemsStr: V
          } = this;
          let h = 0, W = 0;
          const Z = V.length - 1, s = [];
          for (let o = 0, F = a.length; o < F; o++) {
            let N = a[o];
            for (; h !== Z && N >= W + V[h].length; )
              W += V[h].length, h++;
            h === V.length && console.error("Could not find a matching mapping");
            const Q = {
              begin: {
                divIdx: h,
                offset: N - W
              }
            };
            for (N += U[o]; h !== Z && N > W + V[h].length; )
              W += V[h].length, h++;
            Q.end = {
              divIdx: h,
              offset: N - W
            }, s.push(Q);
          }
          return s;
        }
        _renderMatches(a) {
          if (a.length === 0)
            return;
          const {
            findController: U,
            pageIdx: V
          } = this, {
            textContentItemsStr: h,
            textDivs: W
          } = this, Z = V === U.selected.pageIdx, s = U.selected.matchIdx, o = U.state.highlightAll;
          let F = null;
          const N = {
            divIdx: -1,
            offset: void 0
          };
          function Q(M, S) {
            const p = M.divIdx;
            return W[p].textContent = "", u(p, 0, M.offset, S);
          }
          function u(M, S, p, Y) {
            let k = W[M];
            if (k.nodeType === Node.TEXT_NODE) {
              const f = document.createElement("span");
              k.before(f), f.append(k), W[M] = f, k = f;
            }
            const L = h[M].substring(S, p), z = document.createTextNode(L);
            if (Y) {
              const f = document.createElement("span");
              return f.className = `${Y} appended`, f.append(z), k.append(f), Y.includes("selected") ? f.offsetLeft : 0;
            }
            return k.append(z), 0;
          }
          let i = s, c = i + 1;
          if (o)
            i = 0, c = a.length;
          else if (!Z)
            return;
          let R = -1, m = -1;
          for (let M = i; M < c; M++) {
            const S = a[M], p = S.begin;
            if (p.divIdx === R && p.offset === m)
              continue;
            R = p.divIdx, m = p.offset;
            const Y = S.end, k = Z && M === s, L = k ? " selected" : "";
            let z = 0;
            if (!F || p.divIdx !== F.divIdx ? (F !== null && u(F.divIdx, F.offset, N.offset), Q(p)) : u(F.divIdx, F.offset, p.offset), p.divIdx === Y.divIdx)
              z = u(p.divIdx, p.offset, Y.offset, "highlight" + L);
            else {
              z = u(p.divIdx, p.offset, N.offset, "highlight begin" + L);
              for (let f = p.divIdx + 1, K = Y.divIdx; f < K; f++)
                W[f].className = "highlight middle" + L;
              Q(Y, "highlight end" + L);
            }
            F = Y, k && U.scrollMatchIntoView({
              element: W[p.divIdx],
              selectedLeft: z,
              pageIndex: V,
              matchIndex: s
            });
          }
          F && u(F.divIdx, F.offset, N.offset);
        }
        _updateMatches(a = !1) {
          if (!this.enabled && !a)
            return;
          const {
            findController: U,
            matches: V,
            pageIdx: h
          } = this, {
            textContentItemsStr: W,
            textDivs: Z
          } = this;
          let s = -1;
          for (const N of V) {
            const Q = Math.max(s, N.begin.divIdx);
            for (let u = Q, i = N.end.divIdx; u <= i; u++) {
              const c = Z[u];
              c.textContent = W[u], c.className = "";
            }
            s = N.end.divIdx + 1;
          }
          if (!U?.highlightMatches || a)
            return;
          const o = U.pageMatches[h] || null, F = U.pageMatchesLength[h] || null;
          this.matches = this._convertMatches(o, F), this._renderMatches(this.matches);
        }
      }
    }
  ),
  /***/
  765: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            TextLayerBuilder: () => (
              /* binding */
              h
            )
            /* harmony export */
          });
          var a = n(603), U = n(256), V = e([a]);
          a = (V.then ? (await V)() : V)[0];
          class h {
            #l = !1;
            #t = null;
            #n = 0;
            #d = 0;
            #a = null;
            constructor({
              highlighter: Z = null,
              accessibilityManager: s = null,
              enablePermissions: o = !1,
              onAppend: F = null
            }) {
              this.textContentItemsStr = [], this.renderingDone = !1, this.textDivs = [], this.textDivProperties = /* @__PURE__ */ new WeakMap(), this.textLayerRenderTask = null, this.highlighter = Z, this.accessibilityManager = s, this.#l = o === !0, this.#t = F, this.div = document.createElement("div"), this.div.tabIndex = 0, this.div.className = "textLayer";
            }
            #e() {
              this.renderingDone = !0;
              const Z = document.createElement("div");
              Z.className = "endOfContent", this.div.append(Z), this.#i();
            }
            get numTextDivs() {
              return this.textDivs.length;
            }
            async render(Z) {
              if (!this.#a)
                throw new Error('No "textContentSource" parameter specified.');
              const s = Z.scale * (globalThis.devicePixelRatio || 1), {
                rotation: o
              } = Z;
              if (this.renderingDone) {
                const F = o !== this.#n, N = s !== this.#d;
                (F || N) && (this.hide(), (0, a.updateTextLayer)({
                  container: this.div,
                  viewport: Z,
                  textDivs: this.textDivs,
                  textDivProperties: this.textDivProperties,
                  mustRescale: N,
                  mustRotate: F
                }), this.#d = s, this.#n = o), this.show();
                return;
              }
              this.cancel(), this.highlighter?.setTextMapping(this.textDivs, this.textContentItemsStr), this.accessibilityManager?.setTextMapping(this.textDivs), this.textLayerRenderTask = (0, a.renderTextLayer)({
                textContentSource: this.#a,
                container: this.div,
                viewport: Z,
                textDivs: this.textDivs,
                textDivProperties: this.textDivProperties,
                textContentItemsStr: this.textContentItemsStr
              }), await this.textLayerRenderTask.promise, this.#e(), this.#d = s, this.#n = o, this.#t?.(this.div), this.highlighter?.enable(), this.accessibilityManager?.enable();
            }
            hide() {
              !this.div.hidden && this.renderingDone && (this.highlighter?.disable(), this.div.hidden = !0);
            }
            show() {
              this.div.hidden && this.renderingDone && (this.div.hidden = !1, this.highlighter?.enable());
            }
            cancel() {
              this.textLayerRenderTask && (this.textLayerRenderTask.cancel(), this.textLayerRenderTask = null), this.highlighter?.disable(), this.accessibilityManager?.disable(), this.textContentItemsStr.length = 0, this.textDivs.length = 0, this.textDivProperties = /* @__PURE__ */ new WeakMap();
            }
            setTextContentSource(Z) {
              this.cancel(), this.#a = Z;
            }
            #i() {
              const {
                div: Z
              } = this;
              Z.addEventListener("mousedown", (s) => {
                const o = Z.querySelector(".endOfContent");
                if (!o)
                  return;
                let F = s.target !== Z;
                if (F &&= getComputedStyle(o).getPropertyValue("-moz-user-select") !== "none", F) {
                  const N = Z.getBoundingClientRect(), Q = Math.max(0, (s.pageY - N.top) / N.height);
                  o.style.top = (Q * 100).toFixed(2) + "%";
                }
                o.classList.add("active");
              }), Z.addEventListener("mouseup", () => {
                const s = Z.querySelector(".endOfContent");
                s && (s.style.top = "", s.classList.remove("active"));
              }), Z.addEventListener("copy", (s) => {
                if (!this.#l) {
                  const o = document.getSelection();
                  s.clipboardData.setData("text/plain", (0, U.removeNullCharacters)((0, a.normalizeUnicode)(o.toString())));
                }
                s.preventDefault(), s.stopPropagation();
              });
            }
          }
          d();
        } catch (h) {
          d(h);
        }
      });
    }
  ),
  /***/
  256: (
    /***/
    (l, t, n) => {
      n.d(t, {
        /* harmony export */
        DEFAULT_SCALE: () => (
          /* binding */
          d
        ),
        /* harmony export */
        DEFAULT_SCALE_DELTA: () => (
          /* binding */
          a
        ),
        /* harmony export */
        DEFAULT_SCALE_VALUE: () => (
          /* binding */
          e
        ),
        /* harmony export */
        MAX_AUTO_SCALE: () => (
          /* binding */
          W
        ),
        /* harmony export */
        MAX_SCALE: () => (
          /* binding */
          V
        ),
        /* harmony export */
        MIN_SCALE: () => (
          /* binding */
          U
        ),
        /* harmony export */
        OutputScale: () => (
          /* binding */
          i
        ),
        /* harmony export */
        PresentationModeState: () => (
          /* binding */
          F
        ),
        /* harmony export */
        ProgressBar: () => (
          /* binding */
          ll
        ),
        /* harmony export */
        RenderingStates: () => (
          /* binding */
          o
        ),
        /* harmony export */
        SCROLLBAR_PADDING: () => (
          /* binding */
          Z
        ),
        /* harmony export */
        ScrollMode: () => (
          /* binding */
          Q
        ),
        /* harmony export */
        SpreadMode: () => (
          /* binding */
          u
        ),
        /* harmony export */
        TextLayerMode: () => (
          /* binding */
          N
        ),
        /* harmony export */
        UNKNOWN_SCALE: () => (
          /* binding */
          h
        ),
        /* harmony export */
        VERTICAL_PADDING: () => (
          /* binding */
          s
        ),
        /* harmony export */
        apiPageLayoutToViewerModes: () => (
          /* binding */
          q
        ),
        /* harmony export */
        approximateFraction: () => (
          /* binding */
          Y
        ),
        /* harmony export */
        binarySearchFirstItem: () => (
          /* binding */
          p
        ),
        /* harmony export */
        docStyle: () => (
          /* binding */
          O
        ),
        /* harmony export */
        getVisibleElements: () => (
          /* binding */
          z
        ),
        /* harmony export */
        isPortraitOrientation: () => (
          /* binding */
          w
        ),
        /* harmony export */
        isValidRotation: () => (
          /* binding */
          f
        ),
        /* harmony export */
        isValidScrollMode: () => (
          /* binding */
          K
        ),
        /* harmony export */
        isValidSpreadMode: () => (
          /* binding */
          P
        ),
        /* harmony export */
        parseQueryString: () => (
          /* binding */
          m
        ),
        /* harmony export */
        removeNullCharacters: () => (
          /* binding */
          S
        ),
        /* harmony export */
        roundToDivide: () => (
          /* binding */
          k
        ),
        /* harmony export */
        scrollIntoView: () => (
          /* binding */
          c
        ),
        /* harmony export */
        watchScroll: () => (
          /* binding */
          R
        )
        /* harmony export */
      });
      const e = "auto", d = 1, a = 1.1, U = 0.1, V = 10, h = 0, W = 1.25, Z = 40, s = 5, o = {
        INITIAL: 0,
        RUNNING: 1,
        PAUSED: 2,
        FINISHED: 3
      }, F = {
        UNKNOWN: 0,
        NORMAL: 1,
        CHANGING: 2,
        FULLSCREEN: 3
      }, N = {
        DISABLE: 0,
        ENABLE: 1,
        ENABLE_PERMISSIONS: 2
      }, Q = {
        UNKNOWN: -1,
        VERTICAL: 0,
        HORIZONTAL: 1,
        WRAPPED: 2,
        PAGE: 3
      }, u = {
        UNKNOWN: -1,
        NONE: 0,
        ODD: 1,
        EVEN: 2
      };
      class i {
        constructor() {
          const il = window.devicePixelRatio || 1;
          this.sx = il, this.sy = il;
        }
        get scaled() {
          return this.sx !== 1 || this.sy !== 1;
        }
      }
      function c(_, il, dl = !1) {
        let tl = _.offsetParent;
        if (!tl) {
          console.error("offsetParent is not set -- cannot scroll");
          return;
        }
        let al = _.offsetTop + _.clientTop, Ul = _.offsetLeft + _.clientLeft;
        for (; tl.clientHeight === tl.scrollHeight && tl.clientWidth === tl.scrollWidth || dl && (tl.classList.contains("markedContent") || getComputedStyle(tl).overflow === "hidden"); )
          if (al += tl.offsetTop, Ul += tl.offsetLeft, tl = tl.offsetParent, !tl)
            return;
        il && (il.top !== void 0 && (al += il.top), il.left !== void 0 && (Ul += il.left, tl.scrollLeft = Ul)), tl.scrollTop = al;
      }
      function R(_, il) {
        const dl = function(Ul) {
          al || (al = window.requestAnimationFrame(function() {
            al = null;
            const B = _.scrollLeft, X = tl.lastX;
            B !== X && (tl.right = B > X), tl.lastX = B;
            const b = _.scrollTop, r = tl.lastY;
            b !== r && (tl.down = b > r), tl.lastY = b, il(tl);
          }));
        }, tl = {
          right: !0,
          down: !0,
          lastX: _.scrollLeft,
          lastY: _.scrollTop,
          _eventHandler: dl
        };
        let al = null;
        return _.addEventListener("scroll", dl, !0), tl;
      }
      function m(_) {
        const il = /* @__PURE__ */ new Map();
        for (const [dl, tl] of new URLSearchParams(_))
          il.set(dl.toLowerCase(), tl);
        return il;
      }
      const M = /[\x00-\x1F]/g;
      function S(_, il = !1) {
        return M.test(_) ? il ? _.replaceAll(M, (dl) => dl === "\0" ? "" : " ") : _.replaceAll("\0", "") : _;
      }
      function p(_, il, dl = 0) {
        let tl = dl, al = _.length - 1;
        if (al < 0 || !il(_[al]))
          return _.length;
        if (il(_[tl]))
          return tl;
        for (; tl < al; ) {
          const Ul = tl + al >> 1, cl = _[Ul];
          il(cl) ? al = Ul : tl = Ul + 1;
        }
        return tl;
      }
      function Y(_) {
        if (Math.floor(_) === _)
          return [_, 1];
        const il = 1 / _, dl = 8;
        if (il > dl)
          return [1, dl];
        if (Math.floor(il) === il)
          return [1, il];
        const tl = _ > 1 ? il : _;
        let al = 0, Ul = 1, cl = 1, B = 1;
        for (; ; ) {
          const b = al + cl, r = Ul + B;
          if (r > dl)
            break;
          tl <= b / r ? (cl = b, B = r) : (al = b, Ul = r);
        }
        let X;
        return tl - al / Ul < cl / B - tl ? X = tl === _ ? [al, Ul] : [Ul, al] : X = tl === _ ? [cl, B] : [B, cl], X;
      }
      function k(_, il) {
        const dl = _ % il;
        return dl === 0 ? _ : Math.round(_ - dl + il);
      }
      function L(_, il, dl) {
        if (_ < 2)
          return _;
        let tl = il[_].div, al = tl.offsetTop + tl.clientTop;
        al >= dl && (tl = il[_ - 1].div, al = tl.offsetTop + tl.clientTop);
        for (let Ul = _ - 2; Ul >= 0 && (tl = il[Ul].div, !(tl.offsetTop + tl.clientTop + tl.clientHeight <= al)); --Ul)
          _ = Ul;
        return _;
      }
      function z({
        scrollEl: _,
        views: il,
        sortByVisibility: dl = !1,
        horizontal: tl = !1,
        rtl: al = !1
      }) {
        const Ul = _.scrollTop, cl = Ul + _.clientHeight, B = _.scrollLeft, X = B + _.clientWidth;
        function b(v) {
          const A = v.div;
          return A.offsetTop + A.clientTop + A.clientHeight > Ul;
        }
        function r(v) {
          const A = v.div, g = A.offsetLeft + A.clientLeft, D = g + A.clientWidth;
          return al ? g < X : D > B;
        }
        const G = [], J = /* @__PURE__ */ new Set(), T = il.length;
        let y = p(il, tl ? r : b);
        y > 0 && y < T && !tl && (y = L(y, il, Ul));
        let I = tl ? X : -1;
        for (let v = y; v < T; v++) {
          const A = il[v], g = A.div, D = g.offsetLeft + g.clientLeft, C = g.offsetTop + g.clientTop, nl = g.clientWidth, Fl = g.clientHeight, sl = D + nl, Vl = C + Fl;
          if (I === -1)
            Vl >= cl && (I = Vl);
          else if ((tl ? D : C) > I)
            break;
          if (Vl <= Ul || C >= cl || sl <= B || D >= X)
            continue;
          const Rl = Math.max(0, Ul - C) + Math.max(0, Vl - cl), Wl = Math.max(0, B - D) + Math.max(0, sl - X), ml = (Fl - Rl) / Fl, rl = (nl - Wl) / nl, Gl = ml * rl * 100 | 0;
          G.push({
            id: A.id,
            x: D,
            y: C,
            view: A,
            percent: Gl,
            widthPercent: rl * 100 | 0
          }), J.add(A.id);
        }
        const E = G[0], x = G.at(-1);
        return dl && G.sort(function(v, A) {
          const g = v.percent - A.percent;
          return Math.abs(g) > 1e-3 ? -g : v.id - A.id;
        }), {
          first: E,
          last: x,
          views: G,
          ids: J
        };
      }
      function f(_) {
        return Number.isInteger(_) && _ % 90 === 0;
      }
      function K(_) {
        return Number.isInteger(_) && Object.values(Q).includes(_) && _ !== Q.UNKNOWN;
      }
      function P(_) {
        return Number.isInteger(_) && Object.values(u).includes(_) && _ !== u.UNKNOWN;
      }
      function w(_) {
        return _.width <= _.height;
      }
      new Promise(function(_) {
        window.requestAnimationFrame(_);
      });
      const O = document.documentElement.style;
      function el(_, il, dl) {
        return Math.min(Math.max(_, il), dl);
      }
      class ll {
        #l = null;
        #t = null;
        #n = 0;
        #d = null;
        #a = !0;
        constructor(il) {
          this.#l = il.classList, this.#d = il.style;
        }
        get percent() {
          return this.#n;
        }
        set percent(il) {
          if (this.#n = el(il, 0, 100), isNaN(il)) {
            this.#l.add("indeterminate");
            return;
          }
          this.#l.remove("indeterminate"), this.#d.setProperty("--progressBar-percent", `${this.#n}%`);
        }
        setWidth(il) {
          if (!il)
            return;
          const tl = il.parentNode.offsetWidth - il.offsetWidth;
          tl > 0 && this.#d.setProperty("--progressBar-end-offset", `${tl}px`);
        }
        setDisableAutoFetch(il = 5e3) {
          isNaN(this.#n) || (this.#t && clearTimeout(this.#t), this.show(), this.#t = setTimeout(() => {
            this.#t = null, this.hide();
          }, il));
        }
        hide() {
          this.#a && (this.#a = !1, this.#l.add("hidden"));
        }
        show() {
          this.#a || (this.#a = !0, this.#l.remove("hidden"));
        }
      }
      function q(_) {
        let il = Q.VERTICAL, dl = u.NONE;
        switch (_) {
          case "SinglePage":
            il = Q.PAGE;
            break;
          case "OneColumn":
            break;
          case "TwoPageLeft":
            il = Q.PAGE;
          case "TwoColumnLeft":
            dl = u.ODD;
            break;
          case "TwoPageRight":
            il = Q.PAGE;
          case "TwoColumnRight":
            dl = u.EVEN;
            break;
        }
        return {
          scrollMode: il,
          spreadMode: dl
        };
      }
    }
  ),
  /***/
  973: (
    /***/
    (l, t, n) => {
      n.a(l, async (e, d) => {
        try {
          n.d(t, {
            /* harmony export */
            XfaLayerBuilder: () => (
              /* binding */
              V
            )
            /* harmony export */
          });
          var a = n(603), U = e([a]);
          a = (U.then ? (await U)() : U)[0];
          class V {
            constructor({
              pdfPage: W,
              annotationStorage: Z = null,
              linkService: s,
              xfaHtml: o = null
            }) {
              this.pdfPage = W, this.annotationStorage = Z, this.linkService = s, this.xfaHtml = o, this.div = null, this._cancelled = !1;
            }
            async render(W, Z = "display") {
              if (Z === "print") {
                const F = {
                  viewport: W.clone({
                    dontFlip: !0
                  }),
                  div: this.div,
                  xfaHtml: this.xfaHtml,
                  annotationStorage: this.annotationStorage,
                  linkService: this.linkService,
                  intent: Z
                };
                return this.div = document.createElement("div"), F.div = this.div, a.XfaLayer.render(F);
              }
              const s = await this.pdfPage.getXfa();
              if (this._cancelled || !s)
                return {
                  textDivs: []
                };
              const o = {
                viewport: W.clone({
                  dontFlip: !0
                }),
                div: this.div,
                xfaHtml: s,
                annotationStorage: this.annotationStorage,
                linkService: this.linkService,
                intent: Z
              };
              return this.div ? a.XfaLayer.update(o) : (this.div = document.createElement("div"), o.div = this.div, a.XfaLayer.render(o));
            }
            cancel() {
              this._cancelled = !0;
            }
            hide() {
              this.div && (this.div.hidden = !0);
            }
          }
          d();
        } catch (V) {
          d(V);
        }
      });
    }
  )
  /******/
}, TU = {};
function rn(l) {
  var t = TU[l];
  if (t !== void 0)
    return t.exports;
  var n = TU[l] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  return yM[l](n, n.exports, rn), n.exports;
}
(() => {
  var l = typeof Symbol == "function" ? Symbol("webpack queues") : "__webpack_queues__", t = typeof Symbol == "function" ? Symbol("webpack exports") : "__webpack_exports__", n = typeof Symbol == "function" ? Symbol("webpack error") : "__webpack_error__", e = (a) => {
    a && a.d < 1 && (a.d = 1, a.forEach((U) => U.r--), a.forEach((U) => U.r-- ? U.r++ : U()));
  }, d = (a) => a.map((U) => {
    if (U !== null && typeof U == "object") {
      if (U[l])
        return U;
      if (U.then) {
        var V = [];
        V.d = 0, U.then((Z) => {
          h[t] = Z, e(V);
        }, (Z) => {
          h[n] = Z, e(V);
        });
        var h = {};
        return h[l] = (Z) => Z(V), h;
      }
    }
    var W = {};
    return W[l] = (Z) => {
    }, W[t] = U, W;
  });
  rn.a = (a, U, V) => {
    var h;
    V && ((h = []).d = -1);
    var W = /* @__PURE__ */ new Set(), Z = a.exports, s, o, F, N = new Promise((Q, u) => {
      F = u, o = Q;
    });
    N[t] = Z, N[l] = (Q) => (h && Q(h), W.forEach(Q), N.catch((u) => {
    })), a.exports = N, U((Q) => {
      s = d(Q);
      var u, i = () => s.map((R) => {
        if (R[n])
          throw R[n];
        return R[t];
      }), c = new Promise((R) => {
        u = () => R(i), u.r = 0;
        var m = (M) => M !== h && !W.has(M) && (W.add(M), M && !M.d && (u.r++, M.push(u)));
        s.map((M) => M[l](m));
      });
      return u.r ? c : i();
    }, (Q) => (Q ? F(N[n] = Q) : o(Z), e(h))), h && h.d < 0 && (h.d = 0);
  };
})();
rn.d = (l, t) => {
  for (var n in t)
    rn.o(t, n) && !rn.o(l, n) && Object.defineProperty(l, n, { enumerable: !0, get: t[n] });
};
rn.o = (l, t) => Object.prototype.hasOwnProperty.call(l, t);
var Al = rn(624);
Al = globalThis.pdfjsViewer = await (globalThis.pdfjsViewerPromise = Al);
var BM = Al.AnnotationLayerBuilder, zM = Al.DownloadManager, LM = Al.EventBus, kM = Al.FindState, IM = Al.GenericL10n, DM = Al.LinkTarget, CM = Al.PDFFindController, wM = Al.PDFHistory, EM = Al.PDFLinkService, xM = Al.PDFPageView, gM = Al.PDFScriptingManager, jM = Al.PDFSinglePageViewer, OM = Al.PDFViewer, vM = Al.ProgressBar, fM = Al.RenderingStates, KM = Al.ScrollMode, HM = Al.SimpleLinkService, PM = Al.SpreadMode, AM = Al.StructTreeLayerBuilder, $M = Al.TextLayerBuilder, qM = Al.XfaLayerBuilder, _M = Al.parseQueryString;
const GU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AnnotationLayerBuilder: BM,
  DownloadManager: zM,
  EventBus: LM,
  FindState: kM,
  GenericL10n: IM,
  LinkTarget: DM,
  PDFFindController: CM,
  PDFHistory: wM,
  PDFLinkService: EM,
  PDFPageView: xM,
  PDFScriptingManager: gM,
  PDFSinglePageViewer: jM,
  PDFViewer: OM,
  ProgressBar: vM,
  RenderingStates: fM,
  ScrollMode: KM,
  SimpleLinkService: HM,
  SpreadMode: PM,
  StructTreeLayerBuilder: AM,
  TextLayerBuilder: $M,
  XfaLayerBuilder: qM,
  parseQueryString: _M
}, Symbol.toStringTag, { value: "Module" })), lp = { class: "pdf-view-container" }, tp = { style: { display: "flex" } }, np = {
  key: 1,
  class: "pdf-list-container"
}, ep = {
  name: "pdfViewContainer"
}, dp = /* @__PURE__ */ pl({
  ...ep,
  setup(l) {
    const t = new URL("data:text/javascript;base64,LyoqCiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZQogKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlCiAqCiAqIENvcHlyaWdodCAyMDIzIE1vemlsbGEgRm91bmRhdGlvbgogKgogKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsKICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKICoKICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAogKgogKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlCiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuICJBUyBJUyIgQkFTSVMsCiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLgogKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kCiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLgogKgogKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGUKICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZQogKi92YXIgZT17ZDoodCxpKT0+e2Zvcih2YXIgYSBpbiBpKWUubyhpLGEpJiYhZS5vKHQsYSkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGEse2VudW1lcmFibGU6ITAsZ2V0OmlbYV19KX0sbzooZSx0KT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LF9fd2VicGFja19leHBvcnRzX189Z2xvYmFsVGhpcy5wZGZqc1dvcmtlcj17fTtlLmQoX193ZWJwYWNrX2V4cG9ydHNfXyx7V29ya2VyTWVzc2FnZUhhbmRsZXI6KCk9Pldvcmtlck1lc3NhZ2VIYW5kbGVyfSk7Y29uc3QgdD0hKCJvYmplY3QiIT10eXBlb2YgcHJvY2Vzc3x8cHJvY2VzcysiIiE9IltvYmplY3QgcHJvY2Vzc10ifHxwcm9jZXNzLnZlcnNpb25zLm53fHxwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uJiZwcm9jZXNzLnR5cGUmJiJicm93c2VyIiE9PXByb2Nlc3MudHlwZSksaT1bMSwwLDAsMSwwLDBdLGE9Wy4wMDEsMCwwLC4wMDEsMCwwXSxzPTEuMzUscj0uMzUsbj0uMjU5MjU5MjU5MjU5MjU5MjQsbz0xLGc9MixjPTQsQz04LGg9MTYsbD02NCxRPTI1NixFPSJwZGZqc19pbnRlcm5hbF9lZGl0b3JfIix1PTMsZD05LGY9MTMscD0xNSxtPXtQUklOVDo0LE1PRElGWV9DT05URU5UUzo4LENPUFk6MTYsTU9ESUZZX0FOTk9UQVRJT05TOjMyLEZJTExfSU5URVJBQ1RJVkVfRk9STVM6MjU2LENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6NTEyLEFTU0VNQkxFOjEwMjQsUFJJTlRfSElHSF9RVUFMSVRZOjIwNDh9LHk9MCx3PTQsYj0xLEQ9MixGPTMsUz0xLGs9MixOPTMsUj00LEc9NSx4PTYsVT03LE09OCxMPTksSD0xMCxKPTExLFk9MTIsdj0xMyxLPTE0LFQ9MTUscT0xNixPPTE3LFc9MjAsaj0iR3JvdXAiLFg9IlIiLFo9MSxWPTIsej00LF89MTYsJD0zMixBQT0xMjgsZUE9NTEyLHRBPTEsaUE9MixhQT00MDk2LHNBPTgxOTIsckE9MzI3NjgsbkE9NjU1MzYsb0E9MTMxMDcyLGdBPTEwNDg1NzYsSUE9MjA5NzE1MixjQT04Mzg4NjA4LENBPTE2Nzc3MjE2LGhBPTEsbEE9MixCQT0zLFFBPTQsRUE9NSx1QT17RToiTW91c2UgRW50ZXIiLFg6Ik1vdXNlIEV4aXQiLEQ6Ik1vdXNlIERvd24iLFU6Ik1vdXNlIFVwIixGbzoiRm9jdXMiLEJsOiJCbHVyIixQTzoiUGFnZU9wZW4iLFBDOiJQYWdlQ2xvc2UiLFBWOiJQYWdlVmlzaWJsZSIsUEk6IlBhZ2VJbnZpc2libGUiLEs6IktleXN0cm9rZSIsRjoiRm9ybWF0IixWOiJWYWxpZGF0ZSIsQzoiQ2FsY3VsYXRlIn0sZEE9e1dDOiJXaWxsQ2xvc2UiLFdTOiJXaWxsU2F2ZSIsRFM6IkRpZFNhdmUiLFdQOiJXaWxsUHJpbnQiLERQOiJEaWRQcmludCJ9LGZBPXtPOiJQYWdlT3BlbiIsQzoiUGFnZUNsb3NlIn0scEE9e0VSUk9SUzowLFdBUk5JTkdTOjEsSU5GT1M6NX0sbUE9e05PTkU6MCxCSU5BUlk6MX0seUE9MSx3QT0yLGJBPTMsREE9NCxGQT01LFNBPTYsa0E9NyxOQT04LFJBPTksR0E9MTAseEE9MTEsVUE9MTIsTUE9MTMsTEE9MTQsSEE9MTUsSkE9MTYsWUE9MTcsdkE9MTgsS0E9MTksVEE9MjAscUE9MjEsT0E9MjIsUEE9MjMsV0E9MjQsakE9MjUsWEE9MjYsWkE9MjcsVkE9MjgsekE9MjksX0E9MzAsJEE9MzEsQWU9MzIsZWU9MzMsdGU9MzQsaWU9MzUsYWU9MzYsc2U9MzcscmU9MzgsbmU9Mzksb2U9NDAsZ2U9NDEsSWU9NDIsY2U9NDMsQ2U9NDQsaGU9NDUsbGU9NDYsQmU9NDcsUWU9NDgsRWU9NDksdWU9NTAsZGU9NTEsZmU9NTIscGU9NTMsbWU9NTQseWU9NTUsd2U9NTYsYmU9NTcsRGU9NTgsRmU9NTksU2U9NjAsa2U9NjEsTmU9NjIsUmU9NjMsR2U9NjQseGU9NjUsVWU9NjYsTWU9NjcsTGU9NjgsSGU9NjksSmU9NzAsWWU9NzEsdmU9NzIsS2U9NzMsVGU9NzQscWU9NzUsT2U9NzYsUGU9NzcsV2U9ODAsamU9ODEsWGU9ODMsWmU9ODQsVmU9ODUsemU9ODYsX2U9ODcsJGU9ODgsQXQ9ODksZXQ9OTAsdHQ9OTEsaXQ9MSxhdD0yO2xldCBzdD1wQS5XQVJOSU5HUztmdW5jdGlvbiBnZXRWZXJib3NpdHlMZXZlbCgpe3JldHVybiBzdH1mdW5jdGlvbiBpbmZvKGUpe3N0Pj1wQS5JTkZPUyYmY29uc29sZS5sb2coYEluZm86ICR7ZX1gKX1mdW5jdGlvbiB3YXJuKGUpe3N0Pj1wQS5XQVJOSU5HUyYmY29uc29sZS5sb2coYFdhcm5pbmc6ICR7ZX1gKX1mdW5jdGlvbiB1bnJlYWNoYWJsZShlKXt0aHJvdyBuZXcgRXJyb3IoZSl9ZnVuY3Rpb24gYXNzZXJ0KGUsdCl7ZXx8dW5yZWFjaGFibGUodCl9ZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybChlLHQ9bnVsbCxpPW51bGwpe2lmKCFlKXJldHVybiBudWxsO3RyeXtpZihpJiYic3RyaW5nIj09dHlwZW9mIGUpe2lmKGkuYWRkRGVmYXVsdFByb3RvY29sJiZlLnN0YXJ0c1dpdGgoInd3dy4iKSl7Y29uc3QgdD1lLm1hdGNoKC9cLi9nKTt0Py5sZW5ndGg+PTImJihlPWBodHRwOi8vJHtlfWApfWlmKGkudHJ5Q29udmVydEVuY29kaW5nKXRyeXtlPXN0cmluZ1RvVVRGOFN0cmluZyhlKX1jYXRjaHt9fWNvbnN0IGE9dD9uZXcgVVJMKGUsdCk6bmV3IFVSTChlKTtpZihmdW5jdGlvbiBfaXNWYWxpZFByb3RvY29sKGUpe3N3aXRjaChlPy5wcm90b2NvbCl7Y2FzZSJodHRwOiI6Y2FzZSJodHRwczoiOmNhc2UiZnRwOiI6Y2FzZSJtYWlsdG86IjpjYXNlInRlbDoiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fShhKSlyZXR1cm4gYX1jYXRjaHt9cmV0dXJuIG51bGx9ZnVuY3Rpb24gc2hhZG93KGUsdCxpLGE9ITEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOmksZW51bWVyYWJsZTohYSxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITF9KTtyZXR1cm4gaX1jb25zdCBydD1mdW5jdGlvbiBCYXNlRXhjZXB0aW9uQ2xvc3VyZSgpe2Z1bmN0aW9uIEJhc2VFeGNlcHRpb24oZSx0KXt0aGlzLmNvbnN0cnVjdG9yPT09QmFzZUV4Y2VwdGlvbiYmdW5yZWFjaGFibGUoIkNhbm5vdCBpbml0aWFsaXplIEJhc2VFeGNlcHRpb24uIik7dGhpcy5tZXNzYWdlPWU7dGhpcy5uYW1lPXR9QmFzZUV4Y2VwdGlvbi5wcm90b3R5cGU9bmV3IEVycm9yO0Jhc2VFeGNlcHRpb24uY29uc3RydWN0b3I9QmFzZUV4Y2VwdGlvbjtyZXR1cm4gQmFzZUV4Y2VwdGlvbn0oKTtjbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIHJ0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSwiUGFzc3dvcmRFeGNlcHRpb24iKTt0aGlzLmNvZGU9dH19Y2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgcnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLCJVbmtub3duRXJyb3JFeGNlcHRpb24iKTt0aGlzLmRldGFpbHM9dH19Y2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIHJ0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIkludmFsaWRQREZFeGNlcHRpb24iKX19Y2xhc3MgTWlzc2luZ1BERkV4Y2VwdGlvbiBleHRlbmRzIHJ0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIk1pc3NpbmdQREZFeGNlcHRpb24iKX19Y2xhc3MgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIGV4dGVuZHMgcnR7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24iKTt0aGlzLnN0YXR1cz10fX1jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIHJ0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIkZvcm1hdEVycm9yIil9fWNsYXNzIEFib3J0RXhjZXB0aW9uIGV4dGVuZHMgcnR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiQWJvcnRFeGNlcHRpb24iKX19ZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhlKXsib2JqZWN0Ij09dHlwZW9mIGUmJnZvaWQgMCE9PWU/Lmxlbmd0aHx8dW5yZWFjaGFibGUoIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmciKTtjb25zdCB0PWUubGVuZ3RoLGk9ODE5MjtpZih0PGkpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlKTtjb25zdCBhPVtdO2ZvcihsZXQgcz0wO3M8dDtzKz1pKXtjb25zdCByPU1hdGgubWluKHMraSx0KSxuPWUuc3ViYXJyYXkocyxyKTthLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG4pKX1yZXR1cm4gYS5qb2luKCIiKX1mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKGUpeyJzdHJpbmciIT10eXBlb2YgZSYmdW5yZWFjaGFibGUoIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXMiKTtjb25zdCB0PWUubGVuZ3RoLGk9bmV3IFVpbnQ4QXJyYXkodCk7Zm9yKGxldCBhPTA7YTx0OysrYSlpW2FdPTI1NSZlLmNoYXJDb2RlQXQoYSk7cmV0dXJuIGl9ZnVuY3Rpb24gc3RyaW5nMzIoZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZT4+MjQmMjU1LGU+PjE2JjI1NSxlPj44JjI1NSwyNTUmZSl9ZnVuY3Rpb24gb2JqZWN0U2l6ZShlKXtyZXR1cm4gT2JqZWN0LmtleXMoZSkubGVuZ3RofWNsYXNzIEZlYXR1cmVUZXN0e3N0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKXtyZXR1cm4gc2hhZG93KHRoaXMsImlzTGl0dGxlRW5kaWFuIixmdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpe2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkoNCk7ZVswXT0xO3JldHVybiAxPT09bmV3IFVpbnQzMkFycmF5KGUuYnVmZmVyLDAsMSlbMF19KCkpfXN0YXRpYyBnZXQgaXNFdmFsU3VwcG9ydGVkKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJpc0V2YWxTdXBwb3J0ZWQiLGZ1bmN0aW9uIGlzRXZhbFN1cHBvcnRlZCgpe3RyeXtuZXcgRnVuY3Rpb24oIiIpO3JldHVybiEwfWNhdGNoe3JldHVybiExfX0oKSl9c3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpe3JldHVybiBzaGFkb3codGhpcywiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQiLCJ1bmRlZmluZWQiIT10eXBlb2YgT2Zmc2NyZWVuQ2FudmFzKX1zdGF0aWMgZ2V0IHBsYXRmb3JtKCl7cmV0dXJuInVuZGVmaW5lZCIhPXR5cGVvZiBuYXZpZ2F0b3ImJiJzdHJpbmciPT10eXBlb2YgbmF2aWdhdG9yPy5wbGF0Zm9ybT9zaGFkb3codGhpcywicGxhdGZvcm0iLHtpc01hYzpuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoIk1hYyIpfSk6c2hhZG93KHRoaXMsInBsYXRmb3JtIix7aXNNYWM6ITF9KX1zdGF0aWMgZ2V0IGlzQ1NTUm91bmRTdXBwb3J0ZWQoKXtyZXR1cm4gc2hhZG93KHRoaXMsImlzQ1NTUm91bmRTdXBwb3J0ZWQiLGdsb2JhbFRoaXMuQ1NTPy5zdXBwb3J0cz8uKCJ3aWR0aDogcm91bmQoMS41cHgsIDFweCkiKSl9fWNvbnN0IG50PUFycmF5LmZyb20oQXJyYXkoMjU2KS5rZXlzKCksKGU9PmUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIjAiKSkpO2NsYXNzIFV0aWx7c3RhdGljIG1ha2VIZXhDb2xvcihlLHQsaSl7cmV0dXJuYCMke250W2VdfSR7bnRbdF19JHtudFtpXX1gfXN0YXRpYyBzY2FsZU1pbk1heChlLHQpe2xldCBpO2lmKGVbMF0pe2lmKGVbMF08MCl7aT10WzBdO3RbMF09dFsyXTt0WzJdPWl9dFswXSo9ZVswXTt0WzJdKj1lWzBdO2lmKGVbM108MCl7aT10WzFdO3RbMV09dFszXTt0WzNdPWl9dFsxXSo9ZVszXTt0WzNdKj1lWzNdfWVsc2V7aT10WzBdO3RbMF09dFsxXTt0WzFdPWk7aT10WzJdO3RbMl09dFszXTt0WzNdPWk7aWYoZVsxXTwwKXtpPXRbMV07dFsxXT10WzNdO3RbM109aX10WzFdKj1lWzFdO3RbM10qPWVbMV07aWYoZVsyXTwwKXtpPXRbMF07dFswXT10WzJdO3RbMl09aX10WzBdKj1lWzJdO3RbMl0qPWVbMl19dFswXSs9ZVs0XTt0WzFdKz1lWzVdO3RbMl0rPWVbNF07dFszXSs9ZVs1XX1zdGF0aWMgdHJhbnNmb3JtKGUsdCl7cmV0dXJuW2VbMF0qdFswXStlWzJdKnRbMV0sZVsxXSp0WzBdK2VbM10qdFsxXSxlWzBdKnRbMl0rZVsyXSp0WzNdLGVbMV0qdFsyXStlWzNdKnRbM10sZVswXSp0WzRdK2VbMl0qdFs1XStlWzRdLGVbMV0qdFs0XStlWzNdKnRbNV0rZVs1XV19c3RhdGljIGFwcGx5VHJhbnNmb3JtKGUsdCl7cmV0dXJuW2VbMF0qdFswXStlWzFdKnRbMl0rdFs0XSxlWzBdKnRbMV0rZVsxXSp0WzNdK3RbNV1dfXN0YXRpYyBhcHBseUludmVyc2VUcmFuc2Zvcm0oZSx0KXtjb25zdCBpPXRbMF0qdFszXS10WzFdKnRbMl07cmV0dXJuWyhlWzBdKnRbM10tZVsxXSp0WzJdK3RbMl0qdFs1XS10WzRdKnRbM10pL2ksKC1lWzBdKnRbMV0rZVsxXSp0WzBdK3RbNF0qdFsxXS10WzVdKnRbMF0pL2ldfXN0YXRpYyBnZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChlLHQpe2NvbnN0IGk9dGhpcy5hcHBseVRyYW5zZm9ybShlLHQpLGE9dGhpcy5hcHBseVRyYW5zZm9ybShlLnNsaWNlKDIsNCksdCkscz10aGlzLmFwcGx5VHJhbnNmb3JtKFtlWzBdLGVbM11dLHQpLHI9dGhpcy5hcHBseVRyYW5zZm9ybShbZVsyXSxlWzFdXSx0KTtyZXR1cm5bTWF0aC5taW4oaVswXSxhWzBdLHNbMF0sclswXSksTWF0aC5taW4oaVsxXSxhWzFdLHNbMV0sclsxXSksTWF0aC5tYXgoaVswXSxhWzBdLHNbMF0sclswXSksTWF0aC5tYXgoaVsxXSxhWzFdLHNbMV0sclsxXSldfXN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKGUpe2NvbnN0IHQ9ZVswXSplWzNdLWVbMV0qZVsyXTtyZXR1cm5bZVszXS90LC1lWzFdL3QsLWVbMl0vdCxlWzBdL3QsKGVbMl0qZVs1XS1lWzRdKmVbM10pL3QsKGVbNF0qZVsxXS1lWzVdKmVbMF0pL3RdfXN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShlKXtjb25zdCB0PVtlWzBdLGVbMl0sZVsxXSxlWzNdXSxpPWVbMF0qdFswXStlWzFdKnRbMl0sYT1lWzBdKnRbMV0rZVsxXSp0WzNdLHM9ZVsyXSp0WzBdK2VbM10qdFsyXSxyPWVbMl0qdFsxXStlWzNdKnRbM10sbj0oaStyKS8yLG89TWF0aC5zcXJ0KChpK3IpKioyLTQqKGkqci1zKmEpKS8yLGc9bitvfHwxLGM9bi1vfHwxO3JldHVybltNYXRoLnNxcnQoZyksTWF0aC5zcXJ0KGMpXX1zdGF0aWMgbm9ybWFsaXplUmVjdChlKXtjb25zdCB0PWUuc2xpY2UoMCk7aWYoZVswXT5lWzJdKXt0WzBdPWVbMl07dFsyXT1lWzBdfWlmKGVbMV0+ZVszXSl7dFsxXT1lWzNdO3RbM109ZVsxXX1yZXR1cm4gdH1zdGF0aWMgaW50ZXJzZWN0KGUsdCl7Y29uc3QgaT1NYXRoLm1heChNYXRoLm1pbihlWzBdLGVbMl0pLE1hdGgubWluKHRbMF0sdFsyXSkpLGE9TWF0aC5taW4oTWF0aC5tYXgoZVswXSxlWzJdKSxNYXRoLm1heCh0WzBdLHRbMl0pKTtpZihpPmEpcmV0dXJuIG51bGw7Y29uc3Qgcz1NYXRoLm1heChNYXRoLm1pbihlWzFdLGVbM10pLE1hdGgubWluKHRbMV0sdFszXSkpLHI9TWF0aC5taW4oTWF0aC5tYXgoZVsxXSxlWzNdKSxNYXRoLm1heCh0WzFdLHRbM10pKTtyZXR1cm4gcz5yP251bGw6W2kscyxhLHJdfXN0YXRpYyNBKGUsdCxpLGEscyxyLG4sbyxnLGMpe2lmKGc8PTB8fGc+PTEpcmV0dXJuO2NvbnN0IEM9MS1nLGg9ZypnLGw9aCpnLFE9QyooQyooQyplKzMqZyp0KSszKmgqaSkrbCphLEU9QyooQyooQypzKzMqZypyKSszKmgqbikrbCpvO2NbMF09TWF0aC5taW4oY1swXSxRKTtjWzFdPU1hdGgubWluKGNbMV0sRSk7Y1syXT1NYXRoLm1heChjWzJdLFEpO2NbM109TWF0aC5tYXgoY1szXSxFKX1zdGF0aWMjZShlLHQsaSxhLHMscixuLG8sZyxjLEMsaCl7aWYoTWF0aC5hYnMoZyk8MWUtMTIpe01hdGguYWJzKGMpPj0xZS0xMiYmdGhpcy4jQShlLHQsaSxhLHMscixuLG8sLUMvYyxoKTtyZXR1cm59Y29uc3QgbD1jKioyLTQqQypnO2lmKGw8MClyZXR1cm47Y29uc3QgUT1NYXRoLnNxcnQobCksRT0yKmc7dGhpcy4jQShlLHQsaSxhLHMscixuLG8sKC1jK1EpL0UsaCk7dGhpcy4jQShlLHQsaSxhLHMscixuLG8sKC1jLVEpL0UsaCl9c3RhdGljIGJlemllckJvdW5kaW5nQm94KGUsdCxpLGEscyxyLG4sbyxnKXtpZihnKXtnWzBdPU1hdGgubWluKGdbMF0sZSxuKTtnWzFdPU1hdGgubWluKGdbMV0sdCxvKTtnWzJdPU1hdGgubWF4KGdbMl0sZSxuKTtnWzNdPU1hdGgubWF4KGdbM10sdCxvKX1lbHNlIGc9W01hdGgubWluKGUsbiksTWF0aC5taW4odCxvKSxNYXRoLm1heChlLG4pLE1hdGgubWF4KHQsbyldO3RoaXMuI2UoZSxpLHMsbix0LGEscixvLDMqKDMqKGktcyktZStuKSw2KihlLTIqaStzKSwzKihpLWUpLGcpO3RoaXMuI2UoZSxpLHMsbix0LGEscixvLDMqKDMqKGEtciktdCtvKSw2Kih0LTIqYStyKSwzKihhLXQpLGcpO3JldHVybiBnfX1jb25zdCBvdD1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsNzI4LDcxMSw3MTAsNzI5LDczMyw3MzEsNzMwLDczMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw4MjI2LDgyMjQsODIyNSw4MjMwLDgyMTIsODIxMSw0MDIsODI2MCw4MjQ5LDgyNTAsODcyMiw4MjQwLDgyMjIsODIyMCw4MjIxLDgyMTYsODIxNyw4MjE4LDg0ODIsNjQyNTcsNjQyNTgsMzIxLDMzOCwzNTIsMzc2LDM4MSwzMDUsMzIyLDMzOSwzNTMsMzgyLDAsODM2NF07ZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoZSl7aWYoZVswXT49IsOvIil7bGV0IHQ7aWYoIsO+Ij09PWVbMF0mJiLDvyI9PT1lWzFdKXt0PSJ1dGYtMTZiZSI7ZS5sZW5ndGglMj09MSYmKGU9ZS5zbGljZSgwLC0xKSl9ZWxzZSBpZigiw78iPT09ZVswXSYmIsO+Ij09PWVbMV0pe3Q9InV0Zi0xNmxlIjtlLmxlbmd0aCUyPT0xJiYoZT1lLnNsaWNlKDAsLTEpKX1lbHNlIsOvIj09PWVbMF0mJiLCuyI9PT1lWzFdJiYiwr8iPT09ZVsyXSYmKHQ9InV0Zi04Iik7aWYodCl0cnl7Y29uc3QgaT1uZXcgVGV4dERlY29kZXIodCx7ZmF0YWw6ITB9KSxhPXN0cmluZ1RvQnl0ZXMoZSkscz1pLmRlY29kZShhKTtyZXR1cm4gcy5pbmNsdWRlcygiGyIpP3MucmVwbGFjZUFsbCgvXHgxYlteXHgxYl0qKD86XHgxYnwkKS9nLCIiKTpzfWNhdGNoKGUpe3dhcm4oYHN0cmluZ1RvUERGU3RyaW5nOiAiJHtlfSIuYCl9fWNvbnN0IHQ9W107Zm9yKGxldCBpPTAsYT1lLmxlbmd0aDtpPGE7aSsrKXtjb25zdCBzPWUuY2hhckNvZGVBdChpKTtpZigyNz09PXMpe2Zvcig7KytpPGEmJjI3IT09ZS5jaGFyQ29kZUF0KGkpOyk7Y29udGludWV9Y29uc3Qgcj1vdFtzXTt0LnB1c2gocj9TdHJpbmcuZnJvbUNoYXJDb2RlKHIpOmUuY2hhckF0KGkpKX1yZXR1cm4gdC5qb2luKCIiKX1mdW5jdGlvbiBzdHJpbmdUb1VURjhTdHJpbmcoZSl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZSkpfWZ1bmN0aW9uIHV0ZjhTdHJpbmdUb1N0cmluZyhlKXtyZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGUpKX1mdW5jdGlvbiBpc0FycmF5RXF1YWwoZSx0KXtpZihlLmxlbmd0aCE9PXQubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgaT0wLGE9ZS5sZW5ndGg7aTxhO2krKylpZihlW2ldIT09dFtpXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBnZXRNb2RpZmljYXRpb25EYXRlKGU9bmV3IERhdGUpe3JldHVybltlLmdldFVUQ0Z1bGxZZWFyKCkudG9TdHJpbmcoKSwoZS5nZXRVVENNb250aCgpKzEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwiMCIpLGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwiMCIpLGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIjAiKSxlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIjAiKSxlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIjAiKV0uam9pbigiIil9bGV0IGd0PW51bGwsSXQ9bnVsbDtjb25zdCBjdD0wLEN0PTEsaHQ9MixsdD0zLEJ0PTQsUXQ9NSxFdD02LHV0PTcsZHQ9OCxmdD1TeW1ib2woIkNJUkNVTEFSX1JFRiIpLHB0PVN5bWJvbCgiRU9GIik7bGV0IG10PU9iamVjdC5jcmVhdGUobnVsbCkseXQ9T2JqZWN0LmNyZWF0ZShudWxsKSx3dD1PYmplY3QuY3JlYXRlKG51bGwpO2NsYXNzIE5hbWV7Y29uc3RydWN0b3IoZSl7dGhpcy5uYW1lPWV9c3RhdGljIGdldChlKXtyZXR1cm4geXRbZV18fD1uZXcgTmFtZShlKX19Y2xhc3MgQ21ke2NvbnN0cnVjdG9yKGUpe3RoaXMuY21kPWV9c3RhdGljIGdldChlKXtyZXR1cm4gbXRbZV18fD1uZXcgQ21kKGUpfX1jb25zdCBidD1mdW5jdGlvbiBub25TZXJpYWxpemFibGVDbG9zdXJlKCl7cmV0dXJuIGJ0fTtjbGFzcyBEaWN0e2NvbnN0cnVjdG9yKGU9bnVsbCl7dGhpcy5fbWFwPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy54cmVmPWU7dGhpcy5vYmpJZD1udWxsO3RoaXMuc3VwcHJlc3NFbmNyeXB0aW9uPSExO3RoaXMuX19ub25TZXJpYWxpemFibGVfXz1idH1hc3NpZ25YcmVmKGUpe3RoaXMueHJlZj1lfWdldCBzaXplKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX21hcCkubGVuZ3RofWdldChlLHQsaSl7bGV0IGE9dGhpcy5fbWFwW2VdO2lmKHZvaWQgMD09PWEmJnZvaWQgMCE9PXQpe2E9dGhpcy5fbWFwW3RdO3ZvaWQgMD09PWEmJnZvaWQgMCE9PWkmJihhPXRoaXMuX21hcFtpXSl9cmV0dXJuIGEgaW5zdGFuY2VvZiBSZWYmJnRoaXMueHJlZj90aGlzLnhyZWYuZmV0Y2goYSx0aGlzLnN1cHByZXNzRW5jcnlwdGlvbik6YX1hc3luYyBnZXRBc3luYyhlLHQsaSl7bGV0IGE9dGhpcy5fbWFwW2VdO2lmKHZvaWQgMD09PWEmJnZvaWQgMCE9PXQpe2E9dGhpcy5fbWFwW3RdO3ZvaWQgMD09PWEmJnZvaWQgMCE9PWkmJihhPXRoaXMuX21hcFtpXSl9cmV0dXJuIGEgaW5zdGFuY2VvZiBSZWYmJnRoaXMueHJlZj90aGlzLnhyZWYuZmV0Y2hBc3luYyhhLHRoaXMuc3VwcHJlc3NFbmNyeXB0aW9uKTphfWdldEFycmF5KGUsdCxpKXtsZXQgYT10aGlzLl9tYXBbZV07aWYodm9pZCAwPT09YSYmdm9pZCAwIT09dCl7YT10aGlzLl9tYXBbdF07dm9pZCAwPT09YSYmdm9pZCAwIT09aSYmKGE9dGhpcy5fbWFwW2ldKX1hIGluc3RhbmNlb2YgUmVmJiZ0aGlzLnhyZWYmJihhPXRoaXMueHJlZi5mZXRjaChhLHRoaXMuc3VwcHJlc3NFbmNyeXB0aW9uKSk7aWYoQXJyYXkuaXNBcnJheShhKSl7YT1hLnNsaWNlKCk7Zm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7ZSsrKWFbZV1pbnN0YW5jZW9mIFJlZiYmdGhpcy54cmVmJiYoYVtlXT10aGlzLnhyZWYuZmV0Y2goYVtlXSx0aGlzLnN1cHByZXNzRW5jcnlwdGlvbikpfXJldHVybiBhfWdldFJhdyhlKXtyZXR1cm4gdGhpcy5fbWFwW2VdfWdldEtleXMoKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5fbWFwKX1nZXRSYXdWYWx1ZXMoKXtyZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9tYXApfXNldChlLHQpe3RoaXMuX21hcFtlXT10fWhhcyhlKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fbWFwW2VdfWZvckVhY2goZSl7Zm9yKGNvbnN0IHQgaW4gdGhpcy5fbWFwKWUodCx0aGlzLmdldCh0KSl9c3RhdGljIGdldCBlbXB0eSgpe2NvbnN0IGU9bmV3IERpY3QobnVsbCk7ZS5zZXQ9KGUsdCk9Pnt1bnJlYWNoYWJsZSgiU2hvdWxkIG5vdCBjYWxsIGBzZXRgIG9uIHRoZSBlbXB0eSBkaWN0aW9uYXJ5LiIpfTtyZXR1cm4gc2hhZG93KHRoaXMsImVtcHR5IixlKX1zdGF0aWMgbWVyZ2Uoe3hyZWY6ZSxkaWN0QXJyYXk6dCxtZXJnZVN1YkRpY3RzOmk9ITF9KXtjb25zdCBhPW5ldyBEaWN0KGUpLHM9bmV3IE1hcDtmb3IoY29uc3QgZSBvZiB0KWlmKGUgaW5zdGFuY2VvZiBEaWN0KWZvcihjb25zdFt0LGFdb2YgT2JqZWN0LmVudHJpZXMoZS5fbWFwKSl7bGV0IGU9cy5nZXQodCk7aWYodm9pZCAwPT09ZSl7ZT1bXTtzLnNldCh0LGUpfWVsc2UgaWYoIShpJiZhIGluc3RhbmNlb2YgRGljdCkpY29udGludWU7ZS5wdXNoKGEpfWZvcihjb25zdFt0LGldb2Ygcyl7aWYoMT09PWkubGVuZ3RofHwhKGlbMF1pbnN0YW5jZW9mIERpY3QpKXthLl9tYXBbdF09aVswXTtjb250aW51ZX1jb25zdCBzPW5ldyBEaWN0KGUpO2Zvcihjb25zdCBlIG9mIGkpZm9yKGNvbnN0W3QsaV1vZiBPYmplY3QuZW50cmllcyhlLl9tYXApKXZvaWQgMD09PXMuX21hcFt0XSYmKHMuX21hcFt0XT1pKTtzLnNpemU+MCYmKGEuX21hcFt0XT1zKX1zLmNsZWFyKCk7cmV0dXJuIGEuc2l6ZT4wP2E6RGljdC5lbXB0eX1jbG9uZSgpe2NvbnN0IGU9bmV3IERpY3QodGhpcy54cmVmKTtmb3IoY29uc3QgdCBvZiB0aGlzLmdldEtleXMoKSllLnNldCh0LHRoaXMuZ2V0UmF3KHQpKTtyZXR1cm4gZX19Y2xhc3MgUmVme2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5udW09ZTt0aGlzLmdlbj10fXRvU3RyaW5nKCl7cmV0dXJuIDA9PT10aGlzLmdlbj9gJHt0aGlzLm51bX1SYDpgJHt0aGlzLm51bX1SJHt0aGlzLmdlbn1gfXN0YXRpYyBmcm9tU3RyaW5nKGUpe2NvbnN0IHQ9d3RbZV07aWYodClyZXR1cm4gdDtjb25zdCBpPS9eKFxkKylSKFxkKikkLy5leGVjKGUpO3JldHVybiBpJiYiMCIhPT1pWzFdP3d0W2VdPW5ldyBSZWYocGFyc2VJbnQoaVsxXSksaVsyXT9wYXJzZUludChpWzJdKTowKTpudWxsfXN0YXRpYyBnZXQoZSx0KXtjb25zdCBpPTA9PT10P2Ake2V9UmA6YCR7ZX1SJHt0fWA7cmV0dXJuIHd0W2ldfHw9bmV3IFJlZihlLHQpfX1jbGFzcyBSZWZTZXR7Y29uc3RydWN0b3IoZT1udWxsKXt0aGlzLl9zZXQ9bmV3IFNldChlPy5fc2V0KX1oYXMoZSl7cmV0dXJuIHRoaXMuX3NldC5oYXMoZS50b1N0cmluZygpKX1wdXQoZSl7dGhpcy5fc2V0LmFkZChlLnRvU3RyaW5nKCkpfXJlbW92ZShlKXt0aGlzLl9zZXQuZGVsZXRlKGUudG9TdHJpbmcoKSl9W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5fc2V0LnZhbHVlcygpfWNsZWFyKCl7dGhpcy5fc2V0LmNsZWFyKCl9fWNsYXNzIFJlZlNldENhY2hle2NvbnN0cnVjdG9yKCl7dGhpcy5fbWFwPW5ldyBNYXB9Z2V0IHNpemUoKXtyZXR1cm4gdGhpcy5fbWFwLnNpemV9Z2V0KGUpe3JldHVybiB0aGlzLl9tYXAuZ2V0KGUudG9TdHJpbmcoKSl9aGFzKGUpe3JldHVybiB0aGlzLl9tYXAuaGFzKGUudG9TdHJpbmcoKSl9cHV0KGUsdCl7dGhpcy5fbWFwLnNldChlLnRvU3RyaW5nKCksdCl9cHV0QWxpYXMoZSx0KXt0aGlzLl9tYXAuc2V0KGUudG9TdHJpbmcoKSx0aGlzLmdldCh0KSl9W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5fbWFwLnZhbHVlcygpfWNsZWFyKCl7dGhpcy5fbWFwLmNsZWFyKCl9Kml0ZW1zKCl7Zm9yKGNvbnN0W2UsdF1vZiB0aGlzLl9tYXApeWllbGRbUmVmLmZyb21TdHJpbmcoZSksdF19fWZ1bmN0aW9uIGlzTmFtZShlLHQpe3JldHVybiBlIGluc3RhbmNlb2YgTmFtZSYmKHZvaWQgMD09PXR8fGUubmFtZT09PXQpfWZ1bmN0aW9uIGlzQ21kKGUsdCl7cmV0dXJuIGUgaW5zdGFuY2VvZiBDbWQmJih2b2lkIDA9PT10fHxlLmNtZD09PXQpfWZ1bmN0aW9uIGlzRGljdChlLHQpe3JldHVybiBlIGluc3RhbmNlb2YgRGljdCYmKHZvaWQgMD09PXR8fGlzTmFtZShlLmdldCgiVHlwZSIpLHQpKX1mdW5jdGlvbiBpc1JlZnNFcXVhbChlLHQpe3JldHVybiBlLm51bT09PXQubnVtJiZlLmdlbj09PXQuZ2VufWNsYXNzIEJhc2VTdHJlYW17Y29uc3RydWN0b3IoKXt0aGlzLmNvbnN0cnVjdG9yPT09QmFzZVN0cmVhbSYmdW5yZWFjaGFibGUoIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTdHJlYW0uIil9Z2V0IGxlbmd0aCgpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBnZXR0ZXIgYGxlbmd0aGAgYWNjZXNzZWQiKX1nZXQgaXNFbXB0eSgpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBnZXR0ZXIgYGlzRW1wdHlgIGFjY2Vzc2VkIil9Z2V0IGlzRGF0YUxvYWRlZCgpe3JldHVybiBzaGFkb3codGhpcywiaXNEYXRhTG9hZGVkIiwhMCl9Z2V0Qnl0ZSgpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYGdldEJ5dGVgIGNhbGxlZCIpfWdldEJ5dGVzKGUpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYGdldEJ5dGVzYCBjYWxsZWQiKX1wZWVrQnl0ZSgpe2NvbnN0IGU9dGhpcy5nZXRCeXRlKCk7LTEhPT1lJiZ0aGlzLnBvcy0tO3JldHVybiBlfXBlZWtCeXRlcyhlKXtjb25zdCB0PXRoaXMuZ2V0Qnl0ZXMoZSk7dGhpcy5wb3MtPXQubGVuZ3RoO3JldHVybiB0fWdldFVpbnQxNigpe2NvbnN0IGU9dGhpcy5nZXRCeXRlKCksdD10aGlzLmdldEJ5dGUoKTtyZXR1cm4tMT09PWV8fC0xPT09dD8tMTooZTw8OCkrdH1nZXRJbnQzMigpe3JldHVybih0aGlzLmdldEJ5dGUoKTw8MjQpKyh0aGlzLmdldEJ5dGUoKTw8MTYpKyh0aGlzLmdldEJ5dGUoKTw8OCkrdGhpcy5nZXRCeXRlKCl9Z2V0Qnl0ZVJhbmdlKGUsdCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgZ2V0Qnl0ZVJhbmdlYCBjYWxsZWQiKX1nZXRTdHJpbmcoZSl7cmV0dXJuIGJ5dGVzVG9TdHJpbmcodGhpcy5nZXRCeXRlcyhlKSl9c2tpcChlKXt0aGlzLnBvcys9ZXx8MX1yZXNldCgpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYHJlc2V0YCBjYWxsZWQiKX1tb3ZlU3RhcnQoKXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGBtb3ZlU3RhcnRgIGNhbGxlZCIpfW1ha2VTdWJTdHJlYW0oZSx0LGk9bnVsbCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgbWFrZVN1YlN0cmVhbWAgY2FsbGVkIil9Z2V0QmFzZVN0cmVhbXMoKXtyZXR1cm4gbnVsbH19Y29uc3QgRHQ9L15bMS05XVwuXGQkLztmdW5jdGlvbiBnZXRMb29rdXBUYWJsZUZhY3RvcnkoZSl7bGV0IHQ7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoZSl7dD1PYmplY3QuY3JlYXRlKG51bGwpO2UodCk7ZT1udWxsfXJldHVybiB0fX1jbGFzcyBNaXNzaW5nRGF0YUV4Y2VwdGlvbiBleHRlbmRzIHJ0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoYE1pc3NpbmcgZGF0YSBbJHtlfSwgJHt0fSlgLCJNaXNzaW5nRGF0YUV4Y2VwdGlvbiIpO3RoaXMuYmVnaW49ZTt0aGlzLmVuZD10fX1jbGFzcyBQYXJzZXJFT0ZFeGNlcHRpb24gZXh0ZW5kcyBydHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJQYXJzZXJFT0ZFeGNlcHRpb24iKX19Y2xhc3MgWFJlZkVudHJ5RXhjZXB0aW9uIGV4dGVuZHMgcnR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiWFJlZkVudHJ5RXhjZXB0aW9uIil9fWNsYXNzIFhSZWZQYXJzZUV4Y2VwdGlvbiBleHRlbmRzIHJ0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsIlhSZWZQYXJzZUV4Y2VwdGlvbiIpfX1mdW5jdGlvbiBhcnJheUJ1ZmZlcnNUb0J5dGVzKGUpe2NvbnN0IHQ9ZS5sZW5ndGg7aWYoMD09PXQpcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO2lmKDE9PT10KXJldHVybiBuZXcgVWludDhBcnJheShlWzBdKTtsZXQgaT0wO2ZvcihsZXQgYT0wO2E8dDthKyspaSs9ZVthXS5ieXRlTGVuZ3RoO2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkoaSk7bGV0IHM9MDtmb3IobGV0IGk9MDtpPHQ7aSsrKXtjb25zdCB0PW5ldyBVaW50OEFycmF5KGVbaV0pO2Euc2V0KHQscyk7cys9dC5ieXRlTGVuZ3RofXJldHVybiBhfWZ1bmN0aW9uIGdldEluaGVyaXRhYmxlUHJvcGVydHkoe2RpY3Q6ZSxrZXk6dCxnZXRBcnJheTppPSExLHN0b3BXaGVuRm91bmQ6YT0hMH0pe2xldCBzO2NvbnN0IHI9bmV3IFJlZlNldDtmb3IoO2UgaW5zdGFuY2VvZiBEaWN0JiYoIWUub2JqSWR8fCFyLmhhcyhlLm9iaklkKSk7KXtlLm9iaklkJiZyLnB1dChlLm9iaklkKTtjb25zdCBuPWk/ZS5nZXRBcnJheSh0KTplLmdldCh0KTtpZih2b2lkIDAhPT1uKXtpZihhKXJldHVybiBuOyhzfHw9W10pLnB1c2gobil9ZT1lLmdldCgiUGFyZW50Iil9cmV0dXJuIHN9Y29uc3QgRnQ9WyIiLCJDIiwiQ0MiLCJDQ0MiLCJDRCIsIkQiLCJEQyIsIkRDQyIsIkRDQ0MiLCJDTSIsIiIsIlgiLCJYWCIsIlhYWCIsIlhMIiwiTCIsIkxYIiwiTFhYIiwiTFhYWCIsIlhDIiwiIiwiSSIsIklJIiwiSUlJIiwiSVYiLCJWIiwiVkkiLCJWSUkiLCJWSUlJIiwiSVgiXTtmdW5jdGlvbiB0b1JvbWFuTnVtZXJhbHMoZSx0PSExKXthc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihlKSYmZT4wLCJUaGUgbnVtYmVyIHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIuIik7Y29uc3QgaT1bXTtsZXQgYTtmb3IoO2U+PTFlMzspe2UtPTFlMztpLnB1c2goIk0iKX1hPWUvMTAwfDA7ZSU9MTAwO2kucHVzaChGdFthXSk7YT1lLzEwfDA7ZSU9MTA7aS5wdXNoKEZ0WzEwK2FdKTtpLnB1c2goRnRbMjArZV0pO2NvbnN0IHM9aS5qb2luKCIiKTtyZXR1cm4gdD9zLnRvTG93ZXJDYXNlKCk6c31mdW5jdGlvbiBsb2cyKGUpe3JldHVybiBlPD0wPzA6TWF0aC5jZWlsKE1hdGgubG9nMihlKSl9ZnVuY3Rpb24gcmVhZEludDgoZSx0KXtyZXR1cm4gZVt0XTw8MjQ+PjI0fWZ1bmN0aW9uIHJlYWRVaW50MTYoZSx0KXtyZXR1cm4gZVt0XTw8OHxlW3QrMV19ZnVuY3Rpb24gcmVhZFVpbnQzMihlLHQpe3JldHVybihlW3RdPDwyNHxlW3QrMV08PDE2fGVbdCsyXTw8OHxlW3QrM10pPj4+MH1mdW5jdGlvbiBpc1doaXRlU3BhY2UoZSl7cmV0dXJuIDMyPT09ZXx8OT09PWV8fDEzPT09ZXx8MTA9PT1lfWZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoZSx0KXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKSYmKG51bGw9PT10fHxlLmxlbmd0aD09PXQpJiZlLmV2ZXJ5KChlPT4ibnVtYmVyIj09dHlwZW9mIGUpKX1mdW5jdGlvbiBwYXJzZVhGQVBhdGgoZSl7Y29uc3QgdD0vKC4rKVxbKFxkKylcXSQvO3JldHVybiBlLnNwbGl0KCIuIikubWFwKChlPT57Y29uc3QgaT1lLm1hdGNoKHQpO3JldHVybiBpP3tuYW1lOmlbMV0scG9zOnBhcnNlSW50KGlbMl0sMTApfTp7bmFtZTplLHBvczowfX0pKX1mdW5jdGlvbiBlc2NhcGVQREZOYW1lKGUpe2NvbnN0IHQ9W107bGV0IGk9MDtmb3IobGV0IGE9MCxzPWUubGVuZ3RoO2E8czthKyspe2NvbnN0IHM9ZS5jaGFyQ29kZUF0KGEpO2lmKHM8MzN8fHM+MTI2fHwzNT09PXN8fDQwPT09c3x8NDE9PT1zfHw2MD09PXN8fDYyPT09c3x8OTE9PT1zfHw5Mz09PXN8fDEyMz09PXN8fDEyNT09PXN8fDQ3PT09c3x8Mzc9PT1zKXtpPGEmJnQucHVzaChlLnN1YnN0cmluZyhpLGEpKTt0LnB1c2goYCMke3MudG9TdHJpbmcoMTYpfWApO2k9YSsxfX1pZigwPT09dC5sZW5ndGgpcmV0dXJuIGU7aTxlLmxlbmd0aCYmdC5wdXNoKGUuc3Vic3RyaW5nKGksZS5sZW5ndGgpKTtyZXR1cm4gdC5qb2luKCIiKX1mdW5jdGlvbiBlc2NhcGVTdHJpbmcoZSl7cmV0dXJuIGUucmVwbGFjZUFsbCgvKFsoKVxcXG5ccl0pL2csKGU9PiJcbiI9PT1lPyJcXG4iOiJcciI9PT1lPyJcXHIiOmBcXCR7ZX1gKSl9ZnVuY3Rpb24gX2NvbGxlY3RKUyhlLHQsaSxhKXtpZighZSlyZXR1cm47bGV0IHM9bnVsbDtpZihlIGluc3RhbmNlb2YgUmVmKXtpZihhLmhhcyhlKSlyZXR1cm47cz1lO2EucHV0KHMpO2U9dC5mZXRjaChlKX1pZihBcnJheS5pc0FycmF5KGUpKWZvcihjb25zdCBzIG9mIGUpX2NvbGxlY3RKUyhzLHQsaSxhKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBEaWN0KXtpZihpc05hbWUoZS5nZXQoIlMiKSwiSmF2YVNjcmlwdCIpKXtjb25zdCB0PWUuZ2V0KCJKUyIpO2xldCBhO3QgaW5zdGFuY2VvZiBCYXNlU3RyZWFtP2E9dC5nZXRTdHJpbmcoKToic3RyaW5nIj09dHlwZW9mIHQmJihhPXQpO2EmJj1zdHJpbmdUb1BERlN0cmluZyhhKS5yZXBsYWNlQWxsKCJcMCIsIiIpO2EmJmkucHVzaChhKX1fY29sbGVjdEpTKGUuZ2V0UmF3KCJOZXh0IiksdCxpLGEpfXMmJmEucmVtb3ZlKHMpfWZ1bmN0aW9uIGNvbGxlY3RBY3Rpb25zKGUsdCxpKXtjb25zdCBhPU9iamVjdC5jcmVhdGUobnVsbCkscz1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OnQsa2V5OiJBQSIsc3RvcFdoZW5Gb3VuZDohMX0pO2lmKHMpZm9yKGxldCB0PXMubGVuZ3RoLTE7dD49MDt0LS0pe2NvbnN0IHI9c1t0XTtpZihyIGluc3RhbmNlb2YgRGljdClmb3IoY29uc3QgdCBvZiByLmdldEtleXMoKSl7Y29uc3Qgcz1pW3RdO2lmKCFzKWNvbnRpbnVlO2NvbnN0IG49W107X2NvbGxlY3RKUyhyLmdldFJhdyh0KSxlLG4sbmV3IFJlZlNldCk7bi5sZW5ndGg+MCYmKGFbc109bil9fWlmKHQuaGFzKCJBIikpe2NvbnN0IGk9W107X2NvbGxlY3RKUyh0LmdldCgiQSIpLGUsaSxuZXcgUmVmU2V0KTtpLmxlbmd0aD4wJiYoYS5BY3Rpb249aSl9cmV0dXJuIG9iamVjdFNpemUoYSk+MD9hOm51bGx9Y29uc3QgU3Q9ezYwOiImbHQ7Iiw2MjoiJmd0OyIsMzg6IiZhbXA7IiwzNDoiJnF1b3Q7IiwzOToiJmFwb3M7In07ZnVuY3Rpb24qY29kZVBvaW50SXRlcihlKXtmb3IobGV0IHQ9MCxpPWUubGVuZ3RoO3Q8aTt0Kyspe2NvbnN0IGk9ZS5jb2RlUG9pbnRBdCh0KTtpPjU1Mjk1JiYoaTw1NzM0NHx8aT42NTUzMykmJnQrKzt5aWVsZCBpfX1mdW5jdGlvbiBlbmNvZGVUb1htbFN0cmluZyhlKXtjb25zdCB0PVtdO2xldCBpPTA7Zm9yKGxldCBhPTAscz1lLmxlbmd0aDthPHM7YSsrKXtjb25zdCBzPWUuY29kZVBvaW50QXQoYSk7aWYoMzI8PXMmJnM8PTEyNil7Y29uc3Qgcj1TdFtzXTtpZihyKXtpPGEmJnQucHVzaChlLnN1YnN0cmluZyhpLGEpKTt0LnB1c2gocik7aT1hKzF9fWVsc2V7aTxhJiZ0LnB1c2goZS5zdWJzdHJpbmcoaSxhKSk7dC5wdXNoKGAmI3gke3MudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9O2ApO3M+NTUyOTUmJihzPDU3MzQ0fHxzPjY1NTMzKSYmYSsrO2k9YSsxfX1pZigwPT09dC5sZW5ndGgpcmV0dXJuIGU7aTxlLmxlbmd0aCYmdC5wdXNoKGUuc3Vic3RyaW5nKGksZS5sZW5ndGgpKTtyZXR1cm4gdC5qb2luKCIiKX1mdW5jdGlvbiB2YWxpZGF0ZUZvbnROYW1lKGUsdD0hMSl7Y29uc3QgaT0vXigifCcpLiooInwnKSQvLmV4ZWMoZSk7aWYoaSYmaVsxXT09PWlbMl0pe2lmKG5ldyBSZWdFeHAoYFteXFxcXF0ke2lbMV19YCkudGVzdChlLnNsaWNlKDEsLTEpKSl7dCYmd2FybihgRm9udEZhbWlseSBjb250YWlucyB1bmVzY2FwZWQgJHtpWzFdfTogJHtlfS5gKTtyZXR1cm4hMX19ZWxzZSBmb3IoY29uc3QgaSBvZiBlLnNwbGl0KC9bIFx0XSsvKSlpZigvXihcZHwoLShcZHwtKSkpLy50ZXN0KGkpfHwhL15bXHctXFxdKyQvLnRlc3QoaSkpe3QmJndhcm4oYEZvbnRGYW1pbHkgY29udGFpbnMgaW52YWxpZCA8Y3VzdG9tLWlkZW50PjogJHtlfS5gKTtyZXR1cm4hMX1yZXR1cm4hMH1mdW5jdGlvbiB2YWxpZGF0ZUNTU0ZvbnQoZSl7Y29uc3QgdD1uZXcgU2V0KFsiMTAwIiwiMjAwIiwiMzAwIiwiNDAwIiwiNTAwIiwiNjAwIiwiNzAwIiwiODAwIiwiOTAwIiwiMTAwMCIsIm5vcm1hbCIsImJvbGQiLCJib2xkZXIiLCJsaWdodGVyIl0pLHtmb250RmFtaWx5OmksZm9udFdlaWdodDphLGl0YWxpY0FuZ2xlOnN9PWU7aWYoIXZhbGlkYXRlRm9udE5hbWUoaSwhMCkpcmV0dXJuITE7Y29uc3Qgcj1hP2EudG9TdHJpbmcoKToiIjtlLmZvbnRXZWlnaHQ9dC5oYXMocik/cjoiNDAwIjtjb25zdCBuPXBhcnNlRmxvYXQocyk7ZS5pdGFsaWNBbmdsZT1pc05hTihuKXx8bjwtOTB8fG4+OTA/IjE0IjpzLnRvU3RyaW5nKCk7cmV0dXJuITB9ZnVuY3Rpb24gcmVjb3ZlckpzVVJMKGUpe2NvbnN0IHQ9bmV3IFJlZ0V4cCgiXlxccyooIitbImFwcC5sYXVuY2hVUkwiLCJ3aW5kb3cub3BlbiIsInhmYS5ob3N0LmdvdG9VUkwiXS5qb2luKCJ8IikucmVwbGFjZUFsbCgiLiIsIlxcLiIpKyIpXFwoKD86J3xcIikoW14nXCJdKikoPzonfFwiKSg/OixcXHMqKFxcdyspXFwpfFxcKSkiLCJpIikuZXhlYyhlKTtpZih0Py5bMl0pe2NvbnN0IGU9dFsyXTtsZXQgaT0hMTsidHJ1ZSI9PT10WzNdJiYiYXBwLmxhdW5jaFVSTCI9PT10WzFdJiYoaT0hMCk7cmV0dXJue3VybDplLG5ld1dpbmRvdzppfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBudW1iZXJUb1N0cmluZyhlKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGUpKXJldHVybiBlLnRvU3RyaW5nKCk7Y29uc3QgdD1NYXRoLnJvdW5kKDEwMCplKTtyZXR1cm4gdCUxMDA9PTA/KHQvMTAwKS50b1N0cmluZygpOnQlMTA9PTA/ZS50b0ZpeGVkKDEpOmUudG9GaXhlZCgyKX1mdW5jdGlvbiBnZXROZXdBbm5vdGF0aW9uc01hcChlKXtpZighZSlyZXR1cm4gbnVsbDtjb25zdCB0PW5ldyBNYXA7Zm9yKGNvbnN0W2ksYV1vZiBlKXtpZighaS5zdGFydHNXaXRoKEUpKWNvbnRpbnVlO2xldCBlPXQuZ2V0KGEucGFnZUluZGV4KTtpZighZSl7ZT1bXTt0LnNldChhLnBhZ2VJbmRleCxlKX1lLnB1c2goYSl9cmV0dXJuIHQuc2l6ZT4wP3Q6bnVsbH1mdW5jdGlvbiBpc0FzY2lpKGUpe3JldHVybi9eW1x4MDAtXHg3Rl0qJC8udGVzdChlKX1mdW5jdGlvbiBzdHJpbmdUb1VURjE2SGV4U3RyaW5nKGUpe2NvbnN0IHQ9W107Zm9yKGxldCBpPTAsYT1lLmxlbmd0aDtpPGE7aSsrKXtjb25zdCBhPWUuY2hhckNvZGVBdChpKTt0LnB1c2goKGE+PjgmMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwiMCIpLCgyNTUmYSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIjAiKSl9cmV0dXJuIHQuam9pbigiIil9ZnVuY3Rpb24gc3RyaW5nVG9VVEYxNlN0cmluZyhlLHQ9ITEpe2NvbnN0IGk9W107dCYmaS5wdXNoKCLDvsO/Iik7Zm9yKGxldCB0PTAsYT1lLmxlbmd0aDt0PGE7dCsrKXtjb25zdCBhPWUuY2hhckNvZGVBdCh0KTtpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhPj44JjI1NSksU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmYSkpfXJldHVybiBpLmpvaW4oIiIpfWZ1bmN0aW9uIGdldFJvdGF0aW9uTWF0cml4KGUsdCxpKXtzd2l0Y2goZSl7Y2FzZSA5MDpyZXR1cm5bMCwxLC0xLDAsdCwwXTtjYXNlIDE4MDpyZXR1cm5bLTEsMCwwLC0xLHQsaV07Y2FzZSAyNzA6cmV0dXJuWzAsLTEsMSwwLDAsaV07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgcm90YXRpb24iKX19ZnVuY3Rpb24gZ2V0U2l6ZUluQnl0ZXMoZSl7cmV0dXJuIE1hdGguY2VpbChNYXRoLmNlaWwoTWF0aC5sb2cyKDErZSkpLzgpfWNsYXNzIFN0cmVhbSBleHRlbmRzIEJhc2VTdHJlYW17Y29uc3RydWN0b3IoZSx0LGksYSl7c3VwZXIoKTt0aGlzLmJ5dGVzPWUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSk7dGhpcy5zdGFydD10fHwwO3RoaXMucG9zPXRoaXMuc3RhcnQ7dGhpcy5lbmQ9dCtpfHx0aGlzLmJ5dGVzLmxlbmd0aDt0aGlzLmRpY3Q9YX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuZW5kLXRoaXMuc3RhcnR9Z2V0IGlzRW1wdHkoKXtyZXR1cm4gMD09PXRoaXMubGVuZ3RofWdldEJ5dGUoKXtyZXR1cm4gdGhpcy5wb3M+PXRoaXMuZW5kPy0xOnRoaXMuYnl0ZXNbdGhpcy5wb3MrK119Z2V0Qnl0ZXMoZSl7Y29uc3QgdD10aGlzLmJ5dGVzLGk9dGhpcy5wb3MsYT10aGlzLmVuZDtpZighZSlyZXR1cm4gdC5zdWJhcnJheShpLGEpO2xldCBzPWkrZTtzPmEmJihzPWEpO3RoaXMucG9zPXM7cmV0dXJuIHQuc3ViYXJyYXkoaSxzKX1nZXRCeXRlUmFuZ2UoZSx0KXtlPDAmJihlPTApO3Q+dGhpcy5lbmQmJih0PXRoaXMuZW5kKTtyZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheShlLHQpfXJlc2V0KCl7dGhpcy5wb3M9dGhpcy5zdGFydH1tb3ZlU3RhcnQoKXt0aGlzLnN0YXJ0PXRoaXMucG9zfW1ha2VTdWJTdHJlYW0oZSx0LGk9bnVsbCl7cmV0dXJuIG5ldyBTdHJlYW0odGhpcy5ieXRlcy5idWZmZXIsZSx0LGkpfX1jbGFzcyBTdHJpbmdTdHJlYW0gZXh0ZW5kcyBTdHJlYW17Y29uc3RydWN0b3IoZSl7c3VwZXIoc3RyaW5nVG9CeXRlcyhlKSl9fWNsYXNzIE51bGxTdHJlYW0gZXh0ZW5kcyBTdHJlYW17Y29uc3RydWN0b3IoKXtzdXBlcihuZXcgVWludDhBcnJheSgwKSl9fWNsYXNzIENodW5rZWRTdHJlYW0gZXh0ZW5kcyBTdHJlYW17Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKG5ldyBVaW50OEFycmF5KGUpLDAsZSxudWxsKTt0aGlzLmNodW5rU2l6ZT10O3RoaXMuX2xvYWRlZENodW5rcz1uZXcgU2V0O3RoaXMubnVtQ2h1bmtzPU1hdGguY2VpbChlL3QpO3RoaXMubWFuYWdlcj1pO3RoaXMucHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoPTA7dGhpcy5sYXN0U3VjY2Vzc2Z1bEVuc3VyZUJ5dGVDaHVuaz0tMX1nZXRNaXNzaW5nQ2h1bmtzKCl7Y29uc3QgZT1bXTtmb3IobGV0IHQ9MCxpPXRoaXMubnVtQ2h1bmtzO3Q8aTsrK3QpdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyh0KXx8ZS5wdXNoKHQpO3JldHVybiBlfWdldCBudW1DaHVua3NMb2FkZWQoKXtyZXR1cm4gdGhpcy5fbG9hZGVkQ2h1bmtzLnNpemV9Z2V0IGlzRGF0YUxvYWRlZCgpe3JldHVybiB0aGlzLm51bUNodW5rc0xvYWRlZD09PXRoaXMubnVtQ2h1bmtzfW9uUmVjZWl2ZURhdGEoZSx0KXtjb25zdCBpPXRoaXMuY2h1bmtTaXplO2lmKGUlaSE9MCl0aHJvdyBuZXcgRXJyb3IoYEJhZCBiZWdpbiBvZmZzZXQ6ICR7ZX1gKTtjb25zdCBhPWUrdC5ieXRlTGVuZ3RoO2lmKGElaSE9MCYmYSE9PXRoaXMuYnl0ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgQmFkIGVuZCBvZmZzZXQ6ICR7YX1gKTt0aGlzLmJ5dGVzLnNldChuZXcgVWludDhBcnJheSh0KSxlKTtjb25zdCBzPU1hdGguZmxvb3IoZS9pKSxyPU1hdGguZmxvb3IoKGEtMSkvaSkrMTtmb3IobGV0IGU9cztlPHI7KytlKXRoaXMuX2xvYWRlZENodW5rcy5hZGQoZSl9b25SZWNlaXZlUHJvZ3Jlc3NpdmVEYXRhKGUpe2xldCB0PXRoaXMucHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoO2NvbnN0IGk9TWF0aC5mbG9vcih0L3RoaXMuY2h1bmtTaXplKTt0aGlzLmJ5dGVzLnNldChuZXcgVWludDhBcnJheShlKSx0KTt0Kz1lLmJ5dGVMZW5ndGg7dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGg9dDtjb25zdCBhPXQ+PXRoaXMuZW5kP3RoaXMubnVtQ2h1bmtzOk1hdGguZmxvb3IodC90aGlzLmNodW5rU2l6ZSk7Zm9yKGxldCBlPWk7ZTxhOysrZSl0aGlzLl9sb2FkZWRDaHVua3MuYWRkKGUpfWVuc3VyZUJ5dGUoZSl7aWYoZTx0aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aClyZXR1cm47Y29uc3QgdD1NYXRoLmZsb29yKGUvdGhpcy5jaHVua1NpemUpO2lmKCEodD50aGlzLm51bUNodW5rcykmJnQhPT10aGlzLmxhc3RTdWNjZXNzZnVsRW5zdXJlQnl0ZUNodW5rKXtpZighdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyh0KSl0aHJvdyBuZXcgTWlzc2luZ0RhdGFFeGNlcHRpb24oZSxlKzEpO3RoaXMubGFzdFN1Y2Nlc3NmdWxFbnN1cmVCeXRlQ2h1bms9dH19ZW5zdXJlUmFuZ2UoZSx0KXtpZihlPj10KXJldHVybjtpZih0PD10aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aClyZXR1cm47Y29uc3QgaT1NYXRoLmZsb29yKGUvdGhpcy5jaHVua1NpemUpO2lmKGk+dGhpcy5udW1DaHVua3MpcmV0dXJuO2NvbnN0IGE9TWF0aC5taW4oTWF0aC5mbG9vcigodC0xKS90aGlzLmNodW5rU2l6ZSkrMSx0aGlzLm51bUNodW5rcyk7Zm9yKGxldCBzPWk7czxhOysrcylpZighdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyhzKSl0aHJvdyBuZXcgTWlzc2luZ0RhdGFFeGNlcHRpb24oZSx0KX1uZXh0RW1wdHlDaHVuayhlKXtjb25zdCB0PXRoaXMubnVtQ2h1bmtzO2ZvcihsZXQgaT0wO2k8dDsrK2kpe2NvbnN0IGE9KGUraSkldDtpZighdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyhhKSlyZXR1cm4gYX1yZXR1cm4gbnVsbH1oYXNDaHVuayhlKXtyZXR1cm4gdGhpcy5fbG9hZGVkQ2h1bmtzLmhhcyhlKX1nZXRCeXRlKCl7Y29uc3QgZT10aGlzLnBvcztpZihlPj10aGlzLmVuZClyZXR1cm4tMTtlPj10aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVCeXRlKGUpO3JldHVybiB0aGlzLmJ5dGVzW3RoaXMucG9zKytdfWdldEJ5dGVzKGUpe2NvbnN0IHQ9dGhpcy5ieXRlcyxpPXRoaXMucG9zLGE9dGhpcy5lbmQ7aWYoIWUpe2E+dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlUmFuZ2UoaSxhKTtyZXR1cm4gdC5zdWJhcnJheShpLGEpfWxldCBzPWkrZTtzPmEmJihzPWEpO3M+dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlUmFuZ2UoaSxzKTt0aGlzLnBvcz1zO3JldHVybiB0LnN1YmFycmF5KGkscyl9Z2V0Qnl0ZVJhbmdlKGUsdCl7ZTwwJiYoZT0wKTt0PnRoaXMuZW5kJiYodD10aGlzLmVuZCk7dD50aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVSYW5nZShlLHQpO3JldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KGUsdCl9bWFrZVN1YlN0cmVhbShlLHQsaT1udWxsKXt0P2UrdD50aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aCYmdGhpcy5lbnN1cmVSYW5nZShlLGUrdCk6ZT49dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGgmJnRoaXMuZW5zdXJlQnl0ZShlKTtmdW5jdGlvbiBDaHVua2VkU3RyZWFtU3Vic3RyZWFtKCl7fUNodW5rZWRTdHJlYW1TdWJzdHJlYW0ucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodGhpcyk7Q2h1bmtlZFN0cmVhbVN1YnN0cmVhbS5wcm90b3R5cGUuZ2V0TWlzc2luZ0NodW5rcz1mdW5jdGlvbigpe2NvbnN0IGU9dGhpcy5jaHVua1NpemUsdD1NYXRoLmZsb29yKHRoaXMuc3RhcnQvZSksaT1NYXRoLmZsb29yKCh0aGlzLmVuZC0xKS9lKSsxLGE9W107Zm9yKGxldCBlPXQ7ZTxpOysrZSl0aGlzLl9sb2FkZWRDaHVua3MuaGFzKGUpfHxhLnB1c2goZSk7cmV0dXJuIGF9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShDaHVua2VkU3RyZWFtU3Vic3RyZWFtLnByb3RvdHlwZSwiaXNEYXRhTG9hZGVkIix7Z2V0KCl7cmV0dXJuIHRoaXMubnVtQ2h1bmtzTG9hZGVkPT09dGhpcy5udW1DaHVua3N8fDA9PT10aGlzLmdldE1pc3NpbmdDaHVua3MoKS5sZW5ndGh9LGNvbmZpZ3VyYWJsZTohMH0pO2NvbnN0IGE9bmV3IENodW5rZWRTdHJlYW1TdWJzdHJlYW07YS5wb3M9YS5zdGFydD1lO2EuZW5kPWUrdHx8dGhpcy5lbmQ7YS5kaWN0PWk7cmV0dXJuIGF9Z2V0QmFzZVN0cmVhbXMoKXtyZXR1cm5bdGhpc119fWNsYXNzIENodW5rZWRTdHJlYW1NYW5hZ2Vye2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5sZW5ndGg9dC5sZW5ndGg7dGhpcy5jaHVua1NpemU9dC5yYW5nZUNodW5rU2l6ZTt0aGlzLnN0cmVhbT1uZXcgQ2h1bmtlZFN0cmVhbSh0aGlzLmxlbmd0aCx0aGlzLmNodW5rU2l6ZSx0aGlzKTt0aGlzLnBkZk5ldHdvcmtTdHJlYW09ZTt0aGlzLmRpc2FibGVBdXRvRmV0Y2g9dC5kaXNhYmxlQXV0b0ZldGNoO3RoaXMubXNnSGFuZGxlcj10Lm1zZ0hhbmRsZXI7dGhpcy5jdXJyUmVxdWVzdElkPTA7dGhpcy5fY2h1bmtzTmVlZGVkQnlSZXF1ZXN0PW5ldyBNYXA7dGhpcy5fcmVxdWVzdHNCeUNodW5rPW5ldyBNYXA7dGhpcy5fcHJvbWlzZXNCeVJlcXVlc3Q9bmV3IE1hcDt0aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aD0wO3RoaXMuYWJvcnRlZD0hMTt0aGlzLl9sb2FkZWRTdHJlYW1DYXBhYmlsaXR5PVByb21pc2Uud2l0aFJlc29sdmVycygpfXNlbmRSZXF1ZXN0KGUsdCl7Y29uc3QgaT10aGlzLnBkZk5ldHdvcmtTdHJlYW0uZ2V0UmFuZ2VSZWFkZXIoZSx0KTtpLmlzU3RyZWFtaW5nU3VwcG9ydGVkfHwoaS5vblByb2dyZXNzPXRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMpKTtsZXQgYT1bXSxzPTA7cmV0dXJuIG5ldyBQcm9taXNlKCgoZSx0KT0+e2NvbnN0IHJlYWRDaHVuaz0oe3ZhbHVlOnIsZG9uZTpufSk9Pnt0cnl7aWYobil7Y29uc3QgdD1hcnJheUJ1ZmZlcnNUb0J5dGVzKGEpO2E9bnVsbDtlKHQpO3JldHVybn1zKz1yLmJ5dGVMZW5ndGg7aS5pc1N0cmVhbWluZ1N1cHBvcnRlZCYmdGhpcy5vblByb2dyZXNzKHtsb2FkZWQ6c30pO2EucHVzaChyKTtpLnJlYWQoKS50aGVuKHJlYWRDaHVuayx0KX1jYXRjaChlKXt0KGUpfX07aS5yZWFkKCkudGhlbihyZWFkQ2h1bmssdCl9KSkudGhlbigodD0+e3RoaXMuYWJvcnRlZHx8dGhpcy5vblJlY2VpdmVEYXRhKHtjaHVuazp0LGJlZ2luOmV9KX0pKX1yZXF1ZXN0QWxsQ2h1bmtzKGU9ITEpe2lmKCFlKXtjb25zdCBlPXRoaXMuc3RyZWFtLmdldE1pc3NpbmdDaHVua3MoKTt0aGlzLl9yZXF1ZXN0Q2h1bmtzKGUpfXJldHVybiB0aGlzLl9sb2FkZWRTdHJlYW1DYXBhYmlsaXR5LnByb21pc2V9X3JlcXVlc3RDaHVua3MoZSl7Y29uc3QgdD10aGlzLmN1cnJSZXF1ZXN0SWQrKyxpPW5ldyBTZXQ7dGhpcy5fY2h1bmtzTmVlZGVkQnlSZXF1ZXN0LnNldCh0LGkpO2Zvcihjb25zdCB0IG9mIGUpdGhpcy5zdHJlYW0uaGFzQ2h1bmsodCl8fGkuYWRkKHQpO2lmKDA9PT1pLnNpemUpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2NvbnN0IGE9UHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7dGhpcy5fcHJvbWlzZXNCeVJlcXVlc3Quc2V0KHQsYSk7Y29uc3Qgcz1bXTtmb3IoY29uc3QgZSBvZiBpKXtsZXQgaT10aGlzLl9yZXF1ZXN0c0J5Q2h1bmsuZ2V0KGUpO2lmKCFpKXtpPVtdO3RoaXMuX3JlcXVlc3RzQnlDaHVuay5zZXQoZSxpKTtzLnB1c2goZSl9aS5wdXNoKHQpfWlmKHMubGVuZ3RoPjApe2NvbnN0IGU9dGhpcy5ncm91cENodW5rcyhzKTtmb3IoY29uc3QgdCBvZiBlKXtjb25zdCBlPXQuYmVnaW5DaHVuayp0aGlzLmNodW5rU2l6ZSxpPU1hdGgubWluKHQuZW5kQ2h1bmsqdGhpcy5jaHVua1NpemUsdGhpcy5sZW5ndGgpO3RoaXMuc2VuZFJlcXVlc3QoZSxpKS5jYXRjaChhLnJlamVjdCl9fXJldHVybiBhLnByb21pc2UuY2F0Y2goKGU9PntpZighdGhpcy5hYm9ydGVkKXRocm93IGV9KSl9Z2V0U3RyZWFtKCl7cmV0dXJuIHRoaXMuc3RyZWFtfXJlcXVlc3RSYW5nZShlLHQpe3Q9TWF0aC5taW4odCx0aGlzLmxlbmd0aCk7Y29uc3QgaT10aGlzLmdldEJlZ2luQ2h1bmsoZSksYT10aGlzLmdldEVuZENodW5rKHQpLHM9W107Zm9yKGxldCBlPWk7ZTxhOysrZSlzLnB1c2goZSk7cmV0dXJuIHRoaXMuX3JlcXVlc3RDaHVua3Mocyl9cmVxdWVzdFJhbmdlcyhlPVtdKXtjb25zdCB0PVtdO2Zvcihjb25zdCBpIG9mIGUpe2NvbnN0IGU9dGhpcy5nZXRCZWdpbkNodW5rKGkuYmVnaW4pLGE9dGhpcy5nZXRFbmRDaHVuayhpLmVuZCk7Zm9yKGxldCBpPWU7aTxhOysraSl0LmluY2x1ZGVzKGkpfHx0LnB1c2goaSl9dC5zb3J0KChmdW5jdGlvbihlLHQpe3JldHVybiBlLXR9KSk7cmV0dXJuIHRoaXMuX3JlcXVlc3RDaHVua3ModCl9Z3JvdXBDaHVua3MoZSl7Y29uc3QgdD1bXTtsZXQgaT0tMSxhPS0xO2ZvcihsZXQgcz0wLHI9ZS5sZW5ndGg7czxyOysrcyl7Y29uc3Qgcj1lW3NdO2k8MCYmKGk9cik7aWYoYT49MCYmYSsxIT09cil7dC5wdXNoKHtiZWdpbkNodW5rOmksZW5kQ2h1bms6YSsxfSk7aT1yfXMrMT09PWUubGVuZ3RoJiZ0LnB1c2goe2JlZ2luQ2h1bms6aSxlbmRDaHVuazpyKzF9KTthPXJ9cmV0dXJuIHR9b25Qcm9ncmVzcyhlKXt0aGlzLm1zZ0hhbmRsZXIuc2VuZCgiRG9jUHJvZ3Jlc3MiLHtsb2FkZWQ6dGhpcy5zdHJlYW0ubnVtQ2h1bmtzTG9hZGVkKnRoaXMuY2h1bmtTaXplK2UubG9hZGVkLHRvdGFsOnRoaXMubGVuZ3RofSl9b25SZWNlaXZlRGF0YShlKXtjb25zdCB0PWUuY2h1bmssaT12b2lkIDA9PT1lLmJlZ2luLGE9aT90aGlzLnByb2dyZXNzaXZlRGF0YUxlbmd0aDplLmJlZ2luLHM9YSt0LmJ5dGVMZW5ndGgscj1NYXRoLmZsb29yKGEvdGhpcy5jaHVua1NpemUpLG49czx0aGlzLmxlbmd0aD9NYXRoLmZsb29yKHMvdGhpcy5jaHVua1NpemUpOk1hdGguY2VpbChzL3RoaXMuY2h1bmtTaXplKTtpZihpKXt0aGlzLnN0cmVhbS5vblJlY2VpdmVQcm9ncmVzc2l2ZURhdGEodCk7dGhpcy5wcm9ncmVzc2l2ZURhdGFMZW5ndGg9c31lbHNlIHRoaXMuc3RyZWFtLm9uUmVjZWl2ZURhdGEoYSx0KTt0aGlzLnN0cmVhbS5pc0RhdGFMb2FkZWQmJnRoaXMuX2xvYWRlZFN0cmVhbUNhcGFiaWxpdHkucmVzb2x2ZSh0aGlzLnN0cmVhbSk7Y29uc3Qgbz1bXTtmb3IobGV0IGU9cjtlPG47KytlKXtjb25zdCB0PXRoaXMuX3JlcXVlc3RzQnlDaHVuay5nZXQoZSk7aWYodCl7dGhpcy5fcmVxdWVzdHNCeUNodW5rLmRlbGV0ZShlKTtmb3IoY29uc3QgaSBvZiB0KXtjb25zdCB0PXRoaXMuX2NodW5rc05lZWRlZEJ5UmVxdWVzdC5nZXQoaSk7dC5oYXMoZSkmJnQuZGVsZXRlKGUpO3Quc2l6ZT4wfHxvLnB1c2goaSl9fX1pZighdGhpcy5kaXNhYmxlQXV0b0ZldGNoJiYwPT09dGhpcy5fcmVxdWVzdHNCeUNodW5rLnNpemUpe2xldCBlO2lmKDE9PT10aGlzLnN0cmVhbS5udW1DaHVua3NMb2FkZWQpe2NvbnN0IHQ9dGhpcy5zdHJlYW0ubnVtQ2h1bmtzLTE7dGhpcy5zdHJlYW0uaGFzQ2h1bmsodCl8fChlPXQpfWVsc2UgZT10aGlzLnN0cmVhbS5uZXh0RW1wdHlDaHVuayhuKTtOdW1iZXIuaXNJbnRlZ2VyKGUpJiZ0aGlzLl9yZXF1ZXN0Q2h1bmtzKFtlXSl9Zm9yKGNvbnN0IGUgb2Ygbyl7Y29uc3QgdD10aGlzLl9wcm9taXNlc0J5UmVxdWVzdC5nZXQoZSk7dGhpcy5fcHJvbWlzZXNCeVJlcXVlc3QuZGVsZXRlKGUpO3QucmVzb2x2ZSgpfXRoaXMubXNnSGFuZGxlci5zZW5kKCJEb2NQcm9ncmVzcyIse2xvYWRlZDp0aGlzLnN0cmVhbS5udW1DaHVua3NMb2FkZWQqdGhpcy5jaHVua1NpemUsdG90YWw6dGhpcy5sZW5ndGh9KX1vbkVycm9yKGUpe3RoaXMuX2xvYWRlZFN0cmVhbUNhcGFiaWxpdHkucmVqZWN0KGUpfWdldEJlZ2luQ2h1bmsoZSl7cmV0dXJuIE1hdGguZmxvb3IoZS90aGlzLmNodW5rU2l6ZSl9Z2V0RW5kQ2h1bmsoZSl7cmV0dXJuIE1hdGguZmxvb3IoKGUtMSkvdGhpcy5jaHVua1NpemUpKzF9YWJvcnQoZSl7dGhpcy5hYm9ydGVkPSEwO3RoaXMucGRmTmV0d29ya1N0cmVhbT8uY2FuY2VsQWxsUmVxdWVzdHMoZSk7Zm9yKGNvbnN0IHQgb2YgdGhpcy5fcHJvbWlzZXNCeVJlcXVlc3QudmFsdWVzKCkpdC5yZWplY3QoZSl9fWNsYXNzIENvbG9yU3BhY2V7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmNvbnN0cnVjdG9yPT09Q29sb3JTcGFjZSYmdW5yZWFjaGFibGUoIkNhbm5vdCBpbml0aWFsaXplIENvbG9yU3BhY2UuIik7dGhpcy5uYW1lPWU7dGhpcy5udW1Db21wcz10fWdldFJnYihlLHQpe2NvbnN0IGk9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDMpO3RoaXMuZ2V0UmdiSXRlbShlLHQsaSwwKTtyZXR1cm4gaX1nZXRSZ2JJdGVtKGUsdCxpLGEpe3VucmVhY2hhYmxlKCJTaG91bGQgbm90IGNhbGwgQ29sb3JTcGFjZS5nZXRSZ2JJdGVtIil9Z2V0UmdiQnVmZmVyKGUsdCxpLGEscyxyLG4pe3VucmVhY2hhYmxlKCJTaG91bGQgbm90IGNhbGwgQ29sb3JTcGFjZS5nZXRSZ2JCdWZmZXIiKX1nZXRPdXRwdXRMZW5ndGgoZSx0KXt1bnJlYWNoYWJsZSgiU2hvdWxkIG5vdCBjYWxsIENvbG9yU3BhY2UuZ2V0T3V0cHV0TGVuZ3RoIil9aXNQYXNzdGhyb3VnaChlKXtyZXR1cm4hMX1pc0RlZmF1bHREZWNvZGUoZSx0KXtyZXR1cm4gQ29sb3JTcGFjZS5pc0RlZmF1bHREZWNvZGUoZSx0aGlzLm51bUNvbXBzKX1maWxsUmdiKGUsdCxpLGEscyxyLG4sbyxnKXtjb25zdCBjPXQqaTtsZXQgQz1udWxsO2NvbnN0IGg9MTw8bixsPWkhPT1zfHx0IT09YTtpZih0aGlzLmlzUGFzc3Rocm91Z2gobikpQz1vO2Vsc2UgaWYoMT09PXRoaXMubnVtQ29tcHMmJmM+aCYmIkRldmljZUdyYXkiIT09dGhpcy5uYW1lJiYiRGV2aWNlUkdCIiE9PXRoaXMubmFtZSl7Y29uc3QgdD1uPD04P25ldyBVaW50OEFycmF5KGgpOm5ldyBVaW50MTZBcnJheShoKTtmb3IobGV0IGU9MDtlPGg7ZSsrKXRbZV09ZTtjb25zdCBpPW5ldyBVaW50OENsYW1wZWRBcnJheSgzKmgpO3RoaXMuZ2V0UmdiQnVmZmVyKHQsMCxoLGksMCxuLDApO2lmKGwpe0M9bmV3IFVpbnQ4QXJyYXkoMypjKTtsZXQgZT0wO2ZvcihsZXQgdD0wO3Q8YzsrK3Qpe2NvbnN0IGE9MypvW3RdO0NbZSsrXT1pW2FdO0NbZSsrXT1pW2ErMV07Q1tlKytdPWlbYSsyXX19ZWxzZXtsZXQgdD0wO2ZvcihsZXQgYT0wO2E8YzsrK2Epe2NvbnN0IHM9MypvW2FdO2VbdCsrXT1pW3NdO2VbdCsrXT1pW3MrMV07ZVt0KytdPWlbcysyXTt0Kz1nfX19ZWxzZSBpZihsKXtDPW5ldyBVaW50OENsYW1wZWRBcnJheSgzKmMpO3RoaXMuZ2V0UmdiQnVmZmVyKG8sMCxjLEMsMCxuLDApfWVsc2UgdGhpcy5nZXRSZ2JCdWZmZXIobywwLGEqcixlLDAsbixnKTtpZihDKWlmKGwpIWZ1bmN0aW9uIHJlc2l6ZVJnYkltYWdlKGUsdCxpLGEscyxyLG4pe249MSE9PW4/MDpuO2NvbnN0IG89aS9zLGc9YS9yO2xldCBjLEM9MDtjb25zdCBoPW5ldyBVaW50MTZBcnJheShzKSxsPTMqaTtmb3IobGV0IGU9MDtlPHM7ZSsrKWhbZV09MypNYXRoLmZsb29yKGUqbyk7Zm9yKGxldCBpPTA7aTxyO2krKyl7Y29uc3QgYT1NYXRoLmZsb29yKGkqZykqbDtmb3IobGV0IGk9MDtpPHM7aSsrKXtjPWEraFtpXTt0W0MrK109ZVtjKytdO3RbQysrXT1lW2MrK107dFtDKytdPWVbYysrXTtDKz1ufX19KEMsZSx0LGksYSxzLGcpO2Vsc2V7bGV0IHQ9MCxpPTA7Zm9yKGxldCBzPTAsbj1hKnI7czxuO3MrKyl7ZVt0KytdPUNbaSsrXTtlW3QrK109Q1tpKytdO2VbdCsrXT1DW2krK107dCs9Z319fWdldCB1c2VzWmVyb1RvT25lUmFuZ2UoKXtyZXR1cm4gc2hhZG93KHRoaXMsInVzZXNaZXJvVG9PbmVSYW5nZSIsITApfXN0YXRpYyBfY2FjaGUoZSx0LGksYSl7aWYoIWkpdGhyb3cgbmV3IEVycm9yKCdDb2xvclNwYWNlLl9jYWNoZSAtIGV4cGVjdGVkICJsb2NhbENvbG9yU3BhY2VDYWNoZSIgYXJndW1lbnQuJyk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKCdDb2xvclNwYWNlLl9jYWNoZSAtIGV4cGVjdGVkICJwYXJzZWRDb2xvclNwYWNlIiBhcmd1bWVudC4nKTtsZXQgcyxyO2lmKGUgaW5zdGFuY2VvZiBSZWYpe3I9ZTtlPXQuZmV0Y2goZSl9ZSBpbnN0YW5jZW9mIE5hbWUmJihzPWUubmFtZSk7KHN8fHIpJiZpLnNldChzLHIsYSl9c3RhdGljIGdldENhY2hlZChlLHQsaSl7aWYoIWkpdGhyb3cgbmV3IEVycm9yKCdDb2xvclNwYWNlLmdldENhY2hlZCAtIGV4cGVjdGVkICJsb2NhbENvbG9yU3BhY2VDYWNoZSIgYXJndW1lbnQuJyk7aWYoZSBpbnN0YW5jZW9mIFJlZil7Y29uc3QgYT1pLmdldEJ5UmVmKGUpO2lmKGEpcmV0dXJuIGE7dHJ5e2U9dC5mZXRjaChlKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZX19aWYoZSBpbnN0YW5jZW9mIE5hbWUpe2NvbnN0IHQ9aS5nZXRCeU5hbWUoZS5uYW1lKTtpZih0KXJldHVybiB0fXJldHVybiBudWxsfXN0YXRpYyBhc3luYyBwYXJzZUFzeW5jKHtjczplLHhyZWY6dCxyZXNvdXJjZXM6aT1udWxsLHBkZkZ1bmN0aW9uRmFjdG9yeTphLGxvY2FsQ29sb3JTcGFjZUNhY2hlOnN9KXtjb25zdCByPXRoaXMuX3BhcnNlKGUsdCxpLGEpO3RoaXMuX2NhY2hlKGUsdCxzLHIpO3JldHVybiByfXN0YXRpYyBwYXJzZSh7Y3M6ZSx4cmVmOnQscmVzb3VyY2VzOmk9bnVsbCxwZGZGdW5jdGlvbkZhY3Rvcnk6YSxsb2NhbENvbG9yU3BhY2VDYWNoZTpzfSl7Y29uc3Qgcj10aGlzLmdldENhY2hlZChlLHQscyk7aWYocilyZXR1cm4gcjtjb25zdCBuPXRoaXMuX3BhcnNlKGUsdCxpLGEpO3RoaXMuX2NhY2hlKGUsdCxzLG4pO3JldHVybiBufXN0YXRpYyBfcGFyc2UoZSx0LGk9bnVsbCxhKXtpZigoZT10LmZldGNoSWZSZWYoZSkpaW5zdGFuY2VvZiBOYW1lKXN3aXRjaChlLm5hbWUpe2Nhc2UiRyI6Y2FzZSJEZXZpY2VHcmF5IjpyZXR1cm4gdGhpcy5zaW5nbGV0b25zLmdyYXk7Y2FzZSJSR0IiOmNhc2UiRGV2aWNlUkdCIjpyZXR1cm4gdGhpcy5zaW5nbGV0b25zLnJnYjtjYXNlIkNNWUsiOmNhc2UiRGV2aWNlQ01ZSyI6cmV0dXJuIHRoaXMuc2luZ2xldG9ucy5jbXlrO2Nhc2UiUGF0dGVybiI6cmV0dXJuIG5ldyBQYXR0ZXJuQ1MobnVsbCk7ZGVmYXVsdDppZihpIGluc3RhbmNlb2YgRGljdCl7Y29uc3Qgcz1pLmdldCgiQ29sb3JTcGFjZSIpO2lmKHMgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCByPXMuZ2V0KGUubmFtZSk7aWYocil7aWYociBpbnN0YW5jZW9mIE5hbWUpcmV0dXJuIHRoaXMuX3BhcnNlKHIsdCxpLGEpO2U9cjticmVha319fXRocm93IG5ldyBGb3JtYXRFcnJvcihgVW5yZWNvZ25pemVkIENvbG9yU3BhY2U6ICR7ZS5uYW1lfWApfWlmKEFycmF5LmlzQXJyYXkoZSkpe2NvbnN0IHM9dC5mZXRjaElmUmVmKGVbMF0pLm5hbWU7bGV0IHIsbixvLGcsYyxDO3N3aXRjaChzKXtjYXNlIkciOmNhc2UiRGV2aWNlR3JheSI6cmV0dXJuIHRoaXMuc2luZ2xldG9ucy5ncmF5O2Nhc2UiUkdCIjpjYXNlIkRldmljZVJHQiI6cmV0dXJuIHRoaXMuc2luZ2xldG9ucy5yZ2I7Y2FzZSJDTVlLIjpjYXNlIkRldmljZUNNWUsiOnJldHVybiB0aGlzLnNpbmdsZXRvbnMuY215aztjYXNlIkNhbEdyYXkiOnI9dC5mZXRjaElmUmVmKGVbMV0pO2c9ci5nZXRBcnJheSgiV2hpdGVQb2ludCIpO2M9ci5nZXRBcnJheSgiQmxhY2tQb2ludCIpO0M9ci5nZXQoIkdhbW1hIik7cmV0dXJuIG5ldyBDYWxHcmF5Q1MoZyxjLEMpO2Nhc2UiQ2FsUkdCIjpyPXQuZmV0Y2hJZlJlZihlWzFdKTtnPXIuZ2V0QXJyYXkoIldoaXRlUG9pbnQiKTtjPXIuZ2V0QXJyYXkoIkJsYWNrUG9pbnQiKTtDPXIuZ2V0QXJyYXkoIkdhbW1hIik7Y29uc3QgaD1yLmdldEFycmF5KCJNYXRyaXgiKTtyZXR1cm4gbmV3IENhbFJHQkNTKGcsYyxDLGgpO2Nhc2UiSUNDQmFzZWQiOmNvbnN0IGw9dC5mZXRjaElmUmVmKGVbMV0pLmRpY3Q7bj1sLmdldCgiTiIpO2NvbnN0IFE9bC5nZXQoIkFsdGVybmF0ZSIpO2lmKFEpe2NvbnN0IGU9dGhpcy5fcGFyc2UoUSx0LGksYSk7aWYoZS5udW1Db21wcz09PW4pcmV0dXJuIGU7d2FybigiSUNDQmFzZWQgY29sb3Igc3BhY2U6IElnbm9yaW5nIGluY29ycmVjdCAvQWx0ZXJuYXRlIGVudHJ5LiIpfWlmKDE9PT1uKXJldHVybiB0aGlzLnNpbmdsZXRvbnMuZ3JheTtpZigzPT09bilyZXR1cm4gdGhpcy5zaW5nbGV0b25zLnJnYjtpZig0PT09bilyZXR1cm4gdGhpcy5zaW5nbGV0b25zLmNteWs7YnJlYWs7Y2FzZSJQYXR0ZXJuIjpvPWVbMV18fG51bGw7byYmKG89dGhpcy5fcGFyc2Uobyx0LGksYSkpO3JldHVybiBuZXcgUGF0dGVybkNTKG8pO2Nhc2UiSSI6Y2FzZSJJbmRleGVkIjpvPXRoaXMuX3BhcnNlKGVbMV0sdCxpLGEpO2NvbnN0IEU9dC5mZXRjaElmUmVmKGVbMl0pKzEsdT10LmZldGNoSWZSZWYoZVszXSk7cmV0dXJuIG5ldyBJbmRleGVkQ1MobyxFLHUpO2Nhc2UiU2VwYXJhdGlvbiI6Y2FzZSJEZXZpY2VOIjpjb25zdCBkPXQuZmV0Y2hJZlJlZihlWzFdKTtuPUFycmF5LmlzQXJyYXkoZCk/ZC5sZW5ndGg6MTtvPXRoaXMuX3BhcnNlKGVbMl0sdCxpLGEpO2NvbnN0IGY9YS5jcmVhdGUoZVszXSk7cmV0dXJuIG5ldyBBbHRlcm5hdGVDUyhuLG8sZik7Y2FzZSJMYWIiOnI9dC5mZXRjaElmUmVmKGVbMV0pO2c9ci5nZXRBcnJheSgiV2hpdGVQb2ludCIpO2M9ci5nZXRBcnJheSgiQmxhY2tQb2ludCIpO2NvbnN0IHA9ci5nZXRBcnJheSgiUmFuZ2UiKTtyZXR1cm4gbmV3IExhYkNTKGcsYyxwKTtkZWZhdWx0OnRocm93IG5ldyBGb3JtYXRFcnJvcihgVW5pbXBsZW1lbnRlZCBDb2xvclNwYWNlIG9iamVjdDogJHtzfWApfX10aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVucmVjb2duaXplZCBDb2xvclNwYWNlIG9iamVjdDogJHtlfWApfXN0YXRpYyBpc0RlZmF1bHREZWNvZGUoZSx0KXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4hMDtpZigyKnQhPT1lLmxlbmd0aCl7d2FybigiVGhlIGRlY29kZSBtYXAgaXMgbm90IHRoZSBjb3JyZWN0IGxlbmd0aCIpO3JldHVybiEwfWZvcihsZXQgdD0wLGk9ZS5sZW5ndGg7dDxpO3QrPTIpaWYoMCE9PWVbdF18fDEhPT1lW3QrMV0pcmV0dXJuITE7cmV0dXJuITB9c3RhdGljIGdldCBzaW5nbGV0b25zKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJzaW5nbGV0b25zIix7Z2V0IGdyYXkoKXtyZXR1cm4gc2hhZG93KHRoaXMsImdyYXkiLG5ldyBEZXZpY2VHcmF5Q1MpfSxnZXQgcmdiKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJyZ2IiLG5ldyBEZXZpY2VSZ2JDUyl9LGdldCBjbXlrKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJjbXlrIixuZXcgRGV2aWNlQ215a0NTKX19KX19Y2xhc3MgQWx0ZXJuYXRlQ1MgZXh0ZW5kcyBDb2xvclNwYWNle2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcigiQWx0ZXJuYXRlIixlKTt0aGlzLmJhc2U9dDt0aGlzLnRpbnRGbj1pO3RoaXMudG1wQnVmPW5ldyBGbG9hdDMyQXJyYXkodC5udW1Db21wcyl9Z2V0UmdiSXRlbShlLHQsaSxhKXtjb25zdCBzPXRoaXMudG1wQnVmO3RoaXMudGludEZuKGUsdCxzLDApO3RoaXMuYmFzZS5nZXRSZ2JJdGVtKHMsMCxpLGEpfWdldFJnYkJ1ZmZlcihlLHQsaSxhLHMscixuKXtjb25zdCBvPXRoaXMudGludEZuLGc9dGhpcy5iYXNlLGM9MS8oKDE8PHIpLTEpLEM9Zy5udW1Db21wcyxoPWcudXNlc1plcm9Ub09uZVJhbmdlLGw9KGcuaXNQYXNzdGhyb3VnaCg4KXx8IWgpJiYwPT09bjtsZXQgUT1sP3M6MDtjb25zdCBFPWw/YTpuZXcgVWludDhDbGFtcGVkQXJyYXkoQyppKSx1PXRoaXMubnVtQ29tcHMsZD1uZXcgRmxvYXQzMkFycmF5KHUpLGY9bmV3IEZsb2F0MzJBcnJheShDKTtsZXQgcCxtO2ZvcihwPTA7cDxpO3ArKyl7Zm9yKG09MDttPHU7bSsrKWRbbV09ZVt0KytdKmM7byhkLDAsZiwwKTtpZihoKWZvcihtPTA7bTxDO20rKylFW1ErK109MjU1KmZbbV07ZWxzZXtnLmdldFJnYkl0ZW0oZiwwLEUsUSk7USs9Q319bHx8Zy5nZXRSZ2JCdWZmZXIoRSwwLGksYSxzLDgsbil9Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIHRoaXMuYmFzZS5nZXRPdXRwdXRMZW5ndGgoZSp0aGlzLmJhc2UubnVtQ29tcHMvdGhpcy5udW1Db21wcyx0KX19Y2xhc3MgUGF0dGVybkNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigiUGF0dGVybiIsbnVsbCk7dGhpcy5iYXNlPWV9aXNEZWZhdWx0RGVjb2RlKGUsdCl7dW5yZWFjaGFibGUoIlNob3VsZCBub3QgY2FsbCBQYXR0ZXJuQ1MuaXNEZWZhdWx0RGVjb2RlIil9fWNsYXNzIEluZGV4ZWRDUyBleHRlbmRzIENvbG9yU3BhY2V7Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKCJJbmRleGVkIiwxKTt0aGlzLmJhc2U9ZTt0aGlzLmhpZ2hWYWw9dDtjb25zdCBhPWUubnVtQ29tcHMqdDt0aGlzLmxvb2t1cD1uZXcgVWludDhBcnJheShhKTtpZihpIGluc3RhbmNlb2YgQmFzZVN0cmVhbSl7Y29uc3QgZT1pLmdldEJ5dGVzKGEpO3RoaXMubG9va3VwLnNldChlKX1lbHNle2lmKCJzdHJpbmciIT10eXBlb2YgaSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEluZGV4ZWRDUyAtIHVucmVjb2duaXplZCBsb29rdXAgdGFibGU6ICR7aX1gKTtmb3IobGV0IGU9MDtlPGE7KytlKXRoaXMubG9va3VwW2VdPTI1NSZpLmNoYXJDb2RlQXQoZSl9fWdldFJnYkl0ZW0oZSx0LGksYSl7Y29uc3Qgcz10aGlzLmJhc2UubnVtQ29tcHMscj1lW3RdKnM7dGhpcy5iYXNlLmdldFJnYkJ1ZmZlcih0aGlzLmxvb2t1cCxyLDEsaSxhLDgsMCl9Z2V0UmdiQnVmZmVyKGUsdCxpLGEscyxyLG4pe2NvbnN0IG89dGhpcy5iYXNlLGc9by5udW1Db21wcyxjPW8uZ2V0T3V0cHV0TGVuZ3RoKGcsbiksQz10aGlzLmxvb2t1cDtmb3IobGV0IHI9MDtyPGk7KytyKXtjb25zdCBpPWVbdCsrXSpnO28uZ2V0UmdiQnVmZmVyKEMsaSwxLGEscyw4LG4pO3MrPWN9fWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiB0aGlzLmJhc2UuZ2V0T3V0cHV0TGVuZ3RoKGUqdGhpcy5iYXNlLm51bUNvbXBzLHQpfWlzRGVmYXVsdERlY29kZShlLHQpe2lmKCFBcnJheS5pc0FycmF5KGUpKXJldHVybiEwO2lmKDIhPT1lLmxlbmd0aCl7d2FybigiRGVjb2RlIG1hcCBsZW5ndGggaXMgbm90IGNvcnJlY3QiKTtyZXR1cm4hMH1pZighTnVtYmVyLmlzSW50ZWdlcih0KXx8dDwxKXt3YXJuKCJCaXRzIHBlciBjb21wb25lbnQgaXMgbm90IGNvcnJlY3QiKTtyZXR1cm4hMH1yZXR1cm4gMD09PWVbMF0mJmVbMV09PT0oMTw8dCktMX19Y2xhc3MgRGV2aWNlR3JheUNTIGV4dGVuZHMgQ29sb3JTcGFjZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCJEZXZpY2VHcmF5IiwxKX1nZXRSZ2JJdGVtKGUsdCxpLGEpe2NvbnN0IHM9MjU1KmVbdF07aVthXT1pW2ErMV09aVthKzJdPXN9Z2V0UmdiQnVmZmVyKGUsdCxpLGEscyxyLG4pe2NvbnN0IG89MjU1LygoMTw8ciktMSk7bGV0IGc9dCxjPXM7Zm9yKGxldCB0PTA7dDxpOysrdCl7Y29uc3QgdD1vKmVbZysrXTthW2MrK109dDthW2MrK109dDthW2MrK109dDtjKz1ufX1nZXRPdXRwdXRMZW5ndGgoZSx0KXtyZXR1cm4gZSooMyt0KX19Y2xhc3MgRGV2aWNlUmdiQ1MgZXh0ZW5kcyBDb2xvclNwYWNle2NvbnN0cnVjdG9yKCl7c3VwZXIoIkRldmljZVJHQiIsMyl9Z2V0UmdiSXRlbShlLHQsaSxhKXtpW2FdPTI1NSplW3RdO2lbYSsxXT0yNTUqZVt0KzFdO2lbYSsyXT0yNTUqZVt0KzJdfWdldFJnYkJ1ZmZlcihlLHQsaSxhLHMscixuKXtpZig4PT09ciYmMD09PW4pe2Euc2V0KGUuc3ViYXJyYXkodCx0KzMqaSkscyk7cmV0dXJufWNvbnN0IG89MjU1LygoMTw8ciktMSk7bGV0IGc9dCxjPXM7Zm9yKGxldCB0PTA7dDxpOysrdCl7YVtjKytdPW8qZVtnKytdO2FbYysrXT1vKmVbZysrXTthW2MrK109byplW2crK107Yys9bn19Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIGUqKDMrdCkvM3wwfWlzUGFzc3Rocm91Z2goZSl7cmV0dXJuIDg9PT1lfX1jbGFzcyBEZXZpY2VDbXlrQ1MgZXh0ZW5kcyBDb2xvclNwYWNle2NvbnN0cnVjdG9yKCl7c3VwZXIoIkRldmljZUNNWUsiLDQpfSN0KGUsdCxpLGEscyl7Y29uc3Qgcj1lW3RdKmksbj1lW3QrMV0qaSxvPWVbdCsyXSppLGc9ZVt0KzNdKmk7YVtzXT0yNTUrciooLTQuMzg3MzMyMzg0NjA5OTg4KnIrNTQuNDg2MTUxOTQxODkxNzYqbisxOC44MjI5MDUwMjE2NTMwMipvKzIxMi4yNTY2MjQ1MTYzOTU4NSpnLTI4NS4yMzMxMDI2MTM3MDA0KStuKigxLjcxNDk3NjM0NzczNjIxMzQqbi01LjYwOTY3MzY5MDQwNDczMTUqbystMTcuODczODcwODYxNDE1NDQ0KmctNS40OTcwMDY0MjcxOTYzNjYpK28qKC0yLjUyMTczNDAxMzE2ODMwMzMqby0yMS4yNDg5MjMzMzczNTMwNzMqZysxNy41MTE5MjcwODQxODEzKStnKigtMjEuODYxMjIxNDc0NjM2MDUqZy0xODkuNDgxODA4MzU5MjI3NDcpO2FbcysxXT0yNTUrciooOC44NDEwNDE0MjIwMzYxNDkqcis2MC4xMTgwMjcwNDU1OTczNjYqbis2Ljg3MTQyNTU5MjA0OTAwNypvKzMxLjE1OTEwMDEzMDA1NTkyMipnLTc5LjI5NzA4NDQ4MTY1NDgpK24qKC0xNS4zMTAzNjEzMDY5Njc4MTcqbisxNy41NzUyNTEyNjExMDk0ODIqbysxMzEuMzUyNTA5MTI0OTM5NzYqZy0xOTAuOTQ1MzMwMjU4ODk1MSkrbyooNC40NDQzMzkxMDI4NTI3Mzkqbys5Ljg2MzI4NjE0OTM0MDUqZy0yNC44Njc0MTU4MjU1NTg3OCkrZyooLTIwLjczNzMyNTQ3MTE4MTAzNCpnLTE4Ny44MDQ1MzcwOTcxOTU3OCk7YVtzKzJdPTI1NStyKiguODg0MjUyMjQzMDAwMzI5NipyKzguMDc4Njc3NTAzMTEyOTI4Km4rMzAuODk5NzgzMDk3MDM3Mjkqby0uMjM4ODMyMzg2ODkxNzg5MzQqZy0xNC4xODM1NzY3OTk2NzMyODYpK24qKDEwLjQ5NTkzMjczNDMyMDcyKm4rNjMuMDIzNzg0OTQ3NTQwNTIqbys1MC42MDY5NTc2NTYzNjA3MzQqZy0xMTIuMjM4ODQyNTM3MTkyNDgpK28qKC4wMzI5NjA0MTExNDg3MzIxNypvKzExNS42MDM4NDQ0OTY0NjY0MSpnLTE5My41ODIwOTM1Njg2MTUwNSkrZyooLTIyLjMzODE2ODA3MzA5ODg2KmctMTgwLjEyNjEzOTc0NzA4MzY3KX1nZXRSZ2JJdGVtKGUsdCxpLGEpe3RoaXMuI3QoZSx0LDEsaSxhKX1nZXRSZ2JCdWZmZXIoZSx0LGksYSxzLHIsbil7Y29uc3Qgbz0xLygoMTw8ciktMSk7Zm9yKGxldCByPTA7cjxpO3IrKyl7dGhpcy4jdChlLHQsbyxhLHMpO3QrPTQ7cys9MytufX1nZXRPdXRwdXRMZW5ndGgoZSx0KXtyZXR1cm4gZS80KigzK3QpfDB9fWNsYXNzIENhbEdyYXlDUyBleHRlbmRzIENvbG9yU3BhY2V7Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKCJDYWxHcmF5IiwxKTtpZighZSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIldoaXRlUG9pbnQgbWlzc2luZyAtIHJlcXVpcmVkIGZvciBjb2xvciBzcGFjZSBDYWxHcmF5Iik7W3RoaXMuWFcsdGhpcy5ZVyx0aGlzLlpXXT1lO1t0aGlzLlhCLHRoaXMuWUIsdGhpcy5aQl09dHx8WzAsMCwwXTt0aGlzLkc9aXx8MTtpZih0aGlzLlhXPDB8fHRoaXMuWlc8MHx8MSE9PXRoaXMuWVcpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIFdoaXRlUG9pbnQgY29tcG9uZW50cyBmb3IgJHt0aGlzLm5hbWV9LCBubyBmYWxsYmFjayBhdmFpbGFibGVgKTtpZih0aGlzLlhCPDB8fHRoaXMuWUI8MHx8dGhpcy5aQjwwKXtpbmZvKGBJbnZhbGlkIEJsYWNrUG9pbnQgZm9yICR7dGhpcy5uYW1lfSwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHQuYCk7dGhpcy5YQj10aGlzLllCPXRoaXMuWkI9MH0wPT09dGhpcy5YQiYmMD09PXRoaXMuWUImJjA9PT10aGlzLlpCfHx3YXJuKGAke3RoaXMubmFtZX0sIEJsYWNrUG9pbnQ6IFhCOiAke3RoaXMuWEJ9LCBZQjogJHt0aGlzLllCfSwgWkI6ICR7dGhpcy5aQn0sIG9ubHkgZGVmYXVsdCB2YWx1ZXMgYXJlIHN1cHBvcnRlZC5gKTtpZih0aGlzLkc8MSl7aW5mbyhgSW52YWxpZCBHYW1tYTogJHt0aGlzLkd9IGZvciAke3RoaXMubmFtZX0sIGZhbGxpbmcgYmFjayB0byBkZWZhdWx0LmApO3RoaXMuRz0xfX0jdChlLHQsaSxhLHMpe2NvbnN0IHI9KGVbdF0qcykqKnRoaXMuRyxuPXRoaXMuWVcqcixvPU1hdGgubWF4KDI5NS44Km4qKi4zMzMzMzMzMzMzMzMzMzMzLTQwLjgsMCk7aVthXT1vO2lbYSsxXT1vO2lbYSsyXT1vfWdldFJnYkl0ZW0oZSx0LGksYSl7dGhpcy4jdChlLHQsaSxhLDEpfWdldFJnYkJ1ZmZlcihlLHQsaSxhLHMscixuKXtjb25zdCBvPTEvKCgxPDxyKS0xKTtmb3IobGV0IHI9MDtyPGk7KytyKXt0aGlzLiN0KGUsdCxhLHMsbyk7dCs9MTtzKz0zK259fWdldE91dHB1dExlbmd0aChlLHQpe3JldHVybiBlKigzK3QpfX1jbGFzcyBDYWxSR0JDUyBleHRlbmRzIENvbG9yU3BhY2V7c3RhdGljI2k9bmV3IEZsb2F0MzJBcnJheShbLjg5NTEsLjI2NjQsLS4xNjE0LC0uNzUwMiwxLjcxMzUsLjAzNjcsLjAzODksLS4wNjg1LDEuMDI5Nl0pO3N0YXRpYyNhPW5ldyBGbG9hdDMyQXJyYXkoWy45ODY5OTI5LC0uMTQ3MDU0MywuMTU5OTYyNywuNDMyMzA1MywuNTE4MzYwMywuMDQ5MjkxMiwtLjAwODUyODcsLjA0MDA0MjgsLjk2ODQ4NjddKTtzdGF0aWMjcz1uZXcgRmxvYXQzMkFycmF5KFszLjI0MDQ1NDIsLTEuNTM3MTM4NSwtLjQ5ODUzMTQsLS45NjkyNjYsMS44NzYwMTA4LC4wNDE1NTYsLjA1NTY0MzQsLS4yMDQwMjU5LDEuMDU3MjI1Ml0pO3N0YXRpYyNyPW5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSk7c3RhdGljI249bmV3IEZsb2F0MzJBcnJheSgzKTtzdGF0aWMjbz1uZXcgRmxvYXQzMkFycmF5KDMpO3N0YXRpYyNnPW5ldyBGbG9hdDMyQXJyYXkoMyk7c3RhdGljI0k9KDI0LzExNikqKjMvODtjb25zdHJ1Y3RvcihlLHQsaSxhKXtzdXBlcigiQ2FsUkdCIiwzKTtpZighZSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIldoaXRlUG9pbnQgbWlzc2luZyAtIHJlcXVpcmVkIGZvciBjb2xvciBzcGFjZSBDYWxSR0IiKTtjb25zdFtzLHIsbl09dGhpcy53aGl0ZVBvaW50PWUsW28sZyxjXT10aGlzLmJsYWNrUG9pbnQ9dHx8bmV3IEZsb2F0MzJBcnJheSgzKTtbdGhpcy5HUix0aGlzLkdHLHRoaXMuR0JdPWl8fG5ldyBGbG9hdDMyQXJyYXkoWzEsMSwxXSk7W3RoaXMuTVhBLHRoaXMuTVlBLHRoaXMuTVpBLHRoaXMuTVhCLHRoaXMuTVlCLHRoaXMuTVpCLHRoaXMuTVhDLHRoaXMuTVlDLHRoaXMuTVpDXT1hfHxuZXcgRmxvYXQzMkFycmF5KFsxLDAsMCwwLDEsMCwwLDAsMV0pO2lmKHM8MHx8bjwwfHwxIT09cil0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgV2hpdGVQb2ludCBjb21wb25lbnRzIGZvciAke3RoaXMubmFtZX0sIG5vIGZhbGxiYWNrIGF2YWlsYWJsZWApO2lmKG88MHx8ZzwwfHxjPDApe2luZm8oYEludmFsaWQgQmxhY2tQb2ludCBmb3IgJHt0aGlzLm5hbWV9IFske299LCAke2d9LCAke2N9XSwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHQuYCk7dGhpcy5ibGFja1BvaW50PW5ldyBGbG9hdDMyQXJyYXkoMyl9aWYodGhpcy5HUjwwfHx0aGlzLkdHPDB8fHRoaXMuR0I8MCl7aW5mbyhgSW52YWxpZCBHYW1tYSBbJHt0aGlzLkdSfSwgJHt0aGlzLkdHfSwgJHt0aGlzLkdCfV0gZm9yICR7dGhpcy5uYW1lfSwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHQuYCk7dGhpcy5HUj10aGlzLkdHPXRoaXMuR0I9MX19I2MoZSx0LGkpe2lbMF09ZVswXSp0WzBdK2VbMV0qdFsxXStlWzJdKnRbMl07aVsxXT1lWzNdKnRbMF0rZVs0XSp0WzFdK2VbNV0qdFsyXTtpWzJdPWVbNl0qdFswXStlWzddKnRbMV0rZVs4XSp0WzJdfSNDKGUsdCxpKXtpWzBdPTEqdFswXS9lWzBdO2lbMV09MSp0WzFdL2VbMV07aVsyXT0xKnRbMl0vZVsyXX0jaChlLHQsaSl7aVswXT0uOTUwNDcqdFswXS9lWzBdO2lbMV09MSp0WzFdL2VbMV07aVsyXT0xLjA4ODgzKnRbMl0vZVsyXX0jbChlKXtyZXR1cm4gZTw9LjAwMzEzMDg/dGhpcy4jQigwLDEsMTIuOTIqZSk6ZT49Ljk5NTU0NTI1PzE6dGhpcy4jQigwLDEsMS4wNTUqZSoqKDEvMi40KS0uMDU1KX0jQihlLHQsaSl7cmV0dXJuIE1hdGgubWF4KGUsTWF0aC5taW4odCxpKSl9I1EoZSl7cmV0dXJuIGU8MD8tdGhpcy4jUSgtZSk6ZT44PygoZSsxNikvMTE2KSoqMzplKkNhbFJHQkNTLiNJfSNFKGUsdCxpKXtpZigwPT09ZVswXSYmMD09PWVbMV0mJjA9PT1lWzJdKXtpWzBdPXRbMF07aVsxXT10WzFdO2lbMl09dFsyXTtyZXR1cm59Y29uc3QgYT10aGlzLiNRKDApLHM9KDEtYSkvKDEtdGhpcy4jUShlWzBdKSkscj0xLXMsbj0oMS1hKS8oMS10aGlzLiNRKGVbMV0pKSxvPTEtbixnPSgxLWEpLygxLXRoaXMuI1EoZVsyXSkpLGM9MS1nO2lbMF09dFswXSpzK3I7aVsxXT10WzFdKm4rbztpWzJdPXRbMl0qZytjfSN1KGUsdCxpKXtpZigxPT09ZVswXSYmMT09PWVbMl0pe2lbMF09dFswXTtpWzFdPXRbMV07aVsyXT10WzJdO3JldHVybn1jb25zdCBhPWk7dGhpcy4jYyhDYWxSR0JDUy4jaSx0LGEpO2NvbnN0IHM9Q2FsUkdCQ1MuI247dGhpcy4jQyhlLGEscyk7dGhpcy4jYyhDYWxSR0JDUy4jYSxzLGkpfSNkKGUsdCxpKXtjb25zdCBhPWk7dGhpcy4jYyhDYWxSR0JDUy4jaSx0LGEpO2NvbnN0IHM9Q2FsUkdCQ1MuI247dGhpcy4jaChlLGEscyk7dGhpcy4jYyhDYWxSR0JDUy4jYSxzLGkpfSN0KGUsdCxpLGEscyl7Y29uc3Qgcj10aGlzLiNCKDAsMSxlW3RdKnMpLG49dGhpcy4jQigwLDEsZVt0KzFdKnMpLG89dGhpcy4jQigwLDEsZVt0KzJdKnMpLGc9MT09PXI/MTpyKip0aGlzLkdSLGM9MT09PW4/MTpuKip0aGlzLkdHLEM9MT09PW8/MTpvKip0aGlzLkdCLGg9dGhpcy5NWEEqZyt0aGlzLk1YQipjK3RoaXMuTVhDKkMsbD10aGlzLk1ZQSpnK3RoaXMuTVlCKmMrdGhpcy5NWUMqQyxRPXRoaXMuTVpBKmcrdGhpcy5NWkIqYyt0aGlzLk1aQypDLEU9Q2FsUkdCQ1MuI287RVswXT1oO0VbMV09bDtFWzJdPVE7Y29uc3QgdT1DYWxSR0JDUy4jZzt0aGlzLiN1KHRoaXMud2hpdGVQb2ludCxFLHUpO2NvbnN0IGQ9Q2FsUkdCQ1MuI287dGhpcy4jRSh0aGlzLmJsYWNrUG9pbnQsdSxkKTtjb25zdCBmPUNhbFJHQkNTLiNnO3RoaXMuI2QoQ2FsUkdCQ1MuI3IsZCxmKTtjb25zdCBwPUNhbFJHQkNTLiNvO3RoaXMuI2MoQ2FsUkdCQ1MuI3MsZixwKTtpW2FdPTI1NSp0aGlzLiNsKHBbMF0pO2lbYSsxXT0yNTUqdGhpcy4jbChwWzFdKTtpW2ErMl09MjU1KnRoaXMuI2wocFsyXSl9Z2V0UmdiSXRlbShlLHQsaSxhKXt0aGlzLiN0KGUsdCxpLGEsMSl9Z2V0UmdiQnVmZmVyKGUsdCxpLGEscyxyLG4pe2NvbnN0IG89MS8oKDE8PHIpLTEpO2ZvcihsZXQgcj0wO3I8aTsrK3Ipe3RoaXMuI3QoZSx0LGEscyxvKTt0Kz0zO3MrPTMrbn19Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIGUqKDMrdCkvM3wwfX1jbGFzcyBMYWJDUyBleHRlbmRzIENvbG9yU3BhY2V7Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKCJMYWIiLDMpO2lmKCFlKXRocm93IG5ldyBGb3JtYXRFcnJvcigiV2hpdGVQb2ludCBtaXNzaW5nIC0gcmVxdWlyZWQgZm9yIGNvbG9yIHNwYWNlIExhYiIpO1t0aGlzLlhXLHRoaXMuWVcsdGhpcy5aV109ZTtbdGhpcy5hbWluLHRoaXMuYW1heCx0aGlzLmJtaW4sdGhpcy5ibWF4XT1pfHxbLTEwMCwxMDAsLTEwMCwxMDBdO1t0aGlzLlhCLHRoaXMuWUIsdGhpcy5aQl09dHx8WzAsMCwwXTtpZih0aGlzLlhXPDB8fHRoaXMuWlc8MHx8MSE9PXRoaXMuWVcpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFdoaXRlUG9pbnQgY29tcG9uZW50cywgbm8gZmFsbGJhY2sgYXZhaWxhYmxlIik7aWYodGhpcy5YQjwwfHx0aGlzLllCPDB8fHRoaXMuWkI8MCl7aW5mbygiSW52YWxpZCBCbGFja1BvaW50LCBmYWxsaW5nIGJhY2sgdG8gZGVmYXVsdCIpO3RoaXMuWEI9dGhpcy5ZQj10aGlzLlpCPTB9aWYodGhpcy5hbWluPnRoaXMuYW1heHx8dGhpcy5ibWluPnRoaXMuYm1heCl7aW5mbygiSW52YWxpZCBSYW5nZSwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHRzIik7dGhpcy5hbWluPS0xMDA7dGhpcy5hbWF4PTEwMDt0aGlzLmJtaW49LTEwMDt0aGlzLmJtYXg9MTAwfX0jZihlKXtyZXR1cm4gZT49Ni8yOT9lKiozOjEwOC84NDEqKGUtNC8yOSl9I3AoZSx0LGksYSl7cmV0dXJuIGkrZSooYS1pKS90fSN0KGUsdCxpLGEscyl7bGV0IHI9ZVt0XSxuPWVbdCsxXSxvPWVbdCsyXTtpZighMSE9PWkpe3I9dGhpcy4jcChyLGksMCwxMDApO249dGhpcy4jcChuLGksdGhpcy5hbWluLHRoaXMuYW1heCk7bz10aGlzLiNwKG8saSx0aGlzLmJtaW4sdGhpcy5ibWF4KX1uPnRoaXMuYW1heD9uPXRoaXMuYW1heDpuPHRoaXMuYW1pbiYmKG49dGhpcy5hbWluKTtvPnRoaXMuYm1heD9vPXRoaXMuYm1heDpvPHRoaXMuYm1pbiYmKG89dGhpcy5ibWluKTtjb25zdCBnPShyKzE2KS8xMTYsYz1nK24vNTAwLEM9Zy1vLzIwMCxoPXRoaXMuWFcqdGhpcy4jZihjKSxsPXRoaXMuWVcqdGhpcy4jZihnKSxRPXRoaXMuWlcqdGhpcy4jZihDKTtsZXQgRSx1LGQ7aWYodGhpcy5aVzwxKXtFPTMuMTMzOSpoKy0xLjYxNypsKy0uNDkwNipRO3U9LS45Nzg1KmgrMS45MTYqbCsuMDMzMypRO2Q9LjA3MipoKy0uMjI5KmwrMS40MDU3KlF9ZWxzZXtFPTMuMjQwNipoKy0xLjUzNzIqbCstLjQ5ODYqUTt1PS0uOTY4OSpoKzEuODc1OCpsKy4wNDE1KlE7ZD0uMDU1NypoKy0uMjA0KmwrMS4wNTcqUX1hW3NdPTI1NSpNYXRoLnNxcnQoRSk7YVtzKzFdPTI1NSpNYXRoLnNxcnQodSk7YVtzKzJdPTI1NSpNYXRoLnNxcnQoZCl9Z2V0UmdiSXRlbShlLHQsaSxhKXt0aGlzLiN0KGUsdCwhMSxpLGEpfWdldFJnYkJ1ZmZlcihlLHQsaSxhLHMscixuKXtjb25zdCBvPSgxPDxyKS0xO2ZvcihsZXQgcj0wO3I8aTtyKyspe3RoaXMuI3QoZSx0LG8sYSxzKTt0Kz0zO3MrPTMrbn19Z2V0T3V0cHV0TGVuZ3RoKGUsdCl7cmV0dXJuIGUqKDMrdCkvM3wwfWlzRGVmYXVsdERlY29kZShlLHQpe3JldHVybiEwfWdldCB1c2VzWmVyb1RvT25lUmFuZ2UoKXtyZXR1cm4gc2hhZG93KHRoaXMsInVzZXNaZXJvVG9PbmVSYW5nZSIsITEpfX1mdW5jdGlvbiBoZXhUb0ludChlLHQpe2xldCBpPTA7Zm9yKGxldCBhPTA7YTw9dDthKyspaT1pPDw4fGVbYV07cmV0dXJuIGk+Pj4wfWZ1bmN0aW9uIGhleFRvU3RyKGUsdCl7cmV0dXJuIDE9PT10P1N0cmluZy5mcm9tQ2hhckNvZGUoZVswXSxlWzFdKTozPT09dD9TdHJpbmcuZnJvbUNoYXJDb2RlKGVbMF0sZVsxXSxlWzJdLGVbM10pOlN0cmluZy5mcm9tQ2hhckNvZGUoLi4uZS5zdWJhcnJheSgwLHQrMSkpfWZ1bmN0aW9uIGFkZEhleChlLHQsaSl7bGV0IGE9MDtmb3IobGV0IHM9aTtzPj0wO3MtLSl7YSs9ZVtzXSt0W3NdO2Vbc109MjU1JmE7YT4+PTh9fWZ1bmN0aW9uIGluY0hleChlLHQpe2xldCBpPTE7Zm9yKGxldCBhPXQ7YT49MCYmaT4wO2EtLSl7aSs9ZVthXTtlW2FdPTI1NSZpO2k+Pj04fX1jb25zdCBrdD0xNjtjbGFzcyBCaW5hcnlDTWFwU3RyZWFte2NvbnN0cnVjdG9yKGUpe3RoaXMuYnVmZmVyPWU7dGhpcy5wb3M9MDt0aGlzLmVuZD1lLmxlbmd0aDt0aGlzLnRtcEJ1Zj1uZXcgVWludDhBcnJheSgxOSl9cmVhZEJ5dGUoKXtyZXR1cm4gdGhpcy5wb3M+PXRoaXMuZW5kPy0xOnRoaXMuYnVmZmVyW3RoaXMucG9zKytdfXJlYWROdW1iZXIoKXtsZXQgZSx0PTA7ZG97Y29uc3QgaT10aGlzLnJlYWRCeXRlKCk7aWYoaTwwKXRocm93IG5ldyBGb3JtYXRFcnJvcigidW5leHBlY3RlZCBFT0YgaW4gYmNtYXAiKTtlPSEoMTI4JmkpO3Q9dDw8N3wxMjcmaX13aGlsZSghZSk7cmV0dXJuIHR9cmVhZFNpZ25lZCgpe2NvbnN0IGU9dGhpcy5yZWFkTnVtYmVyKCk7cmV0dXJuIDEmZT9+KGU+Pj4xKTplPj4+MX1yZWFkSGV4KGUsdCl7ZS5zZXQodGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MsdGhpcy5wb3MrdCsxKSk7dGhpcy5wb3MrPXQrMX1yZWFkSGV4TnVtYmVyKGUsdCl7bGV0IGk7Y29uc3QgYT10aGlzLnRtcEJ1ZjtsZXQgcz0wO2Rve2NvbnN0IGU9dGhpcy5yZWFkQnl0ZSgpO2lmKGU8MCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoInVuZXhwZWN0ZWQgRU9GIGluIGJjbWFwIik7aT0hKDEyOCZlKTthW3MrK109MTI3JmV9d2hpbGUoIWkpO2xldCByPXQsbj0wLG89MDtmb3IoO3I+PTA7KXtmb3IoO288OCYmYS5sZW5ndGg+MDspe258PWFbLS1zXTw8bztvKz03fWVbcl09MjU1Jm47ci0tO24+Pj04O28tPTh9fXJlYWRIZXhTaWduZWQoZSx0KXt0aGlzLnJlYWRIZXhOdW1iZXIoZSx0KTtjb25zdCBpPTEmZVt0XT8yNTU6MDtsZXQgYT0wO2ZvcihsZXQgcz0wO3M8PXQ7cysrKXthPSgxJmEpPDw4fGVbc107ZVtzXT1hPj4xXml9fXJlYWRTdHJpbmcoKXtjb25zdCBlPXRoaXMucmVhZE51bWJlcigpLHQ9bmV3IEFycmF5KGUpO2ZvcihsZXQgaT0wO2k8ZTtpKyspdFtpXT10aGlzLnJlYWROdW1iZXIoKTtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi50KX19Y2xhc3MgQmluYXJ5Q01hcFJlYWRlcnthc3luYyBwcm9jZXNzKGUsdCxpKXtjb25zdCBhPW5ldyBCaW5hcnlDTWFwU3RyZWFtKGUpLHM9YS5yZWFkQnl0ZSgpO3QudmVydGljYWw9ISEoMSZzKTtsZXQgcj1udWxsO2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkoa3QpLG89bmV3IFVpbnQ4QXJyYXkoa3QpLGc9bmV3IFVpbnQ4QXJyYXkoa3QpLGM9bmV3IFVpbnQ4QXJyYXkoa3QpLEM9bmV3IFVpbnQ4QXJyYXkoa3QpO2xldCBoLGw7Zm9yKDsobD1hLnJlYWRCeXRlKCkpPj0wOyl7Y29uc3QgZT1sPj41O2lmKDc9PT1lKXtzd2l0Y2goMzEmbCl7Y2FzZSAwOmEucmVhZFN0cmluZygpO2JyZWFrO2Nhc2UgMTpyPWEucmVhZFN0cmluZygpfWNvbnRpbnVlfWNvbnN0IGk9ISEoMTYmbCkscz0xNSZsO2lmKHMrMT5rdCl0aHJvdyBuZXcgRXJyb3IoIkJpbmFyeUNNYXBSZWFkZXIucHJvY2VzczogSW52YWxpZCBkYXRhU2l6ZS4iKTtjb25zdCBRPTEsRT1hLnJlYWROdW1iZXIoKTtzd2l0Y2goZSl7Y2FzZSAwOmEucmVhZEhleChuLHMpO2EucmVhZEhleE51bWJlcihvLHMpO2FkZEhleChvLG4scyk7dC5hZGRDb2Rlc3BhY2VSYW5nZShzKzEsaGV4VG9JbnQobixzKSxoZXhUb0ludChvLHMpKTtmb3IobGV0IGU9MTtlPEU7ZSsrKXtpbmNIZXgobyxzKTthLnJlYWRIZXhOdW1iZXIobixzKTthZGRIZXgobixvLHMpO2EucmVhZEhleE51bWJlcihvLHMpO2FkZEhleChvLG4scyk7dC5hZGRDb2Rlc3BhY2VSYW5nZShzKzEsaGV4VG9JbnQobixzKSxoZXhUb0ludChvLHMpKX1icmVhaztjYXNlIDE6YS5yZWFkSGV4KG4scyk7YS5yZWFkSGV4TnVtYmVyKG8scyk7YWRkSGV4KG8sbixzKTthLnJlYWROdW1iZXIoKTtmb3IobGV0IGU9MTtlPEU7ZSsrKXtpbmNIZXgobyxzKTthLnJlYWRIZXhOdW1iZXIobixzKTthZGRIZXgobixvLHMpO2EucmVhZEhleE51bWJlcihvLHMpO2FkZEhleChvLG4scyk7YS5yZWFkTnVtYmVyKCl9YnJlYWs7Y2FzZSAyOmEucmVhZEhleChnLHMpO2g9YS5yZWFkTnVtYmVyKCk7dC5tYXBPbmUoaGV4VG9JbnQoZyxzKSxoKTtmb3IobGV0IGU9MTtlPEU7ZSsrKXtpbmNIZXgoZyxzKTtpZighaSl7YS5yZWFkSGV4TnVtYmVyKEMscyk7YWRkSGV4KGcsQyxzKX1oPWEucmVhZFNpZ25lZCgpKyhoKzEpO3QubWFwT25lKGhleFRvSW50KGcscyksaCl9YnJlYWs7Y2FzZSAzOmEucmVhZEhleChuLHMpO2EucmVhZEhleE51bWJlcihvLHMpO2FkZEhleChvLG4scyk7aD1hLnJlYWROdW1iZXIoKTt0Lm1hcENpZFJhbmdlKGhleFRvSW50KG4scyksaGV4VG9JbnQobyxzKSxoKTtmb3IobGV0IGU9MTtlPEU7ZSsrKXtpbmNIZXgobyxzKTtpZihpKW4uc2V0KG8pO2Vsc2V7YS5yZWFkSGV4TnVtYmVyKG4scyk7YWRkSGV4KG4sbyxzKX1hLnJlYWRIZXhOdW1iZXIobyxzKTthZGRIZXgobyxuLHMpO2g9YS5yZWFkTnVtYmVyKCk7dC5tYXBDaWRSYW5nZShoZXhUb0ludChuLHMpLGhleFRvSW50KG8scyksaCl9YnJlYWs7Y2FzZSA0OmEucmVhZEhleChnLFEpO2EucmVhZEhleChjLHMpO3QubWFwT25lKGhleFRvSW50KGcsUSksaGV4VG9TdHIoYyxzKSk7Zm9yKGxldCBlPTE7ZTxFO2UrKyl7aW5jSGV4KGcsUSk7aWYoIWkpe2EucmVhZEhleE51bWJlcihDLFEpO2FkZEhleChnLEMsUSl9aW5jSGV4KGMscyk7YS5yZWFkSGV4U2lnbmVkKEMscyk7YWRkSGV4KGMsQyxzKTt0Lm1hcE9uZShoZXhUb0ludChnLFEpLGhleFRvU3RyKGMscykpfWJyZWFrO2Nhc2UgNTphLnJlYWRIZXgobixRKTthLnJlYWRIZXhOdW1iZXIobyxRKTthZGRIZXgobyxuLFEpO2EucmVhZEhleChjLHMpO3QubWFwQmZSYW5nZShoZXhUb0ludChuLFEpLGhleFRvSW50KG8sUSksaGV4VG9TdHIoYyxzKSk7Zm9yKGxldCBlPTE7ZTxFO2UrKyl7aW5jSGV4KG8sUSk7aWYoaSluLnNldChvKTtlbHNle2EucmVhZEhleE51bWJlcihuLFEpO2FkZEhleChuLG8sUSl9YS5yZWFkSGV4TnVtYmVyKG8sUSk7YWRkSGV4KG8sbixRKTthLnJlYWRIZXgoYyxzKTt0Lm1hcEJmUmFuZ2UoaGV4VG9JbnQobixRKSxoZXhUb0ludChvLFEpLGhleFRvU3RyKGMscykpfWJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBCaW5hcnlDTWFwUmVhZGVyLnByb2Nlc3MgLSB1bmtub3duIHR5cGU6ICR7ZX1gKX19cmV0dXJuIHI/aShyKTp0fX1jb25zdCBOdD1uZXcgVWludDhBcnJheSgwKTtjbGFzcyBEZWNvZGVTdHJlYW0gZXh0ZW5kcyBCYXNlU3RyZWFte2NvbnN0cnVjdG9yKGUpe3N1cGVyKCk7dGhpcy5fcmF3TWluQnVmZmVyTGVuZ3RoPWV8fDA7dGhpcy5wb3M9MDt0aGlzLmJ1ZmZlckxlbmd0aD0wO3RoaXMuZW9mPSExO3RoaXMuYnVmZmVyPU50O3RoaXMubWluQnVmZmVyTGVuZ3RoPTUxMjtpZihlKWZvcig7dGhpcy5taW5CdWZmZXJMZW5ndGg8ZTspdGhpcy5taW5CdWZmZXJMZW5ndGgqPTJ9Z2V0IGlzRW1wdHkoKXtmb3IoOyF0aGlzLmVvZiYmMD09PXRoaXMuYnVmZmVyTGVuZ3RoOyl0aGlzLnJlYWRCbG9jaygpO3JldHVybiAwPT09dGhpcy5idWZmZXJMZW5ndGh9ZW5zdXJlQnVmZmVyKGUpe2NvbnN0IHQ9dGhpcy5idWZmZXI7aWYoZTw9dC5ieXRlTGVuZ3RoKXJldHVybiB0O2xldCBpPXRoaXMubWluQnVmZmVyTGVuZ3RoO2Zvcig7aTxlOylpKj0yO2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkoaSk7YS5zZXQodCk7cmV0dXJuIHRoaXMuYnVmZmVyPWF9Z2V0Qnl0ZSgpe2NvbnN0IGU9dGhpcy5wb3M7Zm9yKDt0aGlzLmJ1ZmZlckxlbmd0aDw9ZTspe2lmKHRoaXMuZW9mKXJldHVybi0xO3RoaXMucmVhZEJsb2NrKCl9cmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMucG9zKytdfWdldEJ5dGVzKGUsdD0hMSl7Y29uc3QgaT10aGlzLnBvcztsZXQgYTtpZihlKXt0aGlzLmVuc3VyZUJ1ZmZlcihpK2UpO2E9aStlO2Zvcig7IXRoaXMuZW9mJiZ0aGlzLmJ1ZmZlckxlbmd0aDxhOyl0aGlzLnJlYWRCbG9jayh0KTtjb25zdCBzPXRoaXMuYnVmZmVyTGVuZ3RoO2E+cyYmKGE9cyl9ZWxzZXtmb3IoOyF0aGlzLmVvZjspdGhpcy5yZWFkQmxvY2sodCk7YT10aGlzLmJ1ZmZlckxlbmd0aH10aGlzLnBvcz1hO3JldHVybiB0aGlzLmJ1ZmZlci5zdWJhcnJheShpLGEpfXJlc2V0KCl7dGhpcy5wb3M9MH1tYWtlU3ViU3RyZWFtKGUsdCxpPW51bGwpe2lmKHZvaWQgMD09PXQpZm9yKDshdGhpcy5lb2Y7KXRoaXMucmVhZEJsb2NrKCk7ZWxzZXtjb25zdCBpPWUrdDtmb3IoO3RoaXMuYnVmZmVyTGVuZ3RoPD1pJiYhdGhpcy5lb2Y7KXRoaXMucmVhZEJsb2NrKCl9cmV0dXJuIG5ldyBTdHJlYW0odGhpcy5idWZmZXIsZSx0LGkpfWdldEJhc2VTdHJlYW1zKCl7cmV0dXJuIHRoaXMuc3RyP3RoaXMuc3RyLmdldEJhc2VTdHJlYW1zKCk6bnVsbH19Y2xhc3MgU3RyZWFtc1NlcXVlbmNlU3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdD1udWxsKXtsZXQgaT0wO2Zvcihjb25zdCB0IG9mIGUpaSs9dCBpbnN0YW5jZW9mIERlY29kZVN0cmVhbT90Ll9yYXdNaW5CdWZmZXJMZW5ndGg6dC5sZW5ndGg7c3VwZXIoaSk7dGhpcy5zdHJlYW1zPWU7dGhpcy5fb25FcnJvcj10fXJlYWRCbG9jaygpe2NvbnN0IGU9dGhpcy5zdHJlYW1zO2lmKDA9PT1lLmxlbmd0aCl7dGhpcy5lb2Y9ITA7cmV0dXJufWNvbnN0IHQ9ZS5zaGlmdCgpO2xldCBpO3RyeXtpPXQuZ2V0Qnl0ZXMoKX1jYXRjaChlKXtpZih0aGlzLl9vbkVycm9yKXt0aGlzLl9vbkVycm9yKGUsdC5kaWN0Py5vYmpJZCk7cmV0dXJufXRocm93IGV9Y29uc3QgYT10aGlzLmJ1ZmZlckxlbmd0aCxzPWEraS5sZW5ndGg7dGhpcy5lbnN1cmVCdWZmZXIocykuc2V0KGksYSk7dGhpcy5idWZmZXJMZW5ndGg9c31nZXRCYXNlU3RyZWFtcygpe2NvbnN0IGU9W107Zm9yKGNvbnN0IHQgb2YgdGhpcy5zdHJlYW1zKXtjb25zdCBpPXQuZ2V0QmFzZVN0cmVhbXMoKTtpJiZlLnB1c2goLi4uaSl9cmV0dXJuIGUubGVuZ3RoPjA/ZTpudWxsfX1jbGFzcyBBc2NpaTg1U3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCl7dCYmKHQqPS44KTtzdXBlcih0KTt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7dGhpcy5pbnB1dD1uZXcgVWludDhBcnJheSg1KX1yZWFkQmxvY2soKXtjb25zdCBlPXRoaXMuc3RyO2xldCB0PWUuZ2V0Qnl0ZSgpO2Zvcig7aXNXaGl0ZVNwYWNlKHQpOyl0PWUuZ2V0Qnl0ZSgpO2lmKC0xPT09dHx8MTI2PT09dCl7dGhpcy5lb2Y9ITA7cmV0dXJufWNvbnN0IGk9dGhpcy5idWZmZXJMZW5ndGg7bGV0IGEscztpZigxMjI9PT10KXthPXRoaXMuZW5zdXJlQnVmZmVyKGkrNCk7Zm9yKHM9MDtzPDQ7KytzKWFbaStzXT0wO3RoaXMuYnVmZmVyTGVuZ3RoKz00fWVsc2V7Y29uc3Qgcj10aGlzLmlucHV0O3JbMF09dDtmb3Iocz0xO3M8NTsrK3Mpe3Q9ZS5nZXRCeXRlKCk7Zm9yKDtpc1doaXRlU3BhY2UodCk7KXQ9ZS5nZXRCeXRlKCk7cltzXT10O2lmKC0xPT09dHx8MTI2PT09dClicmVha31hPXRoaXMuZW5zdXJlQnVmZmVyKGkrcy0xKTt0aGlzLmJ1ZmZlckxlbmd0aCs9cy0xO2lmKHM8NSl7Zm9yKDtzPDU7KytzKXJbc109MTE3O3RoaXMuZW9mPSEwfWxldCBuPTA7Zm9yKHM9MDtzPDU7KytzKW49ODUqbisocltzXS0zMyk7Zm9yKHM9MztzPj0wOy0tcyl7YVtpK3NdPTI1NSZuO24+Pj04fX19fWNsYXNzIEFzY2lpSGV4U3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCl7dCYmKHQqPS41KTtzdXBlcih0KTt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7dGhpcy5maXJzdERpZ2l0PS0xfXJlYWRCbG9jaygpe2NvbnN0IGU9dGhpcy5zdHIuZ2V0Qnl0ZXMoOGUzKTtpZighZS5sZW5ndGgpe3RoaXMuZW9mPSEwO3JldHVybn1jb25zdCB0PWUubGVuZ3RoKzE+PjEsaT10aGlzLmVuc3VyZUJ1ZmZlcih0aGlzLmJ1ZmZlckxlbmd0aCt0KTtsZXQgYT10aGlzLmJ1ZmZlckxlbmd0aCxzPXRoaXMuZmlyc3REaWdpdDtmb3IoY29uc3QgdCBvZiBlKXtsZXQgZTtpZih0Pj00OCYmdDw9NTcpZT0xNSZ0O2Vsc2V7aWYoISh0Pj02NSYmdDw9NzB8fHQ+PTk3JiZ0PD0xMDIpKXtpZig2Mj09PXQpe3RoaXMuZW9mPSEwO2JyZWFrfWNvbnRpbnVlfWU9OSsoMTUmdCl9aWYoczwwKXM9ZTtlbHNle2lbYSsrXT1zPDw0fGU7cz0tMX19aWYocz49MCYmdGhpcy5lb2Ype2lbYSsrXT1zPDw0O3M9LTF9dGhpcy5maXJzdERpZ2l0PXM7dGhpcy5idWZmZXJMZW5ndGg9YX19Y29uc3QgUnQ9LTEsR3Q9W1stMSwtMV0sWy0xLC0xXSxbNyw4XSxbNyw3XSxbNiw2XSxbNiw2XSxbNiw1XSxbNiw1XSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbNCwwXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMywxXSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMyw0XSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMywzXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXSxbMSwyXV0seHQ9W1stMSwtMV0sWzEyLC0yXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWzExLDE3OTJdLFsxMSwxNzkyXSxbMTIsMTk4NF0sWzEyLDIwNDhdLFsxMiwyMTEyXSxbMTIsMjE3Nl0sWzEyLDIyNDBdLFsxMiwyMzA0XSxbMTEsMTg1Nl0sWzExLDE4NTZdLFsxMSwxOTIwXSxbMTEsMTkyMF0sWzEyLDIzNjhdLFsxMiwyNDMyXSxbMTIsMjQ5Nl0sWzEyLDI1NjBdXSxVdD1bWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbOCwyOV0sWzgsMjldLFs4LDMwXSxbOCwzMF0sWzgsNDVdLFs4LDQ1XSxbOCw0Nl0sWzgsNDZdLFs3LDIyXSxbNywyMl0sWzcsMjJdLFs3LDIyXSxbNywyM10sWzcsMjNdLFs3LDIzXSxbNywyM10sWzgsNDddLFs4LDQ3XSxbOCw0OF0sWzgsNDhdLFs2LDEzXSxbNiwxM10sWzYsMTNdLFs2LDEzXSxbNiwxM10sWzYsMTNdLFs2LDEzXSxbNiwxM10sWzcsMjBdLFs3LDIwXSxbNywyMF0sWzcsMjBdLFs4LDMzXSxbOCwzM10sWzgsMzRdLFs4LDM0XSxbOCwzNV0sWzgsMzVdLFs4LDM2XSxbOCwzNl0sWzgsMzddLFs4LDM3XSxbOCwzOF0sWzgsMzhdLFs3LDE5XSxbNywxOV0sWzcsMTldLFs3LDE5XSxbOCwzMV0sWzgsMzFdLFs4LDMyXSxbOCwzMl0sWzYsMV0sWzYsMV0sWzYsMV0sWzYsMV0sWzYsMV0sWzYsMV0sWzYsMV0sWzYsMV0sWzYsMTJdLFs2LDEyXSxbNiwxMl0sWzYsMTJdLFs2LDEyXSxbNiwxMl0sWzYsMTJdLFs2LDEyXSxbOCw1M10sWzgsNTNdLFs4LDU0XSxbOCw1NF0sWzcsMjZdLFs3LDI2XSxbNywyNl0sWzcsMjZdLFs4LDM5XSxbOCwzOV0sWzgsNDBdLFs4LDQwXSxbOCw0MV0sWzgsNDFdLFs4LDQyXSxbOCw0Ml0sWzgsNDNdLFs4LDQzXSxbOCw0NF0sWzgsNDRdLFs3LDIxXSxbNywyMV0sWzcsMjFdLFs3LDIxXSxbNywyOF0sWzcsMjhdLFs3LDI4XSxbNywyOF0sWzgsNjFdLFs4LDYxXSxbOCw2Ml0sWzgsNjJdLFs4LDYzXSxbOCw2M10sWzgsMF0sWzgsMF0sWzgsMzIwXSxbOCwzMjBdLFs4LDM4NF0sWzgsMzg0XSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTBdLFs1LDEwXSxbNSwxMF0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs1LDExXSxbNSwxMV0sWzUsMTFdLFs3LDI3XSxbNywyN10sWzcsMjddLFs3LDI3XSxbOCw1OV0sWzgsNTldLFs4LDYwXSxbOCw2MF0sWzksMTQ3Ml0sWzksMTUzNl0sWzksMTYwMF0sWzksMTcyOF0sWzcsMThdLFs3LDE4XSxbNywxOF0sWzcsMThdLFs3LDI0XSxbNywyNF0sWzcsMjRdLFs3LDI0XSxbOCw0OV0sWzgsNDldLFs4LDUwXSxbOCw1MF0sWzgsNTFdLFs4LDUxXSxbOCw1Ml0sWzgsNTJdLFs3LDI1XSxbNywyNV0sWzcsMjVdLFs3LDI1XSxbOCw1NV0sWzgsNTVdLFs4LDU2XSxbOCw1Nl0sWzgsNTddLFs4LDU3XSxbOCw1OF0sWzgsNThdLFs2LDE5Ml0sWzYsMTkyXSxbNiwxOTJdLFs2LDE5Ml0sWzYsMTkyXSxbNiwxOTJdLFs2LDE5Ml0sWzYsMTkyXSxbNiwxNjY0XSxbNiwxNjY0XSxbNiwxNjY0XSxbNiwxNjY0XSxbNiwxNjY0XSxbNiwxNjY0XSxbNiwxNjY0XSxbNiwxNjY0XSxbOCw0NDhdLFs4LDQ0OF0sWzgsNTEyXSxbOCw1MTJdLFs5LDcwNF0sWzksNzY4XSxbOCw2NDBdLFs4LDY0MF0sWzgsNTc2XSxbOCw1NzZdLFs5LDgzMl0sWzksODk2XSxbOSw5NjBdLFs5LDEwMjRdLFs5LDEwODhdLFs5LDExNTJdLFs5LDEyMTZdLFs5LDEyODBdLFs5LDEzNDRdLFs5LDE0MDhdLFs3LDI1Nl0sWzcsMjU2XSxbNywyNTZdLFs3LDI1Nl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsMl0sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzQsM10sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSwxMjhdLFs1LDEyOF0sWzUsMTI4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw4XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNSw5XSxbNiwxNl0sWzYsMTZdLFs2LDE2XSxbNiwxNl0sWzYsMTZdLFs2LDE2XSxbNiwxNl0sWzYsMTZdLFs2LDE3XSxbNiwxN10sWzYsMTddLFs2LDE3XSxbNiwxN10sWzYsMTddLFs2LDE3XSxbNiwxN10sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNF0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzYsMTRdLFs2LDE0XSxbNiwxNF0sWzYsMTRdLFs2LDE0XSxbNiwxNF0sWzYsMTRdLFs2LDE0XSxbNiwxNV0sWzYsMTVdLFs2LDE1XSxbNiwxNV0sWzYsMTVdLFs2LDE1XSxbNiwxNV0sWzYsMTVdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNSw2NF0sWzUsNjRdLFs1LDY0XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw2XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XSxbNCw3XV0sTXQ9W1stMSwtMV0sWy0xLC0xXSxbMTIsLTJdLFsxMiwtMl0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWy0xLC0xXSxbMTEsMTc5Ml0sWzExLDE3OTJdLFsxMSwxNzkyXSxbMTEsMTc5Ml0sWzEyLDE5ODRdLFsxMiwxOTg0XSxbMTIsMjA0OF0sWzEyLDIwNDhdLFsxMiwyMTEyXSxbMTIsMjExMl0sWzEyLDIxNzZdLFsxMiwyMTc2XSxbMTIsMjI0MF0sWzEyLDIyNDBdLFsxMiwyMzA0XSxbMTIsMjMwNF0sWzExLDE4NTZdLFsxMSwxODU2XSxbMTEsMTg1Nl0sWzExLDE4NTZdLFsxMSwxOTIwXSxbMTEsMTkyMF0sWzExLDE5MjBdLFsxMSwxOTIwXSxbMTIsMjM2OF0sWzEyLDIzNjhdLFsxMiwyNDMyXSxbMTIsMjQzMl0sWzEyLDI0OTZdLFsxMiwyNDk2XSxbMTIsMjU2MF0sWzEyLDI1NjBdLFsxMCwxOF0sWzEwLDE4XSxbMTAsMThdLFsxMCwxOF0sWzEwLDE4XSxbMTAsMThdLFsxMCwxOF0sWzEwLDE4XSxbMTIsNTJdLFsxMiw1Ml0sWzEzLDY0MF0sWzEzLDcwNF0sWzEzLDc2OF0sWzEzLDgzMl0sWzEyLDU1XSxbMTIsNTVdLFsxMiw1Nl0sWzEyLDU2XSxbMTMsMTI4MF0sWzEzLDEzNDRdLFsxMywxNDA4XSxbMTMsMTQ3Ml0sWzEyLDU5XSxbMTIsNTldLFsxMiw2MF0sWzEyLDYwXSxbMTMsMTUzNl0sWzEzLDE2MDBdLFsxMSwyNF0sWzExLDI0XSxbMTEsMjRdLFsxMSwyNF0sWzExLDI1XSxbMTEsMjVdLFsxMSwyNV0sWzExLDI1XSxbMTMsMTY2NF0sWzEzLDE3MjhdLFsxMiwzMjBdLFsxMiwzMjBdLFsxMiwzODRdLFsxMiwzODRdLFsxMiw0NDhdLFsxMiw0NDhdLFsxMyw1MTJdLFsxMyw1NzZdLFsxMiw1M10sWzEyLDUzXSxbMTIsNTRdLFsxMiw1NF0sWzEzLDg5Nl0sWzEzLDk2MF0sWzEzLDEwMjRdLFsxMywxMDg4XSxbMTMsMTE1Ml0sWzEzLDEyMTZdLFsxMCw2NF0sWzEwLDY0XSxbMTAsNjRdLFsxMCw2NF0sWzEwLDY0XSxbMTAsNjRdLFsxMCw2NF0sWzEwLDY0XV0sTHQ9W1s4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbOCwxM10sWzgsMTNdLFs4LDEzXSxbMTEsMjNdLFsxMSwyM10sWzEyLDUwXSxbMTIsNTFdLFsxMiw0NF0sWzEyLDQ1XSxbMTIsNDZdLFsxMiw0N10sWzEyLDU3XSxbMTIsNThdLFsxMiw2MV0sWzEyLDI1Nl0sWzEwLDE2XSxbMTAsMTZdLFsxMCwxNl0sWzEwLDE2XSxbMTAsMTddLFsxMCwxN10sWzEwLDE3XSxbMTAsMTddLFsxMiw0OF0sWzEyLDQ5XSxbMTIsNjJdLFsxMiw2M10sWzEyLDMwXSxbMTIsMzFdLFsxMiwzMl0sWzEyLDMzXSxbMTIsNDBdLFsxMiw0MV0sWzExLDIyXSxbMTEsMjJdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbOCwxNF0sWzgsMTRdLFs4LDE0XSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDEwXSxbNywxMF0sWzcsMTBdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzcsMTFdLFs3LDExXSxbNywxMV0sWzksMTVdLFs5LDE1XSxbOSwxNV0sWzksMTVdLFs5LDE1XSxbOSwxNV0sWzksMTVdLFs5LDE1XSxbMTIsMTI4XSxbMTIsMTkyXSxbMTIsMjZdLFsxMiwyN10sWzEyLDI4XSxbMTIsMjldLFsxMSwxOV0sWzExLDE5XSxbMTEsMjBdLFsxMSwyMF0sWzEyLDM0XSxbMTIsMzVdLFsxMiwzNl0sWzEyLDM3XSxbMTIsMzhdLFsxMiwzOV0sWzExLDIxXSxbMTEsMjFdLFsxMiw0Ml0sWzEyLDQzXSxbMTAsMF0sWzEwLDBdLFsxMCwwXSxbMTAsMF0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXSxbNywxMl0sWzcsMTJdLFs3LDEyXV0sSHQ9W1stMSwtMV0sWy0xLC0xXSxbLTEsLTFdLFstMSwtMV0sWzYsOV0sWzYsOF0sWzUsN10sWzUsN10sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNl0sWzQsNV0sWzQsNV0sWzQsNV0sWzQsNV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsMV0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzMsNF0sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsM10sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl0sWzIsMl1dO2NsYXNzIENDSVRURmF4RGVjb2Rlcntjb25zdHJ1Y3RvcihlLHQ9e30pe2lmKCFlfHwiZnVuY3Rpb24iIT10eXBlb2YgZS5uZXh0KXRocm93IG5ldyBFcnJvcignQ0NJVFRGYXhEZWNvZGVyIC0gaW52YWxpZCAic291cmNlIiBwYXJhbWV0ZXIuJyk7dGhpcy5zb3VyY2U9ZTt0aGlzLmVvZj0hMTt0aGlzLmVuY29kaW5nPXQuS3x8MDt0aGlzLmVvbGluZT10LkVuZE9mTGluZXx8ITE7dGhpcy5ieXRlQWxpZ249dC5FbmNvZGVkQnl0ZUFsaWdufHwhMTt0aGlzLmNvbHVtbnM9dC5Db2x1bW5zfHwxNzI4O3RoaXMucm93cz10LlJvd3N8fDA7dGhpcy5lb2Jsb2NrPXQuRW5kT2ZCbG9jaz8/ITA7dGhpcy5ibGFjaz10LkJsYWNrSXMxfHwhMTt0aGlzLmNvZGluZ0xpbmU9bmV3IFVpbnQzMkFycmF5KHRoaXMuY29sdW1ucysxKTt0aGlzLnJlZkxpbmU9bmV3IFVpbnQzMkFycmF5KHRoaXMuY29sdW1ucysyKTt0aGlzLmNvZGluZ0xpbmVbMF09dGhpcy5jb2x1bW5zO3RoaXMuY29kaW5nUG9zPTA7dGhpcy5yb3c9MDt0aGlzLm5leHRMaW5lMkQ9dGhpcy5lbmNvZGluZzwwO3RoaXMuaW5wdXRCaXRzPTA7dGhpcy5pbnB1dEJ1Zj0wO3RoaXMub3V0cHV0Qml0cz0wO3RoaXMucm93c0RvbmU9ITE7bGV0IGk7Zm9yKDswPT09KGk9dGhpcy5fbG9va0JpdHMoMTIpKTspdGhpcy5fZWF0Qml0cygxKTsxPT09aSYmdGhpcy5fZWF0Qml0cygxMik7aWYodGhpcy5lbmNvZGluZz4wKXt0aGlzLm5leHRMaW5lMkQ9IXRoaXMuX2xvb2tCaXRzKDEpO3RoaXMuX2VhdEJpdHMoMSl9fXJlYWROZXh0Q2hhcigpe2lmKHRoaXMuZW9mKXJldHVybi0xO2NvbnN0IGU9dGhpcy5yZWZMaW5lLHQ9dGhpcy5jb2RpbmdMaW5lLGk9dGhpcy5jb2x1bW5zO2xldCBhLHMscixuLG87aWYoMD09PXRoaXMub3V0cHV0Qml0cyl7dGhpcy5yb3dzRG9uZSYmKHRoaXMuZW9mPSEwKTtpZih0aGlzLmVvZilyZXR1cm4tMTt0aGlzLmVycj0hMTtsZXQgcixvLGc7aWYodGhpcy5uZXh0TGluZTJEKXtmb3Iobj0wO3Rbbl08aTsrK24pZVtuXT10W25dO2VbbisrXT1pO2Vbbl09aTt0WzBdPTA7dGhpcy5jb2RpbmdQb3M9MDthPTA7cz0wO2Zvcig7dFt0aGlzLmNvZGluZ1Bvc108aTspe3I9dGhpcy5fZ2V0VHdvRGltQ29kZSgpO3N3aXRjaChyKXtjYXNlIDA6dGhpcy5fYWRkUGl4ZWxzKGVbYSsxXSxzKTtlW2ErMV08aSYmKGErPTIpO2JyZWFrO2Nhc2UgMTpyPW89MDtpZihzKXtkb3tyKz1nPXRoaXMuX2dldEJsYWNrQ29kZSgpfXdoaWxlKGc+PTY0KTtkb3tvKz1nPXRoaXMuX2dldFdoaXRlQ29kZSgpfXdoaWxlKGc+PTY0KX1lbHNle2Rve3IrPWc9dGhpcy5fZ2V0V2hpdGVDb2RlKCl9d2hpbGUoZz49NjQpO2Rve28rPWc9dGhpcy5fZ2V0QmxhY2tDb2RlKCl9d2hpbGUoZz49NjQpfXRoaXMuX2FkZFBpeGVscyh0W3RoaXMuY29kaW5nUG9zXStyLHMpO3RbdGhpcy5jb2RpbmdQb3NdPGkmJnRoaXMuX2FkZFBpeGVscyh0W3RoaXMuY29kaW5nUG9zXStvLDFecyk7Zm9yKDtlW2FdPD10W3RoaXMuY29kaW5nUG9zXSYmZVthXTxpOylhKz0yO2JyZWFrO2Nhc2UgNzp0aGlzLl9hZGRQaXhlbHMoZVthXSszLHMpO3NePTE7aWYodFt0aGlzLmNvZGluZ1Bvc108aSl7KythO2Zvcig7ZVthXTw9dFt0aGlzLmNvZGluZ1Bvc10mJmVbYV08aTspYSs9Mn1icmVhaztjYXNlIDU6dGhpcy5fYWRkUGl4ZWxzKGVbYV0rMixzKTtzXj0xO2lmKHRbdGhpcy5jb2RpbmdQb3NdPGkpeysrYTtmb3IoO2VbYV08PXRbdGhpcy5jb2RpbmdQb3NdJiZlW2FdPGk7KWErPTJ9YnJlYWs7Y2FzZSAzOnRoaXMuX2FkZFBpeGVscyhlW2FdKzEscyk7c149MTtpZih0W3RoaXMuY29kaW5nUG9zXTxpKXsrK2E7Zm9yKDtlW2FdPD10W3RoaXMuY29kaW5nUG9zXSYmZVthXTxpOylhKz0yfWJyZWFrO2Nhc2UgMjp0aGlzLl9hZGRQaXhlbHMoZVthXSxzKTtzXj0xO2lmKHRbdGhpcy5jb2RpbmdQb3NdPGkpeysrYTtmb3IoO2VbYV08PXRbdGhpcy5jb2RpbmdQb3NdJiZlW2FdPGk7KWErPTJ9YnJlYWs7Y2FzZSA4OnRoaXMuX2FkZFBpeGVsc05lZyhlW2FdLTMscyk7c149MTtpZih0W3RoaXMuY29kaW5nUG9zXTxpKXthPjA/LS1hOisrYTtmb3IoO2VbYV08PXRbdGhpcy5jb2RpbmdQb3NdJiZlW2FdPGk7KWErPTJ9YnJlYWs7Y2FzZSA2OnRoaXMuX2FkZFBpeGVsc05lZyhlW2FdLTIscyk7c149MTtpZih0W3RoaXMuY29kaW5nUG9zXTxpKXthPjA/LS1hOisrYTtmb3IoO2VbYV08PXRbdGhpcy5jb2RpbmdQb3NdJiZlW2FdPGk7KWErPTJ9YnJlYWs7Y2FzZSA0OnRoaXMuX2FkZFBpeGVsc05lZyhlW2FdLTEscyk7c149MTtpZih0W3RoaXMuY29kaW5nUG9zXTxpKXthPjA/LS1hOisrYTtmb3IoO2VbYV08PXRbdGhpcy5jb2RpbmdQb3NdJiZlW2FdPGk7KWErPTJ9YnJlYWs7Y2FzZSBSdDp0aGlzLl9hZGRQaXhlbHMoaSwwKTt0aGlzLmVvZj0hMDticmVhaztkZWZhdWx0OmluZm8oImJhZCAyZCBjb2RlIik7dGhpcy5fYWRkUGl4ZWxzKGksMCk7dGhpcy5lcnI9ITB9fX1lbHNle3RbMF09MDt0aGlzLmNvZGluZ1Bvcz0wO3M9MDtmb3IoO3RbdGhpcy5jb2RpbmdQb3NdPGk7KXtyPTA7aWYocylkb3tyKz1nPXRoaXMuX2dldEJsYWNrQ29kZSgpfXdoaWxlKGc+PTY0KTtlbHNlIGRve3IrPWc9dGhpcy5fZ2V0V2hpdGVDb2RlKCl9d2hpbGUoZz49NjQpO3RoaXMuX2FkZFBpeGVscyh0W3RoaXMuY29kaW5nUG9zXStyLHMpO3NePTF9fWxldCBjPSExO3RoaXMuYnl0ZUFsaWduJiYodGhpcy5pbnB1dEJpdHMmPS04KTtpZih0aGlzLmVvYmxvY2t8fHRoaXMucm93IT09dGhpcy5yb3dzLTEpe3I9dGhpcy5fbG9va0JpdHMoMTIpO2lmKHRoaXMuZW9saW5lKWZvcig7ciE9PVJ0JiYxIT09cjspe3RoaXMuX2VhdEJpdHMoMSk7cj10aGlzLl9sb29rQml0cygxMil9ZWxzZSBmb3IoOzA9PT1yOyl7dGhpcy5fZWF0Qml0cygxKTtyPXRoaXMuX2xvb2tCaXRzKDEyKX1pZigxPT09cil7dGhpcy5fZWF0Qml0cygxMik7Yz0hMH1lbHNlIHI9PT1SdCYmKHRoaXMuZW9mPSEwKX1lbHNlIHRoaXMucm93c0RvbmU9ITA7aWYoIXRoaXMuZW9mJiZ0aGlzLmVuY29kaW5nPjAmJiF0aGlzLnJvd3NEb25lKXt0aGlzLm5leHRMaW5lMkQ9IXRoaXMuX2xvb2tCaXRzKDEpO3RoaXMuX2VhdEJpdHMoMSl9aWYodGhpcy5lb2Jsb2NrJiZjJiZ0aGlzLmJ5dGVBbGlnbil7cj10aGlzLl9sb29rQml0cygxMik7aWYoMT09PXIpe3RoaXMuX2VhdEJpdHMoMTIpO2lmKHRoaXMuZW5jb2Rpbmc+MCl7dGhpcy5fbG9va0JpdHMoMSk7dGhpcy5fZWF0Qml0cygxKX1pZih0aGlzLmVuY29kaW5nPj0wKWZvcihuPTA7bjw0Oysrbil7cj10aGlzLl9sb29rQml0cygxMik7MSE9PXImJmluZm8oImJhZCBydGMgY29kZTogIityKTt0aGlzLl9lYXRCaXRzKDEyKTtpZih0aGlzLmVuY29kaW5nPjApe3RoaXMuX2xvb2tCaXRzKDEpO3RoaXMuX2VhdEJpdHMoMSl9fXRoaXMuZW9mPSEwfX1lbHNlIGlmKHRoaXMuZXJyJiZ0aGlzLmVvbGluZSl7Zm9yKDs7KXtyPXRoaXMuX2xvb2tCaXRzKDEzKTtpZihyPT09UnQpe3RoaXMuZW9mPSEwO3JldHVybi0xfWlmKHI+PjE9PTEpYnJlYWs7dGhpcy5fZWF0Qml0cygxKX10aGlzLl9lYXRCaXRzKDEyKTtpZih0aGlzLmVuY29kaW5nPjApe3RoaXMuX2VhdEJpdHMoMSk7dGhpcy5uZXh0TGluZTJEPSEoMSZyKX19dGhpcy5vdXRwdXRCaXRzPXRbMF0+MD90W3RoaXMuY29kaW5nUG9zPTBdOnRbdGhpcy5jb2RpbmdQb3M9MV07dGhpcy5yb3crK31pZih0aGlzLm91dHB1dEJpdHM+PTgpe289MSZ0aGlzLmNvZGluZ1Bvcz8wOjI1NTt0aGlzLm91dHB1dEJpdHMtPTg7aWYoMD09PXRoaXMub3V0cHV0Qml0cyYmdFt0aGlzLmNvZGluZ1Bvc108aSl7dGhpcy5jb2RpbmdQb3MrKzt0aGlzLm91dHB1dEJpdHM9dFt0aGlzLmNvZGluZ1Bvc10tdFt0aGlzLmNvZGluZ1Bvcy0xXX19ZWxzZXtyPTg7bz0wO2Rve2lmKCJudW1iZXIiIT10eXBlb2YgdGhpcy5vdXRwdXRCaXRzKXRocm93IG5ldyBGb3JtYXRFcnJvcignSW52YWxpZCAvQ0NJVFRGYXhEZWNvZGUgZGF0YSwgIm91dHB1dEJpdHMiIG11c3QgYmUgYSBudW1iZXIuJyk7aWYodGhpcy5vdXRwdXRCaXRzPnIpe288PD1yOzEmdGhpcy5jb2RpbmdQb3N8fChvfD0yNTU+Pjgtcik7dGhpcy5vdXRwdXRCaXRzLT1yO3I9MH1lbHNle288PD10aGlzLm91dHB1dEJpdHM7MSZ0aGlzLmNvZGluZ1Bvc3x8KG98PTI1NT4+OC10aGlzLm91dHB1dEJpdHMpO3ItPXRoaXMub3V0cHV0Qml0czt0aGlzLm91dHB1dEJpdHM9MDtpZih0W3RoaXMuY29kaW5nUG9zXTxpKXt0aGlzLmNvZGluZ1BvcysrO3RoaXMub3V0cHV0Qml0cz10W3RoaXMuY29kaW5nUG9zXS10W3RoaXMuY29kaW5nUG9zLTFdfWVsc2UgaWYocj4wKXtvPDw9cjtyPTB9fX13aGlsZShyKX10aGlzLmJsYWNrJiYob149MjU1KTtyZXR1cm4gb31fYWRkUGl4ZWxzKGUsdCl7Y29uc3QgaT10aGlzLmNvZGluZ0xpbmU7bGV0IGE9dGhpcy5jb2RpbmdQb3M7aWYoZT5pW2FdKXtpZihlPnRoaXMuY29sdW1ucyl7aW5mbygicm93IGlzIHdyb25nIGxlbmd0aCIpO3RoaXMuZXJyPSEwO2U9dGhpcy5jb2x1bW5zfTEmYV50JiYrK2E7aVthXT1lfXRoaXMuY29kaW5nUG9zPWF9X2FkZFBpeGVsc05lZyhlLHQpe2NvbnN0IGk9dGhpcy5jb2RpbmdMaW5lO2xldCBhPXRoaXMuY29kaW5nUG9zO2lmKGU+aVthXSl7aWYoZT50aGlzLmNvbHVtbnMpe2luZm8oInJvdyBpcyB3cm9uZyBsZW5ndGgiKTt0aGlzLmVycj0hMDtlPXRoaXMuY29sdW1uc30xJmFedCYmKythO2lbYV09ZX1lbHNlIGlmKGU8aVthXSl7aWYoZTwwKXtpbmZvKCJpbnZhbGlkIGNvZGUiKTt0aGlzLmVycj0hMDtlPTB9Zm9yKDthPjAmJmU8aVthLTFdOyktLWE7aVthXT1lfXRoaXMuY29kaW5nUG9zPWF9X2ZpbmRUYWJsZUNvZGUoZSx0LGksYSl7Y29uc3Qgcz1hfHwwO2ZvcihsZXQgYT1lO2E8PXQ7KythKXtsZXQgZT10aGlzLl9sb29rQml0cyhhKTtpZihlPT09UnQpcmV0dXJuWyEwLDEsITFdO2E8dCYmKGU8PD10LWEpO2lmKCFzfHxlPj1zKXtjb25zdCB0PWlbZS1zXTtpZih0WzBdPT09YSl7dGhpcy5fZWF0Qml0cyhhKTtyZXR1cm5bITAsdFsxXSwhMF19fX1yZXR1cm5bITEsMCwhMV19X2dldFR3b0RpbUNvZGUoKXtsZXQgZSx0PTA7aWYodGhpcy5lb2Jsb2NrKXt0PXRoaXMuX2xvb2tCaXRzKDcpO2U9R3RbdF07aWYoZT8uWzBdPjApe3RoaXMuX2VhdEJpdHMoZVswXSk7cmV0dXJuIGVbMV19fWVsc2V7Y29uc3QgZT10aGlzLl9maW5kVGFibGVDb2RlKDEsNyxHdCk7aWYoZVswXSYmZVsyXSlyZXR1cm4gZVsxXX1pbmZvKCJCYWQgdHdvIGRpbSBjb2RlIik7cmV0dXJuIFJ0fV9nZXRXaGl0ZUNvZGUoKXtsZXQgZSx0PTA7aWYodGhpcy5lb2Jsb2NrKXt0PXRoaXMuX2xvb2tCaXRzKDEyKTtpZih0PT09UnQpcmV0dXJuIDE7ZT10Pj41PT0wP3h0W3RdOlV0W3Q+PjNdO2lmKGVbMF0+MCl7dGhpcy5fZWF0Qml0cyhlWzBdKTtyZXR1cm4gZVsxXX19ZWxzZXtsZXQgZT10aGlzLl9maW5kVGFibGVDb2RlKDEsOSxVdCk7aWYoZVswXSlyZXR1cm4gZVsxXTtlPXRoaXMuX2ZpbmRUYWJsZUNvZGUoMTEsMTIseHQpO2lmKGVbMF0pcmV0dXJuIGVbMV19aW5mbygiYmFkIHdoaXRlIGNvZGUiKTt0aGlzLl9lYXRCaXRzKDEpO3JldHVybiAxfV9nZXRCbGFja0NvZGUoKXtsZXQgZSx0O2lmKHRoaXMuZW9ibG9jayl7ZT10aGlzLl9sb29rQml0cygxMyk7aWYoZT09PVJ0KXJldHVybiAxO3Q9ZT4+Nz09MD9NdFtlXTplPj45PT0wJiZlPj43IT0wP0x0WyhlPj4xKS02NF06SHRbZT4+N107aWYodFswXT4wKXt0aGlzLl9lYXRCaXRzKHRbMF0pO3JldHVybiB0WzFdfX1lbHNle2xldCBlPXRoaXMuX2ZpbmRUYWJsZUNvZGUoMiw2LEh0KTtpZihlWzBdKXJldHVybiBlWzFdO2U9dGhpcy5fZmluZFRhYmxlQ29kZSg3LDEyLEx0LDY0KTtpZihlWzBdKXJldHVybiBlWzFdO2U9dGhpcy5fZmluZFRhYmxlQ29kZSgxMCwxMyxNdCk7aWYoZVswXSlyZXR1cm4gZVsxXX1pbmZvKCJiYWQgYmxhY2sgY29kZSIpO3RoaXMuX2VhdEJpdHMoMSk7cmV0dXJuIDF9X2xvb2tCaXRzKGUpe2xldCB0O2Zvcig7dGhpcy5pbnB1dEJpdHM8ZTspe2lmKC0xPT09KHQ9dGhpcy5zb3VyY2UubmV4dCgpKSlyZXR1cm4gMD09PXRoaXMuaW5wdXRCaXRzP1J0OnRoaXMuaW5wdXRCdWY8PGUtdGhpcy5pbnB1dEJpdHMmNjU1MzU+PjE2LWU7dGhpcy5pbnB1dEJ1Zj10aGlzLmlucHV0QnVmPDw4fHQ7dGhpcy5pbnB1dEJpdHMrPTh9cmV0dXJuIHRoaXMuaW5wdXRCdWY+PnRoaXMuaW5wdXRCaXRzLWUmNjU1MzU+PjE2LWV9X2VhdEJpdHMoZSl7KHRoaXMuaW5wdXRCaXRzLT1lKTwwJiYodGhpcy5pbnB1dEJpdHM9MCl9fWNsYXNzIENDSVRURmF4U3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcih0KTt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3Q7aSBpbnN0YW5jZW9mIERpY3R8fChpPURpY3QuZW1wdHkpO2NvbnN0IGE9e25leHQ6KCk9PmUuZ2V0Qnl0ZSgpfTt0aGlzLmNjaXR0RmF4RGVjb2Rlcj1uZXcgQ0NJVFRGYXhEZWNvZGVyKGEse0s6aS5nZXQoIksiKSxFbmRPZkxpbmU6aS5nZXQoIkVuZE9mTGluZSIpLEVuY29kZWRCeXRlQWxpZ246aS5nZXQoIkVuY29kZWRCeXRlQWxpZ24iKSxDb2x1bW5zOmkuZ2V0KCJDb2x1bW5zIiksUm93czppLmdldCgiUm93cyIpLEVuZE9mQmxvY2s6aS5nZXQoIkVuZE9mQmxvY2siKSxCbGFja0lzMTppLmdldCgiQmxhY2tJczEiKX0pfXJlYWRCbG9jaygpe2Zvcig7IXRoaXMuZW9mOyl7Y29uc3QgZT10aGlzLmNjaXR0RmF4RGVjb2Rlci5yZWFkTmV4dENoYXIoKTtpZigtMT09PWUpe3RoaXMuZW9mPSEwO3JldHVybn10aGlzLmVuc3VyZUJ1ZmZlcih0aGlzLmJ1ZmZlckxlbmd0aCsxKTt0aGlzLmJ1ZmZlclt0aGlzLmJ1ZmZlckxlbmd0aCsrXT1lfX19Y29uc3QgSnQ9bmV3IEludDMyQXJyYXkoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxZdD1uZXcgSW50MzJBcnJheShbMyw0LDUsNiw3LDgsOSwxMCw2NTU0Nyw2NTU0OSw2NTU1MSw2NTU1MywxMzEwOTEsMTMxMDk1LDEzMTA5OSwxMzExMDMsMTk2NjQzLDE5NjY1MSwxOTY2NTksMTk2NjY3LDI2MjIxMSwyNjIyMjcsMjYyMjQzLDI2MjI1OSwzMjc4MTEsMzI3ODQzLDMyNzg3NSwzMjc5MDcsMjU4LDI1OCwyNThdKSx2dD1uZXcgSW50MzJBcnJheShbMSwyLDMsNCw2NTU0MSw2NTU0MywxMzEwODEsMTMxMDg1LDE5NjYyNSwxOTY2MzMsMjYyMTc3LDI2MjE5MywzMjc3NDUsMzI3Nzc3LDM5MzM0NSwzOTM0MDksNDU5MDA5LDQ1OTEzNyw1MjQ4MDEsNTI1MDU3LDU5MDg0OSw1OTEzNjEsNjU3NDA5LDY1ODQzMyw3MjQ5OTMsNzI3MDQxLDc5NDYyNSw3OTg3MjEsODY4MzUzLDg3NjU0NV0pLEt0PVtuZXcgSW50MzJBcnJheShbNDU5MDA4LDUyNDM2OCw1MjQzMDQsNTI0NTY4LDQ1OTAyNCw1MjQ0MDAsNTI0MzM2LDU5MDAxNiw0NTkwMTYsNTI0Mzg0LDUyNDMyMCw1ODk5ODQsNTI0Mjg4LDUyNDQxNiw1MjQzNTIsNTkwMDQ4LDQ1OTAxMiw1MjQzNzYsNTI0MzEyLDU4OTk2OCw0NTkwMjgsNTI0NDA4LDUyNDM0NCw1OTAwMzIsNDU5MDIwLDUyNDM5Miw1MjQzMjgsNTllNCw1MjQyOTYsNTI0NDI0LDUyNDM2MCw1OTAwNjQsNDU5MDEwLDUyNDM3Miw1MjQzMDgsNTI0NTcyLDQ1OTAyNiw1MjQ0MDQsNTI0MzQwLDU5MDAyNCw0NTkwMTgsNTI0Mzg4LDUyNDMyNCw1ODk5OTIsNTI0MjkyLDUyNDQyMCw1MjQzNTYsNTkwMDU2LDQ1OTAxNCw1MjQzODAsNTI0MzE2LDU4OTk3Niw0NTkwMzAsNTI0NDEyLDUyNDM0OCw1OTAwNDAsNDU5MDIyLDUyNDM5Niw1MjQzMzIsNTkwMDA4LDUyNDMwMCw1MjQ0MjgsNTI0MzY0LDU5MDA3Miw0NTkwMDksNTI0MzcwLDUyNDMwNiw1MjQ1NzAsNDU5MDI1LDUyNDQwMiw1MjQzMzgsNTkwMDIwLDQ1OTAxNyw1MjQzODYsNTI0MzIyLDU4OTk4OCw1MjQyOTAsNTI0NDE4LDUyNDM1NCw1OTAwNTIsNDU5MDEzLDUyNDM3OCw1MjQzMTQsNTg5OTcyLDQ1OTAyOSw1MjQ0MTAsNTI0MzQ2LDU5MDAzNiw0NTkwMjEsNTI0Mzk0LDUyNDMzMCw1OTAwMDQsNTI0Mjk4LDUyNDQyNiw1MjQzNjIsNTkwMDY4LDQ1OTAxMSw1MjQzNzQsNTI0MzEwLDUyNDU3NCw0NTkwMjcsNTI0NDA2LDUyNDM0Miw1OTAwMjgsNDU5MDE5LDUyNDM5MCw1MjQzMjYsNTg5OTk2LDUyNDI5NCw1MjQ0MjIsNTI0MzU4LDU5MDA2MCw0NTkwMTUsNTI0MzgyLDUyNDMxOCw1ODk5ODAsNDU5MDMxLDUyNDQxNCw1MjQzNTAsNTkwMDQ0LDQ1OTAyMyw1MjQzOTgsNTI0MzM0LDU5MDAxMiw1MjQzMDIsNTI0NDMwLDUyNDM2Niw1OTAwNzYsNDU5MDA4LDUyNDM2OSw1MjQzMDUsNTI0NTY5LDQ1OTAyNCw1MjQ0MDEsNTI0MzM3LDU5MDAxOCw0NTkwMTYsNTI0Mzg1LDUyNDMyMSw1ODk5ODYsNTI0Mjg5LDUyNDQxNyw1MjQzNTMsNTkwMDUwLDQ1OTAxMiw1MjQzNzcsNTI0MzEzLDU4OTk3MCw0NTkwMjgsNTI0NDA5LDUyNDM0NSw1OTAwMzQsNDU5MDIwLDUyNDM5Myw1MjQzMjksNTkwMDAyLDUyNDI5Nyw1MjQ0MjUsNTI0MzYxLDU5MDA2Niw0NTkwMTAsNTI0MzczLDUyNDMwOSw1MjQ1NzMsNDU5MDI2LDUyNDQwNSw1MjQzNDEsNTkwMDI2LDQ1OTAxOCw1MjQzODksNTI0MzI1LDU4OTk5NCw1MjQyOTMsNTI0NDIxLDUyNDM1Nyw1OTAwNTgsNDU5MDE0LDUyNDM4MSw1MjQzMTcsNTg5OTc4LDQ1OTAzMCw1MjQ0MTMsNTI0MzQ5LDU5MDA0Miw0NTkwMjIsNTI0Mzk3LDUyNDMzMyw1OTAwMTAsNTI0MzAxLDUyNDQyOSw1MjQzNjUsNTkwMDc0LDQ1OTAwOSw1MjQzNzEsNTI0MzA3LDUyNDU3MSw0NTkwMjUsNTI0NDAzLDUyNDMzOSw1OTAwMjIsNDU5MDE3LDUyNDM4Nyw1MjQzMjMsNTg5OTkwLDUyNDI5MSw1MjQ0MTksNTI0MzU1LDU5MDA1NCw0NTkwMTMsNTI0Mzc5LDUyNDMxNSw1ODk5NzQsNDU5MDI5LDUyNDQxMSw1MjQzNDcsNTkwMDM4LDQ1OTAyMSw1MjQzOTUsNTI0MzMxLDU5MDAwNiw1MjQyOTksNTI0NDI3LDUyNDM2Myw1OTAwNzAsNDU5MDExLDUyNDM3NSw1MjQzMTEsNTI0NTc1LDQ1OTAyNyw1MjQ0MDcsNTI0MzQzLDU5MDAzMCw0NTkwMTksNTI0MzkxLDUyNDMyNyw1ODk5OTgsNTI0Mjk1LDUyNDQyMyw1MjQzNTksNTkwMDYyLDQ1OTAxNSw1MjQzODMsNTI0MzE5LDU4OTk4Miw0NTkwMzEsNTI0NDE1LDUyNDM1MSw1OTAwNDYsNDU5MDIzLDUyNDM5OSw1MjQzMzUsNTkwMDE0LDUyNDMwMyw1MjQ0MzEsNTI0MzY3LDU5MDA3OCw0NTkwMDgsNTI0MzY4LDUyNDMwNCw1MjQ1NjgsNDU5MDI0LDUyNDQwMCw1MjQzMzYsNTkwMDE3LDQ1OTAxNiw1MjQzODQsNTI0MzIwLDU4OTk4NSw1MjQyODgsNTI0NDE2LDUyNDM1Miw1OTAwNDksNDU5MDEyLDUyNDM3Niw1MjQzMTIsNTg5OTY5LDQ1OTAyOCw1MjQ0MDgsNTI0MzQ0LDU5MDAzMyw0NTkwMjAsNTI0MzkyLDUyNDMyOCw1OTAwMDEsNTI0Mjk2LDUyNDQyNCw1MjQzNjAsNTkwMDY1LDQ1OTAxMCw1MjQzNzIsNTI0MzA4LDUyNDU3Miw0NTkwMjYsNTI0NDA0LDUyNDM0MCw1OTAwMjUsNDU5MDE4LDUyNDM4OCw1MjQzMjQsNTg5OTkzLDUyNDI5Miw1MjQ0MjAsNTI0MzU2LDU5MDA1Nyw0NTkwMTQsNTI0MzgwLDUyNDMxNiw1ODk5NzcsNDU5MDMwLDUyNDQxMiw1MjQzNDgsNTkwMDQxLDQ1OTAyMiw1MjQzOTYsNTI0MzMyLDU5MDAwOSw1MjQzMDAsNTI0NDI4LDUyNDM2NCw1OTAwNzMsNDU5MDA5LDUyNDM3MCw1MjQzMDYsNTI0NTcwLDQ1OTAyNSw1MjQ0MDIsNTI0MzM4LDU5MDAyMSw0NTkwMTcsNTI0Mzg2LDUyNDMyMiw1ODk5ODksNTI0MjkwLDUyNDQxOCw1MjQzNTQsNTkwMDUzLDQ1OTAxMyw1MjQzNzgsNTI0MzE0LDU4OTk3Myw0NTkwMjksNTI0NDEwLDUyNDM0Niw1OTAwMzcsNDU5MDIxLDUyNDM5NCw1MjQzMzAsNTkwMDA1LDUyNDI5OCw1MjQ0MjYsNTI0MzYyLDU5MDA2OSw0NTkwMTEsNTI0Mzc0LDUyNDMxMCw1MjQ1NzQsNDU5MDI3LDUyNDQwNiw1MjQzNDIsNTkwMDI5LDQ1OTAxOSw1MjQzOTAsNTI0MzI2LDU4OTk5Nyw1MjQyOTQsNTI0NDIyLDUyNDM1OCw1OTAwNjEsNDU5MDE1LDUyNDM4Miw1MjQzMTgsNTg5OTgxLDQ1OTAzMSw1MjQ0MTQsNTI0MzUwLDU5MDA0NSw0NTkwMjMsNTI0Mzk4LDUyNDMzNCw1OTAwMTMsNTI0MzAyLDUyNDQzMCw1MjQzNjYsNTkwMDc3LDQ1OTAwOCw1MjQzNjksNTI0MzA1LDUyNDU2OSw0NTkwMjQsNTI0NDAxLDUyNDMzNyw1OTAwMTksNDU5MDE2LDUyNDM4NSw1MjQzMjEsNTg5OTg3LDUyNDI4OSw1MjQ0MTcsNTI0MzUzLDU5MDA1MSw0NTkwMTIsNTI0Mzc3LDUyNDMxMyw1ODk5NzEsNDU5MDI4LDUyNDQwOSw1MjQzNDUsNTkwMDM1LDQ1OTAyMCw1MjQzOTMsNTI0MzI5LDU5MDAwMyw1MjQyOTcsNTI0NDI1LDUyNDM2MSw1OTAwNjcsNDU5MDEwLDUyNDM3Myw1MjQzMDksNTI0NTczLDQ1OTAyNiw1MjQ0MDUsNTI0MzQxLDU5MDAyNyw0NTkwMTgsNTI0Mzg5LDUyNDMyNSw1ODk5OTUsNTI0MjkzLDUyNDQyMSw1MjQzNTcsNTkwMDU5LDQ1OTAxNCw1MjQzODEsNTI0MzE3LDU4OTk3OSw0NTkwMzAsNTI0NDEzLDUyNDM0OSw1OTAwNDMsNDU5MDIyLDUyNDM5Nyw1MjQzMzMsNTkwMDExLDUyNDMwMSw1MjQ0MjksNTI0MzY1LDU5MDA3NSw0NTkwMDksNTI0MzcxLDUyNDMwNyw1MjQ1NzEsNDU5MDI1LDUyNDQwMyw1MjQzMzksNTkwMDIzLDQ1OTAxNyw1MjQzODcsNTI0MzIzLDU4OTk5MSw1MjQyOTEsNTI0NDE5LDUyNDM1NSw1OTAwNTUsNDU5MDEzLDUyNDM3OSw1MjQzMTUsNTg5OTc1LDQ1OTAyOSw1MjQ0MTEsNTI0MzQ3LDU5MDAzOSw0NTkwMjEsNTI0Mzk1LDUyNDMzMSw1OTAwMDcsNTI0Mjk5LDUyNDQyNyw1MjQzNjMsNTkwMDcxLDQ1OTAxMSw1MjQzNzUsNTI0MzExLDUyNDU3NSw0NTkwMjcsNTI0NDA3LDUyNDM0Myw1OTAwMzEsNDU5MDE5LDUyNDM5MSw1MjQzMjcsNTg5OTk5LDUyNDI5NSw1MjQ0MjMsNTI0MzU5LDU5MDA2Myw0NTkwMTUsNTI0MzgzLDUyNDMxOSw1ODk5ODMsNDU5MDMxLDUyNDQxNSw1MjQzNTEsNTkwMDQ3LDQ1OTAyMyw1MjQzOTksNTI0MzM1LDU5MDAxNSw1MjQzMDMsNTI0NDMxLDUyNDM2Nyw1OTAwNzldKSw5XSxUdD1bbmV3IEludDMyQXJyYXkoWzMyNzY4MCwzMjc2OTYsMzI3Njg4LDMyNzcwNCwzMjc2ODQsMzI3NzAwLDMyNzY5MiwzMjc3MDgsMzI3NjgyLDMyNzY5OCwzMjc2OTAsMzI3NzA2LDMyNzY4NiwzMjc3MDIsMzI3Njk0LDAsMzI3NjgxLDMyNzY5NywzMjc2ODksMzI3NzA1LDMyNzY4NSwzMjc3MDEsMzI3NjkzLDMyNzcwOSwzMjc2ODMsMzI3Njk5LDMyNzY5MSwzMjc3MDcsMzI3Njg3LDMyNzcwMywzMjc2OTUsMF0pLDVdO2NsYXNzIEZsYXRlU3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIodCk7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O2NvbnN0IGk9ZS5nZXRCeXRlKCksYT1lLmdldEJ5dGUoKTtpZigtMT09PWl8fC0xPT09YSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgaGVhZGVyIGluIGZsYXRlIHN0cmVhbTogJHtpfSwgJHthfWApO2lmKDghPSgxNSZpKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIGluIGZsYXRlIHN0cmVhbTogJHtpfSwgJHthfWApO2lmKCgoaTw8OCkrYSklMzEhPTApdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBCYWQgRkNIRUNLIGluIGZsYXRlIHN0cmVhbTogJHtpfSwgJHthfWApO2lmKDMyJmEpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBGRElDVCBiaXQgc2V0IGluIGZsYXRlIHN0cmVhbTogJHtpfSwgJHthfWApO3RoaXMuY29kZVNpemU9MDt0aGlzLmNvZGVCdWY9MH1nZXRCaXRzKGUpe2NvbnN0IHQ9dGhpcy5zdHI7bGV0IGksYT10aGlzLmNvZGVTaXplLHM9dGhpcy5jb2RlQnVmO2Zvcig7YTxlOyl7aWYoLTE9PT0oaT10LmdldEJ5dGUoKSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJCYWQgZW5jb2RpbmcgaW4gZmxhdGUgc3RyZWFtIik7c3w9aTw8YTthKz04fWk9cyYoMTw8ZSktMTt0aGlzLmNvZGVCdWY9cz4+ZTt0aGlzLmNvZGVTaXplPWEtPWU7cmV0dXJuIGl9Z2V0Q29kZShlKXtjb25zdCB0PXRoaXMuc3RyLGk9ZVswXSxhPWVbMV07bGV0IHMscj10aGlzLmNvZGVTaXplLG49dGhpcy5jb2RlQnVmO2Zvcig7cjxhJiYtMSE9PShzPXQuZ2V0Qnl0ZSgpKTspe258PXM8PHI7cis9OH1jb25zdCBvPWlbbiYoMTw8YSktMV0sZz1vPj4xNixjPTY1NTM1Jm87aWYoZzwxfHxyPGcpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJCYWQgZW5jb2RpbmcgaW4gZmxhdGUgc3RyZWFtIik7dGhpcy5jb2RlQnVmPW4+Pmc7dGhpcy5jb2RlU2l6ZT1yLWc7cmV0dXJuIGN9Z2VuZXJhdGVIdWZmbWFuVGFibGUoZSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgaSxhPTA7Zm9yKGk9MDtpPHQ7KytpKWVbaV0+YSYmKGE9ZVtpXSk7Y29uc3Qgcz0xPDxhLHI9bmV3IEludDMyQXJyYXkocyk7Zm9yKGxldCBuPTEsbz0wLGc9MjtuPD1hOysrbixvPDw9MSxnPDw9MSlmb3IobGV0IGE9MDthPHQ7KythKWlmKGVbYV09PT1uKXtsZXQgZT0wLHQ9bztmb3IoaT0wO2k8bjsrK2kpe2U9ZTw8MXwxJnQ7dD4+PTF9Zm9yKGk9ZTtpPHM7aSs9ZylyW2ldPW48PDE2fGE7KytvfXJldHVybltyLGFdfSNtKGUpe2luZm8oZSk7dGhpcy5lb2Y9ITB9cmVhZEJsb2NrKCl7bGV0IGUsdDtjb25zdCBpPXRoaXMuc3RyO2xldCBhLHMscj10aGlzLmdldEJpdHMoMyk7MSZyJiYodGhpcy5lb2Y9ITApO3I+Pj0xO2lmKDA9PT1yKXtsZXQgdDtpZigtMT09PSh0PWkuZ2V0Qnl0ZSgpKSl7dGhpcy4jbSgiQmFkIGJsb2NrIGhlYWRlciBpbiBmbGF0ZSBzdHJlYW0iKTtyZXR1cm59bGV0IGE9dDtpZigtMT09PSh0PWkuZ2V0Qnl0ZSgpKSl7dGhpcy4jbSgiQmFkIGJsb2NrIGhlYWRlciBpbiBmbGF0ZSBzdHJlYW0iKTtyZXR1cm59YXw9dDw8ODtpZigtMT09PSh0PWkuZ2V0Qnl0ZSgpKSl7dGhpcy4jbSgiQmFkIGJsb2NrIGhlYWRlciBpbiBmbGF0ZSBzdHJlYW0iKTtyZXR1cm59bGV0IHM9dDtpZigtMT09PSh0PWkuZ2V0Qnl0ZSgpKSl7dGhpcy4jbSgiQmFkIGJsb2NrIGhlYWRlciBpbiBmbGF0ZSBzdHJlYW0iKTtyZXR1cm59c3w9dDw8ODtpZihzIT09KDY1NTM1Jn5hKSYmKDAhPT1hfHwwIT09cykpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJCYWQgdW5jb21wcmVzc2VkIGJsb2NrIGxlbmd0aCBpbiBmbGF0ZSBzdHJlYW0iKTt0aGlzLmNvZGVCdWY9MDt0aGlzLmNvZGVTaXplPTA7Y29uc3Qgcj10aGlzLmJ1ZmZlckxlbmd0aCxuPXIrYTtlPXRoaXMuZW5zdXJlQnVmZmVyKG4pO3RoaXMuYnVmZmVyTGVuZ3RoPW47aWYoMD09PWEpLTE9PT1pLnBlZWtCeXRlKCkmJih0aGlzLmVvZj0hMCk7ZWxzZXtjb25zdCB0PWkuZ2V0Qnl0ZXMoYSk7ZS5zZXQodCxyKTt0Lmxlbmd0aDxhJiYodGhpcy5lb2Y9ITApfXJldHVybn1pZigxPT09cil7YT1LdDtzPVR0fWVsc2V7aWYoMiE9PXIpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJVbmtub3duIGJsb2NrIHR5cGUgaW4gZmxhdGUgc3RyZWFtIik7e2NvbnN0IGU9dGhpcy5nZXRCaXRzKDUpKzI1NyxpPXRoaXMuZ2V0Qml0cyg1KSsxLHI9dGhpcy5nZXRCaXRzKDQpKzQsbj1uZXcgVWludDhBcnJheShKdC5sZW5ndGgpO2xldCBvO2ZvcihvPTA7bzxyOysrbyluW0p0W29dXT10aGlzLmdldEJpdHMoMyk7Y29uc3QgZz10aGlzLmdlbmVyYXRlSHVmZm1hblRhYmxlKG4pO3Q9MDtvPTA7Y29uc3QgYz1lK2ksQz1uZXcgVWludDhBcnJheShjKTtsZXQgaCxsLFE7Zm9yKDtvPGM7KXtjb25zdCBlPXRoaXMuZ2V0Q29kZShnKTtpZigxNj09PWUpe2g9MjtsPTM7UT10fWVsc2UgaWYoMTc9PT1lKXtoPTM7bD0zO1E9dD0wfWVsc2V7aWYoMTghPT1lKXtDW28rK109dD1lO2NvbnRpbnVlfWg9NztsPTExO1E9dD0wfWxldCBpPXRoaXMuZ2V0Qml0cyhoKStsO2Zvcig7aS0tID4wOylDW28rK109UX1hPXRoaXMuZ2VuZXJhdGVIdWZmbWFuVGFibGUoQy5zdWJhcnJheSgwLGUpKTtzPXRoaXMuZ2VuZXJhdGVIdWZmbWFuVGFibGUoQy5zdWJhcnJheShlLGMpKX19ZT10aGlzLmJ1ZmZlcjtsZXQgbj1lP2UubGVuZ3RoOjAsbz10aGlzLmJ1ZmZlckxlbmd0aDtmb3IoOzspe2xldCBpPXRoaXMuZ2V0Q29kZShhKTtpZihpPDI1Nil7aWYobysxPj1uKXtlPXRoaXMuZW5zdXJlQnVmZmVyKG8rMSk7bj1lLmxlbmd0aH1lW28rK109aTtjb250aW51ZX1pZigyNTY9PT1pKXt0aGlzLmJ1ZmZlckxlbmd0aD1vO3JldHVybn1pLT0yNTc7aT1ZdFtpXTtsZXQgcj1pPj4xNjtyPjAmJihyPXRoaXMuZ2V0Qml0cyhyKSk7dD0oNjU1MzUmaSkrcjtpPXRoaXMuZ2V0Q29kZShzKTtpPXZ0W2ldO3I9aT4+MTY7cj4wJiYocj10aGlzLmdldEJpdHMocikpO2NvbnN0IGc9KDY1NTM1JmkpK3I7aWYobyt0Pj1uKXtlPXRoaXMuZW5zdXJlQnVmZmVyKG8rdCk7bj1lLmxlbmd0aH1mb3IobGV0IGk9MDtpPHQ7KytpLCsrbyllW29dPWVbby1nXX19fWNvbnN0IHF0PVt7cWU6MjIwMTcsbm1wczoxLG5scHM6MSxzd2l0Y2hGbGFnOjF9LHtxZToxMzMxMyxubXBzOjIsbmxwczo2LHN3aXRjaEZsYWc6MH0se3FlOjYxNDUsbm1wczozLG5scHM6OSxzd2l0Y2hGbGFnOjB9LHtxZToyNzUzLG5tcHM6NCxubHBzOjEyLHN3aXRjaEZsYWc6MH0se3FlOjEzMTMsbm1wczo1LG5scHM6Mjksc3dpdGNoRmxhZzowfSx7cWU6NTQ1LG5tcHM6MzgsbmxwczozMyxzd2l0Y2hGbGFnOjB9LHtxZToyMjAxNyxubXBzOjcsbmxwczo2LHN3aXRjaEZsYWc6MX0se3FlOjIxNTA1LG5tcHM6OCxubHBzOjE0LHN3aXRjaEZsYWc6MH0se3FlOjE4NDMzLG5tcHM6OSxubHBzOjE0LHN3aXRjaEZsYWc6MH0se3FlOjE0MzM3LG5tcHM6MTAsbmxwczoxNCxzd2l0Y2hGbGFnOjB9LHtxZToxMjI4OSxubXBzOjExLG5scHM6MTcsc3dpdGNoRmxhZzowfSx7cWU6OTIxNyxubXBzOjEyLG5scHM6MTgsc3dpdGNoRmxhZzowfSx7cWU6NzE2OSxubXBzOjEzLG5scHM6MjAsc3dpdGNoRmxhZzowfSx7cWU6NTYzMyxubXBzOjI5LG5scHM6MjEsc3dpdGNoRmxhZzowfSx7cWU6MjIwMTcsbm1wczoxNSxubHBzOjE0LHN3aXRjaEZsYWc6MX0se3FlOjIxNTA1LG5tcHM6MTYsbmxwczoxNCxzd2l0Y2hGbGFnOjB9LHtxZToyMDczNyxubXBzOjE3LG5scHM6MTUsc3dpdGNoRmxhZzowfSx7cWU6MTg0MzMsbm1wczoxOCxubHBzOjE2LHN3aXRjaEZsYWc6MH0se3FlOjE0MzM3LG5tcHM6MTksbmxwczoxNyxzd2l0Y2hGbGFnOjB9LHtxZToxMzMxMyxubXBzOjIwLG5scHM6MTgsc3dpdGNoRmxhZzowfSx7cWU6MTIyODksbm1wczoyMSxubHBzOjE5LHN3aXRjaEZsYWc6MH0se3FlOjEwMjQxLG5tcHM6MjIsbmxwczoxOSxzd2l0Y2hGbGFnOjB9LHtxZTo5MjE3LG5tcHM6MjMsbmxwczoyMCxzd2l0Y2hGbGFnOjB9LHtxZTo4NzA1LG5tcHM6MjQsbmxwczoyMSxzd2l0Y2hGbGFnOjB9LHtxZTo3MTY5LG5tcHM6MjUsbmxwczoyMixzd2l0Y2hGbGFnOjB9LHtxZTo2MTQ1LG5tcHM6MjYsbmxwczoyMyxzd2l0Y2hGbGFnOjB9LHtxZTo1NjMzLG5tcHM6MjcsbmxwczoyNCxzd2l0Y2hGbGFnOjB9LHtxZTo1MTIxLG5tcHM6MjgsbmxwczoyNSxzd2l0Y2hGbGFnOjB9LHtxZTo0NjA5LG5tcHM6MjksbmxwczoyNixzd2l0Y2hGbGFnOjB9LHtxZTo0MzUzLG5tcHM6MzAsbmxwczoyNyxzd2l0Y2hGbGFnOjB9LHtxZToyNzUzLG5tcHM6MzEsbmxwczoyOCxzd2l0Y2hGbGFnOjB9LHtxZToyNDk3LG5tcHM6MzIsbmxwczoyOSxzd2l0Y2hGbGFnOjB9LHtxZToyMjA5LG5tcHM6MzMsbmxwczozMCxzd2l0Y2hGbGFnOjB9LHtxZToxMzEzLG5tcHM6MzQsbmxwczozMSxzd2l0Y2hGbGFnOjB9LHtxZToxMDg5LG5tcHM6MzUsbmxwczozMixzd2l0Y2hGbGFnOjB9LHtxZTo2NzMsbm1wczozNixubHBzOjMzLHN3aXRjaEZsYWc6MH0se3FlOjU0NSxubXBzOjM3LG5scHM6MzQsc3dpdGNoRmxhZzowfSx7cWU6MzIxLG5tcHM6MzgsbmxwczozNSxzd2l0Y2hGbGFnOjB9LHtxZToyNzMsbm1wczozOSxubHBzOjM2LHN3aXRjaEZsYWc6MH0se3FlOjEzMyxubXBzOjQwLG5scHM6Mzcsc3dpdGNoRmxhZzowfSx7cWU6NzMsbm1wczo0MSxubHBzOjM4LHN3aXRjaEZsYWc6MH0se3FlOjM3LG5tcHM6NDIsbmxwczozOSxzd2l0Y2hGbGFnOjB9LHtxZToyMSxubXBzOjQzLG5scHM6NDAsc3dpdGNoRmxhZzowfSx7cWU6OSxubXBzOjQ0LG5scHM6NDEsc3dpdGNoRmxhZzowfSx7cWU6NSxubXBzOjQ1LG5scHM6NDIsc3dpdGNoRmxhZzowfSx7cWU6MSxubXBzOjQ1LG5scHM6NDMsc3dpdGNoRmxhZzowfSx7cWU6MjIwMTcsbm1wczo0NixubHBzOjQ2LHN3aXRjaEZsYWc6MH1dO2NsYXNzIEFyaXRobWV0aWNEZWNvZGVye2NvbnN0cnVjdG9yKGUsdCxpKXt0aGlzLmRhdGE9ZTt0aGlzLmJwPXQ7dGhpcy5kYXRhRW5kPWk7dGhpcy5jaGlnaD1lW3RdO3RoaXMuY2xvdz0wO3RoaXMuYnl0ZUluKCk7dGhpcy5jaGlnaD10aGlzLmNoaWdoPDw3JjY1NTM1fHRoaXMuY2xvdz4+OSYxMjc7dGhpcy5jbG93PXRoaXMuY2xvdzw8NyY2NTUzNTt0aGlzLmN0LT03O3RoaXMuYT0zMjc2OH1ieXRlSW4oKXtjb25zdCBlPXRoaXMuZGF0YTtsZXQgdD10aGlzLmJwO2lmKDI1NT09PWVbdF0paWYoZVt0KzFdPjE0Myl7dGhpcy5jbG93Kz02NTI4MDt0aGlzLmN0PTh9ZWxzZXt0Kys7dGhpcy5jbG93Kz1lW3RdPDw5O3RoaXMuY3Q9Nzt0aGlzLmJwPXR9ZWxzZXt0Kys7dGhpcy5jbG93Kz10PHRoaXMuZGF0YUVuZD9lW3RdPDw4OjY1MjgwO3RoaXMuY3Q9ODt0aGlzLmJwPXR9aWYodGhpcy5jbG93PjY1NTM1KXt0aGlzLmNoaWdoKz10aGlzLmNsb3c+PjE2O3RoaXMuY2xvdyY9NjU1MzV9fXJlYWRCaXQoZSx0KXtsZXQgaT1lW3RdPj4xLGE9MSZlW3RdO2NvbnN0IHM9cXRbaV0scj1zLnFlO2xldCBuLG89dGhpcy5hLXI7aWYodGhpcy5jaGlnaDxyKWlmKG88cil7bz1yO249YTtpPXMubm1wc31lbHNle289cjtuPTFeYTsxPT09cy5zd2l0Y2hGbGFnJiYoYT1uKTtpPXMubmxwc31lbHNle3RoaXMuY2hpZ2gtPXI7aWYoMCE9KDMyNzY4Jm8pKXt0aGlzLmE9bztyZXR1cm4gYX1pZihvPHIpe249MV5hOzE9PT1zLnN3aXRjaEZsYWcmJihhPW4pO2k9cy5ubHBzfWVsc2V7bj1hO2k9cy5ubXBzfX1kb3swPT09dGhpcy5jdCYmdGhpcy5ieXRlSW4oKTtvPDw9MTt0aGlzLmNoaWdoPXRoaXMuY2hpZ2g8PDEmNjU1MzV8dGhpcy5jbG93Pj4xNSYxO3RoaXMuY2xvdz10aGlzLmNsb3c8PDEmNjU1MzU7dGhpcy5jdC0tfXdoaWxlKDA9PSgzMjc2OCZvKSk7dGhpcy5hPW87ZVt0XT1pPDwxfGE7cmV0dXJuIG59fWNsYXNzIEpiaWcyRXJyb3IgZXh0ZW5kcyBydHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJKYmlnMkVycm9yIil9fWNsYXNzIENvbnRleHRDYWNoZXtnZXRDb250ZXh0cyhlKXtyZXR1cm4gZSBpbiB0aGlzP3RoaXNbZV06dGhpc1tlXT1uZXcgSW50OEFycmF5KDY1NTM2KX19Y2xhc3MgRGVjb2RpbmdDb250ZXh0e2NvbnN0cnVjdG9yKGUsdCxpKXt0aGlzLmRhdGE9ZTt0aGlzLnN0YXJ0PXQ7dGhpcy5lbmQ9aX1nZXQgZGVjb2Rlcigpe3JldHVybiBzaGFkb3codGhpcywiZGVjb2RlciIsbmV3IEFyaXRobWV0aWNEZWNvZGVyKHRoaXMuZGF0YSx0aGlzLnN0YXJ0LHRoaXMuZW5kKSl9Z2V0IGNvbnRleHRDYWNoZSgpe3JldHVybiBzaGFkb3codGhpcywiY29udGV4dENhY2hlIixuZXcgQ29udGV4dENhY2hlKX19Y29uc3QgT3Q9MioqMzEtMSxQdD0tKDIqKjMxKTtmdW5jdGlvbiBkZWNvZGVJbnRlZ2VyKGUsdCxpKXtjb25zdCBhPWUuZ2V0Q29udGV4dHModCk7bGV0IHM9MTtmdW5jdGlvbiByZWFkQml0cyhlKXtsZXQgdD0wO2ZvcihsZXQgcj0wO3I8ZTtyKyspe2NvbnN0IGU9aS5yZWFkQml0KGEscyk7cz1zPDI1Nj9zPDwxfGU6NTExJihzPDwxfGUpfDI1Njt0PXQ8PDF8ZX1yZXR1cm4gdD4+PjB9Y29uc3Qgcj1yZWFkQml0cygxKSxuPXJlYWRCaXRzKDEpP3JlYWRCaXRzKDEpP3JlYWRCaXRzKDEpP3JlYWRCaXRzKDEpP3JlYWRCaXRzKDEpP3JlYWRCaXRzKDMyKSs0NDM2OnJlYWRCaXRzKDEyKSszNDA6cmVhZEJpdHMoOCkrODQ6cmVhZEJpdHMoNikrMjA6cmVhZEJpdHMoNCkrNDpyZWFkQml0cygyKTtsZXQgbzswPT09cj9vPW46bj4wJiYobz0tbik7cmV0dXJuIG8+PVB0JiZvPD1PdD9vOm51bGx9ZnVuY3Rpb24gZGVjb2RlSUFJRChlLHQsaSl7Y29uc3QgYT1lLmdldENvbnRleHRzKCJJQUlEIik7bGV0IHM9MTtmb3IobGV0IGU9MDtlPGk7ZSsrKXtzPXM8PDF8dC5yZWFkQml0KGEscyl9cmV0dXJuIGk8MzE/cyYoMTw8aSktMToyMTQ3NDgzNjQ3JnN9Y29uc3QgV3Q9WyJTeW1ib2xEaWN0aW9uYXJ5IixudWxsLG51bGwsbnVsbCwiSW50ZXJtZWRpYXRlVGV4dFJlZ2lvbiIsbnVsbCwiSW1tZWRpYXRlVGV4dFJlZ2lvbiIsIkltbWVkaWF0ZUxvc3NsZXNzVGV4dFJlZ2lvbiIsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLCJQYXR0ZXJuRGljdGlvbmFyeSIsbnVsbCxudWxsLG51bGwsIkludGVybWVkaWF0ZUhhbGZ0b25lUmVnaW9uIixudWxsLCJJbW1lZGlhdGVIYWxmdG9uZVJlZ2lvbiIsIkltbWVkaWF0ZUxvc3NsZXNzSGFsZnRvbmVSZWdpb24iLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLCJJbnRlcm1lZGlhdGVHZW5lcmljUmVnaW9uIixudWxsLCJJbW1lZGlhdGVHZW5lcmljUmVnaW9uIiwiSW1tZWRpYXRlTG9zc2xlc3NHZW5lcmljUmVnaW9uIiwiSW50ZXJtZWRpYXRlR2VuZXJpY1JlZmluZW1lbnRSZWdpb24iLG51bGwsIkltbWVkaWF0ZUdlbmVyaWNSZWZpbmVtZW50UmVnaW9uIiwiSW1tZWRpYXRlTG9zc2xlc3NHZW5lcmljUmVmaW5lbWVudFJlZ2lvbiIsbnVsbCxudWxsLG51bGwsbnVsbCwiUGFnZUluZm9ybWF0aW9uIiwiRW5kT2ZQYWdlIiwiRW5kT2ZTdHJpcGUiLCJFbmRPZkZpbGUiLCJQcm9maWxlcyIsIlRhYmxlcyIsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLCJFeHRlbnNpb24iXSxqdD1bW3t4Oi0xLHk6LTJ9LHt4OjAseTotMn0se3g6MSx5Oi0yfSx7eDotMix5Oi0xfSx7eDotMSx5Oi0xfSx7eDowLHk6LTF9LHt4OjEseTotMX0se3g6Mix5Oi0xfSx7eDotNCx5OjB9LHt4Oi0zLHk6MH0se3g6LTIseTowfSx7eDotMSx5OjB9XSxbe3g6LTEseTotMn0se3g6MCx5Oi0yfSx7eDoxLHk6LTJ9LHt4OjIseTotMn0se3g6LTIseTotMX0se3g6LTEseTotMX0se3g6MCx5Oi0xfSx7eDoxLHk6LTF9LHt4OjIseTotMX0se3g6LTMseTowfSx7eDotMix5OjB9LHt4Oi0xLHk6MH1dLFt7eDotMSx5Oi0yfSx7eDowLHk6LTJ9LHt4OjEseTotMn0se3g6LTIseTotMX0se3g6LTEseTotMX0se3g6MCx5Oi0xfSx7eDoxLHk6LTF9LHt4Oi0yLHk6MH0se3g6LTEseTowfV0sW3t4Oi0zLHk6LTF9LHt4Oi0yLHk6LTF9LHt4Oi0xLHk6LTF9LHt4OjAseTotMX0se3g6MSx5Oi0xfSx7eDotNCx5OjB9LHt4Oi0zLHk6MH0se3g6LTIseTowfSx7eDotMSx5OjB9XV0sWHQ9W3tjb2Rpbmc6W3t4OjAseTotMX0se3g6MSx5Oi0xfSx7eDotMSx5OjB9XSxyZWZlcmVuY2U6W3t4OjAseTotMX0se3g6MSx5Oi0xfSx7eDotMSx5OjB9LHt4OjAseTowfSx7eDoxLHk6MH0se3g6LTEseToxfSx7eDowLHk6MX0se3g6MSx5OjF9XX0se2NvZGluZzpbe3g6LTEseTotMX0se3g6MCx5Oi0xfSx7eDoxLHk6LTF9LHt4Oi0xLHk6MH1dLHJlZmVyZW5jZTpbe3g6MCx5Oi0xfSx7eDotMSx5OjB9LHt4OjAseTowfSx7eDoxLHk6MH0se3g6MCx5OjF9LHt4OjEseToxfV19XSxadD1bMzk3MTcsMTk0MSwyMjksNDA1XSxWdD1bMzIsOF07ZnVuY3Rpb24gZGVjb2RlQml0bWFwKGUsdCxpLGEscyxyLG4sbyl7aWYoZSl7cmV0dXJuIGRlY29kZU1NUkJpdG1hcChuZXcgUmVhZGVyKG8uZGF0YSxvLnN0YXJ0LG8uZW5kKSx0LGksITEpfWlmKDA9PT1hJiYhciYmIXMmJjQ9PT1uLmxlbmd0aCYmMz09PW5bMF0ueCYmLTE9PT1uWzBdLnkmJi0zPT09blsxXS54JiYtMT09PW5bMV0ueSYmMj09PW5bMl0ueCYmLTI9PT1uWzJdLnkmJi0yPT09blszXS54JiYtMj09PW5bM10ueSlyZXR1cm4gZnVuY3Rpb24gZGVjb2RlQml0bWFwVGVtcGxhdGUwKGUsdCxpKXtjb25zdCBhPWkuZGVjb2RlcixzPWkuY29udGV4dENhY2hlLmdldENvbnRleHRzKCJHQiIpLHI9W107bGV0IG4sbyxnLGMsQyxoLGw7Zm9yKG89MDtvPHQ7bysrKXtDPXJbb109bmV3IFVpbnQ4QXJyYXkoZSk7aD1vPDE/QzpyW28tMV07bD1vPDI/QzpyW28tMl07bj1sWzBdPDwxM3xsWzFdPDwxMnxsWzJdPDwxMXxoWzBdPDw3fGhbMV08PDZ8aFsyXTw8NXxoWzNdPDw0O2ZvcihnPTA7ZzxlO2crKyl7Q1tnXT1jPWEucmVhZEJpdChzLG4pO249KDMxNzM1Jm4pPDwxfChnKzM8ZT9sW2crM108PDExOjApfChnKzQ8ZT9oW2crNF08PDQ6MCl8Y319cmV0dXJuIHJ9KHQsaSxvKTtjb25zdCBnPSEhcixjPWp0W2FdLmNvbmNhdChuKTtjLnNvcnQoKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUueS10Lnl8fGUueC10Lnh9KSk7Y29uc3QgQz1jLmxlbmd0aCxoPW5ldyBJbnQ4QXJyYXkoQyksbD1uZXcgSW50OEFycmF5KEMpLFE9W107bGV0IEUsdSxkPTAsZj0wLHA9MCxtPTA7Zm9yKHU9MDt1PEM7dSsrKXtoW3VdPWNbdV0ueDtsW3VdPWNbdV0ueTtmPU1hdGgubWluKGYsY1t1XS54KTtwPU1hdGgubWF4KHAsY1t1XS54KTttPU1hdGgubWluKG0sY1t1XS55KTt1PEMtMSYmY1t1XS55PT09Y1t1KzFdLnkmJmNbdV0ueD09PWNbdSsxXS54LTE/ZHw9MTw8Qy0xLXU6US5wdXNoKHUpfWNvbnN0IHk9US5sZW5ndGgsdz1uZXcgSW50OEFycmF5KHkpLGI9bmV3IEludDhBcnJheSh5KSxEPW5ldyBVaW50MTZBcnJheSh5KTtmb3IoRT0wO0U8eTtFKyspe3U9UVtFXTt3W0VdPWNbdV0ueDtiW0VdPWNbdV0ueTtEW0VdPTE8PEMtMS11fWNvbnN0IEY9LWYsUz0tbSxrPXQtcCxOPVp0W2FdO2xldCBSPW5ldyBVaW50OEFycmF5KHQpO2NvbnN0IEc9W10seD1vLmRlY29kZXIsVT1vLmNvbnRleHRDYWNoZS5nZXRDb250ZXh0cygiR0IiKTtsZXQgTSxMLEgsSixZLHY9MCxLPTA7Zm9yKGxldCBlPTA7ZTxpO2UrKyl7aWYocyl7dl49eC5yZWFkQml0KFUsTik7aWYodil7Ry5wdXNoKFIpO2NvbnRpbnVlfX1SPW5ldyBVaW50OEFycmF5KFIpO0cucHVzaChSKTtmb3IoTT0wO008dDtNKyspe2lmKGcmJnJbZV1bTV0pe1JbTV09MDtjb250aW51ZX1pZihNPj1GJiZNPGsmJmU+PVMpe0s9Szw8MSZkO2Zvcih1PTA7dTx5O3UrKyl7TD1lK2JbdV07SD1NK3dbdV07Sj1HW0xdW0hdO2lmKEope0o9RFt1XTtLfD1KfX19ZWxzZXtLPTA7WT1DLTE7Zm9yKHU9MDt1PEM7dSsrLFktLSl7SD1NK2hbdV07aWYoSD49MCYmSDx0KXtMPWUrbFt1XTtpZihMPj0wKXtKPUdbTF1bSF07SiYmKEt8PUo8PFkpfX19fWNvbnN0IGk9eC5yZWFkQml0KFUsSyk7UltNXT1pfX1yZXR1cm4gR31mdW5jdGlvbiBkZWNvZGVSZWZpbmVtZW50KGUsdCxpLGEscyxyLG4sbyxnKXtsZXQgYz1YdFtpXS5jb2Rpbmc7MD09PWkmJihjPWMuY29uY2F0KFtvWzBdXSkpO2NvbnN0IEM9Yy5sZW5ndGgsaD1uZXcgSW50MzJBcnJheShDKSxsPW5ldyBJbnQzMkFycmF5KEMpO2xldCBRO2ZvcihRPTA7UTxDO1ErKyl7aFtRXT1jW1FdLng7bFtRXT1jW1FdLnl9bGV0IEU9WHRbaV0ucmVmZXJlbmNlOzA9PT1pJiYoRT1FLmNvbmNhdChbb1sxXV0pKTtjb25zdCB1PUUubGVuZ3RoLGQ9bmV3IEludDMyQXJyYXkodSksZj1uZXcgSW50MzJBcnJheSh1KTtmb3IoUT0wO1E8dTtRKyspe2RbUV09RVtRXS54O2ZbUV09RVtRXS55fWNvbnN0IHA9YVswXS5sZW5ndGgsbT1hLmxlbmd0aCx5PVZ0W2ldLHc9W10sYj1nLmRlY29kZXIsRD1nLmNvbnRleHRDYWNoZS5nZXRDb250ZXh0cygiR1IiKTtsZXQgRj0wO2ZvcihsZXQgaT0wO2k8dDtpKyspe2lmKG4pe0ZePWIucmVhZEJpdChELHkpO2lmKEYpdGhyb3cgbmV3IEpiaWcyRXJyb3IoInByZWRpY3Rpb24gaXMgbm90IHN1cHBvcnRlZCIpfWNvbnN0IHQ9bmV3IFVpbnQ4QXJyYXkoZSk7dy5wdXNoKHQpO2ZvcihsZXQgbj0wO248ZTtuKyspe2xldCBvLGcsYz0wO2ZvcihRPTA7UTxDO1ErKyl7bz1pK2xbUV07Zz1uK2hbUV07bzwwfHxnPDB8fGc+PWU/Yzw8PTE6Yz1jPDwxfHdbb11bZ119Zm9yKFE9MDtRPHU7USsrKXtvPWkrZltRXS1yO2c9bitkW1FdLXM7bzwwfHxvPj1tfHxnPDB8fGc+PXA/Yzw8PTE6Yz1jPDwxfGFbb11bZ119Y29uc3QgRT1iLnJlYWRCaXQoRCxjKTt0W25dPUV9fXJldHVybiB3fWZ1bmN0aW9uIGRlY29kZVRleHRSZWdpb24oZSx0LGksYSxzLHIsbixvLGcsYyxDLGgsbCxRLEUsdSxkLGYscCl7aWYoZSYmdCl0aHJvdyBuZXcgSmJpZzJFcnJvcigicmVmaW5lbWVudCB3aXRoIEh1ZmZtYW4gaXMgbm90IHN1cHBvcnRlZCIpO2NvbnN0IG09W107bGV0IHksdztmb3IoeT0wO3k8YTt5Kyspe3c9bmV3IFVpbnQ4QXJyYXkoaSk7aWYocylmb3IobGV0IGU9MDtlPGk7ZSsrKXdbZV09czttLnB1c2godyl9Y29uc3QgYj1kLmRlY29kZXIsRD1kLmNvbnRleHRDYWNoZTtsZXQgRj1lPy1RLnRhYmxlRGVsdGFULmRlY29kZShwKTotZGVjb2RlSW50ZWdlcihELCJJQURUIixiKSxTPTA7eT0wO2Zvcig7eTxyOyl7Ris9ZT9RLnRhYmxlRGVsdGFULmRlY29kZShwKTpkZWNvZGVJbnRlZ2VyKEQsIklBRFQiLGIpO1MrPWU/US50YWJsZUZpcnN0Uy5kZWNvZGUocCk6ZGVjb2RlSW50ZWdlcihELCJJQUZTIixiKTtsZXQgYT1TO2Zvcig7Oyl7bGV0IHM9MDtuPjEmJihzPWU/cC5yZWFkQml0cyhmKTpkZWNvZGVJbnRlZ2VyKEQsIklBSVQiLGIpKTtjb25zdCByPW4qRitzLFM9ZT9RLnN5bWJvbElEVGFibGUuZGVjb2RlKHApOmRlY29kZUlBSUQoRCxiLGcpLGs9dCYmKGU/cC5yZWFkQml0KCk6ZGVjb2RlSW50ZWdlcihELCJJQVJJIixiKSk7bGV0IE49b1tTXSxSPU5bMF0ubGVuZ3RoLEc9Ti5sZW5ndGg7aWYoayl7Y29uc3QgZT1kZWNvZGVJbnRlZ2VyKEQsIklBUkRXIixiKSx0PWRlY29kZUludGVnZXIoRCwiSUFSREgiLGIpO1IrPWU7Rys9dDtOPWRlY29kZVJlZmluZW1lbnQoUixHLEUsTiwoZT4+MSkrZGVjb2RlSW50ZWdlcihELCJJQVJEWCIsYiksKHQ+PjEpK2RlY29kZUludGVnZXIoRCwiSUFSRFkiLGIpLCExLHUsZCl9bGV0IHg9MDtjPzEmaD94PUctMTphKz1HLTE6aD4xP2ErPVItMTp4PVItMTtjb25zdCBVPXItKDEmaD8wOkctMSksTT1hLSgyJmg/Ui0xOjApO2xldCBMLEgsSjtpZihjKWZvcihMPTA7TDxHO0wrKyl7dz1tW00rTF07aWYoIXcpY29udGludWU7Sj1OW0xdO2NvbnN0IGU9TWF0aC5taW4oaS1VLFIpO3N3aXRjaChsKXtjYXNlIDA6Zm9yKEg9MDtIPGU7SCsrKXdbVStIXXw9SltIXTticmVhaztjYXNlIDI6Zm9yKEg9MDtIPGU7SCsrKXdbVStIXV49SltIXTticmVhaztkZWZhdWx0OnRocm93IG5ldyBKYmlnMkVycm9yKGBvcGVyYXRvciAke2x9IGlzIG5vdCBzdXBwb3J0ZWRgKX19ZWxzZSBmb3IoSD0wO0g8RztIKyspe3c9bVtVK0hdO2lmKHcpe0o9TltIXTtzd2l0Y2gobCl7Y2FzZSAwOmZvcihMPTA7TDxSO0wrKyl3W00rTF18PUpbTF07YnJlYWs7Y2FzZSAyOmZvcihMPTA7TDxSO0wrKyl3W00rTF1ePUpbTF07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcihgb3BlcmF0b3IgJHtsfSBpcyBub3Qgc3VwcG9ydGVkYCl9fX15Kys7Y29uc3QgWT1lP1EudGFibGVEZWx0YVMuZGVjb2RlKHApOmRlY29kZUludGVnZXIoRCwiSUFEUyIsYik7aWYobnVsbD09PVkpYnJlYWs7YSs9eCtZK0N9fXJldHVybiBtfWZ1bmN0aW9uIHJlYWRTZWdtZW50SGVhZGVyKGUsdCl7Y29uc3QgaT17fTtpLm51bWJlcj1yZWFkVWludDMyKGUsdCk7Y29uc3QgYT1lW3QrNF0scz02MyZhO2lmKCFXdFtzXSl0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBzZWdtZW50IHR5cGU6ICIrcyk7aS50eXBlPXM7aS50eXBlTmFtZT1XdFtzXTtpLmRlZmVycmVkTm9uUmV0YWluPSEhKDEyOCZhKTtjb25zdCByPSEhKDY0JmEpLG49ZVt0KzVdO2xldCBvPW4+PjUmNztjb25zdCBnPVszMSZuXTtsZXQgYz10KzY7aWYoNz09PW4pe289NTM2ODcwOTExJnJlYWRVaW50MzIoZSxjLTEpO2MrPTM7bGV0IHQ9bys3Pj4zO2dbMF09ZVtjKytdO2Zvcig7LS10PjA7KWcucHVzaChlW2MrK10pfWVsc2UgaWYoNT09PW58fDY9PT1uKXRocm93IG5ldyBKYmlnMkVycm9yKCJpbnZhbGlkIHJlZmVycmVkLXRvIGZsYWdzIik7aS5yZXRhaW5CaXRzPWc7bGV0IEM9NDtpLm51bWJlcjw9MjU2P0M9MTppLm51bWJlcjw9NjU1MzYmJihDPTIpO2NvbnN0IGg9W107bGV0IGwsUTtmb3IobD0wO2w8bztsKyspe2xldCB0O3Q9MT09PUM/ZVtjXToyPT09Qz9yZWFkVWludDE2KGUsYyk6cmVhZFVpbnQzMihlLGMpO2gucHVzaCh0KTtjKz1DfWkucmVmZXJyZWRUbz1oO2lmKHIpe2kucGFnZUFzc29jaWF0aW9uPXJlYWRVaW50MzIoZSxjKTtjKz00fWVsc2UgaS5wYWdlQXNzb2NpYXRpb249ZVtjKytdO2kubGVuZ3RoPXJlYWRVaW50MzIoZSxjKTtjKz00O2lmKDQyOTQ5NjcyOTU9PT1pLmxlbmd0aCl7aWYoMzghPT1zKXRocm93IG5ldyBKYmlnMkVycm9yKCJpbnZhbGlkIHVua25vd24gc2VnbWVudCBsZW5ndGgiKTt7Y29uc3QgdD1yZWFkUmVnaW9uU2VnbWVudEluZm9ybWF0aW9uKGUsYyksYT0hISgxJmVbYyt6dF0pLHM9NixyPW5ldyBVaW50OEFycmF5KHMpO2lmKCFhKXtyWzBdPTI1NTtyWzFdPTE3Mn1yWzJdPXQuaGVpZ2h0Pj4+MjQmMjU1O3JbM109dC5oZWlnaHQ+PjE2JjI1NTtyWzRdPXQuaGVpZ2h0Pj44JjI1NTtyWzVdPTI1NSZ0LmhlaWdodDtmb3IobD1jLFE9ZS5sZW5ndGg7bDxRO2wrKyl7bGV0IHQ9MDtmb3IoO3Q8cyYmclt0XT09PWVbbCt0XTspdCsrO2lmKHQ9PT1zKXtpLmxlbmd0aD1sK3M7YnJlYWt9fWlmKDQyOTQ5NjcyOTU9PT1pLmxlbmd0aCl0aHJvdyBuZXcgSmJpZzJFcnJvcigic2VnbWVudCBlbmQgd2FzIG5vdCBmb3VuZCIpfX1pLmhlYWRlckVuZD1jO3JldHVybiBpfWZ1bmN0aW9uIHJlYWRTZWdtZW50cyhlLHQsaSxhKXtjb25zdCBzPVtdO2xldCByPWk7Zm9yKDtyPGE7KXtjb25zdCBpPXJlYWRTZWdtZW50SGVhZGVyKHQscik7cj1pLmhlYWRlckVuZDtjb25zdCBhPXtoZWFkZXI6aSxkYXRhOnR9O2lmKCFlLnJhbmRvbUFjY2Vzcyl7YS5zdGFydD1yO3IrPWkubGVuZ3RoO2EuZW5kPXJ9cy5wdXNoKGEpO2lmKDUxPT09aS50eXBlKWJyZWFrfWlmKGUucmFuZG9tQWNjZXNzKWZvcihsZXQgZT0wLHQ9cy5sZW5ndGg7ZTx0O2UrKyl7c1tlXS5zdGFydD1yO3IrPXNbZV0uaGVhZGVyLmxlbmd0aDtzW2VdLmVuZD1yfXJldHVybiBzfWZ1bmN0aW9uIHJlYWRSZWdpb25TZWdtZW50SW5mb3JtYXRpb24oZSx0KXtyZXR1cm57d2lkdGg6cmVhZFVpbnQzMihlLHQpLGhlaWdodDpyZWFkVWludDMyKGUsdCs0KSx4OnJlYWRVaW50MzIoZSx0KzgpLHk6cmVhZFVpbnQzMihlLHQrMTIpLGNvbWJpbmF0aW9uT3BlcmF0b3I6NyZlW3QrMTZdfX1jb25zdCB6dD0xNztmdW5jdGlvbiBwcm9jZXNzU2VnbWVudChlLHQpe2NvbnN0IGk9ZS5oZWFkZXIsYT1lLmRhdGEscz1lLmVuZDtsZXQgcixuLG8sZyxjPWUuc3RhcnQ7c3dpdGNoKGkudHlwZSl7Y2FzZSAwOmNvbnN0IGU9e30sdD1yZWFkVWludDE2KGEsYyk7ZS5odWZmbWFuPSEhKDEmdCk7ZS5yZWZpbmVtZW50PSEhKDImdCk7ZS5odWZmbWFuREhTZWxlY3Rvcj10Pj4yJjM7ZS5odWZmbWFuRFdTZWxlY3Rvcj10Pj40JjM7ZS5iaXRtYXBTaXplU2VsZWN0b3I9dD4+NiYxO2UuYWdncmVnYXRpb25JbnN0YW5jZXNTZWxlY3Rvcj10Pj43JjE7ZS5iaXRtYXBDb2RpbmdDb250ZXh0VXNlZD0hISgyNTYmdCk7ZS5iaXRtYXBDb2RpbmdDb250ZXh0UmV0YWluZWQ9ISEoNTEyJnQpO2UudGVtcGxhdGU9dD4+MTAmMztlLnJlZmluZW1lbnRUZW1wbGF0ZT10Pj4xMiYxO2MrPTI7aWYoIWUuaHVmZm1hbil7Zz0wPT09ZS50ZW1wbGF0ZT80OjE7bj1bXTtmb3Iobz0wO288ZztvKyspe24ucHVzaCh7eDpyZWFkSW50OChhLGMpLHk6cmVhZEludDgoYSxjKzEpfSk7Yys9Mn1lLmF0PW59aWYoZS5yZWZpbmVtZW50JiYhZS5yZWZpbmVtZW50VGVtcGxhdGUpe249W107Zm9yKG89MDtvPDI7bysrKXtuLnB1c2goe3g6cmVhZEludDgoYSxjKSx5OnJlYWRJbnQ4KGEsYysxKX0pO2MrPTJ9ZS5yZWZpbmVtZW50QXQ9bn1lLm51bWJlck9mRXhwb3J0ZWRTeW1ib2xzPXJlYWRVaW50MzIoYSxjKTtjKz00O2UubnVtYmVyT2ZOZXdTeW1ib2xzPXJlYWRVaW50MzIoYSxjKTtjKz00O3I9W2UsaS5udW1iZXIsaS5yZWZlcnJlZFRvLGEsYyxzXTticmVhaztjYXNlIDY6Y2FzZSA3OmNvbnN0IEM9e307Qy5pbmZvPXJlYWRSZWdpb25TZWdtZW50SW5mb3JtYXRpb24oYSxjKTtjKz16dDtjb25zdCBoPXJlYWRVaW50MTYoYSxjKTtjKz0yO0MuaHVmZm1hbj0hISgxJmgpO0MucmVmaW5lbWVudD0hISgyJmgpO0MubG9nU3RyaXBTaXplPWg+PjImMztDLnN0cmlwU2l6ZT0xPDxDLmxvZ1N0cmlwU2l6ZTtDLnJlZmVyZW5jZUNvcm5lcj1oPj40JjM7Qy50cmFuc3Bvc2VkPSEhKDY0JmgpO0MuY29tYmluYXRpb25PcGVyYXRvcj1oPj43JjM7Qy5kZWZhdWx0UGl4ZWxWYWx1ZT1oPj45JjE7Qy5kc09mZnNldD1oPDwxNz4+Mjc7Qy5yZWZpbmVtZW50VGVtcGxhdGU9aD4+MTUmMTtpZihDLmh1ZmZtYW4pe2NvbnN0IGU9cmVhZFVpbnQxNihhLGMpO2MrPTI7Qy5odWZmbWFuRlM9MyZlO0MuaHVmZm1hbkRTPWU+PjImMztDLmh1ZmZtYW5EVD1lPj40JjM7Qy5odWZmbWFuUmVmaW5lbWVudERXPWU+PjYmMztDLmh1ZmZtYW5SZWZpbmVtZW50REg9ZT4+OCYzO0MuaHVmZm1hblJlZmluZW1lbnREWD1lPj4xMCYzO0MuaHVmZm1hblJlZmluZW1lbnREWT1lPj4xMiYzO0MuaHVmZm1hblJlZmluZW1lbnRTaXplU2VsZWN0b3I9ISEoMTYzODQmZSl9aWYoQy5yZWZpbmVtZW50JiYhQy5yZWZpbmVtZW50VGVtcGxhdGUpe249W107Zm9yKG89MDtvPDI7bysrKXtuLnB1c2goe3g6cmVhZEludDgoYSxjKSx5OnJlYWRJbnQ4KGEsYysxKX0pO2MrPTJ9Qy5yZWZpbmVtZW50QXQ9bn1DLm51bWJlck9mU3ltYm9sSW5zdGFuY2VzPXJlYWRVaW50MzIoYSxjKTtjKz00O3I9W0MsaS5yZWZlcnJlZFRvLGEsYyxzXTticmVhaztjYXNlIDE2OmNvbnN0IGw9e30sUT1hW2MrK107bC5tbXI9ISEoMSZRKTtsLnRlbXBsYXRlPVE+PjEmMztsLnBhdHRlcm5XaWR0aD1hW2MrK107bC5wYXR0ZXJuSGVpZ2h0PWFbYysrXTtsLm1heFBhdHRlcm5JbmRleD1yZWFkVWludDMyKGEsYyk7Yys9NDtyPVtsLGkubnVtYmVyLGEsYyxzXTticmVhaztjYXNlIDIyOmNhc2UgMjM6Y29uc3QgRT17fTtFLmluZm89cmVhZFJlZ2lvblNlZ21lbnRJbmZvcm1hdGlvbihhLGMpO2MrPXp0O2NvbnN0IHU9YVtjKytdO0UubW1yPSEhKDEmdSk7RS50ZW1wbGF0ZT11Pj4xJjM7RS5lbmFibGVTa2lwPSEhKDgmdSk7RS5jb21iaW5hdGlvbk9wZXJhdG9yPXU+PjQmNztFLmRlZmF1bHRQaXhlbFZhbHVlPXU+PjcmMTtFLmdyaWRXaWR0aD1yZWFkVWludDMyKGEsYyk7Yys9NDtFLmdyaWRIZWlnaHQ9cmVhZFVpbnQzMihhLGMpO2MrPTQ7RS5ncmlkT2Zmc2V0WD00Mjk0OTY3Mjk1JnJlYWRVaW50MzIoYSxjKTtjKz00O0UuZ3JpZE9mZnNldFk9NDI5NDk2NzI5NSZyZWFkVWludDMyKGEsYyk7Yys9NDtFLmdyaWRWZWN0b3JYPXJlYWRVaW50MTYoYSxjKTtjKz0yO0UuZ3JpZFZlY3Rvclk9cmVhZFVpbnQxNihhLGMpO2MrPTI7cj1bRSxpLnJlZmVycmVkVG8sYSxjLHNdO2JyZWFrO2Nhc2UgMzg6Y2FzZSAzOTpjb25zdCBkPXt9O2QuaW5mbz1yZWFkUmVnaW9uU2VnbWVudEluZm9ybWF0aW9uKGEsYyk7Yys9enQ7Y29uc3QgZj1hW2MrK107ZC5tbXI9ISEoMSZmKTtkLnRlbXBsYXRlPWY+PjEmMztkLnByZWRpY3Rpb249ISEoOCZmKTtpZighZC5tbXIpe2c9MD09PWQudGVtcGxhdGU/NDoxO249W107Zm9yKG89MDtvPGc7bysrKXtuLnB1c2goe3g6cmVhZEludDgoYSxjKSx5OnJlYWRJbnQ4KGEsYysxKX0pO2MrPTJ9ZC5hdD1ufXI9W2QsYSxjLHNdO2JyZWFrO2Nhc2UgNDg6Y29uc3QgcD17d2lkdGg6cmVhZFVpbnQzMihhLGMpLGhlaWdodDpyZWFkVWludDMyKGEsYys0KSxyZXNvbHV0aW9uWDpyZWFkVWludDMyKGEsYys4KSxyZXNvbHV0aW9uWTpyZWFkVWludDMyKGEsYysxMil9OzQyOTQ5NjcyOTU9PT1wLmhlaWdodCYmZGVsZXRlIHAuaGVpZ2h0O2NvbnN0IG09YVtjKzE2XTtyZWFkVWludDE2KGEsYysxNyk7cC5sb3NzbGVzcz0hISgxJm0pO3AucmVmaW5lbWVudD0hISgyJm0pO3AuZGVmYXVsdFBpeGVsVmFsdWU9bT4+MiYxO3AuY29tYmluYXRpb25PcGVyYXRvcj1tPj4zJjM7cC5yZXF1aXJlc0J1ZmZlcj0hISgzMiZtKTtwLmNvbWJpbmF0aW9uT3BlcmF0b3JPdmVycmlkZT0hISg2NCZtKTtyPVtwXTticmVhaztjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDYyOmJyZWFrO2Nhc2UgNTM6cj1baS5udW1iZXIsYSxjLHNdO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoYHNlZ21lbnQgdHlwZSAke2kudHlwZU5hbWV9KCR7aS50eXBlfSkgaXMgbm90IGltcGxlbWVudGVkYCl9Y29uc3QgQz0ib24iK2kudHlwZU5hbWU7QyBpbiB0JiZ0W0NdLmFwcGx5KHQscil9ZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnRzKGUsdCl7Zm9yKGxldCBpPTAsYT1lLmxlbmd0aDtpPGE7aSsrKXByb2Nlc3NTZWdtZW50KGVbaV0sdCl9Y2xhc3MgU2ltcGxlU2VnbWVudFZpc2l0b3J7b25QYWdlSW5mb3JtYXRpb24oZSl7dGhpcy5jdXJyZW50UGFnZUluZm89ZTtjb25zdCB0PWUud2lkdGgrNz4+MyxpPW5ldyBVaW50OENsYW1wZWRBcnJheSh0KmUuaGVpZ2h0KTtlLmRlZmF1bHRQaXhlbFZhbHVlJiZpLmZpbGwoMjU1KTt0aGlzLmJ1ZmZlcj1pfWRyYXdCaXRtYXAoZSx0KXtjb25zdCBpPXRoaXMuY3VycmVudFBhZ2VJbmZvLGE9ZS53aWR0aCxzPWUuaGVpZ2h0LHI9aS53aWR0aCs3Pj4zLG49aS5jb21iaW5hdGlvbk9wZXJhdG9yT3ZlcnJpZGU/ZS5jb21iaW5hdGlvbk9wZXJhdG9yOmkuY29tYmluYXRpb25PcGVyYXRvcixvPXRoaXMuYnVmZmVyLGc9MTI4Pj4oNyZlLngpO2xldCBjLEMsaCxsLFE9ZS55KnIrKGUueD4+Myk7c3dpdGNoKG4pe2Nhc2UgMDpmb3IoYz0wO2M8cztjKyspe2g9ZztsPVE7Zm9yKEM9MDtDPGE7QysrKXt0W2NdW0NdJiYob1tsXXw9aCk7aD4+PTE7aWYoIWgpe2g9MTI4O2wrK319USs9cn1icmVhaztjYXNlIDI6Zm9yKGM9MDtjPHM7YysrKXtoPWc7bD1RO2ZvcihDPTA7QzxhO0MrKyl7dFtjXVtDXSYmKG9bbF1ePWgpO2g+Pj0xO2lmKCFoKXtoPTEyODtsKyt9fVErPXJ9YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcihgb3BlcmF0b3IgJHtufSBpcyBub3Qgc3VwcG9ydGVkYCl9fW9uSW1tZWRpYXRlR2VuZXJpY1JlZ2lvbihlLHQsaSxhKXtjb25zdCBzPWUuaW5mbyxyPW5ldyBEZWNvZGluZ0NvbnRleHQodCxpLGEpLG49ZGVjb2RlQml0bWFwKGUubW1yLHMud2lkdGgscy5oZWlnaHQsZS50ZW1wbGF0ZSxlLnByZWRpY3Rpb24sbnVsbCxlLmF0LHIpO3RoaXMuZHJhd0JpdG1hcChzLG4pfW9uSW1tZWRpYXRlTG9zc2xlc3NHZW5lcmljUmVnaW9uKCl7dGhpcy5vbkltbWVkaWF0ZUdlbmVyaWNSZWdpb24oLi4uYXJndW1lbnRzKX1vblN5bWJvbERpY3Rpb25hcnkoZSx0LGksYSxzLHIpe2xldCBuLG87aWYoZS5odWZmbWFuKXtuPWZ1bmN0aW9uIGdldFN5bWJvbERpY3Rpb25hcnlIdWZmbWFuVGFibGVzKGUsdCxpKXtsZXQgYSxzLHIsbixvPTA7c3dpdGNoKGUuaHVmZm1hbkRIU2VsZWN0b3Ipe2Nhc2UgMDpjYXNlIDE6YT1nZXRTdGFuZGFyZFRhYmxlKGUuaHVmZm1hbkRIU2VsZWN0b3IrNCk7YnJlYWs7Y2FzZSAzOmE9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKG8sdCxpKTtvKys7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBIdWZmbWFuIERIIHNlbGVjdG9yIil9c3dpdGNoKGUuaHVmZm1hbkRXU2VsZWN0b3Ipe2Nhc2UgMDpjYXNlIDE6cz1nZXRTdGFuZGFyZFRhYmxlKGUuaHVmZm1hbkRXU2VsZWN0b3IrMik7YnJlYWs7Y2FzZSAzOnM9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKG8sdCxpKTtvKys7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBIdWZmbWFuIERXIHNlbGVjdG9yIil9aWYoZS5iaXRtYXBTaXplU2VsZWN0b3Ipe3I9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKG8sdCxpKTtvKyt9ZWxzZSByPWdldFN0YW5kYXJkVGFibGUoMSk7bj1lLmFnZ3JlZ2F0aW9uSW5zdGFuY2VzU2VsZWN0b3I/Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKG8sdCxpKTpnZXRTdGFuZGFyZFRhYmxlKDEpO3JldHVybnt0YWJsZURlbHRhSGVpZ2h0OmEsdGFibGVEZWx0YVdpZHRoOnMsdGFibGVCaXRtYXBTaXplOnIsdGFibGVBZ2dyZWdhdGVJbnN0YW5jZXM6bn19KGUsaSx0aGlzLmN1c3RvbVRhYmxlcyk7bz1uZXcgUmVhZGVyKGEscyxyKX1sZXQgZz10aGlzLnN5bWJvbHM7Z3x8KHRoaXMuc3ltYm9scz1nPXt9KTtjb25zdCBjPVtdO2Zvcihjb25zdCBlIG9mIGkpe2NvbnN0IHQ9Z1tlXTt0JiZjLnB1c2goLi4udCl9Y29uc3QgQz1uZXcgRGVjb2RpbmdDb250ZXh0KGEscyxyKTtnW3RdPWZ1bmN0aW9uIGRlY29kZVN5bWJvbERpY3Rpb25hcnkoZSx0LGksYSxzLHIsbixvLGcsYyxDLGgpe2lmKGUmJnQpdGhyb3cgbmV3IEpiaWcyRXJyb3IoInN5bWJvbCByZWZpbmVtZW50IHdpdGggSHVmZm1hbiBpcyBub3Qgc3VwcG9ydGVkIik7Y29uc3QgbD1bXTtsZXQgUT0wLEU9bG9nMihpLmxlbmd0aCthKTtjb25zdCB1PUMuZGVjb2RlcixkPUMuY29udGV4dENhY2hlO2xldCBmLHA7aWYoZSl7Zj1nZXRTdGFuZGFyZFRhYmxlKDEpO3A9W107RT1NYXRoLm1heChFLDEpfWZvcig7bC5sZW5ndGg8YTspe1ErPWU/ci50YWJsZURlbHRhSGVpZ2h0LmRlY29kZShoKTpkZWNvZGVJbnRlZ2VyKGQsIklBREgiLHUpO2xldCBhPTAscz0wO2NvbnN0IGY9ZT9wLmxlbmd0aDowO2Zvcig7Oyl7Y29uc3QgZj1lP3IudGFibGVEZWx0YVdpZHRoLmRlY29kZShoKTpkZWNvZGVJbnRlZ2VyKGQsIklBRFciLHUpO2lmKG51bGw9PT1mKWJyZWFrO2ErPWY7cys9YTtsZXQgbTtpZih0KXtjb25zdCBzPWRlY29kZUludGVnZXIoZCwiSUFBSSIsdSk7aWYocz4xKW09ZGVjb2RlVGV4dFJlZ2lvbihlLHQsYSxRLDAscywxLGkuY29uY2F0KGwpLEUsMCwwLDEsMCxyLGcsYyxDLDAsaCk7ZWxzZXtjb25zdCBlPWRlY29kZUlBSUQoZCx1LEUpLHQ9ZGVjb2RlSW50ZWdlcihkLCJJQVJEWCIsdSkscz1kZWNvZGVJbnRlZ2VyKGQsIklBUkRZIix1KTttPWRlY29kZVJlZmluZW1lbnQoYSxRLGcsZTxpLmxlbmd0aD9pW2VdOmxbZS1pLmxlbmd0aF0sdCxzLCExLGMsQyl9bC5wdXNoKG0pfWVsc2UgaWYoZSlwLnB1c2goYSk7ZWxzZXttPWRlY29kZUJpdG1hcCghMSxhLFEsbiwhMSxudWxsLG8sQyk7bC5wdXNoKG0pfX1pZihlJiYhdCl7Y29uc3QgZT1yLnRhYmxlQml0bWFwU2l6ZS5kZWNvZGUoaCk7aC5ieXRlQWxpZ24oKTtsZXQgdDtpZigwPT09ZSl0PXJlYWRVbmNvbXByZXNzZWRCaXRtYXAoaCxzLFEpO2Vsc2V7Y29uc3QgaT1oLmVuZCxhPWgucG9zaXRpb24rZTtoLmVuZD1hO3Q9ZGVjb2RlTU1SQml0bWFwKGgscyxRLCExKTtoLmVuZD1pO2gucG9zaXRpb249YX1jb25zdCBpPXAubGVuZ3RoO2lmKGY9PT1pLTEpbC5wdXNoKHQpO2Vsc2V7bGV0IGUsYSxzLHIsbixvPTA7Zm9yKGU9ZjtlPGk7ZSsrKXtyPXBbZV07cz1vK3I7bj1bXTtmb3IoYT0wO2E8UTthKyspbi5wdXNoKHRbYV0uc3ViYXJyYXkobyxzKSk7bC5wdXNoKG4pO289c319fX1jb25zdCBtPVtdLHk9W107bGV0IHcsYixEPSExO2NvbnN0IEY9aS5sZW5ndGgrYTtmb3IoO3kubGVuZ3RoPEY7KXtsZXQgdD1lP2YuZGVjb2RlKGgpOmRlY29kZUludGVnZXIoZCwiSUFFWCIsdSk7Zm9yKDt0LS07KXkucHVzaChEKTtEPSFEfWZvcih3PTAsYj1pLmxlbmd0aDt3PGI7dysrKXlbd10mJm0ucHVzaChpW3ddKTtmb3IobGV0IGU9MDtlPGE7dysrLGUrKyl5W3ddJiZtLnB1c2gobFtlXSk7cmV0dXJuIG19KGUuaHVmZm1hbixlLnJlZmluZW1lbnQsYyxlLm51bWJlck9mTmV3U3ltYm9scyxlLm51bWJlck9mRXhwb3J0ZWRTeW1ib2xzLG4sZS50ZW1wbGF0ZSxlLmF0LGUucmVmaW5lbWVudFRlbXBsYXRlLGUucmVmaW5lbWVudEF0LEMsbyl9b25JbW1lZGlhdGVUZXh0UmVnaW9uKGUsdCxpLGEscyl7Y29uc3Qgcj1lLmluZm87bGV0IG4sbztjb25zdCBnPXRoaXMuc3ltYm9scyxjPVtdO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9Z1tlXTt0JiZjLnB1c2goLi4udCl9Y29uc3QgQz1sb2cyKGMubGVuZ3RoKTtpZihlLmh1ZmZtYW4pe289bmV3IFJlYWRlcihpLGEscyk7bj1mdW5jdGlvbiBnZXRUZXh0UmVnaW9uSHVmZm1hblRhYmxlcyhlLHQsaSxhLHMpe2NvbnN0IHI9W107Zm9yKGxldCBlPTA7ZTw9MzQ7ZSsrKXtjb25zdCB0PXMucmVhZEJpdHMoNCk7ci5wdXNoKG5ldyBIdWZmbWFuTGluZShbZSx0LDAsMF0pKX1jb25zdCBuPW5ldyBIdWZmbWFuVGFibGUociwhMSk7ci5sZW5ndGg9MDtmb3IobGV0IGU9MDtlPGE7KXtjb25zdCB0PW4uZGVjb2RlKHMpO2lmKHQ+PTMyKXtsZXQgaSxhLG47c3dpdGNoKHQpe2Nhc2UgMzI6aWYoMD09PWUpdGhyb3cgbmV3IEpiaWcyRXJyb3IoIm5vIHByZXZpb3VzIHZhbHVlIGluIHN5bWJvbCBJRCB0YWJsZSIpO2E9cy5yZWFkQml0cygyKSszO2k9cltlLTFdLnByZWZpeExlbmd0aDticmVhaztjYXNlIDMzOmE9cy5yZWFkQml0cygzKSszO2k9MDticmVhaztjYXNlIDM0OmE9cy5yZWFkQml0cyg3KSsxMTtpPTA7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBjb2RlIGxlbmd0aCBpbiBzeW1ib2wgSUQgdGFibGUiKX1mb3Iobj0wO248YTtuKyspe3IucHVzaChuZXcgSHVmZm1hbkxpbmUoW2UsaSwwLDBdKSk7ZSsrfX1lbHNle3IucHVzaChuZXcgSHVmZm1hbkxpbmUoW2UsdCwwLDBdKSk7ZSsrfX1zLmJ5dGVBbGlnbigpO2NvbnN0IG89bmV3IEh1ZmZtYW5UYWJsZShyLCExKTtsZXQgZyxjLEMsaD0wO3N3aXRjaChlLmh1ZmZtYW5GUyl7Y2FzZSAwOmNhc2UgMTpnPWdldFN0YW5kYXJkVGFibGUoZS5odWZmbWFuRlMrNik7YnJlYWs7Y2FzZSAzOmc9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKGgsdCxpKTtoKys7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBIdWZmbWFuIEZTIHNlbGVjdG9yIil9c3dpdGNoKGUuaHVmZm1hbkRTKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpjPWdldFN0YW5kYXJkVGFibGUoZS5odWZmbWFuRFMrOCk7YnJlYWs7Y2FzZSAzOmM9Z2V0Q3VzdG9tSHVmZm1hblRhYmxlKGgsdCxpKTtoKys7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcigiaW52YWxpZCBIdWZmbWFuIERTIHNlbGVjdG9yIil9c3dpdGNoKGUuaHVmZm1hbkRUKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpDPWdldFN0YW5kYXJkVGFibGUoZS5odWZmbWFuRFQrMTEpO2JyZWFrO2Nhc2UgMzpDPWdldEN1c3RvbUh1ZmZtYW5UYWJsZShoLHQsaSk7aCsrO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgSHVmZm1hbiBEVCBzZWxlY3RvciIpfWlmKGUucmVmaW5lbWVudCl0aHJvdyBuZXcgSmJpZzJFcnJvcigicmVmaW5lbWVudCB3aXRoIEh1ZmZtYW4gaXMgbm90IHN1cHBvcnRlZCIpO3JldHVybntzeW1ib2xJRFRhYmxlOm8sdGFibGVGaXJzdFM6Zyx0YWJsZURlbHRhUzpjLHRhYmxlRGVsdGFUOkN9fShlLHQsdGhpcy5jdXN0b21UYWJsZXMsYy5sZW5ndGgsbyl9Y29uc3QgaD1uZXcgRGVjb2RpbmdDb250ZXh0KGksYSxzKSxsPWRlY29kZVRleHRSZWdpb24oZS5odWZmbWFuLGUucmVmaW5lbWVudCxyLndpZHRoLHIuaGVpZ2h0LGUuZGVmYXVsdFBpeGVsVmFsdWUsZS5udW1iZXJPZlN5bWJvbEluc3RhbmNlcyxlLnN0cmlwU2l6ZSxjLEMsZS50cmFuc3Bvc2VkLGUuZHNPZmZzZXQsZS5yZWZlcmVuY2VDb3JuZXIsZS5jb21iaW5hdGlvbk9wZXJhdG9yLG4sZS5yZWZpbmVtZW50VGVtcGxhdGUsZS5yZWZpbmVtZW50QXQsaCxlLmxvZ1N0cmlwU2l6ZSxvKTt0aGlzLmRyYXdCaXRtYXAocixsKX1vbkltbWVkaWF0ZUxvc3NsZXNzVGV4dFJlZ2lvbigpe3RoaXMub25JbW1lZGlhdGVUZXh0UmVnaW9uKC4uLmFyZ3VtZW50cyl9b25QYXR0ZXJuRGljdGlvbmFyeShlLHQsaSxhLHMpe2xldCByPXRoaXMucGF0dGVybnM7cnx8KHRoaXMucGF0dGVybnM9cj17fSk7Y29uc3Qgbj1uZXcgRGVjb2RpbmdDb250ZXh0KGksYSxzKTtyW3RdPWZ1bmN0aW9uIGRlY29kZVBhdHRlcm5EaWN0aW9uYXJ5KGUsdCxpLGEscyxyKXtjb25zdCBuPVtdO2lmKCFlKXtuLnB1c2goe3g6LXQseTowfSk7MD09PXMmJm4ucHVzaCh7eDotMyx5Oi0xfSx7eDoyLHk6LTJ9LHt4Oi0yLHk6LTJ9KX1jb25zdCBvPWRlY29kZUJpdG1hcChlLChhKzEpKnQsaSxzLCExLG51bGwsbixyKSxnPVtdO2ZvcihsZXQgZT0wO2U8PWE7ZSsrKXtjb25zdCBhPVtdLHM9dCplLHI9cyt0O2ZvcihsZXQgZT0wO2U8aTtlKyspYS5wdXNoKG9bZV0uc3ViYXJyYXkocyxyKSk7Zy5wdXNoKGEpfXJldHVybiBnfShlLm1tcixlLnBhdHRlcm5XaWR0aCxlLnBhdHRlcm5IZWlnaHQsZS5tYXhQYXR0ZXJuSW5kZXgsZS50ZW1wbGF0ZSxuKX1vbkltbWVkaWF0ZUhhbGZ0b25lUmVnaW9uKGUsdCxpLGEscyl7Y29uc3Qgcj10aGlzLnBhdHRlcm5zW3RbMF1dLG49ZS5pbmZvLG89bmV3IERlY29kaW5nQ29udGV4dChpLGEscyksZz1mdW5jdGlvbiBkZWNvZGVIYWxmdG9uZVJlZ2lvbihlLHQsaSxhLHMscixuLG8sZyxjLEMsaCxsLFEsRSl7aWYobil0aHJvdyBuZXcgSmJpZzJFcnJvcigic2tpcCBpcyBub3Qgc3VwcG9ydGVkIik7aWYoMCE9PW8pdGhyb3cgbmV3IEpiaWcyRXJyb3IoYG9wZXJhdG9yICIke299IiBpcyBub3Qgc3VwcG9ydGVkIGluIGhhbGZ0b25lIHJlZ2lvbmApO2NvbnN0IHU9W107bGV0IGQsZixwO2ZvcihkPTA7ZDxzO2QrKyl7cD1uZXcgVWludDhBcnJheShhKTtpZihyKWZvcihmPTA7ZjxhO2YrKylwW2ZdPXI7dS5wdXNoKHApfWNvbnN0IG09dC5sZW5ndGgseT10WzBdLHc9eVswXS5sZW5ndGgsYj15Lmxlbmd0aCxEPWxvZzIobSksRj1bXTtpZighZSl7Ri5wdXNoKHt4Omk8PTE/MzoyLHk6LTF9KTswPT09aSYmRi5wdXNoKHt4Oi0zLHk6LTF9LHt4OjIseTotMn0se3g6LTIseTotMn0pfWNvbnN0IFM9W107bGV0IGssTixSLEcseCxVLE0sTCxILEosWTtlJiYoaz1uZXcgUmVhZGVyKEUuZGF0YSxFLnN0YXJ0LEUuZW5kKSk7Zm9yKGQ9RC0xO2Q+PTA7ZC0tKXtOPWU/ZGVjb2RlTU1SQml0bWFwKGssZyxjLCEwKTpkZWNvZGVCaXRtYXAoITEsZyxjLGksITEsbnVsbCxGLEUpO1NbZF09Tn1mb3IoUj0wO1I8YztSKyspZm9yKEc9MDtHPGc7RysrKXt4PTA7VT0wO2ZvcihmPUQtMTtmPj0wO2YtLSl7eF49U1tmXVtSXVtHXTtVfD14PDxmfU09dFtVXTtMPUMrUipRK0cqbD4+ODtIPWgrUipsLUcqUT4+ODtpZihMPj0wJiZMK3c8PWEmJkg+PTAmJkgrYjw9cylmb3IoZD0wO2Q8YjtkKyspe1k9dVtIK2RdO0o9TVtkXTtmb3IoZj0wO2Y8dztmKyspWVtMK2ZdfD1KW2ZdfWVsc2V7bGV0IGUsdDtmb3IoZD0wO2Q8YjtkKyspe3Q9SCtkO2lmKCEodDwwfHx0Pj1zKSl7WT11W3RdO0o9TVtkXTtmb3IoZj0wO2Y8dztmKyspe2U9TCtmO2U+PTAmJmU8YSYmKFlbZV18PUpbZl0pfX19fX1yZXR1cm4gdX0oZS5tbXIscixlLnRlbXBsYXRlLG4ud2lkdGgsbi5oZWlnaHQsZS5kZWZhdWx0UGl4ZWxWYWx1ZSxlLmVuYWJsZVNraXAsZS5jb21iaW5hdGlvbk9wZXJhdG9yLGUuZ3JpZFdpZHRoLGUuZ3JpZEhlaWdodCxlLmdyaWRPZmZzZXRYLGUuZ3JpZE9mZnNldFksZS5ncmlkVmVjdG9yWCxlLmdyaWRWZWN0b3JZLG8pO3RoaXMuZHJhd0JpdG1hcChuLGcpfW9uSW1tZWRpYXRlTG9zc2xlc3NIYWxmdG9uZVJlZ2lvbigpe3RoaXMub25JbW1lZGlhdGVIYWxmdG9uZVJlZ2lvbiguLi5hcmd1bWVudHMpfW9uVGFibGVzKGUsdCxpLGEpe2xldCBzPXRoaXMuY3VzdG9tVGFibGVzO3N8fCh0aGlzLmN1c3RvbVRhYmxlcz1zPXt9KTtzW2VdPWZ1bmN0aW9uIGRlY29kZVRhYmxlc1NlZ21lbnQoZSx0LGkpe2NvbnN0IGE9ZVt0XSxzPTQyOTQ5NjcyOTUmcmVhZFVpbnQzMihlLHQrMSkscj00Mjk0OTY3Mjk1JnJlYWRVaW50MzIoZSx0KzUpLG49bmV3IFJlYWRlcihlLHQrOSxpKSxvPTErKGE+PjEmNyksZz0xKyhhPj40JjcpLGM9W107bGV0IEMsaCxsPXM7ZG97Qz1uLnJlYWRCaXRzKG8pO2g9bi5yZWFkQml0cyhnKTtjLnB1c2gobmV3IEh1ZmZtYW5MaW5lKFtsLEMsaCwwXSkpO2wrPTE8PGh9d2hpbGUobDxyKTtDPW4ucmVhZEJpdHMobyk7Yy5wdXNoKG5ldyBIdWZmbWFuTGluZShbcy0xLEMsMzIsMCwibG93ZXIiXSkpO0M9bi5yZWFkQml0cyhvKTtjLnB1c2gobmV3IEh1ZmZtYW5MaW5lKFtyLEMsMzIsMF0pKTtpZigxJmEpe0M9bi5yZWFkQml0cyhvKTtjLnB1c2gobmV3IEh1ZmZtYW5MaW5lKFtDLDBdKSl9cmV0dXJuIG5ldyBIdWZmbWFuVGFibGUoYywhMSl9KHQsaSxhKX19Y2xhc3MgSHVmZm1hbkxpbmV7Y29uc3RydWN0b3IoZSl7aWYoMj09PWUubGVuZ3RoKXt0aGlzLmlzT09CPSEwO3RoaXMucmFuZ2VMb3c9MDt0aGlzLnByZWZpeExlbmd0aD1lWzBdO3RoaXMucmFuZ2VMZW5ndGg9MDt0aGlzLnByZWZpeENvZGU9ZVsxXTt0aGlzLmlzTG93ZXJSYW5nZT0hMX1lbHNle3RoaXMuaXNPT0I9ITE7dGhpcy5yYW5nZUxvdz1lWzBdO3RoaXMucHJlZml4TGVuZ3RoPWVbMV07dGhpcy5yYW5nZUxlbmd0aD1lWzJdO3RoaXMucHJlZml4Q29kZT1lWzNdO3RoaXMuaXNMb3dlclJhbmdlPSJsb3dlciI9PT1lWzRdfX19Y2xhc3MgSHVmZm1hblRyZWVOb2Rle2NvbnN0cnVjdG9yKGUpe3RoaXMuY2hpbGRyZW49W107aWYoZSl7dGhpcy5pc0xlYWY9ITA7dGhpcy5yYW5nZUxlbmd0aD1lLnJhbmdlTGVuZ3RoO3RoaXMucmFuZ2VMb3c9ZS5yYW5nZUxvdzt0aGlzLmlzTG93ZXJSYW5nZT1lLmlzTG93ZXJSYW5nZTt0aGlzLmlzT09CPWUuaXNPT0J9ZWxzZSB0aGlzLmlzTGVhZj0hMX1idWlsZFRyZWUoZSx0KXtjb25zdCBpPWUucHJlZml4Q29kZT4+dCYxO2lmKHQ8PTApdGhpcy5jaGlsZHJlbltpXT1uZXcgSHVmZm1hblRyZWVOb2RlKGUpO2Vsc2V7bGV0IGE9dGhpcy5jaGlsZHJlbltpXTthfHwodGhpcy5jaGlsZHJlbltpXT1hPW5ldyBIdWZmbWFuVHJlZU5vZGUobnVsbCkpO2EuYnVpbGRUcmVlKGUsdC0xKX19ZGVjb2RlTm9kZShlKXtpZih0aGlzLmlzTGVhZil7aWYodGhpcy5pc09PQilyZXR1cm4gbnVsbDtjb25zdCB0PWUucmVhZEJpdHModGhpcy5yYW5nZUxlbmd0aCk7cmV0dXJuIHRoaXMucmFuZ2VMb3crKHRoaXMuaXNMb3dlclJhbmdlPy10OnQpfWNvbnN0IHQ9dGhpcy5jaGlsZHJlbltlLnJlYWRCaXQoKV07aWYoIXQpdGhyb3cgbmV3IEpiaWcyRXJyb3IoImludmFsaWQgSHVmZm1hbiBkYXRhIik7cmV0dXJuIHQuZGVjb2RlTm9kZShlKX19Y2xhc3MgSHVmZm1hblRhYmxle2NvbnN0cnVjdG9yKGUsdCl7dHx8dGhpcy5hc3NpZ25QcmVmaXhDb2RlcyhlKTt0aGlzLnJvb3ROb2RlPW5ldyBIdWZmbWFuVHJlZU5vZGUobnVsbCk7Zm9yKGxldCB0PTAsaT1lLmxlbmd0aDt0PGk7dCsrKXtjb25zdCBpPWVbdF07aS5wcmVmaXhMZW5ndGg+MCYmdGhpcy5yb290Tm9kZS5idWlsZFRyZWUoaSxpLnByZWZpeExlbmd0aC0xKX19ZGVjb2RlKGUpe3JldHVybiB0aGlzLnJvb3ROb2RlLmRlY29kZU5vZGUoZSl9YXNzaWduUHJlZml4Q29kZXMoZSl7Y29uc3QgdD1lLmxlbmd0aDtsZXQgaT0wO2ZvcihsZXQgYT0wO2E8dDthKyspaT1NYXRoLm1heChpLGVbYV0ucHJlZml4TGVuZ3RoKTtjb25zdCBhPW5ldyBVaW50MzJBcnJheShpKzEpO2ZvcihsZXQgaT0wO2k8dDtpKyspYVtlW2ldLnByZWZpeExlbmd0aF0rKztsZXQgcyxyLG4sbz0xLGc9MDthWzBdPTA7Zm9yKDtvPD1pOyl7Zz1nK2Fbby0xXTw8MTtzPWc7cj0wO2Zvcig7cjx0Oyl7bj1lW3JdO2lmKG4ucHJlZml4TGVuZ3RoPT09byl7bi5wcmVmaXhDb2RlPXM7cysrfXIrK31vKyt9fX1jb25zdCBfdD17fTtmdW5jdGlvbiBnZXRTdGFuZGFyZFRhYmxlKGUpe2xldCB0LGk9X3RbZV07aWYoaSlyZXR1cm4gaTtzd2l0Y2goZSl7Y2FzZSAxOnQ9W1swLDEsNCwwXSxbMTYsMiw4LDJdLFsyNzIsMywxNiw2XSxbNjU4MDgsMywzMiw3XV07YnJlYWs7Y2FzZSAyOnQ9W1swLDEsMCwwXSxbMSwyLDAsMl0sWzIsMywwLDZdLFszLDQsMywxNF0sWzExLDUsNiwzMF0sWzc1LDYsMzIsNjJdLFs2LDYzXV07YnJlYWs7Y2FzZSAzOnQ9W1stMjU2LDgsOCwyNTRdLFswLDEsMCwwXSxbMSwyLDAsMl0sWzIsMywwLDZdLFszLDQsMywxNF0sWzExLDUsNiwzMF0sWy0yNTcsOCwzMiwyNTUsImxvd2VyIl0sWzc1LDcsMzIsMTI2XSxbNiw2Ml1dO2JyZWFrO2Nhc2UgNDp0PVtbMSwxLDAsMF0sWzIsMiwwLDJdLFszLDMsMCw2XSxbNCw0LDMsMTRdLFsxMiw1LDYsMzBdLFs3Niw1LDMyLDMxXV07YnJlYWs7Y2FzZSA1OnQ9W1stMjU1LDcsOCwxMjZdLFsxLDEsMCwwXSxbMiwyLDAsMl0sWzMsMywwLDZdLFs0LDQsMywxNF0sWzEyLDUsNiwzMF0sWy0yNTYsNywzMiwxMjcsImxvd2VyIl0sWzc2LDYsMzIsNjJdXTticmVhaztjYXNlIDY6dD1bWy0yMDQ4LDUsMTAsMjhdLFstMTAyNCw0LDksOF0sWy01MTIsNCw4LDldLFstMjU2LDQsNywxMF0sWy0xMjgsNSw2LDI5XSxbLTY0LDUsNSwzMF0sWy0zMiw0LDUsMTFdLFswLDIsNywwXSxbMTI4LDMsNywyXSxbMjU2LDMsOCwzXSxbNTEyLDQsOSwxMl0sWzEwMjQsNCwxMCwxM10sWy0yMDQ5LDYsMzIsNjIsImxvd2VyIl0sWzIwNDgsNiwzMiw2M11dO2JyZWFrO2Nhc2UgNzp0PVtbLTEwMjQsNCw5LDhdLFstNTEyLDMsOCwwXSxbLTI1Niw0LDcsOV0sWy0xMjgsNSw2LDI2XSxbLTY0LDUsNSwyN10sWy0zMiw0LDUsMTBdLFswLDQsNSwxMV0sWzMyLDUsNSwyOF0sWzY0LDUsNiwyOV0sWzEyOCw0LDcsMTJdLFsyNTYsMyw4LDFdLFs1MTIsMyw5LDJdLFsxMDI0LDMsMTAsM10sWy0xMDI1LDUsMzIsMzAsImxvd2VyIl0sWzIwNDgsNSwzMiwzMV1dO2JyZWFrO2Nhc2UgODp0PVtbLTE1LDgsMywyNTJdLFstNyw5LDEsNTA4XSxbLTUsOCwxLDI1M10sWy0zLDksMCw1MDldLFstMiw3LDAsMTI0XSxbLTEsNCwwLDEwXSxbMCwyLDEsMF0sWzIsNSwwLDI2XSxbMyw2LDAsNThdLFs0LDMsNCw0XSxbMjAsNiwxLDU5XSxbMjIsNCw0LDExXSxbMzgsNCw1LDEyXSxbNzAsNSw2LDI3XSxbMTM0LDUsNywyOF0sWzI2Miw2LDcsNjBdLFszOTAsNyw4LDEyNV0sWzY0Niw2LDEwLDYxXSxbLTE2LDksMzIsNTEwLCJsb3dlciJdLFsxNjcwLDksMzIsNTExXSxbMiwxXV07YnJlYWs7Y2FzZSA5OnQ9W1stMzEsOCw0LDI1Ml0sWy0xNSw5LDIsNTA4XSxbLTExLDgsMiwyNTNdLFstNyw5LDEsNTA5XSxbLTUsNywxLDEyNF0sWy0zLDQsMSwxMF0sWy0xLDMsMSwyXSxbMSwzLDEsM10sWzMsNSwxLDI2XSxbNSw2LDEsNThdLFs3LDMsNSw0XSxbMzksNiwyLDU5XSxbNDMsNCw1LDExXSxbNzUsNCw2LDEyXSxbMTM5LDUsNywyN10sWzI2Nyw1LDgsMjhdLFs1MjMsNiw4LDYwXSxbNzc5LDcsOSwxMjVdLFsxMjkxLDYsMTEsNjFdLFstMzIsOSwzMiw1MTAsImxvd2VyIl0sWzMzMzksOSwzMiw1MTFdLFsyLDBdXTticmVhaztjYXNlIDEwOnQ9W1stMjEsNyw0LDEyMl0sWy01LDgsMCwyNTJdLFstNCw3LDAsMTIzXSxbLTMsNSwwLDI0XSxbLTIsMiwyLDBdLFsyLDUsMCwyNV0sWzMsNiwwLDU0XSxbNCw3LDAsMTI0XSxbNSw4LDAsMjUzXSxbNiwyLDYsMV0sWzcwLDUsNSwyNl0sWzEwMiw2LDUsNTVdLFsxMzQsNiw2LDU2XSxbMTk4LDYsNyw1N10sWzMyNiw2LDgsNThdLFs1ODIsNiw5LDU5XSxbMTA5NCw2LDEwLDYwXSxbMjExOCw3LDExLDEyNV0sWy0yMiw4LDMyLDI1NCwibG93ZXIiXSxbNDE2Niw4LDMyLDI1NV0sWzIsMl1dO2JyZWFrO2Nhc2UgMTE6dD1bWzEsMSwwLDBdLFsyLDIsMSwyXSxbNCw0LDAsMTJdLFs1LDQsMSwxM10sWzcsNSwxLDI4XSxbOSw1LDIsMjldLFsxMyw2LDIsNjBdLFsxNyw3LDIsMTIyXSxbMjEsNywzLDEyM10sWzI5LDcsNCwxMjRdLFs0NSw3LDUsMTI1XSxbNzcsNyw2LDEyNl0sWzE0MSw3LDMyLDEyN11dO2JyZWFrO2Nhc2UgMTI6dD1bWzEsMSwwLDBdLFsyLDIsMCwyXSxbMywzLDEsNl0sWzUsNSwwLDI4XSxbNiw1LDEsMjldLFs4LDYsMSw2MF0sWzEwLDcsMCwxMjJdLFsxMSw3LDEsMTIzXSxbMTMsNywyLDEyNF0sWzE3LDcsMywxMjVdLFsyNSw3LDQsMTI2XSxbNDEsOCw1LDI1NF0sWzczLDgsMzIsMjU1XV07YnJlYWs7Y2FzZSAxMzp0PVtbMSwxLDAsMF0sWzIsMywwLDRdLFszLDQsMCwxMl0sWzQsNSwwLDI4XSxbNSw0LDEsMTNdLFs3LDMsMyw1XSxbMTUsNiwxLDU4XSxbMTcsNiwyLDU5XSxbMjEsNiwzLDYwXSxbMjksNiw0LDYxXSxbNDUsNiw1LDYyXSxbNzcsNyw2LDEyNl0sWzE0MSw3LDMyLDEyN11dO2JyZWFrO2Nhc2UgMTQ6dD1bWy0yLDMsMCw0XSxbLTEsMywwLDVdLFswLDEsMCwwXSxbMSwzLDAsNl0sWzIsMywwLDddXTticmVhaztjYXNlIDE1OnQ9W1stMjQsNyw0LDEyNF0sWy04LDYsMiw2MF0sWy00LDUsMSwyOF0sWy0yLDQsMCwxMl0sWy0xLDMsMCw0XSxbMCwxLDAsMF0sWzEsMywwLDVdLFsyLDQsMCwxM10sWzMsNSwxLDI5XSxbNSw2LDIsNjFdLFs5LDcsNCwxMjVdLFstMjUsNywzMiwxMjYsImxvd2VyIl0sWzI1LDcsMzIsMTI3XV07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgSmJpZzJFcnJvcihgc3RhbmRhcmQgdGFibGUgQi4ke2V9IGRvZXMgbm90IGV4aXN0YCl9Zm9yKGxldCBlPTAsaT10Lmxlbmd0aDtlPGk7ZSsrKXRbZV09bmV3IEh1ZmZtYW5MaW5lKHRbZV0pO2k9bmV3IEh1ZmZtYW5UYWJsZSh0LCEwKTtfdFtlXT1pO3JldHVybiBpfWNsYXNzIFJlYWRlcntjb25zdHJ1Y3RvcihlLHQsaSl7dGhpcy5kYXRhPWU7dGhpcy5zdGFydD10O3RoaXMuZW5kPWk7dGhpcy5wb3NpdGlvbj10O3RoaXMuc2hpZnQ9LTE7dGhpcy5jdXJyZW50Qnl0ZT0wfXJlYWRCaXQoKXtpZih0aGlzLnNoaWZ0PDApe2lmKHRoaXMucG9zaXRpb24+PXRoaXMuZW5kKXRocm93IG5ldyBKYmlnMkVycm9yKCJlbmQgb2YgZGF0YSB3aGlsZSByZWFkaW5nIGJpdCIpO3RoaXMuY3VycmVudEJ5dGU9dGhpcy5kYXRhW3RoaXMucG9zaXRpb24rK107dGhpcy5zaGlmdD03fWNvbnN0IGU9dGhpcy5jdXJyZW50Qnl0ZT4+dGhpcy5zaGlmdCYxO3RoaXMuc2hpZnQtLTtyZXR1cm4gZX1yZWFkQml0cyhlKXtsZXQgdCxpPTA7Zm9yKHQ9ZS0xO3Q+PTA7dC0tKWl8PXRoaXMucmVhZEJpdCgpPDx0O3JldHVybiBpfWJ5dGVBbGlnbigpe3RoaXMuc2hpZnQ9LTF9bmV4dCgpe3JldHVybiB0aGlzLnBvc2l0aW9uPj10aGlzLmVuZD8tMTp0aGlzLmRhdGFbdGhpcy5wb3NpdGlvbisrXX19ZnVuY3Rpb24gZ2V0Q3VzdG9tSHVmZm1hblRhYmxlKGUsdCxpKXtsZXQgYT0wO2ZvcihsZXQgcz0wLHI9dC5sZW5ndGg7czxyO3MrKyl7Y29uc3Qgcj1pW3Rbc11dO2lmKHIpe2lmKGU9PT1hKXJldHVybiByO2ErK319dGhyb3cgbmV3IEpiaWcyRXJyb3IoImNhbid0IGZpbmQgY3VzdG9tIEh1ZmZtYW4gdGFibGUiKX1mdW5jdGlvbiByZWFkVW5jb21wcmVzc2VkQml0bWFwKGUsdCxpKXtjb25zdCBhPVtdO2ZvcihsZXQgcz0wO3M8aTtzKyspe2NvbnN0IGk9bmV3IFVpbnQ4QXJyYXkodCk7YS5wdXNoKGkpO2ZvcihsZXQgYT0wO2E8dDthKyspaVthXT1lLnJlYWRCaXQoKTtlLmJ5dGVBbGlnbigpfXJldHVybiBhfWZ1bmN0aW9uIGRlY29kZU1NUkJpdG1hcChlLHQsaSxhKXtjb25zdCBzPW5ldyBDQ0lUVEZheERlY29kZXIoZSx7SzotMSxDb2x1bW5zOnQsUm93czppLEJsYWNrSXMxOiEwLEVuZE9mQmxvY2s6YX0pLHI9W107bGV0IG4sbz0hMTtmb3IobGV0IGU9MDtlPGk7ZSsrKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KHQpO3IucHVzaChlKTtsZXQgaT0tMTtmb3IobGV0IGE9MDthPHQ7YSsrKXtpZihpPDApe249cy5yZWFkTmV4dENoYXIoKTtpZigtMT09PW4pe249MDtvPSEwfWk9N31lW2FdPW4+PmkmMTtpLS19fWlmKGEmJiFvKXtjb25zdCBlPTU7Zm9yKGxldCB0PTA7dDxlJiYtMSE9PXMucmVhZE5leHRDaGFyKCk7dCsrKTt9cmV0dXJuIHJ9Y2xhc3MgSmJpZzJJbWFnZXtwYXJzZUNodW5rcyhlKXtyZXR1cm4gZnVuY3Rpb24gcGFyc2VKYmlnMkNodW5rcyhlKXtjb25zdCB0PW5ldyBTaW1wbGVTZWdtZW50VmlzaXRvcjtmb3IobGV0IGk9MCxhPWUubGVuZ3RoO2k8YTtpKyspe2NvbnN0IGE9ZVtpXTtwcm9jZXNzU2VnbWVudHMocmVhZFNlZ21lbnRzKHt9LGEuZGF0YSxhLnN0YXJ0LGEuZW5kKSx0KX1yZXR1cm4gdC5idWZmZXJ9KGUpfXBhcnNlKGUpe3Rocm93IG5ldyBFcnJvcigiTm90IGltcGxlbWVudGVkOiBKYmlnMkltYWdlLnBhcnNlIil9fWNsYXNzIEpiaWcyU3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcih0KTt0aGlzLnN0cmVhbT1lO3RoaXMuZGljdD1lLmRpY3Q7dGhpcy5tYXliZUxlbmd0aD10O3RoaXMucGFyYW1zPWl9Z2V0IGJ5dGVzKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJieXRlcyIsdGhpcy5zdHJlYW0uZ2V0Qnl0ZXModGhpcy5tYXliZUxlbmd0aCkpfWVuc3VyZUJ1ZmZlcihlKXt9cmVhZEJsb2NrKCl7aWYodGhpcy5lb2YpcmV0dXJuO2NvbnN0IGU9bmV3IEpiaWcySW1hZ2UsdD1bXTtpZih0aGlzLnBhcmFtcyBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9dGhpcy5wYXJhbXMuZ2V0KCJKQklHMkdsb2JhbHMiKTtpZihlIGluc3RhbmNlb2YgQmFzZVN0cmVhbSl7Y29uc3QgaT1lLmdldEJ5dGVzKCk7dC5wdXNoKHtkYXRhOmksc3RhcnQ6MCxlbmQ6aS5sZW5ndGh9KX19dC5wdXNoKHtkYXRhOnRoaXMuYnl0ZXMsc3RhcnQ6MCxlbmQ6dGhpcy5ieXRlcy5sZW5ndGh9KTtjb25zdCBpPWUucGFyc2VDaHVua3ModCksYT1pLmxlbmd0aDtmb3IobGV0IGU9MDtlPGE7ZSsrKWlbZV1ePTI1NTt0aGlzLmJ1ZmZlcj1pO3RoaXMuYnVmZmVyTGVuZ3RoPWE7dGhpcy5lb2Y9ITB9fWZ1bmN0aW9uIGNvbnZlcnRUb1JHQkEoZSl7c3dpdGNoKGUua2luZCl7Y2FzZSBiOnJldHVybiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQShlKTtjYXNlIEQ6cmV0dXJuIGZ1bmN0aW9uIGNvbnZlcnRSR0JUb1JHQkEoe3NyYzplLHNyY1Bvczp0PTAsZGVzdDppLGRlc3RQb3M6YT0wLHdpZHRoOnMsaGVpZ2h0OnJ9KXtsZXQgbj0wO2NvbnN0IG89ZS5sZW5ndGg+PjIsZz1uZXcgVWludDMyQXJyYXkoZS5idWZmZXIsdCxvKTtpZihGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbil7Zm9yKDtuPG8tMjtuKz0zLGErPTQpe2NvbnN0IGU9Z1tuXSx0PWdbbisxXSxzPWdbbisyXTtpW2FdPTQyNzgxOTAwODB8ZTtpW2ErMV09ZT4+PjI0fHQ8PDh8NDI3ODE5MDA4MDtpW2ErMl09dD4+PjE2fHM8PDE2fDQyNzgxOTAwODA7aVthKzNdPXM+Pj44fDQyNzgxOTAwODB9Zm9yKGxldCB0PTQqbixzPWUubGVuZ3RoO3Q8czt0Kz0zKWlbYSsrXT1lW3RdfGVbdCsxXTw8OHxlW3QrMl08PDE2fDQyNzgxOTAwODB9ZWxzZXtmb3IoO248by0yO24rPTMsYSs9NCl7Y29uc3QgZT1nW25dLHQ9Z1tuKzFdLHM9Z1tuKzJdO2lbYV09MjU1fGU7aVthKzFdPWU8PDI0fHQ+Pj44fDI1NTtpW2ErMl09dDw8MTZ8cz4+PjE2fDI1NTtpW2ErM109czw8OHwyNTV9Zm9yKGxldCB0PTQqbixzPWUubGVuZ3RoO3Q8czt0Kz0zKWlbYSsrXT1lW3RdPDwyNHxlW3QrMV08PDE2fGVbdCsyXTw8OHwyNTV9cmV0dXJue3NyY1Bvczp0LGRlc3RQb3M6YX19KGUpfXJldHVybiBudWxsfWZ1bmN0aW9uIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtzcmM6ZSxzcmNQb3M6dD0wLGRlc3Q6aSx3aWR0aDphLGhlaWdodDpzLG5vbkJsYWNrQ29sb3I6cj00Mjk0OTY3Mjk1LGludmVyc2VEZWNvZGU6bj0hMX0pe2NvbnN0IG89RmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4/NDI3ODE5MDA4MDoyNTUsW2csY109bj9bcixvXTpbbyxyXSxDPWE+PjMsaD03JmEsbD1lLmxlbmd0aDtpPW5ldyBVaW50MzJBcnJheShpLmJ1ZmZlcik7bGV0IFE9MDtmb3IobGV0IGE9MDthPHM7YSsrKXtmb3IoY29uc3QgYT10K0M7dDxhO3QrKyl7Y29uc3QgYT10PGw/ZVt0XToyNTU7aVtRKytdPTEyOCZhP2M6ZztpW1ErK109NjQmYT9jOmc7aVtRKytdPTMyJmE/YzpnO2lbUSsrXT0xNiZhP2M6ZztpW1ErK109OCZhP2M6ZztpW1ErK109NCZhP2M6ZztpW1ErK109MiZhP2M6ZztpW1ErK109MSZhP2M6Z31pZigwPT09aCljb250aW51ZTtjb25zdCBhPXQ8bD9lW3QrK106MjU1O2ZvcihsZXQgZT0wO2U8aDtlKyspaVtRKytdPWEmMTw8Ny1lP2M6Z31yZXR1cm57c3JjUG9zOnQsZGVzdFBvczpRfX1jbGFzcyBKcGVnRXJyb3IgZXh0ZW5kcyBydHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJKcGVnRXJyb3IiKX19Y2xhc3MgRE5MTWFya2VyRXJyb3IgZXh0ZW5kcyBydHtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGUsIkROTE1hcmtlckVycm9yIik7dGhpcy5zY2FuTGluZXM9dH19Y2xhc3MgRU9JTWFya2VyRXJyb3IgZXh0ZW5kcyBydHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJFT0lNYXJrZXJFcnJvciIpfX1jb25zdCAkdD1uZXcgVWludDhBcnJheShbMCwxLDgsMTYsOSwyLDMsMTAsMTcsMjQsMzIsMjUsMTgsMTEsNCw1LDEyLDE5LDI2LDMzLDQwLDQ4LDQxLDM0LDI3LDIwLDEzLDYsNywxNCwyMSwyOCwzNSw0Miw0OSw1Niw1Nyw1MCw0MywzNiwyOSwyMiwxNSwyMywzMCwzNyw0NCw1MSw1OCw1OSw1Miw0NSwzOCwzMSwzOSw0Niw1Myw2MCw2MSw1NCw0Nyw1NSw2Miw2M10pLEFpPTQwMTcsZWk9Nzk5LHRpPTM0MDYsaWk9MjI3NixhaT0xNTY3LHNpPTM3ODQscmk9NTc5MyxuaT0yODk2O2Z1bmN0aW9uIGJ1aWxkSHVmZm1hblRhYmxlKGUsdCl7bGV0IGksYSxzPTAscj0xNjtmb3IoO3I+MCYmIWVbci0xXTspci0tO2NvbnN0IG49W3tjaGlsZHJlbjpbXSxpbmRleDowfV07bGV0IG8sZz1uWzBdO2ZvcihpPTA7aTxyO2krKyl7Zm9yKGE9MDthPGVbaV07YSsrKXtnPW4ucG9wKCk7Zy5jaGlsZHJlbltnLmluZGV4XT10W3NdO2Zvcig7Zy5pbmRleD4wOylnPW4ucG9wKCk7Zy5pbmRleCsrO24ucHVzaChnKTtmb3IoO24ubGVuZ3RoPD1pOyl7bi5wdXNoKG89e2NoaWxkcmVuOltdLGluZGV4OjB9KTtnLmNoaWxkcmVuW2cuaW5kZXhdPW8uY2hpbGRyZW47Zz1vfXMrK31pZihpKzE8cil7bi5wdXNoKG89e2NoaWxkcmVuOltdLGluZGV4OjB9KTtnLmNoaWxkcmVuW2cuaW5kZXhdPW8uY2hpbGRyZW47Zz1vfX1yZXR1cm4gblswXS5jaGlsZHJlbn1mdW5jdGlvbiBnZXRCbG9ja0J1ZmZlck9mZnNldChlLHQsaSl7cmV0dXJuIDY0KigoZS5ibG9ja3NQZXJMaW5lKzEpKnQraSl9ZnVuY3Rpb24gZGVjb2RlU2NhbihlLHQsaSxhLHMscixuLG8sZyxjPSExKXtjb25zdCBDPWkubWN1c1BlckxpbmUsaD1pLnByb2dyZXNzaXZlLGw9dDtsZXQgUT0wLEU9MDtmdW5jdGlvbiByZWFkQml0KCl7aWYoRT4wKXtFLS07cmV0dXJuIFE+PkUmMX1RPWVbdCsrXTtpZigyNTU9PT1RKXtjb25zdCBhPWVbdCsrXTtpZihhKXtpZigyMjA9PT1hJiZjKXtjb25zdCBhPXJlYWRVaW50MTYoZSx0Kz0yKTt0Kz0yO2lmKGE+MCYmYSE9PWkuc2NhbkxpbmVzKXRocm93IG5ldyBETkxNYXJrZXJFcnJvcigiRm91bmQgRE5MIG1hcmtlciAoMHhGRkRDKSB3aGlsZSBwYXJzaW5nIHNjYW4gZGF0YSIsYSl9ZWxzZSBpZigyMTc9PT1hKXtpZihjKXtjb25zdCBlPXAqKDg9PT1pLnByZWNpc2lvbj84OjApO2lmKGU+MCYmTWF0aC5yb3VuZChpLnNjYW5MaW5lcy9lKT49NSl0aHJvdyBuZXcgRE5MTWFya2VyRXJyb3IoIkZvdW5kIEVPSSBtYXJrZXIgKDB4RkZEOSkgd2hpbGUgcGFyc2luZyBzY2FuIGRhdGEsIHBvc3NpYmx5IGNhdXNlZCBieSBpbmNvcnJlY3QgYHNjYW5MaW5lc2AgcGFyYW1ldGVyIixlKX10aHJvdyBuZXcgRU9JTWFya2VyRXJyb3IoIkZvdW5kIEVPSSBtYXJrZXIgKDB4RkZEOSkgd2hpbGUgcGFyc2luZyBzY2FuIGRhdGEiKX10aHJvdyBuZXcgSnBlZ0Vycm9yKGB1bmV4cGVjdGVkIG1hcmtlciAkeyhRPDw4fGEpLnRvU3RyaW5nKDE2KX1gKX19RT03O3JldHVybiBRPj4+N31mdW5jdGlvbiBkZWNvZGVIdWZmbWFuKGUpe2xldCB0PWU7Zm9yKDs7KXt0PXRbcmVhZEJpdCgpXTtzd2l0Y2godHlwZW9mIHQpe2Nhc2UibnVtYmVyIjpyZXR1cm4gdDtjYXNlIm9iamVjdCI6Y29udGludWV9dGhyb3cgbmV3IEpwZWdFcnJvcigiaW52YWxpZCBodWZmbWFuIHNlcXVlbmNlIil9fWZ1bmN0aW9uIHJlY2VpdmUoZSl7bGV0IHQ9MDtmb3IoO2U+MDspe3Q9dDw8MXxyZWFkQml0KCk7ZS0tfXJldHVybiB0fWZ1bmN0aW9uIHJlY2VpdmVBbmRFeHRlbmQoZSl7aWYoMT09PWUpcmV0dXJuIDE9PT1yZWFkQml0KCk/MTotMTtjb25zdCB0PXJlY2VpdmUoZSk7cmV0dXJuIHQ+PTE8PGUtMT90OnQrKC0xPDxlKSsxfWxldCB1PTA7bGV0IGQsZj0wO2xldCBwPTA7ZnVuY3Rpb24gZGVjb2RlTWN1KGUsdCxpLGEscyl7Y29uc3Qgcj1pJUM7cD0oaS9DfDApKmUudithO2NvbnN0IG49ciplLmgrczt0KGUsZ2V0QmxvY2tCdWZmZXJPZmZzZXQoZSxwLG4pKX1mdW5jdGlvbiBkZWNvZGVCbG9jayhlLHQsaSl7cD1pL2UuYmxvY2tzUGVyTGluZXwwO2NvbnN0IGE9aSVlLmJsb2Nrc1BlckxpbmU7dChlLGdldEJsb2NrQnVmZmVyT2Zmc2V0KGUscCxhKSl9Y29uc3QgbT1hLmxlbmd0aDtsZXQgeSx3LGIsRCxGLFM7Uz1oPzA9PT1yPzA9PT1vP2Z1bmN0aW9uIGRlY29kZURDRmlyc3QoZSx0KXtjb25zdCBpPWRlY29kZUh1ZmZtYW4oZS5odWZmbWFuVGFibGVEQyksYT0wPT09aT8wOnJlY2VpdmVBbmRFeHRlbmQoaSk8PGc7ZS5ibG9ja0RhdGFbdF09ZS5wcmVkKz1hfTpmdW5jdGlvbiBkZWNvZGVEQ1N1Y2Nlc3NpdmUoZSx0KXtlLmJsb2NrRGF0YVt0XXw9cmVhZEJpdCgpPDxnfTowPT09bz9mdW5jdGlvbiBkZWNvZGVBQ0ZpcnN0KGUsdCl7aWYodT4wKXt1LS07cmV0dXJufWxldCBpPXI7Y29uc3QgYT1uO2Zvcig7aTw9YTspe2NvbnN0IGE9ZGVjb2RlSHVmZm1hbihlLmh1ZmZtYW5UYWJsZUFDKSxzPTE1JmEscj1hPj40O2lmKDA9PT1zKXtpZihyPDE1KXt1PXJlY2VpdmUocikrKDE8PHIpLTE7YnJlYWt9aSs9MTY7Y29udGludWV9aSs9cjtjb25zdCBuPSR0W2ldO2UuYmxvY2tEYXRhW3Qrbl09cmVjZWl2ZUFuZEV4dGVuZChzKSooMTw8Zyk7aSsrfX06ZnVuY3Rpb24gZGVjb2RlQUNTdWNjZXNzaXZlKGUsdCl7bGV0IGk9cjtjb25zdCBhPW47bGV0IHMsbyxjPTA7Zm9yKDtpPD1hOyl7Y29uc3QgYT10KyR0W2ldLHI9ZS5ibG9ja0RhdGFbYV08MD8tMToxO3N3aXRjaChmKXtjYXNlIDA6bz1kZWNvZGVIdWZmbWFuKGUuaHVmZm1hblRhYmxlQUMpO3M9MTUmbztjPW8+PjQ7aWYoMD09PXMpaWYoYzwxNSl7dT1yZWNlaXZlKGMpKygxPDxjKTtmPTR9ZWxzZXtjPTE2O2Y9MX1lbHNle2lmKDEhPT1zKXRocm93IG5ldyBKcGVnRXJyb3IoImludmFsaWQgQUNuIGVuY29kaW5nIik7ZD1yZWNlaXZlQW5kRXh0ZW5kKHMpO2Y9Yz8yOjN9Y29udGludWU7Y2FzZSAxOmNhc2UgMjppZihlLmJsb2NrRGF0YVthXSllLmJsb2NrRGF0YVthXSs9cioocmVhZEJpdCgpPDxnKTtlbHNle2MtLTswPT09YyYmKGY9Mj09PWY/MzowKX1icmVhaztjYXNlIDM6aWYoZS5ibG9ja0RhdGFbYV0pZS5ibG9ja0RhdGFbYV0rPXIqKHJlYWRCaXQoKTw8Zyk7ZWxzZXtlLmJsb2NrRGF0YVthXT1kPDxnO2Y9MH1icmVhaztjYXNlIDQ6ZS5ibG9ja0RhdGFbYV0mJihlLmJsb2NrRGF0YVthXSs9cioocmVhZEJpdCgpPDxnKSl9aSsrfWlmKDQ9PT1mKXt1LS07MD09PXUmJihmPTApfX06ZnVuY3Rpb24gZGVjb2RlQmFzZWxpbmUoZSx0KXtjb25zdCBpPWRlY29kZUh1ZmZtYW4oZS5odWZmbWFuVGFibGVEQyksYT0wPT09aT8wOnJlY2VpdmVBbmRFeHRlbmQoaSk7ZS5ibG9ja0RhdGFbdF09ZS5wcmVkKz1hO2xldCBzPTE7Zm9yKDtzPDY0Oyl7Y29uc3QgaT1kZWNvZGVIdWZmbWFuKGUuaHVmZm1hblRhYmxlQUMpLGE9MTUmaSxyPWk+PjQ7aWYoMD09PWEpe2lmKHI8MTUpYnJlYWs7cys9MTY7Y29udGludWV9cys9cjtjb25zdCBuPSR0W3NdO2UuYmxvY2tEYXRhW3Qrbl09cmVjZWl2ZUFuZEV4dGVuZChhKTtzKyt9fTtsZXQgayxOPTA7Y29uc3QgUj0xPT09bT9hWzBdLmJsb2Nrc1BlckxpbmUqYVswXS5ibG9ja3NQZXJDb2x1bW46QyppLm1jdXNQZXJDb2x1bW47bGV0IEcseDtmb3IoO048PVI7KXtjb25zdCBpPXM/TWF0aC5taW4oUi1OLHMpOlI7aWYoaT4wKXtmb3Iodz0wO3c8bTt3KyspYVt3XS5wcmVkPTA7dT0wO2lmKDE9PT1tKXt5PWFbMF07Zm9yKEY9MDtGPGk7RisrKXtkZWNvZGVCbG9jayh5LFMsTik7TisrfX1lbHNlIGZvcihGPTA7RjxpO0YrKyl7Zm9yKHc9MDt3PG07dysrKXt5PWFbd107Rz15Lmg7eD15LnY7Zm9yKGI9MDtiPHg7YisrKWZvcihEPTA7RDxHO0QrKylkZWNvZGVNY3UoeSxTLE4sYixEKX1OKyt9fUU9MDtrPWZpbmROZXh0RmlsZU1hcmtlcihlLHQpO2lmKCFrKWJyZWFrO2lmKGsuaW52YWxpZCl7d2FybihgZGVjb2RlU2NhbiAtICR7aT4wPyJ1bmV4cGVjdGVkIjoiZXhjZXNzaXZlIn0gTUNVIGRhdGEsIGN1cnJlbnQgbWFya2VyIGlzOiAke2suaW52YWxpZH1gKTt0PWsub2Zmc2V0fWlmKCEoay5tYXJrZXI+PTY1NDg4JiZrLm1hcmtlcjw9NjU0OTUpKWJyZWFrO3QrPTJ9cmV0dXJuIHQtbH1mdW5jdGlvbiBxdWFudGl6ZUFuZEludmVyc2UoZSx0LGkpe2NvbnN0IGE9ZS5xdWFudGl6YXRpb25UYWJsZSxzPWUuYmxvY2tEYXRhO2xldCByLG4sbyxnLGMsQyxoLGwsUSxFLHUsZCxmLHAsbSx5LHc7aWYoIWEpdGhyb3cgbmV3IEpwZWdFcnJvcigibWlzc2luZyByZXF1aXJlZCBRdWFudGl6YXRpb24gVGFibGUuIik7Zm9yKGxldCBlPTA7ZTw2NDtlKz04KXtRPXNbdCtlXTtFPXNbdCtlKzFdO3U9c1t0K2UrMl07ZD1zW3QrZSszXTtmPXNbdCtlKzRdO3A9c1t0K2UrNV07bT1zW3QrZSs2XTt5PXNbdCtlKzddO1EqPWFbZV07aWYoMCE9KEV8dXxkfGZ8cHxtfHkpKXtFKj1hW2UrMV07dSo9YVtlKzJdO2QqPWFbZSszXTtmKj1hW2UrNF07cCo9YVtlKzVdO20qPWFbZSs2XTt5Kj1hW2UrN107cj1yaSpRKzEyOD4+ODtuPXJpKmYrMTI4Pj44O289dTtnPW07Yz1uaSooRS15KSsxMjg+Pjg7bD1uaSooRSt5KSsxMjg+Pjg7Qz1kPDw0O2g9cDw8NDtyPXIrbisxPj4xO249ci1uO3c9bypzaStnKmFpKzEyOD4+ODtvPW8qYWktZypzaSsxMjg+Pjg7Zz13O2M9YytoKzE+PjE7aD1jLWg7bD1sK0MrMT4+MTtDPWwtQztyPXIrZysxPj4xO2c9ci1nO249bitvKzE+PjE7bz1uLW87dz1jKmlpK2wqdGkrMjA0OD4+MTI7Yz1jKnRpLWwqaWkrMjA0OD4+MTI7bD13O3c9QyplaStoKkFpKzIwNDg+PjEyO0M9QypBaS1oKmVpKzIwNDg+PjEyO2g9dztpW2VdPXIrbDtpW2UrN109ci1sO2lbZSsxXT1uK2g7aVtlKzZdPW4taDtpW2UrMl09bytDO2lbZSs1XT1vLUM7aVtlKzNdPWcrYztpW2UrNF09Zy1jfWVsc2V7dz1yaSpRKzUxMj4+MTA7aVtlXT13O2lbZSsxXT13O2lbZSsyXT13O2lbZSszXT13O2lbZSs0XT13O2lbZSs1XT13O2lbZSs2XT13O2lbZSs3XT13fX1mb3IobGV0IGU9MDtlPDg7KytlKXtRPWlbZV07RT1pW2UrOF07dT1pW2UrMTZdO2Q9aVtlKzI0XTtmPWlbZSszMl07cD1pW2UrNDBdO209aVtlKzQ4XTt5PWlbZSs1Nl07aWYoMCE9KEV8dXxkfGZ8cHxtfHkpKXtyPXJpKlErMjA0OD4+MTI7bj1yaSpmKzIwNDg+PjEyO289dTtnPW07Yz1uaSooRS15KSsyMDQ4Pj4xMjtsPW5pKihFK3kpKzIwNDg+PjEyO0M9ZDtoPXA7cj00MTEyKyhyK24rMT4+MSk7bj1yLW47dz1vKnNpK2cqYWkrMjA0OD4+MTI7bz1vKmFpLWcqc2krMjA0OD4+MTI7Zz13O2M9YytoKzE+PjE7aD1jLWg7bD1sK0MrMT4+MTtDPWwtQztyPXIrZysxPj4xO2c9ci1nO249bitvKzE+PjE7bz1uLW87dz1jKmlpK2wqdGkrMjA0OD4+MTI7Yz1jKnRpLWwqaWkrMjA0OD4+MTI7bD13O3c9QyplaStoKkFpKzIwNDg+PjEyO0M9QypBaS1oKmVpKzIwNDg+PjEyO2g9dztRPXIrbDt5PXItbDtFPW4raDttPW4taDt1PW8rQztwPW8tQztkPWcrYztmPWctYztRPDE2P1E9MDpRPj00MDgwP1E9MjU1OlE+Pj00O0U8MTY/RT0wOkU+PTQwODA/RT0yNTU6RT4+PTQ7dTwxNj91PTA6dT49NDA4MD91PTI1NTp1Pj49NDtkPDE2P2Q9MDpkPj00MDgwP2Q9MjU1OmQ+Pj00O2Y8MTY/Zj0wOmY+PTQwODA/Zj0yNTU6Zj4+PTQ7cDwxNj9wPTA6cD49NDA4MD9wPTI1NTpwPj49NDttPDE2P209MDptPj00MDgwP209MjU1Om0+Pj00O3k8MTY/eT0wOnk+PTQwODA/eT0yNTU6eT4+PTQ7c1t0K2VdPVE7c1t0K2UrOF09RTtzW3QrZSsxNl09dTtzW3QrZSsyNF09ZDtzW3QrZSszMl09ZjtzW3QrZSs0MF09cDtzW3QrZSs0OF09bTtzW3QrZSs1Nl09eX1lbHNle3c9cmkqUSs4MTkyPj4xNDt3PXc8LTIwNDA/MDp3Pj0yMDI0PzI1NTp3KzIwNTY+PjQ7c1t0K2VdPXc7c1t0K2UrOF09dztzW3QrZSsxNl09dztzW3QrZSsyNF09dztzW3QrZSszMl09dztzW3QrZSs0MF09dztzW3QrZSs0OF09dztzW3QrZSs1Nl09d319fWZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50RGF0YShlLHQpe2NvbnN0IGk9dC5ibG9ja3NQZXJMaW5lLGE9dC5ibG9ja3NQZXJDb2x1bW4scz1uZXcgSW50MTZBcnJheSg2NCk7Zm9yKGxldCBlPTA7ZTxhO2UrKylmb3IobGV0IGE9MDthPGk7YSsrKXtxdWFudGl6ZUFuZEludmVyc2UodCxnZXRCbG9ja0J1ZmZlck9mZnNldCh0LGUsYSkscyl9cmV0dXJuIHQuYmxvY2tEYXRhfWZ1bmN0aW9uIGZpbmROZXh0RmlsZU1hcmtlcihlLHQsaT10KXtjb25zdCBhPWUubGVuZ3RoLTE7bGV0IHM9aTx0P2k6dDtpZih0Pj1hKXJldHVybiBudWxsO2NvbnN0IHI9cmVhZFVpbnQxNihlLHQpO2lmKHI+PTY1NDcyJiZyPD02NTUzNClyZXR1cm57aW52YWxpZDpudWxsLG1hcmtlcjpyLG9mZnNldDp0fTtsZXQgbj1yZWFkVWludDE2KGUscyk7Zm9yKDshKG4+PTY1NDcyJiZuPD02NTUzNCk7KXtpZigrK3M+PWEpcmV0dXJuIG51bGw7bj1yZWFkVWludDE2KGUscyl9cmV0dXJue2ludmFsaWQ6ci50b1N0cmluZygxNiksbWFya2VyOm4sb2Zmc2V0OnN9fWNsYXNzIEpwZWdJbWFnZXtjb25zdHJ1Y3Rvcih7ZGVjb2RlVHJhbnNmb3JtOmU9bnVsbCxjb2xvclRyYW5zZm9ybTp0PS0xfT17fSl7dGhpcy5fZGVjb2RlVHJhbnNmb3JtPWU7dGhpcy5fY29sb3JUcmFuc2Zvcm09dH1wYXJzZShlLHtkbmxTY2FuTGluZXM6dD1udWxsfT17fSl7ZnVuY3Rpb24gcmVhZERhdGFCbG9jaygpe2NvbnN0IHQ9cmVhZFVpbnQxNihlLHMpO3MrPTI7bGV0IGk9cyt0LTI7Y29uc3QgYT1maW5kTmV4dEZpbGVNYXJrZXIoZSxpLHMpO2lmKGE/LmludmFsaWQpe3dhcm4oInJlYWREYXRhQmxvY2sgLSBpbmNvcnJlY3QgbGVuZ3RoLCBjdXJyZW50IG1hcmtlciBpczogIithLmludmFsaWQpO2k9YS5vZmZzZXR9Y29uc3Qgcj1lLnN1YmFycmF5KHMsaSk7cys9ci5sZW5ndGg7cmV0dXJuIHJ9ZnVuY3Rpb24gcHJlcGFyZUNvbXBvbmVudHMoZSl7Y29uc3QgdD1NYXRoLmNlaWwoZS5zYW1wbGVzUGVyTGluZS84L2UubWF4SCksaT1NYXRoLmNlaWwoZS5zY2FuTGluZXMvOC9lLm1heFYpO2Zvcihjb25zdCBhIG9mIGUuY29tcG9uZW50cyl7Y29uc3Qgcz1NYXRoLmNlaWwoTWF0aC5jZWlsKGUuc2FtcGxlc1BlckxpbmUvOCkqYS5oL2UubWF4SCkscj1NYXRoLmNlaWwoTWF0aC5jZWlsKGUuc2NhbkxpbmVzLzgpKmEudi9lLm1heFYpLG49dCphLmgsbz02NCooaSphLnYpKihuKzEpO2EuYmxvY2tEYXRhPW5ldyBJbnQxNkFycmF5KG8pO2EuYmxvY2tzUGVyTGluZT1zO2EuYmxvY2tzUGVyQ29sdW1uPXJ9ZS5tY3VzUGVyTGluZT10O2UubWN1c1BlckNvbHVtbj1pfWxldCBpLGEscz0wLHI9bnVsbCxuPW51bGwsbz0wO2NvbnN0IGc9W10sYz1bXSxDPVtdO2xldCBoPXJlYWRVaW50MTYoZSxzKTtzKz0yO2lmKDY1NDk2IT09aCl0aHJvdyBuZXcgSnBlZ0Vycm9yKCJTT0kgbm90IGZvdW5kIik7aD1yZWFkVWludDE2KGUscyk7cys9MjtBOmZvcig7NjU0OTchPT1oOyl7bGV0IGwsUSxFO3N3aXRjaChoKXtjYXNlIDY1NTA0OmNhc2UgNjU1MDU6Y2FzZSA2NTUwNjpjYXNlIDY1NTA3OmNhc2UgNjU1MDg6Y2FzZSA2NTUwOTpjYXNlIDY1NTEwOmNhc2UgNjU1MTE6Y2FzZSA2NTUxMjpjYXNlIDY1NTEzOmNhc2UgNjU1MTQ6Y2FzZSA2NTUxNTpjYXNlIDY1NTE2OmNhc2UgNjU1MTc6Y2FzZSA2NTUxODpjYXNlIDY1NTE5OmNhc2UgNjU1MzQ6Y29uc3QgdT1yZWFkRGF0YUJsb2NrKCk7NjU1MDQ9PT1oJiY3ND09PXVbMF0mJjcwPT09dVsxXSYmNzM9PT11WzJdJiY3MD09PXVbM10mJjA9PT11WzRdJiYocj17dmVyc2lvbjp7bWFqb3I6dVs1XSxtaW5vcjp1WzZdfSxkZW5zaXR5VW5pdHM6dVs3XSx4RGVuc2l0eTp1WzhdPDw4fHVbOV0seURlbnNpdHk6dVsxMF08PDh8dVsxMV0sdGh1bWJXaWR0aDp1WzEyXSx0aHVtYkhlaWdodDp1WzEzXSx0aHVtYkRhdGE6dS5zdWJhcnJheSgxNCwxNCszKnVbMTJdKnVbMTNdKX0pOzY1NTE4PT09aCYmNjU9PT11WzBdJiYxMDA9PT11WzFdJiYxMTE9PT11WzJdJiY5OD09PXVbM10mJjEwMT09PXVbNF0mJihuPXt2ZXJzaW9uOnVbNV08PDh8dVs2XSxmbGFnczA6dVs3XTw8OHx1WzhdLGZsYWdzMTp1WzldPDw4fHVbMTBdLHRyYW5zZm9ybUNvZGU6dVsxMV19KTticmVhaztjYXNlIDY1NDk5OmNvbnN0IGQ9cmVhZFVpbnQxNihlLHMpO3MrPTI7Y29uc3QgZj1kK3MtMjtsZXQgcDtmb3IoO3M8Zjspe2NvbnN0IHQ9ZVtzKytdLGk9bmV3IFVpbnQxNkFycmF5KDY0KTtpZih0Pj40PT0wKWZvcihRPTA7UTw2NDtRKyspe3A9JHRbUV07aVtwXT1lW3MrK119ZWxzZXtpZih0Pj40IT0xKXRocm93IG5ldyBKcGVnRXJyb3IoIkRRVCAtIGludmFsaWQgdGFibGUgc3BlYyIpO2ZvcihRPTA7UTw2NDtRKyspe3A9JHRbUV07aVtwXT1yZWFkVWludDE2KGUscyk7cys9Mn19Z1sxNSZ0XT1pfWJyZWFrO2Nhc2UgNjU0NzI6Y2FzZSA2NTQ3MzpjYXNlIDY1NDc0OmlmKGkpdGhyb3cgbmV3IEpwZWdFcnJvcigiT25seSBzaW5nbGUgZnJhbWUgSlBFR3Mgc3VwcG9ydGVkIik7cys9MjtpPXt9O2kuZXh0ZW5kZWQ9NjU0NzM9PT1oO2kucHJvZ3Jlc3NpdmU9NjU0NzQ9PT1oO2kucHJlY2lzaW9uPWVbcysrXTtjb25zdCBtPXJlYWRVaW50MTYoZSxzKTtzKz0yO2kuc2NhbkxpbmVzPXR8fG07aS5zYW1wbGVzUGVyTGluZT1yZWFkVWludDE2KGUscyk7cys9MjtpLmNvbXBvbmVudHM9W107aS5jb21wb25lbnRJZHM9e307Y29uc3QgeT1lW3MrK107bGV0IHc9MCxiPTA7Zm9yKGw9MDtsPHk7bCsrKXtjb25zdCB0PWVbc10sYT1lW3MrMV0+PjQscj0xNSZlW3MrMV07dzxhJiYodz1hKTtiPHImJihiPXIpO2NvbnN0IG49ZVtzKzJdO0U9aS5jb21wb25lbnRzLnB1c2goe2g6YSx2OnIscXVhbnRpemF0aW9uSWQ6bixxdWFudGl6YXRpb25UYWJsZTpudWxsfSk7aS5jb21wb25lbnRJZHNbdF09RS0xO3MrPTN9aS5tYXhIPXc7aS5tYXhWPWI7cHJlcGFyZUNvbXBvbmVudHMoaSk7YnJlYWs7Y2FzZSA2NTQ3Njpjb25zdCBEPXJlYWRVaW50MTYoZSxzKTtzKz0yO2ZvcihsPTI7bDxEOyl7Y29uc3QgdD1lW3MrK10saT1uZXcgVWludDhBcnJheSgxNik7bGV0IGE9MDtmb3IoUT0wO1E8MTY7USsrLHMrKylhKz1pW1FdPWVbc107Y29uc3Qgcj1uZXcgVWludDhBcnJheShhKTtmb3IoUT0wO1E8YTtRKysscysrKXJbUV09ZVtzXTtsKz0xNythOyh0Pj40PT0wP0M6YylbMTUmdF09YnVpbGRIdWZmbWFuVGFibGUoaSxyKX1icmVhaztjYXNlIDY1NTAxOnMrPTI7YT1yZWFkVWludDE2KGUscyk7cys9MjticmVhaztjYXNlIDY1NDk4OmNvbnN0IEY9MT09KytvJiYhdDtzKz0yO2NvbnN0IFM9ZVtzKytdLGs9W107Zm9yKGw9MDtsPFM7bCsrKXtjb25zdCB0PWVbcysrXSxhPWkuY29tcG9uZW50SWRzW3RdLHI9aS5jb21wb25lbnRzW2FdO3IuaW5kZXg9dDtjb25zdCBuPWVbcysrXTtyLmh1ZmZtYW5UYWJsZURDPUNbbj4+NF07ci5odWZmbWFuVGFibGVBQz1jWzE1Jm5dO2sucHVzaChyKX1jb25zdCBOPWVbcysrXSxSPWVbcysrXSxHPWVbcysrXTt0cnl7Y29uc3QgdD1kZWNvZGVTY2FuKGUscyxpLGssYSxOLFIsRz4+NCwxNSZHLEYpO3MrPXR9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIEROTE1hcmtlckVycm9yKXt3YXJuKGAke3QubWVzc2FnZX0gLS0gYXR0ZW1wdGluZyB0byByZS1wYXJzZSB0aGUgSlBFRyBpbWFnZS5gKTtyZXR1cm4gdGhpcy5wYXJzZShlLHtkbmxTY2FuTGluZXM6dC5zY2FuTGluZXN9KX1pZih0IGluc3RhbmNlb2YgRU9JTWFya2VyRXJyb3Ipe3dhcm4oYCR7dC5tZXNzYWdlfSAtLSBpZ25vcmluZyB0aGUgcmVzdCBvZiB0aGUgaW1hZ2UgZGF0YS5gKTticmVhayBBfXRocm93IHR9YnJlYWs7Y2FzZSA2NTUwMDpzKz00O2JyZWFrO2Nhc2UgNjU1MzU6MjU1IT09ZVtzXSYmcy0tO2JyZWFrO2RlZmF1bHQ6Y29uc3QgeD1maW5kTmV4dEZpbGVNYXJrZXIoZSxzLTIscy0zKTtpZih4Py5pbnZhbGlkKXt3YXJuKCJKcGVnSW1hZ2UucGFyc2UgLSB1bmV4cGVjdGVkIGRhdGEsIGN1cnJlbnQgbWFya2VyIGlzOiAiK3guaW52YWxpZCk7cz14Lm9mZnNldDticmVha31pZigheHx8cz49ZS5sZW5ndGgtMSl7d2FybigiSnBlZ0ltYWdlLnBhcnNlIC0gcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBpbWFnZSBkYXRhIHdpdGhvdXQgZmluZGluZyBhbiBFT0kgbWFya2VyICgweEZGRDkpLiIpO2JyZWFrIEF9dGhyb3cgbmV3IEpwZWdFcnJvcigiSnBlZ0ltYWdlLnBhcnNlIC0gdW5rbm93biBtYXJrZXI6ICIraC50b1N0cmluZygxNikpfWg9cmVhZFVpbnQxNihlLHMpO3MrPTJ9aWYoIWkpdGhyb3cgbmV3IEpwZWdFcnJvcigiSnBlZ0ltYWdlLnBhcnNlIC0gbm8gZnJhbWUgZGF0YSBmb3VuZC4iKTt0aGlzLndpZHRoPWkuc2FtcGxlc1BlckxpbmU7dGhpcy5oZWlnaHQ9aS5zY2FuTGluZXM7dGhpcy5qZmlmPXI7dGhpcy5hZG9iZT1uO3RoaXMuY29tcG9uZW50cz1bXTtmb3IoY29uc3QgZSBvZiBpLmNvbXBvbmVudHMpe2NvbnN0IHQ9Z1tlLnF1YW50aXphdGlvbklkXTt0JiYoZS5xdWFudGl6YXRpb25UYWJsZT10KTt0aGlzLmNvbXBvbmVudHMucHVzaCh7aW5kZXg6ZS5pbmRleCxvdXRwdXQ6YnVpbGRDb21wb25lbnREYXRhKDAsZSksc2NhbGVYOmUuaC9pLm1heEgsc2NhbGVZOmUudi9pLm1heFYsYmxvY2tzUGVyTGluZTplLmJsb2Nrc1BlckxpbmUsYmxvY2tzUGVyQ29sdW1uOmUuYmxvY2tzUGVyQ29sdW1ufSl9dGhpcy5udW1Db21wb25lbnRzPXRoaXMuY29tcG9uZW50cy5sZW5ndGh9X2dldExpbmVhcml6ZWRCbG9ja0RhdGEoZSx0LGk9ITEpe2NvbnN0IGE9dGhpcy53aWR0aC9lLHM9dGhpcy5oZWlnaHQvdDtsZXQgcixuLG8sZyxjLEMsaCxsLFEsRSx1LGQ9MDtjb25zdCBmPXRoaXMuY29tcG9uZW50cy5sZW5ndGgscD1lKnQqZixtPW5ldyBVaW50OENsYW1wZWRBcnJheShwKSx5PW5ldyBVaW50MzJBcnJheShlKSx3PTQyOTQ5NjcyODg7bGV0IGI7Zm9yKGg9MDtoPGY7aCsrKXtyPXRoaXMuY29tcG9uZW50c1toXTtuPXIuc2NhbGVYKmE7bz1yLnNjYWxlWSpzO2Q9aDt1PXIub3V0cHV0O2c9ci5ibG9ja3NQZXJMaW5lKzE8PDM7aWYobiE9PWIpe2ZvcihjPTA7YzxlO2MrKyl7bD0wfGMqbjt5W2NdPShsJncpPDwzfDcmbH1iPW59Zm9yKEM9MDtDPHQ7QysrKXtsPTB8QypvO0U9ZyoobCZ3KXwoNyZsKTw8Mztmb3IoYz0wO2M8ZTtjKyspe21bZF09dVtFK3lbY11dO2QrPWZ9fX1sZXQgRD10aGlzLl9kZWNvZGVUcmFuc2Zvcm07aXx8NCE9PWZ8fER8fChEPW5ldyBJbnQzMkFycmF5KFstMjU2LDI1NSwtMjU2LDI1NSwtMjU2LDI1NSwtMjU2LDI1NV0pKTtpZihEKWZvcihoPTA7aDxwOylmb3IobD0wLFE9MDtsPGY7bCsrLGgrKyxRKz0yKW1baF09KG1baF0qRFtRXT4+OCkrRFtRKzFdO3JldHVybiBtfWdldCBfaXNDb2xvckNvbnZlcnNpb25OZWVkZWQoKXtyZXR1cm4gdGhpcy5hZG9iZT8hIXRoaXMuYWRvYmUudHJhbnNmb3JtQ29kZTozPT09dGhpcy5udW1Db21wb25lbnRzPzAhPT10aGlzLl9jb2xvclRyYW5zZm9ybSYmKDgyIT09dGhpcy5jb21wb25lbnRzWzBdLmluZGV4fHw3MSE9PXRoaXMuY29tcG9uZW50c1sxXS5pbmRleHx8NjYhPT10aGlzLmNvbXBvbmVudHNbMl0uaW5kZXgpOjE9PT10aGlzLl9jb2xvclRyYW5zZm9ybX1fY29udmVydFljY1RvUmdiKGUpe2xldCB0LGksYTtmb3IobGV0IHM9MCxyPWUubGVuZ3RoO3M8cjtzKz0zKXt0PWVbc107aT1lW3MrMV07YT1lW3MrMl07ZVtzXT10LTE3OS40NTYrMS40MDIqYTtlW3MrMV09dCsxMzUuNDU5LS4zNDQqaS0uNzE0KmE7ZVtzKzJdPXQtMjI2LjgxNisxLjc3MippfXJldHVybiBlfV9jb252ZXJ0WWNjVG9SZ2JhKGUsdCl7Zm9yKGxldCBpPTAsYT0wLHM9ZS5sZW5ndGg7aTxzO2krPTMsYSs9NCl7Y29uc3Qgcz1lW2ldLHI9ZVtpKzFdLG49ZVtpKzJdO3RbYV09cy0xNzkuNDU2KzEuNDAyKm47dFthKzFdPXMrMTM1LjQ1OS0uMzQ0KnItLjcxNCpuO3RbYSsyXT1zLTIyNi44MTYrMS43NzIqcjt0W2ErM109MjU1fXJldHVybiB0fV9jb252ZXJ0WWNja1RvUmdiKGUpe2xldCB0LGksYSxzLHI9MDtmb3IobGV0IG49MCxvPWUubGVuZ3RoO248bztuKz00KXt0PWVbbl07aT1lW24rMV07YT1lW24rMl07cz1lW24rM107ZVtyKytdPWkqKC02NjA2MzU2Njk0MjAzNjRlLTE5KmkrLjAwMDQzNzEzMDQ3NTkyNjIzMiphLTU0MDgwNjEwMDY0NTk5ZS0xOCp0Ky4wMDA0ODQ0OTc5NzEyMDI4MSpzLS4xNTQzNjIxNTE4NzExMjYpLTEyMi42NzE5NTQwNjg5NCthKigtLjAwMDk1Nzk2NDM3ODQ0NTc3MyphKy4wMDA4MTcwNzY5MTEzNDY2MjUqdC0uMDA0NzcyNzE0MDU0MDg3NDcqcysxLjUzMzgwMjUzMjIxNzM0KSt0KiguMDAwOTYxMjUwMTg0MTMwNjg4KnQtLjAwMjY2MjU3MzMyMjgzOTMzKnMrLjQ4MzU3MDg4NDUxMjY1KStzKigtLjAwMDMzNjE5NzE3NzYxODM5NCpzKy40ODQ3OTE1NjE0OTA3NzYpO2VbcisrXT0xMDcuMjY4MDM5Mzk3NzI0K2kqKDIxOTkyNzEwNDUyNTc0MWUtMTkqaS0uMDAwNjQwOTkyMDE4Mjk3OTQ1KmErLjAwMDY1OTM5NzAwMTI0NTU3Nyp0Ky4wMDA0MjYxMDU2NTI5Mzg4Mzcqcy0uMTc2NDkxNzkyNDYyODc1KSthKigtLjAwMDc3ODI2OTk0MTUxMzY4MyphKy4wMDEzMDg3MjI2MTQwODI3NSp0Ky4wMDA3NzA0ODI2MzE4MDExMzIqcy0uMTUxMDUxNDkyNzc1NTYyKSt0KiguMDAxMjY5MzUzNjgxMTQ4NDMqdC0uMDAyNjUwOTAxODkwMTA4OTgqcysuMjU4MDI5MTAyMDY4NDUpK3MqKC0uMDAwMzE4OTEzMTE3NTg4MzI4KnMtLjIxMzc0MjQwMDMyMzY2NSk7ZVtyKytdPWkqKC0uMDAwNTcwMTE1MTk2OTczNjc3KmktMjYzNDA5MDUxMDA0NTg5ZS0xOSphKy4wMDIwNzQxMDg4MTE1MDEyKnQtLjAwMjg4MjYwMjM2ODUzNDQyKnMrLjgxNDI3Mjk2ODM1OTI5NSktMjAuODEwMDEyNTQ2OTQ3K2EqKC0xNTM0OTYwNTc0NDA5NzVlLTE5KmEtLjAwMDEzMjY4OTA0Mzk2MTQ0Nip0Ky4wMDA1NjA4MzM2OTEyNDI4MTIqcy0uMTk1MTUyMDI3NTM0MDQ5KSt0KiguMDAxNzQ0MTgxMzI5Mjc1ODIqdC0uMDAyNTUyNDMzMjE0MzkzNDcqcysuMTE2OTM1MDIwNDY1MTQ1KStzKigtLjAwMDM0MzUzMTk5NjUxMDU1NSpzKy4yNDE2NTI2MDIzMjQwNyl9cmV0dXJuIGUuc3ViYXJyYXkoMCxyKX1fY29udmVydFljY2tUb1JnYmEoZSl7Zm9yKGxldCB0PTAsaT1lLmxlbmd0aDt0PGk7dCs9NCl7Y29uc3QgaT1lW3RdLGE9ZVt0KzFdLHM9ZVt0KzJdLHI9ZVt0KzNdO2VbdF09YSooLTY2MDYzNTY2OTQyMDM2NGUtMTkqYSsuMDAwNDM3MTMwNDc1OTI2MjMyKnMtNTQwODA2MTAwNjQ1OTllLTE4KmkrLjAwMDQ4NDQ5Nzk3MTIwMjgxKnItLjE1NDM2MjE1MTg3MTEyNiktMTIyLjY3MTk1NDA2ODk0K3MqKC0uMDAwOTU3OTY0Mzc4NDQ1NzczKnMrLjAwMDgxNzA3NjkxMTM0NjYyNSppLS4wMDQ3NzI3MTQwNTQwODc0NypyKzEuNTMzODAyNTMyMjE3MzQpK2kqKC4wMDA5NjEyNTAxODQxMzA2ODgqaS0uMDAyNjYyNTczMzIyODM5MzMqcisuNDgzNTcwODg0NTEyNjUpK3IqKC0uMDAwMzM2MTk3MTc3NjE4Mzk0KnIrLjQ4NDc5MTU2MTQ5MDc3Nik7ZVt0KzFdPTEwNy4yNjgwMzkzOTc3MjQrYSooMjE5OTI3MTA0NTI1NzQxZS0xOSphLS4wMDA2NDA5OTIwMTgyOTc5NDUqcysuMDAwNjU5Mzk3MDAxMjQ1NTc3KmkrLjAwMDQyNjEwNTY1MjkzODgzNypyLS4xNzY0OTE3OTI0NjI4NzUpK3MqKC0uMDAwNzc4MjY5OTQxNTEzNjgzKnMrLjAwMTMwODcyMjYxNDA4Mjc1KmkrLjAwMDc3MDQ4MjYzMTgwMTEzMipyLS4xNTEwNTE0OTI3NzU1NjIpK2kqKC4wMDEyNjkzNTM2ODExNDg0MyppLS4wMDI2NTA5MDE4OTAxMDg5OCpyKy4yNTgwMjkxMDIwNjg0NSkrciooLS4wMDAzMTg5MTMxMTc1ODgzMjgqci0uMjEzNzQyNDAwMzIzNjY1KTtlW3QrMl09YSooLS4wMDA1NzAxMTUxOTY5NzM2NzcqYS0yNjM0MDkwNTEwMDQ1ODllLTE5KnMrLjAwMjA3NDEwODgxMTUwMTIqaS0uMDAyODgyNjAyMzY4NTM0NDIqcisuODE0MjcyOTY4MzU5Mjk1KS0yMC44MTAwMTI1NDY5NDcrcyooLTE1MzQ5NjA1NzQ0MDk3NWUtMTkqcy0uMDAwMTMyNjg5MDQzOTYxNDQ2KmkrLjAwMDU2MDgzMzY5MTI0MjgxMipyLS4xOTUxNTIwMjc1MzQwNDkpK2kqKC4wMDE3NDQxODEzMjkyNzU4MippLS4wMDI1NTI0MzMyMTQzOTM0NypyKy4xMTY5MzUwMjA0NjUxNDUpK3IqKC0uMDAwMzQzNTMxOTk2NTEwNTU1KnIrLjI0MTY1MjYwMjMyNDA3KTtlW3QrM109MjU1fXJldHVybiBlfV9jb252ZXJ0WWNja1RvQ215ayhlKXtsZXQgdCxpLGE7Zm9yKGxldCBzPTAscj1lLmxlbmd0aDtzPHI7cys9NCl7dD1lW3NdO2k9ZVtzKzFdO2E9ZVtzKzJdO2Vbc109NDM0LjQ1Ni10LTEuNDAyKmE7ZVtzKzFdPTExOS41NDEtdCsuMzQ0KmkrLjcxNCphO2VbcysyXT00ODEuODE2LXQtMS43NzIqaX1yZXR1cm4gZX1fY29udmVydENteWtUb1JnYihlKXtsZXQgdCxpLGEscyxyPTA7Zm9yKGxldCBuPTAsbz1lLmxlbmd0aDtuPG87bis9NCl7dD1lW25dO2k9ZVtuKzFdO2E9ZVtuKzJdO3M9ZVtuKzNdO2VbcisrXT0yNTUrdCooLTY3NDcxNDcwNzM2MDI0NDFlLTIwKnQrLjAwMDgzNzkyNjIxMjEwMTM3MjcqaSsuMDAwMjg5NDcxODE4ODY0MzI5NCphKy4wMDMyNjQyMzEwNTc1Mzc4MDYqcy0xLjExODU2MTE4NjcyMDM5MzcpK2kqKDI2Mzc0MTA3NjE2MDg5NDA1ZS0yMSppLTg2MjY5NDkxNTg2Mzg1NzJlLTIwKmEtLjAwMDI3NDg3NjkwNjc0OTk0OTEqcy0uMDIxNTU2ODg3OTQ5Nzg5NjcpK2EqKC0zODc4MDk5MjEyODY5MzYzZS0yMCphLS4wMDAzMjY3ODA4Mjc5NDg1Mjg2KnMrLjA2ODY3NDIyMzg1OTUzNDUpLXMqKC4wMDAzMzYxOTcxNzc2MTgzOTM3KnMrLjc0MzA2NTkxNTEzNDIyNTQpO2VbcisrXT0yNTUrdCooLjAwMDEzNTk2MzcyODEzNTg4ODQ4KnQrLjAwMDkyNDUzNzEzMjU3MzU4NSppKy4wMDAxMDU2NzM1OTYxODY4MzU5MyphKy4wMDA0NzkxODY0Njg3NDM2NTEyKnMtLjMxMDk2ODk1ODc1MTU4NzUpK2kqKC0uMDAwMjM1NDUzNDYxMDgzNzAzNDQqaSsuMDAwMjcwMjg0NTI1MzUzNDcxNCphKy4wMDIwMjAwMzA4OTc3MzA3MTU2KnMtLjc0ODgwNTIxNjcwMTU0OTQpK2EqKDY4MzQ4MTU5OTgyMzU2NjJlLTIwKmErLjAwMDE1MTY4NDUyMzYzNDYwOTczKnMtLjA5NzUxOTI3Nzc0NzI4OTMzKS1zKiguMDAwMzE4OTEzMTE3NTg4MzI4MSpzKy43MzY0ODgzODA3NzMzMTY4KTtlW3IrK109MjU1K3QqKDEzNTk4NjUwNDExMzg1MzA3ZS0yMSp0Ky4wMDAxMjQyMzk1NjE3NTQ5MDg1MSppKy4wMDA0NzUxOTg1MDk3NTgzNTg5KmEtMzY3MjkzMTc0NzY2MzA0MjJlLTIyKnMtLjA1NTYyMTg2OTgwMjY0MDM0KStpKiguMDAwMTYxNDEzODA1OTg3MjQ2NzYqaSsuMDAwOTY5MjIzOTEzMDcyNTE4NiphKy4wMDA3NzgyNjkyNDUwMDM2MjUzKnMtLjQ0MDE1MjMyMzY3NTI2NDYzKSthKig1LjA2ODg4MjkxNDA2ODc2OWUtNyphKy4wMDE3Nzc4MzY5MDExMzc1MDcxKnMtLjc1OTE0NTQ2NDk3NDk2MDkpLXMqKC4wMDAzNDM1MzE5OTY1MTA1NTUzKnMrLjcwNjM3NzAxODYxNjAxNDQpfXJldHVybiBlLnN1YmFycmF5KDAscil9X2NvbnZlcnRDbXlrVG9SZ2JhKGUpe2ZvcihsZXQgdD0wLGk9ZS5sZW5ndGg7dDxpO3QrPTQpe2NvbnN0IGk9ZVt0XSxhPWVbdCsxXSxzPWVbdCsyXSxyPWVbdCszXTtlW3RdPTI1NStpKigtNjc0NzE0NzA3MzYwMjQ0MWUtMjAqaSsuMDAwODM3OTI2MjEyMTAxMzcyNyphKy4wMDAyODk0NzE4MTg4NjQzMjk0KnMrLjAwMzI2NDIzMTA1NzUzNzgwNipyLTEuMTE4NTYxMTg2NzIwMzkzNykrYSooMjYzNzQxMDc2MTYwODk0MDVlLTIxKmEtODYyNjk0OTE1ODYzODU3MmUtMjAqcy0uMDAwMjc0ODc2OTA2NzQ5OTQ5MSpyLS4wMjE1NTY4ODc5NDk3ODk2NykrcyooLTM4NzgwOTkyMTI4NjkzNjNlLTIwKnMtLjAwMDMyNjc4MDgyNzk0ODUyODYqcisuMDY4Njc0MjIzODU5NTM0NSktciooLjAwMDMzNjE5NzE3NzYxODM5MzcqcisuNzQzMDY1OTE1MTM0MjI1NCk7ZVt0KzFdPTI1NStpKiguMDAwMTM1OTYzNzI4MTM1ODg4NDgqaSsuMDAwOTI0NTM3MTMyNTczNTg1KmErLjAwMDEwNTY3MzU5NjE4NjgzNTkzKnMrLjAwMDQ3OTE4NjQ2ODc0MzY1MTIqci0uMzEwOTY4OTU4NzUxNTg3NSkrYSooLS4wMDAyMzU0NTM0NjEwODM3MDM0NCphKy4wMDAyNzAyODQ1MjUzNTM0NzE0KnMrLjAwMjAyMDAzMDg5NzczMDcxNTYqci0uNzQ4ODA1MjE2NzAxNTQ5NCkrcyooNjgzNDgxNTk5ODIzNTY2MmUtMjAqcysuMDAwMTUxNjg0NTIzNjM0NjA5NzMqci0uMDk3NTE5Mjc3NzQ3Mjg5MzMpLXIqKC4wMDAzMTg5MTMxMTc1ODgzMjgxKnIrLjczNjQ4ODM4MDc3MzMxNjgpO2VbdCsyXT0yNTUraSooMTM1OTg2NTA0MTEzODUzMDdlLTIxKmkrLjAwMDEyNDIzOTU2MTc1NDkwODUxKmErLjAwMDQ3NTE5ODUwOTc1ODM1ODkqcy0zNjcyOTMxNzQ3NjYzMDQyMmUtMjIqci0uMDU1NjIxODY5ODAyNjQwMzQpK2EqKC4wMDAxNjE0MTM4MDU5ODcyNDY3NiphKy4wMDA5NjkyMjM5MTMwNzI1MTg2KnMrLjAwMDc3ODI2OTI0NTAwMzYyNTMqci0uNDQwMTUyMzIzNjc1MjY0NjMpK3MqKDUuMDY4ODgyOTE0MDY4NzY5ZS03KnMrLjAwMTc3NzgzNjkwMTEzNzUwNzEqci0uNzU5MTQ1NDY0OTc0OTYwOSktciooLjAwMDM0MzUzMTk5NjUxMDU1NTMqcisuNzA2Mzc3MDE4NjE2MDE0NCk7ZVt0KzNdPTI1NX1yZXR1cm4gZX1nZXREYXRhKHt3aWR0aDplLGhlaWdodDp0LGZvcmNlUkdCQTppPSExLGZvcmNlUkdCOmE9ITEsaXNTb3VyY2VQREY6cz0hMX0pe2lmKHRoaXMubnVtQ29tcG9uZW50cz40KXRocm93IG5ldyBKcGVnRXJyb3IoIlVuc3VwcG9ydGVkIGNvbG9yIG1vZGUiKTtjb25zdCByPXRoaXMuX2dldExpbmVhcml6ZWRCbG9ja0RhdGEoZSx0LHMpO2lmKDE9PT10aGlzLm51bUNvbXBvbmVudHMmJihpfHxhKSl7Y29uc3QgZT1yLmxlbmd0aCooaT80OjMpLHQ9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGUpO2xldCBhPTA7aWYoaSkhZnVuY3Rpb24gZ3JheVRvUkdCQShlLHQpe2lmKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKWZvcihsZXQgaT0wLGE9ZS5sZW5ndGg7aTxhO2krKyl0W2ldPTY1NzkzKmVbaV18NDI3ODE5MDA4MDtlbHNlIGZvcihsZXQgaT0wLGE9ZS5sZW5ndGg7aTxhO2krKyl0W2ldPTE2ODQzMDA4KmVbaV18MjU1fShyLG5ldyBVaW50MzJBcnJheSh0LmJ1ZmZlcikpO2Vsc2UgZm9yKGNvbnN0IGUgb2Ygcil7dFthKytdPWU7dFthKytdPWU7dFthKytdPWV9cmV0dXJuIHR9aWYoMz09PXRoaXMubnVtQ29tcG9uZW50cyYmdGhpcy5faXNDb2xvckNvbnZlcnNpb25OZWVkZWQpe2lmKGkpe2NvbnN0IGU9bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHIubGVuZ3RoLzMqNCk7cmV0dXJuIHRoaXMuX2NvbnZlcnRZY2NUb1JnYmEocixlKX1yZXR1cm4gdGhpcy5fY29udmVydFljY1RvUmdiKHIpfWlmKDQ9PT10aGlzLm51bUNvbXBvbmVudHMpe2lmKHRoaXMuX2lzQ29sb3JDb252ZXJzaW9uTmVlZGVkKXJldHVybiBpP3RoaXMuX2NvbnZlcnRZY2NrVG9SZ2JhKHIpOmE/dGhpcy5fY29udmVydFljY2tUb1JnYihyKTp0aGlzLl9jb252ZXJ0WWNja1RvQ215ayhyKTtpZihpKXJldHVybiB0aGlzLl9jb252ZXJ0Q215a1RvUmdiYShyKTtpZihhKXJldHVybiB0aGlzLl9jb252ZXJ0Q215a1RvUmdiKHIpfXJldHVybiByfX1jbGFzcyBKcGVnU3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxpKXtsZXQgYTtmb3IoOy0xIT09KGE9ZS5nZXRCeXRlKCkpOylpZigyNTU9PT1hKXtlLnNraXAoLTEpO2JyZWFrfXN1cGVyKHQpO3RoaXMuc3RyZWFtPWU7dGhpcy5kaWN0PWUuZGljdDt0aGlzLm1heWJlTGVuZ3RoPXQ7dGhpcy5wYXJhbXM9aX1nZXQgYnl0ZXMoKXtyZXR1cm4gc2hhZG93KHRoaXMsImJ5dGVzIix0aGlzLnN0cmVhbS5nZXRCeXRlcyh0aGlzLm1heWJlTGVuZ3RoKSl9ZW5zdXJlQnVmZmVyKGUpe31yZWFkQmxvY2soKXtpZih0aGlzLmVvZilyZXR1cm47Y29uc3QgZT17ZGVjb2RlVHJhbnNmb3JtOnZvaWQgMCxjb2xvclRyYW5zZm9ybTp2b2lkIDB9LHQ9dGhpcy5kaWN0LmdldEFycmF5KCJEIiwiRGVjb2RlIik7aWYoKHRoaXMuZm9yY2VSR0JBfHx0aGlzLmZvcmNlUkdCKSYmQXJyYXkuaXNBcnJheSh0KSl7Y29uc3QgaT10aGlzLmRpY3QuZ2V0KCJCUEMiLCJCaXRzUGVyQ29tcG9uZW50Iil8fDgsYT10Lmxlbmd0aCxzPW5ldyBJbnQzMkFycmF5KGEpO2xldCByPSExO2NvbnN0IG49KDE8PGkpLTE7Zm9yKGxldCBlPTA7ZTxhO2UrPTIpe3NbZV09MjU2Kih0W2UrMV0tdFtlXSl8MDtzW2UrMV09dFtlXSpufDA7MjU2PT09c1tlXSYmMD09PXNbZSsxXXx8KHI9ITApfXImJihlLmRlY29kZVRyYW5zZm9ybT1zKX1pZih0aGlzLnBhcmFtcyBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IHQ9dGhpcy5wYXJhbXMuZ2V0KCJDb2xvclRyYW5zZm9ybSIpO051bWJlci5pc0ludGVnZXIodCkmJihlLmNvbG9yVHJhbnNmb3JtPXQpfWNvbnN0IGk9bmV3IEpwZWdJbWFnZShlKTtpLnBhcnNlKHRoaXMuYnl0ZXMpO2NvbnN0IGE9aS5nZXREYXRhKHt3aWR0aDp0aGlzLmRyYXdXaWR0aCxoZWlnaHQ6dGhpcy5kcmF3SGVpZ2h0LGZvcmNlUkdCQTp0aGlzLmZvcmNlUkdCQSxmb3JjZVJHQjp0aGlzLmZvcmNlUkdCLGlzU291cmNlUERGOiEwfSk7dGhpcy5idWZmZXI9YTt0aGlzLmJ1ZmZlckxlbmd0aD1hLmxlbmd0aDt0aGlzLmVvZj0hMH19dmFyIG9pLGdpPShvaT0iZmlsZTovLy9DOi9wZGZqcy9ib3Rpby1maWxlcy1wZGZqcy9wcml2YXRlL2Q2OTE5YmVkMDNjNjY3Ny9leHRlcm5hbC9vcGVuanBlZy9vcGVuanBlZy5qcyIsZnVuY3Rpb24oZT17fSl7dmFyIHQsaSxhPWU7bmV3IFByb21pc2UoKChlLGEpPT57dD1lO2k9YX0pKTthLmRlY29kZT1mdW5jdGlvbihlLHQpe2NvbnN0IGk9ZS5sZW5ndGgscz1hLl9tYWxsb2MoaSk7YS5IRUFQVTguc2V0KGUscyk7Y29uc3Qgcj1hLl9qcDJfZGVjb2RlKHMsaSx0PzE6MCk7YS5fZnJlZShzKTtpZihyKXtjb25zdHtlcnJvck1lc3NhZ2VzOmV9PWE7aWYoZSl7ZGVsZXRlIGEuZXJyb3JNZXNzYWdlcztyZXR1cm4gZX1yZXR1cm4iVW5rbm93biBlcnJvciJ9Y29uc3R7aW1hZ2VEYXRhOm59PWE7YS5pbWFnZURhdGE9bnVsbDtyZXR1cm4gbn07dmFyIHMscj1PYmplY3QuYXNzaWduKHt9LGEpLG49Ii4vdGhpcy5wcm9ncmFtIixvPSIiOyJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihvPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKTtvaSYmKG89b2kpO289by5zdGFydHNXaXRoKCJibG9iOiIpPyIiOm8uc3Vic3RyKDAsby5yZXBsYWNlKC9bPyNdLiovLCIiKS5sYXN0SW5kZXhPZigiLyIpKzEpO3ZhciBnLGMsQyxoLGwsUT1hLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLEU9YS5wcmludEVycnx8Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oYSxyKTtyPW51bGw7YS5hcmd1bWVudHMmJmEuYXJndW1lbnRzO2EudGhpc1Byb2dyYW0mJihuPWEudGhpc1Byb2dyYW0pO2EucXVpdCYmYS5xdWl0O2Eud2FzbUJpbmFyeSYmKGc9YS53YXNtQmluYXJ5KTtmdW5jdGlvbiB0cnlQYXJzZUFzRGF0YVVSSShlKXtpZihpc0RhdGFVUkkoZSkpcmV0dXJuIGZ1bmN0aW9uIGludEFycmF5RnJvbUJhc2U2NChlKXtmb3IodmFyIHQ9YXRvYihlKSxpPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxhPTA7YTx0Lmxlbmd0aDsrK2EpaVthXT10LmNoYXJDb2RlQXQoYSk7cmV0dXJuIGl9KGUuc2xpY2UoYi5sZW5ndGgpKX1mdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpe3ZhciBlPWMuYnVmZmVyO2EuSEVBUDg9Qz1uZXcgSW50OEFycmF5KGUpO2EuSEVBUDE2PW5ldyBJbnQxNkFycmF5KGUpO2EuSEVBUFU4PWg9bmV3IFVpbnQ4QXJyYXkoZSk7YS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShlKTthLkhFQVAzMj1uZXcgSW50MzJBcnJheShlKTthLkhFQVBVMzI9bD1uZXcgVWludDMyQXJyYXkoZSk7YS5IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoZSk7YS5IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoZSl9dmFyIHUsZD1bXSxmPVtdLHA9W10sbT0wLHk9bnVsbCx3PW51bGwsYj0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCIsaXNEYXRhVVJJPWU9PmUuc3RhcnRzV2l0aChiKTt1PSJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsQUdGemJRRUFBQUFCemdFYVlBTi9mMzhCZjJBRWYzOS9md0YvWUFGL0FHQUNmMzhBWUFGL0FYOWdBMzkvZndCZ0FuOS9BWDlnQkg5L2YzOEFZQU4vZm44QmZtQUNmbjhCZjJBRmYzOS9mMzhCZjJBQ2ZuOEJmbUFEZjM1L0FYOWdBQUYvWUFkL2YzOS9mMzkvQVg5Z0JYOS9mMzkvQUdBSmYzOS9mMzkvZjM5L0FYOWdDMzkvZjM5L2YzOS9mMzkvQVg5Z0JuOS9mMzkvZndGL1lBWi9mSDkvZjM4QmYyQUlmMzkvZjM5L2YzOEFZQWgvZjM5L2YzOS9md0YvWUFBQVlBWi9mMzkvZjM4QVlBZC9mMzkvZjM5L0FHQUNmSDhCZkFJeENBRmhBV0VBQWdGaEFXSUFCQUZoQVdNQUJnRmhBV1FBQmdGaEFXVUFBUUZoQVdZQUJRRmhBV2NBQWdGaEFXZ0FBd08rQWJ3QkJ3SUZBQVlFQUFVR0JRRUVEd1VFRkFJR0FnWUNBZ0FRRVFRQ0NSSUNCUUlDQWdRSEJBSU5EQVlDRlFNSEFBQUVBd0VXQ2dvREFBb0dBUVFFQlFVTkRnRUJBd0FEQmdJUUJCY1lBZ2NHQXdjSEFRRUNBQVFFR1FZSEJBNFBBQVFDQWdJQUJnQUdBUUVCQVFFQkFRRUFBQUFBQUFZREFnSUNBd01EQXdNQUF4TUlCQTBBQXdNQUJBZ0pDd2dBQUFFQkFRRUJBUUVCREFFQUJBUUZDZzRCRWhFQkFBQUdBd01CQlFVRkJRVUZCUVVCQ3dFQkFRRUJBUUVCQVFrRUJRRndBV3hzQlFjQkFZSUNnSUFDQmdnQmZ3RkJnTmdGQ3djYkJnRnBBZ0FCYWdBNkFXc0Fqd0VCYkFBSkFXMEJBQUZ1QUk0QkNiSUJBUUJCQVF0clNzTUJ1UUZzYkMrZUFaTUJrQUdFQVlNQmdnR0JBWUFCZjM1OVMzcDVlSGQyZFhSemNuRndiMjdDQWNFQndBRy9BYjRCdlFFNXZBRzdBVGs1dWdHNEFiY0J0Z0cxQWJRQnN3R3lBYkVCc0FHcUFaOEJuUUdjQVpzQm1nR1pBWmdCbHdHV0FaVUJsQUdTQVpFQlFrTkZTMEY4VERGSmUwZytQMGNrSUtJQm9RR2pBYXNCcndHc0FhWUJvQUdrQWFVQnJRR3VBV21uQWFnQnFRRktqUUdNQVlVQmh3R0dBWWtCaXdHSUFRcW11QTI4QVlJQ0FRTi9Jd0JCa0FScklnUWtBQUpBSUFCRkRRQUNRQUpBQWtBQ1FDQUJRUUZyRGdRQUFRUUNCQXNnQUVFTWFpRUJEQUlMSUFCQkVHb2hBU0FBUVFScUlRQU1BUXNnQUVFVWFpRUJJQUJCQ0dvaEFBc2dBU2dDQUNJRlJRMEFJQUpGRFFBZ0FDZ0NBQ0VHSUFSQkFFR0FCQkFPSWdFZ0F6WUNqQVFqQUVHZ0FXc2lBQ1FBSUFBZ0FUWUNsQUVnQUVIL0F6WUNtQUVnQUVFQVFaQUJFQTRpQUVGL05nSk1JQUJCNWdBMkFpUWdBRUYvTmdKUUlBQWdBRUdmQVdvMkFpd2dBQ0FBUVpRQmFqWUNWQ0FCUVFBNkFBQWdBQ0FDSUFOQjV3QkI2QUFRWkNBQVFhQUJhaVFBSUFGQkFEb0Evd01nQVNBR0lBVVJBd0FMSUFSQmtBUnFKQUFMMEFJQkJYOGdBQVJBSUFCQkJHc2lBeWdDQUNJRUlRRWdBeUVDSUFCQkNHc29BZ0FpQUNBQVFYNXhJZ0JIQkVBZ0FpQUFheUlDS0FJRUlnRWdBaWdDQ0NJRk5nSUlJQVVnQVRZQ0JDQUFJQVJxSVFFTElBTWdCR29pQUNnQ0FDSURJQUFnQTJwQkJHc29BZ0JIQkVBZ0FDZ0NCQ0lFSUFBb0FnZ2lBRFlDQ0NBQUlBUTJBZ1FnQVNBRGFpRUJDeUFDSUFFMkFnQWdBaUFCUVh4eGFrRUVheUFCUVFGeU5nSUFJQUlDZnlBQ0tBSUFRUWhySWdCQi93Qk5CRUFnQUVFRGRrRUJhd3dCQ3lBQVp5RURJQUJCSFNBRGEzWkJCSE1nQTBFQ2RHdEI3Z0JxSUFCQi94OU5EUUFhUVQ4Z0FFRWVJQU5yZGtFQ2N5QURRUUYwYTBISEFHb2lBQ0FBUVQ5UEd3c2lBVUVFZENJQVFhREdBV28yQWdRZ0FpQUFRYWpHQVdvaUFDZ0NBRFlDQ0NBQUlBSTJBZ0FnQWlnQ0NDQUNOZ0lFUWFqT0FVR296Z0VwQXdCQ0FTQUJyWWFFTndNQUN3dkpBZ0VFZnlBQlFRQTJBZ0FDUUNBQ1JRMEFJQUVnQW1vaEF3SkFJQUpCRUVrRVFDQUFJUUVNQVFzQ1FDQUFJQUpxSUFGTkRRQWdBQ0FEVHcwQUlBQWhBUXdCQ3lBRFFSQnJJUVlnQUNBQ1FYQnhJZ1ZxSVFFZ0F5QUZheUVEQTBBZ0JpQUVheUFBSUFScS9RQUFBUDBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBORHc0TkRBc0tDUWdIQmdVRUF3SUJBUDBMQUFBZ0JFRVFhaUlFSUFWSERRQUxJQUlnQlVZTkFRc0NRQ0FDUVFOeElnWkZCRUFnQlNFRURBRUxRUUFoQUNBRklRUURRQ0FEUVFGcklnTWdBUzBBQURvQUFDQUVRUUZxSVFRZ0FVRUJhaUVCSUFCQkFXb2lBQ0FHUncwQUN3c2dCU0FDYTBGOFN3MEFBMEFnQTBFQmF5QUJMUUFBT2dBQUlBTkJBbXNnQVMwQUFUb0FBQ0FEUVFOcklBRXRBQUk2QUFBZ0EwRUVheUlESUFFdEFBTTZBQUFnQVVFRWFpRUJJQVJCQkdvaUJDQUNSdzBBQ3dzTGdBUUJBMzhnQWtHQUJFOEVRQ0FBSUFFZ0FoQUZJQUFQQ3lBQUlBSnFJUU1DUUNBQUlBRnpRUU54UlFSQUFrQWdBRUVEY1VVRVFDQUFJUUlNQVFzZ0FrVUVRQ0FBSVFJTUFRc2dBQ0VDQTBBZ0FpQUJMUUFBT2dBQUlBRkJBV29oQVNBQ1FRRnFJZ0pCQTNGRkRRRWdBaUFEU1EwQUN3c0NRQ0FEUVh4eElnUkJ3QUJKRFFBZ0FpQUVRVUJxSWdWTERRQURRQ0FDSUFFb0FnQTJBZ0FnQWlBQktBSUVOZ0lFSUFJZ0FTZ0NDRFlDQ0NBQ0lBRW9BZ3cyQWd3Z0FpQUJLQUlRTmdJUUlBSWdBU2dDRkRZQ0ZDQUNJQUVvQWhnMkFoZ2dBaUFCS0FJY05nSWNJQUlnQVNnQ0lEWUNJQ0FDSUFFb0FpUTJBaVFnQWlBQktBSW9OZ0lvSUFJZ0FTZ0NMRFlDTENBQ0lBRW9BakEyQWpBZ0FpQUJLQUkwTmdJMElBSWdBU2dDT0RZQ09DQUNJQUVvQWp3MkFqd2dBVUZBYXlFQklBSkJRR3NpQWlBRlRRMEFDd3NnQWlBRVR3MEJBMEFnQWlBQktBSUFOZ0lBSUFGQkJHb2hBU0FDUVFScUlnSWdCRWtOQUFzTUFRc2dBMEVFU1FSQUlBQWhBZ3dCQ3lBQUlBTkJCR3NpQkVzRVFDQUFJUUlNQVFzZ0FDRUNBMEFnQWlBQkxRQUFPZ0FBSUFJZ0FTMEFBVG9BQVNBQ0lBRXRBQUk2QUFJZ0FpQUJMUUFET2dBRElBRkJCR29oQVNBQ1FRUnFJZ0lnQkUwTkFBc0xJQUlnQTBrRVFBTkFJQUlnQVMwQUFEb0FBQ0FCUVFGcUlRRWdBa0VCYWlJQ0lBTkhEUUFMQ3lBQUN6QUJBWDhDUUNBQVJRMEFJQUZGRFFCQkNDQUFJQUZzSWdFUUd5SUFCRUFnQUVFQUlBRVFEaG9MSUFBaEFnc2dBZ3NSQUNBQVJRUkFRUUFQQzBFSUlBQVFHd3Z5QWdJQ2Z3RitBa0FnQWtVTkFDQUFJQUU2QUFBZ0FDQUNhaUlEUVFGcklBRTZBQUFnQWtFRFNRMEFJQUFnQVRvQUFpQUFJQUU2QUFFZ0EwRURheUFCT2dBQUlBTkJBbXNnQVRvQUFDQUNRUWRKRFFBZ0FDQUJPZ0FESUFOQkJHc2dBVG9BQUNBQ1FRbEpEUUFnQUVFQUlBQnJRUU54SWdScUlnTWdBVUgvQVhGQmdZS0VDR3dpQVRZQ0FDQURJQUlnQkd0QmZIRWlCR29pQWtFRWF5QUJOZ0lBSUFSQkNVa05BQ0FESUFFMkFnZ2dBeUFCTmdJRUlBSkJDR3NnQVRZQ0FDQUNRUXhySUFFMkFnQWdCRUVaU1EwQUlBTWdBVFlDR0NBRElBRTJBaFFnQXlBQk5nSVFJQU1nQVRZQ0RDQUNRUkJySUFFMkFnQWdBa0VVYXlBQk5nSUFJQUpCR0dzZ0FUWUNBQ0FDUVJ4cklBRTJBZ0FnQkNBRFFRUnhRUmh5SWdScklnSkJJRWtOQUNBQnJVS0JnSUNBRUg0aEJTQURJQVJxSVFFRFFDQUJJQVUzQXhnZ0FTQUZOd01RSUFFZ0JUY0RDQ0FCSUFVM0F3QWdBVUVnYWlFQklBSkJJR3NpQWtFZlN3MEFDd3NnQUFzbkFRRi9Jd0JCRUdzaUF5UUFJQU1nQWpZQ0RDQUFJQUVnQWtFQVFRQVFaQ0FEUVJCcUpBQUw2QVVCQ1g4Z0FVVUVRRUVBRHdzQ2Z5QUFSUVJBUVFnZ0FSQWJEQUVMSUFGRkJFQWdBQkFKUVFBTUFRc0NRQ0FCUVVkTERRQWdBQUovUVFnZ0FVRURha0Y4Y1NBQlFRaE5HeUlIUVFocUlRRUNRQUovQWtBZ0FFRUVheUlLSWdRb0FnQWlCU0FFYWlJQ0tBSUFJZ2tnQWlBSmFpSUlRUVJyS0FJQVJ3UkFJQWdnQVNBRWFpSURRUkJxVHdSQUlBSW9BZ1FpQlNBQ0tBSUlJZ0kyQWdnZ0FpQUZOZ0lFSUFNZ0NDQURheUlDTmdJQUlBTWdBa0Y4Y1dwQkJHc2dBa0VCY2pZQ0FDQURBbjhnQXlnQ0FFRUlheUlDUWY4QVRRUkFJQUpCQTNaQkFXc01BUXNnQWtFZElBSm5JZ1ZyZGtFRWN5QUZRUUowYTBIdUFHb2dBa0gvSDAwTkFCcEJQeUFDUVI0Z0JXdDJRUUp6SUFWQkFYUnJRY2NBYWlJQ0lBSkJQMDhiQ3lJQ1FRUjBJZ1ZCb01ZQmFqWUNCQ0FESUFWQnFNWUJhaUlGS0FJQU5nSUlJQVVnQXpZQ0FDQURLQUlJSUFNMkFnUkJxTTRCUWFqT0FTa0RBRUlCSUFLdGhvUTNBd0FnQkNBQk5nSUFEQVFMSUFNZ0NFc05BU0FDS0FJRUlnRWdBaWdDQ0NJRE5nSUlJQU1nQVRZQ0JDQUVJQVVnQ1dvaUFUWUNBQXdEQ3lBRklBRkJFR3BQQkVBZ0JDQUJOZ0lBSUFRZ0FVRjhjV3BCQkdzZ0FUWUNBQ0FCSUFScUlnTWdCU0FCYXlJQk5nSUFJQU1nQVVGOGNXcEJCR3NnQVVFQmNqWUNBQ0FEQW44Z0F5Z0NBRUVJYXlJQlFmOEFUUVJBSUFGQkEzWkJBV3NNQVFzZ0FVRWRJQUZuSWdScmRrRUVjeUFFUVFKMGEwSHVBR29nQVVIL0gwME5BQnBCUHlBQlFSNGdCR3QyUVFKeklBUkJBWFJyUWNjQWFpSUJJQUZCUDA4YkN5SUJRUVIwSWdSQm9NWUJhallDQkNBRElBUkJxTVlCYWlJRUtBSUFOZ0lJSUFRZ0F6WUNBQ0FES0FJSUlBTTJBZ1JCcU00QlFhak9BU2tEQUVJQklBR3Rob1EzQXdCQkFRd0VDMEVCSUFFZ0JVME5BUm9MUVFBTERBRUxJQVFnQVVGOGNXcEJCR3NnQVRZQ0FFRUJDdzBCR2tFSUlBY1FHeUlCUlEwQUlBRWdBQ0FISUFvb0FnQkJDR3NpQmlBR0lBZExHeEFMR2lBQUVBa2dBU0VHQ3lBR0N3c1hBQ0FBTFFBQVFTQnhSUVJBSUFFZ0FpQUFFRFlhQ3d1OEJBRUZmeUFDSUFBb0FqQWlCVTBFUUNBQklBQW9BaVFnQWhBTEdpQUFJQUFvQWlRZ0FtbzJBaVFnQUNBQUtBSXdJQUpyTmdJd0lBQWdBQ2tET0NBQ3JYdzNBemdnQWc4TElBQXRBRVJCQkhFRVFDQUJJQUFvQWlRZ0JSQUxHaUFBS0FJd0lRRWdBRUVBTmdJd0lBQWdBU0FBS0FJa2FqWUNKQ0FBSUFBcEF6Z2dBYTE4TndNNElBVkJmeUFGR3c4TEFrQWdCUVJBSUFFZ0FDZ0NKQ0FGRUFzaEJDQUFJQUFvQWlBaUJ6WUNKQ0FBS0FJd0lRRWdBRUVBTmdJd0lBQWdBQ2tET0NBQnJYdzNBemdnQWlBQmF5RUNJQUVnQkdvaEFRd0JDeUFBSUFBb0FpQWlCellDSkFzQ1FBSkFBMEFDUUNBQUtBSUFJUVFnQUNnQ0VDRUdBa0FnQUNnQ1FDSUlJQUpMQkVBZ0FDQUhJQWdnQkNBR0VRQUFJZ1kyQWpBZ0JrRi9SZ1JBREFZTElBSWdCazBOQWlBQklBQW9BaVFnQmhBTEdpQUFJQUFvQWlBaUJ6WUNKQ0FBS0FJd0lRUU1BUXNnQUNBQklBSWdCQ0FHRVFBQUlnUTJBakFnQkVGL1JnUkFEQVVMSUFJZ0JFME5BeUFBSUFBb0FpQWlCellDSkNBRUlRWUxJQUJCQURZQ01DQUFJQUFwQXpnZ0JLMThOd000SUFFZ0JHb2hBU0FDSUFScklRSWdCU0FHYWlFRkRBRUxDeUFCSUFBb0FpUWdBaEFMR2lBQUlBQW9BaVFnQW1vMkFpUWdBQ0FBS0FJd0lBSnJOZ0l3SUFBZ0FDa0RPQ0FDclh3M0F6Z2dBaUFGYWc4TElBQkJBRFlDTUNBQUlBQW9BaUEyQWlRZ0FDQUFLUU00SUFTdGZEY0RPQ0FFSUFWcUR3c2dBMEVFUWF2MUFFRUFFQWdnQUVFQU5nSXdJQUFnQUNnQ1JFRUVjallDUkNBRlFYOGdCUnNMaXdjQ0RYOEJmaUFBS0FJUUlnZEJJRThFUUNBQUtRTUlwdzhMQWtBZ0FDZ0NHQ0lDUVFST0JFQWdBQ2dDQUNJQktBSUFJUVFnQUNBQ1FRUnJJZ1UyQWhnZ0FDQUJRUVJxTmdJQURBRUxRWDlCQUNBQUtBSWNHeUVFSUFKQkFFd0VRQ0FDSVFVTUFRc2dBa0VCY1NFTUlBQW9BZ0FoQVFKQUlBSkJBVVlFUUNBQklRWU1BUXNnQWtIKy8vLy9CM0VoQ2dOQUlBQWdBVUVCYWpZQ0FDQUJMUUFBSVFrZ0FDQUJRUUpxSWdZMkFnQWdBQ0FDUVFGck5nSVlJQUV0QUFFaEFTQUFJQUpCQW1zaUFqWUNHQ0FFUWY4QklBTjBRWDl6Y1NBSklBTjBja0dBL2dNZ0EzUkJmM054SUFFZ0EwRUljblJ5SVFRZ0EwRVFhaUVESUFZaEFTQUZRUUpxSWdVZ0NrY05BQXNMUVFBaEJTQU1SUTBBSUFBZ0JrRUJhallDQUNBR0xRQUFJUUVnQUNBQ1FRRnJOZ0lZSUFSQi93RWdBM1JCZjNOeElBRWdBM1J5SVFRTElBQW9BaFFoQVNBQUlBUkJHSFlpQ2tIL0FVWTJBaFFnQUVFSFFRZ2dBUnNpQVVFSFFRZ2dCRUgvQVhFaUJrSC9BVVliYWlJQ1FRZEJDQ0FFUVFoMlFmOEJjU0lEUWY4QlJodHFJZ2xCQjBFSUlBUkJFSFpCL3dGeElnUkIvd0ZHR3lBSGFtb2lDRFlDRUNBQUlBQXBBd2dnQXlBQmRDQUVJQUowY2lBS0lBbDBjaUFHY3EwZ0I2MkdoQ0lPTndNSUlBaEJIMDBFUUFKQUlBVkJCRTRFUUNBQUtBSUFJZ0VvQWdBaEFpQUFJQVZCQkdzMkFoZ2dBQ0FCUVFScU5nSUFEQUVMUVFBaEEwRi9RUUFnQUNnQ0hCc2hBaUFGUVFCTURRQWdCVUVCY1NFTklBQW9BZ0FoQVFKQUlBVkJBVVlFUUNBQklRUU1BUXNnQlVIKy8vLy9CM0VoQ1VFQUlRWURRQ0FBSUFGQkFXbzJBZ0FnQVMwQUFDRUxJQUFnQVVFQ2FpSUVOZ0lBSUFBZ0JVRUJhellDR0NBQkxRQUJJUUVnQUNBRlFRSnJJZ1UyQWhnZ0FrSC9BU0FEZEVGL2MzRWdDeUFEZEhKQmdQNERJQU4wUVg5emNTQUJJQU5CQ0hKMGNpRUNJQU5CRUdvaEF5QUVJUUVnQmtFQ2FpSUdJQWxIRFFBTEN5QU5SUTBBSUFBZ0JFRUJhallDQUNBRUxRQUFJUUVnQUNBRlFRRnJOZ0lZSUFKQi93RWdBM1JCZjNOeElBRWdBM1J5SVFJTElBQWdBa0VZZGlJQlFmOEJSallDRkNBQVFRZEJDQ0FLUWY4QlJoc2lCRUVIUVFnZ0FrSC9BWEVpQmtIL0FVWWJhaUlGUVFkQkNDQUNRUWgyUWY4QmNTSURRZjhCUmh0cUlnZEJCMEVJSUFKQkVIWkIvd0Z4SWdKQi93RkdHeUFJYW1vMkFoQWdBQ0FESUFSMElBSWdCWFJ5SUFFZ0IzUnlJQVp5clNBSXJZWWdEb1FpRGpjRENBc2dEcWNMYXdFQmZ5TUFRWUFDYXlJRkpBQUNRQ0FDSUFOTURRQWdCRUdBd0FSeERRQWdCU0FCSUFJZ0Eyc2lBMEdBQWlBRFFZQUNTU0lCR3hBT0dpQUJSUVJBQTBBZ0FDQUZRWUFDRUJFZ0EwR0FBbXNpQTBIL0FVc05BQXNMSUFBZ0JTQURFQkVMSUFWQmdBSnFKQUFMTVFBZ0FRSi9JQUlvQWt4QkFFZ0VRQ0FBSUFFZ0FoQTJEQUVMSUFBZ0FTQUNFRFlMSWdCR0JFQVBDeUFBSUFGdUdnczNBUUovSXdCQkVHc2lBU1FBSUFBRWZ5QUJRUXhxUVJBZ0FCQmxJUUJCQUNBQktBSU1JQUFiQlVFQUN5RUNJQUZCRUdva0FDQUNDeGNBSUFBZ0FTQUNJQU1nQkNBRklBWWdCMEVCRUI4YUMyb0JBMzhnQUFSQUlBQW9BaGdpQVFSQUlBQW9BaEFpQWdSL1FRQWhBUU5BSUFBb0FoZ2dBVUUwYkdvb0Fpd2lBd1JBSUFNUUNTQUFLQUlRSVFJTElBRkJBV29pQVNBQ1NRMEFDeUFBS0FJWUJTQUJDeEFKQ3lBQUtBSWNJZ0VFUUNBQkVBa0xJQUFRQ1FzTG9RRUJCSDhnQVVFQVRBUkFRUUFQQ3lBQUtBSU1JUUlnQUNnQ0VDRURBMEFnQVNFRkFrQWdBdzBBSUFBZ0FrRUlkRUdBL2dOeElnSTJBZ3dnQUVFSFFRZ2dBa0dBL2dOR0d5SUROZ0lRSUFBb0FnZ2lBU0FBS0FJRVR3MEFJQUFnQVVFQmFqWUNDQ0FBSUFJZ0FTMEFBSElpQWpZQ0RBc2dBQ0FEUVFGcklnTTJBaEFnQWlBRGRrRUJjU0FGUVFGcklnRjBJQVJ5SVFRZ0JVRUJTdzBBQ3lBRUN4NEFJQUFvQWd3RVFDQUFRUUEyQWlnRFFDQUFLQUlZUVFCS0RRQUxDd3VYQkFJR2Z3SitBa0FDUUFOQUlBQWdBRUVCYTNFTkFTQUJRVWRMRFFFZ0FFRUlJQUJCQ0VzaUJ4c2hBRUdvemdFcEF3QWlDQUovUVFnZ0FVRURha0Y4Y1NBQlFRaE5HeUlCUWY4QVRRUkFJQUZCQTNaQkFXc01BUXNnQVdjaEFpQUJRUjBnQW10MlFRUnpJQUpCQW5SclFlNEFhaUFCUWY4ZlRRMEFHa0UvSUFGQkhpQUNhM1pCQW5NZ0FrRUJkR3RCeHdCcUlnSWdBa0UvVHhzTElnU3RpQ0lKUWdCU0JFQURRQ0FKSUFsNklnaUlJUWtDZmlBRUlBaW5haUlFUVFSMElnTkJxTVlCYWlnQ0FDSUNJQU5Cb01ZQmFpSURSd1JBSUFJZ0FDQUJFRFVpQlEwR0lBSW9BZ1FpQlNBQ0tBSUlJZ1kyQWdnZ0JpQUZOZ0lFSUFJZ0F6WUNDQ0FDSUFNb0FnUTJBZ1FnQXlBQ05nSUVJQUlvQWdRZ0FqWUNDQ0FFUVFGcUlRUWdDVUlCaUF3QkMwR296Z0ZCcU00QktRTUFRbjRnQksySmd6Y0RBQ0FKUWdHRkN5SUpRZ0JTRFFBTFFhak9BU2tEQUNFSUMwRS9JQWg1cDJzaEJnSkFJQWhRQkVCQkFDRUNEQUVMSUFaQkJIUWlBMEdveGdGcUtBSUFJUUlnQ0VLQWdJQ0FCRlFOQUVIakFDRUVJQUlnQTBHZ3hnRnFJZ05HRFFBRFFDQUVSUTBCSUFJZ0FDQUJFRFVpQlEwRUlBUkJBV3NoQkNBQ0tBSUlJZ0lnQTBjTkFBc2dBeUVDQ3lBQklBQkJNR3BCTUNBSEcyb1FaZzBBQ3lBQ1JRMEFJQUlnQmtFRWRFR2d4Z0ZxSWdOR0RRQURRQ0FDSUFBZ0FSQTFJZ1VOQWlBQ0tBSUlJZ0lnQTBjTkFBc0xRUUFoQlFzZ0JRdVNGUUVQZndKQUFrQWdBQ2dDREVVRVFFRUJJUThnQUNnQ0JFRUFTZzBCSUFBb0FnaEJBVW9OQVF3Q0MwRUJJUTBnQUNnQ0NFRUFTZzBBSUFBb0FnUkJBa2dOQVFzZ0FDZ0NBQ0lJSUExQkJYUnFJUVFDUUNBQUtBSVFJZ2NnQUNnQ0ZDSUtUdzBBSUFRZ0IwRUdkR29oQVFKQUlBb2dCMnRCQTNFaUJrVUVRQ0FISVFJTUFRc2dCeUVDQTBBZ0FTQUIvUUFFQVAwTVdIYWRQMWgyblQ5WWRwMC9XSGFkUC8zbUFmMExCQUFnQVNBQi9RQUVFUDBNV0hhZFAxaDJuVDlZZHAwL1dIYWRQLzNtQWYwTEJCQWdBVUZBYXlFQklBSkJBV29oQWlBRFFRRnFJZ01nQmtjTkFBc0xJQWNnQ210QmZFc05BQU5BSUFFZ0FmMEFCQUQ5REZoMm5UOVlkcDAvV0hhZFAxaDJuVC85NWdIOUN3UUFJQUVnQWYwQUJCRDlERmgyblQ5WWRwMC9XSGFkUDFoMm5ULzk1Z0g5Q3dRUUlBRWdBZjBBQkVEOURGaDJuVDlZZHAwL1dIYWRQMWgyblQvOTVnSDlDd1JBSUFFZ0FmMEFCRkQ5REZoMm5UOVlkcDAvV0hhZFAxaDJuVC85NWdIOUN3UlFJQUVnQWYwQUJJQUIvUXhZZHAwL1dIYWRQMWgyblQ5WWRwMC8vZVlCL1FzRWdBRWdBU0FCL1FBRWtBSDlERmgyblQ5WWRwMC9XSGFkUDFoMm5ULzk1Z0g5Q3dTUUFTQUJJQUg5QUFUQUFmME1XSGFkUDFoMm5UOVlkcDAvV0hhZFAvM21BZjBMQk1BQklBRWdBZjBBQk5BQi9ReFlkcDAvV0hhZFAxaDJuVDlZZHAwLy9lWUIvUXNFMEFFZ0FVR0FBbW9oQVNBQ1FRUnFJZ0lnQ2tjTkFBc0xJQWdnRDBFRmRHb2hCUUpBSUFBb0FoZ2lCaUFBS0FJY0lndFBEUUFnQlNBR1FRWjBhaUVCQWtBZ0N5QUdhMEVEY1NJSVJRUkFJQVloQWd3QkMwRUFJUU1nQmlFQ0EwQWdBU0FCL1FBRUFQME1BQmpRUHdBWTBEOEFHTkEvQUJqUVAvM21BZjBMQkFBZ0FTQUIvUUFFRVAwTUFCalFQd0FZMEQ4QUdOQS9BQmpRUC8zbUFmMExCQkFnQVVGQWF5RUJJQUpCQVdvaEFpQURRUUZxSWdNZ0NFY05BQXNMSUFZZ0MydEJmRXNOQUFOQUlBRWdBZjBBQkFEOURBQVkwRDhBR05BL0FCalFQd0FZMEQvOTVnSDlDd1FBSUFFZ0FmMEFCQkQ5REFBWTBEOEFHTkEvQUJqUVB3QVkwRC85NWdIOUN3UVFJQUVnQWYwQUJFRDlEQUFZMEQ4QUdOQS9BQmpRUHdBWTBELzk1Z0g5Q3dSQUlBRWdBZjBBQkZEOURBQVkwRDhBR05BL0FCalFQd0FZMEQvOTVnSDlDd1JRSUFFZ0FmMEFCSUFCL1F3QUdOQS9BQmpRUHdBWTBEOEFHTkEvL2VZQi9Rc0VnQUVnQVNBQi9RQUVrQUg5REFBWTBEOEFHTkEvQUJqUVB3QVkwRC85NWdIOUN3U1FBU0FCSUFIOUFBVEFBZjBNQUJqUVB3QVkwRDhBR05BL0FCalFQLzNtQWYwTEJNQUJJQUVnQWYwQUJOQUIvUXdBR05BL0FCalFQd0FZMEQ4QUdOQS8vZVlCL1FzRTBBRWdBVUdBQW1vaEFTQUNRUVJxSWdJZ0MwY05BQXNMSUFvZ0FDZ0NDQ0lKSUFBb0FnUWlEaUFOYXlJQUlBQWdDVW9iSWdnZ0NDQUtTeHNoRENBRVFTQnFJUUVDZnlBSFJRUkFJQXhGQkVCQkFDRURJQUVNQWdzZ0JDQUUvUUFFQUNBRi9RQUVBQ0FFL1FBRUlQM2tBZjBNVlJQalBsVVQ0ejVWRStNK1ZSUGpQdjNtQWYzbEFmMExCQUFnQkNBRS9RQUVFQ0FGL1FBRUVDQUUvUUFFTVAza0FmME1WUlBqUGxVVDR6NVZFK00rVlJQalB2M21BZjNsQWYwTEJCQkJBU0VESUFSQjRBQnFEQUVMSUFFZ0J5SURRUVowYWdzaEFpQURJQXhKQkVBRFFDQUNRU0JySWdBZ0FQMEFCQUFnQWtGQWF2MEFCQUFnQXYwQUJBRDk1QUg5REZVVDR6NVZFK00rVlJQalBsVVQ0ejc5NWdIOTVRSDlDd1FBSUFKQkVHc2lBQ0FBL1FBRUFDQUNRVEJyL1FBRUFDQUMvUUFFRVAza0FmME1WUlBqUGxVVDR6NVZFK00rVlJQalB2M21BZjNsQWYwTEJBQWdBa0ZBYXlFQ0lBTkJBV29pQXlBTVJ3MEFDd3NnQ0NBS1R5SU5SUVJBSUFKQklHc2lBQ0FBL1FBRUFDQUNRVUJxL1FBRUFQME1WUk5qUDFVVFl6OVZFMk0vVlJOalAvM21BZjNsQWYwTEJBQWdBa0VRYXlJQUlBRDlBQVFBSUFKQk1HdjlBQVFBL1F4VkUyTS9WUk5qUDFVVFl6OVZFMk0vL2VZQi9lVUIvUXNFQUFzZ0N5QU9JQWtnRDJzaUFDQUFJQTVLR3lJT0lBc2dEa2tiSVFrZ0JVRWdhaUVDSUFrQ2Z5QUdSUVJBSUFsRkJFQWdBaUVEUVFBTUFnc2dCU0FGL1FBRUFDQUUvUUFFQUNBRi9RQUVJUDNrQWYwTWRnWmlQM1lHWWo5MkJtSS9kZ1ppUC8zbUFmM2xBZjBMQkFBZ0JTQUYvUUFFRUNBRS9RQUVFQ0FGL1FBRU1QM2tBZjBNZGdaaVAzWUdZajkyQm1JL2RnWmlQLzNtQWYzbEFmMExCQkFnQlVIZ0FHb2hBMEVCREFFTElBSWdCa0VHZEdvaEF5QUdDeUlBU3dSQUEwQWdBMEVnYXlJSUlBajlBQVFBSUFOQlFHcjlBQVFBSUFQOUFBUUEvZVFCL1F4MkJtSS9kZ1ppUDNZR1lqOTJCbUkvL2VZQi9lVUIvUXNFQUNBRFFSQnJJZ2dnQ1AwQUJBQWdBMEV3YS8wQUJBQWdBLzBBQkJEOTVBSDlESFlHWWo5MkJtSS9kZ1ppUDNZR1lqLzk1Z0g5NVFIOUN3UUFJQU5CUUdzaEF5QUFRUUZxSWdBZ0NVY05BQXNMSUFzZ0RrMGlDRVVFUUNBRFFTQnJJZ0FnQVAwQUJBQWdBMEZBYXYwQUJBRDlESFlHNGo5MkJ1SS9kZ2JpUDNZRzRqLzk1Z0g5NVFIOUN3UUFJQU5CRUdzaUFDQUEvUUFFQUNBRFFUQnIvUUFFQVAwTWRnYmlQM1lHNGo5MkJ1SS9kZ2JpUC8zbUFmM2xBZjBMQkFBTEFrQWdCMFVFUUNBTVJRUkFRUUFoQnd3Q0N5QUVJQVQ5QUFRQUlBWDlBQVFBSUFUOUFBUWcvZVFCL1F5dUFWazlyZ0ZaUGE0QldUMnVBVms5L2VZQi9lUUIvUXNFQUNBRUlBVDlBQVFRSUFYOUFBUVFJQVQ5QUFRdy9lUUIvUXl1QVZrOXJnRlpQYTRCV1QydUFWazkvZVlCL2VRQi9Rc0VFQ0FFUWVBQWFpRUJRUUVoQnd3QkN5QUJJQWRCQm5ScUlRRUxJQWNnREVrRVFBTkFJQUZCSUdzaUFDQUEvUUFFQUNBQlFVQnEvUUFFQUNBQi9RQUVBUDNrQWYwTXJnRlpQYTRCV1QydUFWazlyZ0ZaUGYzbUFmM2tBZjBMQkFBZ0FVRVFheUlBSUFEOUFBUUFJQUZCTUd2OUFBUUFJQUg5QUFRUS9lUUIvUXl1QVZrOXJnRlpQYTRCV1QydUFWazkvZVlCL2VRQi9Rc0VBQ0FCUVVCcklRRWdCMEVCYWlJSElBeEhEUUFMQ3lBTlJRUkFJQUZCSUdzaUFDQUEvUUFFQUNBQlFVQnEvUUFFQVAwTXJnSFpQYTRCMlQydUFkazlyZ0haUGYzbUFmM2tBZjBMQkFBZ0FVRVFheUlBSUFEOUFBUUFJQUZCTUd2OUFBUUEvUXl1QWRrOXJnSFpQYTRCMlQydUFkazkvZVlCL2VRQi9Rc0VBQXNDUUNBR1JRUkFJQWxGQkVCQkFDRUdEQUlMSUFVZ0JmMEFCQUFnQlAwQUJBQWdCZjBBQkNEOTVBSDlESE1HeXo5ekJzcy9jd2JMUDNNR3l6Lzk1Z0g5NUFIOUN3UUFJQVVnQmYwQUJCQWdCUDBBQkJBZ0JmMEFCREQ5NUFIOURITUd5ejl6QnNzL2N3YkxQM01HeXovOTVnSDk1QUg5Q3dRUUlBVkI0QUJxSVFKQkFTRUdEQUVMSUFJZ0JrRUdkR29oQWdzZ0JpQUpTUVJBQTBBZ0FrRWdheUlBSUFEOUFBUUFJQUpCUUdyOUFBUUFJQUw5QUFRQS9lUUIvUXh6QnNzL2N3YkxQM01HeXo5ekJzcy8vZVlCL2VRQi9Rc0VBQ0FDUVJCcklnQWdBUDBBQkFBZ0FrRXdhLzBBQkFBZ0F2MEFCQkQ5NUFIOURITUd5ejl6QnNzL2N3YkxQM01HeXovOTVnSDk1QUg5Q3dRQUlBSkJRR3NoQWlBR1FRRnFJZ1lnQ1VjTkFBc0xJQWdOQUNBQ1FTQnJJZ0FnQVAwQUJBQWdBa0ZBYXYwQUJBRDlESE1HUzBCekJrdEFjd1pMUUhNR1MwRDk1Z0g5NUFIOUN3UUFJQUpCRUdzaUFDQUEvUUFFQUNBQ1FUQnIvUUFFQVAwTWN3WkxRSE1HUzBCekJrdEFjd1pMUVAzbUFmM2tBZjBMQkFBTEMxMEJCSDhnQUFSQUlBQW9BaFFpQVNBQUtBSVFJZ0pzQkVBRFFDQUFLQUlZSUFOQkFuUnFLQUlBSWdRRVFDQUVFQWtnQUNnQ0VDRUNJQUFvQWhRaEFRc2dBMEVCYWlJRElBRWdBbXhKRFFBTEN5QUFLQUlZRUFrZ0FCQUpDd3VGQVFFQ2Z3SkFBa0FnQUNnQ0JDSURJQUFvQWdBaUJFY0VRQ0FBS0FJSUlRTU1BUXNnQUNBRFFRcHFJZ1EyQWdRZ0FDZ0NDQ0FFUVFKMEVCQWlBMFVOQVNBQUlBTTJBZ2dnQUNnQ0FDRUVDeUFESUFSQkFuUnFJQUUyQWdBZ0FDQUVRUUZxTmdJQVFRRVBDeUFBS0FJSUVBa2dBRUlBTndJQUlBSkJBVUhTTGtFQUVBaEJBQXZZSXdJcWZ3TjdBa0FnQUNnQ0FDSUpJQU5KRFFBZ0FTQURUdzBBSUFFZ0NVOE5BQ0FBS0FJRUlna2dCRWtOQUNBQ0lBUlBEUUFnQWlBSlR3MEFJQVZCSEdzaEtDQUFLQUlJSWhsQkFuUWhFU0FIUVFKMElROGdCa0VDZENFZklBVkJCR3NoS1NBQ0lBQW9BZ3h1SVI0Z0FTQVpiaUVqSUFaQkNFY2hKQ0FDSVIwRFFDQUFLQUlNSWdraENpQUNJQjFHQkVBZ0NTQUNJQWx3YXlFS0N5QUtJQVFnSFdzaURDQUtJQXhKR3lJVFFYeHhJUnNnRTBFRGNTRVdJQk5CZUhFaEtpQVRRUWR4SVNVZ0UwRUJheUVhSUJrZ0NVRUNkQ0FLUVFKMGEwRUVhbXdoSUNBR1FRSkdJQk5CQVVaeElTc2dDU0FLYXlBWmJDRW1JQ2dnRHlBZElBSnJJZ3hzSWdscUlTY2dDU0FwYWlFc0lBVWdDV29oTFNBRklBY2dER3hCQW5ScUlSd2dJeUVoSUFFaEdBTkFJQmtnR1NBamJDQUJhMm9nR1NBQklCaEdHeUlNSUFNZ0dHc2lDU0FKSUF4TEd5RVFJQmtnREdzaENTQWhRUUowSWcwZ0FDZ0NHQ0FBS0FJUUlCNXNRUUowYW1vb0FnQWhFZ0pBQWtBZ0NBUkFBa0FDUUFKQUFrQUNRQ0FTQkVBZ0VpQW1RUUowYWlBSlFRSjBhaUVLSUJnZ0FXc2hEU0FHUVFGR0RRUWdIQ0FHSUExc1FRSjBhaUVMSUJCQkFVWU5BeUFyRFFJZ0pBMEJJQkJCQjAwTkFTQVRSUTBJSUNjZ0RTQWZiR29nRUVFRmRHb2hGU0FTSUNBZ0VFRUNkR29nREVFQ2RHdHFJU0lnRUVGOGNTRU5RUUFoRWd3RkN5QUdRUUZIQkVBZ0UwVU5DQ0FRUVh4eElRMGdFRUVEY1NFTUlCd2dHQ0FCYXlBR2JFRUNkR29oQzBFQUlSSWdFRUVCYTBFRFNTRVVBMEFDUUNBUVJRMEFRUUFoQ1VFQUlRcEJBQ0VPSUJSRkJFQURRQ0FMSUFZZ0NteEJBblJxUVFBMkFnQWdDeUFLUVFGeUlBWnNRUUowYWtFQU5nSUFJQXNnQ2tFQ2NpQUdiRUVDZEdwQkFEWUNBQ0FMSUFwQkEzSWdCbXhCQW5ScVFRQTJBZ0FnQ2tFRWFpRUtJQTVCQkdvaURpQU5SdzBBQ3dzZ0RFVU5BQU5BSUFzZ0JpQUtiRUVDZEdwQkFEWUNBQ0FLUVFGcUlRb2dDVUVCYWlJSklBeEhEUUFMQ3lBTElBOXFJUXNnRXlBU1FRRnFJaEpIRFFBTERBZ0xJQk5GRFFjZ0VFRUNkQ0VNSUJ3Z0dDQUJhMEVDZEdvaEMwRUFJUWtnR2tFSFR3UkFBMEFnQzBFQUlBd1FEaUFQYWtFQUlBd1FEaUFQYWtFQUlBd1FEaUFQYWtFQUlBd1FEaUFQYWtFQUlBd1FEaUFQYWtFQUlBd1FEaUFQYWtFQUlBd1FEaUFQYWtFQUlBd1FEaUFQYWlFTElBbEJDR29pQ1NBcVJ3MEFDd3RCQUNFSklDVkZEUWNEUUNBTFFRQWdEQkFPSUE5cUlRc2dDVUVCYWlJSklDVkhEUUFMREFjTElCTkZEUVlnRUVGOGNTRVVJQkJCQTNFaEVrRUFJUTBnRUVFQmEwRURTU0VYREFVTFFRQWhDU0FRUVh4eElnNEVRQU5BSUFzZ0NVRURkR29nQ2lBSlFRSjBhaWdDQURZQ0FDQUxJQWxCQVhJaUZFRURkR29nQ2lBVVFRSjBhaWdDQURZQ0FDQUxJQWxCQW5JaUZFRURkR29nQ2lBVVFRSjBhaWdDQURZQ0FDQUxJQWxCQTNJaUZFRURkR29nQ2lBVVFRSjBhaWdDQURZQ0FDQUpRUVJxSWdrZ0Rra05BQXNMSUFrZ0VFOE5CUUpBSUJBZ0NXc2lGRUVRU1EwQUlDMGdEU0FmYkNJTmFpQUpRUU4wYWlBU0lDQnFJZzRnRUNBTWEwRUNkR3BKQkVBZ0RpQUpJQXhyUVFKMGFpQU5JQ3hxSUJCQkEzUnFTUTBCQ3lBS0lBbEJBblJxSVEwZ0NmMFIvUXdBQUFBQUFRQUFBQUlBQUFBREFBQUEvYTRCSVRNZ0NTQVVRWHh4SWd4cUlRbEJBQ0VPQTBBZ0N5QXpRUUg5cXdFaU5QMGJBRUVDZEdvZ0RTQU9RUUowYXYwQUFnQWlOZjFhQWdBQUlBc2dOUDBiQVVFQ2RHb2dOZjFhQWdBQklBc2dOUDBiQWtFQ2RHb2dOZjFhQWdBQ0lBc2dOUDBiQTBFQ2RHb2dOZjFhQWdBRElEUDlEQVFBQUFBRUFBQUFCQUFBQUFRQUFBRDlyZ0VoTXlBT1FRUnFJZzRnREVjTkFBc2dEQ0FVUmcwR0MwRUFJUXdnQ1NFT0lCQWdDV3RCQTNFaURRUkFBMEFnQ3lBT1FRTjBhaUFLSUE1QkFuUnFLQUlBTmdJQUlBNUJBV29oRGlBTVFRRnFJZ3dnRFVjTkFBc0xJQWtnRUd0QmZFc05CUU5BSUFzZ0RrRURkR29nQ2lBT1FRSjBhaWdDQURZQ0FDQUxJQTVCQVdvaUNVRURkR29nQ2lBSlFRSjBhaWdDQURZQ0FDQUxJQTVCQW1vaUNVRURkR29nQ2lBSlFRSjBhaWdDQURZQ0FDQUxJQTVCQTJvaUNVRURkR29nQ2lBSlFRSjBhaWdDQURZQ0FDQU9RUVJxSWc0Z0VFY05BQXNNQlFzZ0UwVU5CRUVBSVFrZ0drRURUd1JBQTBBZ0N5QUtLQUlBTmdJQUlBc2dEMm9pRENBS0lCRnFJZzBvQWdBMkFnQWdEQ0FQYWlJTUlBMGdFV29pRFNnQ0FEWUNBQ0FNSUE5cUlnd2dEU0FSYWlJTktBSUFOZ0lBSUEwZ0VXb2hDaUFNSUE5cUlRc2dDVUVFYWlJSklCdEhEUUFMQzBFQUlRa2dGa1VOQkFOQUlBc2dDaWdDQURZQ0FDQUtJQkZxSVFvZ0N5QVBhaUVMSUFsQkFXb2lDU0FXUncwQUN3d0VDeUFjSUExQkFuUnFJUXNnRUVFRVJ3UkFJQk5GRFFRZ0VFRUNkQ0VKUVFBaERpQWFRUU5QQkVBRFFDQUxJQW9nQ1JBTElTOGdDaUFSYWlJTklCRnFJZ3NnRVdvaUVpQVJhaUVLSUM4Z0Qyb2dEU0FKRUFzZ0Qyb2dDeUFKRUFzZ0Qyb2dFaUFKRUFzZ0Qyb2hDeUFPUVFScUlnNGdHMGNOQUFzTFFRQWhEaUFXUlEwRUEwQWdDeUFLSUFrUUN5RXdJQW9nRVdvaENpQXdJQTlxSVFzZ0RrRUJhaUlPSUJaSERRQUxEQVFMSUJORkRRTkJBQ0VKSUJwQkEwOEVRQU5BSUFzZ0N2MEFBZ0Q5Q3dJQUlBc2dEMm9pRENBS0lCRnFJZzM5QUFJQS9Rc0NBQ0FNSUE5cUlnd2dEU0FSYWlJTi9RQUNBUDBMQWdBZ0RDQVBhaUlNSUEwZ0VXb2lEZjBBQWdEOUN3SUFJQTBnRVdvaENpQU1JQTlxSVFzZ0NVRUVhaUlKSUJ0SERRQUxDMEVBSVFrZ0ZrVU5Bd05BSUFzZ0N2MEFBZ0Q5Q3dJQUlBb2dFV29oQ2lBTElBOXFJUXNnQ1VFQmFpSUpJQlpIRFFBTERBTUxBMEJCQUNFSklBMEVRQU5BSUFzZ0NVRUZkR29nQ2lBSlFRSjBhaWdDQURZQ0FDQUxJQWxCQVhJaURFRUZkR29nQ2lBTVFRSjBhaWdDQURZQ0FDQUxJQWxCQW5JaURFRUZkR29nQ2lBTVFRSjBhaWdDQURZQ0FDQUxJQWxCQTNJaURFRUZkR29nQ2lBTVFRSjBhaWdDQURZQ0FDQUpRUVJxSWdrZ0RVa05BQXNMQWtBZ0NTQVFUdzBBQWtBZ0VDQUpheUlVUVFoUEJFQUNRQ0FMSUFsQkJYUnFJQ0lnRVNBU2JHcFBEUUFnQ2lBSlFRSjBhaUFWSUE4Z0VteHFUdzBBSUFraERBd0NDeUFKL1JIOURBQUFBQUFCQUFBQUFnQUFBQU1BQUFEOXJnRWhNeUFKSUJSQmZIRWlGMm9oREVFQUlRNERRQ0FMSUROQkEvMnJBU0kwL1JzQVFRSjBhaUFLSUFrZ0RtcEJBblJxL1FBQ0FDSTEvVm9DQUFBZ0N5QTAvUnNCUVFKMGFpQTEvVm9DQUFFZ0N5QTAvUnNDUVFKMGFpQTEvVm9DQUFJZ0N5QTAvUnNEUVFKMGFpQTEvVm9DQUFNZ00vME1CQUFBQUFRQUFBQUVBQUFBQkFBQUFQMnVBU0V6SUE1QkJHb2lEaUFYUncwQUN5QVVJQmRHRFFJTUFRc2dDU0VNQzBFQUlRNGdFQ0FNSWdsclFRTnhJaFFFUUFOQUlBc2dDVUVGZEdvZ0NpQUpRUUowYWlnQ0FEWUNBQ0FKUVFGcUlRa2dEa0VCYWlJT0lCUkhEUUFMQ3lBTUlCQnJRWHhMRFFBRFFDQUxJQWxCQlhScUlBb2dDVUVDZEdvb0FnQTJBZ0FnQ3lBSlFRRnFJZ3hCQlhScUlBb2dERUVDZEdvb0FnQTJBZ0FnQ3lBSlFRSnFJZ3hCQlhScUlBb2dERUVDZEdvb0FnQTJBZ0FnQ3lBSlFRTnFJZ3hCQlhScUlBb2dERUVDZEdvb0FnQTJBZ0FnQ1VFRWFpSUpJQkJIRFFBTEN5QUtJQkZxSVFvZ0N5QVBhaUVMSUJNZ0VrRUJhaUlTUncwQUN3d0NDeUFTUlFSQVFRRWdBQ2dDQ0NBQUtBSU1iRUVDZEJBTUloSkZCRUJCQUE4TElBQW9BaGdnQUNnQ0VDQWViRUVDZEdvZ0RXb2dFallDQUFzZ0VpQW1RUUowYWlBSlFRSjBhaUVMSUJnZ0FXc2hDUUpBQWtBQ1FBSkFJQVpCQVVjRVFDQWNJQVlnQ1d4QkFuUnFJUW9nRUVFQlJnMEJJQ1FOQWlBUVFRZE5EUUlnRTBVTkJpQW5JQWtnSDJ4cUlCQkJCWFJxSVNJZ0lDQVFRUUowYWlBTVFRSjBheUV1SUJCQmZIRWhGRUVBSVF3RFFFRUFJUWtnRkFSQUEwQWdDeUFKUVFKMGFpQUtJQWxCQlhScUtBSUFOZ0lBSUFzZ0NVRUJjaUlOUVFKMGFpQUtJQTFCQlhScUtBSUFOZ0lBSUFzZ0NVRUNjaUlOUVFKMGFpQUtJQTFCQlhScUtBSUFOZ0lBSUFzZ0NVRURjaUlOUVFKMGFpQUtJQTFCQlhScUtBSUFOZ0lBSUFsQkJHb2lDU0FVU1EwQUN3c0NRQ0FKSUJCUERRQUNRQ0FRSUFsckloZEJDRThFUUFKQUlBc2dDVUVDZEdvZ0lpQU1JQTlzYWs4TkFDQUtJQWxCQlhScUlCSWdMaUFNSUJGc2FtcFBEUUFnQ1NFTkRBSUxJQW45RWYwTUFBQUFBQUVBQUFBQ0FBQUFBd0FBQVAydUFTRXpJQWtnRjBGOGNTSVZhaUVOUVFBaERnTkFJQXNnQ1NBT2FrRUNkR29nQ2lBelFRUDlxd0VpTlAwYkEwRUNkR29nQ2lBMC9Sc0NRUUowYWlBS0lEVDlHd0ZCQW5ScUlBb2dOUDBiQUVFQ2RHcjlDUUlBL1ZZQ0FBSDlWZ0lBQXYxV0FnQUQvUXNDQUNBei9Rd0VBQUFBQkFBQUFBUUFBQUFFQUFBQS9hNEJJVE1nRGtFRWFpSU9JQlZIRFFBTElCVWdGMFlOQWd3QkN5QUpJUTBMUVFBaERpQVFJQTBpQ1d0QkEzRWlGd1JBQTBBZ0N5QUpRUUowYWlBS0lBbEJCWFJxS0FJQU5nSUFJQWxCQVdvaENTQU9RUUZxSWc0Z0YwY05BQXNMSUEwZ0VHdEJmRXNOQUFOQUlBc2dDVUVDZEdvZ0NpQUpRUVYwYWlnQ0FEWUNBQ0FMSUFsQkFXb2lEVUVDZEdvZ0NpQU5RUVYwYWlnQ0FEWUNBQ0FMSUFsQkFtb2lEVUVDZEdvZ0NpQU5RUVYwYWlnQ0FEWUNBQ0FMSUFsQkEyb2lEVUVDZEdvZ0NpQU5RUVYwYWlnQ0FEWUNBQ0FKUVFScUlna2dFRWNOQUFzTElBc2dFV29oQ3lBS0lBOXFJUW9nRXlBTVFRRnFJZ3hIRFFBTERBWUxJQndnQ1VFQ2RHb2hDaUFRUVFSR0RRSWdFMFVOQlNBUVFRSjBJUWxCQUNFT0lCcEJBMDhFUUFOQUlBc2dDaUFKRUFzaE1TQUtJQTlxSWcwZ0Qyb2lDeUFQYWlJU0lBOXFJUW9nTVNBUmFpQU5JQWtRQ3lBUmFpQUxJQWtRQ3lBUmFpQVNJQWtRQ3lBUmFpRUxJQTVCQkdvaURpQWJSdzBBQ3d0QkFDRU9JQlpGRFFVRFFDQUxJQW9nQ1JBTElUSWdDaUFQYWlFS0lESWdFV29oQ3lBT1FRRnFJZzRnRmtjTkFBc01CUXNnRTBVTkJFRUFJUWtnR2tFRFR3UkFBMEFnQ3lBS0tBSUFOZ0lBSUFzZ0VXb2lEQ0FLSUE5cUlnMG9BZ0EyQWdBZ0RDQVJhaUlNSUEwZ0Qyb2lEU2dDQURZQ0FDQU1JQkZxSWd3Z0RTQVBhaUlOS0FJQU5nSUFJQXdnRVdvaEN5QU5JQTlxSVFvZ0NVRUVhaUlKSUJ0SERRQUxDMEVBSVFrZ0ZrVU5CQU5BSUFzZ0NpZ0NBRFlDQUNBTElCRnFJUXNnQ2lBUGFpRUtJQWxCQVdvaUNTQVdSdzBBQ3d3RUN5QVRSUTBESUJCQmZIRWhGQ0FRUVFOeElSSkJBQ0VOSUJCQkFXdEJBMGtoRnd3QkN5QVRSUTBDUVFBaENTQWFRUU5QQkVBRFFDQUxJQXI5QUFJQS9Rc0NBQ0FMSUJGcUlnd2dDaUFQYWlJTi9RQUNBUDBMQWdBZ0RDQVJhaUlNSUEwZ0Qyb2lEZjBBQWdEOUN3SUFJQXdnRVdvaURDQU5JQTlxSWczOUFBSUEvUXNDQUNBTklBOXFJUW9nRENBUmFpRUxJQWxCQkdvaUNTQWJSdzBBQ3d0QkFDRUpJQlpGRFFJRFFDQUxJQXI5QUFJQS9Rc0NBQ0FLSUE5cUlRb2dDeUFSYWlFTElBbEJBV29pQ1NBV1J3MEFDd3dDQ3dOQUFrQWdFRVVOQUVFQUlRNUJBQ0VKUVFBaERDQVhSUVJBQTBBZ0N5QUpRUUowYWlBS0lBWWdDV3hCQW5ScUtBSUFOZ0lBSUFzZ0NVRUJjaUlWUVFKMGFpQUtJQVlnRld4QkFuUnFLQUlBTmdJQUlBc2dDVUVDY2lJVlFRSjBhaUFLSUFZZ0ZXeEJBblJxS0FJQU5nSUFJQXNnQ1VFRGNpSVZRUUowYWlBS0lBWWdGV3hCQW5ScUtBSUFOZ0lBSUFsQkJHb2hDU0FNUVFScUlnd2dGRWNOQUFzTElCSkZEUUFEUUNBTElBbEJBblJxSUFvZ0JpQUpiRUVDZEdvb0FnQTJBZ0FnQ1VFQmFpRUpJQTVCQVdvaURpQVNSdzBBQ3dzZ0N5QVJhaUVMSUFvZ0Qyb2hDaUFUSUExQkFXb2lEVWNOQUFzTUFRc0RRQUpBSUJCRkRRQkJBQ0VPUVFBaENVRUFJUXdnRjBVRVFBTkFJQXNnQmlBSmJFRUNkR29nQ2lBSlFRSjBhaWdDQURZQ0FDQUxJQWxCQVhJaUZTQUdiRUVDZEdvZ0NpQVZRUUowYWlnQ0FEWUNBQ0FMSUFsQkFuSWlGU0FHYkVFQ2RHb2dDaUFWUVFKMGFpZ0NBRFlDQUNBTElBbEJBM0lpRlNBR2JFRUNkR29nQ2lBVlFRSjBhaWdDQURZQ0FDQUpRUVJxSVFrZ0RFRUVhaUlNSUJSSERRQUxDeUFTUlEwQUEwQWdDeUFHSUFsc1FRSjBhaUFLSUFsQkFuUnFLQUlBTmdJQUlBbEJBV29oQ1NBT1FRRnFJZzRnRWtjTkFBc0xJQW9nRVdvaENpQUxJQTlxSVFzZ0RVRUJhaUlOSUJOSERRQUxDeUFoUVFGcUlTRWdFQ0FZYWlJWUlBTkpEUUFMSUI1QkFXb2hIaUFUSUIxcUloMGdCRWtOQUFzTFFRRUx5RE1GSm44UGZnRjdBWDBCZkNNQVFkQUFheUlQSkFBZ0QwR1Evd00yQWlnZ0FDZ0NiQ0FBS0FKb2JDRVhBbjhDUUFKQUFrQWdBQ2dDQ0NJTFFRaEhCRUJCQUNBTFFZQUNSdzBFR2lBUFFkbi9BellDS0F3QkN5QUFMUUJFUVFGeERRQWdGMEVCY1NFaUlCZEJmSEVoRFNBWFFRRnJyVUtNTEg0aU1VSWdpS2RCQUVjaEl5QXhweUVrSUE5QnpRQnFJU1VnRDBITUFHb2hLQ0FQUWNnQWFpRXBJQmRCSkVraEtrR1Evd01oQ3dKQUFrQUNRQU5BQWtBZ0MwR1Qvd05HRFFBQ1FBTkFJQWtwQXdnaU1WQUVma0lBQlNBeElBa3BBemg5QzFBRVFDQUFRY0FBTmdJSURBTUxJQWtnQUNnQ0VFRUNJQW9RRWtFQ1J3UkFJQXBCQVVHV0VrRUFFQWhCQUF3TEN5QUFLQUlRSUE5QkpHcEJBaEFLSUE4b0FpUWlDMEVCVFFSQUlBcEJBVUdITGtFQUVBaEJBQXdMQ3dKQUlBOG9BaWhCZ0lFQ1JnUkFJQWtwQXdnaU1WQUVma0lBQlNBeElBa3BBemg5QzFBTkFTQVBLQUlrSVFzTElBQW9BZ2dpRkVFUWNRUkFJQUFnQUNnQ0dDQUxhMEVDYXpZQ0dBc2dEeUFMUVFKckloSTJBaVJCOEwwQklRd2dEeWdDS0NFT0EwQWdEQ0lMS0FJQUloZ0VRQ0FMUVF4cUlRd2dEaUFZUncwQkN3c2dDeWdDQkNBVWNVVUVRQ0FLUVFGQi9DaEJBQkFJUVFBTURBc0NRQ0FBS0FJVUlCSlBCRUFnQUNnQ0VDRU1EQUVMSUFrcEF3Z2lNVkFFZmtJQUJTQXhJQWtwQXpoOUN5QVNyVk1FUUNBS1FRRkJqQ3hCQUJBSVFRQU1EUXNnQUNnQ0VDQVBLQUlrRUJBaURFVUVRQ0FBS0FJUUVBa2dBRUlBTndNUUlBcEJBVUhVSlVFQUVBaEJBQXdOQ3lBQUlBdzJBaEFnQUNBUEtBSWtJaEkyQWhRTElBa2dEQ0FTSUFvUUVpSU1JQThvQWlSSEJFQWdDa0VCUVpZU1FRQVFDRUVBREF3TElBc29BZ2dpQzBVRVFDQUtRUUZCNnRZQVFRQVFDRUVBREF3TElBQWdBQ2dDRUNBTUlBb2dDeEVCQUVVRVFDQVBJQThvQWlnMkFpQWdDa0VCUWFUb0FDQVBRU0JxRUFoQkFBd01DeUFKS1FNNElURWdEeWdDSkNFUklBQW9Bc2dCSWhRb0FpZ2lFaUFBS0FMTUFTSU1RU2hzSWc1cUloWW9BaFFpSEVFQmFpSWRJQllvQWh3aUMwc0VRQ0FXQW44Z0M3TkRBQURJUXBJaVFVTUFBSUJQWFNCQlF3QUFBQUJnY1FSQUlFR3BEQUVMUVFBTElnczJBaHdnRmlnQ0dDQUxRUmhzRUJBaEN5QVVLQUlvSWhJZ0Rtb2hGaUFMUlEwRElCWWdDellDR0NBV0tBSVVJaHhCQVdvaEhRc2dEaUFTYWlJT0tBSVlJQnhCR0d4cUlnc2dFVUVFYWpZQ0VDQUxJREduSUJGclFRUnJJZ3lzTndNSUlBc2dHRHNCQUNBT0lCMDJBaFFDUUNBWVFaRC9BMGNOQUNBT0tBSVFJZ3NFUUNBTElBNG9BZ3hCR0d4cUlBeXROd01BQ3lBSktRTTRweUFQS0FJa2EwRUVhNjBpTVNBQUtRTXdWdzBBSUFBZ01UY0RNQXNnQUMwQVJFRUVjUVJBSUFrZ0FEVUNHQ0FLSUFrb0FpZ1JDQUFnQURVQ0dGSUVRQ0FLUVFGQmxoSkJBQkFJUVFBTURRc2dEMEdUL3dNMkFpZ01CQXNnQ1NBQUtBSVFRUUlnQ2hBU1FRSkhCRUFnQ2tFQlFaWVNRUUFRQ0VFQURBd0xJQUFvQWhBZ0QwRW9ha0VDRUFvZ0R5Z0NLRUdUL3dOSERRRU1Bd3NMSUFCQndBQTJBZ2dNQVFzZ0ZpZ0NHQkFKSUJRb0FpZ2dERUVvYkdvaUFFRUFOZ0ljSUFCQ0FEY0NGQ0FLUVFGQmhSMUJBQkFJUVFBTUNBc0NRQ0FKS1FNSUlqRlFCSDVDQUFVZ01TQUpLUU00ZlF0UUJFQWdBQ2dDQ0VIQUFFWU5BUXNDUUFKQUlBQXRBRVFpQzBFRWNVVUVRQ0FBS0FMTUFVR01MR3doRENBQUtBS2NBU0V1QWtBQ1FDQUFLQUk0QkVBZ0NTa0RDQ0l4VUFSK1FnQUZJREVnQ1NrRE9IMExweUVUREFFTElBQW9BaGdpRTBFQ1NRMEJDeUFBSUJOQkFtc2lFellDR0FzZ0xpQU1haUVZSUJORkRRRWdDU2tEQ0NJeFVBUitRZ0FGSURFZ0NTa0RPSDBMSUJPdFV3UkFJQUFvQXJnQkJFQWdDa0VCUWJrc1FRQVFDRUVBREEwTElBcEJBa0c1TEVFQUVBZ0xJQUFvQWhnaURrRitUd1JBSUFwQkFVSCtDa0VBRUFoQkFBd01Dd0pBSUJnb0F0d3JJZ3dFUUNBWUtBTGdLeUlMUVgwZ0RtdExCRUFnQ2tFQlFic0pRUUFRQ0VFQURBNExJQXdnQ3lBT2FrRUNhaEFRSWdzRVFDQVlJQXMyQXR3ckRBUUxJQmdvQXR3ckVBa2dHRUVBTmdMY0t3d0JDeUFZSUE1QkFtb1FEU0lMTmdMY0t5QUxEUUlMSUFwQkFVR0hMMEVBRUFoQkFBd0xDeUFBUVFnMkFnZ2dBQ0FMUWZvQmNUb0FSQXdCQ3lBQUtBTElBU0lXQkVBZ0ZpZ0NLQ0lTSUFBb0Fzd0JJaFJCS0d3aUVXb2lEQ2dDRUNBTUtBSU1RUmhzYWlJTElBa3BBemdpTWtJQ2ZTSXhOd01JSUFzZ01pQUFOUUlZZkRjREVDQUFLQUlZSVE0Q1FDQU1LQUlVSWh4QkFXb2lIU0FNS0FJY0lndE5CRUFnRENnQ0dDRU1EQUVMSUF3Q2Z5QUxzME1BQU1oQ2tpSkJRd0FBZ0U5ZElFRkRBQUFBQUdCeEJFQWdRYWtNQVF0QkFBc2lDellDSENBTUtBSVlJQXRCR0d3UUVDRU1JQllvQWlnaUVpQVJhaUVMSUF4RkRRWWdDeUFNTmdJWUlBc29BaFFpSEVFQmFpRWRDeUFNSUJ4QkdHeHFJZ3NnRGtFQ2FqWUNFQ0FMSURIRU53TUlJQXRCay84RE93RUFJQkVnRW1vZ0hUWUNGQXNnQUNnQ0dDRU1Ba0FnRTBVRVFFRUFJUk1NQVFzZ0NTQVlLQUxjS3lBWUtBTGdLMm9nRENBS0VCSWhFeUFBS0FJWUlRd0xJQUJCQ0VIQUFDQU1JQk5HR3pZQ0NDQVlJQmdvQXVBcklCTnFOZ0xnS3lBQUxRQkVJZ3RCQ1hGQkFVY05BQ0FBSUF0QkNISTZBRVFnQUNnQ3pBRWhEaUFKS0FJY1FRSkdEUUFnQ1NrRE9DSXhRbjlSRFFBQ1FBTkFRUUFoRENBSklBOUJ4Z0JxSWd0QkFpQUtFQkpCQWtjTkFTQUxJQTlCUUd0QkFoQUtJQThvQWtCQmtQOERSdzBCUVpZU0lSSWdDU0FMUVFJZ0NoQVNRUUpIRFFrZ0N5QVBRVHhxUVFJUUNpQVBLQUk4UVFwSEJFQkJoeTRoRWd3S0N5QVBRUWcyQWp3Z0NTQVBRY1lBYWtFSUlBb1FFaUlMSUE4b0FqeEhEUWtnQzBFSVJ3UkFRYjBlSVJJTUNnc2dEMEhHQUdvZ0QwRTRha0VDRUFvZ0tTQVBRVFJxUVFRUUNpQW9JQTlCTUdwQkFSQUtJQ1VnRDBFc2FrRUJFQW9nRGlBUEtBSTRSd1JBSUE4b0FqUWlDMEVPU1EwQ0lBOGdDMEVNYXlJTE5nSTBJQWtnQzYwZ0NpQUpLQUlvRVFnQUlBODFBalJSRFFFTUFnc0xJQThvQWpBZ0R5Z0NMRVloREFzZ0NTQXhJQW9nQ1NnQ0xCRU1BRVVOQ0NBTVJRMEFJQUFnQUMwQVJFSHVBWEZCRUhJNkFFUUNRQ0FYUlEwQUlBQW9BcHdCSVJOQkFDRUxBa0FnS2cwQUlCTkIyQ3RxSWd3Z0pHb2dERWtnSTNJTkFBTkFJQk1nQzBHTUxHeHFJaHdvQXRnckloMzlFU0FUSUF0QkFYSkJqQ3hzYWlJWUtBTFlLeUlXL1J3QklCTWdDMEVDY2tHTUxHeHFJaEVvQXRnckloVDlIQUlnRXlBTFFRTnlRWXdzYkdvaURpZ0MyQ3NpRFAwY0EvME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFQMDRJa0Q5R3dCQkFYRUVRQ0FjUWRncmFpQWRRUUZxTmdJQUN5QkEvUnNCUVFGeEJFQWdHRUhZSzJvZ0ZrRUJhallDQUFzZ1FQMGJBa0VCY1FSQUlCRkIyQ3RxSUJSQkFXbzJBZ0FMSUVEOUd3TkJBWEVFUUNBT1FkZ3JhaUFNUVFGcU5nSUFDeUFMUVFScUlnc2dEVWNOQUFzZ0Z5QU5JZ3RHRFFFTElBdEJBWEloRENBaUJFQWdFeUFMUVl3c2JHb2lEaWdDMkNzaUN3UkFJQTVCMkN0cUlBdEJBV28yQWdBTElBd2hDd3NnRENBWFJnMEFBMEFnRXlBTFFZd3NiR29pRGlnQzJDc2lEQVJBSUE1QjJDdHFJQXhCQVdvMkFnQUxJQTVCNU5jQWFpSU9LQUlBSWd3RVFDQU9JQXhCQVdvMkFnQUxJQXRCQW1vaUN5QVhSdzBBQ3dzZ0NrRUNRWlhEQUVFQUVBZ0xJQUF0QUVSQkFYRU5BQ0FKSUFBb0FoQkJBaUFLRUJKQkFrY0VRQUpBSUFBb0Fzd0JRUUZxSUJkSERRQWdGMFVOQUNBQUtBS2NBU0VNUVFBaEN3TkFJQXdnQzBHTUxHeHFJZ2tvQXRRclJRUkFJQWtvQXRnclJRMElDeUFMUVFGcUlnc2dGMGNOQUFzTElBcEJBVUdXRWtFQUVBaEJBQXdKQ3lBQUtBSVFJQTlCS0dwQkFoQUtJQThvQWlnaEN5QUFMUUJFUVFGeERRSWdDMEhaL3dOSERRRU1BZ3NMSUE4b0FpZ2hDd3NnQzBIWi93TkhEUUlnQUNnQ0NFR0FBa1lOQWlBQVFZQUNOZ0lJSUFCQkFEWUN6QUVNQWdzZ0N5Z0NHQkFKSUJZb0FpZ2dGRUVvYkdvaUFFRUFOZ0ljSUFCQ0FEY0NGQ0FLUVFGQmhSMUJBQkFJUVFBTUJBc2dEeUFMTmdJUUlBcEJCRUhDMFFBZ0QwRVFhaEFJSUFBZ0N6WUN6QUVnRDBIWi93TTJBaWdnQUVHQUFqWUNDQXNnQUNnQ3pBRWhDeUFBS0FLY0FTRUpBa0FDUUNBQUxRQkVRUUZ4RFFBQ1FBSkFJQXNnRjA4TkFDQUpJQXRCakN4c2FpRVRBMEFnRXlnQzNDc05BU0FBSUF0QkFXb2lDellDekFFZ0UwR01MR29oRXlBTElCZEhEUUFMREFFTElBc2dGMGNOQVFzZ0NFRUFOZ0lBREFFTEFrQUNRQ0FLUVFFZ0NTQUxRWXdzYkdvaUVTZ0N0Q2dFZjBHY05BVWdFUzBBaUN4QkFuRkZEUUlDUUNBUktBS29LQ0lOUlFSQVFRQWhEQXdCQ3lBUktBS3NLQ0VKUVFBaERFRUFJUXNnRFVFRVR3UkFJQTFCZkhFaEMvME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFDRkFRUUFoRWdOQUlBa2dFa0VEZEdvaURFRWNhaUFNUVJScUlBeEJER29nRFAwSkFnVDlWZ0lBQWYxV0FnQUMvVllDQUFNZ1FQMnVBU0ZBSUJKQkJHb2lFaUFMUncwQUN5QkFJRUFnUVAwTkNBa0tDd3dORGc4QUFRSURBQUVDQS8ydUFTSkFJRUFnUVAwTkJBVUdCd0FCQWdNQUFRSURBQUVDQS8ydUFmMGJBQ0VNSUFzZ0RVWU5BUXNEUUNBSklBdEJBM1JxS0FJRUlBeHFJUXdnQzBFQmFpSUxJQTFIRFFBTEN5QVJJQXdRRFNJSk5nSzBLQ0FKRFFGQmx4NExRUUFRQ0NBS1FRRkI5VHhCQUJBSVFRQU1CUXNnRVNBTU5nSzhLQ0FSS0FLc0tDRUpJQkVvQXFnb0lnd0VRRUVBSVJKQkFDRUxBMEFnQ1NBTFFRTjBJaFJxSWc0b0FnQWlEUVJBSUJFb0FyUW9JQkpxSUEwZ0RpZ0NCQkFMR2lBUktBS3NLQ0FVYWlJSktBSUVJUzhnQ1NnQ0FCQUpJQkVvQXF3b0lna2dGR3BDQURjQ0FDQXZJQkpxSVJJZ0VTZ0NxQ2doREFzZ0MwRUJhaUlMSUF4SkRRQUxDeUFSUVFBMkFxZ29JQWtRQ1NBUlFRQTJBcXdvSUJFZ0VTZ0N0Q2cyQXJBb0lCRWdFU2dDdkNnMkFyZ29Dd0ovUVFBaEtDQUFLQUxRQVNJTEtBSWNJaVlvQWt3Z0FDZ0N6QUVpQ1VHTUxHeHFLQUxRS3lFYklBc29BaGdpRkNnQ0dDRW5JQXNvQWhRb0FnQWlIaUFtS0FJRUlDWW9BZ3dpQ3lBSklBa2dKaWdDR0NJSmJpSU1JQWxzYTJ4cUlnNGdGQ2dDQUNJSklBa2dEa2tiSWcwMkFnQWdIa0YvSUFzZ0Rtb2lDU0FKSUE1Skd5SUxJQlFvQWdnaUNTQUpJQXRMR3lJSk5nSUlBa0FnQ1NBTlNpQU5RUUJPY1VVRVFDQUtRUUZCZ1ROQkFCQUlEQUVMSUI0b0FoUWhFQ0FlSUNZb0FnZ2dEQ0FtS0FJUUlndHNhaUlOSUJRb0FnUWlDU0FKSUExSkd5SU1OZ0lFSUI1QmZ5QUxJQTFxSWdrZ0NTQU5TUnNpQ3lBVUtBSU1JZ2tnQ1NBTFN4c2lDVFlDRENBSklBeEtJQXhCQUU1eFJRUkFJQXBCQVVIYk1rRUFFQWdNQVFzQ1FDQWJLQUlFQkVBZ0hpZ0NFQTBCUVFFTUF3c2dDa0VCUWRVb1FRQVFDQXdCQ3dKQUFrQURRQ0FuUVFBMkFpUWdFQ0FuTkFJQUlqVkNBWDBpTVNBZU5BSUFmQ0ExZno0Q0FDQVFJQ2MwQWdRaU5FSUJmU0l5SUI0MEFnUjhJRFIvUGdJRUlCQWdNU0FlTkFJSWZDQTFmejRDQ0NBZU5BSU1JVEVnRUNBb05nSVFJQkFnTVNBeWZDQTBmejRDRENBUUlCc29BZ1FpQ3pZQ0ZDQVFRUUVnQ3lBbUtBSlFJZ2xySUFrZ0Mwc2JOZ0lZSUJBb0FqUVFDU0FRUVFBMkFrUWdFUDBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQWpRZ0MwR1lBV3doREFKQUlCQW9BaHdpQ1VVRVFDQVFJQXdRRFNJSk5nSWNJQWxGRFFVZ0VDQU1OZ0lnSUFsQkFDQU1FQTRhREFFTElBd2dFQ2dDSUUwTkFDQUpJQXdRRUNJTFJRUkFJQXBCQVVHQUYwRUFFQWdnRUNnQ0hCQUpJQkJDQURjQ0hBd0ZDeUFRSUFzMkFod2dDeUFRS0FJZ0lnbHFRUUFnRENBSmF4QU9HaUFRSUF3MkFpQUxJQkFvQWhRaUN3UkFJQnRCc0FkcUlSMGdHMEdzQm1vaEdDQWJRUnhxSVNzZ0VDZ0NIQ0VhUVFBaExBTkFJQnBDZnlBTFFRRnJJZ210SWpPR1FuK0ZJaklnRURRQ0FId2dNNGVuSWhZMkFnQWdHaUF5SUJBMEFnUjhJRE9IcHlJUk5nSUVJQm9nTWlBUU5BSUlmQ0F6aHlJeHB5SVVOZ0lJSUJvZ01pQVFOQUlNZkNBemh5STBweUlPTmdJTUlESEVRZ0VnR0NBc1FRSjBJZ3hxS0FJQUloK3RJakdHZkVJQmZTQXhoNmNnSDNRaURVRUFTQTBFSURURVFuOGdEQ0FkYWlnQ0FDSWdyU0l4aGtKL2hYd2dNWWVuSUNCMElneEJBRWdOQkNBYUlBeEJmeUFnZENBUmNTSVRheUFnZFVFQUlBNGdFVWNiSWd3MkFoUWdHaUFOUVg4Z0gzUWdGbkVpSW1zZ0gzVkJBQ0FVSUJaSEd5SU5OZ0lRQWtBZ0RVVU5BQ0FOclNBTXJYNUNJSWhRRFFBTUJBc2dEQ0FOYkNJalFlZk1tVE5QRFFNZ0kwRW9iQ0VoSUJvZ0xBUi9JQ0JCQVdzaElDQWZRUUZySVI4Z0U2eENBWHhDQVlpbklSTWdJcXhDQVh4Q0FZaW5JU0pCQXdWQkFRczJBaGdnR2tFY2FpRVZRZ0VnQzYwaU5vWWhOMEovSUJzb0Fnd2lDeUFnSUFzZ0lFa2JJaTJ0SWp5R1FuK0ZJVDFDZnlBYktBSUlJZ3NnSHlBTElCOUpHeUlTclNJK2hrSi9oU0UvUVFBaEtRTkFBbjRnTEVVRVFDQXlJQkEwQWdSOElET0hJVGdnTWlBUU5BSUFmQ0F6aHlFNVFRQWhDeUF5SWpFaE9pQXpEQUVMSURjZ0tVRUJhaUlMUVFGMnJTQXpoa0ovaFh3aU9pQVFOQUlFZkNBMmh5RTRJRGNnQzBFQmNhMGdNNFpDZjRWOElqRWdFRFFDQUh3Z05vY2hPU0EyQ3lFN0lCQTBBZ2doTlNBUU5BSU1JVFFnRlNBNFBnSUVJQlVnT1Q0Q0FDQVZJQXMyQWhBZ0ZTQTBJRHA4SUR1SFBnSU1JQlVnTVNBMWZDQTdoejRDQ0VFQUlRMENRQ0FiS0FJVVJRMEFJQXRGRFFCQkFrRUJJQXRCQTBZYklRMExJQ3NvQWdRaERFUUFBQUFBQUFEd1B5RkNBa0FnSnlnQ0dDQU5haUFyS0FJQWF5SUxRWUFJVGdSQVJBQUFBQUFBQU9CL0lVSWdDMEgvRDBrRVFDQUxRZjhIYXlFTERBSUxSQUFBQUFBQUFQQi9JVUpCL1JjZ0N5QUxRZjBYVHh0Qi9nOXJJUXNNQVFzZ0MwR0JlRW9OQUVRQUFBQUFBQUJnQXlGQ0lBdEJ1SEJMQkVBZ0MwSEpCMm9oQ3d3QkMwUUFBQUFBQUFBQUFDRkNRZkJvSUFzZ0MwSHdhRTBiUVpJUGFpRUxDeUFWSUVJZ0MwSC9CMnF0UWpTR3Y2SWdETGRFQUFBQUFBQUFRRCtpUkFBQUFBQUFBUEEvb0tLMk9BSWdJQlVnS3lnQ0FDQWJLQUtrQm1wQkFXczJBaHdnRlNnQ0ZDRUxBa0FDUUFKQUlDTkZEUUFnQ3cwQUlCVWdJUkFOSWdzMkFoUWdDMFVFUUNBS1FRRkJsQlZCQUJBSURBb0xJQXRCQUNBaEVBNGFJQlVnSVRZQ0dBd0JDeUFoSUJVb0FoaExCRUFnQ3lBaEVCQWlERVVFUUNBS1FRRkJsQlZCQUJBSUlCVW9BaFFRQ1NBVlFnQTNBaFFNQ2dzZ0ZTQU1OZ0lVSUF3Z0ZTZ0NHQ0lMYWtFQUlDRWdDMnNRRGhvZ0ZTQWhOZ0lZQ3lBalJRMEJDeUFWS0FJVUlRdEJBQ0VrQTBBZ0N5QWtJQ1FnR2lnQ0VDSU1iaUlXSUF4c2F5SU9JQjkwSUNKcUlnMGdGU2dDQUNJTUlBd2dEVWdiSWhFMkFnQWdDeUFXSUNCMElCTnFJZzBnRlNnQ0JDSU1JQXdnRFVnYkloUTJBZ1FnQ3lBT1FRRnFJQjkwSUNKcUlnMGdGU2dDQ0NJTUlBd2dEVW9iSWc0MkFnZ2dDeUFXUVFGcUlDQjBJQk5xSWcwZ0ZTZ0NEQ0lNSUF3Z0RVb2JJZ3cyQWd3Z0N5QS9JQTZzZkNBK2g2Y2dFU0FTZFNJV2F5QVNkQ0FTZFNJTk5nSVFJQXNnUFNBTXJId2dQSWVuSUJRZ0xYVWlFV3NnTFhRZ0xYVWlERFlDRkNBTUlBMXNJaVd0UWdhR1FpQ0lRZ0JTQkVBZ0NrRUJRZVVWUVFBUUNBd0pDeUFsUVFaMElRNENRQUovQWtBZ0N5Z0NHQ0lNRFFBZ0pVVU5BQ0FMSUE0UURTSU1OZ0lZSUF4RkRRc2dERUVBSUE0UURob2dDMEVjYWd3QkN5QU9JQXNvQWh4TkRRRWdEQ0FPRUJBaURVVUVRQ0FMS0FJWUVBa2dDMElBTndJWUlBcEJBVUhqRWtFQUVBZ01Dd3NnQ3lBTk5nSVlJQTBnQ3lnQ0hDSU1ha0VBSUE0Z0RHc1FEaG9nQzBFY2Fnc2dEallDQUFzZ0N5Z0NGQ0VPSUFzb0FoQWhEU0FMQW44Z0N5Z0NJQ0lNUlFSQUlBMGdEaUFLRUZ3TUFRc2dEQ0FOSUE0Z0NoQmFDellDSUNBTEtBSVVJUTRnQ3lnQ0VDRU5JQXNDZnlBTEtBSWtJZ3hGQkVBZ0RTQU9JQW9RWEF3QkN5QU1JQTBnRGlBS0VGb0xOZ0lrSUNVRVFFRUFJUmNEUUNBWElBc29BaEFpRG00aEhBSkFJQXNvQWhnZ0YwRUdkR29pR1NnQ0FDSVVCRUFnR1NnQ09DRU5JQmtvQWdRaERDQVpLQUl3SVNvZ0dTZ0NQQkFKSUJuOURBQUFBQUFBQUFBQUFBQUFBQUFBQUFEOUN3SW9JQmxDQURjQ09DQVovUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNDR0NBWi9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0NDQ0FaSUJRMkFnQWdHU0FxTmdJd0lDb0VRQ0FVUVFBZ0trRVliQkFPR2dzZ0dTQU5OZ0k0SUJrZ0REWUNCQXdCQ3lBWlFRcEJHQkFNSWd3MkFnQWdERVVOQ3lBWlFRbzJBakFMSUJrZ0Z5QU9JQnhzYXlBV2FpSVVJQkowSWcwZ0N5Z0NBQ0lNSUF3Z0RVZ2JOZ0lJSUJrZ0VTQWNhaUlPSUMxMElnMGdDeWdDQkNJTUlBd2dEVWdiTmdJTUlCa2dGRUVCYWlBU2RDSU5JQXNvQWdnaURDQU1JQTFLR3pZQ0VDQVpJQTVCQVdvZ0xYUWlEU0FMS0FJTUlnd2dEQ0FOU2hzMkFoUWdGMEVCYWlJWElDVkhEUUFMQ3lBTFFTaHFJUXNnSkVFQmFpSWtJQ05IRFFBTEN5QXJRUWhxSVNzZ0ZVRWthaUVWSUNsQkFXb2lLU0FhS0FJWVNRMEFDeUFhUVpnQmFpRWFJQWtoQ3lBc1FRRnFJaXdnRUNnQ0ZFa05BQXNMSUNkQk5Hb2hKeUFRUWN3QWFpRVFJQnRCdUFocUlSc2dLRUVCYWlJb0lCNG9BaEJKRFFBTFFRRU1Bd3NnQ2tFQlFaUVdRUUFRQ0F3QkN5QUtRUUZCc3hGQkFCQUlDMEVBQzBVRVFDQUtRUUZCd2h0QkFCQUlRUUFNQkFzZ0FDZ0N6QUVoQ1NBUElBQW9BbWdnQUNnQ2JHdzJBZ1FnRHlBSlFRRnFOZ0lBSUFwQkJFSE8xd0FnRHhBSUlBRWdBQ2dDekFFMkFnQWdDRUVCTmdJQUlBSUVRQ0FDSUFBb0F0QUJRUUFRVFNJQk5nSUFRUUFnQVVGL1JnMEVHZ3NnQXlBQUtBTFFBU2dDRkNnQ0FDSUJLQUlBTmdJQUlBUWdBU2dDQkRZQ0FDQUZJQUVvQWdnMkFnQWdCaUFCS0FJTU5nSUFJQWNnQVNnQ0VEWUNBQ0FBSUFBb0FnaEJnQUZ5TmdJSUMwRUJEQUlMSUFwQkFTQVNRUUFRQ0FzZ0NrRUJRZVFiUVFBUUNFRUFDeUV3SUE5QjBBQnFKQUFnTUF2ZUVBSU5md0orQWtBZ0FDZ0NJQ0lGRFFBQ1FDQUFLQUlRSWdsQkJVb0VRQ0FKSVFNTUFRc0NRQUpBSUFBb0FoUWlBa0VGVGdSQUlBQW9BZ0FpQVNnQ0FDRUZJQUFnQVVFRWFqWUNBQ0FDUVFScklRY01BUXNnQWtFQVRBUkFRWDhoQlF3Q0N5QUFLQUlBSVFFQ2Z5QUNRUUZHQkVCQmZ5RUdRUUFNQVF0QmZ5RUdJQUpCQVdzaUEwRUJjU0VOQWtBZ0FrRUNSZ1JBUVFBaEJTQUNJUVFNQVFzZ0EwRitjU0VMUVFBaEJTQUJJUU1nQWlFRUEwQWdBQ0FEUVFGcU5nSUFJQU10QUFBaERDQUFJQU5CQW1vaUFUWUNBQ0FBSUFSQkFXczJBaFFnQXkwQUFTRURJQUFnQkVFQ2F5SUVOZ0lVSUFaQi93RWdCWFJCZjNOeElBd2dCWFJ5UVlEK0F5QUZkRUYvYzNFZ0F5QUZRUWh5ZEhJaEJpQUZRUkJxSVFVZ0FTRURJQWhCQW1vaUNDQUxSdzBBQ3dzZ0RRUkFJQUFnQVVFQmFpSUROZ0lBSUFFdEFBQWhBU0FBSUFSQkFXczJBaFFnQmtIL0FTQUZkRUYvYzNFZ0FTQUZkSEloQmlBRElRRUxJQUpCQTNSQkNHc0xJUVVnQUNBQlFRRnFOZ0lBSUFaQi93RWdCWFJCZjNOeElBRXRBQUJCRDNJZ0JYUnlJUVVMSUFBZ0J6WUNGQXNnQUNnQ0dDRUJJQUFnQlVFWWRpSUhRZjhCUmpZQ0dDQUFJQWtnQlVFUWRrSC9BWEVpQ0VIL0FVWWlDaUFGUVFoMlFmOEJjU0lMUWY4QlJpSU1JQUVnQlVIL0FYRWlCRUgvQVVZaUFtcHFhaUlCYTBFZ2FpSUROZ0lRSUFBZ0FDa0RDQ0FFUVFkQkNDQUNHM1FnQzNKQkIwRUlJQXdiZENBSWNrRUhRUWdnQ2h0MElBZHlyU0FCSUFsclFTQnFyWWFFTndNSVFRQWhCU0FEUVFaSURRRUxJQUFvQWh3aUFVRUNkRUd3blFGcUtBSUFJUUlDZmlBQUtRTUlJZzVDQUZNRVFFRU1JQUZCQVdvZ0FVRUxUaHNoQkNBRFFRRnJJUU5CZnlBQ2RFRi9jMEVCZENFQlFnRU1BUXNnQVVFQmEwRUFJQUZCQVVvYklRUWdEa0UvSUFKcnJZaW5RWDhnQW5SQmYzTnhRUUYwUVFGeUlRRWdBeUFDUVFGcUlnSnJJUU1nQXEwTElROGdBQ0FETmdJUUlBQWdCRFlDSENBQUlBNGdENFkzQXdnZ0FDQUJyQ0FBS1FNb1FrQ0RoRGNES0VFQklRVWdBMEVHU0EwQUlBQW9BaHdpQVVFQ2RFR3duUUZxS0FJQUlRSUNmaUFBS1FNSUlnNUNBRk1FUUVFTUlBRkJBV29nQVVFTFRoc2hCQ0FEUVFGcklRTkJmeUFDZEVGL2MwRUJkQ0VCUWdFTUFRc2dBVUVCYTBFQUlBRkJBVW9iSVFRZ0RrRS9JQUpycllpblFYOGdBblJCZjNOeFFRRjBRUUZ5SVFFZ0F5QUNRUUZxSWdKcklRTWdBcTBMSVE4Z0FDQUROZ0lRSUFBZ0JEWUNIQ0FBSUE0Z0Q0WTNBd2dnQUNBQUtRTW9RdjlBZ3lBQnJFSUhob1EzQXloQkFpRUZJQU5CQmtnTkFDQUFLQUljSWdGQkFuUkJzSjBCYWlnQ0FDRUNBbjRnQUNrRENDSU9RZ0JUQkVCQkRDQUJRUUZxSUFGQkMwNGJJUVFnQTBFQmF5RURRWDhnQW5SQmYzTkJBWFFoQVVJQkRBRUxJQUZCQVd0QkFDQUJRUUZLR3lFRUlBNUJQeUFDYTYySXAwRi9JQUowUVg5emNVRUJkRUVCY2lFQklBTWdBa0VCYWlJQ2F5RURJQUt0Q3lFUElBQWdBellDRUNBQUlBUTJBaHdnQUNBT0lBK0dOd01JSUFBZ0FDa0RLRUwvLzBDRElBR3NRZzZHaERjREtFRURJUVVnQTBFR1NBMEFJQUFvQWh3aUFVRUNkRUd3blFGcUtBSUFJUUlDZmlBQUtRTUlJZzVDQUZNRVFFRU1JQUZCQVdvZ0FVRUxUaHNoQkNBRFFRRnJJUU5CZnlBQ2RFRi9jMEVCZENFQlFnRU1BUXNnQVVFQmEwRUFJQUZCQVVvYklRUWdEa0UvSUFKcnJZaW5RWDhnQW5SQmYzTnhRUUYwUVFGeUlRRWdBeUFDUVFGcUlnSnJJUU1nQXEwTElROGdBQ0FETmdJUUlBQWdCRFlDSENBQUlBNGdENFkzQXdnZ0FDQUFLUU1vUXYvLy8wQ0RJQUdzUWhXR2hEY0RLRUVFSVFVZ0EwRUdTQTBBSUFBb0Fod2lBVUVDZEVHd25RRnFLQUlBSVFJQ2ZpQUFLUU1JSWc1Q0FGTUVRRUVNSUFGQkFXb2dBVUVMVGhzaEJDQURRUUZySVFOQmZ5QUNkRUYvYzBFQmRDRUJRZ0VNQVFzZ0FVRUJhMEVBSUFGQkFVb2JJUVFnRGtFL0lBSnJyWWluUVg4Z0FuUkJmM054UVFGMFFRRnlJUUVnQXlBQ1FRRnFJZ0pySVFNZ0FxMExJUThnQUNBRE5nSVFJQUFnQkRZQ0hDQUFJQTRnRDRZM0F3Z2dBQ0FBS1FNb1F2Ly8vLzlBZ3lBQnJFSWNob1EzQXloQkJTRUZJQU5CQmtnTkFDQUFLQUljSWdGQkFuUkJzSjBCYWlnQ0FDRUNBbjRnQUNrRENDSU9RZ0JUQkVCQkRDQUJRUUZxSUFGQkMwNGJJUVFnQTBFQmF5RURRWDhnQW5SQmYzTkJBWFFoQVVJQkRBRUxJQUZCQVd0QkFDQUJRUUZLR3lFRUlBNUJQeUFDYTYySXAwRi9JQUowUVg5emNVRUJkRUVCY2lFQklBTWdBa0VCYWlJQ2F5RURJQUt0Q3lFUElBQWdBellDRUNBQUlBUTJBaHdnQUNBT0lBK0dOd01JSUFBZ0FDa0RLRUwvLy8vLy8wQ0RJQUd0UWlPR2hEY0RLRUVHSVFVZ0EwRUdTQTBBSUFBb0Fod2lBVUVDZEVHd25RRnFLQUlBSVFJQ2ZpQUFLUU1JSWc1Q0FGTUVRRUVNSUFGQkFXb2dBVUVMVGhzaEJDQURRUUZySVFOQmZ5QUNkRUYvYzBFQmRDRUJRZ0VNQVFzZ0FVRUJhMEVBSUFGQkFVb2JJUVFnRGtFL0lBSnJyWWluUVg4Z0FuUkJmM054UVFGMFFRRnlJUUVnQXlBQ1FRRnFJZ0pySVFNZ0FxMExJUThnQUNBRE5nSVFJQUFnQkRZQ0hDQUFJQTRnRDRZM0F3Z2dBQ0FBS1FNb1F2Ly8vLy8vLzBDRElBR3RRaXFHaERjREtFRUhJUVVnQTBFR1NBMEFJQUFvQWh3aUFVRUNkRUd3blFGcUtBSUFJUUlDZmlBQUtRTUlJZzVDQUZNRVFFRU1JQUZCQVdvZ0FVRUxUaHNoQkNBRFFRRnJJUU5CZnlBQ2RFRi9jMEVCZENFQlFnRU1BUXNnQVVFQmEwRUFJQUZCQVVvYklRUWdEa0UvSUFKcnJZaW5RWDhnQW5SQmYzTnhRUUYwUVFGeUlRRWdBeUFDUVFGcUlnSnJJUU1nQXEwTElROGdBQ0FETmdJUUlBQWdCRFlDSENBQUlBNGdENFkzQXdnZ0FDQUFLUU1vUXYvLy8vLy8vLzlBZ3lBQnJVSXhob1EzQXloQkNDRUZDeUFBSUFWQkFXczJBaUFnQUNBQUtRTW9JZzVDQjRnM0F5Z2dEcWRCL3dCeEN5SUJBWDhnQUFSQUlBQW9BZ3dpQVFSQUlBRVFDU0FBUVFBMkFnd0xJQUFRQ1FzTGhRRUNCWDhCZmdKQUlBQkNnSUNBZ0JCVUJFQWdBQ0VIREFFTEEwQWdBVUVCYXlJQklBQkNDb0FpQjBMMkFYNGdBSHluUVRCeU9nQUFJQUJDLy8vLy81OEJWaUVGSUFjaEFDQUZEUUFMQ3lBSHB5SUNCRUFEUUNBQlFRRnJJZ0VnQWtFS2JpSURRZllCYkNBQ2FrRXdjam9BQUNBQ1FRbExJUVlnQXlFQ0lBWU5BQXNMSUFFTCtlSUJCSHAvQm5zSWZnRjlJd0JCRUdzaVRpUUFBa0FnQUMwQUNFR0FBWEZGRFFBZ0FDZ0N6QUVnQVVjTkFDQUFLQUtjQVNBQlFZd3NiR29pVHlnQzNDc2lGVVVFUUNCUEVDa01BUXNnQUNnQ3lBRWFJQUFvQXRBQklSa2dBQ2dDVENJSFJRUkFJQUFvQWtnaEJ3c2dCeWdDQUNFR0lBY29BZ1FoQ3lBSEtBSUlJUWtnQnlnQ0RDRU5JQUFvQWp3aEJ5QUFLQUpBSVFnZ1R5Z0M0Q3NoQ2lNQVFSQnJJa0FrQUNBWklBRTJBaVFnR1NnQ0hDZ0NUQ0VNSUJsQkFUWUNRQ0FaSUEwMkFqd2dHU0FKTmdJNElCa2dDellDTkNBWklBWTJBakFnR1NBTUlBRkJqQ3hzYWpZQ0lDQVpLQUpFRUFsQkFDRUxJQmxCQURZQ1JBSkFJQWNFUUVFRUlCa29BaGdvQWhBUURDSUxSUVJBREFJTFFRQWhEVUVBSVFrZ0IwRUVUd1JBSUFkQmZIRWhERUVBSVFFRFFDQUxJQWdnQ1VFQ2RHb2lCaWdDQUVFQ2RHcEJBVFlDQUNBTElBWW9BZ1JCQW5ScVFRRTJBZ0FnQ3lBR0tBSUlRUUowYWtFQk5nSUFJQXNnQmlnQ0RFRUNkR3BCQVRZQ0FDQUpRUVJxSVFrZ0FVRUVhaUlCSUF4SERRQUxDeUFIUVFOeElnRUVRQU5BSUFzZ0NDQUpRUUowYWlnQ0FFRUNkR3BCQVRZQ0FDQUpRUUZxSVFrZ0RVRUJhaUlOSUFGSERRQUxDeUFaSUFzMkFrUUxBa0FDUUNBWktBSVlJZ1lvQWhBaURVVU5BRUVBSVFrQ1FBTkFBa0FnQ3dSQUlBc2dDVUVDZEdvb0FnQkZEUUVMSUFZb0FoZ2dDVUUwYkdvaUFUVUNCQ0tHQVVJQmZTS0tBU0FaTlFJOGZDQ0dBWUFoaXdFZ0FUVUNBQ0tIQVVJQmZTS0lBU0FaTlFJNGZDQ0hBWUFoakFFZ2lnRWdHVFVDTkh3Z2hnR0FJWVlCSUJrb0FoUW9BZ0FvQWhRZ0NVSE1BR3hxSWdFb0FoUWdBU2dDR0dzaUIwRWZTdzBBQWtBZ2lBRWdHVFVDTUh3Z2h3R0FweUlJSUFFb0FnQnJJZ3hCQUNBSUlBeFBHeUFIZGcwQUlJWUJweUlJSUFFb0FnUnJJZ3hCQUNBSUlBeFBHeUFIZGcwQUlBRW9BZ2dpQ0NDTUFhZHJJZ3hCQUNBSUlBeFBHeUFIZGcwQUlBRW9BZ3dpQVNDTEFhZHJJZ2hCQUNBQklBaFBHeUFIZGtVTkFRc2dHVUVBTmdKQURBSUxJQWxCQVdvaUNTQU5SdzBBQ3lBWktBSkFSUTBBSUExRkRRRkJBQ0VOQTBBZ0dTZ0NGQ2dDQUNnQ0ZDQU5RY3dBYkdvaUFTZ0NIQ0FCS0FJWVFaZ0JiR29pQjBHVUFXc29BZ0FoQmlBSFFZd0JheWdDQUNFTElBZEJtQUZyS0FJQUlRa2dCMEdRQVdzb0FnQWhDQUpBSUJrb0FrUWlCd1JBSUFjZ0RVRUNkR29vQWdCRkRRRUxJQXNnQm1zaEJ5QUlJQWxySVFrQ1FDQUdJQXRHRFFBZ0I2MGdDYTErUWlDSVVBMEFJQVZCQVVHVUZrRUFFQWdNQmdzZ0J5QUpiQ0lIUVlDQWdJQUVUd1JBSUFWQkFVR1VGa0VBRUFnTUJnc2dBU0FIUVFKMElnYzJBaXdDZndKQUFrQUNRQ0FCS0FJa0lnWUVRQ0FISUFFb0FqQk5EUVVnQVNnQ0tBMEJDeUFCSUFjUUZpSUhOZ0lrSUFkQkFTQUJLQUlzSWdjYlJRMEJJQUVnQnpZQ01DQUJRU2hxREFNTElBWVFDU0FCSUFFb0Fpd1FGaUlITmdJa0lBY05BU0FCUVFBMkFqQWdBVUlBTndJb0N5QUZRUUZCbEJaQkFCQUlEQWNMSUFFZ0FTZ0NMRFlDTUNBQlFTaHFDMEVCTmdJQUN5QU5RUUZxSWcwZ0dTZ0NHQ0lHS0FJUVNRMEFDd3dCQ3lBTlJRMEFJQVlvQWhnaER5QVpLQUlVS0FJQUtBSVVJUlpCQUNFQkEwQUNRQ0FMQkVBZ0N5QUJRUUowYWlnQ0FFVU5BUXNnRmlBQlFjd0FiR29pQnlBSEtBSUFJZ2tnRHlBQlFUUnNhaUlJTlFJQUlvWUJRZ0Y5SW9vQklCazFBakI4SUlZQmdLY2lEQ0FKSUF4TEd5SUpOZ0k0SUFjZ0J5Z0NCQ0lNSUFnMUFnUWlod0ZDQVgwaWl3RWdHVFVDTkh3Z2h3R0FweUlJSUFnZ0RFa2JJZ2cyQWp3Z0J5QUhLQUlJSWd3Z2lnRWdHVFVDT0h3Z2hnR0FweUlYSUF3Z0Ywa2JJZ3cyQWtBZ0J5QUhLQUlNSWhjZ2l3RWdHVFVDUEh3Z2h3R0FweUlPSUE0Z0Ywc2JJaGMyQWtRZ0NTQU1TdzBESUFnZ0Ywc05BeUFIS0FJVUlnNUZEUUFnRHEwaGl3RWdGNjBoaUFFZ0RLMGhqQUVnQ0swaGpRRWdDYTBoaVFFZ0J5Z0NIQ0VKUWdBaGh3RURRQ0FKSUljQnB5SUlRWmdCYkdvaUIwSi9JQTRnQ0VGL2MycXRJb1lCaGtKL2hTS0tBU0NJQVh3Z2hnR0lQZ0tVQVNBSElJb0JJSXdCZkNDR0FZZytBcEFCSUFjZ2lnRWdqUUY4SUlZQmlENENqQUVnQnlDSkFTQ0tBWHdnaGdHSVBnS0lBU0NIQVVJQmZDS0hBU0NMQVZJTkFBc0xJQUZCQVdvaUFTQU5SdzBBQ3dzZ1FFRUFOZ0lJSUJrb0Fod2hBVUVCUVFnUURDSWJCRUFnR3lBQk5nSUVJQnNnQmpZQ0FBc2dHMFVOQVNBWktBSWtJUkVnR1NnQ0ZDZ0NBQ0VnSXdCQjhBQnJJaE1rQUNBUlFZd3NiQ0lCSUJzb0FnUWlDQ2dDVEdvaUhDZ0NwQU1oS0FKL0lCc29BZ0FpSGlFWElBVWhNMEVBSVEwakFFRWdheUlQSkFBZ0FTQUlLQUpNYWlJZEtBS2tBeUVZQWtBZ0Z5Z0NFQ0lXUVpBRWJCQU5JZ3hGRFFBQ1FDQVdRUUowRUEwaUMwVUVRQ0FNSVFzTUFRc0NmeUFJS0FKTUlCRkJqQ3hzYWlJSktBS2tBeUlhUVFGcUlnRkI4QUVRRENJSEJFQUNRQ0FCQkVBZ0Z5Z0NFQ0VPSUFjaEFRTkFJQUVnTXpZQzdBRWdBU0FPUVJBUURDSUdOZ0xJQVNBR1JRMENJQUVnRnlnQ0VDSWZOZ0xFQVVFQUlRWkJBQ0VPSUI4RVFBTkFJQUVvQXNnQklBWkJCSFJxSWc0Z0NTZ0MwQ3NnQmtHNENHeHFJaDhvQWdSQkVCQU1JaUUyQWd3Z0lVVU5CQ0FPSUI4b0FnUTJBZ2dnQmtFQmFpSUdJQmNvQWhBaURra05BQXNMSUFGQjhBRnFJUUVnRWlBYVJpRnpJQkpCQVdvaEVpQnpSUTBBQ3dzZ0J3d0NDeUFIS0FJRUlnRUVRQ0FCRUFrZ0IwRUFOZ0lFQ3lBSElRRkJBQ0VKQTBBZ0FTZ0N5QUVpQmdSQVFRQWhEaUFCS0FMRUFTSVNCSDhEUUNBR0tBSU1JaDhFUUNBZkVBa2dCa0VBTmdJTUlBRW9Bc1FCSVJJTElBWkJFR29oQmlBT1FRRnFJZzRnRWtrTkFBc2dBU2dDeUFFRklBWUxFQWtnQVVFQU5nTElBUXNnQVVId0FXb2hBU0FKSUJwR0lYUWdDVUVCYWlFSklIUkZEUUFMSUFjUUNRdEJBQXNpQndSQUFrQWdGa1VOQUVFQUlRa2dEQ0VHSUJaQkJFOEVRQ0FHSUJaQmZIRWlDVUdRQkd4cUlRWWdEQ0VCQTBBZ0N5QVFRUUowYWlBQi9SSDlEQUFBQUFBUUFnQUFJQVFBQURBR0FBRDlyZ0g5Q3dJQUlBRkJ3QkJxSVFFZ0VFRUVhaUlRSUFsSERRQUxJQWtnRmtZTkFRc0RRQ0FMSUFsQkFuUnFJQVkyQWdBZ0JrR1FCR29oQmlBSlFRRnFJZ2tnRmtjTkFBc0xJQXNoRGtFQUlSSWdDQ2dDVENBUlFZd3NiR29vQXRBcklRRWdGeWdDR0NFSklBOGdDQ2dDQkNBSUtBSU1JQkVnRVNBSUtBSVlJZ1p1SWdzZ0JteHJiR29pQmlBWEtBSUFJaEFnQmlBUVN4czJBaFFnRDBGL0lBWWdDQ2dDREdvaUVDQUdJQkJMR3lJR0lCY29BZ2dpRUNBR0lCQkpHellDRUNBUElBZ29BZ2dnQ0NnQ0VDQUxiR29pQmlBWEtBSUVJZ3NnQmlBTFN4czJBZ3dnRDBGL0lBWWdDQ2dDRUdvaUN5QUdJQXRMR3lJR0lCY29BZ3dpQ3lBR0lBdEpHellDQ0NBUFFRQTJBaGdnRDBFQU5nSWNJQTlCLy8vLy93YzJBZ1FnRDBILy8vLy9CellDQUNBWEtBSVFCRUFEUUNBT0JIOGdEaUFTUVFKMGFpZ0NBQVZCQUFzaEN5QUpOUUlFSW9ZQlFnRjlJb29CSUE4MUFnaDhJSVlCZ0NHTEFTQUpOUUlBSW9jQlFnRjlJb2dCSUE4MUFoQjhJSWNCZ0NHTUFTQ0tBU0FQTlFJTWZDQ0dBWUFoaGdFZ2lBRWdEelVDRkh3Z2h3R0FJWWNCSUFFb0FnUWlDQ0FQS0FJY1N3UkFJQThnQ0RZQ0hDQUJLQUlFSVFnTElBZ0VRQ0NMQVVMLy8vLy9ENE1oaWdFZ2pBRkMvLy8vL3crRElZc0JJSVlCUXYvLy8vOFBneUdJQVNDSEFVTC8vLy8vRDRNaGpBRWdBVUd3QjJvaEh5QUJRYXdHYWlFaFFRQWhHZ05BSUI4Z0drRUNkQ0lRYWlnQ0FDRUdJQkFnSVdvb0FnQWhFVUVBSVJBZ0N3UkFJQXNnQmpZQ0JDQUxJQkUyQWdBZ0MwRUlhaUVRQ3dKQUlCRWdDRUVCYXlJSWFpSUxRUjlMRFFBZ0NTZ0NBQ0lpUVg4Z0MzWkxEUUFnRHlBUEtBSUVJaWNnSWlBTGRDSUxJQXNnSjBzYk5nSUVDd0pBSUFZZ0NHb2lDMEVmU3cwQUlBa29BZ1FpSWtGL0lBdDJTdzBBSUE4Z0R5Z0NBQ0luSUNJZ0MzUWlDeUFMSUNkTEd6WUNBQXRCQUNFTElJb0JRbjhnQ0swaWhnR0dRbitGSW9jQmZDQ0dBWWdpalFGQy8vLy8vdytEUWdFZ0JxMGlpUUdHZkVJQmZTQ0pBWWluSUljQklJZ0JmQ0NHQVlpbklpSWdCblpyUVg4Z0JuWnhRUUFnSWlDTkFhZEhHeUVHSUljQklJc0JmQ0NHQVlnaWpRRkMvLy8vL3crRFFnRWdFYTBpaVFHR2ZFSUJmU0NKQVlpbklJY0JJSXdCZkNDR0FZaW5JaUlnRVhaclFYOGdFWFp4UVFBZ0lpQ05BYWRIR3lFUklCQUVRQ0FRSUFZMkFnUWdFQ0FSTmdJQUlCQkJDR29oQ3dzZ0JpQVJiQ0lHSUE4b0FoaExCRUFnRHlBR05nSVlDeUFhUVFGcUlob2dBU2dDQkVrTkFBc0xJQWxCTkdvaENTQUJRYmdJYWlFQklCSkJBV29pRWlBWEtBSVFTUTBBQ3dzZ0dFRUJhaUVoSUE4b0Fod2hFU0FQS0FJWUlSSWdCMEVBTmdJRUFrQWdIU2dDQ0VFQmFpSUJyU0FSSUJJZ0Ztd2lJbXdpR3ExK1FpQ0lVQVJBSUFjZ0FTQWFiQ0lCTmdJSUlBY2dBVUVDRUF3aUFUWUNCQ0FCRFFFTElBd1FDU0FPRUFrZ0J5Z0NCQ0lCQkVBZ0FSQUpJQWRCQURZQ0JBc2dJVVVFUUNBSElRc01Bd3RCQUNFTElBY2hBUU5BSUFFb0FzZ0JJZ2tFUUVFQUlRWWdBU2dDeEFFaUVBUi9BMEFnQ1NnQ0RDSUlCRUFnQ0JBSklBbEJBRFlDRENBQktBTEVBU0VRQ3lBSlFSQnFJUWtnQmtFQmFpSUdJQkJKRFFBTElBRW9Bc2dCQlNBSkN4QUpJQUZCQURZQ3lBRUxJQUZCOEFGcUlRRWdDeUFZUmlGMUlBdEJBV29oQ3lCMVJRMEFDeUFISVFzTUFnc2dGeWdDR0NFWElBY2dEeWdDRkNJbk5nTE1BU0FISUE4b0Fnd2lNRFlDMEFFZ0J5QVBLQUlRSWkwMkF0UUJJQWNnRHlnQ0NDSXJOZ0xZQVNBSElCbzJBZ3dnQnlBaU5nSVFJQWNnRWpZQ0ZFRUJJUjhnQjBFQk5nSVlJQllFUUNBSEtBTElBU0VCUVFBaENDQVhJUXNEUUNBT0lBaEJBblJxS0FJQUlRa2dBU0FMS0FJQU5nSUFJQUVnQ3lnQ0JEWUNCQUpBSUFFb0FnZ2lEVVVOQUNBQktBSU1JUVlnRFVFQlJ3UkFJQTFCZm5FaEwwRUFJUkFEUUNBR0lBa29BZ0EyQWdBZ0JpQUpLQUlFTmdJRUlBWWdDU2dDQ0RZQ0NDQUdJQWtvQWd3MkFnd2dCaUFKS0FJUU5nSVFJQVlnQ1NnQ0ZEWUNGQ0FHSUFrb0FoZzJBaGdnQmlBSktBSWNOZ0ljSUFaQklHb2hCaUFKUVNCcUlRa2dFRUVDYWlJUUlDOUhEUUFMQ3lBTlFRRnhSUTBBSUFZZ0NTZ0NBRFlDQUNBR0lBa29BZ1EyQWdRZ0JpQUpLQUlJTmdJSUlBWWdDU2dDRERZQ0RBc2dDMEUwYWlFTElBRkJFR29oQVNBSVFRRnFJZ2dnRmtjTkFBc0xJQ0ZCQVVzRVFDQUhJUTBEUUNBTklDczJBc2dESUEwZ0xUWUN4QU1nRFNBd05nTEFBeUFOSUNjMkFyd0RJQTFCQVRZQ2lBSWdEU0FTTmdLRUFpQU5JQ0kyQW9BQ0lBMGdHallDL0FFZ0ZnUkFJQTBvQXJnRElRRkJBQ0VJSUJjaEN3TkFJQTRnQ0VFQ2RHb29BZ0FoQ1NBQklBc29BZ0EyQWdBZ0FTQUxLQUlFTmdJRUFrQWdBU2dDQ0NJaFJRMEFJQUVvQWd3aEJpQWhRUUZIQkVBZ0lVRitjU0V2UVFBaEVBTkFJQVlnQ1NnQ0FEWUNBQ0FHSUFrb0FnUTJBZ1FnQmlBSktBSUlOZ0lJSUFZZ0NTZ0NERFlDRENBR0lBa29BaEEyQWhBZ0JpQUpLQUlVTmdJVUlBWWdDU2dDR0RZQ0dDQUdJQWtvQWh3MkFod2dCa0VnYWlFR0lBbEJJR29oQ1NBUVFRSnFJaEFnTDBjTkFBc0xJQ0ZCQVhGRkRRQWdCaUFKS0FJQU5nSUFJQVlnQ1NnQ0JEWUNCQ0FHSUFrb0FnZzJBZ2dnQmlBSktBSU1OZ0lNQ3lBTFFUUnFJUXNnQVVFUWFpRUJJQWhCQVdvaUNDQVdSdzBBQ3dzZ0RTQU5LUUlFTndMMEFTQVlJQjlISVhZZ0RVSHdBV29oRFNBZlFRRnFJUjhnZGcwQUN3c2dEQkFKSUE0UUNTQWRLQUtrQXlFTEFrQWdIUzBBaUN4QkJIRUVRQ0FMUVg5R0RRRWdIVUdvQTJvaEJpQWRLQUlJSVFGQkFDRVFJQWNoQ1FOQUlBWW9BaVFoRFNBSlFRRTJBaXdnQ1NBTk5nSlVJQWtnQmlnQ0FEWUNNQ0FHS0FJRUlRMGdDVUlBTndKRUlBa2dEVFlDTkNBSklBWW9BZ3cyQWp3Z0NTQUdLQUlRTmdKQUlBWW9BZ2doRFNBSklCSTJBa3dnQ1NBTklBRWdBU0FOU3hzMkFqZ2dCa0dVQVdvaEJpQUpRZkFCYWlFSklBc2dFRVloZHlBUVFRRnFJUkFnZDBVTkFBc01BUXNnQzBGL1JnMEFJQjBvQWdnaEJpQWRLQUlFSVEwZ0J5RUpJQXNFUUNBTFFRRnFRWDV4SVFoQkFDRUJBMEFnQ1VJQU53SkVJQWxCQURZQ05DQUpRZ0UzQWl3Z0NTQU5OZ0pVSUFrZ0VUWUNQQ0FKSUEwMkFzUUNJQWtnRWpZQ1RDQUpJQVkyQWpnZ0NVSUFOd0swQWlBSlFRQTJBcVFDSUFsQ0FUY0NuQUlnQ1NBUk5nS3NBaUFKSUFZMkFxZ0NJQWtnRWpZQ3ZBSWdDU0FKS0FMRUFUWUNRQ0FKSUFrb0FyUUROZ0t3QWlBSlFlQURhaUVKSUFGQkFtb2lBU0FJUncwQUN3c2dDMEVCY1EwQUlBbENBRGNDUkNBSlFRQTJBalFnQ1VJQk53SXNJQWtnRFRZQ1ZDQUpJQkUyQWp3Z0NTQVNOZ0pNSUFrZ0JqWUNPQ0FKSUFrb0FzUUJOZ0pBQ3lBSElRME1BZ3NnREJBSkN5QUxFQWtMSUE5QklHb2tBRUVBSUEwaUIwVU5BQm9nS0VFQmFpRU9JQlVoSFNBSElRc0NRQUpBQTBBZ0N5Z0NWRUYvUmcwQ0lCNG9BaEJCQW5RUURTSUJSUTBDSUFGQkFTQWVLQUlRUVFKMEVBNGhDU0FMRUZBRVFBTkFJQ0FvQWhRaENBSkFBa0FnQ3lnQ0tDQWNLQUlNVHcwQUlBc29BaUFpQVNBSUlBc29BaHhCekFCc2FpSUdLQUlZVHcwQUlBWW9BaHdnQVVHWUFXeHFJZzBvQWhoRkRRQWdEVUVjYWlFSVFRQWhBUUpBQTBBZ0dTQUxLQUljSUFzb0FpQWdDQ0FCUVNSc2FpSUdLQUlRSUFZb0FoUWdDeWdDSkVFb2JHb2lCaWdDQUNBR0tBSUVJQVlvQWdnZ0JpZ0NEQkF5UlFSQUlBRkJBV29pQVNBTktBSVlTUTBCREFJTEN5QUpJQXNvQWh4QkFuUnFRUUEyQWdBZ0UwRUFOZ0pvSUJzb0FnUWdJQ2dDRkNBY0lBc2dFMEhzQUdvZ0hTQVRRZWdBYWlBS0lETVFUMFVOQmlBTEtBSWdJUWdnQ3lnQ0hDRVdJQk1vQW1naEdpQVRLQUpzQkVBZ0UwRUFOZ0pvSUNBb0FoUWdGa0hNQUd4cUtBSWNJQWhCbUFGc2FpSWZLQUlZSWdFRWZ5QUtJQnBySVJnZ0NpQWRhaUVoSUI5QkhHb2hERUVBSVJGQkFDRVBJQm9nSFdvaUlpRVNBMEFDUUNBTUtBSUlJQXdvQWdCR0RRQWdEQ2dDRENBTUtBSUVSZzBBSUF3b0FoUWdDeWdDSkVFb2JHb2lCaWdDRkNBR0tBSVFiQ0lvUlEwQUlBWW9BaGdoQVVFQUlSWURRQ0FQQkVBZ0FVRUFOZ0kwQ3lBQktBSWtJaGNFUUNBQktBSUFJUWdDUUNBQklBRW9BaWdpQmdSL0lBZ2dCa0VZYkdvaUNFRVVheWdDQUNBSVFReHJLQUlBUndSQUlBaEJHR3NoQ0F3Q0N5QUdRUUZxQlVFQkN6WUNLQXNDUUFOQUFrQUNRQUpBSUFnb0FoUWlEU0FTUVg5elN3MEFJQThOQUNBTklCSnFJQ0ZORFFFTElBc29BaHdoQmlBTEtBSWdJUmNnQ3lnQ0pDRVBJQnNvQWdRb0FtZ0VRQ0FUSUFZMkFsZ2dFeUFYTmdKVUlCTWdFVFlDVUNBVElBODJBa3dnRXlBV05nSklJQk1nR0RZQ1JDQVRJQTAyQWtBZ00wRUJRWUx1QUNBVFFVQnJFQWdNRVFzZ0V5QUdOZ0k0SUJNZ0Z6WUNOQ0FUSUJFMkFqQWdFeUFQTmdJc0lCTWdGallDS0NBVElCZzJBaVFnRXlBTk5nSWdJRE5CQWtHQzdnQWdFMEVnYWhBSUlBRkJBRFlDTkNBSUlBZ29BaEFpQmlBSUtBSUVhallDQkNBQklBRW9BaVFpRFNBR2F5SVhOZ0lrUVFFaER5QUdJQTFHRFFFZ0FTQUJLQUlvUVFGcUlnZzJBaWdNQXdzZ0FTZ0NCQ0VRSUFFb0FqUWlEeUFCS0FJNFJ3Ui9JQmNGSUJBZ0QwRUJkRUVCY2lJR1FRTjBFQkFpRUVVRVFDQXpRUUZCZ0FoQkFCQUlEQkVMSUFFZ0JqWUNPQ0FCSUJBMkFnUWdBU2dDTkNFUElBZ29BaFFoRFNBQktBSWtDeUVHSUJBZ0QwRURkR29pRnlBTk5nSUVJQmNnRWpZQ0FDQUJJQTlCQVdvMkFqUWdDQ0FJS0FJQUlBMXFOZ0lBSUFnZ0NDZ0NFQ0lRSUFnb0FnUnFJZzgyQWdRZ0FTQUdJQkJySWhjMkFpUWdDQ0FQTmdJSUlBMGdFbW9oRWtFQUlROGdCaUFRUmcwQUlBRWdBU2dDS0VFQmFqWUNLQ0FJUVJocUlRZ0xJQmNOQUFzZ0FTZ0NLQ0VJQ3lBQklBZzJBaXdMSUFGQlFHc2hBU0FXUVFGcUloWWdLRWNOQUFzZ0h5Z0NHQ0VCQ3lBTVFTUnFJUXdnRVVFQmFpSVJJQUZKRFFBTElBc29BaHdoRmlBTEtBSWdJUWdnR0NBU0lDSnJJQThiQlVFQUN5QWFhaUVhQ3lBZUtBSVlJQlpCTkd4cUlnRWdDQ0FCS0FJa0lnRWdBU0FJU1JzMkFpUU1BZ3NnSUNnQ0ZDRUlDeUFUUVFBMkFtZ2dHeWdDQkNBSUlCd2dDeUFUUWV3QWFpQWRJQk5CNkFCcUlBb2dNeEJQUlEwRUlBc29BaHdoRmlBVEtBSm9JUm9nRXlnQ2JFVU5BQUpBSUNBb0FoUWdGa0hNQUd4cUtBSWNJQXNvQWlBaUlrR1lBV3hxSWdFb0FoZ2lLRVVFUUVFQUlSY01BUXNnQ2lBYWF5RVFJQUZCSEdvaERDQUxLQUlrSVNGQkFDRVhRUUFoR0FOQUFrQWdEQ2dDQ0NBTUtBSUFSZzBBSUF3b0Fnd2dEQ2dDQkVZTkFDQU1LQUlVSUNGQktHeHFJZ0VvQWhRZ0FTZ0NFR3dpSjBVTkFDQUJLQUlZSVJGQkFDRWZBMEFnRVNnQ0pDSUJCRUFnRVNnQ0FDRUlBa0FnRVNBUktBSW9JaElFZnlBSUlCSkJHR3hxSWdoQkZHc29BZ0FnQ0VFTWF5Z0NBRWNFUUNBSVFSaHJJUWdNQWdzZ0VrRUJhZ1ZCQVFzaUVqWUNLQXNDUUFKQUlBZ29BaFFpRHlBWGFpSU5JQTlKRFFBZ0RTQVFTdzBBQTBBZ0RTRVhJQWdnQ0NnQ0VDSU5JQWdvQWdScU5nSUVJQUVnRFdzaEJpQUJJQTFHRFFJZ0VTQVNRUUZxSWhJMkFpZ2dDQ2dDTENJUElCZHFJZzBnRDA4RVFDQUlRUmhxSVFnZ0JpRUJJQTBnRUUwTkFRc0xJQkVnQmpZQ0pBc2dHeWdDQkNnQ2FDRUJJQk1nRmpZQ0dDQVRJQ0kyQWhRZ0V5QVlOZ0lRSUJNZ0lUWUNEQ0FUSUI4MkFnZ2dFeUFRTmdJRUlCTWdEellDQUNBelFRRkJBaUFCRzBHdDdRQWdFeEFJSUFFTkNpQUxLQUljSVJZTUJRc2dFU0FHTmdJa0N5QVJRVUJySVJFZ0gwRUJhaUlmSUNkSERRQUxDeUFNUVNScUlRd2dHRUVCYWlJWUlDaEhEUUFMQ3lBWElCcHFJUm9MQWtBZ0NTQVdRUUowYWlnQ0FFVU5BQ0FlS0FJWUlCWkJOR3hxSWdFb0FpUU5BQ0FCSUNBb0FoUWdGa0hNQUd4cUtBSVlRUUZyTmdJa0N5QUtJQnBySVFvZ0dpQWRhaUVkSUFzUVVBMEFDd3NnQ1JBSklBdEI4QUZxSVFzZ0kwRUJhaUlqSUJ3b0FxUURUUTBBQ3lBSElBNFFNeUJBSUIwZ0ZXczJBZ2hCQVF3Q0N5QUhJQTRRTXlBSkVBbEJBQXdCQ3lBSElBNFFNMEVBQ3lGNElCTkI4QUJxSkFBZ0d4QWxJSGhGRFFFZ0dTZ0NJQ2dDMENzaENTQVpLQUlVS0FJQUloWW9BaFFoSFNCQVFRRTJBZ3hCQUNFTlFRQWhGU0FaS0FJZ0lnRW9BZ3dnQVNnQ0NFWUVRQ0FKS0FJUVFRUjJRUUZ4SVJVTEFrQWdGaWdDRUNJeFJRMEFBMEFDUUNBWktBSkVJZ0VFUUNBQklBMUJBblJxS0FJQVJRMEJDeUJBUVF4cUlSTkJBQ0V4QWtBZ0hTZ0NHQ0lCUlEwQUlCa29BaXdoRUFOQUlCMG9BaHdnTVVHWUFXeHFJZ3dvQWhnaUN3UkFJQXhCSEdvaEVpQU1LQUlVSVFFZ0RDZ0NFQ0VYUVFBaERnTkFJQUVnRjJ3RVFDQVNJQTVCSkd4cUlROUJBQ0VJQTBBZ0dTQWRLQUlRSURFZ0R5Z0NFQ0FQS0FJVUlBaEJLR3hxSWdjb0FnQWdCeWdDQkNBSEtBSUlJQWNvQWd3UU1pRUdJQWNvQWhRaUN5QUhLQUlRSWdwc0lRRUNRQ0FHQkVBZ0FVVU5BVUVBSVFvRFFBSkFJQmtnSFNnQ0VDQXhJQThvQWhBZ0J5Z0NHQ0FLUVFaMGFpSUdLQUlJSUFZb0Fnd2dCaWdDRUNBR0tBSVVFREpGQkVBZ0JpZ0NQQ0lCUlEwQklBRVFDU0FHUVFBMkFqd01BUXNnR1NnQ1FFVUVRQ0FHS0FJOERRRWdCaWdDRUNBR0tBSUlSZzBCSUFZb0FoUWdCaWdDREVZTkFRdEJBVUVzRUF3aUFVVUVRQ0JBUVFBMkFnd01DZ3NnR1NnQ1FDRUxJQUZCQURZQ0pDQUJJQk0yQWh3Z0FTQUpOZ0lVSUFFZ0hUWUNFQ0FCSUE4MkFnd2dBU0FHTmdJSUlBRWdNVFlDQkNBQklBczJBZ0FnQVNBVk5nSW9JQUVnTXpZQ0lDQUJJQkFvQWdSQkFVbzJBaGdnRUVFT0lBRVFKaUJBS0FJTVJRMEpDeUFLUVFGcUlnb2dCeWdDRkNBSEtBSVFiRWtOQUFzTUFRc2dBVVVOQUVFQUlSY0RRQ0FIS0FJWUlCZEJCblJxSWdFb0Fqd2lCZ1JBSUFZUUNTQUJRUUEyQWp3Z0J5Z0NFQ0VLSUFjb0FoUWhDd3NnRjBFQmFpSVhJQW9nQzJ4SkRRQUxDeUFJUVFGcUlnZ2dEQ2dDRkNJQklBd29BaEFpRjJ4SkRRQUxJQXdvQWhnaEN3c2dEa0VCYWlJT0lBdEpEUUFMSUIwb0FoZ2hBUXNnTVVFQmFpSXhJQUZKRFFBTEN5QkFLQUlNUlEwQ0lCWW9BaEFoTVFzZ0NVRzRDR29oQ1NBZFFjd0FhaUVkSUExQkFXb2lEU0F4U1EwQUN3dEJBQ0V4SUJrb0Fpd1FHaUJBS0FJTVJRMEJBa0FnR1NnQ1FBMEFJQmtvQWhnaUhTZ0NFRVVOQUVFQUlRa0RRQ0FaS0FJVUtBSUFLQUlVSUFsQnpBQnNhaUlCS0FJY0lCMG9BaGdnQ1VFMGJHb29BaVJCbUFGc2FpSUhLQUtJQVNFR0lBY29BcEFCSVFzZ0J5Z0NqQUVoQ2lBSEtBS1VBU0VISUFFb0FqUVFDU0FCUVFBMkFqUUNRQ0FaS0FKRUlnMEVRQ0FOSUFsQkFuUnFLQUlBUlEwQkN5QUdJQXRHRFFBZ0J5QUtSZzBBSUFjZ0Ntc2lCNjBnQ3lBR2F5SUdyWDVDSUloQ0FGSUVRQ0F6UVFGQmxCWkJBQkFJREFVTElBWWdCMndpQjBHQWdJQ0FCRThFUUNBelFRRkJsQlpCQUJBSURBVUxJQUVnQjBFQ2RCQVdJZ0UyQWpRZ0FRMEFJRE5CQVVHVUZrRUFFQWdNQkFzZ0NVRUJhaUlKSUJrb0FoZ2lIU2dDRUVrTkFBc0xJQmtvQWlBaEhTQVpLQUlVS0FJQUloY29BaEFFUUNBWEtBSVVJUWtnSFNnQzBDc2hIU0FaS0FJWUtBSVlJUTFCQUNFTEEwQUNRQ0FaS0FKRUlnRUVRQ0FCSUF0QkFuUnFLQUlBUlEwQkN5QU5LQUlrUVFGcUlRRWdIU2dDRkVFQlJnUkFJQUVoSGtFQUlRWkJBQ0VNL1F3QUFBQUFBQUFBQUFBQUFBQUFBQUFBSVlBQkl3QkJJR3NpSlNRQUFrQUNRQ0FaS0FKQUJFQkJBU0VISUFGQkFVWU5BaUFKS0FJY0lnd2dDU2dDR0VHWUFXeHFJZ0ZCa0FGcktBSUFJaEFnQVVHWUFXc29BZ0FpRTBZTkFpQU1LQUlFSVJFZ0RDZ0NEQ0VZSUF3b0FnQWhHaUFNS0FJSUlSc2dHU2dDTENJT0tBSUVJUllnSGtFQmF5SUtJUlVnRENFSEFrQWdDa0VFVHdSQUlBcEJBM0VoRlNBSElBcEJmSEVpQ0VHWUFXeHFJUWRCQUNFQkEwQWdnQUVnRENBQlFaZ0JiR29pQmtIb0JHb2dCa0hRQTJvZ0JrRzRBbW9nQnYwSkFxQUIvVllDQUFIOVZnSUFBdjFXQWdBRElBWkI0QVJxSUFaQnlBTnFJQVpCc0FKcUlBYjlDUUtZQWYxV0FnQUIvVllDQUFMOVZnSUFBLzJ4QWYyNUFTQUdRZXdFYWlBR1FkUURhaUFHUWJ3Q2FpQUcvUWtDcEFIOVZnSUFBZjFXQWdBQy9WWUNBQU1nQmtIa0JHb2dCa0hNQTJvZ0JrRzBBbW9nQnYwSkFwd0IvVllDQUFIOVZnSUFBdjFXQWdBRC9iRUIvYmtCSVlBQklBRkJCR29pQVNBSVJ3MEFDeUNBQVNDQUFTQ0FBZjBOQ0FrS0N3d05EZzhBQVFJREFBRUNBLzI1QVNLQUFTQ0FBU0NBQWYwTkJBVUdCd0FCQWdNQUFRSURBQUVDQS8yNUFmMGJBQ0VHSUFnZ0NrWU5BUXNEUUNBR0lBY29BcUFCSUFjb0FwZ0JheUlCSUFFZ0Jra2JJZ0VnQnlnQ3BBRWdCeWdDbkFGcklnWWdBU0FHU3hzaEJpQUhRWmdCYWlFSElCVkJBV3NpRlEwQUN3dEJBQ0VISUFaQi8vLy9QMHNOQWlBbElBWkJCWFFpRWhBc0lnODJBaEFnRDBVTkFpQWxJQTgyQWdBZ0NnUkFJQkFnRTJzaEVDQVlJQkZySVFnZ0d5QWFheUVCQTBBZ0NTZ0NKQ0VUSUNVZ0NDSVZOZ0lJSUNVZ0FTSUhOZ0lZSUF3b0Fwd0JJUVlnRENnQ3BBRWhDQ0FNS0FLZ0FTRUJJQ1VnRENnQ21BRWlFVUVDYnpZQ0hDQWxJQUVnRVdzaUFTQUhhellDRkFKQUlCWkJBa2dpR2tVZ0NDQUdheUlJUVFGTGNVVUVRRUVBSVFZZ0NFVU5BUU5BSUNWQkVHb2dFeUFHSUJCc1FRSjBhaEJXSUFaQkFXb2lCaUFJUncwQUN3d0JDeUFJSUJZZ0NDQVdTUnNpRVVFQmF5RWJJQWdnRVc0aEdFRUFJUWNEUUVFa0VBMGlCa1VOQlNBbC9RQUNFQ0dBQVNBR0lCTTJBaGdnQmlBUU5nSVVJQVlnQVRZQ0VDQUdJSUFCL1FzQ0FDQUdJQWNnR0d3MkFod2dCeUFiUmlFZklBWWdDQ0FIUVFGcUlnY2dHR3dnSHhzMkFpQWdCaUFTRUN3aUh6WUNBQ0FmUlFSQVFRQWhCeUFPRUJvZ0JoQUpJQThRQ1F3SEN5QU9RUW9nQmhBbUlBY2dFVWNOQUFzZ0RoQWFDeUFsSUFnZ0ZXczJBZ1FnSlNBTUtBS2NBVUVDYnpZQ0RBSkFJQnBGSUFGQkFVdHhSUVJBUVFnaEIwRUFJUVlnQVVFSVR3UkFBMEFnSlNBVElBWkJBblJxSUJCQkNCQXJJQWNpQmtFSWFpSUhJQUZORFFBTEN5QUJJQVpORFFFZ0pTQVRJQVpCQW5ScUlCQWdBU0FHYXhBckRBRUxJQUVnRmlBQklCWkpHeUlWUVFGcklSZ2dBU0FWYmlFUlFRQWhCd05BUVNRUURTSUdSUTBGSUNYOUFBSUFJWUFCSUFZZ0V6WUNHQ0FHSUJBMkFoUWdCaUFJTmdJUUlBWWdnQUg5Q3dJQUlBWWdCeUFSYkRZQ0hDQUhJQmhHSVJvZ0JpQUJJQWRCQVdvaUJ5QVJiQ0FhR3pZQ0lDQUdJQklRTENJYU5nSUFJQnBGQkVCQkFDRUhJQTRRR2lBR0VBa2dEeEFKREFjTElBNUJDeUFHRUNZZ0J5QVZSdzBBQ3lBT0VCb0xJQXhCbUFGcUlRd2dDa0VCYXlJS0RRQUxDMEVCSVFjZ0R4QUpEQUlMUVFFaEJ5QUpLQUljSWdnZ0hrR1lBV3hxSWpWQm1BRnJJbDhvQWdBZ05VR1FBV3NvQWdCR0RRRWdOVUdVQVdzaVlDZ0NBQ0ExUVl3QmF5Z0NBRVlOQVNBSUtBSUVJUTRnQ0NnQ0RDRVBJQWdvQWdBaEZpQUlLQUlJSVJBZ0NTZ0NSQ0VoSUFrb0FrQWhJaUFKS0FJOElTZ2dDU2dDT0NFd0lBa2dIaEJWSWpsRkJFQkJBQ0VIREFJTEFrQUNRQ0FlUVFGSEJFQUNRQUpBSUI1QkFXc2lDa0VFU1FSQUlBb2hBU0FJSVFjTUFRc2dDa0VEY1NFQklBZ2dDa0Y4Y1NJVlFaZ0JiR29oQndOQUlJQUJJQWdnREVHWUFXeHFJZ1pCNkFScUlBWkIwQU5xSUFaQnVBSnFJQWI5Q1FLZ0FmMVdBZ0FCL1ZZQ0FBTDlWZ0lBQXlBR1FlQUVhaUFHUWNnRGFpQUdRYkFDYWlBRy9Ra0NtQUg5VmdJQUFmMVdBZ0FDL1ZZQ0FBUDlzUUg5dVFFZ0JrSHNCR29nQmtIVUEyb2dCa0c4QW1vZ0J2MEpBcVFCL1ZZQ0FBSDlWZ0lBQXYxV0FnQURJQVpCNUFScUlBWkJ6QU5xSUFaQnRBSnFJQWI5Q1FLY0FmMVdBZ0FCL1ZZQ0FBTDlWZ0lBQS8yeEFmMjVBU0dBQVNBTVFRUnFJZ3dnRlVjTkFBc2dnQUVnZ0FFZ2dBSDlEUWdKQ2dzTURRNFBBQUVDQXdBQkFnUDl1UUVpZ0FFZ2dBRWdnQUg5RFFRRkJnY0FBUUlEQUFFQ0F3QUJBZ1A5dVFIOUd3QWhCaUFLSUJWR0RRRUxBMEFnQmlBSEtBS2dBU0FIS0FLWUFXc2lDaUFHSUFwTEd5SUdJQWNvQXFRQklBY29BcHdCYXlJS0lBWWdDa3NiSVFZZ0IwR1lBV29oQnlBQlFRRnJJZ0VOQUFzTElBWkJnSUNBZ0FGUERRSWdCa0VFZEJBc0loUkZEUUlDUUNBZVJRMEFJQThnRG1zaEVpQVFJQlpySVJvZ0ZFRUVheUU3SUJSQkJHb2hKQ0FVUVF4cUlTa2dGRUVjYWlGRElCUkJHR29oSHlBVVFSUnFJU0FnRkVFTWF5RkVJQlJCQ0dvaEtpQVVRUkJxSVRZZ0ZFRVFheUUzSUJSQkNHc2hRU0FoclNHR0FTQWlyU0dIQVNBb3JTR0tBU0F3clNHTEFVRUJJVVlEUUNBSUtBS2NBU0lCUVFKdklVY2dDQ2dDbUFFaUIwRUNieUU4SUFnb0FxUUJJQUZySWljZ0Vtc2hMQ0FJS0FLZ0FTQUhheUl0SUJwcklTNGdNQ0lNSVFjZ0tDSUdJUW9nSWlJQklUb2dJU0lQSVJFQ1FDQUpLQUlVSWhVZ1JrWU5BQ0FWSUVacklSVkJBQ0VLUVFBaEJ5QU1CRUJDZnlBVnJTS0lBWVpDZjRVZ2l3RjhJSWdCaUtjaEJ3c2dLQVJBUW44Z0ZhMGlpQUdHUW4rRklJb0JmQ0NJQVlpbklRb0xRUUFoRDBFQUlRRWdJZ1JBUW44Z0ZhMGlpQUdHUW4rRklJY0JmQ0NJQVlpbklRRUxJQ0VFUUVKL0lCV3RJb2dCaGtKL2hTQ0dBWHdnaUFHSXB5RVBDMEVBSVRwQkFDRU1RUUVnRlVFQmEzUWlEaUF3U1FSQUlEQWdEbXV0UW44Z0ZhMGlpQUdHUW4rRmZDQ0lBWWluSVF3TElBNGdJa2tFUUNBaUlBNXJyVUovSUJXdElvZ0Joa0ovaFh3Z2lBR0lweUU2QzBFQUlSRkJBQ0VHSUE0Z0tFa0VRQ0FvSUE1cnJVSi9JQld0SW9nQmhrSi9oWHdnaUFHSXB5RUdDeUFPSUNGUERRQWdJU0FPYTYxQ2Z5QVZyU0tJQVlaQ2Y0VjhJSWdCaUtjaEVRdEJmeUE2SUFnb0FyUUJJaFZySWc1QkFDQU9JRHBOR3lJT1FRSnFJaFlnRGlBV1N4c2lEaUF1SUE0Z0xra2JJalJCZnlBQklBZ29BdGdCSWhOcklnNUJBQ0FCSUE1UEd5SUJRUUpxSWc0Z0FTQU9TeHNpQVNBYUlBRWdHa2tiSWlZZ1BCdEJBWFFpQVNBbUlEUWdQQnRCQVhSQkFYSWlEaUFCSUE1TEd5SklJQzFKSVJnZ0RDQVZheUlCUVFBZ0FTQU1UUnNpQVVFQ2F5SU1RUUFnQVNBTVR4c2lFQ0FISUJOcklnRkJBQ0FCSUFkTkd5SUJRUUpySWd4QkFDQUJJQXhQR3lJV0lEd2JRUUYwSWd3Z0ZpQVFJRHdiUVFGMFFRRnlJaXRKSVM4Z0NpQUlLQUs0QVNJYmF5SVZRUUFnQ2lBVlR4c2lDa0VDYXlJVlFRQWdDaUFWVHhzaUZTRWpJQVlnQ0NnQzNBRWlDbXNpRGtFQUlBWWdEazhiSWdaQkFtc2lEa0VBSUFZZ0RrOGJJZzRoUFVGL0lBOGdHMnNpQmtFQUlBWWdEMDBiSWdaQkFtb2lEeUFHSUE5TEd5SUdJQklnQmlBU1NSc2lHeUUrUVg4Z0VTQUtheUlHUVFBZ0JpQVJUUnNpQmtFQ2FpSUtJQVlnQ2tzYklnWWdMQ0FHSUN4Skd5SWNJVDhnUndSQUlCVWhQU0FjSVQ0Z0d5RS9JQTRoSXdzZ1NDQXRJQmdiSVVrZ0RDQXJJQzhiSVJnZ0VpQWNhaUZRSUE0Z0Vtb2hVU0FuQkVBZ0ZDQVdRUU4wSWdacUlrVkJCR29nT3lBdVFRTjBJZ3BxSWxJZ0ZpQXVTQ0lNR3lGVElBWWdKR29pQmlBbUlDNGdKaUF1U0JzaUR5QUhJQk1nQnlBVFNSdEJBaUFCSUFGQkFrOGJhaUlCYWlJVElBZHJRUUpySWhGQkEzUWlLMm9nQmtrZ0tTQUhJQUZyUVFOMGFpSUJJQ3RxSUFGSmNpQVJRZi8vLy84QlMzSWhWQ0EwSUJwQkFXc2dHaUEwU2hzaEwwRUFJUkVnR2tFQlNpQXVRUUJLY2lGVklDUWdQRUVDZENJQmF5QVFRUU4wYWlGV0lBRWdSV29oVnlBV0lBZEJmM01nRTJvaVNrRjhjU0l5YWlFNElCWkJBV29pRXlBeWFpRkNJQm9nTkdvaFdDQVFJQnBxSVZrZ0Z2MFIvUXdBQUFBQUFRQUFBQUlBQUFBREFBQUEvYTRCSVlNQklCUWdHRUVDZEdvaFdpQkJJQnBCQTNRaUFXb2hTeUFCSUR0cUlVd2dDaUJCYWlGTklCcEZJQzVCQVVaeElWc2dGQ0JKUVFKMElnRnFJVndnQVNBN2FpRmRJQlA5RWYwTUFBQUFBQUVBQUFBQ0FBQUFBd0FBQVAydUFTR0VBU0E3SUJZZ0xpQU1HMEVEZEdvaFhnTkFBa0FDUUNBUklCdEpJQkVnRlU5eERRQWdFU0JRU1NBUklGRlBjUTBBSUJGQkFXb2hLd3dCQ3lBdElFaExCRUFnWFVFQU5nSUFJRnhCQURZQ0FBc2dPU0FXSUJFZ0ppQVJRUUZxSWlzZ1YwRUNRUUFRRnlBNUlGa2dFU0JZSUNzZ1ZrRUNRUUFRRndKQUFrQUNRQ0E4UlFSQUlGVkZEUU1nRmlBbVRnMENBa0FDUUNBV1FRQktCRUFnWGlnQ0FDRUhEQUVMSUNRb0FnQWlCeUVCSUJaQkFFZ05BUXNnQnlFQklGTW9BZ0FoQndzZ1JTQkZLQUlBSUFFZ0IycEJBbXBCQW5Wck5nSUFJQk1pQnlBUFRnMEJRUUFoQnlDRUFTR0FBU0NEQVNHQ0FTQVRJUUVnRmlFS0lFcEJGRWtnVkhKRkJFQURRQ0FVSUlBQlFRSDlxd0VpZ1FIOUd3QkJBblJxSWdFZ0ZDQ0JBZjBiQTBFQ2RHb2lCaUFVSUlFQi9Sc0NRUUowYWlJS0lCUWdnUUg5R3dGQkFuUnFJZ3dnQWYwSkFnRDlWZ0lBQWYxV0FnQUMvVllDQUFNZ0ZDQ0NBVUVCL2FzQi9Rd0JBQUFBQVFBQUFBRUFBQUFCQUFBQS9WQWloUUg5R3dOQkFuUnFJQlFnaFFIOUd3SkJBblJxSUJRZ2hRSDlHd0ZCQW5ScUlCUWdoUUg5R3dCQkFuUnEvUWtDQVAxV0FnQUIvVllDQUFMOVZnSUFBeUFVSUlFQi9Rd0JBQUFBQVFBQUFBRUFBQUFCQUFBQS9WQWlnUUg5R3dOQkFuUnFJQlFnZ1FIOUd3SkJBblJxSUJRZ2dRSDlHd0ZCQW5ScUlCUWdnUUg5R3dCQkFuUnEvUWtDQVAxV0FnQUIvVllDQUFMOVZnSUFBLzJ1QWYwTUFnQUFBQUlBQUFBQ0FBQUFBZ0FBQVAydUFVRUMvYXdCL2JFQklvRUIvVm9DQUFBZ0RDQ0JBZjFhQWdBQklBb2dnUUg5V2dJQUFpQUdJSUVCL1ZvQ0FBTWdnZ0g5REFRQUFBQUVBQUFBQkFBQUFBUUFBQUQ5cmdFaGdnRWdnQUg5REFRQUFBQUVBQUFBQkFBQUFBUUFBQUQ5cmdFaGdBRWdCMEVFYWlJSElESkhEUUFMSUVJaEFTQTRJUW9nRHlFSElESWdTa1lOQWdzRFFDQVVJQUZCQTNScUlnY2dCeWdDQUNBVUlBcEJBM1JxS0FJRUlBY29BZ1JxUVFKcVFRSjFhellDQUNBQklncEJBV29pQVNBUFJ3MEFDeUFQSVFjTUFRc0NRQ0JiUlFSQUlCWWlCeUFtVGcwQkEwQWdGQ0FIUVFOMGFpSUJLQUlFSVFZZ0FTQUdBbjhDUUNBSFFRQk9CRUFnQVNCTklBY2dMa2diS0FJQUlUb2dCMEVCYWlFQkRBRUxJQlFvQWdBaE9rRUFJUUVnRkNBSFFRRnFJZ2NOQVJvTElBRWdMazRFUUNBQklRY2dUUXdCQ3lBVUlBRWlCMEVEZEdvTEtBSUFJRHBxUVFKcVFRSjFhellDQkNBSElDWklEUUFMREFFTElCUWdGQ2dDQUVFQ2JUWUNBQXdEQ3lBUUlnY2dORTROQWdOQUlCUWdCMEVEZEdvaUFTZ0NBQ0VLQW44Z0IwRUFTQVJBSUNRb0FnQWhCaUFrREFFTElCUWdCMEVEZEdwQkJHb2dUQ0FISUJwSUd5Z0NBQ0VHSUNRZ0IwVU5BQm9nVENBQlFRUnJJQWNnR2tvYkN5RU1JQUVnRENnQ0FDQUdha0VCZFNBS2FqWUNBQ0FIUVFGcUlnY2dORWNOQUFzTUFnc2dCeUFtVGcwQUEwQWdGQ0FIUVFOMGFpSUJJQUVvQWdBQ2Z3SkFJQWRCQUVvRVFDQTdJQWNnTGlBSElDNUlHMEVEZEdvb0FnQWhDZ3dCQ3lBa0tBSUFJUW9nSkNBSFFRQklEUUVhQ3lCU0lBY2dMazROQUJvZ0ZDQUhRUU4wYWtFRWFnc29BZ0FnQ21wQkFtcEJBblZyTmdJQUlBZEJBV29pQnlBbVJ3MEFDd3NnRUNBMFRnMEFJQzhnRUNJQklnZEtCRUFEUUNBVUlBZEJBM1JxSWdFZ0FTZ0NCQ0FVSUFkQkFXb2lCMEVEZEdvb0FnQWdBU2dDQUdwQkFYVnFOZ0lFSUFjZ0wwY05BQXNnTHlFQkN5QUJJRFJPRFFBRFFBSi9Ba0FnQVNJSFFRQk9CRUFnRkNBQlFRTjBhaUJMSUFFZ0drZ2JLQUlBSVF3Z0FVRUJhaUVLREFFTElCUW9BZ0FoREVFQUlRb2dGQ0FIUVFGcUlnRU5BUm9MSUFvZ0drNEVRQ0FLSVFFZ1N3d0JDeUFVSUFvaUFVRURkR29MSVFZZ0ZDQUhRUU4wYWlJSElBY29BZ1FnQmlnQ0FDQU1ha0VCZFdvMkFnUWdBU0EwU0EwQUN3c2dPU0FZSUJFZ1NTQXJJRnBCQVVFQVFRQVFIMFVOQmdzZ0t5SVJJQ2RIRFFBTEN5QUlRWmdCYWlFSUlENUJBWFFpQVNBL1FRRjBRUUZ5SWdjZ0FTQUhTeHNpQVNBbklBRWdKMGtiSVVnZ1F5QVZRUVYwSWdGcUlEc2dMRUVGZENJSGFpQVZJQ3hJSWdZYklVb2dBU0FmYWlBSElFRnFJQVliSVVzZ0FTQWdhaUFISUVScUlBWWJJVXdnQVNBMmFpQUhJRGRxSUFZYklVMGdIQ0FTUVFGcklCSWdIRW9iSVF3Z0xFRUFTaUlQSUJKQkFVcHlJVklnQVNBVWFpSXJJRWRCQkhScUlWTWdLU0FTUVFOMElocEJDR3NpUGtFQUlCSkJBRXdiUVFKMElncHFJVlFnQ2lBcWFpRlZJQW9nSkdvaFZpQUtJQlJxSVZjZ0tVRUFJQ3hCQTNRaUNrRUlheUkvSUE4YlFRSjBJZzlxSVZnZ0R5QXFhaUZaSUE4Z0pHb2hXaUFQSUJScUlWc2dGRUVFSUVkQkFuUnJRUUowYWlBT1FRVjBhaUZjSUJzZ0xDQWJJQ3hJR3lFUElCVkJBV29oRUNBVUlDTkJBWFFpRmlBOVFRRjBRUUZ5SWhNZ0V5QVdTeHNpWFVFRWRHb2hYaUFCSUNscUlUMGdBU0FxYWlFaklBRWdKR29oTHlBYVFRRnJJVGdnR2tFQ2F5RkNJQnBCQTJzaExpQVVJQkpCQlhScUlXRWdHa0VFYXlFMElBcEJCV3NoWWlBS1FRWnJJV01nQ2tFSGF5RmtJQkpGSUN4QkFVWnhJV1VnS1NBSFFSQnJJZ0ZxSVNZZ0FTQXFhaUU2SUFFZ0pHb2hQQ0FCSUJScUlVVWdLU0ErUVFKMElnRnFJV2dnQVNBcWFpRnBJQUVnSkdvaGFpQUJJQlJxSVdzZ095QVZJQ3dnQmh0QkJYUWlBV29oYkNBQklFRnFJUk1nQVNCRWFpRVJJQUVnTjJvaGJTQXBJRDlCQW5RaUFXb2hiaUFCSUNwcUlXOGdBU0FrYWlGd0lBRWdGR29oY1FOQUFrQUNRQUovQWtBZ0dDSVdJRWxKQkVBZ09TQVdJQlZCQkNCSklCWnJJZ0VnQVVFRVR4c2dGbW9pR0NBYklGTkJBVUVJRUJjZ09TQVdJRkVnR0NCUUlGeEJBVUVJRUJjZ1IwVUVRQ0JTUlEwRklCVWdHMDROQkFKL0lCVkJBRW9FUUNCdEtBSUFJUWNnRXlFR0lCRWhDaUJzREFFTElEWW9BZ0FoQnlBVlFRQklEUU1nSHlFR0lDQWhDaUJEQ3lGNUlDc2dLeWdDQUNBSElFMG9BZ0JxUVFKcVFRSjFhellDQUNBdklDOG9BZ0FnQ2lnQ0FDQk1LQUlBYWtFQ2FrRUNkV3MyQWdBZ0l5QWpLQUlBSUFZb0FnQWdTeWdDQUdwQkFtcEJBblZyTmdJQUlFb29BZ0FoQnlCNUtBSUFEQU1MSUdVRVFDQVVJQlFvQWdCQkFtMDJBZ0FnSkNBa0tBSUFRUUp0TmdJQUlDb2dLaWdDQUVFQ2JUWUNBQ0FwSUNrb0FnQkJBbTAyQWdBTUJRc2dHeUFWSWdkS0JFQURRQ0FIUVFOMElRRUNmd0pBSUFkQkFFZ0VRQ0FIUVg5R0RRRWdGQ0FCUVFKMGFpSUJJQUVvQWhBZ0ZDZ0NBRUVCZEVFQ2FrRUNkV3MyQWhBZ0FTQUJLQUlVSUNRb0FnQkJBWFJCQW1wQkFuVnJOZ0lVSUFFZ0FTZ0NHQ0FxS0FJQVFRRjBRUUpxUVFKMWF6WUNHQ0FwS0FJQVFRRjBRUUpxSVFZZ0FVRWNhZ3dDQ3lBc0lBZEJBV29pQmt3RVFDQVVJQUZCQW5ScUlnb2dDaWdDRUNBVUlBRWdQeUFISUN4SUlnWWJRUUowYWlnQ0FDQnhLQUlBYWtFQ2FrRUNkV3MyQWhBZ0NpQUtLQUlVSUJRZ0FVRUJjaUJrSUFZYlFRSjBhaWdDQUNCd0tBSUFha0VDYWtFQ2RXczJBaFFnQ2lBS0tBSVlJQlFnQVVFQ2NpQmpJQVliUVFKMGFpZ0NBQ0J2S0FJQWFrRUNha0VDZFdzMkFoZ2dGQ0FCUVFOeUlHSWdCaHRCQW5ScUtBSUFJRzRvQWdCcVFRSnFJUVlnQ2tFY2Fnd0NDeUFVSUFGQkFuUnFJZ0VnQVNnQ0VDQUJLQUlBSUJRZ0JrRUZkR29pQmlnQ0FHcEJBbXBCQW5Wck5nSVFJQUVnQVNnQ0ZDQUJLQUlFSUFZb0FnUnFRUUpxUVFKMWF6WUNGQ0FCSUFFb0FoZ2dBU2dDQ0NBR0tBSUlha0VDYWtFQ2RXczJBaGdnQVNnQ0RDQUdLQUlNYWtFQ2FpRUdJQUZCSEdvTUFRc2dOeUEzS0FJQUlCUW9BZ0FnV3lnQ0FHcEJBbXBCQW5Wck5nSUFJRVFnUkNnQ0FDQWtLQUlBSUZvb0FnQnFRUUpxUVFKMWF6WUNBQ0JCSUVFb0FnQWdLaWdDQUNCWktBSUFha0VDYWtFQ2RXczJBZ0FnS1NnQ0FDQllLQUlBYWtFQ2FpRUdJRHNMSWdFZ0FTZ0NBQ0FHUVFKMWF6WUNBQ0FIUVFGcUlnY2dHMGNOQUFzTElCd2dEaUlIVEEwRUEwQWdCMEVEZENFQkFuOGdCMEVBU0FSQUlCUWdBVUVDZEdvaUFTQUJLQUlBSURZb0FnQkJBWFJCQVhWcU5nSUFJQUVnQVNnQ0JDQVVLQUlVUVFGMFFRRjFhallDQkNBQklBRW9BZ2dnRkNnQ0dFRUJkRUVCZFdvMkFnZ2dGQ2dDSEVFQmRDRUtJQUZCREdvTUFRc2dCd1JBSUJRZ0FVRUNkR29pQmlBR0tBSUFJR0VnQmlBSElCSktJakliUVJCcktBSUFJQlFnQVVFRWNpQTBJQWNnRWtnaUNodEJBblJxS0FJQWFrRUJkV28yQWdBZ0JpQUdLQUlFSUVRZ0dpQUJJREliUVFKMElqSnFLQUlBSUJRZ0FVRUZjaUF1SUFvYlFRSjBhaWdDQUdwQkFYVnFOZ0lFSUFZZ0JpZ0NDQ0F5SUVGcUtBSUFJQlFnQVVFR2NpQkNJQW9iUVFKMGFpZ0NBR3BCQVhWcU5nSUlJRElnTzJvb0FnQWdGQ0FCUVFkeUlEZ2dDaHRCQW5ScUtBSUFhaUVLSUFaQkRHb01BUXNnRkNBVUtBSUFJRFlvQWdBZ0ZFRUVJRFFnQnlBU1NDSUJHMEVDZEdvb0FnQnFRUUYxYWpZQ0FDQWtJQ1FvQWdBZ0ZDZ0NGQ0FVUVFVZ0xpQUJHMEVDZEdvb0FnQnFRUUYxYWpZQ0FDQXFJQ29vQWdBZ0ZDZ0NHQ0FVUVFZZ1FpQUJHMEVDZEdvb0FnQnFRUUYxYWpZQ0FDQVVLQUljSUJSQkJ5QTRJQUViUVFKMGFpZ0NBR29oQ2lBcEN5SUJJQUVvQWdBZ0NrRUJkV28yQWdBZ0IwRUJhaUlISUJ4SERRQUxEQVFMSUMwaEdpQW5JUklnUmtFQmFpSkdJQjVIRFFVTUJnc2dLeUFyS0FJQUlBZEJBWFJCQW1wQkFuVnJOZ0lBSUM4Z0x5Z0NBQ0FnS0FJQVFRRjBRUUpxUVFKMWF6WUNBQ0FqSUNNb0FnQWdIeWdDQUVFQmRFRUNha0VDZFdzMkFnQWdReWdDQUNJSEN5RUJJRDBnUFNnQ0FDQUJJQWRxUVFKcVFRSjFhellDQUNBVklRWWdFQ0lCSWdjZ0QwZ0VRQU5BSUJRZ0FVRUZkR29pQnlBSC9RQUNBQ0EySUFaQkJYUnEvUUFDQUNBSC9RQUNFUDJ1QWYwTUFnQUFBQUlBQUFBQ0FBQUFBZ0FBQVAydUFVRUMvYXdCL2JFQi9Rc0NBQ0FCSWdaQkFXb2lBU0FQUncwQUN5QVBJUWNMSUFjZ0cwNE5BQU5BSUFkQkEzUWhBU0FISUN4SUlRWUNRQ0FIUVFCTUJFQWdOaWdDQUNFS0lBZEJBRTRFUUNBVUlBRkJBblFpQVdvaU1pQXlLQUlBSUFvZ0FTQTJhaUJGSUFZYktBSUFha0VDYWtFQ2RXczJBZ0FnQVNBa2FpSUtJQW9vQWdBZ0lDZ0NBQ0FCSUNCcUlEd2dCaHNvQWdCcVFRSnFRUUoxYXpZQ0FDQUJJQ3BxSWdvZ0NpZ0NBQ0FmS0FJQUlBRWdIMm9nT2lBR0d5Z0NBR3BCQW1wQkFuVnJOZ0lBSUVNb0FnQWdBU0JEYWlBbUlBWWJLQUlBYWtFQ2FpRUdJQUVnS1dvaEFRd0NDeUFVSUFGQkFuUWlBV29pQmlBR0tBSUFJQXBCQVhSQkFtcEJBblZyTmdJQUlBRWdKR29pQmlBR0tBSUFJQlFvQWhSQkFYUkJBbXBCQW5Wck5nSUFJQUVnS21vaUJpQUdLQUlBSUJRb0FoaEJBWFJCQW1wQkFuVnJOZ0lBSUFFZ0tXb2hBU0FVS0FJY1FRRjBRUUpxSVFZTUFRc2dGQ0FISUN3Z0JodEJBM1JCQkd0QkFuUWlDbW9vQWdBaE1pQUdSUVJBSUJRZ0FVRUNkQ0lCYWlJR0lBWW9BZ0FnTWlCRktBSUFha0VDYWtFQ2RXczJBZ0FnQVNBa2FpSUdJQVlvQWdBZ0NpQWthaWdDQUNBOEtBSUFha0VDYWtFQ2RXczJBZ0FnQVNBcWFpSUdJQVlvQWdBZ0NpQXFhaWdDQUNBNktBSUFha0VDYWtFQ2RXczJBZ0FnQVNBcGFpRUJJQW9nS1dvb0FnQWdKaWdDQUdwQkFtb2hCZ3dCQ3lBVUlBRkJBblFpQVdvaUJpQUdLQUlBSURJZ0JpZ0NFR3BCQW1wQkFuVnJOZ0lBSUFFZ0pHb2lCaUFHS0FJQUlBb2dKR29vQWdBZ0JpZ0NFR3BCQW1wQkFuVnJOZ0lBSUFFZ0ttb2lCaUFHS0FJQUlBb2dLbW9vQWdBZ0JpZ0NFR3BCQW1wQkFuVnJOZ0lBSUFvZ0tXb29BZ0FnQVNBcGFpSUJLQUlRYWtFQ2FpRUdDeUFCSUFFb0FnQWdCa0VDZFdzMkFnQWdCMEVCYWlJSElCdEhEUUFMQ3lBT0lCeE9EUUFnRENBT0lnRWlCMG9FUUFOQUlCUWdBVUVGZEdvaUJ5QUgvUUFDSUNBSC9RQUNBUDJ1QVVFQi9hd0JJQWY5QUFJUS9hNEIvUXNDRUNBQlFRRnFJZ0VnREVjTkFBc2dEQ0VIQ3lBSElCeE9EUUFEUUNCRElBZEJBM1FpQVVFQ2RHb2lNZ0ovSUFkQkFFZ0VRQ0FVS0FJQUlRWWdCMEYvUndSQUlEWWdBVUVDZENJQmFpSUtJQW9vQWdBZ0JtbzJBZ0FnQVNBZ2FpSUdJQVlvQWdBZ0pDZ0NBR28yQWdBZ0FTQWZhaUlCSUFFb0FnQWdLaWdDQUdvMkFnQWdLU2dDQUF3Q0N5QTJJQUZCQW5RaUFXb2lDaUFLS0FJQUlGY29BZ0FnQm1wQkFYVnFOZ0lBSUFFZ0lHb2lCaUFHS0FJQUlGWW9BZ0FnSkNnQ0FHcEJBWFZxTmdJQUlBRWdIMm9pQVNBQktBSUFJRlVvQWdBZ0tpZ0NBR3BCQVhWcU5nSUFJRlFvQWdBZ0tTZ0NBR3BCQVhVTUFRc2dBU0ErSUFjZ0VrZ2JJUVlnRWlBSFFRRnFJbVpNQkVBZ05pQUJRUUowSWdwcUlnRWdBU2dDQUNCcktBSUFJQlFnQmtFQ2RHb2lBU2dDQUdwQkFYVnFOZ0lBSUFvZ0lHb2lCaUFHS0FJQUlHb29BZ0FnQVNnQ0JHcEJBWFZxTmdJQUlBb2dIMm9pQmlBR0tBSUFJR2tvQWdBZ0FTZ0NDR3BCQVhWcU5nSUFJR2dvQWdBZ0FTZ0NER3BCQVhVTUFRc2dOaUFCUVFKMElncHFJZ0VnQVNnQ0FDQVVJR1pCQlhScUlnRW9BZ0FnRkNBR1FRSjBhaUlHS0FJQWFrRUJkV28yQWdBZ0NpQWdhaUptSUdZb0FnQWdBU2dDQkNBR0tBSUVha0VCZFdvMkFnQWdDaUFmYWlJS0lBb29BZ0FnQVNnQ0NDQUdLQUlJYWtFQmRXbzJBZ0FnQVNnQ0RDQUdLQUlNYWtFQmRRc2dNaWdDQUdvMkFnQWdCMEVCYWlJSElCeEhEUUFMQ3lBNUlCWWdYU0FZSUVnZ1hrRUJRUVJCQUJBZkRRQUxDd3dDQ3lBVUVBbEJBU0VIQ3lBNUlEVkJFR3NvQWdBaUFTQmZLQUlBSWdacklEVkJER3NvQWdBZ1lDZ0NBQ0lLYXlBMVFRaHJLQUlBSWdnZ0Jtc2dOVUVFYXlnQ0FDQUtheUFKS0FJMFFRRWdDQ0FCYXhBWElEa1FIUXdEQ3lBNUVCMGdGQkFKUVFBaEJ3d0NDeUE1RUIxQkFDRUhEQUVMUVFBaEJ5QU9FQm9nRHhBSkN5QWxRU0JxSkFBZ0J3MEJEQVVMSUFFaENFRUFJUTc5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUFoZ0FFakFFRkFhaUljSkFBQ1FBSi9Ba0FnR1NnQ1FBUkFJQWtvQWh3aUZTQUpLQUlZUVpnQmJHb2lBVUdZQVdzb0FnQWhHaUFCUVpBQmF5Z0NBQ0ViSUJVb0FnUWhEQ0FWS0FJTUlYb2dGU2dDQUNFUUlCVW9BZ2doRTBFQklRY2dHU2dDTENJZktBSUVJU3NnQ0VFQlJnMERRUUFoQmlBSVFRRnJJaFloQ0NBVklRRUNRQ0FXUVFSUEJFQWdGa0VEY1NFSUlBRWdGa0Y4Y1NJS1FaZ0JiR29oQVVFQUlRY0RRQ0NBQVNBVklBZEJtQUZzYWlJR1FlZ0VhaUFHUWRBRGFpQUdRYmdDYWlBRy9Ra0NvQUg5VmdJQUFmMVdBZ0FDL1ZZQ0FBTWdCa0hnQkdvZ0JrSElBMm9nQmtHd0Ftb2dCdjBKQXBnQi9WWUNBQUg5VmdJQUF2MVdBZ0FEL2JFQi9ia0JJQVpCN0FScUlBWkIxQU5xSUFaQnZBSnFJQWI5Q1FLa0FmMVdBZ0FCL1ZZQ0FBTDlWZ0lBQXlBR1FlUUVhaUFHUWN3RGFpQUdRYlFDYWlBRy9Ra0NuQUg5VmdJQUFmMVdBZ0FDL1ZZQ0FBUDlzUUg5dVFFaGdBRWdCMEVFYWlJSElBcEhEUUFMSUlBQklJQUJJSUFCL1EwSUNRb0xEQTBPRHdBQkFnTUFBUUlEL2JrQklvQUJJSUFCSUlBQi9RMEVCUVlIQUFFQ0F3QUJBZ01BQVFJRC9ia0IvUnNBSVFZZ0NpQVdSZzBCQ3dOQUlBWWdBU2dDb0FFZ0FTZ0NtQUZySWdjZ0JpQUhTeHNpQnlBQktBS2tBU0FCS0FLY0FXc2lCaUFHSUFkSkd5RUdJQUZCbUFGcUlRRWdDRUVCYXlJSURRQUxDMEVBSVFjZ0JrSC8vLzgvU3cwRElCd2dCa0VGZENKR0VCWWlBVFlDSUNBQlJRMERJQndnQVRZQ0FDQVdSUVJBUVFFaEJ5QUJFQWtNQkFzZ2VpQU1heUVQSUJNZ0VHc2hEa0VDSUN0QkFYWWlBU0FCUVFKTkd5RkhJQWtvQWlRaUNpQWJRUnhzSWswZ0drRWNiQ0pmYTJvaEx5QUtJQnRCR0d3aVlDQWFRUmhzSWxKcmFpRTlJQW9nRzBFVWJDSlRJQnBCRkd3aVZHdHFJVDRnQ2lBYlFRUjBJbFVnR2tFRWRDSldhMm9oUHlBS0lCdEJER3dpVnlBYVFReHNJbGhyYWlFNElCc2dHbXNpRUVFSGJDRkpJQkJCQm13aFJTQVFRUVZzSVRJZ0VFRURiQ0ZJSUJCQkFYUWhVQ0FLSUJCQkEzUWlVV29oUWlBS0lCQkJBblFpUVdvaEZDQVFRUVYwSVZrZ0VQMFJJWVFCQTBBZ0hDQVBOZ0lJSUJ3Z0RpSUJOZ0lvSUJVb0Fwd0JJU1FnRlNnQ3BBRWhLU0FWS0FLZ0FTRWVJQlVvQXBnQklTQWdIRUVBTmdJNElCd2dBVFlDTkNBY1FRQTJBakFnSENBZ1FRSnZJaGcyQWl3Z0hDQWVJQ0JySWc0Z0FXc2lFellDUENBY0lCTTJBaVFDUUNBclFRSklJbHBGSUNrZ0pHc2lEMEVQUzNGRkJFQkJBQ0VISUFvaEJpQVBRUWhKRFFFZ1B5QUdJRk1nSGtFQ2RDSUJhaUJVSUNCQkFuUWlDR3ByYWlJNlNTQStJQVlnQVNCVmFpQUlJRlpxYTJvaVEwbHhJRDBnUTBrZ1B5QUdJQUVnWUdvZ0NDQlNhbXRxSWp4SmNYSWdMeUJEU1NBL0lBWWdBU0JOYWlBSUlGOXFhMm9pUkVseGNpRmJJRDBnUkVrZ0x5QThTWEVoWENBK0lFUkpJQzhnT2tseElWMGdQQ0ErU3lBNklEMUxjU0ZlSUVJZ0JpQUJJRmRxSUFnZ1dHcHJhaUpLU1NBNElBWWdBU0JSYWlBSWEyb2lTMGx4SVdFZ0ZDQktTU0E0SUFZZ0d5QWVhaUFhSUNCcWEwRUNkR29pVEVseElXSWdGQ0JMU1NCQ0lFeEpjU0ZqSUFZZ0FTQUlhMm9oS2lBT1FYeHhJUWdnSENnQ0lDSVRJQTVCQlhScUloRkJFR3NoSlNBUlFSUnJJU3dnRVVFWWF5RXVJQkZCSEdzaE5pQVJRUVJySVRrZ0VVRUlheUU3SUJGQkRHc2hORUVBSVJnZ0UwRU1haUlqSUI0Z0lFRi9jMm9pREVFRmRDSUJhaUFqU1NBTVFmLy8vejlMSWd3Z0UwRUVhaUloSUFGcUlDRkpJQUVnRTJvZ0UwbHljaUFUUVFocUlpSWdBV29nSWtseWNpQU9RY2dDU1hJaFpDQVRRUlJxSWlnZ0FXb2dLRWtnRTBFUWFpSW5JQUZxSUNkSmNpQU1jaUFUUVJocUlqQWdBV29nTUVseUlCTkJIR29pTFNBQmFpQXRTWElnRGtIVUFFbHlJV1VEUUNBSElRd2dIRUVnYWlJQklBWWdFRUVJRURRZ0FSQWNBa0FnRGtVTkFDQVlJRmxzSVFkQkFDRUJBa0FDUUNCa0RRQWdZU0FHSURaSklCTWdCeUFxYWlJM1NYRWdCaUFISUVwcUloSkpJQ29nT0V0eElCUWdLa2tnQmlBSElFeHFJaVpKY1NBR0lBY2dTMm9pTlVrZ0tpQkNTM0Z5Y25JZ0JpQXVTU0FoSURkSmNYSWdCaUFzU1NBaUlEZEpjWElnQmlBbFNTQWpJRGRKY1hJZ1kzSWdZbklnRXlBbVNTQUhJQlJxSWpjZ05rbHhjaUFoSUNaSklDNGdOMHR4Y2lBaUlDWkpJQ3dnTjB0eGNpQWpJQ1pKSUNVZ04wdHhjbklOQUNBVElEVkpJQWNnUW1vaUppQTJTWEVOQUNBaElEVkpJQ1lnTGtseERRQWdJaUExU1NBbUlDeEpjUTBBSUNNZ05Va2dKU0FtUzNFTkFDQUhJRGhxSWlZZ05ra2dFaUFUUzNFTkFDQW1JQzVKSUJJZ0lVdHhEUUFnSmlBc1NTQVNJQ0pMY1EwQUlCSWdJMHNnSlNBbVMzRU5BQU5BSUFZZ0FVRUNkR29nRXlBQlFRVjBhaUlTL1FrQ0FDQVNLZ0lnL1NBQklCSkJRR3NxQWdEOUlBSWdFaW9DWVAwZ0EvMExBZ0FnQmlBQklCQnFRUUowYWlBUy9Ra0NCQ0FTS2dJay9TQUJJQklxQWtUOUlBSWdFaW9DWlAwZ0EvMExBZ0FnQmlBQklGQnFRUUowYWlBUy9Ra0NDQ0FTS2dJby9TQUJJQklxQWtqOUlBSWdFaW9DYVAwZ0EvMExBZ0FnQmlBQklFaHFRUUowYWlBUy9Ra0NEQ0FTS2dJcy9TQUJJQklxQWt6OUlBSWdFaW9DYlAwZ0EvMExBZ0FnQVVFRWFpSUJJQWhIRFFBTElBZ2lBU0FPUmcwQkN3TkFJQVlnQVVFQ2RHb2dFeUFCUVFWMGFpSVNLZ0lBT0FJQUlBWWdBU0FRYWtFQ2RHb2dFaW9DQkRnQ0FDQUdJQUVnVUdwQkFuUnFJQklxQWdnNEFnQWdCaUFCSUVocVFRSjBhaUFTS2dJTU9BSUFJQUZCQVdvaUFTQU9SdzBBQ3d0QkFDRUJBa0FnWlEwQUlGd2dCeUErYWlJU0lEUkpJQ2NnQnlBNmFpSW1TWEVnV3lBSElEOXFJalVnTkVrZ0p5QUhJRU5xSWpkSmNYSWdLQ0EzU1NBMUlEdEpjWElnTUNBM1NTQTFJRGxKY1hJZ0xTQTNTU0FSSURWTGNYSWdYbklnWFhKeUlCSWdPMGtnSmlBb1MzRnlJQklnT1VrZ0ppQXdTM0Z5SUNZZ0xVc2dFU0FTUzNGeWNnMEFJQWNnUFdvaUVpQTBTU0FuSUFjZ1BHb2lKa2x4RFFBZ0VpQTdTU0FtSUNoTGNRMEFJQklnT1VrZ0ppQXdTM0VOQUNBbUlDMUxJQkVnRWt0eERRQWdCeUF2YWlJU0lEUkpJQ2NnQnlCRWFpSUhTWEVOQUNBU0lEdEpJQWNnS0V0eERRQWdFaUE1U1NBSElEQkxjUTBBSUFjZ0xVc2dFU0FTUzNFTkFBTkFJQVlnQVNCQmFrRUNkR29nRXlBQlFRVjBhaUlIL1FrQ0VDQUhLZ0l3L1NBQklBY3FBbEQ5SUFJZ0J5b0NjUDBnQS8wTEFnQWdCaUFCSURKcVFRSjBhaUFIL1FrQ0ZDQUhLZ0kwL1NBQklBY3FBbFQ5SUFJZ0J5b0NkUDBnQS8wTEFnQWdCaUFCSUVWcVFRSjBhaUFIL1FrQ0dDQUhLZ0k0L1NBQklBY3FBbGo5SUFJZ0J5b0NlUDBnQS8wTEFnQWdCaUFCSUVscVFRSjBhaUFIL1FrQ0hDQUhLZ0k4L1NBQklBY3FBbHo5SUFJZ0J5b0NmUDBnQS8wTEFnQWdBVUVFYWlJQklBaEhEUUFMSUFnaUFTQU9SZzBCQ3dOQUlBWWdBU0JCYWtFQ2RHb2dFeUFCUVFWMGFpSUhLZ0lRT0FJQUlBWWdBU0F5YWtFQ2RHb2dCeW9DRkRnQ0FDQUdJQUVnUldwQkFuUnFJQWNxQWhnNEFnQWdCaUFCSUVscVFRSjBhaUFIS2dJY09BSUFJQUZCQVdvaUFTQU9SdzBBQ3dzZ0dFRUJhaUVZSUF4QkNHb2hCeUFHSUZGQkFuUnFJUVlnREVFUGFpQVBTUTBBQ3d3QkN5QVBJQTlCQTNZaUJ5QXJJQWNnSzBrYkloSnVRWGh4SVJFZ0QwRjRjU0VIUVFBaENDQUtJUVlEUUVFd0VBMGlERVVOQkNBTUlFWVFGaUlqTmdJQUlDTkZCRUFnSHhBYUlBd1FDVUVBREFZTElBd2dCallDS0NBTUlCQTJBaVFnRENBT05nSWdJQXdnRXpZQ0hDQU1RUUEyQWhnZ0RDQUJOZ0lVSUF4QkFEWUNFQ0FNSUJnMkFnd2dEQ0FCTmdJSUlBd2dFellDQkNBTUlBY2dDQ0FSYkdzZ0VTQUlRUUZxSWdnZ0VrWWJJaU0yQWl3Z0gwRU1JQXdRSmlBR0lCQWdJMnhCQW5ScUlRWWdDQ0FTUncwQUN5QWZFQm9MQWtBZ0J5QVBUdzBBSUJ4QklHb2lBU0FHSUJBZ0R5QUhheUlZRURRZ0FSQWNJQTVGRFFBZ0hDZ0NJQ0lqSUI1QkJYUkJBU0FZSUJoQkFVMGJJaEpCQW5ScUlDQkJCWFJyYWtFZ2F5RWVJQkpCQTNFaElDQVNRWHh4SVF3Z1FTQVNRUUZyYkNFaFFRQWhDQU5BSUNNZ0NFRUZkR29oRTBFQUlRY0NRQUpBSUJoQkJFa05BQ0FlSUFZZ0NFRUNkQ0lSYWlJQklBWWdFU0FoYW1vaUVTQUJJQkZKRzBzRVFDQWpJQUVnRVNBQklCRkxHMEVFYWtrTkFRc2dDUDBSSVlFQi9Rd0FBQUFBQVFBQUFBSUFBQUFEQUFBQUlZQUJRUUFoQVFOQUlBWWdnQUVnaEFIOXRRRWdnUUg5cmdFaWdnSDlHd0JCQW5ScUlCTWdBVUVDZEdyOUFBSUFJb01CL1I4QU9BSUFJQVlnZ2dIOUd3RkJBblJxSUlNQi9SOEJPQUlBSUFZZ2dnSDlHd0pCQW5ScUlJTUIvUjhDT0FJQUlBWWdnZ0g5R3dOQkFuUnFJSU1CL1I4RE9BSUFJSUFCL1F3RUFBQUFCQUFBQUFRQUFBQUVBQUFBL2E0QklZQUJJQUZCQkdvaUFTQU1SdzBBQ3lBTUlnY2dFa1lOQVF0QkFDRVJJQWNoQVNBZ0JFQURRQ0FHSUFFZ0VHd2dDR3BCQW5ScUlCTWdBVUVDZEdvcUFnQTRBZ0FnQVVFQmFpRUJJQkZCQVdvaUVTQWdSdzBBQ3dzZ0J5QVNhMEY4U3cwQUEwQWdCaUFCSUJCc0lBaHFRUUowYWlBVElBRkJBblJxS2dJQU9BSUFJQVlnQVVFQmFpSUhJQkJzSUFocVFRSjBhaUFUSUFkQkFuUnFLZ0lBT0FJQUlBWWdBVUVDYWlJSElCQnNJQWhxUVFKMGFpQVRJQWRCQW5ScUtnSUFPQUlBSUFZZ0FVRURhaUlISUJCc0lBaHFRUUowYWlBVElBZEJBblJxS2dJQU9BSUFJQmdnQVVFRWFpSUJSdzBBQ3dzZ0NFRUJhaUlJSUE1SERRQUxDeUFjSUE4Z0hDZ0NDQ0lNYXlJVE5nSUVJQlVvQXB3QklRRWdIRUVBTmdJUUlCd2dERFlDRkNBY1FRQTJBaGdnSENBVE5nSWNJQndnQVVFQ2J5SVlOZ0lNQWtBZ1drVWdEa0VQUzNGRkJFQWdDaUVCSUE1QkNFa05BU0FQUVg1eElTRWdEMEVCY1NFaUlCTkJmbkVoS0NBVFFRRnhJU2NnREVGK2NTRXdJQXhCQVhFaExTQXBJQ1JCZjNOcUlTTWdIQ2dDQUNJU0lCaEJCWFFpQjJvaElDQVNJQWRyUVNCcUlSNGdEQ0FRYkVFQ2RDRXFJQTRoQ0FOQVFRQWhCa0VBSVFjQ1FBSkFBa0FnREE0Q0FnRUFDd05BSUNBZ0JrRUdkR29pRVNBQklBWWdFR3hCQW5ScUlpWDlBQUlBL1FzQ0FDQVJJQ1g5QUFJUS9Rc0NFQ0FnSUFaQkFYSWlFVUVHZEdvaUpTQUJJQkFnRVd4QkFuUnFJaEg5QUFJUS9Rc0NFQ0FsSUJIOUFBSUEvUXNDQUNBR1FRSnFJUVlnQjBFQ2FpSUhJREJIRFFBTEN5QXRSUTBBSUNBZ0JrRUdkR29pQnlBQklBWWdFR3hCQW5ScUlnYjlBQUlBL1FzQ0FDQUhJQWI5QUFJUS9Rc0NFQXNDUUNBTUlBOUdEUUFnQVNBcWFpRUhRUUFoQmtFQUlSRWdEQ0FqUndSQUEwQWdIaUFHUVFaMGFpSWxJQWNnQmlBUWJFRUNkR29pTFAwQUFnRDlDd0lBSUNVZ0xQMEFBaEQ5Q3dJUUlCNGdCa0VCY2lJbFFRWjBhaUlzSUFjZ0VDQWxiRUVDZEdvaUpmMEFBaEQ5Q3dJUUlDd2dKZjBBQWdEOUN3SUFJQVpCQW1vaEJpQVJRUUpxSWhFZ0tFY05BQXNMSUNkRkRRQWdIaUFHUVFaMGFpSVJJQWNnQmlBUWJFRUNkR29pQi8wQUFnRDlDd0lBSUJFZ0IvMEFBaEQ5Q3dJUUN5QWNFQndDUUNBUFJRMEFRUUFoQmtFQUlRY2dJd1JBQTBBZ0FTQUdJQkJzUVFKMGFpSVJJQklnQmtFRmRHb2lKZjBBQWdEOUN3SUFJQkVnSmYwQUFoRDlDd0lRSUFFZ0JrRUJjaUlSSUJCc1FRSjBhaUlsSUJJZ0VVRUZkR29pRWYwQUFoRDlDd0lRSUNVZ0VmMEFBZ0Q5Q3dJQUlBWkJBbW9oQmlBSFFRSnFJZ2NnSVVjTkFBc0xJQ0pGRFFBZ0FTQUdJQkJzUVFKMGFpSUhJQklnQmtFRmRHb2lCdjBBQWdEOUN3SUFJQWNnQnYwQUFoRDlDd0lRQ3lBQlFTQnFJUUVnQ0VFSWF5SUlRUWRMRFFBTERBRUxRUUVnRGtFRGRpSUJJRWNnQVNCSFNSc2lDQ0FJUVFGTkd5RVJJQTRnQ0c1QmVIRWhFaUFPUVhoeElTQkJBQ0VISUFvaEFRTkFRVEFRRFNJR1JRMEVJQVlnUmhBV0loNDJBZ0FnSGtVRVFDQWZFQm9nQmhBSlFRQU1CZ3NnQmlBQk5nSW9JQVlnRURZQ0pDQUdJQTgyQWlBZ0JpQVROZ0ljSUFaQkFEWUNHQ0FHSUF3MkFoUWdCa0VBTmdJUUlBWWdHRFlDRENBR0lBdzJBZ2dnQmlBVE5nSUVJQVlnSUNBSElCSnNheUFTSUFkQkFXb2lCeUFJUmhzaUhqWUNMQ0FmUVEwZ0JoQW1JQUVnSGtFQ2RHb2hBU0FISUJGSERRQUxJQjhRR2dzQ1FDQU9RUWR4SWhKRkRRQWdHRUVGZENFZ0lCd29BZ0FoQ0FKQUlBeEZEUUFnQ0NBZ2FpRVJJQkpCQW5RaEdFRUFJUVlnREVFQlJ3UkFJQXhCZm5FaEhrRUFJUWNEUUNBUklBWkJCblJxSUFFZ0JpQVFiRUVDZEdvZ0dCQUxHaUFSSUFaQkFYSWlJMEVHZEdvZ0FTQVFJQ05zUVFKMGFpQVlFQXNhSUFaQkFtb2hCaUFIUVFKcUlnY2dIa2NOQUFzTElBeEJBWEZGRFFBZ0VTQUdRUVowYWlBQklBWWdFR3hCQW5ScUlCZ1FDeG9MQWtBZ0RDQVBSZzBBSUFnZ0lHdEJJR29oQnlBQklBd2dFR3hCQW5ScUlSRWdFa0VDZENFWVFRQWhCaUFNSUNrZ0pFRi9jMnBIQkVBZ0UwRitjU0VnUVFBaERBTkFJQWNnQmtFR2RHb2dFU0FHSUJCc1FRSjBhaUFZRUFzYUlBY2dCa0VCY2lJZVFRWjBhaUFSSUJBZ0hteEJBblJxSUJnUUN4b2dCa0VDYWlFR0lBeEJBbW9pRENBZ1J3MEFDd3NnRTBFQmNVVU5BQ0FISUFaQkJuUnFJQkVnQmlBUWJFRUNkR29nR0JBTEdnc2dIQkFjSUE5RkRRQWdFa0VDZENFSFFRQWhCaUFrUVFGcUlDbEhCRUFnRDBGK2NTRU1RUUFoRVFOQUlBRWdCaUFRYkVFQ2RHb2dDQ0FHUVFWMGFpQUhFQXNhSUFFZ0JrRUJjaUlUSUJCc1FRSjBhaUFJSUJOQkJYUnFJQWNRQ3hvZ0JrRUNhaUVHSUJGQkFtb2lFU0FNUncwQUN3c2dEMEVCY1VVTkFDQUJJQVlnRUd4QkFuUnFJQWdnQmtFRmRHb2dCeEFMR2dzZ0ZVR1lBV29oRlNBV1FRRnJJaFlOQUF0QkFRd0NDMEVCSVFjZ0NTZ0NIQ0lNSUFoQm1BRnNhaUlqUVpnQmF5SXZLQUlBSUNOQmtBRnJLQUlBUmcwQ0lDTkJsQUZySWowb0FnQWdJMEdNQVdzb0FnQkdEUUlnRENnQ0JDRVBJQXdvQWd3aEZpQU1LQUlBSVJBZ0RDZ0NDQ0VUSUFrb0FrUWhFaUFKS0FKQUlSRWdDU2dDUENFYUlBa29BamdoSHlBSklBZ1FWU0llUlFSQVFRQWhCd3dEQ3lBSVFRRkdCRUFnSGlBalFSQnJLQUlBSWdFZ0x5Z0NBQ0lHYXlBalFReHJLQUlBSUQwb0FnQWlDbXNnSTBFSWF5Z0NBQ0lJSUFacklDTkJCR3NvQWdBZ0Ntc2dDU2dDTkVFQklBZ2dBV3NRRnlBZUVCME1Bd3RCQUNFR0FrQUNRQ0FJUVFGcklncEJCRWtFUUNBS0lRY2dEQ0VCREFFTElBcEJBM0VoQnlBTUlBcEJmSEVpRlVHWUFXeHFJUUVEUUNDQUFTQU1JQTVCbUFGc2FpSUdRZWdFYWlBR1FkQURhaUFHUWJnQ2FpQUcvUWtDb0FIOVZnSUFBZjFXQWdBQy9WWUNBQU1nQmtIZ0JHb2dCa0hJQTJvZ0JrR3dBbW9nQnYwSkFwZ0IvVllDQUFIOVZnSUFBdjFXQWdBRC9iRUIvYmtCSUFaQjdBUnFJQVpCMUFOcUlBWkJ2QUpxSUFiOUNRS2tBZjFXQWdBQi9WWUNBQUw5VmdJQUF5QUdRZVFFYWlBR1Fjd0RhaUFHUWJRQ2FpQUcvUWtDbkFIOVZnSUFBZjFXQWdBQy9WWUNBQVA5c1FIOXVRRWhnQUVnRGtFRWFpSU9JQlZIRFFBTElJQUJJSUFCSUlBQi9RMElDUW9MREEwT0R3QUJBZ01BQVFJRC9ia0JJb0FCSUlBQklJQUIvUTBFQlFZSEFBRUNBd0FCQWdNQUFRSUQvYmtCL1JzQUlRWWdDaUFWUmcwQkN3TkFJQVlnQVNnQ29BRWdBU2dDbUFGcklnb2dCaUFLU3hzaUJpQUJLQUtrQVNBQktBS2NBV3NpQ2lBR0lBcExHeUVHSUFGQm1BRnFJUUVnQjBFQmF5SUhEUUFMQ3dKQUlBWkJnSUNBd0FCUERRQWdIQ0FHUVFWMEVCWWlJVFlDSUNBaFJRMEFJQndnSVRZQ0FBSkFJQWdFUUNBV0lBOXJJUW9nRXlBUWF5RUdJQ0ZCSUdvaFBpQUlyU0dIQVNBU3JTR0tBU0FSclNHTEFTQWFyU0dJQVNBZnJTR01BU0FKS0FJVUlrS3RJWTBCUWdFaGhnRURRQ0FjSUFvMkFnZ2dIQ0FHTmdJb0lBd29BcVFCSVFjZ0RDZ0NvQUVoQ0NBTUtBS2NBU0VCSUJ3Z0RDZ0NtQUVpRlVFQ2J5SWlOZ0lzSUJ3Z0FVRUNieUkvTmdJTUlCd2dDQ0FWYXlJZ0lBWnJJaWcyQWlRZ0hDQUhJQUZySWhNZ0Ntc2lPRFlDQkNBZkloWWhDQ0FhSWdFaERpQVJJZ2NoR0NBU0loVWhEd0pBSUlZQklJMEJVUTBBSUVJZ2hnR25heUVRUVFBaERrRUFJUWdnRmdSQVFuOGdFSzBpaVFHR1FuK0ZJSXdCZkNDSkFZaW5JUWdMSUJvRVFFSi9JQkN0SW9rQmhrSi9oU0NJQVh3Z2lRR0lweUVPQzBFQUlSVkJBQ0VISUJFRVFFSi9JQkN0SW9rQmhrSi9oU0NMQVh3Z2lRR0lweUVIQ3lBU0JFQkNmeUFRclNLSkFZWkNmNFVnaWdGOElJa0JpS2NoRlF0QkFDRVlRUUFoRmtFQklCQkJBV3QwSWhzZ0gwa0VRQ0FmSUJ0cnJVSi9JQkN0SW9rQmhrSi9oWHdnaVFHSXB5RVdDeUFSSUJ0TEJFQWdFU0FiYTYxQ2Z5QVFyU0tKQVlaQ2Y0VjhJSWtCaUtjaEdBdEJBQ0VQUVFBaEFTQWFJQnRMQkVBZ0dpQWJhNjFDZnlBUXJTS0pBWVpDZjRWOElJa0JpS2NoQVFzZ0VpQWJUUTBBSUJJZ0cydXRRbjhnRUswaWlRR0dRbitGZkNDSkFZaW5JUThMUVg4Z0dDQU1LQUswQVNJUWF5SWJRUUFnR0NBYlR4c2lHRUVFYWlJYklCZ2dHMHNiSWhnZ0tDQVlJQ2hKR3lJdFFYOGdCeUFNS0FMWUFTSVlheUliUVFBZ0J5QWJUeHNpQjBFRWFpSWJJQWNnRzBzYklnY2dCaUFHSUFkTEd5SXJJQ0liUVFGMElnY2dLeUF0SUNJYlFRRjBRUUZ5SWhzZ0J5QWJTeHNpS0NBZ1NTRVVJQllnRUdzaUIwRUFJQWNnRmswYklnZEJCR3NpRmtFQUlBY2dGazhiSWljZ0NDQVlheUlIUVFBZ0J5QUlUUnNpQjBFRWF5SUlRUUFnQnlBSVR4c2lNQ0FpRzBFQmRDSVlJREFnSnlBaUcwRUJkRUVCY2lJa1NTRXBJQTRnRENnQ3VBRWlGbXNpQjBFQUlBY2dEazBiSWdkQkJHc2lDRUVBSUFjZ0NFOGJJZ2doRUNBQklBd29BdHdCSWc1cklnZEJBQ0FCSUFkUEd5SUJRUVJySWdkQkFDQUJJQWRQR3lJQklRZEJmeUFWSUJackloWkJBQ0FWSUJaUEd5SVZRUVJxSWhZZ0ZTQVdTeHNpRlNBS0lBb2dGVXNiSWhZaEZVRi9JQThnRG1zaURrRUFJQTRnRDAwYklnNUJCR29pRHlBT0lBOUxHeUlPSURnZ0RpQTRTUnNpR3lFUElEOEVRQ0FCSVJBZ0ZpRVBJQnNoRlNBSUlRY0xJQ2dnSUNBVUd5RW9JQmdnSkNBcEd5RVlJQndnTFRZQ1BDQWNJQ2MyQWpnZ0hDQXJOZ0kwSUJ3Z01EWUNNQUpBSUJOQkNFa0VRRUVISVFaQkFDRU9EQUVMSUQ0Z0lrRUZkQ0lPYXlBblFRWjBhaUU0SUE0Z0lXb2dNRUVHZEdvaEZDQUdJQzFxSVMwZ0JpQW5haUVuSUFvZ0cyb2hKQ0FCSUFwcUlTa2dJU0FZUVFWMGFpRXFRUUFoRGdOQUFrQUNRQ0FPSUJaSklBNUJCM0lpQmlBSVQzRU5BQ0FPSUNSSklBWWdLVTl4RFFBZ0RrRUlhaUVPREFFTFFRZ2dFeUFPYXlJR0lBWkJDRThiSVNWQkFDRUdBMEFnSGlBd0lBWWdEbW9pSWlBcklDSkJBV29pTENBVUlBWkJBblFpTG1wQkVFRUFFQmNnSGlBbklDSWdMU0FzSUM0Z09HcEJFRUVBRUJjZ0JrRUJhaUlHSUNWSERRQUxJQnhCSUdvUUhDQWVJQmdnRGlBb0lBNUJDR29pRGlBcVFRaEJBVUVBRUI5RkRRVUxJQTVCQjNJaUJpQVRTUTBBQ3dzQ1FDQU9JQk5QRFFBZ0RpQVdTU0FHSUFoUGNVVUVRQ0FPSUFvZ0cycFBEUUVnQmlBQklBcHFTUTBCQ3lBY1FTQnFJUVpCQUNFaUlCTWdEbXNpTUFSQUEwQWdIaUFHS0FJUUlpMGdEaUFpYWlJbklBWW9BaFFnSjBFQmFpSXJJQ0pCQW5RaU9DQUdLQUlBSUFZb0FneEJCWFJxSUMxQkJuUnFha0VRUVFBUUZ5QWVJQVlvQWhnaUxTQUdLQUlJSWhScUlDY2dCaWdDSENBVWFpQXJJQVlvQWdBZ0JpZ0NERUVGZEdzZ0xVRUdkR29nT0dwQklHcEJFRUVBRUJjZ0lrRUJhaUlpSURCSERRQUxDeUFHRUJ3Z0hpQVlJQTRnS0NBVElDRWdHRUVGZEdwQkNFRUJRUUFRSDBVTkF3c2dIQ0FiTmdJY0lCd2dBVFlDR0NBY0lCWTJBaFFnSENBSU5nSVFJQmdnS0VrRVFDQVZRUUYwSWdZZ0QwRUJkRUVCY2lJVklBWWdGVXNiSWdZZ0V5QUdJQk5KR3lFR0lENGdQMEVGZENJVmF5QUJRUVowYWlFT0lCVWdJV29nQ0VFR2RHb2hGU0FLSUJ0cUlROGdBU0FLYWlFS0lDRWdFRUVCZENJQklBZEJBWFJCQVhJaUJ5QUJJQWRKR3lJSFFRVjBhaUVRQTBBZ0hpQVlJQWhCQ0NBb0lCaHJJZ0VnQVVFSVR4c2dHR29pQVNBV0lCVkJBVUVRRUJjZ0hpQVlJQW9nQVNBUElBNUJBVUVRRUJjZ0hCQWNJQjRnR0NBSElBRWdCaUFRUVFGQkNFRUFFQjlGRFFRZ0dFRUlhaUlZSUNoSkRRQUxDeUFNUVpnQmFpRU1JQ0FoQmlBVElRb2doZ0ZDQVh3aWhnRWdod0ZTRFFBTEMwRUJJUWNnSGlBalFSQnJLQUlBSWdFZ0x5Z0NBQ0lHYXlBalFReHJLQUlBSUQwb0FnQWlDbXNnSTBFSWF5Z0NBQ0lJSUFacklDTkJCR3NvQWdBZ0Ntc2dDU2dDTkVFQklBZ2dBV3NRRnlBZUVCMGdJUkFKREFRTElCNFFIU0FoRUFsQkFDRUhEQU1MSUI0UUhVRUFJUWNNQWdzZ0h4QWFRUUFMSVFjZ0hDZ0NJQkFKQ3lBY1FVQnJKQUFnQncwQURBUUxJQjFCdUFocUlSMGdEVUUwYWlFTklBbEJ6QUJxSVFrZ0MwRUJhaUlMSUJjb0FoQkpEUUFMSUJrb0FpQWhIU0FaS0FJVUtBSUFJUmNMQWtBZ0hTZ0NFQ0lKUlEwQUlCa29Ba1FOQUNBWEtBSVVJZzBvQWh3aEFRSkFBa0FDUUNBWktBSkFJZ1lFUUNBWEtBSVFJZ3RCQTBrTkFnSkFJQTBvQWhnaUJ5QU5LQUprUmdSQUlBY2dEU2dDc0FGR0RRRUxJRE5CQVVHdnlnQkJBQkFJREFjTEFrQWdHU2dDR0NnQ0dDSUtLQUlrSWdnZ0NpZ0NXRWNOQUNBSUlBb29Bb3dCUncwQUlBRWdCMEdZQVd3aUNtb2lBVUdNQVdzb0FnQWdBVUdVQVdzb0FnQnJJQUZCa0FGcktBSUFJQUZCbUFGcktBSUFhMndpQVNBTktBSm9JQXBxSWdkQmpBRnJLQUlBSUFkQmxBRnJLQUlBYXlBSFFaQUJheWdDQUNBSFFaZ0JheWdDQUd0c1J3MEFJQTBvQXJRQklBcHFJZ2RCakFGcktBSUFJQWRCbEFGcktBSUFheUFIUVpBQmF5Z0NBQ0FIUVpnQmF5Z0NBR3RzSUFGR0RRSUxJRE5CQVVHdnlnQkJBQkFJREFZTElCY29BaEFpQzBFRFNRMEJBa0FnR1NnQ0dDZ0NHQ0lIS0FJa0lnb2dCeWdDV0VjTkFDQUtJQWNvQW93QklnaEhEUUFnQVNBS1FaZ0JiQ0lIYWlJQktBS1VBU0FCS0FLTUFXc2dBU2dDa0FFZ0FTZ0NpQUZyYkNJQklBY2dEU2dDYUdvaUJ5Z0NsQUVnQnlnQ2pBRnJJQWNvQXBBQklBY29Bb2dCYTJ4SERRQWdEU2dDdEFFZ0NFR1lBV3hxSWdjb0FwUUJJQWNvQW93QmF5QUhLQUtRQVNBSEtBS0lBV3RzSUFGR0RRRUxJRE5CQVVHdnlnQkJBQkFJREFVTElBbEJBa1lFUUNBZEtBTG9LMFVOQXlBTFFRSjBFQTBpQzBVTkJTQVhLQUlRSWdoRkRRSWdHU2dDUUFSQVFRQWhGd0pBSUFoQkRFa0VRRUVBSVFZTUFRc2dEVUVrYWlFS0FrQWdDeUFOSUFoQnpBQnNha0VrYTA4TkFDQUtJQXNnQ0VFQ2RHcFBEUUJCQUNFR0RBRUxJQTFCaUFKcUlRd2dEVUc4QVdvaEZTQU5RZkFBYWlFT0lBMGdDRUY4Y1NJR1Fjd0FiR29oRFVFQUlRa0RRQ0FMSUFsQkFuUnFJQXdnQ1VITUFHd2lCMm9nQnlBVmFpQUhJQTVxSUFjZ0NtcjlDUUlBL1ZZQ0FBSDlWZ0lBQXYxV0FnQUQvUXNDQUNBSlFRUnFJZ2tnQmtjTkFBc2dCaUFJUmcwRUN3SkFJQWhCQTNFaUIwVUVRQ0FHSVFrTUFRc2dCaUVKQTBBZ0N5QUpRUUowYWlBTktBSWtOZ0lBSUFsQkFXb2hDU0FOUWN3QWFpRU5JQmRCQVdvaUZ5QUhSdzBBQ3dzZ0JpQUlhMEY4U3cwRElBdEJER29oQmlBTFFRaHFJUW9nQzBFRWFpRU1BMEFnQ3lBSlFRSjBJZ2RxSUEwb0FpUTJBZ0FnQnlBTWFpQU5LQUp3TmdJQUlBY2dDbW9nRFNnQ3ZBRTJBZ0FnQmlBSGFpQU5LQUtJQWpZQ0FDQU5RYkFDYWlFTklBbEJCR29pQ1NBSVJ3MEFDd3dEQzBFQUlSY0NRQ0FJUVF4SkJFQkJBQ0VHREFFTElBMUJOR29oQ2dKQUlBc2dEU0FJUWN3QWJHcEJGR3RQRFFBZ0NpQUxJQWhCQW5ScVR3MEFRUUFoQmd3QkN5QU5RWmdDYWlFTUlBMUJ6QUZxSVJVZ0RVR0FBV29oRGlBTklBaEJmSEVpQmtITUFHeHFJUTFCQUNFSkEwQWdDeUFKUVFKMGFpQU1JQWxCekFCc0lnZHFJQWNnRldvZ0J5QU9haUFISUFwcS9Ra0NBUDFXQWdBQi9WWUNBQUw5VmdJQUEvMExBZ0FnQ1VFRWFpSUpJQVpIRFFBTElBWWdDRVlOQXdzQ1FDQUlRUU54SWdkRkJFQWdCaUVKREFFTElBWWhDUU5BSUFzZ0NVRUNkR29nRFNnQ05EWUNBQ0FKUVFGcUlRa2dEVUhNQUdvaERTQVhRUUZxSWhjZ0IwY05BQXNMSUFZZ0NHdEJmRXNOQWlBTFFReHFJUVlnQzBFSWFpRUtJQXRCQkdvaERBTkFJQXNnQ1VFQ2RDSUhhaUFOS0FJME5nSUFJQWNnREdvZ0RTZ0NnQUUyQWdBZ0J5QUthaUFOS0FMTUFUWUNBQ0FHSUFkcUlBMG9BcGdDTmdJQUlBMUJzQUpxSVEwZ0NVRUVhaUlKSUFoSERRQUxEQUlMSUIwb0F0QXJLQUlVUVFGR0JFQWdCZ1JBSUEwb0FpUWdEU2dDY0NBTktBSzhBU0FCRUZnTUJBc2dEU2dDTkNBTktBS0FBU0FOS0FMTUFTQUJFRmdNQXdzZ0JnUkFJQTBvQWlRZ0RTZ0NjQ0FOS0FLOEFTQUJFRmNNQXdzZ0RTZ0NOQ0FOS0FLQUFTQU5LQUxNQVNBQkVGY01BZ3NnUUNBTE5nSUFJRE5CQVVIc3lnQWdRQkFJREFFTElCa29BaGdvQWhnb0FpQWFBbjhnSFNnQzZDc2hCMEVBSVE1QkFDQUlRUU4wRUEwaURVVU5BQm9DUUNBQlJRMEFJQWhGRFFBZ0RTQUlRUUowYWlFVElBaEJmSEVoRHlBSVFRTnhJUXdnQ0VFQmF5RVFBMEJCQUNFWFFRQWhDU0FRUVFOUEJFQURRQ0FOSUJkQkFuUWlCbW9nQmlBTGFpZ0NBQ29DQURnQ0FDQU5JQVpCQkhJaUNtb2dDaUFMYWlnQ0FDb0NBRGdDQUNBTklBWkJDSElpQ21vZ0NpQUxhaWdDQUNvQ0FEZ0NBQ0FOSUFaQkRISWlCbW9nQmlBTGFpZ0NBQ29DQURnQ0FDQVhRUVJxSVJjZ0NVRUVhaUlKSUE5SERRQUxDMEVBSVFvZ0RBUkFBMEFnRFNBWFFRSjBJZ1pxSUFZZ0Myb29BZ0FxQWdBNEFnQWdGMEVCYWlFWElBcEJBV29pQ2lBTVJ3MEFDd3RCQUNFR0lBY2hGd05BSUJNZ0JrRUNkQ0lTYWlJSlFRQTJBZ0JEQUFBQUFDR09BVUVBSVFwQkFDRVdJQkJCQWtzRVFBTkFJQWtnRnlvQ0FDQU5JQXBCQW5ScUloVXFBZ0NVSUk0QmtpS09BVGdDQUNBSklCY3FBZ1FnRlNvQ0JKUWdqZ0dTSW80Qk9BSUFJQWtnRnlvQ0NDQVZLZ0lJbENDT0FaSWlqZ0U0QWdBZ0NTQVhLZ0lNSUJVcUFneVVJSTRCa2lLT0FUZ0NBQ0FLUVFScUlRb2dGMEVRYWlFWElCWkJCR29pRmlBUFJ3MEFDd3RCQUNFVklBd0VRQU5BSUFrZ0Z5b0NBQ0FOSUFwQkFuUnFLZ0lBbENDT0FaSWlqZ0U0QWdBZ0NrRUJhaUVLSUJkQkJHb2hGeUFWUVFGcUloVWdERWNOQUFzTElBc2dFbW9pQ2lBS0tBSUFJZ3BCQkdvMkFnQWdDaUNPQVRnQ0FDQUdRUUZxSWdZZ0NFY05BQXNnRGtFQmFpSU9JQUZIRFFBTEN5QU5FQWxCQVFzaGV5QUxFQWtnZTBVTkFnc2dHU2dDRkNnQ0FDSVdLQUlRUlFSQVFRRWhNUXdDQ3lBWktBSWdLQUxRS3lJWFFiZ0lhaUVUSUJkQnRBaHFJUklnR1NnQ1JDRVFJQllvQWhRaEJ5QVpLQUlZS0FJWUlRcEJBQ0VJQTBBQ1FDQVFCRUFnRUNBSVFRSjBhaWdDQUVVTkFRc2dCeWdDSENJQklBb29BaVJCbUFGc2FpRUxBbjhnR1NnQ1FFVUVRQ0FMS0FLVUFTQUxLQUtNQVdzaEJpQUxLQUtRQVNBTEtBS0lBV3NoQVVFQUlReEJOQXdCQ3lBQklBY29BaGhCbUFGc2FpSUdRWkFCYXlnQ0FDQUxLQUlJSUFzb0FnQnJJZ0VnQmtHWUFXc29BZ0JxYXlFTUlBc29BZ3dnQ3lnQ0JHc2hCa0VrQ3lFSklBb29BaGdoQ3dKL0lBb29BaUFFUUVFQklBdEJBV3QwSWd0QkFXc2hIVUVBSUF0ckRBRUxRWDhnQzNSQmYzTWhIVUVBQ3lFUElBRkZEUUFnQmtVTkFDQUhJQWxxS0FJQUlRa2dGeWdDRkVFQlJnUkFJQk1nQ0VHNENHd2lDMm9oRVNBTElCSnFJUmdnQVVFQmNTRWFJQUZCQW5RaE15QUJRWHh4SWc1QkFuUWhHeUFkL1JFaGdnRWdELzBSSVlBQlFRQWhGU0FCUVFSSklSOERRQUpBQWtBQ1FDQWZEUUFnQ1NBUlNTQVlJQWtnTTJwSmNRMEFJQWtnRzJvaERTQVgvUWtDdEFnaGd3RkJBQ0VMQTBBZ0NTQUxRUUowYWlJZ0lJQUJJSU1CSUNEOUFBSUEvYTRCSW9RQklJSUIvYllCSUlRQklJQUIvVG45VXYwTEFnQWdDMEVFYWlJTElBNUhEUUFMSUE0aUN5QUJSZzBDREFFTElBa2hEVUVBSVFzTElBdEJBWEloQ1NBYUJFQWdEU0FQSUJjb0FyUUlJQTBvQWdCcUlnc2dIU0FMSUIxSUd5QUxJQTlJR3pZQ0FDQU5RUVJxSVEwZ0NTRUxDeUFCSUFsR0RRQURRQ0FOSUE4Z0Z5Z0N0QWdnRFNnQ0FHb2lDU0FkSUFrZ0hVZ2JJQWtnRDBnYk5nSUFJQTBnRHlBWEtBSzBDQ0FOS0FJRWFpSUpJQjBnQ1NBZFNCc2dDU0FQU0JzMkFnUWdEVUVJYWlFTklBdEJBbW9pQ3lBQlJ3MEFDd3NnRFNBTVFRSjBhaUVKSUJWQkFXb2lGU0FHUncwQUN3d0JDeUFkckNHR0FTQVByQ0dIQVVFQUlSVURRRUVBSVFzRFFDQUpBbjhnSFNBSktnSUFJbzRCUXdBQUFFOWVEUUFhSUE4Z2pnRkRBQUFBejEwTkFCb2dod0VnRnpRQ3RBZ0NmeUNPQVpBaWpnR0xRd0FBQUU5ZEJFQWdqZ0dvREFFTFFZQ0FnSUI0QzZ4OElvb0JJSVlCSUlZQklJb0JWUnNnaHdFZ2lnRlZHNmNMTmdJQUlBbEJCR29oQ1NBTFFRRnFJZ3NnQVVjTkFBc2dDU0FNUVFKMGFpRUpJQlZCQVdvaUZTQUdSdzBBQ3dzZ0IwSE1BR29oQnlBWFFiZ0lhaUVYSUFwQk5Hb2hDa0VCSVRFZ0NFRUJhaUlJSUJZb0FoQkpEUUFMREFFTElBVkJBVUdhR1VFQUVBZ0xJRUJCRUdva0FDQXhSUVJBSUU4UUtTQUFJQUFvQWdoQmdJQUNjallDQ0NBRlFRRkJ5OVFBUVFBUUNBd0JDd0pBSUFKRkRRQUNmeUFDSVFkQkFDRUdBa0FnQUNnQzBBRWlGVUVCRUUwaUFVRi9SZzBBSUFFZ0Ewc05BRUVCSUJVb0FoZ2lBU2dDRUVVTkFSb2dBU2dDR0NFSUlCVW9BaFFvQWdBb0FoUWhGd05BSUFnb0FoZ2lBVUVIY1NFQ0lBRkJBM1loQXlBWEtBSWNJZ1lnQ0NnQ0pFR1lBV3hxSVFFQ2Z5QVZLQUpBQkVBZ0JpQVhLQUlZUVpnQmJHb2lCa0dRQVdzb0FnQWdBU2dDQ0NBQktBSUFheUlMSUFaQm1BRnJLQUlBYW1zaERDQUJLQUlNSUFFb0FnUnJJUWxCSkF3QkN5QUJLQUtVQVNBQktBS01BV3NoQ1NBQktBS1FBU0FCS0FLSUFXc2hDMEVBSVF4Qk5Bc2dGMm9vQWdBaEFRSkFBa0FDUUFKQUFrQkJCQ0FESUFKQkFFZHFJZ0lnQWtFRFJodEJBV3NPQkFFQ0JBQUVDeUFKUlEwRElBc2dER29oQmlBTFFRSjBJUUlnQ1VFRVR3UkFJQWxCZkhFaENrRUFJUXNEUUNBSElBRWdBaEFMSVFjZ0FTQUdRUUowSWdOcUlnMGdBMm9pRENBRGFpSU9JQU5xSVFFZ0FpQUhhaUFOSUFJUUN5QUNhaUFNSUFJUUN5QUNhaUFPSUFJUUN5QUNhaUVISUF0QkJHb2lDeUFLUncwQUN3dEJBQ0VMSUFsQkEzRWlBMFVOQXdOQUlBY2dBU0FDRUFzaEJ5QUJJQVpCQW5ScUlRRWdBaUFIYWlFSElBdEJBV29pQ3lBRFJ3MEFDd3dEQ3lBSlJTQUxSWEloQWlBSUtBSWdSUTBCSUFJTkFpQUxRUUowSVE0Z0MwRjhjU0lEUVFKMElROUJBQ0VOQTBBQ1FBSkFBa0FnQzBFRVNRMEFJQUVnQnlBTGFra2dBU0FPYWlBSFMzRU5BQ0FESUFkcUlYd2dBU0FQYWlFR1FRQWhDZ05BSUFjZ0Ntb2dBU0FLUVFKMGF2MEFBZ0Q5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUQ5RFFBRUNBd0FBQUFBQUFBQUFBQUFBQUQ5V2dBQUFDQUtRUVJxSWdvZ0EwY05BQXNnZkNFSElBTWlBaUFMUmcwQ0RBRUxJQUVoQmtFQUlRSUxRUUFoQ2lBTElBSWlBV3RCQjNFaUZnUkFBMEFnQnlBR0tBSUFPZ0FBSUFGQkFXb2hBU0FIUVFGcUlRY2dCa0VFYWlFR0lBcEJBV29pQ2lBV1J3MEFDd3NnQWlBTGEwRjRTdzBBQTBBZ0J5QUdLQUlBT2dBQUlBY2dCaWdDQkRvQUFTQUhJQVlvQWdnNkFBSWdCeUFHS0FJTU9nQURJQWNnQmlnQ0VEb0FCQ0FISUFZb0FoUTZBQVVnQnlBR0tBSVlPZ0FHSUFjZ0JpZ0NIRG9BQnlBSFFRaHFJUWNnQmtFZ2FpRUdJQUZCQ0dvaUFTQUxSdzBBQ3dzZ0JpQU1RUUowYWlFQklBMUJBV29pRFNBSlJ3MEFDd3dDQ3lBSlJTQUxSWEloQWlBSUtBSWdCRUFnQWcwQ0lBdEJBblFoRGlBTFFRRjBJUThnQzBGOGNTSURRUUowSVJZZ0EwRUJkQ0VRUVFBaERRTkFBa0FDUUFKQUlBdEJCRWtOQUNBQklBY2dEMnBKSUFFZ0Rtb2dCMHR4RFFBZ0FTQVdhaUVHSUFjZ0VHb2hmVUVBSVFvRFFDQUhJQXBCQVhScUlBRWdDa0VDZEdyOUFBSUEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUTBBQVFRRkNBa01EUUFCQUFFQUFRQUIvVnNCQUFBZ0NrRUVhaUlLSUFOSERRQUxJSDBoQnlBRElnSWdDMFlOQWd3QkN5QUJJUVpCQUNFQ0MwRUFJUW9nQ3lBQ0lnRnJRUWR4SWhNRVFBTkFJQWNnQmlnQ0FEc0JBQ0FCUVFGcUlRRWdCMEVDYWlFSElBWkJCR29oQmlBS1FRRnFJZ29nRTBjTkFBc0xJQUlnQzJ0QmVFc05BQU5BSUFjZ0JpZ0NBRHNCQUNBSElBWW9BZ1E3QVFJZ0J5QUdLQUlJT3dFRUlBY2dCaWdDRERzQkJpQUhJQVlvQWhBN0FRZ2dCeUFHS0FJVU93RUtJQWNnQmlnQ0dEc0JEQ0FISUFZb0FodzdBUTRnQjBFUWFpRUhJQVpCSUdvaEJpQUJRUWhxSWdFZ0MwY05BQXNMSUFZZ0RFRUNkR29oQVNBTlFRRnFJZzBnQ1VjTkFBc01BZ3NnQWcwQklBdEJBblFoRGlBTFFRRjBJUThnQzBGOGNTSURRUUowSVJZZ0EwRUJkQ0VRUVFBaERRTkFBa0FDUUFKQUlBdEJCRWtOQUNBQklBY2dEMnBKSUFFZ0Rtb2dCMHR4RFFBZ0FTQVdhaUVHSUFjZ0VHb2hma0VBSVFvRFFDQUhJQXBCQVhScUlBRWdDa0VDZEdyOUFBSUEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUTBBQVFRRkNBa01EUUFCQUFFQUFRQUIvVnNCQUFBZ0NrRUVhaUlLSUFOSERRQUxJSDRoQnlBRElnSWdDMFlOQWd3QkN5QUJJUVpCQUNFQ0MwRUFJUW9nQ3lBQ0lnRnJRUWR4SWhNRVFBTkFJQWNnQmlnQ0FEc0JBQ0FCUVFGcUlRRWdCMEVDYWlFSElBWkJCR29oQmlBS1FRRnFJZ29nRTBjTkFBc0xJQUlnQzJ0QmVFc05BQU5BSUFjZ0JpZ0NBRHNCQUNBSElBWW9BZ1E3QVFJZ0J5QUdLQUlJT3dFRUlBY2dCaWdDRERzQkJpQUhJQVlvQWhBN0FRZ2dCeUFHS0FJVU93RUtJQWNnQmlnQ0dEc0JEQ0FISUFZb0FodzdBUTRnQjBFUWFpRUhJQVpCSUdvaEJpQUJRUWhxSWdFZ0MwY05BQXNMSUFZZ0RFRUNkR29oQVNBTlFRRnFJZzBnQ1VjTkFBc01BUXNnQWcwQUlBdEJBblFoRGlBTFFYeHhJZ05CQW5RaEQwRUFJUTBEUUFKQUFrQUNRQ0FMUVFSSkRRQWdBU0FISUF0cVNTQUJJQTVxSUFkTGNRMEFJQU1nQjJvaGZ5QUJJQTlxSVFaQkFDRUtBMEFnQnlBS2FpQUJJQXBCQW5ScS9RQUNBUDBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBOQUFRSURBQUFBQUFBQUFBQUFBQUFBUDFhQUFBQUlBcEJCR29pQ2lBRFJ3MEFDeUIvSVFjZ0F5SUNJQXRHRFFJTUFRc2dBU0VHUVFBaEFndEJBQ0VLSUFzZ0FpSUJhMEVIY1NJV0JFQURRQ0FISUFZb0FnQTZBQUFnQVVFQmFpRUJJQWRCQVdvaEJ5QUdRUVJxSVFZZ0NrRUJhaUlLSUJaSERRQUxDeUFDSUF0clFYaExEUUFEUUNBSElBWW9BZ0E2QUFBZ0J5QUdLQUlFT2dBQklBY2dCaWdDQ0RvQUFpQUhJQVlvQWd3NkFBTWdCeUFHS0FJUU9nQUVJQWNnQmlnQ0ZEb0FCU0FISUFZb0FoZzZBQVlnQnlBR0tBSWNPZ0FISUFkQkNHb2hCeUFHUVNCcUlRWWdBVUVJYWlJQklBdEhEUUFMQ3lBR0lBeEJBblJxSVFFZ0RVRUJhaUlOSUFsSERRQUxDeUFYUWN3QWFpRVhJQWhCTkdvaENFRUJJUVlnY2tFQmFpSnlJQlVvQWhnb0FoQkpEUUFMQ3lBR0MwVU5BU0JQS0FMY0t5SUJSUTBBSUFFUUNTQlBRZ0EzQXR3ckN5QUFJQUF0QUVSQi9nRnhPZ0JFSUFBZ0FDZ0NDRUgvZm5FMkFnaEJBU0ZuSUFRcEF3Z2loZ0ZRQkg1Q0FBVWdoZ0VnQkNrRE9IMExVQ0FBS0FJSUlnRkJ3QUJHY1EwQUlBRkJnQUpHRFFBZ0JDQk9RUXBxUVFJZ0JSQVNRUUpIQkVBZ0JVRUJRUUlnQUNnQ3VBRWJRWllTUVFBUUNDQUFLQUs0QVVVaFp3d0JDeUJPUVFwcUlFNUJER3BCQWhBS0lFNG9BZ3dpQVVHUS93TkdEUUFnQVVIWi93TkdCRUFnQUVHQUFqWUNDQ0FBUVFBMkFzd0JEQUVMSUFRcEF3Z2loZ0ZRQkg1Q0FBVWdoZ0VnQkNrRE9IMExVQVJBSUFCQndBQTJBZ2dnQlVFQ1FhMCtRUUFRQ0F3QkMwRUFJV2NnQlVFQlFlMDlRUUFRQ0FzZ1RrRVFhaVFBSUdjTEN3QWdBQVJBSUFBUUNRc0x0QUVCQVg4Z0FDZ0NERVVFUUNBQ0lBQW9BaVFnQVJFREFBOExBa0JCQ0JBTklnTkZEUUFnQXlBQ05nSUVJQU1nQVRZQ0FFRUlFQTBpQVVVRVFDQURFQWtQQ3lBQklBTTJBZ0FnQUNBQUtBSUVRZVFBYkNJQ05nSW9BMEFnQUNnQ0dDQUNTZzBBQ3lBQklBQW9BaFEyQWdRZ0FDQUJOZ0lVSUFBZ0FDZ0NHRUVCYWpZQ0dDQUFLQUljSWdGRkRRQWdBU2dDQUVFQU5nSUlJQUFnQVNnQ0JEWUNIQ0FBSUFBb0FpQkJBV3MyQWlBZ0FSQUpDd3N2QVFGL0lBQUVRQ0FBS0FJRUlnRUVRQ0FBS0FJQUlBRVJBZ0FMSUFBb0FpQVFDU0FBUVFBMkFpQWdBQkFKQ3dzcUFDQUFCRUFnQUNnQ01DQUFRUlJCRUNBQUtBSk1HMm9vQWdBUkFnQWdBRUVBTmdJd0lBQVFDUXNMK2dJQkJIOENRQ0FBUlEwQUlBQW9BcXdvSWdFRVFDQUFLQUtvS0NJQ0JFQkJBQ0VCQTBBZ0FDZ0NyQ2dnQVVFRGRHb29BZ0FpQXdSQUlBTVFDU0FBS0FLb0tDRUNDeUFCUVFGcUlnRWdBa2tOQUFzZ0FDZ0NyQ2doQVFzZ0FFRUFOZ0tvS0NBQkVBa2dBRUVBTmdLc0tBc2dBQ2dDdENnaUFRUkFJQUVRQ1NBQVFRQTJBclFvQ3lBQUtBTFFLeUlCQkVBZ0FSQUpJQUJCQURZQzBDc0xJQUFvQXV3cklnRUVRQ0FCRUFrZ0FFRUFOZ0xzS3dzZ0FDZ0M2Q3NpQVFSQUlBRVFDU0FBUVFBMkF1Z3JDeUFBS0FMOEt5SUJCRUFnQVJBSklBQkJBRFlDaEN3Z0FFSUFOd0w4S3dzZ0FDZ0M4Q3NpQVFSQUlBQW9BdlFySWdNRWYwRUFJUUlEUUNBQktBSU1JZ1FFUUNBRUVBa2dBVUVBTmdJTUlBQW9BdlFySVFNTElBRkJGR29oQVNBQ1FRRnFJZ0lnQTBrTkFBc2dBQ2dDOENzRklBRUxFQWtnQUVFQU5nTHdLd3NnQUNnQzVDc2lBUVJBSUFFUUNTQUFRUUEyQXVRckN5QUFLQUxjS3lJQlJRMEFJQUVRQ1NBQVFnQTNBdHdyQ3d2SUJ3SVJmd0YrSUFBb0FoQWlDRUVnVHdSQUlBQXBBd2luRHdzQ1FDQUFLQUlVSWdOQkJFNEVRQ0FBS0FJQUlnSkJBMnNvQWdBaEFTQUFJQU5CQkdzaUF6WUNGQ0FBSUFKQkJHczJBZ0FNQVFzZ0EwRUFUQVJBREFFTElBTkJBWEVoRFNBQUtBSUFJUUlDUUNBRFFRRkdCRUJCR0NFRURBRUxJQU5CL3YvLy93ZHhJUWxCR0NFRUEwQWdBQ0FDUVFGcklnWTJBZ0FnQWkwQUFDRU1JQUFnQWtFQ2F5SUNOZ0lBSUFBZ0EwRUJhellDRkNBR0xRQUFJUVlnQUNBRFFRSnJJZ00yQWhRZ0RDQUVkQ0FCY2lBR0lBUkJDR3QwY2lFQklBUkJFR3NoQkNBRlFRSnFJZ1VnQ1VjTkFBc0xJQTBFUUNBQUlBSkJBV3MyQWdBZ0FpMEFBQ0VPSUFBZ0EwRUJhellDRkNBT0lBUjBJQUZ5SVFFTFFRQWhBd3NnQUNnQ0dDRUNJQUFnQVVIL0FYRWlDVUdQQVVzMkFoZ2dBRUVIUVFnZ0FVR0FnSUQ0QjNGQmdJQ0ErQWRHRzBFSUlBSWJJZ0pCQ0VFSFFRZ2dBVUdBZ1B3RGNVR0FnUHdEUmhzZ0FVSC8vLy8vZUUwYmFpSUVRUWhCQjBFSUlBRkJnUDRCY1VHQS9nRkdHeUFCUVJCMlFmOEJjU0lGUVk4QlRSdHFJZ1pCQ0VFSFFRZ2dBVUgvQUhGQi93QkdHeUFCUVFoMlFmOEJjU0lIUVk4QlRSc2dDR3BxSWdvMkFoQWdBQ0FBS1FNSUlBVWdBblFnQVVFWWRuSWdCeUFFZEhJZ0NTQUdkSEt0SUFpdGhvUWlFamNEQ0NBS1FSOU5CRUFDUUNBRFFRUk9CRUFnQUNnQ0FDSUNRUU5yS0FJQUlRRWdBQ0FEUVFSck5nSVVJQUFnQWtFRWF6WUNBQXdCQ3lBRFFRQk1CRUJCQUNFQkRBRUxJQU5CQVhFaEVDQUFLQUlBSVFJQ1FDQURRUUZHQkVCQkdDRUVRUUFoQVF3QkN5QURRZjcvLy84SGNTRUdRUmdoQkVFQUlRRkJBQ0VGQTBBZ0FDQUNRUUZySWdjMkFnQWdBaTBBQUNFUElBQWdBa0VDYXlJQ05nSUFJQUFnQTBFQmF6WUNGQ0FITFFBQUlRY2dBQ0FEUVFKcklnTTJBaFFnRHlBRWRDQUJjaUFISUFSQkNHdDBjaUVCSUFSQkVHc2hCQ0FGUVFKcUlnVWdCa2NOQUFzTElCQkZEUUFnQUNBQ1FRRnJOZ0lBSUFJdEFBQWhFU0FBSUFOQkFXczJBaFFnRVNBRWRDQUJjaUVCQ3lBQUlBRkIvd0Z4SWdKQmp3RkxOZ0lZSUFCQkNFRUhRUWdnQVVHQWdJRDRCM0ZCZ0lDQStBZEdHeUFKUVk4QlRSc2lBMEVJUVFkQkNDQUJRWUNBL0FOeFFZQ0EvQU5HR3lBQlFmLy8vLzk0VFJ0cUlnUkJDRUVIUVFnZ0FVR0EvZ0Z4UVlEK0FVWWJJQUZCRUhaQi93RnhJZ1ZCandGTkcyb2lDRUVJUVFkQkNDQUJRZjhBY1VIL0FFWWJJQUZCQ0haQi93RnhJZ2xCandGTkd5QUthbW8yQWhBZ0FDQUZJQU4wSUFGQkdIWnlJQWtnQkhSeUlBSWdDSFJ5clNBS3JZWWdFb1FpRWpjRENBc2dFcWNMeVJRQ0hYOEdleUFBS0FJSUlnb2dBQ2dDQkdvaENBSkFJQUFvQWd4RkJFQWdDRUVDU0EwQklBTkJBRXdOQVNBQUtBSUFJZ1VnQ0VFRWF5SUdRUUYySWd4QkFuUWlDU0FCSUFwQkFuUnFJZ2NnQTBFQ2RDSUVhbXBCQkdwSklBVWdERUVEZEdwQkNHb2lBQ0FIUVFScVMzRWdCU0FCSUFScUlBbHFRUVJxU1NBQlFRUnFJQUJKY1hJaEVpQUlRUVJKSWhRZ0FrRUJSM0loRlNBQ1FRRkdJQVpCQlV0eElSWWdDRUg4Ly8vL0IzRWhFeUFJUVFGeElSY2dDa0VCYWlFUElBaEJBM0VoRVNBQklBVnJJUmdnQlNBSVFRSjBhaUVaSUFVZ0NFRUJheUlBUVFKMGFpRWFJQXhCQVdvaUcwRjhjU0lRUVFGMElRc2dBaUFLYkVFQ2RDRWNJQUJCQVhZZ0FteEJBblFoSFFOQUlBRW9BZ0FnQVNBY2FpZ0NBQ0lKUVFGcVFRRjFheUVIQWtBZ0ZBUkFJQWtoQkVFQUlRWU1BUXRCQUNFR0FrQUNmMEVBSUJaRkRRQWFRUUFnRWcwQUdpQUovUkVoSWlBSC9SRWhJZjBNQUFBQUFBSUFBQUFFQUFBQUJnQUFBQ0VsUVFBaEFBTkFJQUVnQUVFQ2RHcjlBQUlFSVNRZ0FTQUFJQTlxUVFKMGF2MEFBZ0FoSXlBRklBQkJBM1JxSWdRZ0lmMWFBZ0FESUFSQkNHb2dKQ0FqSUNJZ0kvME5EQTBPRHhBUkVoTVVGUllYR0JrYUd5SWsvYTRCL1F3Q0FBQUFBZ0FBQUFJQUFBQUNBQUFBL2E0QlFRTDlyQUg5c1FFaUl2MWFBZ0FBSUFSQkVHb2dJdjFhQWdBQklBUkJHR29nSXYxYUFnQUNJQVVnSmYwTUFRQUFBQUVBQUFBQkFBQUFBUUFBQVAxUUlpYjlHd0JCQW5ScUlDSWdJU0FpL1EwTURRNFBFQkVTRXhRVkZoY1lHUm9iL2E0QlFRSDlyQUVnSlAydUFTSWgvVm9DQUFBZ0JTQW0vUnNCUVFKMGFpQWgvVm9DQUFFZ0JTQW0vUnNDUVFKMGFpQWgvVm9DQUFJZ0JTQW0vUnNEUVFKMGFpQWgvVm9DQUFNZ0pmME1DQUFBQUFnQUFBQUlBQUFBQ0FBQUFQMnVBU0VsSUNJaElTQWpJU0lnQUVFRWFpSUFJQkJIRFFBTElDTDlHd01oQkNBaC9Sc0RJUWNnRUNBYlJnMEJJQXNoQmlBRUlRa2dFQXNoQUFOQUlBRWdBRUVCYWlJS0lBSnNRUUowYWlnQ0FDRWVJQUVnQUNBUGFpQUNiRUVDZEdvb0FnQWhCQ0FGSUFaQkFuUnFJZzRnQnpZQ0FDQU9JQWNnSGlBRUlBbHFRUUpxUVFKMWF5SUhha0VCZFNBSmFqWUNCQ0FHUVFKcUlRWWdBQ0FNUnlFZklBUWhDU0FLSVFBZ0h3MEFDd3dCQ3lBTElRWUxJQVVnQmtFQ2RHb2dCellDQUVGOElRQWdGd1IvSUJvZ0FTQWRhaWdDQUNBRVFRRnFRUUYxYXlJQU5nSUFJQUFnQjJwQkFYVWhCMEY0QlVGOEN5QVphaUFFSUFkcU5nSUFRUUFoQmtFQUlRQkJBQ0VFQWtBZ0ZTQVlJQTFCQW5ScVFSQkpja1VFUUFOQUlBRWdBRUVDZENJRWFpQUVJQVZxL1FBQ0FQMExBZ0FnQUVFRWFpSUFJQk5IRFFBTElCTWlCQ0FJUmcwQkN5QUVJUUFnRVFSQUEwQWdBU0FBSUFKc1FRSjBhaUFGSUFCQkFuUnFLQUlBTmdJQUlBQkJBV29oQUNBR1FRRnFJZ1lnRVVjTkFBc0xJQVFnQ0d0QmZFc05BQU5BSUFFZ0FDQUNiRUVDZEdvZ0JTQUFRUUowYWlnQ0FEWUNBQ0FCSUFCQkFXb2lCQ0FDYkVFQ2RHb2dCU0FFUVFKMGFpZ0NBRFlDQUNBQklBQkJBbW9pQkNBQ2JFRUNkR29nQlNBRVFRSjBhaWdDQURZQ0FDQUJJQUJCQTJvaUJDQUNiRUVDZEdvZ0JTQUVRUUowYWlnQ0FEWUNBQ0FBUVFScUlnQWdDRWNOQUFzTElBRkJCR29oQVNBTlFRRnFJZzBnQTBjTkFBc01BUXNDUUFKQUFrQWdDRUVCYXc0Q0FBRUNDeUFEUVFCTURRSkJBQ0VDQWtBZ0EwRUVTUVJBSUFFaEFBd0JDeUFCSUFOQi9QLy8vd2R4SWdKQkFuUnFJUUFEUUNBQklBWkJBblJxSWdRZ0JQMEFBZ0FpSWYwYkFFRUNiZjBSSUNIOUd3RkJBbTM5SEFFZ0lmMGJBa0VDYmYwY0FpQWgvUnNEUVFKdC9Sd0QvUXNDQUNBR1FRUnFJZ1lnQWtjTkFBc2dBaUFEUmcwREN3TkFJQUFnQUNnQ0FFRUNiVFlDQUNBQVFRUnFJUUFnQWtFQmFpSUNJQU5IRFFBTERBSUxJQU5CQUV3TkFTQUFLQUlBSVFrZ0FpQUtiRUVDZENFSEEwQWdDU0FCS0FJQUlBRWdCMm9pQkNnQ0FFRUJha0VCZFdzaUFEWUNCQ0FKSUFBZ0JDZ0NBR29pQURZQ0FDQUJJQUEyQWdBZ0FTQUNRUUowYWlBSktBSUVOZ0lBSUFGQkJHb2hBU0FHUVFGcUlnWWdBMGNOQUFzTUFRc2dDRUVEU0EwQUlBTkJBRXdOQUNBQUtBSUFJZ1VnQ0NBSVFRRnhJaFJGSWdaclFRUnJJZ2xCQVhZaUMwRUNkQ0lISUFFZ0EwRUNkQ0lBYW1wSklBVWdDMEVEZEdwQkRHb2lCQ0FCUVFScVMzRWdCVUVFYWlBQUlBRWdDa0VDZEdvaUFHb2dCMnBCQ0dwSklBQkJDR29nQkVseGNpRVZJQUpCQVVjZ0NFRUVTWEloRmlBQ1FRRkdJQWxCQlV0eElSY2dDRUg4Ly8vL0IzRWhFQ0FJUVFOeElSRWdBU0FGYXlFWUlBVWdDRUVDZEdwQkJHc2hHU0FGSUFoQkFtc2lBRUVDZEdvaEdpQUxRUUZxSWhKQmZIRWlERUVCY2lFVElBeEJBWFJCQVhJaEN5QUNJQXBzUVFKMElSc2dBQ0FHYTBFQ1NTRWNJQWhCQVhaQkFXc2dBbXhCQW5RaEhRTkFJQVVnQVNnQ0FDQUJJQnRxSWc4Z0FrRUNkR29vQWdBaUNTQVBLQUlBSWdCcVFRSnFRUUoxYXlJSElBQnFOZ0lBUVFFaEJBSkFJQndFUUNBSklRWU1BUXNDUUFKL1FRRWdGMFVOQUJwQkFTQVZEUUFhSUFuOUVTRWhJQWY5RVNFaVFRQWhBQU5BSUFVZ0FFRURkR29pQnlBQklBQkJBblFpQkdyOUFBSUVJQ0VnQkNBUGF2MEFBZ2dpSWYwTkRBME9EeEFSRWhNVUZSWVhHQmthR3lJa0lDSDlyZ0g5REFJQUFBQUNBQUFBQWdBQUFBSUFBQUQ5cmdGQkF2MnNBZjJ4QVNJaklDTWdJaUFqL1EwTURRNFBFQkVTRXhRVkZoY1lHUm9iL2E0QlFRSDlyQUVnSlAydUFTSWsvUTBFQlFZSEdCa2FHd2dKQ2dzY0hSNGYvUXNDRkNBSElDSWdKUDBOREEwT0R4QVJFaE1BQVFJREZCVVdGeUFqL1EwQUFRSURCQVVHQnhBUkVoTU1EUTRQL1FzQ0JDQWpJU0lnQUVFRWFpSUFJQXhIRFFBTElDSDlHd01oQmlBaS9Sc0RJUWNnRENBU1JnMEJJQXNoQkNBR0lRa2dFd3NoQUFOQUlBRWdBQ0FDYkVFQ2RHb29BZ0FoSGlBUElBQkJBV29pQ2lBQ2JFRUNkR29vQWdBaEJpQUZJQVJCQW5ScUlnNGdCellDQUNBT0lBY2dIaUFHSUFscVFRSnFRUUoxYXlJSGFrRUJkU0FKYWpZQ0JDQUVRUUpxSVFRZ0FDQVNSeUVnSUFvaEFDQUdJUWtnSUEwQUN3d0JDeUFMSVFRTElCZ2dEVUVDZEdvaENTQUZJQVJCQW5ScUlBYzJBZ0FDUUNBVVJRUkFJQm9nQVNBZGFpZ0NBQ0FHUVFGcVFRRjFheUlBSUFkcVFRRjFJQVpxTmdJQURBRUxJQVlnQjJvaEFBc2dHU0FBTmdJQVFRQWhCa0VBSVFCQkFDRUVBa0FnRmlBSlFSQkpja1VFUUFOQUlBRWdBRUVDZENJRWFpQUVJQVZxL1FBQ0FQMExBZ0FnQUVFRWFpSUFJQkJIRFFBTElCQWlCQ0FJUmcwQkN5QUVJUUFnRVFSQUEwQWdBU0FBSUFKc1FRSjBhaUFGSUFCQkFuUnFLQUlBTmdJQUlBQkJBV29oQUNBR1FRRnFJZ1lnRVVjTkFBc0xJQVFnQ0d0QmZFc05BQU5BSUFFZ0FDQUNiRUVDZEdvZ0JTQUFRUUowYWlnQ0FEWUNBQ0FCSUFCQkFXb2lCQ0FDYkVFQ2RHb2dCU0FFUVFKMGFpZ0NBRFlDQUNBQklBQkJBbW9pQkNBQ2JFRUNkR29nQlNBRVFRSjBhaWdDQURZQ0FDQUJJQUJCQTJvaUJDQUNiRUVDZEdvZ0JTQUVRUUowYWlnQ0FEWUNBQ0FBUVFScUlnQWdDRWNOQUFzTElBRkJCR29oQVNBTlFRRnFJZzBnQTBjTkFBc0xDemNCQW44akFFRVFheUlCSkFBZ0FBUi9JQUZCREdwQklDQUFFR1VoQUVFQUlBRW9BZ3dnQUJzRlFRQUxJUUlnQVVFUWFpUUFJQUlMR3dFQmZ5QUFCRUFnQUNnQ0NDSUJCRUFnQVJBSkN5QUFFQWtMQ3pFQkFuOUJBVUVNRUF3aUFBUkFJQUJCQ2pZQ0JDQUFRUXBCQkJBTUlnRTJBZ2dnQVFSQUlBQVBDeUFBRUFrTFFRQUxVd0VDZnlBQVFRQTJBakFnQUNBQUtBSWdOZ0lrSUFFZ0FDZ0NBQ0FBS0FJY0VRa0FJUVFnQUNnQ1JDRUNJQVJGQkVBZ0FDQUNRUVJ5TmdKRVFRQVBDeUFBSUFFM0F6Z2dBQ0FDUVh0eE5nSkVRUUVMaGdNQ0JYOEtmaU1BUVNCcklnTWtBQUpBSUFBb0FoQWlCVVVFUUVFQklRSU1BUXNDUUNBQU5BSUFJZ2RDQUZNTkFDQUFOQUlFSWdoQ0FGTU5BQ0FBTkFJSUlnbENBRk1OQUNBQU5BSU1JZ3BDQUZNTkFDQUFLQUlZSVFBZ0IwSUJmU0VNSUFoQ0FYMGhEU0FKUWdGOUlRa2dDa0lCZlNFS0EwQWdBQ0FNSUFBb0FnQWlBcTBpQjN3Z0I0QWlDejRDRUNBQUlBMGdBQ2dDQkNJR3JTSUhmQ0FIZ0NJT1BnSVVRZ0VnQURVQ0tDSUhoaUlQUWdGOUlnZ2dDU0FDckNJUWZDQVFmOFI4SUFlSHB5QUlJQXZFZkNBSGg2ZHJJZ0pCQUVnRVFDQURJQUkyQWdRZ0F5QUVOZ0lBSUFGQkFVSGo1QUFnQXhBSVFRQWhBZ3dEQ3lBQUlBSTJBZ2dnQ0NBS0lBYXNJZ3Q4SUF0L3hId2dCNGVuSUE3RUlBOThRZ0Y5SUFlSHAyc2lBa0VBU0FSQUlBTWdBallDRkNBRElBUTJBaEFnQVVFQlFhamxBQ0FEUVJCcUVBaEJBQ0VDREFNTElBQWdBallDRENBQVFUUnFJUUJCQVNFQ0lBUkJBV29pQkNBRlJ3MEFDd3dCQ3lBQlFRRkJwek5CQUJBSUN5QURRU0JxSkFBZ0FndlhCZ0VHZnlBQUJFQUNRQ0FBS0FJQUJFQWdBQ2dDRENJQkJFQWdBUkFwSUFBb0Fnd1FDU0FBUVFBMkFnd0xJQUFvQWhBaUFRUkFJQUVRQ1NBQVFnQTNBeEFMSUFBb0FrQVFDU0FBUWdBM0Fqd01BUXNnQUNnQ0xDSUJCRUFnQVJBSklBQkJBRFlDTEFzZ0FDZ0NJQ0lCQkVBZ0FSQUpJQUJDQURjRElBc2dBQ2dDTkNJQlJRMEFJQUVRQ1NBQVFnQTNBalFMSUFBb0F0QUJFRTRnQUNnQ25BRWlBUVJBSUFBb0FtZ2dBQ2dDYkd3aUF3Ui9BMEFnQVJBcElBRkJqQ3hxSVFFZ0FrRUJhaUlDSUFOSERRQUxJQUFvQXB3QkJTQUJDeEFKSUFCQkFEWUNuQUVMSUFBb0FuUWlBUVJBSUFBb0FuQWlBZ1JBUVFBaEFRTkFJQUFvQW5RZ0FVRURkR29vQWdBaUF3UkFJQU1RQ1NBQUtBSndJUUlMSUFGQkFXb2lBU0FDU1EwQUN5QUFLQUowSVFFTElBQkJBRFlDY0NBQkVBa2dBRUVBTmdKMEN5QUFLQUtJQVJBSklBQkJBRFlDZUNBQVFRQTJBb2dCSUFBb0FtUVFDU0FBUVFBMkFtUWdBQzBBdkFGQkFuRkZCRUFnQUNnQ3FBRVFDUXNnQUVIUUFHcEJBRUh3QUJBT0dpQUFLQUxBQVJBdElBQkJBRFlDd0FFZ0FDZ0N4QUVRTFNBQVFRQTJBc0FCSUFBb0FzZ0JJZ0VFUUNBQktBSWNJZ0lFUUNBQ0VBa2dBVUVBTmdJY0N5QUJLQUlvSWdJRVFDQUJLQUlrQkVBRFFDQUNJQVZCS0d3aUEyb29BaVFpQkFSQUlBUVFDU0FCS0FJb0lnSWdBMnBCQURZQ0pBc2dBaUFEYWlnQ0VDSUVCRUFnQkJBSklBRW9BaWdpQWlBRGFrRUFOZ0lRQ3lBQ0lBTnFLQUlZSWdRRVFDQUVFQWtnQVNnQ0tDSUNJQU5xUVFBMkFoZ0xJQVZCQVdvaUJTQUJLQUlrU1EwQUN3c2dBaEFKSUFGQkFEWUNLQXNnQVJBSkN5QUFRUUEyQXNnQklBQW9Ba2dRR0NBQVFRQTJBa2dnQUNnQ1RCQVlJQUJCQURZQ1RDQUFLQUxVQVNJREJFQUNRQ0FES0FJSVJRMEFJQU1vQWd3RVFDQURRUUEyQWlnRFFDQURLQUlZUVFCS0RRQUxDeUFEUVFFMkFoQWdBeWdDQUJBSklBTW9BaHdpQWtVTkFBTkFJQUlvQWdRaEFTQUNFQWtnQXlBQk5nSWNJQUVpQWcwQUN3c2dBeWdDSkNJQ0JFQWdBaWdDQkNJRlFRQktCRUJCQUNFQkEwQWdBaWdDQUNBQlFReHNhaUlFS0FJSUlnWUVRQ0FFS0FJRUlBWVJBZ0FnQWlnQ0JDRUZDeUFCUVFGcUlnRWdCVWdOQUFzTElBSW9BZ0FRQ1NBQ0VBa0xJQU1RQ1FzZ0FFRUFOZ0xVQVNBQUVBa0xDK1lEQWdoL0JINGdBQ2dDRkNnQ0FDZ0NGQ0FCUWN3QWJHb2lDU2dDRENJSUlBQW9BaGdvQWhnZ0FVRTBiR29pQ2pVQ0JDSVFRZ0Y5SWhJZ0FEVUNQSHdnRUlDbklnc2dDQ0FMU1JzaERDQUpLQUlJSWdnZ0NqVUNBQ0lSUWdGOUloTWdBRFVDT0h3Z0VZQ25JZ29nQ0NBS1NSc2hDaUFKS0FJRUlnZ2dFaUFBTlFJMGZDQVFnS2NpQ3lBSUlBdExHeUVMSUFrb0FnQWlDQ0FUSUFBMUFqQjhJQkdBcHlJTklBZ2dEVXNiSVExQkFDRUlJQUFvQWlBb0F0QXJJQUZCdUFoc2FpZ0NGQ0VPQWtBZ0NTZ0NGRUVBSUFKclFYOGdBaHRxSWdKRkJFQWdDaUVBSUEwaENDQUxJUUVNQVFzZ0EwRUJjU0FDUVFGcklnOTBJZ2tnRFVrRVFDQU5JQWxyclVKL0lBS3RJaENHUW4rRmZDQVFpS2NoQ0F0QkFDRUFRUUFoQVNBRFFRRjJJQTkwSWdNZ0Mwa0VRQ0FMSUFOcnJVSi9JQUt0SWhDR1FuK0ZmQ0FRaUtjaEFRc2dDU0FLU1FSQUlBb2dDV3V0UW44Z0FxMGlFSVpDZjRWOElCQ0lweUVBQ3lBRElBeFBCRUJCQUNFTURBRUxJQXdnQTJ1dFFuOGdBcTBpRUlaQ2Y0VjhJQkNJcHlFTUMwRi9JQUJCQWtFRElBNUJBVVliSWdKcUlnTWdBQ0FEU3hzZ0JFdEJmeUFDSUF4cUlnQWdBQ0FNU1JzZ0JVdHhJQWdnQW1zaUFFRUFJQUFnQ0UwYklBWkpjU0FCSUFKcklnQkJBQ0FBSUFGTkd5QUhTWEVMb2dFQkJuOGdBQVJBSUFBb0FnUWlBZ1JBSUFJUUNTQUFRUUEyQWdRTElBRUVRQ0FBSVFJRFFDQUNLQUxJQVNJREJFQkJBQ0VGSUFJb0FzUUJJZ1FFZndOQUlBTW9BZ3dpQmdSQUlBWVFDU0FEUVFBMkFnd2dBaWdDeEFFaEJBc2dBMEVRYWlFRElBVkJBV29pQlNBRVNRMEFDeUFDS0FMSUFRVWdBd3NRQ1NBQ1FRQTJBc2dCQ3lBQ1FmQUJhaUVDSUFkQkFXb2lCeUFCUncwQUN3c2dBQkFKQ3d2VkdRSVRmd043SUFBb0FnQWlDaUFBS0FJTUlnMUJCWFFpQldvaEJpQUtJQVZySVJZZ0FDZ0NFQ0VGSUFBb0Fod2hDeUFBS0FJVUlRa2dBQ2dDQ0NFT0FrQUNRQUpBQWtBZ0EwRUlTUTBBSUFGQkQzRU5BQ0FHUVE5eFJRMEJDeUFGSUFsUERRSUNRQUpBSUFOQkFXc09BZ0FCQXdzQ1FDQUpJQVZySWdoQkdFa05BQ0FCSUFWQkFuUnFJUWNnRFVFRmRDSUVJQW9nQlVFR2RHcHFJQUVnQ1VFQ2RHcEpCRUFnQnlBS0lBbEJCblJxSUFScVFUeHJTUTBCQ3lBRi9SSDlEQUFBQUFBQkFBQUFBZ0FBQUFNQUFBRDlyZ0VoR0NBRklBaEJmSEVpRDJvaEJVRUFJUVFEUUNBR0lCaEJCUDJyQVNJWC9Sc0FRUUowYWlBSElBUkJBblJxL1FBQ0FDSVovUjhBT0FJQUlBWWdGLzBiQVVFQ2RHb2dHZjBmQVRnQ0FDQUdJQmY5R3dKQkFuUnFJQm45SHdJNEFnQWdCaUFYL1JzRFFRSjBhaUFaL1I4RE9BSUFJQmo5REFRQUFBQUVBQUFBQkFBQUFBUUFBQUQ5cmdFaEdDQUVRUVJxSWdRZ0QwY05BQXNnQ0NBUFJnMEVDeUFGSVFRZ0NTQUZhMEVEY1NJSEJFQkJBQ0VJQTBBZ0JpQUVRUVowYWlBQklBUkJBblJxS2dJQU9BSUFJQVJCQVdvaEJDQUlRUUZxSWdnZ0IwY05BQXNMSUFVZ0NXdEJmRXNOQXdOQUlBWWdCRUVHZEdvZ0FTQUVRUUowYWlvQ0FEZ0NBQ0FHSUFSQkFXb2lCVUVHZEdvZ0FTQUZRUUowYWlvQ0FEZ0NBQ0FHSUFSQkFtb2lCVUVHZEdvZ0FTQUZRUUowYWlvQ0FEZ0NBQ0FHSUFSQkEyb2lCVUVHZEdvZ0FTQUZRUUowYWlvQ0FEZ0NBQ0FFUVFScUlnUWdDVWNOQUFzTUF3c2dBU0FDUVFKMGFpRUlBa0FnQ1NBRmF5SVBRVHhKQkVBZ0JTRUVEQUVMSUFvZ0JVRUdkQ0FOUVFWMGFtb2lCQ0FKSUFWQmYzTnFJZ2RCQm5RaUVHb2dCRWtFUUNBRklRUU1BUXNnQkVFRWFpSUVJQkJxSUFSSkJFQWdCU0VFREFFTElBZEIvLy8vSDBzRVFDQUZJUVFNQVFzZ0RVRUZkQ0lFSUFvZ0JVRUdkR3BxSWdjZ0FTQUNJQWxxUVFKMGFra2dDaUFKUVFaMGFpQUVha0U0YXlJRUlBRWdBaUFGYWtFQ2RHcExjUVJBSUFVaEJBd0JDeUFISUFFZ0NVRUNkR3BKSUFFZ0JVRUNkR29nQkVseEJFQWdCU0VFREFFTElBWDlFZjBNQUFBQUFBRUFBQUFDQUFBQUF3QUFBUDJ1QVNFWUlBVWdEMEY4Y1NJUWFpRUVRUUFoQndOQUlBWWdHRUVFL2FzQkloZjlHd0JCQW5ScUloRWdBU0FGSUFkcVFRSjBJZ3hxL1FBQ0FDSVovUjhBT0FJQUlBWWdGLzBiQVVFQ2RHb2lFeUFaL1I4Qk9BSUFJQVlnRi8wYkFrRUNkR29pRkNBWi9SOENPQUlBSUFZZ0YvMGJBMEVDZEdvaUZTQVovUjhET0FJQUlCRWdDQ0FNYXYwQUFnQWlGLzBmQURnQ0JDQVRJQmY5SHdFNEFnUWdGQ0FYL1I4Q09BSUVJQlVnRi8wZkF6Z0NCQ0FZL1F3RUFBQUFCQUFBQUFRQUFBQUVBQUFBL2E0QklSZ2dCMEVFYWlJSElCQkhEUUFMSUE4Z0VFWU5Bd3NnQkVFQmFpRUZJQWtnQkd0QkFYRUVRQ0FHSUFSQkJuUnFJZ2NnQVNBRVFRSjBJZ1JxS2dJQU9BSUFJQWNnQkNBSWFpb0NBRGdDQkNBRklRUUxJQVVnQ1VZTkFnTkFJQVlnQkVFR2RHb2lCU0FCSUFSQkFuUWlCMm9xQWdBNEFnQWdCU0FISUFocUtnSUFPQUlFSUFZZ0JFRUJhaUlGUVFaMGFpSUhJQUVnQlVFQ2RDSUZhaW9DQURnQ0FDQUhJQVVnQ0dvcUFnQTRBZ1FnQkVFQ2FpSUVJQWxIRFFBTERBSUxJQVVnQ1U4TkFTQUJJQUpCQW5ScUlRZ0RRQ0FHSUFWQkJuUnFJZ1FnQVNBRlFRSjBhaW9DQURnQ0FDQUVJQUVnQWlBRmFpSUhRUUowYWlvQ0FEZ0NCQ0FFSUFFZ0FpQUhhaUlIUVFKMGFpb0NBRGdDQ0NBRUlBRWdBaUFIYWlJSFFRSjBhaW9DQURnQ0RDQUVJQUVnQWlBSGFpSUhRUUowYWlvQ0FEZ0NFQ0FFSUFFZ0FpQUhhaUlIUVFKMGFpb0NBRGdDRkNBRUlBRWdBaUFIYWtFQ2RDSUhhaW9DQURnQ0dDQUVJQWNnQ0dvcUFnQTRBaHdnQlVFQmFpSUZJQWxIRFFBTERBRUxJQUVnQWtFQ2RHb2hDQ0FEUVFOR0lRY2dBMEVFUmlFUElBTkJCVVloRUNBRFFRZEdJUkVEUUNBR0lBVkJCblJxSWdRZ0FTQUZRUUowYWlvQ0FEZ0NBQ0FFSUFFZ0FpQUZhaUlNUVFKMGFpb0NBRGdDQkNBRUlBRWdBaUFNYWlJTVFRSjBhaW9DQURnQ0NBSkFJQWNOQUNBRUlBRWdBaUFNYWlJTVFRSjBhaW9DQURnQ0RDQVBEUUFnQkNBQklBSWdER29pREVFQ2RHb3FBZ0E0QWhBZ0VBMEFJQVFnQVNBQ0lBeHFJZ3hCQW5ScUtnSUFPQUlVSUFOQkJrWU5BQ0FFSUFFZ0FpQU1ha0VDZENJTWFpb0NBRGdDR0NBUkRRQWdCQ0FJSUF4cUtnSUFPQUljQ3lBRlFRRnFJZ1VnQ1VjTkFBc0xJQlpCSUdvaEJpQUJJQTVCQW5ScUlRUWdBQ2dDR0NFRkFrQUNRQUpBSUFOQkNFa05BQ0FFUVE5eERRQWdCa0VQY1VVTkFRc2dCU0FMVHcwQkFrQUNRQUpBSUFOQkFXc09BZ0FCQWdzQ1FDQUxJQVZySWdCQkhFa05BQ0FLSUFWQkJuUkJJSElnRFVFRmRDSUNhMm9nQVNBTElBNXFRUUowYWtrRVFDQUJJQVVnRG1wQkFuUnFJQXRCQm5RZ0Ftc2dDbXBCSEd0SkRRRUxJQVFnQlVFQ2RHb2hBeUFGL1JIOURBQUFBQUFCQUFBQUFnQUFBQU1BQUFEOXJnRWhHQ0FGSUFCQmZIRWlBV29oQlVFQUlRSURRQ0FHSUJoQkJQMnJBU0lYL1JzQVFRSjBhaUFESUFKQkFuUnEvUUFDQUNJWi9SOEFPQUlBSUFZZ0YvMGJBVUVDZEdvZ0dmMGZBVGdDQUNBR0lCZjlHd0pCQW5ScUlCbjlId0k0QWdBZ0JpQVgvUnNEUVFKMGFpQVovUjhET0FJQUlCajlEQVFBQUFBRUFBQUFCQUFBQUFRQUFBRDlyZ0VoR0NBQ1FRUnFJZ0lnQVVjTkFBc2dBQ0FCUmcwRUN5QUZJUUlnQ3lBRmEwRURjU0lBQkVCQkFDRUJBMEFnQmlBQ1FRWjBhaUFFSUFKQkFuUnFLZ0lBT0FJQUlBSkJBV29oQWlBQlFRRnFJZ0VnQUVjTkFBc0xJQVVnQzJ0QmZFc05Bd05BSUFZZ0FrRUdkR29nQkNBQ1FRSjBhaW9DQURnQ0FDQUdJQUpCQVdvaUFFRUdkR29nQkNBQVFRSjBhaW9DQURnQ0FDQUdJQUpCQW1vaUFFRUdkR29nQkNBQVFRSjBhaW9DQURnQ0FDQUdJQUpCQTJvaUFFRUdkR29nQkNBQVFRSjBhaW9DQURnQ0FDQUNRUVJxSWdJZ0MwY05BQXNNQXdzZ0JDQUNRUUowYWlFREFrQWdDeUFGYXlJQVFjUUFTUVJBSUFVaEFnd0JDeUFLSUFWQkJuUWlDVUVnY2lBTlFRVjBJZ2hyYWlJSElBc2dCVUYvYzJvaUQwRUdkQ0lRYWlBSFNRUkFJQVVoQWd3QkN5QUtJQWxCSkhJZ0NHdHFJZ2tnRUdvZ0NVa0VRQ0FGSVFJTUFRc2dEMEgvLy84ZlN3UkFJQVVoQWd3QkN5QUtJQVZCQm5SQklISWdEVUVGZENJSmEyb2lEU0FCSUFzZ0Rtb2lDQ0FDYWtFQ2RHcEpJQXRCQm5RZ0NXc2dDbXBCR0dzaUNTQUJJQTVCQW5ScUlBVkJBblJxSWdvZ0FrRUNkR3BMY1FSQUlBVWhBZ3dCQ3lBTklBRWdDRUVDZEdwSklBa2dDa3R4QkVBZ0JTRUNEQUVMSUFYOUVmME1BQUFBQUFFQUFBQUNBQUFBQXdBQUFQMnVBU0VZSUFVZ0FFRjhjU0lKYWlFQ1FRQWhBUU5BSUFZZ0dFRUUvYXNCSWhmOUd3QkJBblJxSWdvZ0JDQUJJQVZxUVFKMElnMXEvUUFDQUNJWi9SOEFPQUlBSUFZZ0YvMGJBVUVDZEdvaURpQVovUjhCT0FJQUlBWWdGLzBiQWtFQ2RHb2lDQ0FaL1I4Q09BSUFJQVlnRi8wYkEwRUNkR29pQnlBWi9SOERPQUlBSUFvZ0F5QU5hdjBBQWdBaUYvMGZBRGdDQkNBT0lCZjlId0U0QWdRZ0NDQVgvUjhDT0FJRUlBY2dGLzBmQXpnQ0JDQVkvUXdFQUFBQUJBQUFBQVFBQUFBRUFBQUEvYTRCSVJnZ0FVRUVhaUlCSUFsSERRQUxJQUFnQ1VZTkF3c2dBa0VCYWlFQUlBc2dBbXRCQVhFRVFDQUdJQUpCQm5ScUlnRWdCQ0FDUVFKMElnSnFLZ0lBT0FJQUlBRWdBaUFEYWlvQ0FEZ0NCQ0FBSVFJTElBQWdDMFlOQWdOQUlBWWdBa0VHZEdvaUFDQUVJQUpCQW5RaUFXb3FBZ0E0QWdBZ0FDQUJJQU5xS2dJQU9BSUVJQVlnQWtFQmFpSUFRUVowYWlJQklBUWdBRUVDZENJQWFpb0NBRGdDQUNBQklBQWdBMm9xQWdBNEFnUWdBa0VDYWlJQ0lBdEhEUUFMREFJTElBUWdBa0VDZEdvaEFTQURRUU5HSVFrZ0EwRUVSaUVLSUFOQkJVWWhEU0FEUVFkR0lRNERRQ0FHSUFWQkJuUnFJZ0FnQkNBRlFRSjBhaW9DQURnQ0FDQUFJQVFnQWlBRmFpSUlRUUowYWlvQ0FEZ0NCQ0FBSUFRZ0FpQUlhaUlJUVFKMGFpb0NBRGdDQ0FKQUlBa05BQ0FBSUFRZ0FpQUlhaUlJUVFKMGFpb0NBRGdDRENBS0RRQWdBQ0FFSUFJZ0NHb2lDRUVDZEdvcUFnQTRBaEFnRFEwQUlBQWdCQ0FDSUFocUlnaEJBblJxS2dJQU9BSVVJQU5CQmtZTkFDQUFJQVFnQWlBSWFrRUNkQ0lJYWlvQ0FEZ0NHQ0FPRFFBZ0FDQUJJQWhxS2dJQU9BSWNDeUFGUVFGcUlnVWdDMGNOQUFzTUFRc2dCU0FMVHcwQUlBUWdBa0VDZEdvaEFRTkFJQVlnQlVFR2RHb2lBQ0FFSUFWQkFuUnFLZ0lBT0FJQUlBQWdCQ0FDSUFWcUlnTkJBblJxS2dJQU9BSUVJQUFnQkNBQ0lBTnFJZ05CQW5ScUtnSUFPQUlJSUFBZ0JDQUNJQU5xSWdOQkFuUnFLZ0lBT0FJTUlBQWdCQ0FDSUFOcUlnTkJBblJxS2dJQU9BSVFJQUFnQkNBQ0lBTnFJZ05CQW5ScUtnSUFPQUlVSUFBZ0JDQUNJQU5xUVFKMElnTnFLZ0lBT0FJWUlBQWdBU0FEYWlvQ0FEZ0NIQ0FGUVFGcUlnVWdDMGNOQUFzTEM1c0RBUVIvSUFFZ0FFRUVhaUlFYWtFQmEwRUFJQUZyY1NJRklBSnFJQUFnQUNnQ0FDSUJha0VFYTAwRWZ5QUFLQUlFSWdNZ0FDZ0NDQ0lHTmdJSUlBWWdBellDQkNBRUlBVkhCRUFnQUNBQVFRUnJLQUlBUVg1eGF5SURJQVVnQkdzaUJDQURLQUlBYWlJRk5nSUFJQU1nQlVGOGNXcEJCR3NnQlRZQ0FDQUFJQVJxSWdBZ0FTQUVheUlCTmdJQUN3Si9JQUVnQWtFWWFrOEVRQ0FBSUFKcVFRaHFJZ01nQVNBQ2EwRUlheUlCTmdJQUlBTWdBVUY4Y1dwQkJHc2dBVUVCY2pZQ0FDQURBbjhnQXlnQ0FFRUlheUlCUWY4QVRRUkFJQUZCQTNaQkFXc01BUXNnQVdjaEJDQUJRUjBnQkd0MlFRUnpJQVJCQW5SclFlNEFhaUFCUWY4ZlRRMEFHa0UvSUFGQkhpQUVhM1pCQW5NZ0JFRUJkR3RCeHdCcUlnRWdBVUUvVHhzTElnRkJCSFFpQkVHZ3hnRnFOZ0lFSUFNZ0JFR294Z0ZxSWdRb0FnQTJBZ2dnQkNBRE5nSUFJQU1vQWdnZ0F6WUNCRUdvemdGQnFNNEJLUU1BUWdFZ0FhMkdoRGNEQUNBQUlBSkJDR29pQVRZQ0FDQUFJQUZCZkhGcURBRUxJQUFnQVdvTFFRUnJJQUUyQWdBZ0FFRUVhZ1ZCQUFzTHdnRUJBMzhDUUNBQklBSW9BaEFpQXdSL0lBTUZJQUlRTncwQklBSW9BaEFMSUFJb0FoUWlCR3RMQkVBZ0FpQUFJQUVnQWlnQ0pCRUFBQThMQWtBQ1FDQUNLQUpRUVFCSURRQWdBVVVOQUNBQklRTURRQ0FBSUFOcUlnVkJBV3N0QUFCQkNrY0VRQ0FEUVFGcklnTU5BUXdDQ3dzZ0FpQUFJQU1nQWlnQ0pCRUFBQ0lFSUFOSkRRSWdBU0FEYXlFQklBSW9BaFFoQkF3QkN5QUFJUVZCQUNFREN5QUVJQVVnQVJBTEdpQUNJQUlvQWhRZ0FXbzJBaFFnQVNBRGFpRUVDeUFFQzFrQkFYOGdBQ0FBS0FKSUlnRkJBV3NnQVhJMkFrZ2dBQ2dDQUNJQlFRaHhCRUFnQUNBQlFTQnlOZ0lBUVg4UEN5QUFRZ0EzQWdRZ0FDQUFLQUlzSWdFMkFod2dBQ0FCTmdJVUlBQWdBU0FBS0FJd2FqWUNFRUVBQzh3Q0FRUi9JQUVnQVAwQUFnRDlDd0lBSUFFb0FoZ2lBZ1JBSUFFb0FoQWlBd1IvUVFBaEFnTkFJQUVvQWhnZ0FrRTBiR29vQWl3aUJBUkFJQVFRQ1NBQktBSVFJUU1MSUFKQkFXb2lBaUFEU1EwQUN5QUJLQUlZQlNBQ0N4QUpJQUZCQURZQ0dBc2dBU0FBS0FJUUlnSTJBaEFnQVNBQ1FUUnNFQTBpQWpZQ0dDQUNCRUFnQVNnQ0VBUkFRUUFoQXdOQUlBSWdBMEUwYkNJRmFpSUNJQUFvQWhnZ0JXb2lCUDBBQWdEOUN3SUFJQUlnQkNnQ01EWUNNQ0FDSUFUOUFBSWcvUXNDSUNBQ0lBVDlBQUlRL1FzQ0VDQUJLQUlZSWdJZ0JXcEJBRFlDTENBRFFRRnFJZ01nQVNnQ0VFa05BQXNMSUFFZ0FDZ0NGRFlDRkNBQklBQW9BaUFpQWpZQ0lDQUNCRUFnQVNBQ0VBMGlBallDSENBQ1JRUkFJQUZDQURjQ0hBOExJQUlnQUNnQ0hDQUFLQUlnRUFzYUR3c2dBVUVBTmdJY0R3c2dBVUVBTmdJUUlBRkJBRFlDR0FzRUFFRUJDOFlCQVFOL0EwQWdBRUVFZENJQlFhVEdBV29nQVVHZ3hnRnFJZ0kyQWdBZ0FVR294Z0ZxSUFJMkFnQWdBRUVCYWlJQVFjQUFSdzBBQzBFd0VHWWFJd0JCRUdzaUFDUUFBa0FnQUVFTWFpQUFRUWhxRUFNTkFFR3d6Z0ZCQ0NBQUtBSU1RUUowUVFScUVCc2lBVFlDQUNBQlJRMEFRUWdnQUNnQ0NCQWJJZ0VFUUVHd3pnRW9BZ0FpQWlBQUtBSU1RUUowYWtFQU5nSUFJQUlnQVJBQ1JRMEJDMEd3emdGQkFEWUNBQXNnQUVFUWFpUUFRY3pPQVVFcU5nSUFRWlRQQVVIWXp3RTJBZ0FMa0FZQ0JYOERleU1BUVJCcklnWWtBQUovSUFBb0FnaEJFRVlFUUNBQUtBS2NBU0FBS0FMTUFVR01MR3hxREFFTElBQW9BZ3dMSVFBQ1FDQURLQUlBSWdWRkJFQkJBQ0VDSUFSQkFVSEFFMEVBRUFnTUFRc2dBQ2dDMENzaENTQURJQVZCQVdzMkFnQWdBaUFHUVF4cVFRRVFDaUFKSUFGQnVBaHNhaUlISUFZb0Fnd2lBRUVGZGpZQ3BBWWdCeUFBUVI5eElnRTJBaGdnQWtFQmFpRUFJQU1DZndKL0FrQUNmd0pBQWtBZ0FRNENBQU1CQ3lBREtBSUFEQUVMSUFNb0FnQkJBWFlMSWdWQjRnQlBCSDhnQmtMaGdJQ0FrQXczQWdRZ0JpQUZOZ0lBSUFSQkFrSFYrQUFnQmhBSUlBY29BaGdGSUFFTEJFQWdCU0lCRFFGQkFBd0NDeUFGQkVBZ0IwRWNhaUVCUVFBaEFnTkFJQUFnQmtFTWFrRUJFQW9nQWtIZ0FFMEVRQ0FHS0FJTUlRUWdBU0FDUVFOMGFpSUlRUUEyQWdRZ0NDQUVRUU4yTmdJQUN5QUFRUUZxSVFBZ0FrRUJhaUlDSUFWSERRQUxDMEVBSVFJZ0F5Z0NBQ0lBSUFWSkRRTWdBQ0FGYXd3Q0N5QUhRUnhxSVFSQkFDRUNBMEFnQUNBR1FReHFRUUlRQ2lBQ1FlQUFUUVJBSUFRZ0FrRURkR29pQlNBR0tBSU1JZ2hCL3c5eE5nSUVJQVVnQ0VFTGRqWUNBQXNnQUVFQ2FpRUFJQUpCQVdvaUFpQUJSdzBBQ3lBQlFRRjBDeUVBUVFBaEFpQURLQUlBSWdFZ0FFa05BU0FCSUFCckN6WUNBRUVCSVFJZ0J5Z0NHRUVCUncwQUlBZEJIR29oQkNBSC9Ra0NIQ0VNSUFjb0FpQWhBLzBNQVFBQUFBSUFBQUFEQUFBQUJBQUFBQ0VMUVFBaEFRTkFJQVFnQVVFRGRHb2lBRUVZYWlBTUlBdjlEUC8vLy8vLy8vLy8vLy8vLy8vLy8vLzlyZ0VpQ3YwYkFFRURidjBSSUFyOUd3RkJBMjc5SEFFZ0N2MGJBa0VEYnYwY0FpQUsvUnNEUVFOdS9Sd0QvYkVCL1F3QUFBQUFBQUFBQUFBQUFBQUFBQUFBL2JnQklncjlXZ0lBQWlBQVFSQnFJQXI5V2dJQUFTQUFRUWhxSUFyOVdnSUFBQ0FFSUFGQkJHb2lBVUVEZEdvaUJTQUsvVm9DQUFNZ0FDQUROZ0ljSUFBZ0F6WUNGQ0FBSUFNMkFnd2dCU0FETmdJRUlBdjlEQVFBQUFBRUFBQUFCQUFBQUFRQUFBRDlyZ0VoQ3lBQlFlQUFSdzBBQ3dzZ0JrRVFhaVFBSUFJTG53WUJCbjhqQUVFZ2F5SUdKQUFDZnlBQUtBSUlRUkJHQkVBZ0FDZ0NuQUVnQUNnQ3pBRkJqQ3hzYWd3QkN5QUFLQUlNQ3lFRkFrQWdBeWdDQUVFRVRRUkFRUUFoQUNBRVFRRkJuUk5CQUJBSURBRUxJQUlnQlNnQzBDc2dBVUc0Q0d4cUlnVWlDVUVFYWtFQkVBb2dCU0FGS0FJRVFRRnFJZ2MyQWdRZ0IwRWlUd1JBSUFaQklUWUNCQ0FHSUFjMkFnQWdCRUVCUWZrNUlBWVFDRUVBSVFBTUFRc2dCeUFBS0FLZ0FTSUlUUVJBSUFZZ0J6WUNHQ0FHSUFnMkFoUWdCaUFCTmdJUUlBUkJBVUhFK3dBZ0JrRVFhaEFJSUFBZ0FDZ0NDRUdBZ0FKeU5nSUlRUUFoQUF3QkN5QUNRUUZxSUFWQkNHcEJBUkFLSUFVZ0JTZ0NDRUVDYWpZQ0NDQUNRUUpxSUFWQkRHcEJBUkFLSUFVZ0JTZ0NERUVDYWlJQU5nSU1Ba0FDUUNBRktBSUlJZ0ZCQ2tzTkFDQUFRUXBMRFFBZ0FDQUJha0VOU1EwQkMwRUFJUUFnQkVFQlFjTXBRUUFRQ0F3QkN5QUNRUU5xSUFWQkVHcEJBUkFLSUFVdEFCQkJnQUZ4QkVCQkFDRUFJQVJCQVVHTE1rRUFFQWdNQVFzZ0FrRUVhaUFGUVJScVFRRVFDaUFGS0FJVVFRSlBCRUJCQUNFQUlBUkJBVUhLTVVFQUVBZ01BUXNnQXlBREtBSUFRUVZySWdjMkFnQkJBU0VBSUFVb0FnUWhBU0FGTFFBQVFRRnhSUVJBSUFGRkRRRWdCVUd3QjJvaEFTQUZRYXdHYWlFQ1FRQWhCUU5BSUFJZ0JVRUNkQ0lBYWtFUE5nSUFJQUFnQVdwQkR6WUNBRUVCSVFBZ0JVRUJhaUlGSUFrb0FnUkpEUUFMREFFTElBRWdCMDBFUUFKQUlBRkZCRUJCQUNFQkRBRUxJQUpCQldvZ0JrRWNha0VCRUFvZ0JTQUdLQUljSWdCQkJIWTJBckFISUFVZ0FFRVBjVFlDckFZZ0JTZ0NCQ0lCUVFKUEJFQWdCVUd3QjJvaEJ5QUZRYXdHYWlFSUlBSkJCbW9oQUVFQklRVURRQ0FBSUFaQkhHcEJBUkFLQWtBZ0JpZ0NIQ0lCUVJCUEJFQWdBVUVQY1NJQ0RRRUxRUUFoQUNBRVFRRkI4QzFCQUJBSURBVUxJQWdnQlVFQ2RDSUthaUFDTmdJQUlBY2dDbW9nQVVFRWRqWUNBQ0FBUVFGcUlRQWdCVUVCYWlJRklBa29BZ1FpQVVrTkFBc0xJQU1vQWdBaEJ3c2dBeUFISUFGck5nSUFRUUVoQUF3QkMwRUFJUUFnQkVFQlFaMFRRUUFRQ0FzZ0JrRWdhaVFBSUFBTFVnQWdBU0FBTFFBQU9nQUhJQUVnQUMwQUFUb0FCaUFCSUFBdEFBSTZBQVVnQVNBQUxRQURPZ0FFSUFFZ0FDMEFCRG9BQXlBQklBQXRBQVU2QUFJZ0FTQUFMUUFHT2dBQklBRWdBQzBBQnpvQUFBdVNBUUVFZnlBQUlBRTJBcUFCQWtBZ0FDZ0NTQ0lEUlEwQUlBTW9BaGdpQmtVTkFDQUFLQUlNSWdSRkRRQWdCQ2dDMEN0RkRRQWdBeWdDRUNJRVJRUkFRUUVQQzBFQUlRTURRQ0FCSUFBb0Fnd29BdEFySUFOQnVBaHNhaWdDQkU4RVFDQUNRUUZCbzhRQVFRQVFDRUVBRHdzZ0JpQURRVFJzYWlBQk5nSW9RUUVoQlNBRFFRRnFJZ01nQkVjTkFBc0xJQVVMckFjQ0NYOElmaU1BUVJCcklnb2tBQUpBSUFKRkJFQWdBMEVCUVlyV0FFRUFFQWdNQVFzZ0FpZ0NFQ0lMSUFBb0FrZ2lCaWdDRUVrRVFDQURRUUZCa000QVFRQVFDQXdCQ3lBRUlBQW9BbWdpQlNBQUtBSnNiQ0lIVHdSQUlBb2dCRFlDQUNBS0lBZEJBV3MyQWdRZ0EwRUJRWWY3QUNBS0VBaEJBQ0VGREFFTElBSWdBQ2dDVkNBRUlBVWdCQ0FGYmlJSGJHc2lDQ0FBS0FKY2JHb2lCVFlDQUNBQ0lBVWdCaWdDQUNJR0lBVWdCa3NiSWdZMkFnQWdBaUFBS0FKVUlBQW9BbHdnQ0VFQmFteHFJZ1UyQWdnZ0FpQUZJQUFvQWtnb0FnZ2lDQ0FGSUFoSkd5SUlOZ0lJSUFJZ0FDZ0NXQ0FBS0FKZ0lBZHNhaUlGTmdJRUlBSWdCU0FBS0FKSUtBSUVJZ2tnQlNBSlN4c2lDVFlDQkNBQ0lBQW9BbGdnQUNnQ1lDQUhRUUZxYkdvaUJUWUNEQ0FDSUFVZ0FDZ0NTQ2dDRENJSElBVWdCMGtiSWdVMkFnd2dBQ2dDU0NJTUtBSVFJZ2NFUUNBRnJFSUJmU0VSSUFpc1FnRjlJUklnQ2ExQ0FYMGhFeUFHclVJQmZTRVVJQXdvQWhnaENDQUNLQUlZSVFWQkFDRUdBMEFnQlNBSUlBWkJOR3hxS0FJb0lnazJBaWdnQlNBVUlBVW9BZ0FpREswaURud2dEb0FpRlQ0Q0VDQUZJQk1nQlNnQ0JDSU5yU0lPZkNBT2dDSVFQZ0lVSUFWQ2Z5QUpyU0lPaGlJUElCREVmU0FPaDZjZ0R5QVJJQTJzSWhCOElCQi94SDBnRG9lbmF6WUNEQ0FGSUE4Z0ZjUjlJQTZIcHlBUElCSWdES3dpRDN3Z0QzL0VmU0FPaDZkck5nSUlJQVZCTkdvaEJTQUdRUUZxSWdZZ0IwY05BQXNMSUFjZ0Mwa0VRQ0FDS0FJWUlRVURRQ0FGSUFkQk5Hd2lCbW9vQWl3UUNTQUNLQUlZSWdVZ0JtcEJBRFlDTENBSFFRRnFJZ2NnQWlnQ0VFa05BQXNnQWlBQUtBSklLQUlRTmdJUUN5QUFLQUpNSWdVRVFDQUZFQmdMSUFCQkFVRWtFQXdpQnpZQ1RFRUFJUVVnQjBVTkFDQUNJQWNRT0NBQUlBUTJBaXdnQUNnQ3dBRkJGeUFERUI1RkRRQWdBQ2dDd0FFaUJDZ0NBQ0VHSUFRb0FnZ2hCd0pBSUFZRVFFRUJJUVVnQmtFQmNTRUxJQVpCQVVZRWYwRUFCU0FHUVg1eElRaEJBQ0VHQTBBQ2YwRUFJQVZGRFFBYVFRQWdBQ0FCSUFNZ0J5Z0NBQkVBQUVVTkFCb2dBQ0FCSUFNZ0J5Z0NCQkVBQUVFQVJ3c2hCU0FIUVFocUlRY2dCa0VDYWlJR0lBaEhEUUFMSUFWQkFYTUxJUVlDUUFKQUlBc0VRQ0FHRFFFZ0FDQUJJQU1nQnlnQ0FCRUFBRUVBUnlFRkN5QUVRUUEyQWdBZ0JVRUJjVVVOQVF3REN5QUVRUUEyQWdBTElBQW9Ba2dRR0VFQUlRVWdBRUVBTmdKSURBSUxJQVJCQURZQ0FBc2dBQ0FDRUVBaEJRc2dDa0VRYWlRQUlBVUw4Z01CQlg4Q1FBSkFJQUFvQWp3aUFrVUVRQ0FCS0FJUURRRkJBUThMSUFKQk5Hd1FEU0lGUlEwQklBRW9BaEFFUUNBQktBSVlJUUlEUUNBQ0lBTkJOR3dpQkdvb0Fpd1FDU0FCS0FJWUlnSWdCR3BCQURZQ0xDQURRUUZxSWdNZ0FTZ0NFQ0lFU1EwQUN3c2dBU0FBS0FJOEJIOGdBQ2dDVENnQ0dDRURRUUFoQWdOQUlBVWdBa0UwYkdvaUJDQURJQUFvQWtBZ0FrRUNkR29vQWdCQk5Hd2lCbW9pQS8wQUFnRDlDd0lBSUFRZ0F5Z0NNRFlDTUNBRUlBUDlBQUlnL1FzQ0lDQUVJQVA5QUFJUS9Rc0NFQ0FFSUFBb0Frd29BaGdpQXlBR2FpSUdLQUlrTmdJa0lBUWdCaWdDTERZQ0xDQUdRUUEyQWl3Z0FrRUJhaUlDSUFBb0Fqd2lCa2tOQUFzZ0FTZ0NFQVVnQkFzRWZ5QUFLQUpNS0FJWUlRSkJBQ0VEQTBBZ0FpQURRVFJzSWdScUtBSXNFQWtnQUNnQ1RDZ0NHQ0lDSUFScVFRQTJBaXdnQTBFQmFpSURJQUVvQWhCSkRRQUxJQUFvQWp3RklBWUxOZ0lRSUFFb0FoZ1FDU0FCSUFVMkFoaEJBUThMSUFFb0FoZ2hCQ0FBS0FKTUtBSVlJUU5CQUNFQ0EwQWdCQ0FDUVRSc0lnVnFJZ1FnQXlBRmFpZ0NKRFlDSkNBRUtBSXNFQWtnQVNnQ0dDSUVJQVZxSUFBb0Frd29BaGdpQXlBRmFpSUZLQUlzTmdJc0lBVkJBRFlDTENBQ1FRRnFJZ0lnQVNnQ0VFa05BQXRCQVE4TElBQW9Ba2dRR0NBQVFRQTJBa2hCQUF2T0JBRUlmd0pBSUFKRkRRQUNRQ0FBS0FLZ0FTSUZSUTBBSUFBb0FrZ2lCRVVOQUNBRUtBSVFSUTBBSUFRb0FoZ29BaWdnQlVjTkFDQUNLQUlRSWdoRkRRQWdBaWdDR0NJR0tBSW9EUUFnQmlnQ0xBMEFRUUFoQkNBSVFRaFBCRUFnQ0VGNGNTRUpBMEFnQmlBRVFUUnNhaUFGTmdJb0lBWWdCRUVCY2tFMGJHb2dCVFlDS0NBR0lBUkJBbkpCTkd4cUlBVTJBaWdnQmlBRVFRTnlRVFJzYWlBRk5nSW9JQVlnQkVFRWNrRTBiR29nQlRZQ0tDQUdJQVJCQlhKQk5HeHFJQVUyQWlnZ0JpQUVRUVp5UVRSc2FpQUZOZ0lvSUFZZ0JFRUhja0UwYkdvZ0JUWUNLQ0FFUVFocUlRUWdDa0VJYWlJS0lBbEhEUUFMQ3lBSVFRZHhJZ2dFUUFOQUlBWWdCRUUwYkdvZ0JUWUNLQ0FFUVFGcUlRUWdDMEVCYWlJTElBaEhEUUFMQ3lBQ0lBTVFNQTBBUVFBUEN5QUFLQUpNSWdWRkJFQWdBRUVCUVNRUURDSUZOZ0pNSUFWRkRRRUxJQUlnQlJBNElBQW9Bc0FCUVJZZ0F4QWVSUTBBSUFBb0FzQUJJZ1lvQWdBaEJDQUdLQUlJSVFVQ1FDQUVCRUJCQVNFSElBUkJBWEVoQ0NBRVFRRkdCSDlCQUFVZ0JFRitjU0VKUVFBaEJBTkFBbjlCQUNBSFJRMEFHa0VBSUFBZ0FTQURJQVVvQWdBUkFBQkZEUUFhSUFBZ0FTQURJQVVvQWdRUkFBQkJBRWNMSVFjZ0JVRUlhaUVGSUFSQkFtb2lCQ0FKUncwQUN5QUhRUUZ6Q3lFRUFrQUNRQ0FJQkVBZ0JBMEJJQUFnQVNBRElBVW9BZ0FSQUFCQkFFY2hCd3NnQmtFQU5nSUFJQWRCQVhGRkRRRU1Bd3NnQmtFQU5nSUFDeUFBS0FKSUVCZ2dBRUVBTmdKSVFRQVBDeUFHUVFBMkFnQUxJQUFnQWhCQUlRY0xJQWNMK0FRQkJuOENRRUVCUVRBUURDSUNCSDhnQWlBQUtBTElBU0lCL1FBREFQMExBd0FnQWlBQktRTVFOd01RSUFJZ0FTZ0NHQ0lCTmdJWUlBSWdBVUVZYkJBTklnRTJBaHdnQVVVRVFDQUNFQWxCQUE4TEFrQWdBQ2dDeUFFb0Fod2lBd1JBSUFFZ0F5QUNLQUlZUVJoc0VBc2FEQUVMSUFFUUNTQUNRUUEyQWh3TElBSWdBQ2dDeUFFb0FpUWlBVFlDSkNBQ0lBRkJLQkFNSWdFMkFpZ2dBVVVFUUNBQ0tBSWNFQWtnQWhBSlFRQVBDd0pBSUFBb0FzZ0JLQUlvQkVBZ0FpZ0NKRVVOQVFOQUlBRWdCVUVvYkNJRGFpQUFLQUxJQVNnQ0tDQURhaWdDRkNJQk5nSVVJQUZCR0d3UURTRUJJQUlvQWlnaUJDQURhaUlHSUFFMkFoZ2dBVVVFUUNBRkJIOUJBQ0VCQTBBZ0FpZ0NLQ0FCUVNoc2FpZ0NHQkFKSUFGQkFXb2lBU0FGUncwQUN5QUNLQUlvQlNBRUN4QUpEQVVMQWtBZ0FDZ0N5QUVvQWlnZ0Eyb29BaGdpQkFSQUlBRWdCQ0FHS0FJVVFSaHNFQXNhSUFJb0FpZ2hBUXdCQ3lBQkVBa2dBaWdDS0NJQklBTnFRUUEyQWhnTElBRWdBMm9nQUNnQ3lBRW9BaWdnQTJvb0FnUWlBVFlDQkNBQlFSaHNFQTBoQVNBQ0tBSW9JZ1FnQTJvaUJpQUJOZ0lRSUFGRkJFQWdCUVIvUVFBaEFRTkFJQUZCS0d3aUFDQUNLQUlvYWlnQ0dCQUpJQUlvQWlnZ0FHb29BaEFRQ1NBQlFRRnFJZ0VnQlVjTkFBc2dBaWdDS0FVZ0JBc1FDUXdGQ3dKQUlBQW9Bc2dCS0FJb0lBTnFLQUlRSWdRRVFDQUJJQVFnQmlnQ0JFRVliQkFMR2lBQ0tBSW9JUUVNQVFzZ0FSQUpJQUlvQWlnaUFTQURha0VBTmdJUUN5QUJJQU5xUWdBM0FpQWdCVUVCYWlJRklBSW9BaVJKRFFBTERBRUxJQUVRQ1NBQ1FRQTJBaWdMSUFJRlFRQUxEd3NnQWlnQ0hCQUpJQUlRQ1VFQUM2QUdBZzUvQVhzakFFRVFheUlJSkFBZ0FDZ0NTQ2dDRUNFTklBaEJBVUU0RUF3aUFUWUNEQUpBSUFGRkRRQWdBU0FBS0FKSUtBSVFJZ2syQWhnZ0FTQUEvUUFDVlAwTEFnQWdBU0FBS0FKb05nSVFJQUFvQW13aEFpQUJRUUEyQWpRZ0FTQUNOZ0lVSUFFZ0FDZ0NEQ0lNS0FJQU5nSWdJQUVnRENnQ0JEWUNKQ0FCSUF3b0FnZzJBaWdnQVNBTUtBSVFOZ0lzSUFFZ0NVRzRDQkFNSWdBMkFqQWdBQVJBSUEwRVFBTkFJQTVCdUFoc0lnQWdBU2dDTUdvaUJTQU1LQUxRS3lBQWFpSUUvUUFDQUNJUC9Rc0NCQ0FGSUFRb0FoQTJBaFFnQlNBRUtBSVVOZ0lZSUEvOUd3RWlBRUVnVFFSQUlBVkJ0QWRxSUFSQnNBZHFJQUFRQ3hvZ0JVR3dCbW9nQkVHc0Jtb2dCQ2dDQkJBTEdnc2dCU0FFS0FJWUlnQTJBaHdnQlNBRUtBS2tCallDcUFaQkFTRUdBa0FnQUVFQlJ3UkFJQVFvQWdSQkEyd2lBRUVEYTBIZkFFc05BU0FBUVFKcklRWUxJQVZCcEFOcUlRa2dCVUVnYWlFS0lBUkJIR29oQzBFQUlRQUNRQ0FHUVFoSkRRQWdCQ0FHUVFOMGFrRWNhaUFLU3dSQUlBc2dCU0FHUVFKMGFrR2tBMnBKRFFFTElBWkJmSEVoQUVFQUlRSURRQ0FLSUFKQkFuUWlBMm9nQ3lBQ1FRTjBhaUlIUVJ4cUlBZEJGR29nQjBFTWFpQUgvUWtDQlAxV0FnQUIvVllDQUFMOVZnSUFBLzBMQWdBZ0F5QUphaUFIUVJocUlBZEJFR29nQjBFSWFpQUgvUWtDQVAxV0FnQUIvVllDQUFMOVZnSUFBLzBMQWdBZ0FrRUVhaUlDSUFCSERRQUxJQUFnQmtZTkFRc2dBRUVCY2lFRElBWkJBWEVFUUNBS0lBQkJBblFpQW1vZ0N5QUFRUU4wYWlJQUtBSUVOZ0lBSUFJZ0NXb2dBQ2dDQURZQ0FDQURJUUFMSUFNZ0JrWU5BQU5BSUFvZ0FFRUNkQ0lDYWlBTElBQkJBM1JxSWdNb0FnUTJBZ0FnQWlBSmFpQURLQUlBTmdJQUlBb2dBRUVCYWlJRFFRSjBJZ0pxSUFzZ0EwRURkR29pQXlnQ0JEWUNBQ0FDSUFscUlBTW9BZ0EyQWdBZ0FFRUNhaUlBSUFaSERRQUxDeUFGSUFRb0FxZ0dOZ0tzQmlBT1FRRnFJZzRnRFVjTkFBc0xJQUVoQXd3QkN5QUlRUXhxQkVBZ0NDZ0NEQ0lCS0FJd0lnQUVmeUFBRUFrZ0NDZ0NEQVVnQVFzUUNTQUlRUUEyQWd3TEN5QUlRUkJxSkFBZ0F3djVCQUVJZnlNQVFZQUNheUlESkFBZ0FBUkFRZndNUVJFZ0FoQVZJQU1nQUNnQ0FEWUM4QUVnQWtHYUVTQURRZkFCYWhBUElBTWdBQ2dDQkRZQzRBRWdBa0duRVNBRFFlQUJhaEFQSUFNZ0FDZ0NDRFlDMEFFZ0FrR0NOeUFEUWRBQmFoQVBJQU1nQUNnQ0VEWUN3QUVnQWtIOUVDQURRY0FCYWhBUElBRkJBRW9FUUFOQUlBQW9BdEFySVFRZ0F5QUhOZ0t3QVNBQ1FhSU5JQU5Cc0FGcUVBOGdBeUFFSUFkQnVBaHNhaUlFS0FJQU5nS2dBU0FDUVprUklBTkJvQUZxRUE4Z0F5QUVLQUlFTmdLUUFTQUNRZlEzSUFOQmtBRnFFQThnQXlBRUtBSUlOZ0tBQVNBQ1FhQTJJQU5CZ0FGcUVBOGdBeUFFS0FJTU5nSndJQUpCc0RZZ0EwSHdBR29RRHlBRElBUW9BaEEyQW1BZ0FrR0lFU0FEUWVBQWFoQVBJQU1nQkNnQ0ZEWUNVQ0FDUWJZNElBTkIwQUJxRUE5QjFRdEJGeUFDRUJVZ0JDZ0NCQVJBSUFSQnNBZHFJUVlnQkVHc0Jtb2hDRUVBSVFVRFFDQUlJQVZCQW5RaUNXb29BZ0FoQ2lBRElBWWdDV29vQWdBMkFrUWdBeUFLTmdKQUlBSkJpd3dnQTBGQWF4QVBJQVZCQVdvaUJTQUVLQUlFU1EwQUN3c2dBaEJuSUFNZ0JDZ0NHRFlDTUNBQ1FjQTJJQU5CTUdvUUR5QURJQVFvQXFRR05nSWdJQUpCOFRZZ0EwRWdhaEFQUVFFaEJrSHRDMEVVSUFJUUZRSkFJQVFvQWhoQkFVY0VRQ0FFS0FJRUlnVkJBRXdOQVNBRlFRTnNRUUpySVFZTElBUkJIR29oQ0VFQUlRVURRQ0FESUFnZ0JVRURkR29wQWdCQ0lJazNBeEFnQWtHTERDQURRUkJxRUE4Z0JVRUJhaUlGSUFaSERRQUxDeUFDRUdjZ0F5QUVLQUtvQmpZQ0FDQUNRZUEySUFNUUQwR1pERUVGSUFJUUZTQUhRUUZxSWdjZ0FVY05BQXNMUVpvTVFRUWdBaEFWQ3lBRFFZQUNhaVFBQytZS0F3bC9BWHNCZmlNQVFiQUJheUlGSkFBQ1FDQUJRWUFEY1FSQVFaNHRRUXNnQWhBVkRBRUxBa0FnQVVFQmNVVU5BQ0FBS0FKSUlnWkZEUUFqQUVIUUFHc2lBeVFBUWU0TVFRMGdBaEFWSUFOQkFEb0FUeUFEUVFrNkFFNGdBeUFHS1FJQU53SkVJQU1nQTBIT0FHb2lCRFlDUUNBQ1FZWTVJQU5CUUdzUUR5QURJQVlwQWdnM0FqUWdBeUFFTmdJd0lBSkI5VGdnQTBFd2FoQVBJQU1nQmlnQ0VEWUNKQ0FESUFRMkFpQWdBa0dUTnlBRFFTQnFFQThDUUNBR0tBSVlSUTBBSUFZb0FoQkZEUUFEUUNBRElBTkJ6Z0JxSWdvMkFoQWdBeUFITmdJVUlBSkJqZzBnQTBFUWFoQVBJQVlvQWhnZ0IwRTBiR29oQ0NNQVFUQnJJZ1FrQUNBRVFRazdBQzRnQkVFSk9nQXRJQVFnQ0NrQ0FEY0NKQ0FFSUFSQkxXb2lDVFlDSUNBQ1FjODJJQVJCSUdvUUR5QUVJQWdvQWhnMkFoUWdCQ0FKTmdJUUlBSkJ4VGdnQkVFUWFoQVBJQVFnQ0NnQ0lEWUNCQ0FFSUFrMkFnQWdBa0dxT0NBRUVBOGdCRUV3YWlRQUlBTWdDallDQUNBQ1FaUU1JQU1RRHlBSFFRRnFJZ2NnQmlnQ0VFa05BQXNMUVp3TVFRSWdBaEFWSUFOQjBBQnFKQUFMQWtBZ0FVRUNjVVVOQUNBQUtBSklSUTBBUWZrTlFTUWdBaEFWSUFVZ0FDa0NWRGNEb0FFZ0FrSG5FU0FGUWFBQmFoQVBJQVVnQUNrQ1hEY0RrQUVnQWtIRkVTQUZRWkFCYWhBUElBVWdBQ2tEYURjRGdBRWdBa0hYRVNBRlFZQUJhaEFQSUFBb0Fnd2dBQ2dDU0NnQ0VDQUNFRVJCbkF4QkFpQUNFQlVMQWtBZ0FVRUljVVVOQUNBQUtBSklSUTBBSUFBb0FtZ2dBQ2dDYkd3aUJFVU5BQ0FBS0FLY0FTRURBMEFnQXlBQUtBSklLQUlRSUFJUVJDQURRWXdzYWlFRElBdEJBV29pQ3lBRVJ3MEFDd3NnQVVFUWNVVU5BQ0FBS0FMSUFTRUJRZE1OUVNVZ0FoQVZJQVVnQWYwQUF3RDlDd1J3SUFKQnlTc2dCVUh3QUdvUUQwSEJEVUVSSUFJUUZRSkFJQUVvQWh4RkRRQWdBU2dDR0VVTkFFRUFJUU1EUUNBQktBSWNJQU5CR0d4cUlnQXZBUUFoQkNBQUtRTUlJUTBnQlNBQUtBSVFOZ0pnSUFVZ0RUY0RXQ0FGSUFRMkFsQWdBa0dMT0NBRlFkQUFhaEFQSUFOQkFXb2lBeUFCS0FJWVNRMEFDd3RCbWd4QkJDQUNFQlVDUUNBQktBSW9JZ1JGRFFBZ0FTZ0NKQ0lIUlEwQVFRQWhBMEVBSVFBQ1FDQUhRUVJQQkVBZ0IwRjhjU0VBQTBBZ0JDQURRUU55UVNoc2FrRUVhaUFFSUFOQkFuSkJLR3hxUVFScUlBUWdBMEVCY2tFb2JHcEJCR29nQkNBRFFTaHNhdjBKQWdUOVZnSUFBZjFXQWdBQy9WWUNBQU1nRFAydUFTRU1JQU5CQkdvaUF5QUFSdzBBQ3lBTUlBd2dEUDBOQ0FrS0N3d05EZzhBQVFJREFBRUNBLzJ1QVNJTUlBd2dEUDBOQkFVR0J3QUJBZ01BQVFJREFBRUNBLzJ1QWYwYkFDRURJQUFnQjBZTkFRc0RRQ0FFSUFCQktHeHFLQUlFSUFOcUlRTWdBRUVCYWlJQUlBZEhEUUFMQ3lBRFJRMEFRYkFOUVJBZ0FoQVZJQUVvQWlRRVFDQUJLQUlvSVFCQkFDRUhBMEFnQlNBQUlBZEJLR3dpQkdvb0FnUWlCallDUkNBRklBYzJBa0FnQWtIUk9DQUZRVUJyRUE4Z0FTZ0NLQ0VBQWtBZ0JrVU5BRUVBSVFNZ0FDQUVhaWdDRUVVTkFBTkFJQUVvQWlnZ0JHb29BaEFnQTBFWWJHb2lBUDBBQXdBaERDQUZJQUFwQXhBM0F6Z2dCU0FNL1FzREtDQUZJQU0yQWlBZ0FrR0EwUUFnQlVFZ2FoQVBJQU5CQVdvaUF5QUdSdzBBQ3lBQktBSW9JUUFMQWtBZ0FDQUVhaUlHS0FJWVJRMEFRUUFoQXlBR0tBSVVSUTBBQTBBZ0FDQUVhaWdDR0NBRFFSaHNhaUlBTHdFQUlRWWdBQ2tEQ0NFTklBVWdBQ2dDRURZQ0VDQUZJQTAzQXdnZ0JTQUdOZ0lBSUFKQml6Z2dCUkFQSUFOQkFXb2lBeUFCS0FJb0lnQWdCR29vQWhSSkRRQUxDeUFIUVFGcUlnY2dBU2dDSkVrTkFBc0xRWm9NUVFRZ0FoQVZDMEdjREVFQ0lBSVFGUXNnQlVHd0FXb2tBQXVQQWdFRGZ3SkFRUUZCNkFFUURDSUJCSDhnQVVFQk5nSUFJQUZCQVRZQ3VBRWdBU0FCTFFDOEFVRUdjam9BdkFFZ0FVRUJRWXdzRUF3aUFEWUNEQ0FBUlEwQklBRkJBVUhvQnhBTUlnQTJBaEFnQUVVTkFTQUJRZ0EzQXpBZ0FVRi9OZ0lzSUFGQjZBYzJBaFFDUUVFQlFUQVFEQ0lBQkVBZ0FFRUFOZ0lZSUFCQjVBQTJBaUFnQUVIa0FFRVlFQXdpQWpZQ0hDQUNEUUVnQUJBSkN5QUJRUUEyQXNnQkRBSUxJQUJCQURZQ0tDQUJJQUEyQXNnQklBRVFMaUlBTmdMRUFTQUFSUTBCSUFFUUxpSUFOZ0xBQVNBQVJRMEJBa0FRaWdGRkRRQUxJQUZCQUJCZUlnQTJBdFFCSUFCRkJFQWdBVUVBRUY0aUFEWUMxQUVnQUVVTkFnc2dBUVZCQUFzUEN5QUJFREZCQUF1TkNRSUpmd0YrSXdCQjBBRnJJZ2NrQUNBQUtBSklJUWtDUUFKQUFrQWdBQ2dDYUVFQlJ3MEFJQUFvQW14QkFVY05BQ0FBS0FLY0FTZ0MzQ3NOQVFzZ0FDZ0NDRUVJUmcwQUlBWkJBVUc4emdCQkFCQUlEQUVMQWtBZ0FTZ0NFQ0lNUlEwQUlBQW9BcUFCSVFvZ0FTZ0NHQ0VMSUF4QkNFOEVRQ0FNUVhoeElROERRQ0FMSUFoQk5HeHFJQW8yQWlnZ0N5QUlRUUZ5UVRSc2FpQUtOZ0lvSUFzZ0NFRUNja0UwYkdvZ0NqWUNLQ0FMSUFoQkEzSkJOR3hxSUFvMkFpZ2dDeUFJUVFSeVFUUnNhaUFLTmdJb0lBc2dDRUVGY2tFMGJHb2dDallDS0NBTElBaEJCbkpCTkd4cUlBbzJBaWdnQ3lBSVFRZHlRVFJzYWlBS05nSW9JQWhCQ0dvaENDQU9RUWhxSWc0Z0QwY05BQXNMSUF4QkIzRWlERVVOQUFOQUlBc2dDRUUwYkdvZ0NqWUNLQ0FJUVFGcUlRZ2dEVUVCYWlJTklBeEhEUUFMQ3lBQ0lBTnlJQVJ5SUFWeVJRUkFJQVpCQkVHdk1FRUFFQWdnQUVJQU53SWNJQUFnQUNrQ2FEY0NKQ0FCSUFuOUFBSUEvUXNDQUNBQklBWVFNQ0VJREFFTElBSkJBRWdFUUNBSElBSTJBZ0FnQmtFQlFkZmRBQ0FIRUFoQkFDRUlEQUVMSUFJZ0NTZ0NDQ0lJU3dSQUlBY2dDRFlDRkNBSElBSTJBaEFnQmtFQlFhdmhBQ0FIUVJCcUVBaEJBQ0VJREFFTEFrQWdBaUFKS0FJQUlnaEpCRUFnQnlBSU5nTEVBU0FISUFJMkFzQUJJQVpCQWtHTDVBQWdCMEhBQVdvUUNDQUFRUUEyQWh3Z0NTZ0NBQ0VDREFFTElBQWdBaUFBS0FKVWF5QUFLQUpjYmpZQ0hBc2dBU0FDTmdJQUlBTkJBRWdFUUNBSElBTTJBaUFnQmtFQlFaZmRBQ0FIUVNCcUVBaEJBQ0VJREFFTElBTWdDU2dDRENJQ1N3UkFJQWNnQWpZQ05DQUhJQU0yQWpBZ0JrRUJRZjdmQUNBSFFUQnFFQWhCQUNFSURBRUxBa0FnQXlBSktBSUVJZ0pKQkVBZ0J5QUNOZ0swQVNBSElBTTJBckFCSUFaQkFrSGM0Z0FnQjBHd0FXb1FDQ0FBUVFBMkFpQWdDU2dDQkNFRERBRUxJQUFnQXlBQUtBSllheUFBS0FKZ2JqWUNJQXNnQVNBRE5nSUVRUUFoQ0NBRVFRQk1CRUFnQnlBRU5nSkFJQVpCQVVIVjNBQWdCMEZBYXhBSURBRUxJQVFnQ1NnQ0FDSUNTUVJBSUFjZ0FqWUNWQ0FISUFRMkFsQWdCa0VCUWJMakFDQUhRZEFBYWhBSURBRUxBa0FnQkNBSktBSUlJZ0pMQkVBZ0J5QUNOZ0trQVNBSElBUTJBcUFCSUFaQkFrSFQ0QUFnQjBHZ0FXb1FDQ0FBSUFBb0FtZzJBaVFnQ1NnQ0NDRUVEQUVMSUFBZ0FEVUNYQ0lRSUFRZ0FDZ0NWR3V0ZkVJQmZTQVFnRDRDSkFzZ0FTQUVOZ0lJSUFWQkFFd0VRQ0FISUFVMkFtQWdCa0VCUVpMY0FDQUhRZUFBYWhBSURBRUxJQVVnQ1NnQ0JDSUNTUVJBSUFjZ0FqWUNkQ0FISUFVMkFuQWdCa0VCUVlMaUFDQUhRZkFBYWhBSURBRUxBa0FnQlNBSktBSU1JZ0pMQkVBZ0J5QUNOZ0tVQVNBSElBVTJBcEFCSUFaQkFrR2wzd0FnQjBHUUFXb1FDQ0FBSUFBb0FtdzJBaWdnQ1NnQ0RDRUZEQUVMSUFBZ0FEVUNZQ0lRSUFVZ0FDZ0NXR3V0ZkVJQmZTQVFnRDRDS0FzZ0FTQUZOZ0lNSUFBZ0FDMEFSRUVDY2pvQVJDQUJJQVlRTUNJSVJRUkFRUUFoQ0F3QkN5QUhJQUg5QUFJQS9Rc0VnQUVnQmtFRVFiUTVJQWRCZ0FGcUVBZ0xJQWRCMEFGcUpBQWdDQXVWQWdFSGZ5TUFRU0JySWdVa0FBSi9JQUFvQWtnaUJFVUVRQ0FEUVFGQjFlWUFRUUFRQ0VFQURBRUxRUUJCQkNBRUtBSVFFQXdpQkVVTkFCb2dBUVJBSUFBb0FrZ2hDQU5BQWtBQ1FDQUNJQVpCQW5ScUtBSUFJZ2NnQ0NnQ0VFOEVRQ0FGSUFjMkFoQWdBMEVCUWZrUklBVkJFR29RQ0F3QkN5QUVJQWRCQW5ScUlna29BZ0JGRFFFZ0JTQUhOZ0lBSUFOQkFVR05HaUFGRUFnTElBUVFDVUVBREFNTElBbEJBVFlDQUNBR1FRRnFJZ1lnQVVjTkFBc0xJQVFRQ1NBQUtBSkFFQWtDUUNBQkJFQWdBQ0FCUVFKMElnUVFEU0lETmdKQUlBTkZCRUFnQUVFQU5nSThRUUFNQXdzZ0F5QUNJQVFRQ3hvTUFRc2dBRUVBTmdKQUN5QUFJQUUyQWp4QkFRc2hDaUFGUVNCcUpBQWdDZ3U4QlFFSGZ5QUJRUUZCSkJBTUlnUTJBa2dDUUFKQUlBUkZEUUFDUUNBQktBTEVBVUVTSUFNUUhnUkFJQUVvQXNRQlFSTWdBeEFlRFFFTERBSUxJQUVvQXNRQklnY29BZ0FoQmlBSEtBSUlJUVFDUUNBR0JFQkJBU0VGSUFaQkFVY0VRQ0FHUVg1eElRa0RRQUovUVFBZ0JVVU5BQnBCQUNBQklBQWdBeUFFS0FJQUVRQUFSUTBBR2lBQklBQWdBeUFFS0FJRUVRQUFRUUJIQ3lFRklBUkJDR29oQkNBSVFRSnFJZ2dnQ1VjTkFBc0xBa0FDUUNBR1FRRnhCRUFnQlVVTkFTQUJJQUFnQXlBRUtBSUFFUUFBUVFCSElRVUxJQWRCQURZQ0FDQUZSUTBCREFNTElBZEJBRFlDQUFzTUF3c2dCMEVBTmdJQUN3SkFJQUVvQXNBQlFSUWdBeEFlQkVBZ0FTZ0N3QUZCRlNBREVCNE5BUXNNQWdzZ0FTZ0N3QUVpQnlnQ0FDRUdJQWNvQWdnaEJBSkFJQVlFUUVFQklRVWdCa0VCY1NFSklBWkJBVVlFZjBFQUJTQUdRWDV4SVFaQkFDRUlBMEFDZjBFQUlBVkZEUUFhUVFBZ0FTQUFJQU1nQkNnQ0FCRUFBRVVOQUJvZ0FTQUFJQU1nQkNnQ0JCRUFBRUVBUndzaEJTQUVRUWhxSVFRZ0NFRUNhaUlJSUFaSERRQUxJQVZGQ3lFR0FrQUNRQ0FKQkVBZ0JnMEJJQUVnQUNBRElBUW9BZ0FSQUFCQkFFY2hCUXNnQjBFQU5nSUFJQVZGRFFFTUF3c2dCMEVBTmdJQUN3d0RDeUFIUVFBMkFnQUxJQUpCQVVFa0VBd2lBRFlDQUNBQVJRMEFJQUVvQWtnZ0FCQTRJQUVvQXNnQklBRW9BbXdnQVNnQ2FHd2lBRFlDSkNBQVFTZ1FEQ0VESUFFb0FzZ0JJZ0FnQXpZQ0tBSkFJQU5GRFFBZ0FDZ0NKRVVFUUVFQkR3dEJBQ0VFQTBBZ0F5QUVRU2hzSWdWcUlnQkJBRFlDRkNBQVFlUUFOZ0ljUWVRQVFSZ1FEQ0VBSUFVZ0FTZ0N5QUVpQnlnQ0tDSURhaUFBTmdJWUlBQkZEUUZCQVNFS0lBUkJBV29pQkNBSEtBSWtTUTBBQ3d3QkN5QUNLQUlBRUJoQkFDRUtJQUpCQURZQ0FBc2dDZzhMSUFFb0FrZ1FHQ0FCUVFBMkFraEJBQXNDQUFzRUFFRUJDelFBQWtBZ0FFVU5BQ0FCUlEwQUlBQWdBU2dDQkRZQ3BBRWdBQ0FCS0FJQU5nS2dBU0FBSUFFb0FyaEFRUUp4TmdMZ0FRc0x0QVVCQ0g4Z0FDZ0NHQ0lFS0FJUUlnbEZCRUJCQUE4TElBUW9BaGdoQlNBQUtBSVVLQUlBS0FJVUlRUUNRQUpBSUFGRkJFQkJBQ0VCQTBBZ0JTZ0NHQ0VDSUFRb0Fod2dCQ2dDR0VHWUFXeHFJZ0JCakFGcktBSUFJZ2NnQUVHVUFXc29BZ0FpQ0dzaEF5QUFRWkFCYXlnQ0FDQUFRWmdCYXlnQ0FHc2hBQUpBSUFjZ0NFWU5BQ0FBclNBRHJYNUNJSWhRRFFBTUJBc2dBQ0FEYkNFREFrQkJCQ0FDUVFOMklBSkJCM0ZCQUVkcUlnQWdBRUVEUmhzaUFrVU5BQ0FDclNBRHJYNUNJSWhRRFFBTUJBdEJmeUVBSUFJZ0Eyd2lBaUFCUVg5elN3MENJQVJCekFCcUlRUWdCVUUwYWlFRklBRWdBbW9pQVNFQUlBWkJBV29pQmlBSlJ3MEFDd3dCQzBFQUlRRWdBQ2dDUUVVRVFBTkFJQVVvQWhnaEFpQUVLQUljSUFRb0FoaEJtQUZzYWlJQVFRUnJLQUlBSWdjZ0FFRU1heWdDQUNJSWF5RURJQUJCQ0dzb0FnQWdBRUVRYXlnQ0FHc2hBQUpBSUFjZ0NFWU5BQ0FBclNBRHJYNUNJSWhRRFFBTUJBc2dBQ0FEYkNFREFrQkJCQ0FDUVFOMklBSkJCM0ZCQUVkcUlnQWdBRUVEUmhzaUFrVU5BQ0FDclNBRHJYNUNJSWhRRFFBTUJBdEJmeUVBSUFJZ0Eyd2lBaUFCUVg5elN3MENJQVJCekFCcUlRUWdCVUUwYWlFRklBRWdBbW9pQVNFQUlBWkJBV29pQmlBSlJ3MEFDd3dCQ3dOQUlBVW9BaGdoQWlBRUtBSWNJQVFvQWhoQm1BRnNhaUlBUVl3QmF5Z0NBQ0lISUFCQmxBRnJLQUlBSWdocklRTWdBRUdRQVdzb0FnQWdBRUdZQVdzb0FnQnJJUUFDUUNBSElBaEdEUUFnQUswZ0E2MStRaUNJVUEwQURBTUxJQUFnQTJ3aEF3SkFRUVFnQWtFRGRpQUNRUWR4UVFCSGFpSUFJQUJCQTBZYklnSkZEUUFnQXEwZ0E2MStRaUNJVUEwQURBTUxRWDhoQUNBQ0lBTnNJZ0lnQVVGL2Mwc05BU0FFUWN3QWFpRUVJQVZCTkdvaEJTQUJJQUpxSWdFaEFDQUdRUUZxSWdZZ0NVY05BQXNMSUFBUEMwRi9DOW9FQVF0L0lBQUVRQ0FBS0FJVUlnRUVRQ0FCS0FJQUlnVUVRQ0FGS0FJVUlRTWdCU2dDRUFSL1FSQkJFU0FBTFFBb1FRRnhHeUVJQTBBZ0F5Z0NIQ0lDQkVBZ0F5Z0NJQ0lCUVpnQmJpRUtRUUFoQ1NBQlFaZ0JUd1IvQTBBZ0FpZ0NNQ0lCQkVBZ0FpZ0NOQ0lHUVNodUlRZEJBQ0VFSUFaQktFOEVmd05BSUFFb0FpQVFJaUFCUVFBMkFpQWdBU2dDSkJBaUlBRkJBRFlDSkNBQklBZ1JBZ0FnQVVFb2FpRUJJQVJCQVdvaUJDQUhSdzBBQ3lBQ0tBSXdCU0FCQ3hBSklBSkJBRFlDTUFzZ0FpZ0NWQ0lCQkVBZ0FpZ0NXQ0lHUVNodUlRZEJBQ0VFSUFaQktFOEVmd05BSUFFb0FpQVFJaUFCUVFBMkFpQWdBU2dDSkJBaUlBRkJBRFlDSkNBQklBZ1JBZ0FnQVVFb2FpRUJJQVJCQVdvaUJDQUhSdzBBQ3lBQ0tBSlVCU0FCQ3hBSklBSkJBRFlDVkFzZ0FpZ0NlQ0lCQkVBZ0FpZ0NmQ0lHUVNodUlRZEJBQ0VFSUFaQktFOEVmd05BSUFFb0FpQVFJaUFCUVFBMkFpQWdBU2dDSkJBaUlBRkJBRFlDSkNBQklBZ1JBZ0FnQVVFb2FpRUJJQVJCQVdvaUJDQUhSdzBBQ3lBQ0tBSjRCU0FCQ3hBSklBSkJBRFlDZUFzZ0FrR1lBV29oQWlBSlFRRnFJZ2tnQ2tjTkFBc2dBeWdDSEFVZ0Fnc1FDU0FEUVFBMkFod0xBa0FnQXlnQ0tFVU5BQ0FES0FJa0lnRkZEUUFnQVJBSklBUDlEQUFBQUFBQUFBQUFBQUFBQUFBQUFBRDlDd0lrQ3lBREtBSTBFQWtnQTBITUFHb2hBeUFMUVFGcUlnc2dCU2dDRUVrTkFBc2dCU2dDRkFVZ0F3c1FDU0FGUVFBMkFoUWdBQ2dDRkNnQ0FCQUpJQUFvQWhRaUFVRUFOZ0lBQ3lBQkVBa2dBRUVBTmdJVUN5QUFLQUpFRUFrZ0FCQUpDd3ZMRXdFVmZ5TUFRU0JySWc4a0FDQVBJQVUyQWhnZ0FTQURLQUljUWN3QWJHb29BaHdnQXlnQ0lFR1lBV3hxSVJFQ1FBSkFJQU1vQWlnTkFDQVJLQUlZUlEwQUlCRkJIR29oQ1FOQUFrQWdDU2dDQ0NBSktBSUFSd1IvSUFrb0Fnd2dDU2dDQkVZRlFRRUxEUUFnQXlnQ0pDSUJJQWtvQWhoQktHNVBCRUFnQ0VFQlFZSVZRUUFRQ0F3RUN5QUpLQUlVSUFGQktHeHFJZ0VvQWlBUVd5QUJLQUlrRUZzZ0FTZ0NGQ0FCS0FJUWJDSU5SUTBBSUFFb0FoZ2hBU0FOUVFoUEJFQWdEVUY0Y1NFTFFRQWhDZ05BSUFGQ0FEY0M2QU1nQVVJQU53S29BeUFCUWdBM0F1Z0NJQUZDQURjQ3FBSWdBVUlBTndMb0FTQUJRZ0EzQXFnQklBRkNBRGNDYUNBQlFnQTNBaWdnQVVHQUJHb2hBU0FLUVFocUlnb2dDMGNOQUFzTFFRQWhDaUFOUVFkeElnMUZEUUFEUUNBQlFnQTNBaWdnQVVGQWF5RUJJQXBCQVdvaUNpQU5SdzBBQ3dzZ0NVRWthaUVKSUF4QkFXb2lEQ0FSS0FJWVNRMEFDd3NnQlNFTkFrQWdBaTBBQUVFQ2NVVU5BQ0FIUVFWTkJFQWdDRUVDUWJFZlFRQVFDQXdCQ3dKQUlBVXRBQUJCL3dGR0JFQWdCUzBBQVVHUkFVWU5BUXNnQ0VFQ1Fkc2ZRUUFRQ0F3QkN5QVBJQVZCQm1vaURUWUNHQXRCRkJBTklndEZEUUFDZnlBQUxRQnNRUUZ4QkVBZ0FFRW9haUVISUFBb0FpZ2hEU0FBUVN4cURBRUxJQUl0QUlnc1FRSnhCRUFnQWtHd0tHb2hCeUFDS0FLd0tDRU5JQUpCdkNocURBRUxJQThnQlNBSGFpQU5hellDSENBUFFSaHFJUWNnRDBFY2Fnc2lFaWdDQUNFQUlBdENBRGNDRENBTElBMDJBZ2dnQ3lBTk5nSUFJQXNnQUNBTmFqWUNCQ0FMUVFFUUdVVUVRQ0FMRUYwYUlBc29BZ2dnQ3lnQ0FHc2hHaUFMRUNVZ0dpQU5haUVCQWtBZ0FpMEFBRUVFY1VVTkFDQUhLQUlBSUJJb0FnQWdBV3RxUVFGTkJFQWdDRUVDUVpnaFFRQVFDQXdCQ3dKQUlBRXRBQUJCL3dGR0JFQWdBUzBBQVVHU0FVWU5BUXNnQ0VFQ1FjSWhRUUFRQ0F3QkN5QUJRUUpxSVFFTElCSWdFaWdDQUNBSEtBSUFJQUZyYWpZQ0FDQUhJQUUyQWdBZ0JFRUFOZ0lBSUFZZ0R5Z0NHQ0FGYXpZQ0FFRUJJUmNNQVFzZ0VTZ0NHQVJBSUJGQkhHb2hFQU5BSUFNb0FpUWhBQ0FRS0FJVUlRRUNRQ0FRS0FJSUlCQW9BZ0JIQkg4Z0VDZ0NEQ0FRS0FJRVJnVkJBUXNOQUNBQklBQkJLR3hxSWhRb0FoUWdGQ2dDRUd3aUdFVU5BQ0FVS0FJWUlRbEJBQ0VWQTBBQ1FBSi9JQWtvQWloRkJFQWdDeUFVS0FJZ0lCVWdBeWdDS0VFQmFoQlpEQUVMSUF0QkFSQVpDMFVFUUNBSlFRQTJBaVFNQVFzZ0NTZ0NLRVVFUUVFQUlRRURRQ0FCSWdCQkFXb2hBU0FMSUJRb0FpUWdGU0FBRUZsRkRRQUxJQkFvQWh3aEFTQUpRUU0yQWlBZ0NTQUJOZ0lZSUFrZ0FTQUFhMEVCYWpZQ0hBc2dDUUovUVFFZ0MwRUJFQmxGRFFBYVFRSWdDMEVCRUJsRkRRQWFJQXRCQWhBWklnQkJBMGNFUUNBQVFRTnFEQUVMSUF0QkJSQVpJZ0JCSDBjRVFDQUFRUVpxREFFTElBdEJCeEFaUVNWcUN6WUNKRUVBSVFFRFFDQUJJZ0JCQVdvaEFTQUxRUUVRR1EwQUN5QUpJQWtvQWlBZ0FHbzJBaUFDUUFKQUFuOGdDU2dDS0NJQVJRUkFJQUlvQXRBcklBTW9BaHhCdUFoc2FpZ0NFQ0VBSUFrb0FqQkZCRUFnQ1NnQ0FFSHdBUkFRSWdGRkRRUWdDU0FCTmdJQUlBRWdDU2dDTUVFWWJHcEJBRUh3QVJBT0dpQUpRUW8yQWpBTElBa29BZ0FpQWYwTUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAwTEFnQWdBVUlBTndJUVFRRkJDa0h0QUNBQVFRRnhHeUFBUVFSeEd5RUtRUUFNQVFzZ0NTZ0NBQ0lCSUFCQkFXc2lERUVZYkdvaUNpZ0NCQ0FLS0FJTVJ3MEJJQUlvQXRBcklBTW9BaHhCdUFoc2FpZ0NFQ0VLSUFrb0FqQWlEQ0FBUVFGcVNRUi9JQUVnREVFS2FpSU1RUmhzRUJBaUFVVU5BeUFKSUFFMkFnQWdBU0FKS0FJd1FSaHNha0VBUWZBQkVBNGFJQWtnRERZQ01DQUpLQUlBQlNBQkN5QUFRUmhzYWlJQi9Rd0FBQUFBQUFBQUFBQUFBQUFBQUFBQS9Rc0NBQ0FCUWdBM0FoQUNmMEVCSUFwQkJIRU5BQnBCN1FBZ0NrRUJjVVVOQUJwQkFrRUNRUUVnQVVFTWF5Z0NBQ0lLUVFwR0d5QUtRUUZHR3dzaENpQUFDeUVNSUFFZ0NqWUNEQXNnQ1NnQ0pDRUFJQUlvQXRBcklBTW9BaHhCdUFoc2FpMEFFRUhBQUhFRVFBTkFJQXhCR0d3aURpQUpLQUlBYWlBQVFRRWdEQnNpRXpZQ0VDQUpLQUlnSVJaQkFDRUtJQUFoQVNBVFFRSlBCRUFEUUNBS1FRRnFJUW9nQVVFRFN5RWJJQUZCQVhZaEFTQWJEUUFMQ3lBS0lCWnFJZ0ZCSVU4RVFDQVBJQUUyQWhBZ0NFRUJRY3owQUNBUFFSQnFFQWdNQXdzZ0N5QUJFQmtoQ2lBSktBSUFJZ0VnRG1vaURpQUtOZ0lVSUFBZ0RpZ0NFR3NpQUVFQVRBMERJQUlvQXRBcklBTW9BaHhCdUFoc2FpZ0NFQ0VLSUFrb0FqQWlEaUFNUVFKcVNRUkFJQUVnRGtFS2FpSU9RUmhzRUJBaUFVVU5BeUFKSUFFMkFnQWdBU0FKS0FJd1FSaHNha0VBUWZBQkVBNGFJQWtnRGpZQ01DQUpLQUlBSVFFTElBRWdERUVCYWlJTVFSaHNhaUlCL1F3QUFBQUFBQUFBQUFBQUFBQUFBQUFBL1FzQ0FDQUJRZ0EzQWhBZ0FRSi9RUUVnQ2tFRWNRMEFHa0h0QUNBS1FRRnhSUTBBR2tFQ1FRSkJBU0FCUVF4cktBSUFJZ0ZCQ2tZYklBRkJBVVliQ3pZQ0RBd0FDd0FMQTBBZ0RFRVliQ0lPSUFrb0FnQnFJZ0VnQVNnQ0RDQUJLQUlFYXlJQklBQWdBQ0FCU2hzaUFUWUNFQ0FKS0FJZ0lSTkJBQ0VLSUFGQkFrOEVRQU5BSUFwQkFXb2hDaUFCUVFOTElSd2dBVUVCZGlFQklCd05BQXNMSUFvZ0Uyb2lBVUVoVHdSQUlBOGdBVFlDQUNBSVFRRkJ6UFFBSUE4UUNBd0NDeUFMSUFFUUdTRUtJQWtvQWdBaUFTQU9haUlPSUFvMkFoUWdBQ0FPS0FJUWF5SUFRUUJNRFFJZ0FpZ0MwQ3NnQXlnQ0hFRzRDR3hxS0FJUUlRb2dDU2dDTUNJT0lBeEJBbXBKQkVBZ0FTQU9RUXBxSWc1QkdHd1FFQ0lCUlEwQ0lBa2dBVFlDQUNBQklBa29BakJCR0d4cVFRQkI4QUVRRGhvZ0NTQU9OZ0l3SUFrb0FnQWhBUXNnQVNBTVFRRnFJZ3hCR0d4cUlnSDlEQUFBQUFBQUFBQUFBQUFBQUFBQUFBRDlDd0lBSUFGQ0FEY0NFQ0FCQW45QkFTQUtRUVJ4RFFBYVFlMEFJQXBCQVhGRkRRQWFRUUpCQWtFQklBRkJER3NvQWdBaUFVRUtSaHNnQVVFQlJoc0xOZ0lNREFBTEFBc2dDeEFsREFVTElBbEJRR3NoQ1NBVlFRRnFJaFVnR0VjTkFBc0xJQkJCSkdvaEVDQVpRUUZxSWhrZ0VTZ0NHRWtOQUFzTElBc1FYVVVFUUNBTEVDVU1BUXNnQ3lnQ0NDQUxLQUlBYXlFZElBc1FKU0FkSUExcUlRRUNRQ0FDTFFBQVFRUnhSUTBBSUFjb0FnQWdFaWdDQUNBQmEycEJBVTBFUUNBSVFRSkJtQ0ZCQUJBSURBRUxBa0FnQVMwQUFFSC9BVVlFUUNBQkxRQUJRWklCUmcwQkN5QUlRUUpCd2lGQkFCQUlEQUVMSUFGQkFtb2hBUXNnRWlBU0tBSUFJQWNvQWdBZ0FXdHFOZ0lBSUFjZ0FUWUNBRUVCSVJjZ0JFRUJOZ0lBSUFZZ0R5Z0NHQ0FGYXpZQ0FBc2dEMEVnYWlRQUlCY0xreVFDRkg4T2ZnSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBQ2dDVkE0RkFBRUNBd1FLQ3dKQUlBQW9BalFpQmlBQUtBTEVBU0lCU1FSQUlBQW9Ba0FpQnlBQlFRRnFTUTBCQ3lBQUtBTHNBVUVCUWZVK1FRQVFDQXdNQ3lBQUtBSXNSUVJBSUFBb0FpUWhBa0VBSVFFTUJRc2dBRUVBTmdJc0lBQW9Ba1FoQTBFQklRRU1CQXNDUUNBQUtBSTBJZ1lnQUNnQ3hBRWlBVWtFUUNBQUtBSkFJZ2NnQVVFQmFra05BUXNnQUNnQzdBRkJBVUdpUDBFQUVBZ01Dd3NnQUNnQ0xFVUVRQ0FBS0FJa0lRUkJBQ0VCREFnTElBQkJBRFlDTENBQUtBSXdJUU5CQVNFQkRBY0xBa0FnQUNnQ05DSUVJQUFvQXNRQklncEpCRUFnQUNnQ1FDSU9JQXBCQVdwSkRRRUxJQUFvQXV3QlFRRkJxY0FBUVFBUUNBd0tDeUFBS0FJc1JRUkFJQUFvQWlnaEN3d0dDeUFBUWdBM0F1UUJJQUJCQURZQ0xDQUFLQUxJQVNFTUEwQWdEQ0FIUVFSMGFpSUZLQUlJSWc4RVFDQUZLQUlNSVJKQkFDRUJBMEFDUUNBUElBRkJmM05xSWhBZ0VpQUJRUVIwYWlJUktBSUFhaUlKUVI5TERRQWdCU2dDQUNJVFFYOGdDWFpMRFFBZ0FDQUNJQk1nQ1hRaUNTQUNJQWxKR3lBSklBSWJJZ0kyQXVRQkN3SkFJQkVvQWdRZ0VHb2lDVUVmU3cwQUlBVW9BZ1FpRUVGL0lBbDJTdzBBSUFBZ0F5QVFJQWwwSWdrZ0F5QUpTUnNnQ1NBREd5SUROZ0xvQVFzZ0FVRUJhaUlCSUE5SERRQUxDeUFIUVFGcUlnY2dDa2NOQUFzZ0FrVU5CeUFEUlEwSElBQXRBQUJGQkVBZ0FDQUFLQUxRQVRZQ2JDQUFJQUFvQXN3Qk5nSmtJQUFnQUNnQzJBRTJBbkFnQUNBQUtBTFVBVFlDYUFzZ0FDZ0NNQ0VGUVFFaEFRd0ZDd0pBSUFBb0FqUWlCU0FBS0FMRUFTSUpTUVJBSUFBb0FrQWlFaUFKUVFGcVNRMEJDeUFBS0FMc0FVRUJRZncvUVFBUUNBd0pDeUFBS0FJc1JRUkFJQUFvQXNnQklnMGdBQ2dDSENJRVFRUjBhaUVMSUFBb0FpZ2hDQXdFQ3lBQVFnQTNBdVFCSUFCQkFEWUNMQ0FBS0FMSUFTRU5BMEFnRFNBR1FRUjBhaUlLS0FJSUlnNEVRQ0FLS0FJTUlSQkJBQ0VCQTBBQ1FDQU9JQUZCZjNOcUloRWdFQ0FCUVFSMGFpSVRLQUlBYWlJTVFSOUxEUUFnQ2lnQ0FDSVVRWDhnREhaTERRQWdBQ0FDSUJRZ0RIUWlEQ0FDSUF4Skd5QU1JQUliSWdJMkF1UUJDd0pBSUJNb0FnUWdFV29pREVFZlN3MEFJQW9vQWdRaUVVRi9JQXgyU3cwQUlBQWdBeUFSSUF4MElnd2dBeUFNU1JzZ0RDQURHeUlETmdMb0FRc2dBVUVCYWlJQklBNUhEUUFMQ3lBR1FRRnFJZ1lnQ1VjTkFBc2dBa1VOQmlBRFJRMEdBa0FnQUMwQUFBUkFJQUFvQW13aEJnd0JDeUFBSUFBb0F0QUJJZ1kyQW13Z0FDQUFLQUxNQVRZQ1pDQUFJQUFvQXRnQk5nSndJQUFnQUNnQzFBRTJBbWdMUVFFaEFRd0RDd0pBSUFBb0FqUWlCaUFBS0FMRUFTSUJTUVJBSUFBb0FrQWlEeUFCUVFGcVNRMEJDeUFBS0FMc0FVRUJRYzgvUVFBUUNBd0dDeUFBS0FJc1JRUkFJQUFvQXNnQklBQW9BaHdpQmtFRWRHb2hCU0FBS0FJb0lRZEJBQ0VCREFJTElBQWdCallDSENBQVFRQTJBaXhCQVNFQkRBRUxBMEFDZndKQUlBRkZCRUFnQWtFQmFpRUNEQUVMSUFBZ0F6WUNLQ0FBS0FJNElBTk5EUWtnQUNnQ01DRUVRUUFNQVF0QkFRc2hBUU5BQWtBQ1FBSkFBa0FnQVVVRVFDQUFJQVEyQWlBZ0JDQUFLQUk4VHcwQklBQWdCallDSENBR0lRRkJBQ0VGREFRTElBQWdBallDSkNBQUtBSk1JQUpOQkVBZ0FDZ0NIQ0VCUVFFaEJRd0VDeUFBS0FJUUlBQW9BaUJzSUFBb0Fnd2dBQ2dDS0d4cUlBQW9BaFFnQUNnQ0hHeHFJQUFvQWhnZ0FteHFJZ0VnQUNnQ0NFOEVRQXdNQ3lBQUtBSUVJQUZCQVhScUlnRXZBUUFOQVF3TkN5QUFLQUlvUVFGcUlRTU1BUXRCQUNFQkRBTUxRUUVoQVF3Q0N3TkFBa0FDUUFKQUlBVkZCRUFnQVNBSFR3MEJJQUFvQWlBaUJTQUFLQUxJQVNBQlFRUjBhaUlOS0FJSVR3MERJQUF0QUFCRkJFQWdBQ0FOS0FJTUlBVkJCSFJxSWdFb0Fnd2dBU2dDQ0d3MkFrd0xJQUFvQWtnaEFrRUJJUUVNQlFzZ0FDQUJRUUZxSWdFMkFod01BUXNnQUNnQ0lFRUJhaUVFUVFBaEFRd0RDMEVBSVFVTUFRdEJBU0VGREFBTEFBc0FDd0FMQTBBQ2Z3SkFJQUZGQkVBZ0FDQUhRUUZxSWdjMkFpZ01BUXNnQmlBUFR3MElJQUJDQURjQzVBRWdBQ2dDeUFFZ0JrRUVkR29pQlNnQ0NDSUxSUTBJSUFVb0Fnd2hDa0VBSVFKQkFDRUVRUUFoQVFOQUFrQWdDeUFCUVg5emFpSUpJQW9nQVVFRWRHb2lEaWdDQUdvaUNFRWZTdzBBSUFVb0FnQWlERUYvSUFoMlN3MEFJQUFnQkNBTUlBaDBJZ2dnQkNBSVNSc2dDQ0FFR3lJRU5nTGtBUXNDUUNBT0tBSUVJQWxxSWdoQkgwc05BQ0FGS0FJRUlnbEJmeUFJZGtzTkFDQUFJQUlnQ1NBSWRDSUlJQUlnQ0VrYklBZ2dBaHNpQWpZQzZBRUxJQUZCQVdvaUFTQUxSdzBBQ3lBRVJRMEdJQUpGRFFZQ1FDQUFMUUFBQkVBZ0FDZ0NiQ0VDREFFTElBQWdBQ2dDMEFFaUFqWUNiQ0FBSUFBb0Fzd0JOZ0prSUFBZ0FDZ0MyQUUyQW5BZ0FDQUFLQUxVQVRZQ2FBdEJBQXdCQzBFQkN5RUJBMEFDUUFKQUFrQUNRQ0FCUlFSQUlBQWdBallDNEFFZ0FpQUFLQUp3VHcwQklBQW9BbVFoRFVFQUlRRU1CQXNnQUNnQ09DQUhUUVJBSUFBb0FpQWhBMEVCSVFFTUJBc2dBQ2dDRUNBQUtBSWdiQ0FBS0FJTUlBZHNhaUFBS0FJVUlBWnNhaUFBS0FJWUlBQW9BaVJzYWlJQklBQW9BZ2hQQkVBTUN3c2dBQ2dDQkNBQlFRRjBhaUlCTHdFQURRRU1EQXNnQUNBR1FRRnFJZ1kyQWh3TUFRdEJBQ0VCREFNTFFRRWhBUXdDQ3dOQUFrQUNRQUpBSUFBQ2Z5QUJSUVJBSUFBZ0RUWUMzQUVnRFNBQUtBSm9UdzBDSUFBb0FqQU1BUXNnQTBFQmFnc2lBellDSUNBQUtBSThJZ0VnQlNnQ0NDSUVJQUVnQkVrYklBTkxCRUFnQlNnQ0FDSUJJQUd0SWg0Z0JDQURRWDl6YWlJSXJTSVdoaUlYSUJhSXAwY05BeUFGS0FJRUlnUkNmeUFXaUtkeElBUkhEUU1nQkswaUZTQVdoaUlZUWdGOUloa2dBRFVDMkFGOElCaUFJUjhnR1NBQUtBTFFBU0lKclh3Z0dJQWhHaUFYUWdGOUloc2dBRFVDMUFGOElCZUFJU0FnR3lBQUtBTE1BU0lPclh3Z0Y0QWhIQ0FCUW44Z0JTZ0NEQ0FEUVFSMGFpSUxLQUlBSWdvZ0NHcXRJaDJJcDNFZ0FVY05BeUFFSUJVZ0N5Z0NCQ0lCSUFocXJTSVZoaUloSUJXSXAwY05BeUFBS0FMZ0FTSUVyU0lpSUNHQ1FnQlNCRUFnQkNBSlJ3MEVRbjhnRllaQ2Y0VWdHa0wvLy8vL0Q0TWdGb2FEVUEwRUN5QUFLQUxjQVNJRXJTSVZJQjRnSFlhQ1FnQlNCRUFnQkNBT1J3MEVRbjhnSFlaQ2Y0VWdIRUwvLy8vL0Q0TWdGb2FEVUEwRUN5QUxLQUlJSWdSRkRRTWdDeWdDREVVTkF5QWNweUlMSUNDblJnMERJQnFuSWdnZ0g2ZEdEUU1nQUNBQUtBSkVJZ2MyQWlnZ0FDQVZJQnQ4SUJlQXB5QUtkaUFMSUFwMmF5QVpJQ0o4SUJpQXB5QUJkaUFJSUFGMmF5QUViR28yQWlSQkFTRUJEQVVMSUFBb0F0d0JJZ0VnQUNnQzVBRWlCR29nQVNBRWNHc2hEUXdCQ3lBQUtBTGdBU0lCSUFBb0F1Z0JJZ1JxSUFFZ0JIQnJJUUpCQUNFQkRBTUxRUUFoQVF3QkMwRUJJUUVNQUFzQUN3QUxBQXNEUUFKL0FrQWdBVVVFUUNBQUlBaEJBV29pQ0RZQ0tBd0JDeUFBSUFZMkF1QUJJQUFvQW5BZ0JrME5CeUFBS0FKa0lROUJBQXdCQzBFQkN5RUJBMEFDUUFKQUFrQUNRQ0FCUlFSQUlBQWdEellDM0FFZ0R5QUFLQUpvVHcwQklBQWdCVFlDSENBRklRUkJBQ0VCREFRTElBQW9BamdnQ0UwRVFDQUFLQUlnSVFkQkFTRUJEQVFMSUFBb0FoQWdBQ2dDSUd3Z0FDZ0NEQ0FJYkdvZ0FDZ0NGQ0FFYkdvZ0FDZ0NHQ0FBS0FJa2JHb2lBU0FBS0FJSVR3UkFEQW9MSUFBb0FnUWdBVUVCZEdvaUFTOEJBQTBCREFzTElBQW9BdUFCSWdFZ0FDZ0M2QUVpQm1vZ0FTQUdjR3NoQmd3QkMwRUFJUUVNQXd0QkFTRUJEQUlMQTBBQ1FBSkFBa0FDUUNBQlJRUkFJQVFnRWs4TkFpQUFJQUFvQWpBaUJ6WUNJQ0FOSUFSQkJIUnFJUXNNQVFzZ0FDQUhRUUZxSWdjMkFpQUxJQUFvQWp3aUFTQUxLQUlJSWdJZ0FTQUNTUnNnQjBzRVFDQUxLQUlBSWdFZ0FhMGlIaUFDSUFkQmYzTnFJZ3F0SWhhR0loY2dGb2luUncwRElBc29BZ1FpQWtKL0lCYUlwM0VnQWtjTkF5QUNyU0lWSUJhR0loaENBWDBpR1NBQU5RTFlBWHdnR0lBaEh5QVpJQUFvQXRBQklnNnRmQ0FZZ0NFYUlCZENBWDBpR3lBQU5RTFVBWHdnRjRBaElDQWJJQUFvQXN3QklneXRmQ0FYZ0NFY0lBRkNmeUFMS0FJTUlBZEJCSFJxSWdNb0FnQWlDU0FLYXEwaUhZaW5jU0FCUncwRElBSWdGU0FES0FJRUlnRWdDbXF0SWhXR0lpRWdGWWluUncwRElBQW9BdUFCSWdLdElpSWdJWUpDQUZJRVFDQUNJQTVIRFFSQ2Z5QVZoa0ovaFNBYVF2Ly8vLzhQZ3lBV2hvTlFEUVFMSUFBb0F0d0JJZ0t0SWhVZ0hpQWRob0pDQUZJRVFDQUNJQXhIRFFSQ2Z5QWRoa0ovaFNBY1F2Ly8vLzhQZ3lBV2hvTlFEUVFMSUFNb0FnZ2lBa1VOQXlBREtBSU1SUTBESUJ5bklnTWdJS2RHRFFNZ0dxY2lDaUFmcDBZTkF5QUFJQUFvQWtRaUNEWUNLQ0FBSUJVZ0czd2dGNENuSUFsMklBTWdDWFpySUJrZ0lud2dHSUNuSUFGMklBb2dBWFpySUFKc2FqWUNKRUVCSVFFTUJRc2dBQ0FFUVFGcUlnUTJBaHdNQVFzZ0FDZ0MzQUVpQVNBQUtBTGtBU0lDYWlBQklBSndheUVQUVFBaEFRd0RDMEVBSVFFTUFRdEJBU0VCREFBTEFBc0FDd0FMQTBBQ2Z3SkFJQUZGQkVBZ0FDQUxRUUZxSWdzMkFpZ01BUXNnQUNBRk5nSWdJQUFvQWp3Z0JVME5CaUFBS0FKc0lRaEJBQXdCQzBFQkN5RUJBMEFDUUFKQUFrQUNRQ0FCUlFSQUlBQWdDRFlDNEFFZ0NDQUFLQUp3VHcwQklBQW9BbVFoRFVFQUlRRU1CQXNnQUNnQ09DQUxUUVJBSUFBb0Fod2hCa0VCSVFFTUJBc2dBQ2dDRUNBQUtBSWdiQ0FBS0FJTUlBdHNhaUFBS0FJVUlBQW9BaHhzYWlBQUtBSVlJQUFvQWlSc2FpSUJJQUFvQWdoUEJFQU1DUXNnQUNnQ0JDQUJRUUYwYWlJQkx3RUFEUUVNQ2dzZ0FDZ0NJRUVCYWlFRkRBRUxRUUFoQVF3REMwRUJJUUVNQWdzRFFBSkFBa0FDUUFKQUlBRkZCRUFnQUNBTk5nTGNBU0FOSUFBb0FtaFBEUUlnQUNBRU5nSWNJQVFoQmd3QkN5QUFJQVpCQVdvaUJqWUNIQXNnQmlBT1NRUkFJQUFvQWlBaUJ5QUFLQUxJQVNBR1FRUjBhaUlCS0FJSUlnTlBEUU1nQVNnQ0FDSUNJQUt0SWg0Z0F5QUhRWDl6YWlJS3JTSVdoaUlYSUJhSXAwY05BeUFCS0FJRUlnTkNmeUFXaUtkeElBTkhEUU1nQTYwaUZTQVdoaUlZUWdGOUloa2dBRFVDMkFGOElCaUFJUjhnR1NBQUtBTFFBU0lQclh3Z0dJQWhHaUFYUWdGOUloc2dBRFVDMUFGOElCZUFJU0FnR3lBQUtBTE1BU0lKclh3Z0Y0QWhIQ0FDUW44Z0FTZ0NEQ0FIUVFSMGFpSUJLQUlBSWdjZ0NtcXRJaDJJcDNFZ0FrY05BeUFESUJVZ0FTZ0NCQ0lDSUFwcXJTSVZoaUloSUJXSXAwY05BeUFBS0FMZ0FTSURyU0lpSUNHQ1FnQlNCRUFnQXlBUFJ3MEVRbjhnRllaQ2Y0VWdHa0wvLy8vL0Q0TWdGb2FEVUEwRUN5QUFLQUxjQVNJRHJTSVZJQjRnSFlhQ1FnQlNCRUFnQXlBSlJ3MEVRbjhnSFlaQ2Y0VWdIRUwvLy8vL0Q0TWdGb2FEVUEwRUN5QUJLQUlJSWdORkRRTWdBU2dDREVVTkF5QWNweUlCSUNDblJnMERJQnFuSWdvZ0g2ZEdEUU1nQUNBQUtBSkVJZ3MyQWlnZ0FDQVZJQnQ4SUJlQXB5QUhkaUFCSUFkMmF5QVpJQ0o4SUJpQXB5QUNkaUFLSUFKMmF5QURiR28yQWlSQkFTRUJEQVVMSUFBb0F0d0JJZ0VnQUNnQzVBRWlBbW9nQVNBQ2NHc2hEUXdCQ3lBQUtBTGdBU0lCSUFBb0F1Z0JJZ0pxSUFFZ0FuQnJJUWhCQUNFQkRBTUxRUUFoQVF3QkMwRUJJUUVNQUFzQUN3QUxBQXNEUUFKL0FrQWdBVVVFUUNBRVFRRnFJUVFNQVFzZ0FDQUROZ0lnSUFBb0Fqd2dBMDBOQlNBQUtBSkVJUUpCQUF3QkMwRUJDeUVCQTBBQ1FBSkFBa0FDUUNBQlJRUkFJQUFnQWpZQ0tDQUNJQUFvQWpoUERRRWdBQ0FHTmdJY0lBWWhBVUVBSVFVTUJBc2dBQ0FFTmdJa0lBQW9Ba3dnQkUwRVFDQUFLQUljSVFGQkFTRUZEQVFMSUFBb0FoQWdBQ2dDSUd3Z0FDZ0NEQ0FBS0FJb2JHb2dBQ2dDRkNBQUtBSWNiR29nQUNnQ0dDQUViR29pQVNBQUtBSUlUd1JBREFnTElBQW9BZ1FnQVVFQmRHb2lBUzhCQUEwQkRBa0xJQUFvQWlCQkFXb2hBd3dCQzBFQUlRRU1Bd3RCQVNFQkRBSUxBMEFDUUFKQUFrQWdCVVVFUUNBQklBZFBEUUVnQUNnQ0lDSUZJQUFvQXNnQklBRkJCSFJxSWcwb0FnaFBEUU1nQUMwQUFFVUVRQ0FBSUEwb0Fnd2dCVUVFZEdvaUFTZ0NEQ0FCS0FJSWJEWUNUQXNnQUNnQ1NDRUVRUUVoQVF3RkN5QUFJQUZCQVdvaUFUWUNIQXdCQ3lBQUtBSW9RUUZxSVFKQkFDRUJEQU1MUVFBaEJRd0JDMEVCSVFVTUFBc0FDd0FMQUF0QkFBOExJQUFvQXV3QlFRRkJ2d3BCQUJBSUMwRUFEd3NnQVVFQk93RUFRUUVMa1FzQkNuOENRQ0FCS0FJQUlBUkJBMndpREhZaUJrR1FnSUFCY1EwQUlBQWdBRUVjYWlJT0lBQW9BbXdnQmtIdkEzRnFMUUFBUVFKMGFpSUtOZ0pvSUFBZ0FDZ0NCQ0FLS0FJQUlna29BZ0FpQ0dzaUJqWUNCQUpBSUFnZ0FDZ0NBQ0lIUVJCMlN3UkFJQWtvQWdRaEN5QUFJQWcyQWdRZ0NpQUpRUWhCRENBR0lBaEpJZ1liYWlnQ0FEWUNBQ0FMSUF0RklBWWJJUWtnQUNnQ0NDRUdBMEFDUUNBR0RRQWdBQ2dDRUNJR1FRRnFJUXNnQmkwQUFTRUtJQVl0QUFCQi93RkdCRUFnQ2tHUUFVOEVRQ0FBSUFBb0FneEJBV28yQWd3Z0IwR0EvZ05xSVFkQkNDRUdEQUlMSUFBZ0N6WUNFQ0FISUFwQkNYUnFJUWRCQnlFR0RBRUxJQUFnQ3pZQ0VFRUlJUVlnQnlBS1FRaDBhaUVIQ3lBQUlBWkJBV3NpQmpZQ0NDQUFJQWRCQVhRaUJ6WUNBQ0FBSUFoQkFYUWlDRFlDQkNBSVFZQ0FBa2tOQUFzZ0NDRUdEQUVMSUFBZ0J5QUlRUkIwYXlJSE5nSUFJQVpCZ0lBQ2NVVUVRQ0FKS0FJRUlRc2dDaUFKUVF4QkNDQUdJQWhKSWdnYmFpZ0NBRFlDQUNBTFJTQUxJQWdiSVFrZ0FDZ0NDQ0VJQTBBQ1FDQUlEUUFnQUNnQ0VDSUlRUUZxSVFzZ0NDMEFBU0VLSUFndEFBQkIvd0ZHQkVBZ0NrR1FBVThFUUNBQUlBQW9BZ3hCQVdvMkFnd2dCMEdBL2dOcUlRZEJDQ0VJREFJTElBQWdDellDRUNBSElBcEJDWFJxSVFkQkJ5RUlEQUVMSUFBZ0N6WUNFRUVJSVFnZ0J5QUtRUWgwYWlFSEN5QUFJQWhCQVdzaUNEWUNDQ0FBSUFkQkFYUWlCellDQUNBQUlBWkJBWFFpQmpZQ0JDQUdRWUNBQWtrTkFBc01BUXNnQ1NnQ0JDRUpDeUFKUlEwQUlBQWdEaUFCS0FJRUlBeEJFV3AyUVFSeElBRkJCR3NpRFNnQ0FDQU1RUk5xZGtFQmNTQUJLQUlBSWdnZ0RFRVFhblpCd0FCeElBZ2dESFpCcWdGeGNpQUlJQXhCREdwQkRpQUVHM1pCRUhGeWNuSWlEMEhndVFGcUxRQUFRUUowYWlJTE5nSm9JQUFnQmlBTEtBSUFJZ29vQWdBaUNHc2lCallDQkFKQUlBZ2dCMEVRZGtzRVFDQUtLQUlFSVFrZ0FDQUlOZ0lFSUFzZ0NrRUlRUXdnQmlBSVNTSUdHMm9vQWdBMkFnQWdDU0FKUlNBR0d5RUtJQUFvQWdnaEJnTkFBa0FnQmcwQUlBQW9BaEFpQmtFQmFpRUxJQVl0QUFFaENTQUdMUUFBUWY4QlJnUkFJQWxCa0FGUEJFQWdBQ0FBS0FJTVFRRnFOZ0lNSUFkQmdQNERhaUVIUVFnaEJnd0NDeUFBSUFzMkFoQWdCeUFKUVFsMGFpRUhRUWNoQmd3QkN5QUFJQXMyQWhCQkNDRUdJQWNnQ1VFSWRHb2hCd3NnQUNBR1FRRnJJZ1kyQWdnZ0FDQUhRUUYwSWdjMkFnQWdBQ0FJUVFGMElnZzJBZ1FnQ0VHQWdBSkpEUUFMREFFTElBQWdCeUFJUVJCMGF5SUpOZ0lBSUFaQmdJQUNjVVVFUUNBS0tBSUVJUWNnQ3lBS1FReEJDQ0FHSUFoSklnZ2JhaWdDQURZQ0FDQUhSU0FISUFnYklRb2dBQ2dDQ0NFSEEwQUNRQ0FIRFFBZ0FDZ0NFQ0lIUVFGcUlRc2dCeTBBQVNFSUlBY3RBQUJCL3dGR0JFQWdDRUdRQVU4RVFDQUFJQUFvQWd4QkFXbzJBZ3dnQ1VHQS9nTnFJUWxCQ0NFSERBSUxJQUFnQ3pZQ0VDQUpJQWhCQ1hScUlRbEJCeUVIREFFTElBQWdDellDRUVFSUlRY2dDU0FJUVFoMGFpRUpDeUFBSUFkQkFXc2lCellDQ0NBQUlBbEJBWFFpQ1RZQ0FDQUFJQVpCQVhRaUJqWUNCQ0FHUVlDQUFra05BQXNNQVFzZ0NpZ0NCQ0VLQ3lBQ1FRQWdBMnNnQXlBS0lBOUI0THNCYWkwQUFITWlBeHMyQWdBZ0RTQU5LQUlBUVNBZ0RIUnlOZ0lBSUFFZ0FTZ0NBQ0FEUVJOMFFSQnlJQXgwY2pZQ0FDQUJJQUVvQWdSQkNDQU1kSEkyQWdRZ0JDQUZja1VFUUNBQlFYNGdBQ2dDZkd0QkFuUnFJZ0lnQWlnQ0JFR0FnQUp5TmdJRUlBSWdBaWdDQUNBRFFSOTBja0dBZ0FSeU5nSUFJQUpCQkdzaUFpQUNLQUlBUVlDQUNISTJBZ0FMSUFSQkEwY05BQ0FCSUFBb0FueEJBblJxSWdCQkJHb2dBQ2dDQkVFRWNqWUNBQ0FBSUFBb0FneEJBWEkyQWd3Z0FDQUFLQUlJSUFOQkVuUnlRUUp5TmdJSUN3dXJDd0VKZndKQUlBRW9BZ0FnQkVFRGJDSU5kaUlIUVpDQWdBRnhEUUFnQjBIdkEzRWlCMFVOQUNBQUlBQkJIR29pRGlBQUtBSnNJQWRxTFFBQVFRSjBhaUlMTmdKb0lBQWdBQ2dDQkNBTEtBSUFJZ29vQWdBaUNXc2lCellDQkFKQUlBa2dBQ2dDQUNJSVFSQjJTd1JBSUFvb0FnUWhEQ0FBSUFrMkFnUWdDeUFLUVFoQkRDQUhJQWxKSWdjYmFpZ0NBRFlDQUNBTUlBeEZJQWNiSVFvZ0FDZ0NDQ0VIQTBBQ1FDQUhEUUFnQUNnQ0VDSUhRUUZxSVF3Z0J5MEFBU0VMSUFjdEFBQkIvd0ZHQkVBZ0MwR1FBVThFUUNBQUlBQW9BZ3hCQVdvMkFnd2dDRUdBL2dOcUlRaEJDQ0VIREFJTElBQWdERFlDRUNBSUlBdEJDWFJxSVFoQkJ5RUhEQUVMSUFBZ0REWUNFRUVJSVFjZ0NDQUxRUWgwYWlFSUN5QUFJQWRCQVdzaUJ6WUNDQ0FBSUFoQkFYUWlDRFlDQUNBQUlBbEJBWFFpQ1RZQ0JDQUpRWUNBQWtrTkFBc2dDU0VIREFFTElBQWdDQ0FKUVJCMGF5SUlOZ0lBSUFkQmdJQUNjVVVFUUNBS0tBSUVJUXdnQ3lBS1FReEJDQ0FISUFsSklna2JhaWdDQURZQ0FDQU1SU0FNSUFrYklRb2dBQ2dDQ0NFSkEwQUNRQ0FKRFFBZ0FDZ0NFQ0lKUVFGcUlRd2dDUzBBQVNFTElBa3RBQUJCL3dGR0JFQWdDMEdRQVU4RVFDQUFJQUFvQWd4QkFXbzJBZ3dnQ0VHQS9nTnFJUWhCQ0NFSkRBSUxJQUFnRERZQ0VDQUlJQXRCQ1hScUlRaEJCeUVKREFFTElBQWdERFlDRUVFSUlRa2dDQ0FMUVFoMGFpRUlDeUFBSUFsQkFXc2lDVFlDQ0NBQUlBaEJBWFFpQ0RZQ0FDQUFJQWRCQVhRaUJ6WUNCQ0FIUVlDQUFra05BQXNNQVFzZ0NpZ0NCQ0VLQ3dKQUlBcEZEUUFnQUNBT0lBRW9BZ1FnRFVFUmFuWkJCSEVnQVVFRWF5SVBLQUlBSUExQkUycDJRUUZ4SUFFb0FnQWlDU0FOUVJCcWRrSEFBSEVnQ1NBTmRrR3FBWEZ5SUFrZ0RVRU1ha0VPSUFRYmRrRVFjWEp5Y2lJS1FlQzVBV290QUFCQkFuUnFJZ3cyQW1nZ0FDQUhJQXdvQWdBaUN5Z0NBQ0lKYXlJSE5nSUVJQXBCNExzQmFpMEFBQ0VPQWtBZ0NTQUlRUkIyU3dSQUlBc29BZ1FoQ2lBQUlBazJBZ1FnRENBTFFRaEJEQ0FISUFsSklnY2JhaWdDQURZQ0FDQUtJQXBGSUFjYklRc2dBQ2dDQ0NFSEEwQUNRQ0FIRFFBZ0FDZ0NFQ0lIUVFGcUlRd2dCeTBBQVNFS0lBY3RBQUJCL3dGR0JFQWdDa0dRQVU4RVFDQUFJQUFvQWd4QkFXbzJBZ3dnQ0VHQS9nTnFJUWhCQ0NFSERBSUxJQUFnRERZQ0VDQUlJQXBCQ1hScUlRaEJCeUVIREFFTElBQWdERFlDRUVFSUlRY2dDQ0FLUVFoMGFpRUlDeUFBSUFkQkFXc2lCellDQ0NBQUlBaEJBWFFpQ0RZQ0FDQUFJQWxCQVhRaUNUWUNCQ0FKUVlDQUFra05BQXNNQVFzZ0FDQUlJQWxCRUhScklnbzJBZ0FnQjBHQWdBSnhSUVJBSUFzb0FnUWhDQ0FNSUF0QkRFRUlJQWNnQ1VraUNSdHFLQUlBTmdJQUlBaEZJQWdnQ1JzaEN5QUFLQUlJSVFnRFFBSkFJQWdOQUNBQUtBSVFJZ2hCQVdvaERDQUlMUUFCSVFrZ0NDMEFBRUgvQVVZRVFDQUpRWkFCVHdSQUlBQWdBQ2dDREVFQmFqWUNEQ0FLUVlEK0Eyb2hDa0VJSVFnTUFnc2dBQ0FNTmdJUUlBb2dDVUVKZEdvaENrRUhJUWdNQVFzZ0FDQU1OZ0lRUVFnaENDQUtJQWxCQ0hScUlRb0xJQUFnQ0VFQmF5SUlOZ0lJSUFBZ0NrRUJkQ0lLTmdJQUlBQWdCMEVCZENJSE5nSUVJQWRCZ0lBQ1NRMEFDd3dCQ3lBTEtBSUVJUXNMSUFKQkFDQURheUFESUFzZ0RuTWlBaHMyQWdBZ0R5QVBLQUlBUVNBZ0RYUnlOZ0lBSUFFZ0FTZ0NBQ0FDUVJOMFFSQnlJQTEwY2pZQ0FDQUJJQUVvQWdSQkNDQU5kSEkyQWdRZ0JDQUdja1VFUUNBQklBVkJBblJySWdBZ0FDZ0NCRUdBZ0FKeU5nSUVJQUFnQUNnQ0FDQUNRUjkwY2tHQWdBUnlOZ0lBSUFCQkJHc2lBQ0FBS0FJQVFZQ0FDSEkyQWdBTElBUkJBMGNOQUNBQklBVkJBblJxSWdBZ0FDZ0NCRUVCY2pZQ0JDQUFJQUFvQWdBZ0FrRVNkSEpCQW5JMkFnQWdBRUVFYXlJQUlBQW9BZ0JCQkhJMkFnQUxJQUVnQVNnQ0FFR0FnSUFCSUExMGNqWUNBQXNMclFFQUlBQkJnSjRCTmdKa0lBQkJnSjRCTmdKZ0lBQkJnSjRCTmdKY0lBQkJnSjRCTmdKWUlBQkJnSjRCTmdKVUlBQkJnSjRCTmdKUUlBQkJnSjRCTmdKTUlBQkJnSjRCTmdKSUlBQkJnSjRCTmdKRUlBQkJnSjRCTmdKQUlBQkJnSjRCTmdJOElBQkJnSjRCTmdJNElBQkJnSjRCTmdJMElBQkJnSjRCTmdJd0lBQkJnSjRCTmdJc0lBQkJnSjRCTmdJb0lBQkJnSjRCTmdJa0lBQkJnSjRCTmdJZ0lBQkJnSjRCTmdJY0M1SUdBZ2wvQkg0Z0FDQUJOZ0lBSUFEOURBQUFBQUFBQUFBQUFBQUFBQUFBQUFEOUN3TUlJQUFnQXpZQ0hDQUFJQUpCQVdzaUJUWUNHQ0FCUVFOeElRb0NmeUFDUVFCTUJFQWdBU0VFSUFNTUFRc2dBQ0FCUVFGcUlnUTJBZ0FnQVMwQUFBc2hBVUVJSVFjZ0FFRUlOZ0lRSUFBZ0FhMGlEVGNEQ0NBQUlBMUMvd0dESWc1Qy93RlJJZ2syQWhRQ1FDQUtRUU5HRFFBZ0FDQUNRUUpySWdnMkFoZ0NmeUFDUVFKSUJFQWdCQ0VCSUFNTUFRc2dBQ0FFUVFGcUlnRTJBZ0FnQkMwQUFBc2hCQ0FBUVE5QkVDQU9RdjhCVVJzaUJ6WUNFQ0FBSUFTdElnNUMvd0dESWc5Qy93RlJJZ2syQWhRZ0FDQU9RZ2lHSUEyRUlnMDNBd2dnQ2tFQ1JnUkFJQUVoQkNBRklRSWdDQ0VGREFFTElBQWdBa0VEYXlJTE5nSVlJQUFDZnlBQ1FRTklCRUFnQVNFR0lBTU1BUXNnQUNBQlFRRnFJZ1kyQWdBZ0FTMEFBQXV0SWc1Qy93R0RJaEJDL3dGUklnazJBaFFnQUVFSFFRZ2dEMEwvQVZFYklBZHFJZ0UyQWhBZ0FDQU9JQWV0aGlBTmhDSU5Od01JSUFwQkFVWUVRQ0FHSVFRZ0FTRUhJQWdoQWlBTElRVU1BUXNnQUNBQ1FRUnJJZ1UyQWhnZ0FBSi9JQUpCQkVnRVFDQUdJUVFnQXd3QkN5QUFJQVpCQVdvaUJEWUNBQ0FHTFFBQUM2MGlEa0wvQVlOQy93RlJJZ2syQWhRZ0FFRUhRUWdnRUVML0FWRWJJQUZxSWdjMkFoQWdBQ0FPSUFHdGhpQU5oQ0lOTndNSUlBc2hBZ3NDUUNBQ1FRVk9CRUFnQkNnQ0FDRURJQUFnQWtFRmF6WUNHQ0FBSUFSQkJHbzJBZ0FNQVF0QkFDRUJRWDlCQUNBREd5RURJQUpCQWtnTkFBTkFJQUFnQkVFQmFpSUNOZ0lBSUFRdEFBQWhCQ0FBSUFWQkFXc2lCallDR0NBRFFmOEJJQUYwUVg5emNTQUVJQUYwY2lFRElBRkJDR29oQVNBRlFRRkxJUXdnQWlFRUlBWWhCU0FNRFFBTEN5QUFJQU5CR0hZaUFVSC9BVVkyQWhRZ0FFRUhRUWdnQ1JzaUFrRUhRUWdnQTBIL0FYRWlCRUgvQVVZYmFpSUZRUWRCQ0NBRFFRaDJRZjhCY1NJR1FmOEJSaHRxSWdoQkIwRUlJQU5CRUhaQi93RnhJZ05CL3dGR0d5QUhhbW8yQWhBZ0FDQUdJQUowSUFNZ0JYUnlJQUVnQ0hSeUlBUnlyU0FIcllZZ0RZUTNBd2dMdGdVQ0VuOENmZ0ovSUFBb0Fod2dBVUdZQVd4cUlnSkJrQUZyS0FJQUlBSkJtQUZyS0FJQWF5SURJUVVnQWtHTUFXc29BZ0FnQWtHVUFXc29BZ0JySWdJaEJrSEFBQ0FESUFOQndBQlBHeUVEUWNBQUlBSWdBa0hBQUU4YklRUUNRQ0FGUlEwQUlBWkZEUUFnQTBVTkFDQUVSUTBBUVg4Z0JHNUJBbllnQTBrTkFFRUJRUndRRENJQ0lBUTJBZ3dnQWlBRE5nSUlJQUlnQmpZQ0JDQUNJQVUyQWdBZ0FpQUVyU0lVSUFhdGZFSUJmU0FVZ0NJVXB5SUVOZ0lVSUFJZ0E2MGlGU0FGclh4Q0FYMGdGWUFpRmFjaUF6WUNFQUpBSUJSQy8vLy8vdytESUJWQy8vLy8vdytEZmtJZ2lLY05BQ0FDUVFRZ0F5QUViQkFNSWdNMkFoZ2dBMFVOQUNBQ0RBSUxJQUlRQ1F0QkFBc2lDVVVFUUVFQUR3c0NRQ0FCQkVBRFFDQU9RWmdCYkNJUElBQW9BaHhxSWdVb0FoZ2lBZ1JBSUFWQkhHb2hFQ0FGS0FJVUlRTWdCU2dDRUNFRVFRQWhDZ05BSUFNZ0JHd0VRQ0FRSUFwQkpHeHFJUVpCQUNFTEEwQWdCaWdDRkNBTFFTaHNhaUlJS0FJVUlnSWdDQ2dDRUNJSGJBUkFRUUFoQkFOQUlBZ29BaGdnQkVFR2RHb2lBeWdDUENJUkJFQWdBeWdDRENFSElBTW9BaFFoRWlBREtBSVFJUXdnQXlnQ0NDSVRJQVlvQWdCcklRTWdCaWdDRUNJTlFRRnhCRUFnQUNnQ0hDQVBhaUlDUVpBQmF5Z0NBQ0FEYWlBQ1FaZ0JheWdDQUdzaEF3c2dCeUFHS0FJRWF5RUNJQTFCQW5FRVFDQUNJQUFvQWh3Z0Qyb2lEVUdNQVdzb0FnQnFJQTFCbEFGcktBSUFheUVDQ3lBSklBTWdBaUFESUF3Z0Uyc2lER29nRWlBSGF5QUNhaUFSUVFFZ0RFRUFFQjlGRFFrZ0NDZ0NFQ0VISUFnb0FoUWhBZ3NnQkVFQmFpSUVJQUlnQjJ4SkRRQUxJQVVvQWhBaEJDQUZLQUlVSVFNTElBdEJBV29pQ3lBRElBUnNTUTBBQ3lBRktBSVlJUUlMSUFwQkFXb2lDaUFDU1EwQUN3c2dEa0VCYWlJT0lBRkhEUUFMQ3lBSkR3c2dDUkFkUVFBTDBBd0NFSDhHZXlBQUtBSUlJZ3NnQUNnQ0JHb2hCd0pBSUFBb0FneEZCRUFnQjBFQ1NBMEJJQUVvQWdBZ0FTQUxRUUowYWlJTktBSUFJZ1JCQVdwQkFYVnJJUU1nQUNnQ0FDRUdBa0FnQjBFRVNRUkFJQVFoQWd3QkN5QUhRUVJySWdCQkFYWWlDVUVCYWlFTUFrQWdBRUVXU1FSQVFRRWhBQXdCQ3lBR0lBRWdDMEVDZEdvaUJTQUpRUUowSWdKcVFRaHFTU0FHSUFsQkEzUnFRUWhxSWdBZ0JVRUVha3R4QkVCQkFTRUFEQUVMSUFZZ0FTQUNha0VJYWtrZ0FVRUVhaUFBU1hFRVFFRUJJUUFNQVFzZ0RFSDgvLy8vQjNFaUJVRUJjaUVBSUFWQkFYUWhDQ0FFL1JFaEVpQUQvUkVoRS8wTUFBQUFBQUlBQUFBRUFBQUFCZ0FBQUNFV1FRQWhBZ05BSUFFZ0FrRUNkRUVFY2lJRGF2MEFBZ0FoRlNBRElBMXEvUUFDQUNFVUlBWWdBa0VEZEdvaUF5QVQvVm9DQUFNZ0EwRUlhaUFWSUJRZ0VpQVUvUTBNRFE0UEVCRVNFeFFWRmhjWUdSb2JJaFg5cmdIOURBSUFBQUFDQUFBQUFnQUFBQUlBQUFEOXJnRkJBdjJzQWYyeEFTSVMvVm9DQUFBZ0EwRVFhaUFTL1ZvQ0FBRWdBMEVZYWlBUy9Wb0NBQUlnQmlBVy9Rd0JBQUFBQVFBQUFBRUFBQUFCQUFBQS9WQWlGLzBiQUVFQ2RHb2dFaUFUSUJMOURRd05EZzhRRVJJVEZCVVdGeGdaR2h2OXJnRkJBZjJzQVNBVi9hNEJJaFA5V2dJQUFDQUdJQmY5R3dGQkFuUnFJQlA5V2dJQUFTQUdJQmY5R3dKQkFuUnFJQlA5V2dJQUFpQUdJQmY5R3dOQkFuUnFJQlA5V2dJQUF5QVcvUXdJQUFBQUNBQUFBQWdBQUFBSUFBQUEvYTRCSVJZZ0VpRVRJQlFoRWlBQ1FRUnFJZ0lnQlVjTkFBc2dFdjBiQXlFQ0lCUDlHd01oQXlBRklBeEdEUUVnQWlFRUN3TkFJQUVnQUVFQ2RDSUNhaWdDQUNFSklBSWdEV29vQWdBaEFpQUdJQWhCQW5ScUlnVWdBellDQUNBRklBTWdDU0FDSUFScVFRSnFRUUoxYXlJRGFrRUJkU0FFYWpZQ0JDQUlRUUpxSVFnZ0FDQU1SeUVRSUFJaEJDQUFRUUZxSVFBZ0VBMEFDd3NnQmlBSVFRSjBhaUFETmdJQVFYd2hBQ0FIUVFGeEJIOGdCaUFIUVFGcklnQkJBblJxSUFFZ0FFRUJkR29vQWdBZ0FrRUJha0VCZFdzaUFEWUNBQ0FBSUFOcVFRRjFJUU5CZUFWQmZBc2dCaUFIUVFKMElnQnFhaUFDSUFOcU5nSUFJQUVnQmlBQUVBc2FEd3NDUUFKQUFrQWdCMEVCYXc0Q0FBRUNDeUFCSUFFb0FnQkJBbTAyQWdBUEN5QUFLQUlBSWdRZ0FTZ0NBQ0FCSUF0QkFuUnFJZ01vQWdCQkFXcEJBWFZySWdBMkFnUWdCQ0FBSUFNb0FnQnFOZ0lBSUFFZ0JDa0NBRGNDQUE4TElBZEJBMGdOQUNBQUtBSUFJZ29nQVNnQ0FDQUJJQXRCQW5ScUlnNG9BZ1FpQkNBT0tBSUFJZ0JxUVFKcVFRSjFheUlESUFCcU5nSUFRUUVoQ0FKQUlBZEJBbXNpQmlBSFFRRnhJZ3hGSWdCclFRSkpCRUFnQkNFQ0RBRUxJQWNnQUd0QkJHc2lBRUVCZGlJQ1FRRnFJUThDUUFKQUlBQkJGa2tOQUNBS1FRUnFJZ1VnQVNBQ1FRSjBJZ0JxUVFocVNTQUtJQUpCQTNScVFReHFJZ0lnQVVFRWFrdHhEUUFnQlNBQUlBRWdDMEVDZEdvaUFHcEJER3BKSUFCQkNHb2dBa2x4RFFBZ0QwRjhjU0lGUVFGeUlRQWdCVUVCZEVFQmNpRUlJQVQ5RVNFVElBUDlFU0VTUVFBaEFnTkFJQW9nQWtFRGRHb2lCQ0FCSUFKQkFuUWlBMnI5QUFJRUlCTWdBeUFPYXYwQUFnZ2lFLzBOREEwT0R4QVJFaE1VRlJZWEdCa2FHeUlWSUJQOXJnSDlEQUlBQUFBQ0FBQUFBZ0FBQUFJQUFBRDlyZ0ZCQXYyc0FmMnhBU0lVSUJRZ0VpQVUvUTBNRFE0UEVCRVNFeFFWRmhjWUdSb2IvYTRCUVFIOXJBRWdGZjJ1QVNJVi9RMEVCUVlIR0JrYUd3Z0pDZ3NjSFI0Zi9Rc0NGQ0FFSUJJZ0ZmME5EQTBPRHhBUkVoTUFBUUlERkJVV0Z5QVUvUTBBQVFJREJBVUdCeEFSRWhNTURRNFAvUXNDQkNBVUlSSWdBa0VFYWlJQ0lBVkhEUUFMSUJQOUd3TWhBaUFTL1JzRElRTWdCU0FQUmcwQ0lBSWhCQXdCQzBFQklRQUxBMEFnQVNBQVFRSjBhaWdDQUNFTklBNGdBRUVCYWlJRlFRSjBhaWdDQUNFQ0lBb2dDRUVDZEdvaUNTQUROZ0lBSUFrZ0F5QU5JQUlnQkdwQkFtcEJBblZySWdOcVFRRjFJQVJxTmdJRUlBaEJBbW9oQ0NBQUlBOUhJUkVnQWlFRUlBVWhBQ0FSRFFBTEN5QUtJQWhCQW5ScUlBTTJBZ0FDUUNBTVJRUkFJQW9nQmtFQ2RHb2dBU0FIUVFGMGFrRUVheWdDQUNBQ1FRRnFRUUYxYXlJQUlBTnFRUUYxSUFKcU5nSUFEQUVMSUFJZ0Eyb2hBQXNnQ2lBSFFRSjBJZ05xUVFScklBQTJBZ0FnQVNBS0lBTVFDeG9MQzZBSEF3TjlBM3NDZnlBRFFRaFBCRUFnQTBFRGRpRUxBMEFnQWYwQUJBQWhCeUFBSUFEOUFBUUFJZ2dnQXYwQUJBQWlDZjBNdkhTelA3eDBzeis4ZExNL3ZIU3pQLzNtQWYza0FmMExCQUFnQVNBSUlBZjlETTh4c0Q3UE1iQSt6ekd3UHM4eHNENzk1Z0g5NVFFZ0NmME00ZEUyUCtIUk5qL2gwVFkvNGRFMlAvM21BZjNsQWYwTEJBQWdBaUFJSUFmOURPWFE0ai9sME9JLzVkRGlQK1hRNGovOTVnSDk1QUg5Q3dRQUlBSDlBQVFRSVFjZ0FDQUEvUUFFRUNJSUlBTDlBQVFRSWduOURMeDBzeis4ZExNL3ZIU3pQN3gwc3ovOTVnSDk1QUg5Q3dRUUlBRWdDQ0FIL1F6UE1iQSt6ekd3UHM4eHNEN1BNYkErL2VZQi9lVUJJQW45RE9IUk5qL2gwVFkvNGRFMlArSFJOai85NWdIOTVRSDlDd1FRSUFJZ0NDQUgvUXpsME9JLzVkRGlQK1hRNGovbDBPSS8vZVlCL2VRQi9Rc0VFQ0FDUVNCcUlRSWdBVUVnYWlFQklBQkJJR29oQUNBS1FRRnFJZ29nQzBjTkFBc0xBa0FnQTBFSGNTSURSUTBBSUFFcUFnQWhCQ0FBSUFJcUFnQWlCa084ZExNL2xDQUFLZ0lBSWdXU09BSUFJQUVnQlNBRVE4OHhzTDZVa2lBR1ErSFJOcitVa2pnQ0FDQUNJQVVnQkVQbDBPSS9sSkk0QWdBZ0EwRUJSZzBBSUFFcUFnUWhCQ0FBSUFJcUFnUWlCa084ZExNL2xDQUFLZ0lFSWdXU09BSUVJQUVnQlNBRVE4OHhzTDZVa2lBR1ErSFJOcitVa2pnQ0JDQUNJQVVnQkVQbDBPSS9sSkk0QWdRZ0EwRUNSZzBBSUFFcUFnZ2hCQ0FBSUFJcUFnZ2lCa084ZExNL2xDQUFLZ0lJSWdXU09BSUlJQUVnQlNBRVE4OHhzTDZVa2lBR1ErSFJOcitVa2pnQ0NDQUNJQVVnQkVQbDBPSS9sSkk0QWdnZ0EwRURSZzBBSUFFcUFnd2hCQ0FBSUFJcUFnd2lCa084ZExNL2xDQUFLZ0lNSWdXU09BSU1JQUVnQlNBRVE4OHhzTDZVa2lBR1ErSFJOcitVa2pnQ0RDQUNJQVVnQkVQbDBPSS9sSkk0QWd3Z0EwRUVSZzBBSUFFcUFoQWhCQ0FBSUFJcUFoQWlCa084ZExNL2xDQUFLZ0lRSWdXU09BSVFJQUVnQlNBRVE4OHhzTDZVa2lBR1ErSFJOcitVa2pnQ0VDQUNJQVVnQkVQbDBPSS9sSkk0QWhBZ0EwRUZSZzBBSUFFcUFoUWhCQ0FBSUFJcUFoUWlCa084ZExNL2xDQUFLZ0lVSWdXU09BSVVJQUVnQlNBRVE4OHhzTDZVa2lBR1ErSFJOcitVa2pnQ0ZDQUNJQVVnQkVQbDBPSS9sSkk0QWhRZ0EwRUdSZzBBSUFFcUFoZ2hCQ0FBSUFJcUFoZ2lCa084ZExNL2xDQUFLZ0lZSWdXU09BSVlJQUVnQlNBRVE4OHhzTDZVa2lBR1ErSFJOcitVa2pnQ0dDQUNJQVVnQkVQbDBPSS9sSkk0QWhnTEMrQUJBZ1ovQTNzQ1FDQURSUTBBSUFOQkJFOEVRQ0FEUVh4eElRWURRQ0FBSUFSQkFuUWlCV29pQnlBSC9RQUNBQ0FDSUFWcUlnZjlBQUlBSWdzZ0FTQUZhaUlGL1FBQ0FDSU0vYTRCUVFMOXJBSDlzUUVpQ2lBTC9hNEIvUXNDQUNBRklBcjlDd0lBSUFjZ0NpQU0vYTRCL1FzQ0FDQUVRUVJxSWdRZ0JrY05BQXNnQXlBR1JnMEJDd05BSUFBZ0JrRUNkQ0lFYWlJRklBVW9BZ0FnQWlBRWFpSUZLQUlBSWdjZ0FTQUVhaUlJS0FJQUlnbHFRUUoxYXlJRUlBZHFOZ0lBSUFnZ0JEWUNBQ0FGSUFRZ0NXbzJBZ0FnQmtFQmFpSUdJQU5IRFFBTEN3dmRBUUVFZnlNQVFZQUJheUlHSkFBZ0JpRUZBa0FnQVNnQ0RDQUNRUVIwYWlJQ0tBSUFJZ1JGQkVBZ0FpRUJEQUVMQTBBZ0JTQUNOZ0lBSUFWQkJHb2hCU0FFSWdFaUFpZ0NBQ0lFRFFBTEMwRUFJUVFEUUNBQktBSUlJZ0lnQkVnRVFDQUJJQVEyQWdnZ0JDRUNDd0pBSUFJZ0EwNE5BQU5BSUFJZ0FTZ0NCRTROQVFKQUlBQkJBUkFaQkVBZ0FTQUNOZ0lFREFFTElBSkJBV29oQWdzZ0FpQURTQTBBQ3dzZ0FTQUNOZ0lJSUFVZ0JrY0VRQ0FGUVFScklnVW9BZ0FoQVNBQ0lRUU1BUXNMSUFFb0FnUWhCeUFHUVlBQmFpUUFJQWNnQTBnTC9RWUJDMzhqQUVHQUFtc2lDaVFBQWtBZ0FFVUVRRUVBSVFBTUFRc0NRQ0FCSUFBb0FnQkdCRUFnQUNnQ0JDQUNSZzBCQ3lBQUlBSTJBZ1FnQUNBQk5nSUFJQW9nQWpZQ0FDQUtJQUUyQW9BQklBSWhCQ0FCSVFVRFFDQUtJQWNpREVFQmFpSUhRUUowSWdocUlBUkJBV3BCQW0waUNUWUNBQ0FLUVlBQmFpQUlhaUFGUVFGcVFRSnRJZ2cyQWdBZ0JpQUVJQVZzSWd0cUlRWWdDU0VFSUFnaEJTQUxRUUZMRFFBTElBQWdCallDQ0FKQUFrQUNRQUpBSUFaRkJFQWdBQ2dDRENJRVJRMENJQUJCREdvaEJRd0JDeUFHUVFSMElnUWdBQ2dDRUUwTkF5QUFLQUlNSUFRUUVDSUJEUUlnQTBFQlFab3hRUUFRQ0NBQVFReHFJZ1VvQWdBaUJFVU5BUXNnQkJBSklBVkJBRFlDQUFzZ0FCQUpRUUFoQUF3REN5QUFJQUUyQWd3Z0FTQUFLQUlRSWdKcVFRQWdCQ0FDYXhBT0dpQUFJQVEyQWhBZ0FDZ0NCQ0VDSUFBb0FnQWhBUXNnQUNnQ0RDRUZJQXdFUUVFQUlRTWdCU0FCSUFKc1FRUjBhaUlFSVFZRFFBSkFJQW9nQTBFQ2RDSUJhaWdDQUNJSVFRQk1EUUFnQ0VFQmF5RUxRUUFoQ1FKQUFrQWdDa0dBQVdvZ0FXb29BZ0FpQWtFQVRBUkFJQWhCQVhFaERVRUFJUWNnQ0VFQlJ3MEJJQVloQVF3Q0N3TkFJQVloQVNBQ0lRWURRQUpBSUFVZ0JEWUNBQ0FHUVFGR0JFQWdCVUVRYWlFRklBUkJFR29oQkF3QkN5QUZJQVEyQWhBZ0JFRVFhaUVFSUFWQklHb2hCU0FHUVFKS0lRNGdCa0VDYXlFR0lBNE5BUXNMSUFRZ0FTQUNRUVIwYWlBSklBa2dDMFp5UVFGeElnY2JJUVlnQkNBQklBY2JJUVFnQ1VFQmFpSUpJQWhIRFFBTERBSUxJQWhCL3YvLy93ZHhJUWdEUUNBSElBdEdJUUVnQjBFQ2FpRUhJQVFnQmlBQkd5SUVJUVlnQkNFQklBbEJBbW9pQ1NBSVJ3MEFDd3NnRFVVRVFDQUVJUVlNQVFzZ0JDQUJJQUpCQkhScUlBY2dCeUFMUm5KQkFYRWlBaHNoQmlBRUlBRWdBaHNoQkFzZ0EwRUJhaUlESUF4SERRQUxDeUFGUVFBMkFnQUxJQUFvQWdnaUFVVU5BQ0FBS0FJTUlRUWdBVUVFVHdSQUlBRkJmSEVoQWtFQUlRVURRQ0FFUVFBMkFqd2dCRUxuQnpjQ05DQUVRUUEyQWl3Z0JFTG5CemNDSkNBRVFRQTJBaHdnQkVMbkJ6Y0NGQ0FFUVFBMkFnd2dCRUxuQnpjQ0JDQUVRVUJySVFRZ0JVRUVhaUlGSUFKSERRQUxDeUFCUVFOeElnRkZEUUJCQUNFRkEwQWdCRUVBTmdJTUlBUkM1d2MzQWdRZ0JFRVFhaUVFSUFWQkFXb2lCU0FCUncwQUN3c2dDa0dBQW1va0FDQUFDN0VCQVFOL0FrQWdBRVVOQUNBQUtBSUlJZ0ZGRFFBZ0FDZ0NEQ0VBSUFGQkJFOEVRQ0FCUVh4eElRTURRQ0FBUVFBMkFqd2dBRUxuQnpjQ05DQUFRUUEyQWl3Z0FFTG5CemNDSkNBQVFRQTJBaHdnQUVMbkJ6Y0NGQ0FBUVFBMkFnd2dBRUxuQnpjQ0JDQUFRVUJySVFBZ0FrRUVhaUlDSUFOSERRQUxDeUFCUVFOeElnRkZEUUJCQUNFQ0EwQWdBRUVBTmdJTUlBQkM1d2MzQWdRZ0FFRVFhaUVBSUFKQkFXb2lBaUFCUncwQUN3c0wrd1VCRUg4akFFR0FBbXNpQ0NRQUFuOUJBVUVVRUF3aUJrVUVRQ0FDUVFGQjlEQkJBQkFJUVFBTUFRc2dCaUFCTmdJRUlBWWdBRFlDQUNBSUlBRTJBZ0FnQ0NBQU5nS0FBUU5BSUFnZ0JTSU5RUUZxSWdWQkFuUWlCMm9nQVVFQmFrRUNiU0lETmdJQUlBaEJnQUZxSUFkcUlBQkJBV3BCQW0waUJ6WUNBQ0FFSUFBZ0FXd2lDV29oQkNBRElRRWdCeUVBSUFsQkFVc05BQXNnQmlBRU5nSUlJQVJGQkVBZ0JoQUpRUUFNQVFzZ0JpQUVRUkFRRENJRE5nSU1JQU5GQkVBZ0FrRUJRZG9hUVFBUUNDQUdFQWxCQUF3QkN5QUdJQVlvQWdnaUMwRUVkRFlDRUNBRElRQWdEUVJBSUFNZ0JpZ0NCQ0FHS0FJQWJFRUVkR29pQkNFQkEwQUNRQ0FJSUE1QkFuUWlBbW9vQWdBaUNVRUFUQTBBSUFsQkFXc2hERUVBSVFjQ1FDQUlRWUFCYWlBQ2FpZ0NBQ0lDUVFCTUJFQkJBQ0VGSUFsQkFVY0VRQ0FKUWY3Ly8vOEhjU0VLQTBBZ0JTQU1SaUVQSUFWQkFtb2hCU0FCSUFRZ0R4c2lCQ0VCSUFkQkFtb2lCeUFLUncwQUN3c2dDVUVCY1EwQklBUWhBUXdDQ3dOQUlBUWhCU0FDSVFRRFFBSkFJQUFnQVRZQ0FDQUVRUUZHQkVBZ0FFRVFhaUVBSUFGQkVHb2hBUXdCQ3lBQUlBRTJBaEFnQVVFUWFpRUJJQUJCSUdvaEFDQUVRUUpLSVJBZ0JFRUNheUVFSUJBTkFRc0xJQUVnQlNBQ1FRUjBhaUFISUFjZ0RFWnlRUUZ4SWdvYklRUWdBU0FGSUFvYklRRWdCMEVCYWlJSElBbEhEUUFMREFFTElBRWdCQ0FDUVFSMGFpQUZJQVVnREVaeVFRRnhJZ1ViSVJFZ0FTQUVJQVViSVFFZ0VTRUVDeUFPUVFGcUlnNGdEVWNOQUFzTElBQkJBRFlDQUFKQUlBdEZEUUFnQzBFRVR3UkFJQXRCZkhFaEFFRUFJUUVEUUNBRFFRQTJBandnQTBMbkJ6Y0NOQ0FEUVFBMkFpd2dBMExuQnpjQ0pDQURRUUEyQWh3Z0EwTG5CemNDRkNBRFFRQTJBZ3dnQTBMbkJ6Y0NCQ0FEUVVCcklRTWdBVUVFYWlJQklBQkhEUUFMQ3lBTFFRTnhJZ0JGRFFCQkFDRUJBMEFnQTBFQU5nSU1JQU5DNXdjM0FnUWdBMEVRYWlFRElBRkJBV29pQVNBQVJ3MEFDd3NnQmdzaEVpQUlRWUFDYWlRQUlCSUxVd0VCZndKL0lBQXRBQXhCL3dGR0JFQWdBRUtBL29PQThBQTNBZ3hCQUNBQUtBSUlJZ0VnQUNnQ0JFOE5BUm9nQUNBQlFRRnFOZ0lJSUFBZ0FTMEFBRUdBL2dOeU5nSU1DeUFBUVFBMkFoQkJBUXNMU1FFQmZ3SkFRUUZCTEJBTUlnRUVRQ0FCUVFBMkFoQUNRQ0FBUVFCTUJFQWdBVUVCUVFnUURDSUFOZ0lrSUFCRkRRRU1Bd3NnQVVFQU5nSU1DeUFCRUFrTFFRQWhBUXNnQVF0K0FnRi9BWDRnQUwwaUEwSTBpS2RCL3c5eElnSkIvdzlIQkh3Z0FrVUVRQ0FCSUFCRUFBQUFBQUFBQUFCaEJIOUJBQVVnQUVRQUFBQUFBQUR3UTZJZ0FSQmZJUUFnQVNnQ0FFRkFhZ3MyQWdBZ0FBOExJQUVnQWtIK0IyczJBZ0FnQTBMLy8vLy8vLy8vaDRCL2cwS0FnSUNBZ0lDQThEK0V2d1VnQUFzTGtRSUFJQUJGQkVCQkFBOExBbjhDUUNBQlFmOEFUUTBBQWtCQmxNOEJLQUlBS0FJQVJRUkFJQUZCZ0g5eFFZQy9BMFlOQWd3QkN5QUJRZjhQVFFSQUlBQWdBVUUvY1VHQUFYSTZBQUVnQUNBQlFRWjJRY0FCY2pvQUFFRUNEQU1MSUFGQmdFQnhRWURBQTBjZ0FVR0FzQU5QY1VVRVFDQUFJQUZCUDNGQmdBRnlPZ0FDSUFBZ0FVRU1ka0hnQVhJNkFBQWdBQ0FCUVFaMlFUOXhRWUFCY2pvQUFVRUREQU1MSUFGQmdJQUVhMEgvL3o5TkJFQWdBQ0FCUVQ5eFFZQUJjam9BQXlBQUlBRkJFblpCOEFGeU9nQUFJQUFnQVVFR2RrRS9jVUdBQVhJNkFBSWdBQ0FCUVF4MlFUOXhRWUFCY2pvQUFVRUVEQU1MQzBHVXhnRkJHVFlDQUVGL0RBRUxJQUFnQVRvQUFFRUJDd3U4QWdBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUZCQ1dzT0VnQUlDUW9JQ1FFQ0F3UUtDUW9LQ0FrRkJnY0xJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBU2dDQURZQ0FBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVElCQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVE1CQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVEFBQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVEVBQURjREFBOExJQUlnQWlnQ0FFRUhha0Y0Y1NJQlFRaHFOZ0lBSUFBZ0FTc0RBRGtEQUE4TElBQWdBaUFERVFNQUN3OExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVFFDQURjREFBOExJQUlnQWlnQ0FDSUJRUVJxTmdJQUlBQWdBVFVDQURjREFBOExJQUlnQWlnQ0FFRUhha0Y0Y1NJQlFRaHFOZ0lBSUFBZ0FTa0RBRGNEQUF0ekFRWi9JQUFvQWdBaUF5d0FBRUV3YXlJQlFRbExCRUJCQUE4TEEwQkJmeUVFSUFKQnpKbXo1Z0JOQkVCQmZ5QUJJQUpCQ213aUJXb2dBU0FGUWYvLy8vOEhjMHNiSVFRTElBQWdBMEVCYWlJRk5nSUFJQU1zQUFFaEJpQUVJUUlnQlNFRElBWkJNR3NpQVVFS1NRMEFDeUFDQzdRVUFoVi9BWDRqQUVGQWFpSUlKQUFnQ0NBQk5nSThJQWhCSjJvaEZpQUlRU2hxSVJFQ1FBSkFBa0FDUUFOQVFRQWhCd05BSUFFaERTQUhJQTVCLy8vLy93ZHpTZzBDSUFjZ0Rtb2hEZ0pBQWtBQ1FBSkFJQUVpQnkwQUFDSUxCRUFEUUFKQUFrQWdDMEgvQVhFaUFVVUVRQ0FISVFFTUFRc2dBVUVsUncwQklBY2hDd05BSUFzdEFBRkJKVWNFUUNBTElRRU1BZ3NnQjBFQmFpRUhJQXN0QUFJaEdTQUxRUUpxSWdFaEN5QVpRU1ZHRFFBTEN5QUhJQTFySWdjZ0RrSC8vLy8vQjNNaUYwb05DU0FBQkVBZ0FDQU5JQWNRRVFzZ0J3MEhJQWdnQVRZQ1BDQUJRUUZxSVFkQmZ5RVFBa0FnQVN3QUFVRXdheUlKUVFsTERRQWdBUzBBQWtFa1J3MEFJQUZCQTJvaEIwRUJJUklnQ1NFUUN5QUlJQWMyQWp4QkFDRU1Ba0FnQnl3QUFDSUxRU0JySWdGQkgwc0VRQ0FISVFrTUFRc2dCeUVKUVFFZ0FYUWlBVUdKMFFSeFJRMEFBMEFnQ0NBSFFRRnFJZ2syQWp3Z0FTQU1jaUVNSUFjc0FBRWlDMEVnYXlJQlFTQlBEUUVnQ1NFSFFRRWdBWFFpQVVHSjBRUnhEUUFMQ3dKQUlBdEJLa1lFUUFKL0FrQWdDU3dBQVVFd2F5SUJRUWxMRFFBZ0NTMEFBa0VrUncwQUFuOGdBRVVFUUNBRUlBRkJBblJxUVFvMkFnQkJBQXdCQ3lBRElBRkJBM1JxS0FJQUN5RVBJQWxCQTJvaEFVRUJEQUVMSUJJTkJpQUpRUUZxSVFFZ0FFVUVRQ0FJSUFFMkFqeEJBQ0VTUVFBaER3d0RDeUFDSUFJb0FnQWlCMEVFYWpZQ0FDQUhLQUlBSVE5QkFBc2hFaUFJSUFFMkFqd2dEMEVBVGcwQlFRQWdEMnNoRHlBTVFZREFBSEloREF3QkN5QUlRVHhxRUdJaUQwRUFTQTBLSUFnb0Fqd2hBUXRCQUNFSFFYOGhDZ0ovUVFBZ0FTMEFBRUV1UncwQUdpQUJMUUFCUVNwR0JFQUNmd0pBSUFFc0FBSkJNR3NpQ1VFSlN3MEFJQUV0QUFOQkpFY05BQ0FCUVFScUlRRUNmeUFBUlFSQUlBUWdDVUVDZEdwQkNqWUNBRUVBREFFTElBTWdDVUVEZEdvb0FnQUxEQUVMSUJJTkJpQUJRUUpxSVFGQkFDQUFSUTBBR2lBQ0lBSW9BZ0FpQ1VFRWFqWUNBQ0FKS0FJQUN5RUtJQWdnQVRZQ1BDQUtRUUJPREFFTElBZ2dBVUVCYWpZQ1BDQUlRVHhxRUdJaENpQUlLQUk4SVFGQkFRc2hFd05BSUFjaEZFRWNJUWtnQVNJWUxBQUFJZ2RCK3dCclFVWkpEUXNnQVVFQmFpRUJJQWNnRkVFNmJHcEJ6OEFCYWkwQUFDSUhRUUZyUVFoSkRRQUxJQWdnQVRZQ1BBSkFJQWRCRzBjRVFDQUhSUTBNSUJCQkFFNEVRQ0FBUlFSQUlBUWdFRUVDZEdvZ0J6WUNBQXdNQ3lBSUlBTWdFRUVEZEdvcEF3QTNBekFNQWdzZ0FFVU5DQ0FJUVRCcUlBY2dBaUFHRUdFTUFRc2dFRUVBVGcwTFFRQWhCeUFBUlEwSUN5QUFMUUFBUVNCeERRc2dERUgvLzN0eElnc2dEQ0FNUVlEQUFIRWJJUXhCQUNFUVFiQUlJUlVnRVNFSkFrQUNRQUovQWtBQ1FBSkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBWUxBQUFJZ2RCVTNFZ0J5QUhRUTl4UVFOR0d5QUhJQlFiSWdkQjJBQnJEaUVFRmhZV0ZoWVdGaFlRRmdrR0VCQVFGZ1lXRmhZV0FnVURGaFlLRmdFV0ZnUUFDd0pBSUFkQndRQnJEZ2NRRmdzV0VCQVFBQXNnQjBIVEFFWU5Dd3dWQ3lBSUtRTXdJUnhCc0FnTUJRdEJBQ0VIQWtBQ1FBSkFBa0FDUUFKQUFrQWdGRUgvQVhFT0NBQUJBZ01FSEFVR0hBc2dDQ2dDTUNBT05nSUFEQnNMSUFnb0FqQWdEallDQUF3YUN5QUlLQUl3SUE2c053TUFEQmtMSUFnb0FqQWdEanNCQUF3WUN5QUlLQUl3SUE0NkFBQU1Gd3NnQ0NnQ01DQU9OZ0lBREJZTElBZ29BakFnRHF3M0F3QU1GUXRCQ0NBS0lBcEJDRTBiSVFvZ0RFRUljaUVNUWZnQUlRY0xJQkVoQVNBSUtRTXdJaHhDQUZJRVFDQUhRU0J4SVEwRFFDQUJRUUZySWdFZ0hLZEJEM0ZCNE1RQmFpMEFBQ0FOY2pvQUFDQWNRZzlXSVJvZ0hFSUVpQ0VjSUJvTkFBc0xJQUVoRFNBSUtRTXdVQTBESUF4QkNIRkZEUU1nQjBFRWRrR3dDR29oRlVFQ0lSQU1Bd3NnRVNFQklBZ3BBekFpSEVJQVVnUkFBMEFnQVVFQmF5SUJJQnluUVFkeFFUQnlPZ0FBSUJ4Q0IxWWhHeUFjUWdPSUlSd2dHdzBBQ3dzZ0FTRU5JQXhCQ0hGRkRRSWdDaUFSSUFGcklnRkJBV29nQVNBS1NCc2hDZ3dDQ3lBSUtRTXdJaHhDQUZNRVFDQUlRZ0FnSEgwaUhEY0RNRUVCSVJCQnNBZ01BUXNnREVHQUVIRUVRRUVCSVJCQnNRZ01BUXRCc2doQnNBZ2dERUVCY1NJUUd3c2hGU0FjSUJFUUl5RU5DeUFUSUFwQkFFaHhEUkVnREVILy8zdHhJQXdnRXhzaERBSkFJQWdwQXpBaUhFSUFVZzBBSUFvTkFDQVJJUTFCQUNFS0RBNExJQW9nSEZBZ0VTQU5hMm9pQVNBQklBcElHeUVLREEwTElBZ3BBekFoSEF3TEN3Si9RZi8vLy84SElBb2dDa0gvLy8vL0IwOGJJZ3dpQjBFQVJ5RUpBa0FDUUFKQUlBZ29BakFpQVVHRURDQUJHeUlOSWdGQkEzRkZEUUFnQjBVTkFBTkFJQUV0QUFCRkRRSWdCMEVCYXlJSFFRQkhJUWtnQVVFQmFpSUJRUU54UlEwQklBY05BQXNMSUFsRkRRRUNRQ0FCTFFBQVJRMEFJQWRCQkVrTkFBTkFRWUNDaEFnZ0FTZ0NBQ0lKYXlBSmNrR0FnWUtFZUhGQmdJR0NoSGhIRFFJZ0FVRUVhaUVCSUFkQkJHc2lCMEVEU3cwQUN3c2dCMFVOQVFzRFFDQUJJQUV0QUFCRkRRSWFJQUZCQVdvaEFTQUhRUUZySWdjTkFBc0xRUUFMSWdFZ0RXc2dEQ0FCR3lJQklBMXFJUWtnQ2tFQVRnUkFJQXNoRENBQklRb01EQXNnQ3lFTUlBRWhDaUFKTFFBQURROE1Dd3NnQ0NrRE1DSWNRZ0JTRFFGQ0FDRWNEQWtMSUFvRVFDQUlLQUl3REFJTFFRQWhCeUFBUVNBZ0QwRUFJQXdRRkF3Q0N5QUlRUUEyQWd3Z0NDQWNQZ0lJSUFnZ0NFRUlhaUlITmdJd1FYOGhDaUFIQ3lFTFFRQWhCd05BQWtBZ0N5Z0NBQ0lOUlEwQUlBaEJCR29nRFJCZ0lnMUJBRWdORHlBTklBb2dCMnRMRFFBZ0MwRUVhaUVMSUFjZ0RXb2lCeUFLU1EwQkN3dEJQU0VKSUFkQkFFZ05EQ0FBUVNBZ0R5QUhJQXdRRkNBSFJRUkFRUUFoQnd3QkMwRUFJUWtnQ0NnQ01DRUxBMEFnQ3lnQ0FDSU5SUTBCSUFoQkJHb2lDaUFORUdBaURTQUphaUlKSUFkTERRRWdBQ0FLSUEwUUVTQUxRUVJxSVFzZ0J5QUpTdzBBQ3dzZ0FFRWdJQThnQnlBTVFZREFBSE1RRkNBUElBY2dCeUFQU0JzaEJ3d0lDeUFUSUFwQkFFaHhEUWxCUFNFSklBQWdDQ3NETUNBUElBb2dEQ0FISUFVUkV3QWlCMEVBVGcwSERBb0xJQWN0QUFFaEN5QUhRUUZxSVFjTUFBc0FDeUFBRFFrZ0VrVU5BMEVCSVFjRFFDQUVJQWRCQW5ScUtBSUFJZ0FFUUNBRElBZEJBM1JxSUFBZ0FpQUdFR0ZCQVNFT0lBZEJBV29pQjBFS1J3MEJEQXNMQzBFQklRNGdCMEVLVHcwSkEwQWdCQ0FIUVFKMGFpZ0NBQTBCSUFkQkFXb2lCMEVLUncwQUN3d0pDMEVjSVFrTUJnc2dDQ0FjUEFBblFRRWhDaUFXSVEwZ0N5RU1DeUFLSUFrZ0RXc2lDeUFLSUF0S0d5SUtJQkJCLy8vLy93ZHpTZzBEUVQwaENTQVBJQW9nRUdvaUFTQUJJQTlJR3lJSElCZEtEUVFnQUVFZ0lBY2dBU0FNRUJRZ0FDQVZJQkFRRVNBQVFUQWdCeUFCSUF4QmdJQUVjeEFVSUFCQk1DQUtJQXRCQUJBVUlBQWdEU0FMRUJFZ0FFRWdJQWNnQVNBTVFZREFBSE1RRkNBSUtBSThJUUVNQVFzTEMwRUFJUTRNQXd0QlBTRUpDMEdVeGdFZ0NUWUNBQXRCZnlFT0N5QUlRVUJySkFBZ0RndW9BZ0VFZnlNQVFkQUJheUlGSkFBZ0JTQUNOZ0xNQVNBRlFhQUJhaUlDUVFCQktCQU9HaUFGSUFVb0Fzd0JOZ0xJQVFKQVFRQWdBU0FGUWNnQmFpQUZRZEFBYWlBQ0lBTWdCQkJqUVFCSURRQWdBQ2dDVEVFQVNDRUlJQUFnQUNnQ0FDSUhRVjl4TmdJQUFuOENRQUpBSUFBb0FqQkZCRUFnQUVIUUFEWUNNQ0FBUVFBMkFod2dBRUlBTndNUUlBQW9BaXdoQmlBQUlBVTJBaXdNQVFzZ0FDZ0NFQTBCQzBGL0lBQVFOdzBCR2dzZ0FDQUJJQVZCeUFGcUlBVkIwQUJxSUFWQm9BRnFJQU1nQkJCakN5RUJJQVlFZnlBQVFRQkJBQ0FBS0FJa0VRQUFHaUFBUVFBMkFqQWdBQ0FHTmdJc0lBQkJBRFlDSENBQUtBSVVHaUFBUWdBM0F4QkJBQVVnQVFzYUlBQWdBQ2dDQUNBSFFTQnhjallDQUNBSURRQUxJQVZCMEFGcUpBQUxKd0VCZjBFY0lRTWdBVUVEY1FSL1FSd0ZJQUFnQVNBQ0VCc2lBRFlDQUVFQVFUQWdBQnNMQy8wREFRVi9BbjlCOE1RQktBSUFJZ0lnQUVFSGFrRjRjU0lCUVFkcVFYaHhJZ05xSVFBQ1FDQURRUUFnQUNBQ1RSdEZCRUFnQUQ4QVFSQjBUUTBCSUFBUUFRMEJDMEdVeGdGQk1EWUNBRUYvREFFTFFmREVBU0FBTmdJQUlBSUxJZ0pCZjBjRVFDQUJJQUpxSWdCQkJHdEJFRFlDQUNBQVFSQnJJZ05CRURZQ0FBSkFBbjlCb000QktBSUFJZ0VFZnlBQktBSUlCVUVBQ3lBQ1JnUkFJQUlnQWtFRWF5Z0NBRUYrY1dzaUJFRUVheWdDQUNFRklBRWdBRFlDQ0NBRUlBVkJmbkZySWdBZ0FDZ0NBR3BCQkdzdEFBQkJBWEVFUUNBQUtBSUVJZ0VnQUNnQ0NDSUVOZ0lJSUFRZ0FUWUNCQ0FBSUFNZ0FHc2lBVFlDQUF3REN5QUNRUkJyREFFTElBSkJFRFlDQUNBQ0lBQTJBZ2dnQWlBQk5nSUVJQUpCRURZQ0RFR2d6Z0VnQWpZQ0FDQUNRUkJxQ3lJQUlBTWdBR3NpQVRZQ0FBc2dBQ0FCUVh4eGFrRUVheUFCUVFGeU5nSUFJQUFDZnlBQUtBSUFRUWhySWdGQi93Qk5CRUFnQVVFRGRrRUJhd3dCQ3lBQlFSMGdBV2NpQTJ0MlFRUnpJQU5CQW5SclFlNEFhaUFCUWY4ZlRRMEFHa0UvSUFGQkhpQURhM1pCQW5NZ0EwRUJkR3RCeHdCcUlnRWdBVUUvVHhzTElnRkJCSFFpQTBHZ3hnRnFOZ0lFSUFBZ0EwR294Z0ZxSWdNb0FnQTJBZ2dnQXlBQU5nSUFJQUFvQWdnZ0FEWUNCRUdvemdGQnFNNEJLUU1BUWdFZ0FhMkdoRGNEQUFzZ0FrRi9Sd3U5QVFFQ2Z3SkFJQUFvQWt3aUFVRUFUZ1JBSUFGRkRRRkJ6TTRCS0FJQUlBRkIvLy8vL3dOeFJ3MEJDd0pBSUFBb0FsQkJDa1lOQUNBQUtBSVVJZ0VnQUNnQ0VFWU5BQ0FBSUFGQkFXbzJBaFFnQVVFS09nQUFEd3NnQUJCb0R3c2dBRUhNQUdvaUFTQUJLQUlBSWdKQi8vLy8vd01nQWhzMkFnQUNRQUpBSUFBb0FsQkJDa1lOQUNBQUtBSVVJZ0lnQUNnQ0VFWU5BQ0FBSUFKQkFXbzJBaFFnQWtFS09nQUFEQUVMSUFBUWFBc2dBU2dDQUJvZ0FVRUFOZ0lBQzN3QkFuOGpBRUVRYXlJQkpBQWdBVUVLT2dBUEFrQUNRQ0FBS0FJUUlnSUVmeUFDQlNBQUVEY05BaUFBS0FJUUN5QUFLQUlVSWdKR0RRQWdBQ2dDVUVFS1JnMEFJQUFnQWtFQmFqWUNGQ0FDUVFvNkFBQU1BUXNnQUNBQlFROXFRUUVnQUNnQ0pCRUFBRUVCUncwQUlBRXRBQThhQ3lBQlFSQnFKQUFMc0FJQkFuOGdBQVJBSUFBb0FnQVFNU0FBUVFBMkFnQWdBQ2dDU0NJQkJFQWdBUkFKSUFCQkFEWUNTQXNnQUNnQ1JDSUJCRUFnQVJBSklBQkJBRFlDUkFzZ0FDZ0NiQ0lCQkVBZ0FSQUpJQUJCQURZQ2JBc2dBQ2dDZENJQkJFQWdBU2dDQUNJQ0JFQWdBaEFKSUFBb0FuUWlBVUVBTmdJQUN5QUJFQWtnQUVFQU5nSjBDeUFBS0FKNElnRUVRQ0FCS0FJTUlnSUVRQ0FDRUFrZ0FDZ0NlQ0lCUVFBMkFnd0xJQUVvQWdRaUFnUkFJQUlRQ1NBQUtBSjRJZ0ZCQURZQ0JBc2dBU2dDQ0NJQ0JFQWdBaEFKSUFBb0FuZ2lBVUVBTmdJSUN5QUJLQUlBSWdJRVFDQUNFQWtnQUNnQ2VDSUJRUUEyQWdBTElBRVFDU0FBUVFBMkFuZ0xJQUFvQWdRaUFRUkFJQUVRTFNBQVFRQTJBZ1FMSUFBb0FnZ2lBUVJBSUFFUUxTQUFRUUEyQWdnTElBQVFDUXNMaGhzQ0huOEZleU1BUWZBQmF5SUpKQUJCQVNFT0FrQWdBQ2dDQUNnQ1BBMEFJQUFvQW9BQkRRQUNRQUpBSUFBb0FuUWlDRVVFUUNBQUtBSjRJUVFNQVFzZ0FTZ0NFQ0VESUFndkFRUWhCZ0pBSUFBb0FuZ2lCRVVOQUNBRUtBSU1SUTBBSUFRdEFCSWhBd3NDUUNBR0JFQWdDQ2dDQUNFSUEwQWdDQ0FGUVFac2FpSUtMd0VBSWdjZ0EwOEVRQ0FKSUFNMkFyUUJJQWtnQnpZQ3NBRWdBa0VCUWJEbUFDQUpRYkFCYWhBSVFRQWhEZ3dHQ3dKQUlBb3ZBUVFpQ2tVTkFDQUtRZi8vQTBZTkFDQUtRUUZySWdvZ0Ewa05BQ0FKSUFNMkFxUUJJQWtnQ2pZQ29BRWdBa0VCUWJEbUFDQUpRYUFCYWhBSVFRQWhEZ3dHQ3lBRlFRRnFJZ1VnQmtjTkFBc01BUXNnQXcwQ0RBRUxBMEFnQTBFQmF5RURRUUFoQlFOQUlBZ2dCVUVHYkdvdkFRQWdBMGNFUUNBRlFRRnFJZ1VnQmtjTkFRd0VDd3NnQXcwQUN3c0NRQ0FFUlEwQUlBUW9BZ3dpQ2tVTkFBSkFBa0FnQkMwQUVpSUlCRUJCQUNFRlFRRWhCd05BSUFFb0FoQWlBeUFLSUFWQkFuUnFMd0VBSWdSTkJFQWdDU0FETmdLVUFTQUpJQVEyQXBBQklBSkJBVUd3NWdBZ0NVR1FBV29RQ0VFQUlRY0xJQVZCQVdvaUJTQUlSdzBBQ3lBSVFRUVFEQ0lEUlEwQlFRQWhCUU5BQWtBZ0NpQUZRUUowYWlJRUxRQUNJZ1pCQWs4RVFDQUpJQVkyQWtRZ0NTQUZOZ0pBSUFKQkFVSGIyUUFnQ1VGQWF4QUlRUUFoQnd3QkN5QUlJQVF0QUFNaUJFMEVRQ0FKSUFRMkFvQUJJQUpCQVVHajJRQWdDVUdBQVdvUUNFRUFJUWNNQVFzZ0F5QUVRUUowYWlFTEFrQWdCa0VCUnlJTURRQWdDeWdDQUVVTkFDQUpJQVEyQWxBZ0FrRUJRWmZWQUNBSlFkQUFhaEFJUVFBaEJ3d0JDd0pBSUFZTkFDQUVSUTBBSUFrZ0JEWUNaQ0FKSUFVMkFtQWdBa0VCUVpyWUFDQUpRZUFBYWhBSVFRQWhCd3dCQ3dKQUlBd05BQ0FFSUFWR0RRQWdDU0FFTmdKNElBa2dCVFlDZENBSklBVTJBbkFnQWtFQlFiN1lBQ0FKUWZBQWFoQUlRUUFoQnd3QkN5QUxRUUUyQWdBTElBVkJBV29pQlNBSVJ3MEFDMEVBSVFVRFFBSkFBa0FnQXlBRlFRSjBJZ1JxS0FJQVJRUkFJQVFnQ21vdEFBSU5BUXNnQlVFQmFpSUZJQWhIRFFJZ0IwVU5BU0FCS0FJUVFRRkhEUVZCQUNFRkEwQWdBeUFGUVFKMGFpZ0NBQVJBSUFnZ0JVRUJhaUlGUncwQkRBY0xDMEVBSVFjZ0FrRUNRZS9FQUVFQUVBZ2dDRUVRVHdSQUlBaEI4QUZ4SVFkQkFDRUVBMEFnQ2lBRVFRSjBhaUlHUVFFNkFBSWdCaUFFT2dBRElBWkJBVG9BUGlBR1FRRTZBRG9nQmtFQk9nQTJJQVpCQVRvQU1pQUdRUUU2QUM0Z0JrRUJPZ0FxSUFaQkFUb0FKaUFHUVFFNkFDSWdCa0VCT2dBZUlBWkJBVG9BR2lBR1FRRTZBQllnQmtFQk9nQVNJQVpCQVRvQURpQUdRUUU2QUFvZ0JrRUJPZ0FHSUFZZ0JFRUJjam9BQnlBR0lBUkJEM0k2QUQ4Z0JpQUVRUTV5T2dBN0lBWWdCRUVOY2pvQU55QUdJQVJCREhJNkFETWdCaUFFUVF0eU9nQXZJQVlnQkVFS2Nqb0FLeUFHSUFSQkNYSTZBQ2NnQmlBRVFRaHlPZ0FqSUFZZ0JFRUhjam9BSHlBR0lBUkJCbkk2QUJzZ0JpQUVRUVZ5T2dBWElBWWdCRUVFY2pvQUV5QUdJQVJCQTNJNkFBOGdCaUFFUVFKeU9nQUxJQVJCRUdvaUJDQUhSdzBBQ3lBSElBaEdEUVlMQTBBZ0NpQUhRUUowYWlJRUlBYzZBQU1nQkVFQk9nQUNJQWRCQVdvaUJ5QUlSdzBBQ3d3RkN5QUpJQVUyQWpBZ0FrRUJRYVBTQUNBSlFUQnFFQWhCQUNFSElBVkJBV29pQlNBSVJ3MEJDd3NnQXhBSlFRQWhEZ3dGQ3lBSVFRUVFEQ0lERFFFTFFRQWhEaUFDUVFGQm10c0FRUUFRQ0F3REN5QURFQWtMQWtBZ0FDZ0NlQ0lEUlEwQUlBTW9BZ3dpRDBVRVFDQURLQUlFRUFrZ0FDZ0NlQ2dDQ0JBSklBQW9BbmdvQWdBUUNTQUFLQUo0SWdNb0Fnd2lCQVIvSUFRUUNTQUFLQUo0QlNBREN4QUpJQUJCQURZQ2VBd0JDeUFCS0FJWUlRMENRQUpBSUFNdEFCSWlDZ1JBSUFNb0FnQWhGQ0FES0FJRUlRWWdBeWdDQ0NFSVFRQWhCUUpBQTBBZ0RTQVBJQVZCQW5ScUx3RUFRVFJzYWlnQ0xBUkFJQW9nQlVFQmFpSUZSdzBCREFJTEN5QUpJQVUyQWlBZ0FrRUJRZExuQUNBSlFTQnFFQWhCQUNFT0RBWUxJQXBCTkd3UURTSUxSUTBCUVFBaEJRTkFJQThnQlVFQ2RHb2lBeThCQUNFSElBc2dBeTBBQWdSL0lBTXRBQU1GSUFVTFFUUnNhaUlFSUEwZ0IwRTBiR29pQS8wQUFnRDlDd0lBSUFRZ0F5Z0NNRFlDTUNBRUlBUDlBQUlnL1FzQ0lDQUVJQVA5QUFJUS9Rc0NFQ0FMSUFWQk5HeHFJZ1FnQXlnQ0NDQURLQUlNYkVFQ2RCQVdJZ00yQWl3Z0EwVUVRQ0FGUWYvL0EzRWlBQVJBQTBBZ0N5QUFRUUZySWdCQk5HeHFLQUlzRUFrZ0FBMEFDd3NnQ3hBSlFRQWhEaUFDUVFGQm51Y0FRUUFRQ0F3SEN5QUVJQVVnQ0dvdEFBQTJBaGdnQkNBRklBWnFMUUFBTmdJZ0lBVkJBV29pQlNBS1J3MEFDeUFBS0FKNEx3RVFJaEJCQVdzaEVnTkFJQXNnRTBFMGJHb2lBeWdDRENBREtBSUliQ0VHSUEwZ0R5QVRRUUowYWlJRUx3RUFRVFJzYWlnQ0xDRUlBa0FnQkMwQUFrVUVRQ0FHUlEwQklBTW9BaXdoQlVFQUlRZEJBQ0VFQWtBZ0JrRUVTUTBBSUFVZ0NHdEJFRWtOQUNBR1FYeHhJUVJCQUNFREEwQWdCU0FEUVFKMElneHFJQWdnREdyOUFBSUEvUXNDQUNBRFFRUnFJZ01nQkVjTkFBc2dCQ0FHUmcwQ0N5QUVJUU1nQmtFRGNTSU1CRUFEUUNBRklBTkJBblFpRVdvZ0NDQVJhaWdDQURZQ0FDQURRUUZxSVFNZ0IwRUJhaUlISUF4SERRQUxDeUFFSUFaclFYeExEUUVEUUNBRklBTkJBblFpQkdvZ0JDQUlhaWdDQURZQ0FDQUZJQVJCQkdvaUIyb2dCeUFJYWlnQ0FEWUNBQ0FGSUFSQkNHb2lCMm9nQnlBSWFpZ0NBRFlDQUNBRklBUkJER29pQkdvZ0JDQUlhaWdDQURZQ0FDQURRUVJxSWdNZ0JrY05BQXNNQVFzZ0JrVU5BQ0FVSUFRdEFBTWlBMEVDZEdvaEJDQUxJQU5CTkd4cUtBSXNJUVZCQUNFRElBWkJBVWNFUUNBR1FYNXhJUlZCQUNFTUEwQWdCU0FEUVFKMElnZHFJQVFnQnlBSWFpZ0NBQ0lSSUJJZ0VDQVJTaHRCQUNBUlFRQk9HeUFLYkVFQ2RHb29BZ0EyQWdBZ0JTQUhRUVJ5SWdkcUlBUWdCeUFJYWlnQ0FDSUhJQklnQnlBUVNCdEJBQ0FIUVFCT0d5QUtiRUVDZEdvb0FnQTJBZ0FnQTBFQ2FpRURJQXhCQW1vaURDQVZSdzBBQ3dzZ0JrRUJjVVVOQUNBRklBTkJBblFpQTJvZ0JDQURJQWhxS0FJQUlnTWdFaUFESUJCSUcwRUFJQU5CQUU0YklBcHNRUUowYWlnQ0FEWUNBQXNnRTBFQmFpSVRJQXBIRFFBTERBSUxJQXBCTkd3UURTSUxEUUVMUVFBaERpQUNRUUZCbnVjQVFRQVFDQXdEQ3lBQktBSVFJZ01FUUVFQUlRVURRQ0FOSUFWQk5HeHFLQUlzSWdRRVFDQUVFQWtMSUFWQkFXb2lCU0FEUncwQUN3c2dEUkFKSUFFZ0NqWUNFQ0FCSUFzMkFoZ0xJQUFvQW5RaUJVVU5BU0FGS0FJQUlRY2dCUzhCQkNJTEJFQWdCMEVxYWlFU0lBZEJKR29oRXlBSFFSNXFJUkVnQjBFWWFpRVVJQWRCRW1vaEZTQUhRUXhxSVJZZ0IwRUdhaUVYSUF0QkFtc2hHRUVBSVFWQkFTRUVBMEFDUUNBQktBSVFJZ01nQnlBRlFRWnNhaUlOTHdFQUlnWk5CRUFnQ1NBRE5nSVVJQWtnQmpZQ0VDQUNRUUpCekRjZ0NVRVFhaEFJREFFTElBMHZBUVFpQ0VFQmFrSC8vd054UVFGTkJFQWdBU2dDR0NBR1FUUnNhaUFOTHdFQ093RXdEQUVMSUFoQkFXc2lDa0gvL3dOeElnOGdBMDhFUUNBSklBTTJBZ1FnQ1NBUE5nSUFJQUpCQWtHak55QUpFQWdNQVFzQ1FDQUdJQTlHRFFBZ0RTOEJBZzBBSUFrZ0FTZ0NHQ0lJSUFaQk5HeHFJZ01vQWpBMkF1Z0JJQWtnQS8wQUFpRDlDd1BZQVNBSklBUDlBQUlRL1FzRHlBRWdDU0FEL1FBQ0FQMExBN2dCSUFNZ0NDQVBRVFJzSWd4cUlnZ3BBZ2czQWdnZ0F5QUlLUUlRTndJUUlBTWdDQ2tDR0RjQ0dDQURJQWdwQWlBM0FpQWdBeUFJS1FJb053SW9JQU1nQ0NnQ01EWUNNQ0FESUFncEFnQTNBZ0FnQVNnQ0dDQU1haUlESUFuOUFBTzRBZjBMQWdBZ0F5QUovUUFEMkFIOUN3SWdJQU1nQ2YwQUE4Z0IvUXNDRUNBRElBa29BdWdCTmdJd0lBVkJBV29nQzA4TkFDQUVJUWdnR0NBRmEwSC8vd054SWdOQkIwOEVRQ0FFSUFOQkFXb2lHVUg0L3dkeEloQnFJUWdnQ3YwUUlTUWdCdjBRSVNOQkFDRU1BMEFnSXlBa0lCSWdCQ0FNYWtFR2JDSURhaUlhSUFNZ0Uyb2lHeUFESUJGcUlod2dBeUFVYWlJZElBTWdGV29pSGlBRElCWnFJaDhnQXlBWGFpSWdJQU1nQjJvaUEvMElBUUQ5VlFFQUFmMVZBUUFDL1ZVQkFBUDlWUUVBQlAxVkFRQUYvVlVCQUFiOVZRRUFCeUloSUNQOUxpQWhJQ1Q5TFNJbC9VNzlVaUVpSUNFZ0kvMHRJQ1g5VUNJaC9Sa0FRUUZ4QkVBZ0F5QWkvVmtCQUFBTElDSDlHUUZCQVhFRVFDQWdJQ0w5V1FFQUFRc2dJZjBaQWtFQmNRUkFJQjhnSXYxWkFRQUNDeUFoL1JrRFFRRnhCRUFnSGlBaS9Wa0JBQU1MSUNIOUdRUkJBWEVFUUNBZElDTDlXUUVBQkFzZ0lmMFpCVUVCY1FSQUlCd2dJdjFaQVFBRkN5QWgvUmtHUVFGeEJFQWdHeUFpL1ZrQkFBWUxJQ0g5R1FkQkFYRUVRQ0FhSUNMOVdRRUFCd3NnREVFSWFpSU1JQkJIRFFBTElCQWdHVVlOQVFzRFFDQUtJUU1DUUNBR0lBY2dDRUVHYkdvaURDOEJBQ0lRUndSQUlBWWhBeUFQSUJCSERRRUxJQXdnQXpzQkFBc2dDeUFJUVFGcUlnaEIvLzhEY1VjTkFBc0xJQUVvQWhnZ0JrRTBiR29nRFM4QkFqc0JNQXNnQkVFQmFpRUVJQVZCQVdvaUJTQUxSdzBBQ3lBQUtBSjBJZ1VvQWdBaEJ3c2dCd1IvSUFjUUNTQUFLQUowQlNBRkN4QUpJQUJCQURZQ2RBd0JDMEVBSVE0Z0FrRUJRYUxGQUVFQUVBZ0xJQWxCOEFGcUpBQWdEZ3ZwQVFFR2Z5TUFRU0JySWdRa0FBSi9Ba0FnQUNnQ1BDSURCRUJCQVNFRkEwQWdBQ2dDVENnQ0dDQUFLQUpBSUFKQkFuUnFLQUlBSWdaQk5HeHFLQUlzUlFSQUlBUWdCallDRUNBQlFRSkIyamtnQkVFUWFoQUlRUUFoQlNBQUtBSThJUU1MSUFKQkFXb2lBaUFEU1EwQUN3d0JDMEVCSVFWQkFTQUFLQUpNSWdNb0FoQkZEUUVhQTBBZ0F5Z0NHQ0FDUVRSc2FpZ0NMRVVFUUNBRUlBSTJBZ0FnQVVFQ1FkbzVJQVFRQ0VFQUlRVWdBQ2dDVENFREN5QUNRUUZxSWdJZ0F5Z0NFRWtOQUFzTFFRRWdCUTBBR2lBQlFRRkJ2eFZCQUJBSVFRQUxJUWNnQkVFZ2FpUUFJQWNMQkFCQmZ3dUdCd0lXZndKK0lBQW9BaGdpRUNnQ0VFVUVRRUVCRHdzZ0VDZ0NHQ0VOSUFBb0FoUW9BZ0FvQWhRaEN3TkFJQUVnRFNnQ0pDSUNOZ0lrSUFzb0Fod2lCaUFDUVpnQmJHb2hBd0pBQWtBQ2Z5QUFLQUpBSWhFRVFDQUdJQXNvQWhoQm1BRnNhaUlDUVpBQmF5Z0NBQ0FDUVpnQmF5Z0NBR3NoRENBRFFReHFJUVlnQTBFRWFpRUVJQU1vQWdnaEFpQURLQUlBSVFWQkpBd0JDeUFEUVpRQmFpRUdJQU5CakFGcUlRUWdBeWdDa0FFaUFpQURLQUtJQVNJRmF5RU1RVFFMSUF0cUtBSUFJaEpGRFFBZ0JDZ0NBQ0VISUFZb0FnQWhDU0FDSUFWcklRWWdBU2dDQ0NJRFFuOGdBVFVDS0NJWWhrSi9oU0laSUFFMUFoQjhJQmlJcHlJSWFpRUVBbjhnQlNBSVN3UkFJQVVnQ0dzaERrRUFJUWhCQUNBQ0lBUk5EUUVhSUFZZ0JDQUZheUlHYXd3QkN5QUlJQVZySVFnZ0FpQUVUUVJBSUFZZ0NHc2hCa0VBSVE1QkFBd0JDMEVBSVE0Z0F5RUdJQUlnQkdzTElSVWdDU0FIYXlFQ0lBRW9BZ3dpQkNBWklBRTFBaFI4SUJpSXB5SUthaUVGQW44Z0J5QUtTd1JBSUFjZ0Ntc2hEMEVBSVFwQkFDQUZJQWxQRFFFYUlBSWdCU0FIYXlJQ2F3d0JDeUFLSUFkcklRb2dCU0FKVHdSQUlBSWdDbXNoQWtFQUlROUJBQXdCQzBFQUlROGdCQ0VDSUFrZ0JXc0xJUWRCQUNFRklBaEJBRWdOQVNBS1FRQklEUUVnRlVFQVNBMEJJQWRCQUVnTkFTQUdRUUJJRFFFZ0FrRUFTQTBCSUFNZ0Qyd2dEbW9oQnlBS0lBeHNJQWhxSVFrQ1FBSkFBa0FnQVNnQ0xDSUlEUUFnQ1EwQUlBY05BQ0FESUF4SERRQWdBeUFHUncwQUlBSWdCRWNOQVNBQklBdEJKRUUwSUJFYmFpSUNLQUlBTmdJc0lBSkJBRFlDQUF3REN5QUlEUUVMSUFSRkRRSWdCSzBnQTYxK1FpQ0lwdzBDSUFNZ0JHd2lBMEgvLy8vL0Ewc05BaUFCSUFOQkFuUVFGaUlETmdJc0lBTkZEUUlnQmlBQktBSUlJZ1JHSUFFb0Fnd2lCU0FDUm5FTkFDQURRUUFnQkNBRmJFRUNkQkFPR2dzZ0FrVU5BQ0FDUVFGeElSY2dCa0VDZENFR0lBRW9BaXdnQjBFQ2RHb2hCQ0FTSUFsQkFuUnFJUVVnQWtFQlJ3UkFJQUpCL3YvLy93ZHhJUWRCQUNFQ0EwQWdCQ0FGSUFZUUN5RVdJQVVnREVFQ2RDSUphaUlJSUFscUlRVWdGaUFCS0FJSVFRSjBhaUFJSUFZUUN5QUJLQUlJUVFKMGFpRUVJQUpCQW1vaUFpQUhSdzBBQ3dzZ0YwVU5BQ0FFSUFVZ0JoQUxHZ3NnQzBITUFHb2hDeUFOUVRScUlRMGdBVUUwYWlFQlFRRWhCU0FVUVFGcUloUWdFQ2dDRUVrTkFRc0xJQVVMM2hJQ0NYOE1maU1BUWFBQmF5SUZKQUFDUUNBQ1FTTk5CRUJCQUNFQ0lBTkJBVUcyTGtFQUVBZ01BUXNnQWtFa2F5SUNJQUpCQTI0aUNFRURiRWNFUUVFQUlRSWdBMEVCUWJZdVFRQVFDQXdCQ3lBQUtBSklJUVlnQVNBRlFad0JhaUlDUVFJUUNpQUFJQVVvQXB3Qk93RlFJQUZCQW1vZ0JrRUlha0VFRUFvZ0FVRUdhaUFHUVF4cVFRUVFDaUFCUVFwcUlBWkJCQkFLSUFGQkRtb2dCa0VFYWtFRUVBb2dBVUVTYWlBQVFkd0Fha0VFRUFvZ0FVRVdhaUFBUWVBQWFrRUVFQW9nQVVFYWFpQUFRZFFBYWtFRUVBb2dBVUVlYWlBQVFkZ0Fha0VFRUFvZ0FVRWlhaUFDUVFJUUNnSkFBa0FDUUNBRktBS2NBU0lDUVlDQUFVMEVRQ0FHSUFJMkFoQWdBaUFJUndSQUlBVWdDRFlDaEFFZ0JTQUNOZ0tBQVNBRFFRRkJvZkFBSUFWQmdBRnFFQWhCQUNFQ0RBVUxJQVlvQWdRaUFpQUdLQUlNSWdsSklBWW9BZ2dpQ3lBR0tBSUFJZ1JMY1VVRVFDQUZJQW10SUFLdGZUY0RlQ0FGSUF1dElBU3RmVGNEY0NBRFFRRkI2K3dBSUFWQjhBQnFFQWhCQUNFQ0RBVUxJQUFvQWx3aUIwRUFJQUFvQW1BaUNodEZCRUFnQlNBS05nSUVJQVVnQnpZQ0FDQURRUUZCay9FQUlBVVFDRUVBSVFJTUJRc0NRQUpBSUFBb0FsUWlEQ0FFU3cwQVFYOGdCeUFNYWlJSElBY2dERWtiSUFSTkRRQWdBQ2dDV0NJSElBSkxEUUJCZnlBSElBcHFJZ29nQnlBS1N4c2dBa3NOQVF0QkFDRUNJQU5CQVVIV0ZFRUFFQWdNQlFzQ1FDQUFLQUxnQVEwQUlBQW9BdGdCSWdkRkRRQWdBQ2dDM0FFaUNrVU5BQ0FMSUFScklnUWdCMFlnQ1NBQ2F5SUNJQXBHY1EwQUlBVWdBallDYkNBRklBUTJBbWdnQlNBS05nSmtJQVVnQnpZQ1lDQURRUUZCMCtnQUlBVkI0QUJxRUFoQkFDRUNEQVVMSUFZZ0NFRTBFQXdpQkRZQ0dDQUVSUTBCQWtBZ0JpZ0NFRVVOQUNBQlFTUnFJQVZCbUFGcUlnSkJBUkFLSUFRZ0JTZ0NtQUVpQ0VFSGRpSUtOZ0lnSUFRZ0NFSC9BSEZCQVdvaUREWUNHQ0FBS0FMZ0FTRUxJQUZCSldvZ0FrRUJFQW9nQkNBRktBS1lBVFlDQUNBQlFTWnFJQUpCQVJBS0lBUWdCU2dDbUFFaUNEWUNCRUVBSVFJZ0JDZ0NBQ0lIUVlBQ2EwR0Jma2tFUUVFQUlRa01CUXNnQ0VVRVFFRUFJUWtNQlF0QkFDRUpJQWhCL3dGTERRUWdCQ2dDR0NJSVFSOUxEUU1nQkVFQU5nSWtJQVFnQUNnQ29BRTJBaWhCQVNFSklBWW9BaEJCQVUwTkFFRUFJQW9nQ3hzaENrRUFJQXdnQ3hzaEN5QUJRU2RxSVFFRFFDQUJJQVZCbUFGcVFRRVFDaUFFSUFVb0FwZ0JJZ2RCQjNZaUNEWUNWQ0FFSUFkQi93QnhRUUZxSWdjMkFrd0NRQ0FBS0FMZ0FRMEFJQUF0QUx3QlFRUnhEUUFnQnlBTFJpQUlJQXBHY1EwQUlBVWdDRFlDVkNBRklBYzJBbEFnQlNBSk5nSk1JQVVnQ2pZQ1NDQUZJQXMyQWtRZ0JTQUpOZ0pBSUFOQkFrSFg3Z0FnQlVGQWF4QUlDeUFCUVFGcUlBVkJtQUZxSWdoQkFSQUtJQVFnQlNnQ21BRTJBalFnQVVFQ2FpQUlRUUVRQ2lBRUlBVW9BcGdCSWdnMkFqZ2dCQ2dDTkNJSFFZQUNhMEdCZmtrTkJTQUlSUTBGSUFoQmdBSlBEUVVnQkNnQ1RDSUlRU0JQRFFRZ0FVRURhaUVCSUFSQkFEWUNXQ0FFSUFBb0FxQUJOZ0pjSUFSQk5Hb2hCQ0FKUVFGcUlna2dCaWdDRUVrTkFBc0xRUUFoQWlBQUtBSmNJZ2xGRFFRZ0FDZ0NZQ0lMUlEwRUlBQWdDYTBpRFVJQmZTSVBJQVlvQWdnZ0FDZ0NWQ0lIYTYxOElBMkFweUlCTmdKb0lBQWdDNjBpRGtJQmZTSVFJQVlvQWd3Z0FDZ0NXQ0lLYTYxOElBNkFweUlFTmdKc0FrQUNRQ0FCUlEwQUlBUkZEUUJCLy84RElBUnVJQUZQRFFFTElBVWdCRFlDRkNBRklBRTJBaEFnQTBFQlFjWHBBQ0FGUVJCcUVBZ01CUXNnQVNBRWJDRUlBa0FnQUMwQVJFRUNjUVJBSUFBZ0FDZ0NIQ0FIYXlBSmJqWUNIQ0FBSUFBb0FpQWdDbXNnQzI0MkFpQWdBQ0FQSUFBb0FpUWdCMnV0ZkNBTmdENENKQ0FBSUJBZ0FDZ0NLQ0FLYTYxOElBNkFQZ0lvREFFTElBQWdCRFlDS0NBQUlBRTJBaVFnQUVJQU53SWNDeUFBSUFoQmpDd1FEQ0lCTmdLY0FTQUJSUVJBSUFOQkFVSE5IVUVBRUFnTUJRc2dCaWdDRUVHNENCQU1JUUVnQUNnQ0RDQUJOZ0xRS3lBQUtBSU1LQUxRSzBVRVFDQURRUUZCelIxQkFCQUlEQVVMUVFwQkZCQU1JUUVnQUNnQ0RDQUJOZ0x3S3lBQUtBSU1JZ0VvQXZBclJRUkFJQU5CQVVITkhVRUFFQWdNQlFzZ0FVRUtOZ0w0SzBFS1FSUVFEQ0VCSUFBb0Fnd2dBVFlDL0NzZ0FDZ0NEQ0lCS0FMOEswVUVRQ0FEUVFGQnpSMUJBQkFJREFVTElBRkJDallDaEN3Q1FDQUdLQUlRSWdSRkRRQWdCaWdDR0NFSlFRQWhBU0FFUVFGSEJFQWdCRUYrY1NFTEEwQWdDU0FCUVRSc2FpSUhLQUlnUlFSQUlBQW9BZ3dvQXRBcklBRkJ1QWhzYWtFQklBY29BaGhCQVd0ME5nSzBDQXNnQ1NBQlFRRnlJZ2RCTkd4cUlnb29BaUJGQkVBZ0FDZ0NEQ2dDMENzZ0IwRzRDR3hxUVFFZ0NpZ0NHRUVCYTNRMkFyUUlDeUFCUVFKcUlRRWdBa0VDYWlJQ0lBdEhEUUFMQ3lBRVFRRnhSUTBBSUFrZ0FVRTBiR29pQWlnQ0lBMEFJQUFvQWd3b0F0QXJJQUZCdUFoc2FrRUJJQUlvQWhoQkFXdDBOZ0swQ0FzZ0NBUkFJQUFvQXB3QklRRkJBQ0VDQTBBZ0FTQUdLQUlRUWJnSUVBd2lCRFlDMENzZ0JFVUVRRUVBSVFJZ0EwRUJRYzBkUVFBUUNBd0hDeUFCUVl3c2FpRUJJQUpCQVdvaUFpQUlTUTBBQ3dzZ0FFRUVOZ0lJSUFZb0FoQWlBd1JBUVg4Z0FDZ0NXQ0lCSUFBb0FtQWlBaUFBS0FKc1FRRnJiR29pQkNBQ2FpSUNJQUlnQkVrYklnSWdCaWdDRENJRUlBSWdCRWticlNFUVFYOGdBQ2dDVkNJQ0lBQW9BbHdpQkNBQUtBSm9RUUZyYkdvaUFDQUVhaUlFSUFBZ0JFc2JJZ0FnQmlnQ0NDSUVJQUFnQkVrYnJTRVJJQUVnQmlnQ0JDSUFJQUFnQVVrYnJTRVNJQUlnQmlnQ0FDSUFJQUFnQWtrYnJTRVRJQVlvQWhnaEFFRUFJUUVEUUNBQUlBQTFBZ1FpRFVJQmZTSVVJQko4SUEyQUloVStBaFFnQUNBQU5RSUFJZzVDQVgwaUZpQVRmQ0FPZ0NJWFBnSVFJQUJDZnlBQU5RSW9JZytHUW4rRkloZ2dFQ0FVZkNBTmdDQVZmVUwvLy8vL0Q0TjhJQStJUGdJTUlBQWdFU0FXZkNBT2dDQVhmVUwvLy8vL0Q0TWdHSHdnRDRnK0FnZ2dBRUUwYWlFQUlBRkJBV29pQVNBRFJ3MEFDd3RCQVNFQ0RBUUxJQVVnQWpZQ2tBRWdBMEVCUWZZN0lBVkJrQUZxRUFoQkFDRUNEQU1MUVFBaEFpQUdRUUEyQWhBZ0EwRUJRYzBkUVFBUUNBd0NDeUFGSUFnMkFqUWdCU0FKTmdJd0lBTkJBVUhIOHdBZ0JVRXdhaEFJREFFTElBVWdDRFlDS0NBRklBYzJBaVFnQlNBSk5nSWdJQU5CQVVHaDZ3QWdCVUVnYWhBSUN5QUZRYUFCYWlRQUlBSUxuZ01CQjM4akFFRVFheUlHSkFBQ2Z5QUNJQUpCQVVFQ0lBQW9Ba2dvQWhBaUNFR0JBa2tiSWdkQkFYUkJCV29pQkc0aUJTQUViRVlnQWlBRVQzRkZCRUFnQTBFQlFZb2pRUUFRQ0VFQURBRUxBbjhnQUNnQ0NFRVFSZ1JBSUFBb0Fwd0JJQUFvQXN3QlFZd3NiR29NQVFzZ0FDZ0NEQXNoQkVFQUlRQWdCQzBBaUN3aUFrRUVjUVJBSUFRb0FxUURRUUZxSVFBTElBQWdCV29pQlVFZ1R3UkFJQVlnQlRZQ0FDQURRUUZCaXpzZ0JoQUlRUUFNQVFzZ0JDQUNRUVJ5T2dDSUxDQUFJQVZKQkVBZ0JDQUFRWlFCYkdwQnFBTnFJUUlEUUNBQklBSkJBUkFLSUFGQkFXb2lBU0FDUVFScUlBY1FDaUFCSUFkcUlnRWdBa0VJYWtFQ0VBb2dBaUFDS0FJSUlnTWdCQ2dDQ0NJSklBTWdDVWtiTmdJSUlBRkJBbW9nQWtFTWFrRUJFQW9nQVVFRGFpSUJJQUpCRUdvZ0J4QUtJQUVnQjJvaUFTQUdRUXhxUVFFUUNpQUNJQVlvQWd3MkFpUWdBaUFDS0FJUUlnTWdDQ0FESUFoSkd6WUNFQ0FDUVpRQmFpRUNJQUZCQVdvaEFTQUFRUUZxSWdBZ0JVY05BQXNMSUFRZ0JVRUJhellDcEFOQkFRc2hDaUFHUVJCcUpBQWdDZ3ZzQVFFRWZ5TUFRUkJySWdRa0FBSi9Ba0FnQVNBRVFRaHFBbjhnQUNnQ1NDZ0NFRUdBQWswRVFDQUNCRUJCZnlFRlFRRU1BZ3NnQTBFQlFiNGpRUUFRQ0VFQURBTUxJQUpCQVUwTkFVRitJUVZCQWdzaUJoQUtJQVFnQWlBRmFqWUNEQ0FFS0FJSUlnSWdBQ2dDU0NnQ0VDSUZUd1JBSUFRZ0JUWUNCQ0FFSUFJMkFnQWdBMEVCUWNZNklBUVFDRUVBREFJTElBQWdBaUFCSUFacUlBUkJER29nQXhBN1JRUkFJQU5CQVVHK0kwRUFFQWhCQUF3Q0MwRUJJQVFvQWd4RkRRRWFJQU5CQVVHK0kwRUFFQWhCQUF3QkN5QURRUUZCdmlOQkFCQUlRUUFMSVFjZ0JFRVFhaVFBSUFjTDJRRUJCSDhqQUVFUWF5SUVKQUFnQkNBQ05nSU1Ba0FDUUNBQVFRQWdBU0FFUVF4cUlBTVFPMFVOQUNBRUtBSU1EUUFDZnlBQUtBSUlRUkJHQkVBZ0FDZ0NuQUVnQUNnQ3pBRkJqQ3hzYWd3QkN5QUFLQUlNQ3lFSFFRRWhCU0FBS0FKSUtBSVFRUUpKRFFFZ0J5Z0MwQ3NpQWtFY2FpRUdRUUVoQVNBQ0lRTURRQ0FESUFJb0FoZzJBdEFJSUFNZ0FpZ0NwQVkyQXR3T0lBTkIxQWhxSUFaQmlBWVFDeG9nQTBHNENHb2hBeUFCUVFGcUlnRWdBQ2dDU0NnQ0VFa05BQXNNQVFzZ0EwRUJRZFlpUVFBUUNBc2dCRUVRYWlRQUlBVUwxZ0VCQTM4akFFRVFheUlFSkFBQ1FDQUNRUUZCQWlBQUtBSklLQUlRSWdaQmdRSkpHeUlGUVFKcVJ3UkFRUUFoQUNBRFFRRkJpaUJCQUJBSURBRUxBbjhnQUNnQ0NFRVFSZ1JBSUFBb0Fwd0JJQUFvQXN3QlFZd3NiR29NQVFzZ0FDZ0NEQXNoQWlBQklBUkJER29nQlJBS1FRRWhBQ0FCSUFWcUlnVWdCRUVJYWtFQkVBb2dCaUFFS0FJTUlnRk5CRUFnQkNBR05nSUVJQVFnQVRZQ0FDQURRUUZCNk84QUlBUVFDRUVBSVFBTUFRc2dCVUVCYWlBQ0tBTFFLeUFCUWJnSWJHcEJxQVpxUVFFUUNnc2dCRUVRYWlRQUlBQUxoQUlCQlg4akFFRVFheUlFSkFBQ2Z5QUFLQUlJUVJCR0JFQWdBQ2dDbkFFZ0FDZ0N6QUZCakN4c2Fnd0JDeUFBS0FJTUN5RUdBa0FnQWtFQlFRSWdBQ2dDU0NJSEtBSVFRWUVDU1JzaUJVMEVRRUVBSVFJZ0EwRUJRYVFqUVFBUUNBd0JDeUFFSUFWQmYzTWdBbW8yQWd3Z0FTQUVRUWhxSUFVUUNpQUVLQUlJSWdnZ0J5Z0NFRThFUUVFQUlRSWdBMEVCUVpEcEFFRUFFQWdNQVF0QkFTRUNJQUVnQldvaUFTQUdLQUxRS3lBSVFiZ0liR3BCQVJBS0lBQWdCQ2dDQ0NBQlFRRnFJQVJCREdvZ0F4QThSUVJBUVFBaEFpQURRUUZCcENOQkFCQUlEQUVMSUFRb0FneEZEUUJCQUNFQ0lBTkJBVUdrSTBFQUVBZ0xJQVJCRUdva0FDQUNDNndHQVFkL0l3QkJFR3NpQmlRQUlBWWdBallDRENBQUtBSklJUWtDZnlBQUtBSUlRUkJHQkVBZ0FDZ0NuQUVnQUNnQ3pBRkJqQ3hzYWd3QkN5QUFLQUlNQ3lJRUlBUXRBSWdzUVFGeU9nQ0lMQUpBSUFKQkJFMEVRQ0FEUVFGQnZDSkJBQkFJREFFTElBRWdCRUVCRUFvZ0JDZ0NBRUVJVHdSQUlBTkJBVUdhSWtFQUVBZ01BUXNnQVVFQmFpQUdRUWhxUVFFUUNpQUVJQVlvQWdnaUFqWUNCQ0FDUVFWT0JFQWdBMEVCUWZFaFFRQVFDQ0FFUVg4MkFnUUxJQUZCQW1vZ0JFRUlha0VDRUFvZ0JDZ0NDQ0lIUVlDQUJHdEJnSUI4VFFSQUlBWWdCellDQUNBRFFRRkJxVDBnQmhBSURBRUxJQVFnQUNnQ3BBRWlBaUFISUFJYk5nSU1JQUZCQkdvZ0JFRVFha0VCRUFvZ0JDZ0NFRUVDVHdSQUlBTkJBVUdIS2tFQUVBZ01BUXNnQVVFRmFpRUNJQVlnQmlnQ0RFRUZhellDREFKQUlBa29BaEFpQjBVTkFDQUVLQUlBUVFGeElRZ2dCQ2dDMENzaEJFRUFJUWtnQjBFSVR3UkFJQWRCZUhFaEFRTkFJQVFnQlVHNENHeHFJQWcyQWdBZ0JDQUZRUUZ5UWJnSWJHb2dDRFlDQUNBRUlBVkJBbkpCdUFoc2FpQUlOZ0lBSUFRZ0JVRURja0c0Q0d4cUlBZzJBZ0FnQkNBRlFRUnlRYmdJYkdvZ0NEWUNBQ0FFSUFWQkJYSkJ1QWhzYWlBSU5nSUFJQVFnQlVFR2NrRzRDR3hxSUFnMkFnQWdCQ0FGUVFkeVFiZ0liR29nQ0RZQ0FDQUZRUWhxSVFVZ0NrRUlhaUlLSUFGSERRQUxDeUFIUVFkeElnRkZEUUFEUUNBRUlBVkJ1QWhzYWlBSU5nSUFJQVZCQVdvaEJTQUpRUUZxSWdrZ0FVY05BQXNMUVFBaEJTQUFRUUFnQWlBR1FReHFJQU1RUEVVRVFDQURRUUZCdkNKQkFCQUlEQUVMSUFZb0Fnd0VRQ0FEUVFGQnZDSkJBQkFJREFFTEFuOGdBQ2dDQ0VFUVJnUkFJQUFvQXB3QklBQW9Bc3dCUVl3c2JHb01BUXNnQUNnQ0RBc2hBU0FBS0FKSUtBSVFRUUpQQkVBZ0FTZ0MwQ3NpQVNnQ0JFRUNkQ0VISUFGQnNBZHFJUW9nQVVHc0Jtb2hBMEVCSVFrZ0FTRUNBMEFnQWlBQi9RQUNCUDBMQXJ3SUlBSWdBU2dDRkRZQ3pBZ2dBa0hrRG1vZ0F5QUhFQXNhSUFKQjZBOXFJQW9nQnhBTEdpQUNRYmdJYWlFQ0lBbEJBV29pQ1NBQUtBSklLQUlRU1EwQUN3dEJBU0VGQ3lBR1FSQnFKQUFnQlF2c0NRRUdmeU1BUWZBQWF5SUVKQUFnQkVFQU5nSm9Ba0FnQWtFSVJ3UkFJQU5CQVVHOUhrRUFFQWdnQTBFQlFiMGVRUUFRQ0F3QkN5QUJJQUJCekFGcVFRSVFDaUFCUVFKcUlBUkI3QUJxUVFRUUNpQUJRUVpxSUFSQjVBQnFRUUVRQ2lBQlFRZHFJQVJCNkFCcVFRRVFDaUFBS0FMTUFTSUNJQUFvQW1naUNDQUFLQUpzYkU4RVFDQUVJQUkyQW1BZ0EwRUJRWjA3SUFSQjRBQnFFQWdNQVFzZ0FDZ0NuQUVnQWtHTUxHeHFJUVVnQWlBSWJpRUhJQVFvQW1RaEFRSkFJQUFvQWl3aUJrRUFUaUFDSUFaSGNRMEFJQVVvQXRRclFRRnFJZ1lnQVVZTkFDQUVJQVkyQWxnZ0JDQUJOZ0pVSUFRZ0FqWUNVQ0FEUVFGQnRUc2dCRUhRQUdvUUNFRUFJUVVNQVFzZ0JTQUJOZ0xVS3dKQUFrQWdCQ2dDYkNJQlFRRnJRUXhOQkg4Z0FVRU1SdzBCSUFSQkREWUNNQ0FEUVFKQjlkY0FJQVJCTUdvUUNDQUVLQUpzQlNBQkMwVUVRQ0FEUVFSQmpjOEFRUUFRQ0NBQVFRRTJBamdMQWtBQ1FBSkFBa0FnQlNnQzJDc2lBUVJBSUFRb0FtUWlCaUFCU1EwQklBUWdBVFlDSkNBRUlBWTJBaUFnQTBFQlFZVW5JQVJCSUdvUUNDQUFRUUUyQWpoQkFDRUZEQWNMSUFRb0FtZ2lCZzBCREFNTElBUW9BbWdpQmtVTkFRc2dCQ0FHSUFBdEFFUkJCSFpCQVhGcUlnRTJBbWdnQkNnQ1pDSUdJQVVvQXRncklnbEJBV3RMQkVBZ0JDQUpOZ0lFSUFRZ0JqWUNBQ0FEUVFGQm9pWWdCQkFJSUFCQkFUWUNPRUVBSVFVTUJRc2dBU0FHVFFSQUlBUWdBVFlDRkNBRUlBWTJBaEFnQTBFQlFla25JQVJCRUdvUUNDQUFRUUUyQWpoQkFDRUZEQVVMSUFVZ0FUWUMyQ3NMSUFFZ0JDZ0NaRUVCYWtjTkFDQUFJQUF0QUVSQkFYSTZBRVFMSUFRb0Ftd2hBU0FBUVJBMkFnZ2dBRUVBSUFGQkRHc2dBQ2dDT0JzMkFoZ0NRQ0FBS0FJc0lnRkJmMFlFUUVFRUlRVWdBaUFISUFoc2F5SUJJQUFvQWh4SkRRRWdBU0FBS0FJa1R3MEJJQWNnQUNnQ0lFa05BU0FISUFBb0FpaFBRUUowSVFVTUFRc2dBQ2dDekFFZ0FVZEJBblFoQlFzZ0FDQUFMUUJFUWZzQmNTQUZjam9BUkVFQklRVWdBQ2dDeUFFaUFVVU5BaUFCS0FJb0lnWWdBQ2dDekFFaUFrRW9iR29pQnlBQ05nSUFJQWNnQkNnQ1pDSUlOZ0lNSUFRb0FtZ2lBUVJBSUFjZ0FUWUNCQ0FISUFRb0FtZ2lBVFlDQ0NBSEtBSVFJZ0pGQkVBZ0FVRVlFQXdoQVNBQUtBTElBU2dDS0NBQUtBTE1BVUVvYkdvZ0FUWUNFQ0FCRFFSQkFDRUZJQU5CQVVISk5FRUFFQWdNQkFzZ0FpQUJRUmhzRUJBaEFTQUFLQUxJQVNnQ0tDQUFLQUxNQVVFb2JHb2hBaUFCUlFSQUlBSW9BaEFRQ1VFQUlRVWdBQ2dDeUFFb0FpZ2dBQ2dDekFGQktHeHFRUUEyQWhBZ0EwRUJRY2swUVFBUUNBd0VDeUFDSUFFMkFoQU1Bd3NnQnlnQ0VDSUJSUVJBSUFkQkNqWUNDRUVLUVJnUURDRUJJQUFvQXNnQktBSW9JZ1lnQUNnQ3pBRWlBa0VvYkdvaUJ5QUJOZ0lRSUFGRkRRSWdCQ2dDWkNFSUN5QUlJQVlnQWtFb2JHb2lBaWdDQ0VrTkFpQUNJQWhCQVdvaUFqWUNDQ0FCSUFKQkdHd1FFQ0VCSUFBb0FzZ0JLQUlvSUFBb0Fzd0JRU2hzYWlFQ0lBRkZCRUFnQWlnQ0VCQUpRUUFoQlNBQUtBTElBU2dDS0NBQUtBTE1BVUVvYkdvaUFFRUFOZ0lJSUFCQkFEWUNFQ0FEUVFGQnlUUkJBQkFJREFNTElBSWdBVFlDRUF3Q0N5QUVJQUUyQWtBZ0EwRUJRWUxhQUNBRVFVQnJFQWhCQUNFRkRBRUxRUUFoQlNBSFFRQTJBZ2dnQTBFQlFjazBRUUFRQ0FzZ0JFSHdBR29rQUNBRkM2c0hBUWgvSXdCQjBBQnJJZ1FrQUNBRVFRRTJBa3dDUUFKQUlBQW9Bc2dCSWdVb0FpZ2lBdzBBSUFVZ0FDZ0NiQ0FBS0FKb2JDSUROZ0lrSUFOQktCQU1JUU1nQUNnQ3lBRWlCU0FETmdJb0lBTkZCRUJCQUNFRkRBSUxJQVVvQWlSRkRRQURRRUVBSVFVZ0F5QUdRU2hzSWdkcUlnTkJBRFlDRkNBRFFlUUFOZ0ljUWVRQVFSZ1FEQ0VKSUFjZ0FDZ0N5QUVpQ0NnQ0tDSURhaUFKTmdJWUlBbEZEUUlnQmtFQmFpSUdJQWdvQWlSSkRRQUxDeUFBS0FJc0lRa0NRQ0FES0FJUVJRMEFBa0FnQXlBSlFTaHNhaUlES0FJRVJRUkFJQUVnQUNrRE1FSUNmQ0FDRUM4TkFVRUFJUVVnQWtFQlFhY3BRUUFRQ0F3REN5QUJJQU1vQWhBcEF3QkNBbndnQWhBdkRRQkJBQ0VGSUFKQkFVR25LVUVBRUFnTUFnc2dBQ2dDQ0VHQUFrY05BQ0FBUVFnMkFnZ0xBa0FnQUNnQ2JDQUFLQUpvYkNJSFJRMEFJQUFvQXB3QklRVkJBQ0VESUFkQkNFOEVRQ0FIUVhoeElRaEJBQ0VHQTBBZ0JTQURRWXdzYkdwQmZ6WUMxQ3NnQlNBRFFRRnlRWXdzYkdwQmZ6WUMxQ3NnQlNBRFFRSnlRWXdzYkdwQmZ6WUMxQ3NnQlNBRFFRTnlRWXdzYkdwQmZ6WUMxQ3NnQlNBRFFRUnlRWXdzYkdwQmZ6WUMxQ3NnQlNBRFFRVnlRWXdzYkdwQmZ6WUMxQ3NnQlNBRFFRWnlRWXdzYkdwQmZ6WUMxQ3NnQlNBRFFRZHlRWXdzYkdwQmZ6WUMxQ3NnQTBFSWFpRURJQVpCQ0dvaUJpQUlSdzBBQ3dzZ0IwRUhjU0lHUlEwQUEwQWdCU0FEUVl3c2JHcEJmellDMUNzZ0EwRUJhaUVESUFwQkFXb2lDaUFHUncwQUN3dEJBQ0VGSUFBZ0JFSElBR3BCQUNBRVFjUUFhaUFFUVVCcklBUkJQR29nQkVFNGFpQUVRVFJxSUFSQnpBQnFJQUVnQWhBZ1JRMEFJQWxCQVdvaEJ3TkFBa0FnQkNnQ1RFVU5BQ0FBSUFRb0FrZ2lBMEVBUVFBZ0FTQUNFQ1JGRFFJZ0FDZ0NhQ0VJSUFBb0Ftd2hDaUFFSUFOQkFXb2lCallDSUNBRUlBZ2dDbXcyQWlRZ0FrRUVRYkRYQUNBRVFTQnFFQWdnQUNnQzBBRWdBQ2dDVENnQ0dCQnRSUTBDSUFBb0Fwd0JJQU5CakN4c2FpSUZLQUxjS3lJSUJFQWdDQkFKSUFWQ0FEY0MzQ3NMSUFRZ0JqWUNFQ0FDUVFSQjl2d0FJQVJCRUdvUUNDQURJQWxHQkVBZ0FTQUFLQUxJQVNrRENFSUNmQ0FDRUM4TkFVRUFJUVVnQWtFQlFhY3BRUUFRQ0F3REN5QUVJQWMyQWdRZ0JDQUdOZ0lBSUFKQkFrSHQ1UUFnQkJBSVFRQWhCU0FBSUFSQnlBQnFRUUFnQkVIRUFHb2dCRUZBYXlBRVFUeHFJQVJCT0dvZ0JFRTBhaUFFUWN3QWFpQUJJQUlRSUEwQkRBSUxDeUFBSUFJUWF5RUZDeUFFUWRBQWFpUUFJQVVMeUFZQ0IzOEJmaU1BUWRBQWF5SURKQUFnQTBFQk5nSk1Ba0FDUUNBQUtBSm9JZ1JCQVVjTkFDQUFLQUpzUVFGSERRQWdBQ2dDVkEwQUlBQW9BbGdOQUNBQUtBSk1JZ1VvQWdBTkFDQUZLQUlFRFFBZ0JTZ0NDQ0FBS0FKY1J3MEFJQVVvQWd3Z0FDZ0NZRWNOQUVFQUlRUWdBQ0FEUWNnQWFrRUFJQU5CeEFCcUlBTkJRR3NnQTBFOGFpQURRVGhxSUFOQk5Hb2dBMEhNQUdvZ0FTQUNFQ0JGRFFFQ1FDQUFJQU1vQWtoQkFFRUFJQUVnQWhBa0JFQWdBQ2dDVENJQktBSVFEUUZCQVNFRURBTUxJQUpCQVVHU3dRQkJBQkFJREFJTElBRW9BaGdoQVVFQUlRSURRQ0FCSUFKQk5Hd2lCR29vQWl3UUNTQUFLQUpNSWdVb0FoZ2lBU0FFYWlJR0lBQW9BdEFCSWdjb0FoUW9BZ0FvQWhRZ0FrSE1BR3hxSWdnb0FpUTJBaXdnQmlBSEtBSVlLQUlZSUFScUtBSWtOZ0lrSUFoQkFEWUNKRUVCSVFRZ0FrRUJhaUlDSUFVb0FoQkpEUUFMREFFTEEwQUNRQUovQWtBZ0JFRUJSdzBBSUFBb0FteEJBVWNOQUNBQUtBS2NBU2dDM0N0RkRRQWdBMEVBTmdKSUlBQkJBRFlDekFFZ0FDQUFLQUlJUVlBQmNqWUNDRUVBREFFTFFRQWhCQ0FBSUFOQnlBQnFRUUFnQTBIRUFHb2dBMEZBYXlBRFFUeHFJQU5CT0dvZ0EwRTBhaUFEUWN3QWFpQUJJQUlRSUVVTkF5QURLQUpNUlEwQklBTW9Ba2dMSWdkQkFXb2hCQ0FBSUFkQkFFRUFJQUVnQWhBa0lRa2dBQ2dDYUNBQUtBSnNiQ0VGSUFsRkJFQWdBeUFGTmdJRUlBTWdCRFlDQUNBQ1FRRkJsemtnQXhBSVFRQWhCQXdEQ3lBRElBVTJBaVFnQXlBRU5nSWdJQUpCQkVHdzF3QWdBMEVnYWhBSUlBQW9BdEFCSUFBb0Frd29BaGdRYlVVRVFFRUFJUVFNQXdzQ1FBSkFJQUFvQW1oQkFVY05BQ0FBS0FKc1FRRkhEUUFnQUNnQ1RDSUZLQUlBSUFBb0FrZ2lCaWdDQUVjTkFTQUZLQUlFSUFZb0FnUkhEUUVnQlNnQ0NDQUdLQUlJUncwQklBVW9BZ3dnQmlnQ0RFY05BUXNnQUNnQ25BRWdCMEdNTEd4cUlnVW9BdHdySWdaRkRRQWdCaEFKSUFWQ0FEY0MzQ3NMSUFNZ0JEWUNFQ0FDUVFSQjl2d0FJQU5CRUdvUUNDQUJLUU1JSWdwUUJINUNBQVVnQ2lBQktRTTRmUXRRQkVBZ0FDZ0NDRUhBQUVZTkFRc2dDRUVCYWlJSUlBQW9BbWdpQkNBQUtBSnNiRWNOQVFzTElBQWdBaEJySVFRTElBTkIwQUJxSkFBZ0JBdTFCZ0VNZnlBQUtBSklJUWtDUUNBQUtBSm9JQUFvQW14c0lnd0VRQ0FKS0FJUUlnRkJ1QWhzSVEwZ0FTQUJiRUVDZENFS0lBQW9BZ3doQkNBQUtBS2NBU0VEQTBBZ0F5Z0MwQ3NoQ3lBRElBUkJqQ3dRQ3lJQlFRQTJBdWdySUFGQmZ6WUMxQ3NnQVVFQU5nS3dLQ0FCUVFBMkFvUXNJQUZCQURZQzhDc2dBVUlBTndMNEt5QUJJQXMyQXRBcklBRWdBUzBBaUN4Qi9BRnhPZ0NJTENBRUtBTG9Ld1JBSUFFZ0NoQU5JZ00yQXVncklBTkZCRUJCQUE4TElBTWdCQ2dDNkNzZ0NoQUxHZ3NnQVNBRUtBTDRLMEVVYkNJRkVBMGlBellDOEN0QkFDRUlJQU5GRFFJZ0F5QUVLQUx3S3lBRkVBc2FJQVFvQXZRcklnWUVRQ0FFS0FMd0t5RURJQUVvQXZBcklRVkJBQ0VIQTBBZ0F5Z0NEQVJBSUFVZ0F5Z0NFQkFOSWdZMkFnd2dCa1VFUUVFQUR3c2dCaUFES0FJTUlBTW9BaEFRQ3hvZ0JDZ0M5Q3NoQmdzZ0FTQUJLQUw0SzBFQmFqWUMrQ3NnQlVFVWFpRUZJQU5CRkdvaEF5QUhRUUZxSWdjZ0Jra05BQXNMSUFFZ0JDZ0NoQ3hCRkd3aUJSQU5JZ00yQXZ3cklBTkZEUUlnQXlBRUtBTDhLeUFGRUFzYUlBRWdCQ2dDaEN3aUNEWUNoQ3dnQ0FSQUlBUW9BdndySVFNZ0FTZ0MvQ3NoQlVFQUlRY0RRQ0FES0FJSUlnWUVRQ0FGSUFFb0F2QXJJQVlnQkNnQzhDdHJhallDQ0FzZ0F5Z0NEQ0lHQkVBZ0JTQUJLQUx3S3lBR0lBUW9BdkFyYTJvMkFnd0xJQVZCRkdvaEJTQURRUlJxSVFNZ0IwRUJhaUlISUFoSERRQUxDeUFMSUFRb0F0QXJJQTBRQ3hvZ0FVR01MR29oQXlBT1FRRnFJZzRnREVjTkFBc0xRUUVoQ0NBQUFuOUJBRUVCUWNnQUVBd2lBVVVOQUJvZ0FTQUJMUUFvUWY0QmNVRUJjam9BS0NBQlFRRkJCQkFNSWdRMkFoUWdBU0FFRFFBYUlBRVFDVUVBQ3lJQk5nTFFBU0FCUlFSQVFRQVBDeUFBS0FMVUFTRUZRUUFoQkNBQklBQkIwQUJxTmdJY0lBRWdDVFlDR0VFQlFkQUdFQXdoQXlBQktBSVVJQU0yQWdBQ1FDQURSUTBBSUFrb0FoQkJ6QUFRRENFRElBRW9BaFFvQWdBaUJ5QUROZ0lVSUFORkRRQWdCeUFKS0FJUU5nSVFJQUFvQXFRQklRUWdBU0FGTmdJc0lBRWdCRFlDQUVFQklRUUxJQVFOQUNBQUtBTFFBUkJPUVFBaENDQUFRUUEyQXRBQklBSkJBVUhDRzBFQUVBZ0xJQWdMMVJJRERIOEJmUUYrSXdCQk1Hc2lDQ1FBSUFCQkFUWUNDQUovQWtBQ1FDQUJJQWhCS0dvaUJVRUNJQUlRRWtFQ1J3MEFJQVVnQ0VFc2FrRUNFQW9nQ0NnQ0xFSFAvZ05IRFFBZ0FFRUNOZ0lJSUFBb0FzZ0JJQUVwQXpoQ0FuMGlFRGNEQUNBSUlCQTNBeEFnQWtFRVFmN2VBQ0FJUVJCcUVBZ2dBQ2dDeUFFaUF5a0RBQ0VRSUFNb0FoZ2lCMEVCYWlJRklBTW9BaUFpQkUwRVFDQURLQUljSVFRTUFnc2dBd0ovSUFTelF3QUF5RUtTSWc5REFBQ0FUMTBnRDBNQUFBQUFZSEVFUUNBUHFRd0JDMEVBQ3lJRk5nSWdJQU1vQWh3Z0JVRVliQkFRSWdRRVFDQURJQVEyQWh3Z0F5Z0NHQ0lIUVFGcUlRVU1BZ3NnQXlnQ0hCQUpJQU5CQURZQ0lDQURRZ0EzQXhnZ0FrRUJRYWtkUVFBUUNBc2dBa0VCUWNYMUFFRUFFQWhCQUF3QkN5QUVJQWRCR0d4cUlnUkJBallDRUNBRUlCREVOd01JSUFSQnovNERPd0VBSUFNZ0JUWUNHQ0FCSUFBb0FoQkJBaUFDRUJKQkFrY0VRQ0FDUVFGQmxoSkJBQkFJUVFBTUFRc2dBQ2dDRUNBSVFTaHFRUUlRQ2dKQUFrQWdDQ2dDS0NJRVFaRC9BMGNFUUFOQVFmQzlBU0VISUFSQi8vMERUUVJBSUFnZ0JEWUNBQ0FDUVFGQnloQWdDQkFJUVFBTUJRc0RRQ0FISWdVb0FnQWlBd1JBSUFWQkRHb2hCeUFESUFSSERRRUxDd0pBQWtBZ0F3MEFRUUloQmlBQ1FRSkI5UnhCQUJBSVFaWVNJUWNDUUFKQUlBRWdBQ2dDRUVFQ0lBSVFFa0VDUncwQUEwQWdBQ2dDRUNBSVFTeHFRUUlRQ2tId3ZRRWhBeUFJS0FJc0lnUkJnUDREVHdSQUEwQWdBeUlGS0FJQUlnd0VRQ0FEUVF4cUlRTWdCQ0FNUncwQkN3c2dCU2dDQkNBQUtBSUljVVVFUUVIOEtDRUhEQU1MSUF3RVFDQU1RWkQvQTBZRVFDQUlRWkQvQXpZQ0tBd0hDeUFCS1FNNElSQWdBQ2dDeUFFaUF5Z0NHQ0lGUVFGcUlnUWdBeWdDSUNJSFRRUkFJQU1vQWh3aEJ3d0ZDeUFEQW44Z0I3TkRBQURJUXBJaUQwTUFBSUJQWFNBUFF3QUFBQUJnY1FSQUlBK3BEQUVMUVFBTElnVTJBaUFnQXlnQ0hDQUZRUmhzRUJBaUJ3UkFJQU1nQnpZQ0hDQURLQUlZSWdWQkFXb2hCQXdGQ3lBREtBSWNFQWtnQTBFQU5nSWdJQU5DQURjREdFR3BIU0VIREFNTElBWkJBbW9oQmdzZ0FTQUFLQUlRUVFJZ0FoQVNRUUpHRFFBTEN5QUNRUUVnQjBFQUVBZ2dBa0VCUWY3SEFFRUFFQWhCQUF3SEN5QUhJQVZCR0d4cUlnVWdCallDRUNBRklCQ25JQVpyckRjRENDQUZRUUE3QVFBZ0F5QUVOZ0lZSUFnZ0REWUNLRUh3dlFFaEJBTkFJQVFpQlNnQ0FDSURSUTBCSUFSQkRHb2hCQ0FESUF4SERRQUxDeUFGS0FJRUlBQW9BZ2h4UlFSQUlBSkJBVUg4S0VFQUVBaEJBQXdHQ3lBQklBQW9BaEJCQWlBQ0VCSkJBa2NFUUNBQ1FRRkJsaEpCQUJBSVFRQU1CZ3NnQUNnQ0VDQUlRU1JxUVFJUUNpQUlLQUlrSWdSQkFVMEVRQ0FDUVFGQm9TNUJBQkFJUVFBTUJnc2dDQ0FFUVFKcklnYzJBaVFnQUNnQ0VDRUVJQUFvQWhRZ0Iwa0VRQ0FFSUFjUUVDSUVSUVJBSUFBb0FoQVFDU0FBUWdBM0F4QWdBa0VCUWRRbFFRQVFDRUVBREFjTElBQWdCRFlDRUNBQUlBZ29BaVFpQnpZQ0ZBc2dBU0FFSUFjZ0FoQVNJZ1FnQ0NnQ0pFY0VRQ0FDUVFGQmxoSkJBQkFJUVFBTUJnc2dBQ0FBS0FJUUlBUWdBaUFGS0FJSUVRRUFSUVJBSUFKQkFVR29Fa0VBRUFoQkFBd0dDeUFCS1FNNElSQWdDQ2dDSkNFTUFrQWdBQ2dDeUFFaUJTZ0NHQ0lHUVFGcUlnY2dCU2dDSUNJRVRRUkFJQVVvQWh3aEJBd0JDeUFGQW44Z0JMTkRBQURJUXBJaUQwTUFBSUJQWFNBUFF3QUFBQUJnY1FSQUlBK3BEQUVMUVFBTElnUTJBaUFnQlNnQ0hDQUVRUmhzRUJBaUJFVU5CU0FGSUFRMkFod2dCU2dDR0NJR1FRRnFJUWNMSUFRZ0JrRVliR29pQkNBTVFRUnFOZ0lRSUFRZ0VLY2dER3RCQkd1c053TUlJQVFnQXpzQkFDQUZJQWMyQWhnZ0FTQUFLQUlRUVFJZ0FoQVNRUUpIQkVBZ0FrRUJRWllTUVFBUUNFRUFEQVlMUVFFZ0NpQURRZHorQTBZYklRcEJBU0FMSUFOQjB2NERSaHNoQzBFQklBMGdBMEhSL2dOR0d5RU5JQUFvQWhBZ0NFRW9ha0VDRUFvZ0NDZ0NLQ0lFUVpEL0EwY05BUXNMSUEwTkFRc2dBa0VCUVpna1FRQVFDRUVBREFJTElBdEZCRUFnQWtFQlFjWWtRUUFRQ0VFQURBSUxJQXBGQkVBZ0FrRUJRZlFrUVFBUUNFRUFEQUlMUVFBaEEwRUFJUTBqQUVFUWF5SUVKQUJCQVNFSEFrQWdBQzBBdkFGQkFYRkZEUUFDUUNBQUtBSndJZ3RGRFFBQ1FBTkFJQUFvQW5RZ0RVRURkR29pQlNnQ0FDSUtCRUFnQXlBRktBSUVJZ1pySWdWQkFDQURJQVZQR3lFRklBTWdCa2tFUUNBR0lBTnJJUXNnQXlBS2FpRUtBMEFnQzBFRVNRUkFRWTRySVFNTUJRc2dDaUFFUVF4cVFRUVFDaUFFS0FJTUlnTkJmM01nQ1VrRVFFSDBLaUVEREFVTElBTWdDMEVFYXlJR2F5QUZJQU1nQmtzaURCc2hCU0FESUFscUlRa2dCaUFEYXlFTElBcEJBQ0FESUF3YmFrRUVhaUVLSUFNZ0Jra05BQXNnQUNnQ2NDRUxDeUFGSVFNTElBMUJBV29pRFNBTFNRMEFDeUFEUlEwQlFRQWhCeUFDUVFGQjZSWkJBQkFJREFJTFFRQWhCeUFDUVFFZ0EwRUFFQWdNQVFzZ0FDQUpFQTBpQXpZQ2lBRWdBMFVFUUVFQUlRY2dBa0VCUWI0Z1FRQVFDQXdCQ3lBQUlBazJBbndnQUNnQ2RDRUdBa0FnQUNnQ2NDSUtCRUJCQUNFSlFRQWhBMEVBSVFVRFFDQUdJQVZCQTNRaURXb2lEQ2dDQUNJTEJFQWdBQ2dDaUFFZ0Eyb2hDZ0ovSUF3b0FnUWlCaUFKVFFSQUlBb2dDeUFHRUFzYUlBTWdCbW9oQXlBSklBWnJEQUVMSUFvZ0N5QUpFQXNhSUFNZ0NXb2hBeUFHSUFscklnWUVRQ0FKSUF0cUlRa0RRQ0FHUVFSSkRRWWdDU0FFUVFocVFRUVFDaUFKUVFScUlRa2dBQ2dDaUFFZ0Eyb2hDaUFHUVFScklnWWdCQ2dDQ0NJTFNRUkFJQW9nQ1NBR0VBc2FJQU1nQm1vaEF5QUVLQUlJSUFackRBTUxJQW9nQ1NBTEVBc2FJQVFvQWdnaUNpQURhaUVESUFrZ0Ntb2hDU0FHSUFwcklnWU5BQXNMUVFBTElRa2dBQ2dDZENBTmFpZ0NBQkFKSUFBb0FuUWlCaUFOYWtJQU53SUFJQUFvQW5BaENnc2dCVUVCYWlJRklBcEpEUUFMSUFBb0Fud2hDU0FBS0FLSUFTRURDeUFBSUFrMkFwQUJJQUFnQXpZQ2VDQUFRUUEyQW5BZ0JoQUpJQUJCQURZQ2RBd0JDMEVBSVFjZ0FrRUJRWTRyUVFBUUNBc2dCRUVRYWlRQUlBZEZCRUFnQWtFQlFZODlRUUFRQ0VFQURBSUxJQUpCQkVHSDF3QkJBQkFJSUFBb0FzZ0JJQUVwQXpoQy92Ly8vdzk4UXYvLy8vOFBnemNEQ0NBQVFRZzJBZ2hCQVF3QkN5QUZLQUljRUFrZ0JVRUFOZ0lnSUFWQ0FEY0RHQ0FDUVFGQnFSMUJBQkFJUVFBTElRNGdDRUV3YWlRQUlBNExIQUFnQUNnQ0NFVWdBQ2dDd0FGQkFFY2dBQ2dDeEFGQkFFZHhjUXNFQUVFQUN3OEFJQUFFUUNBQUlBRTJBcmdCQ3d1UEFRRUVmeUFBS0FJWUlnRUVRQ0FBS0FJY0lnTkJORzRoQkNBRFFUUlBCSDlCQUNFREEwQWdBU2dDQUNJQ0JFQWdBa0VCYXhBSklBRkJBRFlDQUFzZ0FTZ0NCQ0lDQkVBZ0FoQUpJQUZCQURZQ0JBc2dBU2dDQ0NJQ0JFQWdBaEFKSUFGQkFEWUNDQXNnQVVFMGFpRUJJQU5CQVdvaUF5QUVSdzBBQ3lBQUtBSVlCU0FCQ3hBSklBQkJBRFlDR0FzTGhnRUJCSDhnQUNnQ0dDSUJCRUFnQUNnQ0hDSUNRY0FBVHdSL0lBSkJCblloQkVFQUlRSURRQ0FCS0FJQUlnTUVRQ0FERUFrZ0FVRUFOZ0lBQ3lBQktBSUVJZ01FUUNBREVBa2dBVUVBTmdJRUN5QUJLQUk4RUFrZ0FVRUFOZ0k4SUFGQlFHc2hBU0FDUVFGcUlnSWdCRWNOQUFzZ0FDZ0NHQVVnQVFzUUNTQUFRUUEyQWhnTEN6OEJBWDhnQUFSQUlBQW9BblFpQVFSQUlBRVFDU0FBUVFBMkFuUUxJQUFvQW5naUFRUkFJQUVRQ1NBQVFRQTJBbmdMSUFBb0FwUUJFQWtnQUJBSkN3dkJwZ1VFWEg4Q2V3WitBWDBqQUVIZ0FHc2lJeVFBSUFBb0FnZ2hHZ0pBQWtBQ1FBSkFJQUFvQWdCRkJFQWdHaUFhS0FJUUlCb29BZ2hySUJvb0FoUWdHaWdDREd0c1FRSjBJZ1lRRmlJRE5nSThJQU5GQkVBZ0FDZ0NKQm9nQUNnQ0lFRUJRZEU4UVFBUUNDQUFLQUlrR2lBQVFSeHFJUkFNQXdzZ0EwRUFJQVlRRGhvTUFRc2dHaWdDUENJRFJRMEFJQU1RQ1NBYVFRQTJBandMSUFBb0FoQWlNaWdDSENBeUtBSVlRWmdCYkdvaUEwR1lBV3NvQWdBaE5TQURRWkFCYXlnQ0FDRTJJQUFvQWhRaEx5QUFLQUlNSVRBZ0FDZ0NCQ0UzSUFBb0Fod29BZ0JGRFFJZ0FFRWNhaUVRQWtBQ2YwRUFJQUVvQWdRaUEwRUFUQTBBR2lBQktBSUFJUVlDUUFOQUlBWWdCMEVNYkdvaUJDZ0NBRVVOQVNBSFFRRnFJZ2NnQTBjTkFBdEJBQXdCQ3lBRUtBSUVDeUlFRFFCQkFVR2NBUkFNSWdSRkJFQWdBQ2dDSUVFQlFaQXdRUUFRQ0F3Q0N5QUVRUUEyQW93QklBRW9BZ1FpQTBILy8vLy9CMGNFZndKL0lBRW9BZ0FoQmlBRFFRQktCRUFEUUNBR0lBbEJER3hxSWdjb0FnQkZCRUFnQnlnQ0NDSURCSDhnQnlnQ0JDQURFUUlBSUFFb0FnQUZJQVlMSUFsQkRHeHFJZ0ZCRHpZQ0NDQUJJQVEyQWdSQkFRd0RDeUFKUVFGcUlna2dBMGNOQUFzTFFRQWdCaUFEUVF4c1FReHFFQkFpQTBVTkFCb2dBU0FETmdJQUlBTWdBU2dDQkNJR1FReHNhaUlEUVE4MkFnZ2dBeUFFTmdJRUlBTkJBRFlDQUNBQklBWkJBV28yQWdSQkFRc0ZRUUFMRFFBZ0FDZ0NJRUVCUVkwK1FRQVFDQ0FFS0FKMElnRUVRQ0FCRUFrZ0JFRUFOZ0owQ3lBRUtBSjRJZ0VFUUNBQkVBa2dCRUVBTmdKNEN5QUVLQUtVQVJBSklBUVFDUXdCQ3lBRUlBQW9BaGcyQXBBQklBQW9BaWdoS3lBQUtBSWtJU0VnQUNnQ0lDRWRJQzhvQXFnR0lSRWdNQ2dDRUNFQkFrQUNRQ0F2S0FJUUloWkJ3QUJ4QkVBZ0ZpRUtJd0JCc0FKcklnOGtBQUpBSUJFRVFDQWhCRUJCQUNFSElCMUJBVUdCR0VFQUVBZ01BZ3RCQUNFSElCMUJBVUdCR0VFQUVBZ01BUXNnQkNnQ2RDRUhBa0FDUUNBYUtBSVVJQm9vQWd4cklnTWdHaWdDRUNBYUtBSUlheUlHYkNJQklBUW9Bb1FCU3dSQUlBY1FDU0FFSUFGQkFuUWlFUkFXSWdjMkFuUWdCMFVFUUVFQUlRY01CQXNnQkNBQk5nS0VBUXdCQ3lBSFJRMEJJQUZCQW5RaEVRc2dCMEVBSUJFUURob0xJQVFvQW5naEJ3SkFJQVFvQW9nQlFjOFVTdzBBSUFjUUNTQUVRY0RTQUJBV0lnYzJBbmdnQncwQVFRQWhCd3dCQ3lBRVFkQVVOZ0tJQVNBSFFRQkJ3TklBRUE0YUlBUWdBellDZ0FFZ0JDQUdOZ0o4SUJvb0FoZ2lBa1VFUUVFQklRY01BUXNnR2lnQ0hDRU5RUUVoQndKQUFrQUNRQUpBQWtBZ0dpZ0NOQ0lEQkVBZ0dpZ0NCQ0VKUVFBaEIwRUFJUUVDUUNBRFFRUlBCRUFnQTBGOGNTRUJBMEFnQ1NBSVFRTjBhaUlHUVJ4cUlBWkJGR29nQmtFTWFpQUcvUWtDQlAxV0FnQUIvVllDQUFMOVZnSUFBeUJlL2E0QklWNGdDRUVFYWlJSUlBRkhEUUFMSUY0Z1hpQmUvUTBJQ1FvTERBME9Ed0FCQWdNQUFRSUQvYTRCSWw0Z1hpQmUvUTBFQlFZSEFBRUNBd0FCQWdNQUFRSUQvYTRCL1JzQUlRY2dBU0FEUmcwQkN3TkFJQWtnQVVFRGRHb29BZ1FnQjJvaEJ5QUJRUUZxSWdFZ0EwY05BQXNMSUFOQkFVWUVRQ0FFS0FLUUFVVU5CUXNnQnlBRUtBS1lBVTBOQVNBRUtBS1VBU0FIRUJBaUVRMENRUUFoQnd3R0N5QUVLQUtRQVVVTkJRc2dCQ2dDbEFFaUVRMEJRUUFoQnd3RUN5QUVJQWMyQXBnQklBUWdFVFlDbEFFTElCb29BalJGQkVCQkFDRUhEQUlMSUJvb0FnUWhDRUVBSVFkQkFDRUJBMEFnQnlBUmFpQUlJQUZCQTNRaUEyb2lCaWdDQUNBR0tBSUVFQXNhSUJvb0FnUWlDQ0FEYWlnQ0JDQUhhaUVISUFGQkFXb2lBU0FhS0FJMFNRMEFDd3dCQ3lBYUtBSUVLQUlBSVJFTFFRQWhBVUVBSVFnQ2YwRUFJQm9vQWlnaUEwVU5BQm9nR2lnQ0FDSUdLQUlJSVFoQkFDQURRUUZHRFFBYUlBWW9BaUFMSVFNZ0FpQU5heUZGQWtBZ0F5QUlhaUlJUlFSQVFRQWhDUXdCQzBFQklRRWdHaWdDQUNJREtBSUFJUVZCQUNFSklBaEJBVVlFUUVFQUlRRU1BUXNnQXlnQ0dDRUpDeUJGUVFGcUlSWWdCQ2dDZENFT0lBUW9BbmdoRkNBYUtBSU1JUklnR2lnQ0ZDRVlJQm9vQWdnaEpDQWFLQUlRSVNzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FVVU5BQ0FKRFFBZ0lVVU5BU0FkUVFKQi9NOEFRUUFRQ0VFQklRZ01BZ3NnQ0VFRVNRMEJJQ0VFUUNBUElBZzJBbkFnSFVFQlFmM0ZBQ0FQUWZBQWFoQUlEQWdMSUE4Z0NEWUNZQ0FkUVFGQi9jVUFJQTlCNEFCcUVBaEJBQ0VIREFnTElCMUJBa0g4endCQkFCQUlJQm9vQWhnaUFVRWVTdzBCUVFFaERDQUJJQlpQRFFNTUJRc2dHaWdDR0NJQlFSNU5EUUVnSVVVTkFDQVBJQUUyQWlBZ0hVRUJRYXZiQUNBUFFTQnFFQWdNQlFzZ0R5QUJOZ0lBSUIxQkFVR3Iyd0FnRHhBSVFRQWhCd3dGQ3lBQklCWkpEUUVnQ0VFQ1NRUkFJQWdoREF3QkN5QUJJQlpIQkVBZ0NDRU1EQUVMUVFFaERFR1F4Z0V0QUFBTkFDQWhSUVJBUVpER0FVRUJPZ0FBSUE4Z0NEWUNRQ0FkUVFKQmdjd0FJQTlCUUdzUUNBd0JDMEdReGdFdEFBQkZCRUJCa01ZQlFRRTZBQUFnRHlBSU5nSlFJQjFCQWtHQnpBQWdEMEhRQUdvUUNBc0xBa0FDUUNBRlFRSkpEUUFnQlNBSFN3MEFJQVVnQ1dvZ0IwME5BUXNnSVFSQVFRQWhCeUFkUVFGQnc4VUFRUUFRQ0F3RkMwRUFJUWNnSFVFQlFjUEZBRUVBRUFnTUJBc0NRQUpBSUFVZ0VXb2lFMEVCYXkwQUFFRUVkQ0FUUVFKckxRQUFRUTl4Y2lJR1FRSkpEUUFnQlNBR1NBMEFJQVpCOEI5SkRRRUxJQ0VFUUVFQUlRY2dIVUVCUWVieUFFRUFFQWdNQlF0QkFDRUhJQjFCQVVIbThnQkJBQkFJREFRTElCb29BaHdoSmlBUFFRQTJBcEFDSUE5QkFEWUNtQUlnRDBJQU53T0lBaUFQUWdBM0E2Z0NJQTlDQURjQ25BSWdEeUFHUVFGcklnYzJBcFFDSUE4Z0JTQVJhaUFHYXlJQk5nS0FBa0wvQVNGZ0lBWkJBazhFUUNBQk1RQUFJV0FMUVFnaEF5QVBRUWcyQXBBQ0lBOGdCa0VDYXlJSU5nS1VBaUFQSUdCQ0Q0UWdZQ0FIUVFGR0d5SmdOd09JQWlBUElBRWdCa0VCU21vaUJ6WUNnQUlnRHlCZ1F2OEJVU0lOTmdLWUFnSi9Ba0FnQVVFRGNTSUNRUU5HRFFCQy93RWhZU0FOQkVCQkFDQUhMUUFBUVk4QlN3MENHZ3NnQmtFRFRnUkFJQWN4QUFBaFlRc2dEeUFHUVFOcklnMDJBcFFDSUE5QkQwRVFJR0JDL3dGUklnc2JJZ00yQXBBQ0lBOGdCeUFHUVFKS2FpSUJOZ0tBQWlBUElHRkNENFFnWVNBSVFRRkdHeUpoUXY4QlVUWUNtQUlnRHlCZ1FnZENDQ0FMRzRZZ1lZUWlZRGNEaUFJZ0FrRUNSZzBBSUdGQy93RlJCRUJCQUNBQkxRQUFRWThCU3cwQ0dndEMvd0VoWWlBR1FRUk9CRUFnQVRFQUFDRmlDeUFQSUFaQkJHc2lCellDbEFJZ0R5QUJJQVpCQTBwcUlnRTJBb0FDSUE4Z1lrSVBoQ0JpSUExQkFVWWJJbUpDL3dGUk5nS1lBaUFQSUFOQkIwRUlJR0ZDL3dGUklnZ2JhaUlETmdLUUFpQVBJR0JDQjBJSUlBZ2JoaUJpaENKZ053T0lBaUFDUVFGR0RRQkMvd0VoWVNCaVF2OEJVUVJBUVFBZ0FTMEFBRUdQQVVzTkFob0xJQVpCQlU0RVFDQUJNUUFBSVdFTElBOGdCa0VGYXpZQ2xBSWdEeUFCSUFaQkJFcHFOZ0tBQWlBUElHRkNENFFnWVNBSFFRRkdHeUpoUXY4QlVUWUNtQUlnRHlBRFFRZEJDQ0JpUXY4QlVTSUJHMm9pQXpZQ2tBSWdEeUJnUWdkQ0NDQUJHNFlnWVlRaVlEY0RpQUlMSUE4Z1lFSEFBQ0FEYTYyR053T0lBa0VCQzBVRVFDQWhCRUJCQUNFSElCMUJBVUhlMUFCQkFCQUlEQVVMUVFBaEJ5QWRRUUZCM3RRQVFRQVFDQXdFQ3lBcklDUnJJUlVnRHlBR1FRSnJJZ3MyQXZRQklBOGdCU0FSYWlJQ1FRTnJJZ00yQXVBQklBOGdBa0VDYXkwQUFDSVpRWThCU3lJTk5nTDRBU0FQSUJsQkJIYXRJbUEzQStnQklBOUJBMEVFSUdCQ0I0TkNCMUViSWdFMkF2QUJJQU5CQTNGQkFXb2lCeUFMSUFjZ0MwZ2JJUWdDUUFKQUlBWkJBa3dFUUNBUElBc2dDR3NpQWpZQzlBRU1BUXNnRHlBQ1FRUnJJZ2MyQXVBQklBOGdBeTBBQUNJWFFZOEJTeUlOTmdMNEFTQVBJQmV0SW1FZ0FhMkdJR0NFSW1BM0ErZ0JJQTlCQ0VFSFFRZ2dZVUwvQUlOQy93QlJHeUFaUVk4QlRSc2dBV29pQVRZQzhBRUNRQ0FJUVFGR0JFQWdCeUVEREFFTElBOGdBa0VGYXlJRE5nTGdBU0FQSUFjdEFBQWlHVUdQQVVzaURUWUMrQUVnRHlBWnJTSmhJQUd0aGlCZ2hDSmdOd1BvQVNBUFFRaEJCMEVJSUdGQy93Q0RRdjhBVVJzZ0YwR1BBVTBiSUFGcUlnRTJBdkFCSUFoQkFrWU5BQ0FQSUFKQkJtc2lCellDNEFFZ0R5QURMUUFBSWhkQmp3RkxJZzAyQXZnQklBOGdGNjBpWVNBQnJZWWdZSVFpWURjRDZBRWdEMEVJUVFkQkNDQmhRdjhBZzBML0FGRWJJQmxCandGTkd5QUJhaUlCTmdMd0FTQUlRUU5HQkVBZ0J5RUREQUVMSUE4Z0FrRUhheUlETmdMZ0FTQVBJQWN4QUFBaVlVS1BBVllpRFRZQytBRWdEeUJoSUFHdGhpQmdoQ0pnTndQb0FTQVBRUWhCQjBFSUlHRkMvd0NEUXY4QVVSc2dGMEdQQVUwYklBRnFJZ0UyQXZBQkN5QVBJQXNnQ0dzaUFqWUM5QUVnQVVFZ1N3MEJDd0pBSUFKQkJFNEVRQ0FEUVFOcktBSUFJUWNnRHlBQ1FRUnJOZ0wwQVNBUElBTkJCR3MyQXVBQkRBRUxJQUpCQUV3RVFFRUFJUWNNQVFzZ0FrRUJjU0ZIQWtBZ0FrRUJSZ1JBUVJnaENFRUFJUWNNQVFzZ0FrSCsvLy8vQjNFaEYwRVlJUWhCQUNFSFFRQWhDd05BSUE4Z0EwRUJheUlmTmdMZ0FTQURMUUFBSVVZZ0R5QURRUUpySWdNMkF1QUJJQThnQWtFQmF6WUM5QUVnSHkwQUFDRWZJQThnQWtFQ2F5SUNOZ0wwQVNCR0lBaDBJQWR5SUI4Z0NFRUlhM1J5SVFjZ0NFRVFheUVJSUF0QkFtb2lDeUFYUncwQUN3c2dSMFVOQUNBUElBTkJBV3MyQXVBQklBTXRBQUFoU0NBUElBSkJBV3MyQXZRQklFZ2dDSFFnQjNJaEJ3c2dEeUFIUWY4QmNTSURRWThCU3pZQytBRWdEMEVIUVFnZ0IwR0FnSUQ0QjNGQmdJQ0ErQWRHRzBFSUlBMGJJZ0pCQ0VFSFFRZ2dCMEdBZ1B3RGNVR0FnUHdEUmhzZ0IwSC8vLy8vZUUwYmFpSUlRUWhCQjBFSUlBZEJnUDRCY1VHQS9nRkdHeUFIUVJCMlFmOEJjU0lOUVk4QlRSdHFJZ3RCQ0VFSFFRZ2dCMEgvQUhGQi93QkdHeUFIUVFoMlFmOEJjU0laUVk4QlRSc2dBV3BxTmdMd0FTQVBJQTBnQW5RZ0IwRVlkbklnR1NBSWRISWdBeUFMZEhLdElBR3RoaUJnaERjRDZBRUxJQTlCd0FGcUlCRWdCU0FHYTBIL0FSQlVBbjlCQUNBTVFRSkpEUUFhSUE5Qm9BRnFJQk1nQ1VFQUVGUkJBQ0FNUVFKR0RRQWFRZ0FoWUVJQUlXSWdEMEVCTmdLWUFTQVBRUUEyQXBBQklBOUNBRGNEaUFFZ0R5QUpRUUZySWdZMkFwUUJJQThnQlNBUmFpQUphaUlEUVFGcklnRTJBb0FCSUFGQkEzRWhCUUpBSUFsQkFFd0VRQ0FCSVFNTUFRc2dEeUFEUVFKcklnTTJBb0FCSUFFeEFBQWhZQXNnRHlCZ053T0lBU0FQSUdCQ2p3RldJaEUyQXBnQklBOUJCMEVJSUdCQy93Q0RRdjhBVVJzaURUWUNrQUVDUUNBRlJRMEFJQThnQ1VFQ2F5SUNOZ0tVQVFKQUlBbEJBa2dFUUNBRElRY01BUXNnRHlBRFFRRnJJZ2MyQW9BQklBTXhBQUFoWWdzZ0R5QmlRbzhCVmlJUk5nS1lBU0FQSUdJZ0RhMkdJR0NFSW1FM0E0Z0JJQTlCQ0VFSFFRZ2dZa0wvQUlOQy93QlJHeUJnUW84QldCc2dEV29pRFRZQ2tBRWdCVUVCUmdSQUlBY2hBeUJoSVdBZ0JpRUpJQUloQmd3QkN5QVBJQWxCQTJzaUNEWUNsQUVDUUNBSlFRTklCRUFnQnlFQkRBRUxJQThnQjBFQmF5SUJOZ0tBQVNBSE1RQUFJV01MSUE4Z1kwS1BBVllpRVRZQ21BRWdEeUJqSUEydGhpQmhoQ0pnTndPSUFTQVBRUWhCQjBFSUlHTkMvd0NEUXY4QVVSc2dZa0tQQVZnYklBMXFJZzAyQXBBQklBVkJBa1lFUUNBQklRTWdBaUVKSUFnaEJnd0JDeUFQSUFsQkJHc2lCallDbEFGQ0FDRmlBa0FnQ1VFRVNBUkFJQUVoQXd3QkN5QVBJQUZCQVdzaUF6WUNnQUVnQVRFQUFDRmlDeUFQSUdKQ2p3RldJaEUyQXBnQklBOGdZaUFOcllZZ1lJUWlZRGNEaUFFZ0QwRUlRUWRCQ0NCaVF2OEFnMEwvQUZFYklHTkNqd0ZZR3lBTmFpSU5OZ0tRQVNBSUlRa0xJQTFCSUUwRVFBSkFJQWxCQlU0RVFDQURRUU5yS0FJQUlRY2dEeUFKUVFWck5nS1VBU0FQSUFOQkJHczJBb0FCREFFTFFRQWhCeUFKUVFKSURRQkJHQ0VKQTBBZ0R5QURRUUZySWdFMkFvQUJJQU10QUFBaFNTQVBJQVpCQVdzaUFqWUNsQUVnU1NBSmRDQUhjaUVISUFaQkFVc2hTaUFCSVFNZ0NVRUlheUVKSUFJaEJpQktEUUFMQ3lBUElBZEIvd0Z4SWdGQmp3RkxOZ0tZQVNBUFFRZEJDQ0FIUVlDQWdQZ0hjVUdBZ0lENEIwWWJRUWdnRVJzaUEwRUlRUWRCQ0NBSFFZQ0EvQU54UVlDQS9BTkdHeUFIUWYvLy8vOTRUUnRxSWdaQkNFRUhRUWdnQjBHQS9nRnhRWUQrQVVZYklBZEJFSFpCL3dGeElnbEJqd0ZORzJvaUFrRUlRUWRCQ0NBSFFmOEFjVUgvQUVZYklBZEJDSFpCL3dGeElnaEJqd0ZOR3lBTmFtbzJBcEFCSUE4Z0NTQURkQ0FIUVJoMmNpQUlJQVowY2lBQklBSjBjcTBnRGEyR0lHQ0VOd09JQVF0QkFRc2hNU0FZSUJKcklSOGdGa0VCYWlFc0lCUkJBRG9Bd0JBZ0ZFSEFFR29oQ3lBUFFZQUNhaEFoSVFJZ0ZVRUFTZ1JBSUNaQkFXc2hFeUFVSVFNZ0N5RUlRUUFoRVNBT0lRWkJBQ0VOQTBBZ0RTRUZJQkZCQ0hRZ0QwSGdBV29RS2tIL0FIRkJBWFJ5UWJEOUFHb3ZBUUFoQVFKQUlCRU5BQ0FCUVFBZ0FrRUNheUlIUVg5R0d5RUJJQUpCQVVvRVFDQUhJUUlNQVFzZ0QwR0FBbW9RSVNFQ0N5QVBLUVBvQVNGa0lBOG9BdkFCSVVzZ0F5QURLQUlBSUFGQkJIWWlHRUVEY1NBQlFRSjJRVEJ4Y2lBaWRISWlGallDQUNBQlFRVjJRUWR4SUFGQkVIRWlIa0VFZG5JaEVTQkxJQUZCQjNFaUIyc2hEU0JrSUFldGlDSmdweUVKUVFBaEJ5QVZJQVZCQW5KS0JFQWdFVUVJZENBSlFmOEFjVUVCZEhKQnNQMEFhaThCQUNFSEFrQWdFUTBBSUFkQkFDQUNRUUpySWdsQmYwWWJJUWNnQWtFQlNnUkFJQWtoQWd3QkN5QVBRWUFDYWhBaElRSUxJQWRCQkhaQkFYRWdCMEVGZGtFSGNYSWhFU0FOSUFkQkIzRWlDV3NoRFNCZ0lBbXRpQ0pncHlFSkN5QURJQWRCQW5SQmdBWnhJQWRCTUhGeUlDSkJCR3AwSUJaeU5nSUFBa0FnQjBFQ2RrRUNjU0FCUVFOMlFRRnhjaUlYUVFOSERRQkJCRUVESUFKQkFtc2lGa0YvUmhzaEZ5QUNRUUZLQkVBZ0ZpRUNEQUVMSUE5QmdBSnFFQ0VoQWdzQ2Z5QVhSUVJBSUE5Q2dZQ0FnQkEzQW5oQkFBd0JDeUFYUVFKTkJFQWdEMEVCSUFsQkIzRkI1SjBCYWkwQUFDSVdRUVYyUVg4Z0ZrRUNka0VIY1NJWmRFRi9jeUFKSUJaQkEzRWlDWFp4YWtFQmFpSVdJQmRCQVVZaUZ4czJBbndnRHlBV1FRRWdGeHMyQW5nZ0NTQVphZ3dCQ3lBSklBbEJCM0ZCNUowQmFpMEFBQ0lXUVFOeElobDJJUWtnRjBFRFJnUkFJQlpCQlhaQkFXb2hGeUFaUVFOR0JFQWdEeUFKUVFGeFFRSnlOZ0o4SUE4Z0YwRi9JQlpCQW5aQkIzRWlGblJCZjNNZ0NVRUJkbkZxTmdKNElCWkJCR29NQWdzZ0R5QVhJQWtnQ1VFSGNVSGtuUUZxTFFBQUlnbEJBM0VpRW5ZaUlFRi9JQlpCQW5aQkIzRWlGblJCZjNOeGFqWUNlQ0FQUVg4Z0NVRUNka0VIY1NJWGRFRi9jeUFnSUJaMmNTQUpRUVYyYWtFQmFqWUNmQ0FXSUJscUlCSnFJQmRxREFFTElBOGdDU0FKUVFkeFFlU2RBV290QUFBaUNVRURjU0lTZGlJZ1FYOGdGa0VDZGtFSGNTSVhkRUYvYzNFZ0ZrRUZkbXBCQTJvMkFuZ2dEMEYvSUFsQkFuWkJCM0VpRm5SQmYzTWdJQ0FYZG5FZ0NVRUZkbXBCQTJvMkFud2dFaUFaYWlBWGFpQVdhZ3NoQ1FKQUlDd2dEeWdDZUNJWlR3UkFJQThvQW53aUVpQXNUUTBCQ3lBaEJFQkJBQ0VISUIxQkFVR3A5Z0JCQUJBSURBY0xRUUFoQnlBZFFRRkJxZllBUVFBUUNBd0dDeUFQSUEwZ0NXczJBdkFCSUE4Z1lDQUpyWWczQStnQklBZEI4QUZ4SUJoQkQzRnlRZjhCUWY4QklBVkJCR29pRFNBVmEwRUJkSFlnRFNBVlRCc2lDU0FKUWRVQWNTQWZRUUZLR3lJSlFYOXpjUVJBSUNFRVFFRUFJUWNnSFVFQlFiL2FBRUVBRUFnTUJ3dEJBQ0VISUIxQkFVRy8yZ0JCQUJBSURBWUxBa0FDUUNBZUJFQWdEMEhBQVdvUUV5RVhJQThnRHlnQzBBRWdHU0FCUVJOMFFSOTFhaUlXYXpZQzBBRWdEeUFQS1FQSUFTQVdyWWczQThnQklCZEJmeUFXZEVGL2MzRWdBVUVJZGtFQmNTQVdkSEpCQVhKQkFtb2dFM1FnRjBFZmRISWhGZ3dCQzBFQUlSWWdDVUVCY1VVTkFRc2dCaUFXTmdJQUN3SkFJQUZCSUhFRVFDQVBRY0FCYWhBVElSY2dEeUFQS0FMUUFTQVpJQUZCRW5SQkgzVnFJaFpyTmdMUUFTQVBJQThwQThnQklCYXRpRGNEeUFFZ0JpQVZRUUowYWlBWFFYOGdGblJCZjNOeElBRkJDWFpCQVhFZ0ZuUnlRUUZ5SWhaQkFtb2dFM1FnRjBFZmRISTJBZ0FnQ0VFZ0lCWm5heUlXSUFndEFBQkIvd0J4SWhjZ0ZpQVhTeHRCZ0FGeU9nQUFEQUVMSUFsQkFuRkZEUUFnQmlBVlFRSjBha0VBTmdJQUN5QUdRUVJxSVJjQ1FBSkFJQUZCd0FCeEJFQWdEMEhBQVdvUUV5RVlJQThnRHlnQzBBRWdHU0FCUVJGMFFSOTFhaUlXYXpZQzBBRWdEeUFQS1FQSUFTQVdyWWczQThnQklCaEJmeUFXZEVGL2MzRWdBVUVLZGtFQmNTQVdkSEpCQVhKQkFtb2dFM1FnR0VFZmRISWhGZ3dCQzBFQUlSWWdDVUVFY1VVTkFRc2dGeUFXTmdJQUN5QUlRUUE2QUFFQ1FDQUJRWUFCY1FSQUlBOUJ3QUZxRUJNaEdDQVBJQThvQXRBQklCa2dBVUVRZEVFZmRXb2lGbXMyQXRBQklBOGdEeWtEeUFFZ0ZxMklOd1BJQVNBWElCVkJBblJxSUJoQmZ5QVdkRUYvYzNFZ0FVRUxka0VCY1NBV2RISkJBWElpQVVFQ2FpQVRkQ0FZUVI5MGNqWUNBQ0FJUWFCL0lBRm5hem9BQVF3QkN5QUpRUWh4UlEwQUlCY2dGVUVDZEdwQkFEWUNBQXNnQmtFSWFpRUJBa0FDUUNBSFFSQnhCRUFnRDBIQUFXb1FFeUVaSUE4Z0R5Z0MwQUVnRWlBSFFSTjBRUjkxYWlJV2F6WUMwQUVnRHlBUEtRUElBU0FXcllnM0E4Z0JJQmxCZnlBV2RFRi9jM0VnQjBFSWRrRUJjU0FXZEhKQkFYSkJBbW9nRTNRZ0dVRWZkSEloRnd3QkMwRUFJUmNnQ1VFUWNVVU5BUXNnQVNBWE5nSUFDd0pBSUFkQklIRUVRQ0FQUWNBQmFoQVRJUmtnRHlBUEtBTFFBU0FTSUFkQkVuUkJIM1ZxSWhack5nTFFBU0FQSUE4cEE4Z0JJQmF0aURjRHlBRWdBU0FWUVFKMGFpQVpRWDhnRm5SQmYzTnhJQWRCQ1haQkFYRWdGblJ5UVFGeUlnRkJBbW9nRTNRZ0dVRWZkSEkyQWdBZ0NFRWdJQUZuYXlJQklBZ3RBQUZCL3dCeEloWWdBU0FXU3h0QmdBRnlPZ0FCREFFTElBbEJJSEZGRFFBZ0FTQVZRUUowYWtFQU5nSUFDeUFHUVF4cUlRRUNRQUpBSUFkQndBQnhCRUFnRDBIQUFXb1FFeUVaSUE4Z0R5Z0MwQUVnRWlBSFFSRjBRUjkxYWlJV2F6WUMwQUVnRHlBUEtRUElBU0FXcllnM0E4Z0JJQmxCZnlBV2RFRi9jM0VnQjBFS2RrRUJjU0FXZEhKQkFYSkJBbW9nRTNRZ0dVRWZkSEloRnd3QkMwRUFJUmNnQ1VIQUFIRkZEUUVMSUFFZ0Z6WUNBQXNnQ0VFQ2FpSUlRUUE2QUFBQ1FDQUhRWUFCY1FSQUlBOUJ3QUZxRUJNaEZpQVBJQThvQXRBQklCSWdCMEVRZEVFZmRXb2lDV3MyQXRBQklBOGdEeWtEeUFFZ0NhMklOd1BJQVNBQklCVkJBblJxSUJaQmZ5QUpkRUYvYzNFZ0IwRUxka0VCY1NBSmRISkJBWElpQVVFQ2FpQVRkQ0FXUVI5MGNqWUNBQ0FJUWFCL0lBRm5hem9BQUF3QkN5QUpRWUFCU1EwQUlBRWdGVUVDZEdwQkFEWUNBQXNnSWtFUWN5RWlJQU1nQlVFRWNXb2hBeUFHUVJCcUlRWWdEU0FWU0EwQUN3c2dDa0VJY1NFNElCUkJzQXhxSVNnZ0ZFR2dDR29oS1NBVVFaQUVhaUVsSUI5QkEwNEVRQ0FWUVFOc0lUa2dGVUVCZENFNklDWkJBV3NoSUVFRElDWkJBbXNpQVhRaExVRUJJQUYwSVM0Z0ZVRUhha0VCZGtIOC8vLy9CM0ZCQkdvaFBTQXJJQ1JCZjNOcUlnRkJBM1lpQTBFQ2RDSStRUVJxSVRzZ0EwRUJhaUkvUWZ6Ly8vOERjU0ljUVFKMElUd2dIRUVEZENFU0lBRkJHRWtoUUVFQ0lSa0RRQ0FaSVJNZ0N5MEFBQ0VXSUF0QkFEb0FBQ0FpUVc5eFFRSnpJU0lDUUNBVlFRQk1CRUFnRTBFQ2FpRVpEQUVMSUNVZ0ZDQVRRUVJ4R3lFUklCTkJBbW9oR1NBT0lCTWdGV3hCQW5ScUlRaEJBQ0VLSUFzaEJrRUFJUTBEUUNBTklRVWdCaTBBQVVFRmRrRUVjU0FLSUJaQkIzWnljaUlEUVFoMElBOUI0QUZxRUNwQi93QnhRUUYwY2tHd2pRRnFMd0VBSVFFQ1FDQUREUUFnQVVFQUlBSkJBbXNpQTBGL1Joc2hBU0FDUVFGS0JFQWdBeUVDREFFTElBOUJnQUpxRUNFaEFnc2dEeWtENkFFaFpTQVBLQUx3QVNGTUlCRWdFU2dDQUNBQlFRUjJRUU54SUFGQkFuWkJNSEZ5SUNKMGNpSUpOZ0lBSUFGQndBQnhJaXBCQlhZZ0FVR0FBWEVpSjBFR2RuSWhDaUJNSUFGQkIzRWlBMnNoRnlCbElBT3RpQ0pncHlFTlFRQWhHQUpBSUJVZ0JVRUNja3dFUUVFQUlRY01BUXNnQ2lBR0xRQUNRUVYyUVFSeElBWXRBQUZCQjNaeWNpSURRUWgwSUExQi93QnhRUUYwY2tHd2pRRnFMd0VBSVFjQ1FDQUREUUFnQjBFQUlBSkJBbXNpQTBGL1Joc2hCeUFDUVFGS0JFQWdBeUVDREFFTElBOUJnQUpxRUNFaEFnc2dCMEVGZGlBSFFRWjJja0VDY1NFS0lCY2dCMEVIY1NJRGF5RVhJR0FnQTYySUltQ25JUTBMSUJFZ0IwRUNkRUdBQm5FZ0IwRXdjWElnSWtFRWFuUWdDWEkyQWdCQkFTRUpRUUVoQXdKQUlBZEJBblpCQW5FZ0FVRURka0VCY1hJaUhrVU5BQ0FOSUExQkIzRkI1SjBCYWkwQUFDSURRUU54SWcxMklRa2dIa0VEUndSQVFRRWdDVUYvSUFOQkFuWkJCM0VpR0hSQmYzTnhJQU5CQlhacVFRRnFJZ01nSGtFQlJpSWVHeUVKSUFOQkFTQWVHeUVESUEwZ0dHb2hHQXdCQ3lBSlFRZHhRZVNkQVdvdEFBQWlIa0VEY1NJeklBMGdBMEVDZGtFSGNTSWJhbW9nSGtFQ2RrRUhjU0lOYWlFWUlBa2dNM1lpQ1VGL0lCdDBRWDl6Y1NBRFFRVjJha0VCYWlFRFFYOGdEWFJCZjNNZ0NTQWJkbkVnSGtFRmRtcEJBV29oQ1FzZ0R5QVhJQmhyTmdMd0FTQVBJR0FnR0sySU53UG9BU0FCUWZBQmNTSU5JQTFCQVd0eEJFQWdBeUFXUWY4QWNTSVdJQVl0QUFGQi93QnhJaGNnRmlBWFN4c2lGa0VDYXlJWFFRQWdGaUFYVHh0cUlRTUxJQWRCOEFGeEloY2dGMEVCYTNFRVFDQUpJQVl0QUFGQi93QnhJaFlnQmkwQUFrSC9BSEVpR0NBV0lCaExHeUlXUVFKclFRQWdGa0VDU3h0cUlRa0xJQU1nTEUwZ0NTQXNUWEZGQkVBZ0lRUkFRUUFoQnlBZFFRRkJqZmNBUVFBUUNBd0pDMEVBSVFjZ0hVRUJRWTMzQUVFQUVBZ01DQXNnQmkwQUFpRVdJQVpCQURzQUFTQVhJQTFCQkhaeVFmOEJRZjhCSUFWQkJHb2lEU0FWYTBFQmRIWWdEU0FWVEJzaUYwSFZBSEVnRnlBWklCOUtHeUlZUVg5emNRUkFJQ0VFUUVFQUlRY2dIVUVCUWIvYUFFRUFFQWdNQ1F0QkFDRUhJQjFCQVVHLzJnQkJBQkFJREFnTEFrQUNRQ0FCUVJCeEJFQWdEMEhBQVdvUUV5RWVJQThnRHlnQzBBRWdBeUFCUVJOMFFSOTFhaUlYYXpZQzBBRWdEeUFQS1FQSUFTQVhyWWczQThnQklCNUJmeUFYZEVGL2MzRWdBVUVJZGtFQmNTQVhkSEpCQVhKQkFtb2dJSFFnSGtFZmRISWhGd3dCQzBFQUlSY2dHRUVCY1VVTkFRc2dDQ0FYTmdJQUN3SkFJQUZCSUhFRVFDQVBRY0FCYWhBVElSNGdEeUFQS0FMUUFTQURJQUZCRW5SQkgzVnFJaGRyTmdMUUFTQVBJQThwQThnQklCZXRpRGNEeUFFZ0NDQVZRUUowYWlBZVFYOGdGM1JCZjNOeElBRkJDWFpCQVhFZ0YzUnlRUUZ5SWhkQkFtb2dJSFFnSGtFZmRISTJBZ0FnQmtFZ0lCZG5heUlYSUFZdEFBQkIvd0J4SWg0Z0Z5QWVTeHRCZ0FGeU9nQUFEQUVMSUJoQkFuRkZEUUFnQ0NBVlFRSjBha0VBTmdJQUN5QUlRUVJxSVI0Q1FBSkFJQ29FUUNBUFFjQUJhaEFUSVJzZ0R5QVBLQUxRQVNBRElBRkJFWFJCSDNWcUloZHJOZ0xRQVNBUElBOHBBOGdCSUJldGlEY0R5QUVnRzBGL0lCZDBRWDl6Y1NBQlFRcDJRUUZ4SUJkMGNrRUJja0VDYWlBZ2RDQWJRUjkwY2lFWERBRUxRUUFoRnlBWVFRUnhSUTBCQ3lBZUlCYzJBZ0FMQWtBZ0p3UkFJQTlCd0FGcUVCTWhGeUFQSUE4b0F0QUJJQU1nQVVFUWRFRWZkV29pQTJzMkF0QUJJQThnRHlrRHlBRWdBNjJJTndQSUFTQWVJQlZCQW5ScUlCZEJmeUFEZEVGL2MzRWdBVUVMZGtFQmNTQURkSEpCQVhJaUFVRUNhaUFnZENBWFFSOTBjallDQUNBR1FhQi9JQUZuYXpvQUFRd0JDeUFZUVFoeFJRMEFJQjRnRlVFQ2RHcEJBRFlDQUFzZ0NFRUlhaUVCQWtBQ1FDQUhRUkJ4QkVBZ0QwSEFBV29RRXlFWElBOGdEeWdDMEFFZ0NTQUhRUk4wUVI5MWFpSURhellDMEFFZ0R5QVBLUVBJQVNBRHJZZzNBOGdCSUJkQmZ5QURkRUYvYzNFZ0IwRUlka0VCY1NBRGRISkJBWEpCQW1vZ0lIUWdGMEVmZEhJaEF3d0JDMEVBSVFNZ0dFRVFjVVVOQVFzZ0FTQUROZ0lBQ3dKQUlBZEJJSEVFUUNBUFFjQUJhaEFUSVJjZ0R5QVBLQUxRQVNBSklBZEJFblJCSDNWcUlnTnJOZ0xRQVNBUElBOHBBOGdCSUFPdGlEY0R5QUVnQVNBVlFRSjBhaUFYUVg4Z0EzUkJmM054SUFkQkNYWkJBWEVnQTNSeVFRRnlJZ0ZCQW1vZ0lIUWdGMEVmZEhJMkFnQWdCa0VnSUFGbmF5SUJJQVl0QUFGQi93QnhJZ01nQVNBRFN4dEJnQUZ5T2dBQkRBRUxJQmhCSUhGRkRRQWdBU0FWUVFKMGFrRUFOZ0lBQ3lBSVFReHFJUUVDUUFKQUlBZEJ3QUJ4QkVBZ0QwSEFBV29RRXlFWElBOGdEeWdDMEFFZ0NTQUhRUkYwUVI5MWFpSURhellDMEFFZ0R5QVBLUVBJQVNBRHJZZzNBOGdCSUJkQmZ5QURkRUYvYzNFZ0IwRUtka0VCY1NBRGRISkJBWEpCQW1vZ0lIUWdGMEVmZEhJaEF3d0JDMEVBSVFNZ0dFSEFBSEZGRFFFTElBRWdBellDQUFzZ0JrRUNhaUVHQWtBZ0IwR0FBWEVFUUNBUFFjQUJhaEFUSVJjZ0R5QVBLQUxRQVNBSklBZEJFSFJCSDNWcUlnTnJOZ0xRQVNBUElBOHBBOGdCSUFPdGlEY0R5QUVnQVNBVlFRSjBhaUFYUVg4Z0EzUkJmM054SUFkQkMzWkJBWEVnQTNSeVFRRnlJZ0ZCQW1vZ0lIUWdGMEVmZEhJMkFnQWdCa0dnZnlBQloyczZBQUFNQVFzZ0dFR0FBVWtOQUNBQklCVkJBblJxUVFBMkFnQUxJQ0pCRUhNaElpQVJJQVZCQkhGcUlSRWdDRUVRYWlFSUlBMGdGVWdOQUFzTEFrQWdERUVDU1EwQUlCTkJBbkZGRFFBZ0dVRUVjU0VEQWtBQ2Z3SkFBa0FnTVFSQUlCUWdKU0FER3lFV1FRQWhHQ0FWUVFCTURRRWdEaUFUUVFKcklCVnNRUUowYWlFUkEwQWdEMEdBQVdvUUtpRUhRUUFoQVNBV0tBSUFJZ2dFUUNBUklCaEJBblJxSVFGQkFDRUpRUThoQmdOQUFrQWdCaUFJY1VVTkFDQUdRWkdpeElnQmNTSU5JQWh4QkVBZ0FTQUJLQUlBSUFkQmYzTkJBWEVnSUhSeklDNXlOZ0lBSUFkQkFYWWhCd3NnRFVFQmRDQUljUVJBSUFFZ0ZVRUNkR29pQlNBRktBSUFJQWRCZjNOQkFYRWdJSFJ6SUM1eU5nSUFJQWRCQVhZaEJ3c2dEVUVDZENBSWNRUkFJQUVnT2tFQ2RHb2lCU0FGS0FJQUlBZEJmM05CQVhFZ0lIUnpJQzV5TmdJQUlBZEJBWFloQndzZ0RVRURkQ0FJY1VVTkFDQUJJRGxCQW5ScUlnMGdEU2dDQUNBSFFYOXpRUUZ4SUNCMGN5QXVjallDQUNBSFFRRjJJUWNMSUFGQkJHb2hBU0FHUVFSMElRWWdDVUVCYWlJSlFRaEhEUUFMSUFocElRRUxJQlpCQkdvaEZpQVBJQThvQXBBQklBRnJOZ0tRQVNBUElBOHBBNGdCSUFHdGlEY0RpQUVnR0VFSWFpSVlJQlZJRFFBTEN5QXBJQ2dnQXhzaEJTQVVJQ1VnQXhzaEZpQURSU0VZSUJWQkFFd05BMEVBSVFNZ1FBMEJJQVVnRmlBN2Fra2dGaUFGSUR0cUlnZEpjUTBCUVFBZ0JTSUJJQllpQmlBK2FrRUlha2tnQmtFRWFpQUhTWEVOQWhvZ0JpQThhaUVHSUFFZ1BHb2hBZjBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0ZlUVFBaEJ3TkFJQVVnQjBFQ2RDSURhaUlKSUFNZ0Ztb2lBLzBBQWdBaVgwRUUvYTBCSUY5QkJQMnJBU0JlSUYvOURRd05EZzhRRVJJVEZCVVdGeGdaR2h0QkhQMnRBZjFRL1ZBZ1gvMVFJbDc5Q3dJQUlBa2dYaUFEL1FBQ0JFRWMvYXNCL1ZBaVhrRUIvYTBCL1F4M2QzZDNkM2QzZDNkM2QzZDNkM2QzL1U0Z1hrRUIvYXNCL1F6dTd1N3U3dTd1N3U3dTd1N3U3dTd1L1U3OVVDQmUvVkFnWC8xUC9Rc0NBQ0JmSVY0Z0IwRUVhaUlISUJ4SERRQUxJQndnUDBZTkF5QVNJUU1nWHYwYkF3d0NDeUFEUlNFWUlDa2dLQ0FER3lFRkRBSUxJQVVoQVNBV0lRWkJBQXNoQndOQUlBZEJISFloQ1NBQklBWW9BZ0FpQjBFRWRpQUpJQWRCQkhSeWNpQUhjaUlKTmdJQUlBRWdDU0FHS0FJRVFSeDBjaUlKUVFGMlFmZnUzYnNIY1NBSlFRRjBRZTdkdS9kK2NYSWdDWElnQjBGL2MzRTJBZ0FnQVVFRWFpRUJJQVpCQkdvaEJpQURRUWhxSWdNZ0ZVZ05BQXNMSUJOQkJra05BRUVBSVFsQkFDRVJJQlloQVNBcElDZ2dHQnNpR3lFSElCUWdKU0FZR3lJWElRWUNRQ0FWUVFCTUlnME5BQU5BSUFGQkJHb2hBeUFIS0FJQUlRZ2dBU2dDQUNFQklBY2dPQVIvSUFnRklBRkJCSFFnRVVFY2RuSWdBVUVFZG5JZ0F5Z0NBRUVjZEhJZ0FYSkJBM1JCaUpHaXhIaHhJQWh5Q3lBR0tBSUFRWDl6Y1RZQ0FDQUdRUVJxSVFZZ0IwRUVhaUVISUFFaEVTQURJUUVnQ1VFSWFpSUpJQlZJRFFBTElBME5BQ0FPSUJOQkJtc2dGV3hCQW5ScUlVRkJBQ0VlSUJjaEVRTkFRUUFoQXlBYktBSUFJZ0VFUUNBVklCNXJJVUpCQUNFSFFRQWhDZ05BSUFjaFRTQVBRYUFCYWhBVElRY0NRQ0FLSUFwQkJHb2lCaUJDSUFZZ0htb2dGVWdiSWpOT0lrTUVRRUVBSVFZTUFRc2dFU2dDQUVGL2N5RXFJRUVnQ2lBZWNrRUNkR29oR0VFQUlRWkJEeUFLSWdsQkFuUWlSSFFpRFNFSUEwQUNRQ0FCSUFoeFJRMEFJQWhCa2FMRWlBRnhJaWNnQVhFRVFDQUhRUUZ4QkVBZ0F5QW5jaUVEUVRJZ0NVRUNkSFFnS25FZ0FYSWhBUXNnQjBFQmRpRUhJQVpCQVdvaEJnc2dBU0FuUVFGMElqUnhCRUFnQjBFQmNRUkFJQU1nTkhJaEF5QUJRZlFBSUFsQkFuUjBJQ3B4Y2lFQkN5QUhRUUYySVFjZ0JrRUJhaUVHQ3lBQklDZEJBblFpTkhFRVFDQUhRUUZ4QkVBZ0F5QTBjaUVESUFGQjZBRWdDVUVDZEhRZ0tuRnlJUUVMSUFkQkFYWWhCeUFHUVFGcUlRWUxJQUVnSjBFRGRDSW5jVVVOQUNBSFFRRnhCRUFnQXlBbmNpRURJQUZCd0FFZ0NVRUNkSFFnS25GeUlRRUxJQVpCQVdvaEJpQUhRUUYySVFjTElBaEJCSFFoQ0NBSlFRRnFJZ2tnTTBnTkFBc2dBeUJFZGtILy93TnhSUTBBSUVNTkFBTkFBa0FnQXlBTmNVVU5BQ0FOUVpHaXhJZ0JjU0lKSUFOeEJFQWdHQ0FZS0FJQUlBZEJIM1J5SUMxeU5nSUFJQWRCQVhZaEJ5QUdRUUZxSVFZTElBbEJBWFFnQTNFRVFDQVlJQlZCQW5ScUlnZ2dDQ2dDQUNBSFFSOTBjaUF0Y2pZQ0FDQUhRUUYySVFjZ0JrRUJhaUVHQ3lBSlFRSjBJQU54QkVBZ0dDQTZRUUowYWlJSUlBZ29BZ0FnQjBFZmRISWdMWEkyQWdBZ0IwRUJkaUVISUFaQkFXb2hCZ3NnQ1VFRGRDQURjVVVOQUNBWUlEbEJBblJxSWdrZ0NTZ0NBQ0FIUVI5MGNpQXRjallDQUNBR1FRRnFJUVlnQjBFQmRpRUhDeUFOUVFSMElRMGdHRUVFYWlFWUlBcEJBV29pQ2lBelNBMEFDd3NnRHlBUEtBS3dBU0FHYXpZQ3NBRWdEeUFQS1FPb0FTQUdyWWczQTZnQlFRRWhCMEVFSVFvZ1RVRUJjVVVOQUFzZ0d5QWJLQUlFSUFOQkczWkJEbkVnQTBFZGRuSWdBMEVjZG5JZ0VTZ0NCRUYvYzNGeU5nSUVDeUFSS0FJQUlBTnlJZ05CQTNaQmthTEVpQUZ4SWdGQkJIWWdBVUVFZEhJZ0FYSWhCaUFlQkVBZ0JVRUVheUlISUFjb0FnQWdGa0VFYXlnQ0FFRi9jeUFCUVJ4MGNYSTJBZ0FMSUFVZ0JTZ0NBQ0FHSUJZb0FnQkJmM054Y2pZQ0FDQUZJQVVvQWdRZ0ZpZ0NCRUYvY3lBRFFSOTJjWEkyQWdRZ0cwRUVhaUViSUJGQkJHb2hFU0FGUVFScUlRVWdGa0VFYWlFV0lCNUJDR29pSGlBVlNBMEFDd3NnRjBFQUlEMFFEaG9MSUJrZ0gwZ05BQXNMQWtBZ0RFRUNTUTBBQWtBZ0gwRURjVUVCYXlJV1FRSkpJREZ4QkVBZ0ZVRUFUQTBCUVFFZ0prRUNhM1FoQWlBT0lCOUIvUC8vQjNFZ0ZXeEJBblJxSVJFZ0pTQVVJQjlCQkhFYklRVWdKa0VCYXlFSVFRQWhDaUFWUVF4c0lRd2dGVUVEZENFTEEwQWdEMEdBQVdvUUtpRUhRUUFoQVNBRktBSUFJZ01FUUNBUklBcEJBblJxSVFGQkR5RUdRUUFoQ1FOQUFrQWdBeUFHY1VVTkFDQUdRWkdpeElnQmNTSU5JQU54QkVBZ0FTQUJLQUlBSUFkQmYzTkJBWEVnQ0hSeklBSnlOZ0lBSUFkQkFYWWhCd3NnRFVFQmRDQURjUVJBSUFFZ0ZVRUNkR29pSFNBZEtBSUFJQWRCZjNOQkFYRWdDSFJ6SUFKeU5nSUFJQWRCQVhZaEJ3c2dEVUVDZENBRGNRUkFJQUVnQzJvaUhTQWRLQUlBSUFkQmYzTkJBWEVnQ0hSeklBSnlOZ0lBSUFkQkFYWWhCd3NnRFVFRGRDQURjVVVOQUNBQklBeHFJZzBnRFNnQ0FDQUhRWDl6UVFGeElBaDBjeUFDY2pZQ0FDQUhRUUYySVFjTElBRkJCR29oQVNBR1FRUjBJUVlnQ1VFQmFpSUpRUWhIRFFBTElBTnBJUUVMSUFWQkJHb2hCU0FQSUE4b0FwQUJJQUZyTmdLUUFTQVBJQThwQTRnQklBR3RpRGNEaUFFZ0NrRUlhaUlLSUJWSURRQUxDeUFXUVFGTERRQWdGVUVBVEEwQUlDVWdGQ0FmUVFSeElnRWJJUWtnS0NBcElBRWJJUUpCQUNFREFuOENRQ0FySUNSQmYzTnFJZ0ZCT0VrTkFDQUNJQWtnQVVFQmRrSDgvLy8vQjNFaUJrRUVhaUlIYWtrZ0NTQUNJQWRxSWdkSmNRMEFJQUlnQmlBSmFrRUlha2tnQ1VFRWFpQUhTWEVOQUNBQlFRTjJRUUZxSWcxQi9QLy8vd054SWdoQkEzUWhBeUFKSUFoQkFuUWlBV29oQmlBQklBSnFJUUg5REFBQUFBQUFBQUFBQUFBQUFBQUFBQUFoWGtFQUlRY0RRQ0FDSUFkQkFuUWlGbW9pRVNBSklCWnFJaGI5QUFJQUlsOUJCUDJ0QVNCZlFRVDlxd0VnWGlCZi9RME1EUTRQRUJFU0V4UVZGaGNZR1JvYlFSejlyUUg5VVAxUUlGLzlVQ0plL1FzQ0FDQVJJRjRnRnYwQUFnUkJIUDJyQWYxUUlsNUJBZjJ0QWYwTWQzZDNkM2QzZDNkM2QzZDNkM2QzZC8xT0lGNUJBZjJyQWYwTTd1N3U3dTd1N3U3dTd1N3U3dTd1N3YxTy9WQWdYdjFRSUYvOVQvMExBZ0FnWHlGZUlBZEJCR29pQnlBSVJ3MEFDeUFJSUExR0RRSWdYdjBiQXd3QkN5QUNJUUVnQ1NFR1FRQUxJUWNEUUNBSFFSeDJJUWtnQVNBR0tBSUFJZ2RCQkhZZ0NTQUhRUVIwY25JZ0IzSWlDVFlDQUNBQklBa2dCaWdDQkVFY2RISWlDVUVCZGtIMzd0MjdCM0VnQ1VFQmRFSHUzYnYzZm5GeUlBbHlJQWRCZjNOeE5nSUFJQUZCQkdvaEFTQUdRUVJxSVFZZ0EwRUlhaUlESUJWSURRQUxDeUFmSUI5QkFXcEJBM0ZyUVFOclFRQWdIMEVHU2hzaUVTQWZUZzBBUVFNZ0prRUNhM1FoR1NBcklDUkJmM05xSWdGQkEzWWlBMEVDZENJclFRUnFJUjBnQTBFQmFpSURRZnovLy84RGNTSVNRUUowSVNFZ0VrRURkQ0VXSUJWQkRHd2hMQ0FWUVFOMElTMGdBVUVZU1NFbUlBTWdFa1loR3dOQUFrQUNRQUpBQWtBQ2Z3SkFJQjhnRVdzaUFVRUJheUlEUVFOUEJFQkJmeUVYSUFGQkJVZ05CU0FWUVFCTURRWWdKU0FVSUJGQkJIRWlBUnNoQWlBb0lDa2dBUnNoQ1NBNEJFQkJBQ0VHSUNZTkJDQUNJQWtnSFdwSklBSWdIV29nQ1V0eERRUWdBaUFoYWlFQklBa2dJV29oQndOQUlBa2dCa0VDZENJRGFpSUlJQWo5QUFJQUlBSWdBMnI5QUFJQS9VLzlDd0lBSUFaQkJHb2lCaUFTUncwQUN5QVdJUVlnR3cwR0RBVUxJQlFnSlNBQkd5RU5RUUFoQXlBbURRRWdDU0FOSUIxcVNTQU5JQWtnSFdvaUFVbHhEUUVnQ1NBTklDdHFRUWhxU1NBTlFRUnFJQUZKY1EwQklBa2dBaUFkYWtrZ0FTQUNTM0VOQVNBQ0lDRnFJUWdnQ1NBaGFpRUJJQTBnSVdvaEIvME1BQUFBQUFBQUFBQUFBQUFBQUFBQUFDRmVRUUFoQmdOQUlBa2dCa0VDZENJRGFpSUZJQU1nRFdvaURQMEFBZ0FpWDBFRS9hMEJJRjlCQlAyckFTQmVJRi85RFF3TkRnOFFFUklURkJVV0Z4Z1pHaHRCSFAydEFmMVEvVkFnRFAwQUFnUkJIUDJyQWYxUUlGLzlVRUVEL2FzQi9ReUlpSWlJaUlpSWlJaUlpSWlJaUlpSS9VNGdCZjBBQWdEOVVDQUNJQU5xL1FBQ0FQMVAvUXNDQUNCZklWNGdCa0VFYWlJR0lCSkhEUUFMSUJzTkJTQVdJUU1nWHYwYkF3d0NDeUFEUVFKMFFleWRBV29vQWdBaEZ3d0VDeUFOSVFjZ0NTRUJJQUloQ0VFQUN5RUdBMEFnQmtFY2RpRUpJQUVnQVNnQ0FDQUhLQUlBSWdaQkJIWWdDU0FHUVFSMGNuSWdCeWdDQkVFY2RISWdCbkpCQTNSQmlKR2l4SGh4Y2lBSUtBSUFRWDl6Y1RZQ0FDQUlRUVJxSVFnZ0FVRUVhaUVCSUFkQkJHb2hCeUFEUVFocUlnTWdGVWdOQUFzTUFnc2dDU0VISUFJaEFRc0RRQ0FISUFjb0FnQWdBU2dDQUVGL2MzRTJBZ0FnQVVFRWFpRUJJQWRCQkdvaEJ5QUdRUWhxSWdZZ0ZVZ05BQXNMSUJWQkFFd05BQ0FsSUJRZ0VVRUVjU0lCR3lFS0lDZ2dLU0FCR3lFQ0lCUWdKU0FCR3lFVElDa2dLQ0FCR3lFZUlBNGdFU0FWYkVFQ2RHb2hMa0VBSVFVRFFFRUFJUU1nQWlnQ0FDQVhjU0lCQkVBZ0ZTQUZheUVxUVFBaEIwRUFJUTBEUUNBSElVNGdEMEdnQVdvUUV5RUhBa0FnRFNBTlFRUnFJZ1lnS2lBRklBWnFJQlZJR3lJa1RpSW5CRUJCQUNFR0RBRUxJQmNnQ2lnQ0FFRi9jM0VoR0NBdUlBVWdEWEpCQW5ScUlRdEJBQ0VHUVE4Z0RTSUpRUUowSWh4MElpQWhDQU5BQWtBZ0FTQUljVVVOQUNBSVFaR2l4SWdCY1NJaUlBRnhCRUFnQjBFQmNRUkFJQU1nSW5JaEEwRXlJQWxCQW5SMElCaHhJQUZ5SVFFTElBZEJBWFloQnlBR1FRRnFJUVlMSUFFZ0lrRUJkQ0l4Y1FSQUlBZEJBWEVFUUNBRElERnlJUU1nQVVIMEFDQUpRUUowZENBWWNYSWhBUXNnQjBFQmRpRUhJQVpCQVdvaEJnc2dBU0FpUVFKMElqRnhCRUFnQjBFQmNRUkFJQU1nTVhJaEF5QUJRZWdCSUFsQkFuUjBJQmh4Y2lFQkN5QUhRUUYySVFjZ0JrRUJhaUVHQ3lBQklDSkJBM1FpSW5GRkRRQWdCMEVCY1FSQUlBTWdJbkloQXlBQlFjQUJJQWxCQW5SMElCaHhjaUVCQ3lBR1FRRnFJUVlnQjBFQmRpRUhDeUFJUVFSMElRZ2dDVUVCYWlJSklDUklEUUFMSUFNZ0hIWkIvLzhEY1VVTkFDQW5EUUFEUUFKQUlBTWdJSEZGRFFBZ0lFR1Jvc1NJQVhFaUNTQURjUVJBSUFzZ0N5Z0NBQ0FIUVI5MGNpQVpjallDQUNBSFFRRjJJUWNnQmtFQmFpRUdDeUFKUVFGMElBTnhCRUFnQ3lBVlFRSjBhaUlJSUFnb0FnQWdCMEVmZEhJZ0dYSTJBZ0FnQjBFQmRpRUhJQVpCQVdvaEJnc2dDVUVDZENBRGNRUkFJQXNnTFdvaUNDQUlLQUlBSUFkQkgzUnlJQmx5TmdJQUlBZEJBWFloQnlBR1FRRnFJUVlMSUFsQkEzUWdBM0ZGRFFBZ0N5QXNhaUlKSUFrb0FnQWdCMEVmZEhJZ0dYSTJBZ0FnQmtFQmFpRUdJQWRCQVhZaEJ3c2dJRUVFZENFZ0lBdEJCR29oQ3lBTlFRRnFJZzBnSkVnTkFBc0xJQThnRHlnQ3NBRWdCbXMyQXJBQklBOGdEeWtEcUFFZ0JxMklOd09vQVVFQklRZEJCQ0VOSUU1QkFYRkZEUUFMSUFJZ0FpZ0NCQ0FEUVJ0MlFRNXhJQU5CSFhaeUlBTkJISFp5SUFvb0FnUkJmM054Y2pZQ0JBc2dDaWdDQUNBRGNpSURRUU4yUVpHaXhJZ0JjU0lCUVFSMklBRkJCSFJ5SUFGeUlRWWdCUVJBSUI1QkJHc2lCeUFIS0FJQUlCTkJCR3NvQWdCQmYzTWdBVUVjZEhGeU5nSUFDeUFlSUI0b0FnQWdCaUFUS0FJQVFYOXpjWEkyQWdBZ0hpQWVLQUlFSUJNb0FnUkJmM01nQTBFZmRuRnlOZ0lFSUFKQkJHb2hBaUFLUVFScUlRb2dIa0VFYWlFZUlCTkJCR29oRXlBRlFRaHFJZ1VnRlVnTkFBc0xJQkZCQkdvaUVTQWZTQTBBQ3d0QkFTRUhJQjlCQUV3TkF5QVZRUUJNRFFNZ0ZVSDgvLy8vQjNFaUJrRUNkQ0VDSUJWQkJFa2hDRUVBSVFrRFFDQU9JQWtnRld4QkFuUnFJUU1DUUFKQUlBZ0VRQ0FESVFkQkFDRUJEQUVMSUFJZ0Eyb2hCMEVBSVFFRFFDQURJQUZCQW5ScUlnMGdEZjBBQWdBaVh2ME0vLy8vZi8vLy8zLy8vLzkvLy8vL2YvMU9JbC85b1FFZ1h5QmUvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvVG45VXYwTEFnQWdBVUVFYWlJQklBWkhEUUFMSUFZaUFTQVZSZzBCQ3dOQUlBZEJBQ0FIS0FJQUlnTkIvLy8vL3dkeElnMXJJQTBnQTBFQVNCczJBZ0FnQjBFRWFpRUhJQUZCQVdvaUFTQVZSdzBBQ3d0QkFTRUhJQWxCQVdvaUNTQWZSdzBBQ3d3REN5QWhSUTBBSUE4Z0dpZ0NHRFlDTkNBUElCWTJBakFnSFVFQlFkM0dBQ0FQUVRCcUVBZ01BUXNnRHlBQk5nSVVJQThnRmpZQ0VDQWRRUUZCM2NZQUlBOUJFR29RQ0VFQUlRY01BUXRCQUNFSEN5QVBRYkFDYWlRQUlBY05BUXdEQ3lBRUlBRkJDWFJCNEtrQmFqWUNiQUovSUFRb0FuUWhBUUpBQWtBZ0dpZ0NFQ0FhS0FJSWF5SUZJQm9vQWhRZ0dpZ0NER3NpQ1d3aUF5QUVLQUtFQVVzRVFDQUJFQWtnQkNBRFFRSjBFQllpQVRZQ2RFRUFJQUZGRFFNYUlBUWdBellDaEFFTUFRc2dBVVVOQVFzZ0FVRUFJQU5CQW5RUURob0xJQVFvQW5naEFRSkFJQVZCQW1vaUJpQUpRUU5xUVFKMklneEJBbXBzSWdNZ0JDZ0NpQUZOQkVBZ0EwRUNkQ0VJREFFTElBRVFDU0FFSUFOQkFuUWlDQkFXSWdFMkFuZ2dBUTBBUVFBTUFRc2dCQ0FETmdLSUFTQUJRUUFnQ0JBT0dnSkFJQVpGRFFBZ0JDZ0NlQ0lISVFFQ1FDQUdRUVJQQkVBZ0J5QUdRWHh4SWcxQkFuUnFJUUZCQUNFSUEwQWdCeUFJUVFKMGF2ME1BQUFnU1FBQUlFa0FBQ0JKQUFBZ1NmMExBZ0FnQ0VFRWFpSUlJQTFIRFFBTElBWWdEVVlOQVFzRFFDQUJRWUNBZ01rRU5nSUFJQUZCQkdvaEFTQU5RUUZxSWcwZ0JrY05BQXNMSUFjZ0RFRUJhaUFHYkVFQ2RHb2hBMEVBSVEwQ1FBSkFJQVpCQkVrRVFDQURJUUVNQVFzZ0F5QUdRWHh4SWcxQkFuUnFJUUZCQUNFSUEwQWdBeUFJUVFKMGF2ME1BQUFnU1FBQUlFa0FBQ0JKQUFBZ1NmMExBZ0FnQ0VFRWFpSUlJQTFIRFFBTElBWWdEVVlOQVFzRFFDQUJRWUNBZ01rRU5nSUFJQUZCQkdvaEFTQU5RUUZxSWcwZ0JrY05BQXNMSUFsQkEzRWlBVVVOQUNBR1JRMEFRWUNBZ01nRVFZQ0FnTUFFUVlDQWdJQUVJQUZCQWtZYklBRkJBVVliSVFzZ0J5QUdJQXhzUVFKMGFpRURRUUFoRFFKQUlBWkJCRWtFUUNBRElRRU1BUXNnQXlBR1FYeHhJZzFCQW5ScUlRRWdDLzBSSVY5QkFDRUlBMEFnQXlBSVFRSjBhaUJmL1FzQ0FDQUlRUVJxSWdnZ0RVY05BQXNnQmlBTlJnMEJDd05BSUFFZ0N6WUNBQ0FCUVFScUlRRWdEVUVCYWlJTklBWkhEUUFMQ3lBRUlBazJBb0FCSUFRZ0JUWUNmRUVCQzBVTkFpQWFLQUljSUJGcUlobEJIMDRFUUNBaFJRMENJQ01nR1RZQ0VDQWRRUUpCMXNBQUlDTkJFR29RQ0F3REN5QUVFRk5CQUNFQklBUkJ3S2tCTmdKa0lBUkI0SjRCTmdKZ0lBUkJnSjhCTmdJY0FrQUNRQUpBQWtBZ0dpZ0NOQ0lIUVFGTERRQWdCQ2dDa0FGRkRRSWdCdzBBREFFTElCb29BZ1FoQXlBSFFRUlBCRUFnQjBGOGNTRUNRUUFoQmdOQUlBTWdCa0VEZEdvaUFVRWNhaUFCUVJScUlBRkJER29nQWYwSkFnVDlWZ0lBQWYxV0FnQUMvVllDQUFNZ1h2MnVBU0ZlSUFaQkJHb2lCaUFDUncwQUN5QmVJRjRnWHYwTkNBa0tDd3dORGc4QUFRSURBQUVDQS8ydUFTSmVJRjRnWHYwTkJBVUdCd0FCQWdNQUFRSURBQUVDQS8ydUFmMGJBQ0VCSUFJZ0IwWU5BUXNEUUNBRElBSkJBM1JxS0FJRUlBRnFJUUVnQWtFQmFpSUNJQWRIRFFBTEN5QUJRUUpxSWdNZ0JDZ0NtQUZMQkVBZ0JDZ0NsQUVnQXhBUUlnWkZEUVVnQkNBR05nS1VBU0FCSUFacVFRQTdBQUFnQkNBRE5nS1lBU0FhS0FJMElRY0xJQVFvQXBRQklSNGdCMFVOQVNBYUtBSUVJUVpCQUNFQ1FRQWhBUU5BSUFJZ0htb2dCaUFCUVFOMElnTnFJZ1lvQWdBZ0JpZ0NCQkFMR2lBYUtBSUVJZ1lnQTJvb0FnUWdBbW9oQWlBQlFRRnFJZ0VnR2lnQ05Fa05BQXNNQVFzZ0IwRUJSdzBCSUJvb0FnUW9BZ0FoSGdzZ0dpZ0NQQ0lCQkVBZ0JDZ0NkQ0VzSUFRZ0FUWUNkQXNnR2lnQ0xBUkFJQlpCQ0hFaEpTQUVRUnhxSVE4Z0ZrRUJjU0V0SUJaQkFuRkZJUzVCQWlFZkEwQWdIaUFvYWlFQklCb29BZ0FnS1VFWWJHb2lJQ2dDQUNFREFrQWdMU0FmUVFKSklCa2dHaWdDSEVFRWEweHhjU0lpQkVBZ0JDQUJOZ0lVSUFRZ0FTQURhaUlETmdJWUlBUWdBeThBQURzQmNDQURRZjhCT2dBQUlBUW9BaGhCL3dFNkFBRWdCRUVBTmdJSUlBUkJBRFlDQUNBRUlBRTJBaEFNQVFzZ0JDQUJOZ0lVSUFRZ0FTQURhaUlHTmdJWUlBUWdCaThBQURzQmNDQUdRZjhCT2dBQUlBUW9BaGhCL3dFNkFBRWdCQ0FFUVJ4cU5nSm9JQVFnQVRZQ0VDQUVRUUEyQWd3Z0JDQURCSDhnQVMwQUFFRVFkQVZCZ0lEOEJ3c2lBellDQUVFQklRWWdBVUVCYWlFSklBRXRBQUVoQndKL0lBRXRBQUJCL3dGR0JFQWdCMEdRQVU4RVFDQUVRUUUyQWd3Z0EwR0EvZ055REFJTElBUWdDVFlDRUVFQUlRWWdCMEVKZENBRGFnd0JDeUFFSUFrMkFoQWdCMEVJZENBRGNnc2hBU0FFSUFZMkFnZ2dCRUdBZ0FJMkFnUWdCQ0FCUVFkME5nSUFDeUFnS0FJQUlTb0NRQ0FaUVFCTURRQWdJQ2dDQ0VVTkFDQWlJQzV5SVNkQkFDRW1BMEFDUUFKQUFrQUNRQUpBSUI5QkFXc09BZ0VDQUFzZ0lnUkFRUUVnR1hRaUFVRUJkaUFCY2lFUklBUW9BbndpQlVFQ2RDSU5JQVFvQW5ocVFReHFJUUVnQkNnQ2RDRUdRUUFoQ0NBRUtBS0FBU0lEUVFSUEJFQWdCVVVOQlNBRlFRTnNJUUlnQlVFQmRDRU1RUUFnRVdzaENRTkFJQXhCQW5RaEMwRUFJUU1EUUFKQUlBRWlCeWdDQUNJQlJRMEFBa0FnQVVHUWdJQUJjUTBBSUFGQjd3TnhSUTBBSUFRb0FnQWhBUUpBSUFRb0FnZ2lFQTBBSUFGQi93RkdJUW9nQkNnQ0VDSVFMUUFBSVFFQ1FDQUtSUVJBSUFRZ0FUWUNBQ0FFSUJCQkFXbzJBaEFNQVFzZ0FVR1BBVTBFUUNBRUlBRTJBZ0FnQkNBUVFRRnFOZ0lRUVFjaEVBd0NDMEgvQVNFQklBUkIvd0UyQWdBTFFRZ2hFQXNnQkNBUVFRRnJJaEEyQWdnQ1FDQUJJQkIyUVFGeFJRMEFBa0FnRUEwQUlBRkIvd0ZHSVFvZ0JDZ0NFQ0lRTFFBQUlRRUNRQ0FLUlFSQUlBUWdBVFlDQUNBRUlCQkJBV28yQWhBTUFRc2dBVUdQQVUwRVFDQUVJQUUyQWdBZ0JDQVFRUUZxTmdJUVFRY2hFQXdDQzBIL0FTRUJJQVJCL3dFMkFnQUxRUWdoRUFzZ0JDQVFRUUZySWhBMkFnZ2dCaUFKSUJFZ0FTQVFka0VCY1NJUUd6WUNBQ0FFS0FKOElRRWdCMEVFYXlJS0lBb29BZ0JCSUhJMkFnQWdCeUFIS0FJRVFRaHlOZ0lFSUFjZ0J5Z0NBQ0FRUVJOMGNrRVFjallDQUNBbERRQWdCMEYrSUFGclFRSjBhaUlCSUFFb0FnUkJnSUFDY2pZQ0JDQUJJQUVvQWdBZ0VFRWZkSEpCZ0lBRWNqWUNBQ0FCUVFScklnRWdBU2dDQUVHQWdBaHlOZ0lBQ3lBSElBY29BZ0JCZ0lDQUFYSWlBVFlDQUFzQ1FDQUJRWUNCZ0FoeERRQWdBVUg0SG5GRkRRQWdCQ2dDQUNFQkFrQWdCQ2dDQ0NJUURRQWdBVUgvQVVZaENpQUVLQUlRSWhBdEFBQWhBUUpBSUFwRkJFQWdCQ0FCTmdJQUlBUWdFRUVCYWpZQ0VBd0JDeUFCUVk4QlRRUkFJQVFnQVRZQ0FDQUVJQkJCQVdvMkFoQkJCeUVRREFJTFFmOEJJUUVnQkVIL0FUWUNBQXRCQ0NFUUN5QUVJQkJCQVdzaUVEWUNDQ0FIQW44Z0FTQVFka0VCY1VVRVFDQUhLQUlBREFFTEFrQWdFQTBBSUFGQi93RkdJUW9nQkNnQ0VDSVFMUUFBSVFFQ1FDQUtSUVJBSUFRZ0FUWUNBQ0FFSUJCQkFXbzJBaEFNQVFzZ0FVR1BBVTBFUUNBRUlBRTJBZ0FnQkNBUVFRRnFOZ0lRUVFjaEVBd0NDMEgvQVNFQklBUkIvd0UyQWdBTFFRZ2hFQXNnQkNBUVFRRnJJaEEyQWdnZ0JpQU5haUFKSUJFZ0FTQVFka0VCY1NJQkd6WUNBQ0FIUVFSckloQWdFQ2dDQUVHQUFuSTJBZ0FnQnlBSEtBSUVRY0FBY2pZQ0JDQUhLQUlBSUFGQkZuUnlRWUFCY2d0QmdJQ0FDSElpQVRZQ0FBc0NRQ0FCUVlDSWdNQUFjUTBBSUFGQndQY0JjVVVOQUNBRUtBSUFJUUVDUUNBRUtBSUlJaEFOQUNBQlFmOEJSaUVLSUFRb0FoQWlFQzBBQUNFQkFrQWdDa1VFUUNBRUlBRTJBZ0FnQkNBUVFRRnFOZ0lRREFFTElBRkJqd0ZOQkVBZ0JDQUJOZ0lBSUFRZ0VFRUJhallDRUVFSElSQU1BZ3RCL3dFaEFTQUVRZjhCTmdJQUMwRUlJUkFMSUFRZ0VFRUJheUlRTmdJSUlBY0NmeUFCSUJCMlFRRnhSUVJBSUFjb0FnQU1BUXNDUUNBUURRQWdBVUgvQVVZaENpQUVLQUlRSWhBdEFBQWhBUUpBSUFwRkJFQWdCQ0FCTmdJQUlBUWdFRUVCYWpZQ0VBd0JDeUFCUVk4QlRRUkFJQVFnQVRZQ0FDQUVJQkJCQVdvMkFoQkJCeUVRREFJTFFmOEJJUUVnQkVIL0FUWUNBQXRCQ0NFUUN5QUVJQkJCQVdzaUVEWUNDQ0FHSUF0cUlBa2dFU0FCSUJCMlFRRnhJZ0ViTmdJQUlBZEJCR3NpRUNBUUtBSUFRWUFRY2pZQ0FDQUhJQWNvQWdSQmdBUnlOZ0lFSUFjb0FnQWdBVUVaZEhKQmdBaHlDMEdBZ0lEQUFISWlBVFlDQUFzZ0FVR0F3SUNBQkhFTkFDQUJRWUM4RDNGRkRRQWdCQ2dDQUNFQkFrQWdCQ2dDQ0NJUURRQWdBVUgvQVVZaENpQUVLQUlRSWhBdEFBQWhBUUpBSUFwRkJFQWdCQ0FCTmdJQUlBUWdFRUVCYWpZQ0VBd0JDeUFCUVk4QlRRUkFJQVFnQVRZQ0FDQUVJQkJCQVdvMkFoQkJCeUVRREFJTFFmOEJJUUVnQkVIL0FUWUNBQXRCQ0NFUUN5QUVJQkJCQVdzaUVEWUNDQ0FCSUJCMlFRRnhCRUFnQmlBQ1FRSjBhaUZQQWtBZ0VBMEFJQUZCL3dGR0lSUWdCQ2dDRUNJUUxRQUFJUUVDUUNBVVJRUkFJQVFnQVRZQ0FDQUVJQkJCQVdvMkFoQU1BUXNnQVVHUEFVMEVRQ0FFSUFFMkFnQWdCQ0FRUVFGcU5nSVFRUWNoRUF3Q0MwSC9BU0VCSUFSQi93RTJBZ0FMUVFnaEVBc2dCQ0FRUVFGckloQTJBZ2dnVHlBSklCRWdBU0FRZGtFQmNTSVFHellDQUNBRUtBSjhJUUVnQjBFRWF5SUtJQW9vQWdCQmdJQUJjallDQUNBSElBY29BZ1JCZ0NCeU5nSUVJQWNnQnlnQ0FDQVFRUngwY2tHQXdBQnlOZ0lBSUFjZ0FVRUNkR29pQVNBQktBSUVRUVJ5TmdJRUlBRWdBU2dDREVFQmNqWUNEQ0FCSUFFb0FnZ2dFRUVTZEhKQkFuSTJBZ2dMSUFjZ0J5Z0NBRUdBZ0lDQUJISTJBZ0FMSUFaQkJHb2hCaUFIUVFScUlRRWdBMEVCYWlJRElBVkhEUUFMSUFkQkRHb2hBU0FHSUFKQkFuUnFJUVlnQ0VFRWFpSUlJQVFvQW9BQklnTkJmSEZKRFFBTEN5QURJQWhORFFNZ0JVVU5BMEVBSVJOQkFDQVJheUVMSUFNaEVBTkFBa0FnQ0NBUVJnUkFJQWdoRUF3QkN5QUJRUVJySVF3Z0FTZ0NBQ0VOUVFBaEFnTkFBa0FnRFNBQ1FRTnNJZ2QySWdsQmtJQ0FBWEVOQUNBSlFlOERjVVVOQUNBRUtBSUFJUU1DUUNBRUtBSUlJZ2tOQUNBRFFmOEJSeUVRSUFRb0FoQWlDUzBBQUNFREFrQWdFRVVFUUNBRFFaQUJUd1JBUWY4QklRTWdCRUgvQVRZQ0FBd0NDeUFFSUFNMkFnQWdCQ0FKUVFGcU5nSVFRUWNoQ1F3Q0N5QUVJQU0yQWdBZ0JDQUpRUUZxTmdJUUMwRUlJUWtMSUFRZ0NVRUJheUlKTmdJSUFrQWdBeUFKZGtFQmNVVU5BQ0FHSUFJZ0JXeEJBblJxSVZBQ1FDQUpEUUFnQTBIL0FVY2hEU0FFS0FJUUlna3RBQUFoQXdKQUlBMUZCRUFnQTBHUUFVOEVRRUgvQVNFRElBUkIvd0UyQWdBTUFnc2dCQ0FETmdJQUlBUWdDVUVCYWpZQ0VFRUhJUWtNQWdzZ0JDQUROZ0lBSUFRZ0NVRUJhallDRUF0QkNDRUpDeUFFSUFsQkFXc2lDVFlDQ0NCUUlBc2dFU0FESUFsMlFRRnhJZ2tiTmdJQUlBUW9BbndoRUNBTUlBd29BZ0JCSUNBSGRISTJBZ0FnQVNBQktBSUFJQWxCRTNSQkVISWdCM1J5TmdJQUlBRWdBU2dDQkVFSUlBZDBjallDQkNBQ0lDVnlSUVJBSUFGQmZpQVFhMEVDZEdvaUF5QURLQUlFUVlDQUFuSTJBZ1FnQXlBREtBSUFJQWxCSDNSeVFZQ0FCSEkyQWdBZ0EwRUVheUlESUFNb0FnQkJnSUFJY2pZQ0FBc2dBa0VEUncwQUlBRWdFRUVDZEdvaUF5QURLQUlFUVFSeU5nSUVJQU1nQXlnQ0RFRUJjallDRENBRElBTW9BZ2dnQ1VFU2RISkJBbkkyQWdnTElBRWdBU2dDQUVHQWdJQUJJQWQwY2lJTk5nSUFJQVFvQW9BQklRTUxJQU1oRUNBQ1FRRnFJZ0lnQXlBSWEwa05BQXNMSUFaQkJHb2hCaUFCUVFScUlRRWdFMEVCYWlJVElBVkhEUUFMREFNTFFRQWhCMEVBSVExQkFDRVhBa0FDUUFKQUFrQWdCQ2dDZkNJUVFjQUFSdzBBSUFRb0FvQUJRY0FBUncwQVFRQkJBU0FaZENJQlFRRjJJQUZ5SWhGcklRVWdCRUVjYWlFUUlBUW9BbmhCakFKcUlRWWdCQ2dDQ0NFSUlBUW9BZ1FoQXlBRUtBSUFJUUlnQkNnQ2FDRU1JQVFvQW5RaEFTQVdRUWh4RFFFRFFFRUFJUmNEUUNBQklRa2dCaUlIS0FJQUlnWUVRQUpBSUFaQmtJQ0FBWEVOQUNBR1FlOERjU0lCUlEwQUlBTWdFQ0FFS0FKc0lBRnFMUUFBUVFKMGFpSU1LQUlBSWdzb0FnQWlBV3NoQXdKL0lBRWdBa0VRZGtzRVFDQUxLQUlFSVFvZ0RDQUxRUWhCRENBQklBTkxJaFFiYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVMSUFndEFBRWhBeUFJTFFBQVFmOEJSZ1JBSUFOQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXdDQ3lBRUlBczJBaEFnQTBFSmRDQUNhaUVDUVFjaENBd0JDeUFFSUFzMkFoQkJDQ0VJSUFOQkNIUWdBbW9oQWdzZ0NFRUJheUVJSUFKQkFYUWhBaUFCUVFGMElnRkJnSUFDU1EwQUN5QUJJUU1nQ2lBS1JTQVVHd3dCQ3lBQ0lBRkJFSFJySVFJZ0EwR0FnQUp4UlFSQUlBc29BZ1FoQ2lBTUlBdEJERUVJSUFFZ0Ewc2lGQnRxS0FJQU5nSUFBMEFDUUNBSURRQWdCQ2dDRUNJSVFRRnFJUXNnQ0MwQUFTRUJJQWd0QUFCQi93RkdCRUFnQVVHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUlEQUlMSUFRZ0N6WUNFQ0FCUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQ3pZQ0VFRUlJUWdnQVVFSWRDQUNhaUVDQ3lBSVFRRnJJUWdnQWtFQmRDRUNJQU5CQVhRaUEwR0FnQUpKRFFBTElBcEZJQW9nRkJzTUFRc2dDeWdDQkFzRWZ5QURJQkFnQnlnQ0JFRVJka0VFY1NBSFFRUnJJZ29vQWdCQkUzWkJBWEVnQmtFT2RrRVFjU0FHUVJCMlFjQUFjU0FHUWFvQmNYSnljbklpRkVIZ3VRRnFMUUFBUVFKMGFpSU1LQUlBSWdzb0FnQWlBV3NoQXlBVVFlQzdBV290QUFBaEV5QUpJQVVnRVFKL0lBRWdBa0VRZGtzRVFDQUxLQUlFSVJRZ0RDQUxRUWhCRENBQklBTkxJZzRiYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVMSUFndEFBRWhBeUFJTFFBQVFmOEJSZ1JBSUFOQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXdDQ3lBRUlBczJBaEFnQTBFSmRDQUNhaUVDUVFjaENBd0JDeUFFSUFzMkFoQkJDQ0VJSUFOQkNIUWdBbW9oQWdzZ0NFRUJheUVJSUFKQkFYUWhBaUFCUVFGMElnRkJnSUFDU1EwQUN5QUJJUU1nRkNBVVJTQU9Hd3dCQ3lBQ0lBRkJFSFJySVFJZ0EwR0FnQUp4UlFSQUlBc29BZ1FoRkNBTUlBdEJERUVJSUFFZ0Ewc2lEaHRxS0FJQU5nSUFBMEFDUUNBSURRQWdCQ2dDRUNJSVFRRnFJUXNnQ0MwQUFTRUJJQWd0QUFCQi93RkdCRUFnQVVHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUlEQUlMSUFRZ0N6WUNFQ0FCUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQ3pZQ0VFRUlJUWdnQVVFSWRDQUNhaUVDQ3lBSVFRRnJJUWdnQWtFQmRDRUNJQU5CQVhRaUEwR0FnQUpKRFFBTElCUkZJQlFnRGhzTUFRc2dDeWdDQkFzZ0UzTWlBUnMyQWdBZ0NpQUtLQUlBUVNCeU5nSUFJQWNnQnlnQ0JFRUljallDQkNBSFFZd0NheUlMSUFzb0FnQkJnSUFJY2pZQ0FDQUhRWVFDYXlJTElBc29BZ0JCZ0lBQ2NqWUNBQ0FIUVlnQ2F5SUxJQXNvQWdBZ0FVRWZkSEpCZ0lBRWNqWUNBQ0FHSUFGQkUzUnlRUkJ5QlNBR0MwR0FnSUFCY2lFR0N3SkFJQVpCZ0lHQUNIRU5BQ0FHUWZnZWNVVU5BQ0FESUJBZ0JDZ0NiQ0FHUVFOMkloUkI3d054YWkwQUFFRUNkR29pRENnQ0FDSUxLQUlBSWdGcklRTUNmeUFCSUFKQkVIWkxCRUFnQ3lnQ0JDRUtJQXdnQzBFSVFRd2dBU0FEU3lJVEcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaEN5QUlMUUFCSVFNZ0NDMEFBRUgvQVVZRVFDQURRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFnTUFnc2dCQ0FMTmdJUUlBTkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUxOZ0lRUVFnaENDQURRUWgwSUFKcUlRSUxJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElBb2dDa1VnRXhzTUFRc2dBaUFCUVJCMGF5RUNJQU5CZ0lBQ2NVVUVRQ0FMS0FJRUlRb2dEQ0FMUVF4QkNDQUJJQU5MSWhNYmFpZ0NBRFlDQUFOQUFrQWdDQTBBSUFRb0FoQWlDRUVCYWlFTElBZ3RBQUVoQVNBSUxRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0F3Q0N5QUVJQXMyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBczJBaEJCQ0NFSUlBRkJDSFFnQW1vaEFnc2dDRUVCYXlFSUlBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFLUlNBS0lCTWJEQUVMSUFzb0FnUUxCSDhnQXlBUUlBY29BZ1JCRkhaQkJIRWdCMEVFYXlJS0tBSUFRUloyUVFGeElBWkJEM1pCRUhFZ0JrRVRka0hBQUhFZ0ZFR3FBWEZ5Y25KeUloUkI0TGtCYWkwQUFFRUNkR29pRENnQ0FDSUxLQUlBSWdGcklRTWdGRUhndXdGcUxRQUFJUk1nQ1NBRklCRUNmeUFCSUFKQkVIWkxCRUFnQ3lnQ0JDRVVJQXdnQzBFSVFRd2dBU0FEU3lJT0cyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaEN5QUlMUUFCSVFNZ0NDMEFBRUgvQVVZRVFDQURRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFnTUFnc2dCQ0FMTmdJUUlBTkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUxOZ0lRUVFnaENDQURRUWgwSUFKcUlRSUxJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElCUWdGRVVnRGhzTUFRc2dBaUFCUVJCMGF5RUNJQU5CZ0lBQ2NVVUVRQ0FMS0FJRUlSUWdEQ0FMUVF4QkNDQUJJQU5MSWc0YmFpZ0NBRFlDQUFOQUFrQWdDQTBBSUFRb0FoQWlDRUVCYWlFTElBZ3RBQUVoQVNBSUxRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0F3Q0N5QUVJQXMyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBczJBaEJCQ0NFSUlBRkJDSFFnQW1vaEFnc2dDRUVCYXlFSUlBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFVUlNBVUlBNGJEQUVMSUFzb0FnUUxJQk56SWdFYk5nS0FBaUFLSUFvb0FnQkJnQUp5TmdJQUlBY2dCeWdDQkVIQUFISTJBZ1FnQmlBQlFSWjBja0dBQVhJRklBWUxRWUNBZ0FoeUlRWUxBa0FnQmtHQWlJREFBSEVOQUNBR1FjRDNBWEZGRFFBZ0F5QVFJQVFvQW13Z0JrRUdkaUlVUWU4RGNXb3RBQUJCQW5ScUlnd29BZ0FpQ3lnQ0FDSUJheUVEQW44Z0FTQUNRUkIyU3dSQUlBc29BZ1FoQ2lBTUlBdEJDRUVNSUFFZ0Ewc2lFeHRxS0FJQU5nSUFBMEFDUUNBSURRQWdCQ2dDRUNJSVFRRnFJUXNnQ0MwQUFTRURJQWd0QUFCQi93RkdCRUFnQTBHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUlEQUlMSUFRZ0N6WUNFQ0FEUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQ3pZQ0VFRUlJUWdnQTBFSWRDQUNhaUVDQ3lBSVFRRnJJUWdnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBRWhBeUFLSUFwRklCTWJEQUVMSUFJZ0FVRVFkR3NoQWlBRFFZQ0FBbkZGQkVBZ0N5Z0NCQ0VLSUF3Z0MwRU1RUWdnQVNBRFN5SVRHMm9vQWdBMkFnQURRQUpBSUFnTkFDQUVLQUlRSWdoQkFXb2hDeUFJTFFBQklRRWdDQzBBQUVIL0FVWUVRQ0FCUVpBQlR3UkFJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ01BZ3NnQkNBTE5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFnTUFRc2dCQ0FMTmdJUVFRZ2hDQ0FCUVFoMElBSnFJUUlMSUFoQkFXc2hDQ0FDUVFGMElRSWdBMEVCZENJRFFZQ0FBa2tOQUFzZ0NrVWdDaUFUR3d3QkN5QUxLQUlFQ3dSL0lBTWdFQ0FIS0FJRVFSZDJRUVJ4SUFkQkJHc2lDaWdDQUVFWmRrRUJjU0FHUVJKMlFSQnhJQVpCRm5aQndBQnhJQlJCcWdGeGNuSnljaUlVUWVDNUFXb3RBQUJCQW5ScUlnd29BZ0FpQ3lnQ0FDSUJheUVESUJSQjRMc0JhaTBBQUNFVElBa2dCU0FSQW44Z0FTQUNRUkIyU3dSQUlBc29BZ1FoRkNBTUlBdEJDRUVNSUFFZ0Ewc2lEaHRxS0FJQU5nSUFBMEFDUUNBSURRQWdCQ2dDRUNJSVFRRnFJUXNnQ0MwQUFTRURJQWd0QUFCQi93RkdCRUFnQTBHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUlEQUlMSUFRZ0N6WUNFQ0FEUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQ3pZQ0VFRUlJUWdnQTBFSWRDQUNhaUVDQ3lBSVFRRnJJUWdnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBRWhBeUFVSUJSRklBNGJEQUVMSUFJZ0FVRVFkR3NoQWlBRFFZQ0FBbkZGQkVBZ0N5Z0NCQ0VVSUF3Z0MwRU1RUWdnQVNBRFN5SU9HMm9vQWdBMkFnQURRQUpBSUFnTkFDQUVLQUlRSWdoQkFXb2hDeUFJTFFBQklRRWdDQzBBQUVIL0FVWUVRQ0FCUVpBQlR3UkFJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ01BZ3NnQkNBTE5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFnTUFRc2dCQ0FMTmdJUVFRZ2hDQ0FCUVFoMElBSnFJUUlMSUFoQkFXc2hDQ0FDUVFGMElRSWdBMEVCZENJRFFZQ0FBa2tOQUFzZ0ZFVWdGQ0FPR3d3QkN5QUxLQUlFQ3lBVGN5SUJHellDZ0FRZ0NpQUtLQUlBUVlBUWNqWUNBQ0FISUFjb0FnUkJnQVJ5TmdJRUlBWWdBVUVaZEhKQmdBaHlCU0FHQzBHQWdJREFBSEloQmdzQ1FDQUdRWURBZ0lBRWNRMEFJQVpCZ0x3UGNVVU5BQ0FESUJBZ0JDZ0NiQ0FHUVFsMkloUkI3d054YWkwQUFFRUNkR29pRENnQ0FDSUxLQUlBSWdGcklRTUNmeUFCSUFKQkVIWkxCRUFnQ3lnQ0JDRUtJQXdnQzBFSVFRd2dBU0FEU3lJVEcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaEN5QUlMUUFCSVFNZ0NDMEFBRUgvQVVZRVFDQURRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFnTUFnc2dCQ0FMTmdJUUlBTkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUxOZ0lRUVFnaENDQURRUWgwSUFKcUlRSUxJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElBb2dDa1VnRXhzTUFRc2dBaUFCUVJCMGF5RUNJQU5CZ0lBQ2NVVUVRQ0FMS0FJRUlRb2dEQ0FMUVF4QkNDQUJJQU5MSWhNYmFpZ0NBRFlDQUFOQUFrQWdDQTBBSUFRb0FoQWlDRUVCYWlFTElBZ3RBQUVoQVNBSUxRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0F3Q0N5QUVJQXMyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBczJBaEJCQ0NFSUlBRkJDSFFnQW1vaEFnc2dDRUVCYXlFSUlBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFLUlNBS0lCTWJEQUVMSUFzb0FnUUxCSDhnQXlBUUlBY29BZ1JCR25aQkJIRWdCMEVFYXlJS0tBSUFRUngyUVFGeElBWkJGWFpCRUhFZ0JrRVpka0hBQUhFZ0ZFR3FBWEZ5Y25KeUloUkI0TGtCYWkwQUFFRUNkR29pRENnQ0FDSUxLQUlBSWdGcklRTWdGRUhndXdGcUxRQUFJUk1nQ1NBRklCRUNmeUFCSUFKQkVIWkxCRUFnQ3lnQ0JDRVVJQXdnQzBFSVFRd2dBU0FEU3lJT0cyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaEN5QUlMUUFCSVFNZ0NDMEFBRUgvQVVZRVFDQURRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFnTUFnc2dCQ0FMTmdJUUlBTkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUxOZ0lRUVFnaENDQURRUWgwSUFKcUlRSUxJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElCUWdGRVVnRGhzTUFRc2dBaUFCUVJCMGF5RUNJQU5CZ0lBQ2NVVUVRQ0FMS0FJRUlSUWdEQ0FMUVF4QkNDQUJJQU5MSWc0YmFpZ0NBRFlDQUFOQUFrQWdDQTBBSUFRb0FoQWlDRUVCYWlFTElBZ3RBQUVoQVNBSUxRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0F3Q0N5QUVJQXMyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBczJBaEJCQ0NFSUlBRkJDSFFnQW1vaEFnc2dDRUVCYXlFSUlBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFVUlNBVUlBNGJEQUVMSUFzb0FnUUxJQk56SWdFYk5nS0FCaUFLSUFvb0FnQkJnSUFCY2pZQ0FDQUhJQWNvQWdSQmdDQnlOZ0lFSUFjZ0J5Z0NoQUpCQkhJMkFvUUNJQWNnQnlnQ2pBSkJBWEkyQW93Q0lBY2dCeWdDaUFJZ0FVRVNkSEpCQW5JMkFvZ0NJQVlnQVVFY2RISkJnTUFBY2dVZ0JndEJnSUNBZ0FSeUlRWUxJQWNnQmpZQ0FBc2dCMEVFYWlFR0lBbEJCR29oQVNBWFFRRnFJaGRCd0FCSERRQUxJQWRCREdvaEJpQUpRWVFHYWlFQklBMUJQRWtoVVNBTlFRUnFJUTBnVVEwQUN3d0NDMEVCSUJsMElnRkJBWFlnQVhJaERTQUVLQUo0SWdrZ0VFRUNkR3BCREdvaEJpQUVLQUtBQVNFQklBUW9BZ2doQ0NBRUtBSUVJUU1nQkNnQ0FDRUNJQVFvQW1naERDQUVLQUowSVJFQ1FDQVdRUWh4QkVBQ1FDQUJRUVJKRFFBZ0VBUkFRUUFnRFdzaEZDQUVRUnhxSVFVZ0VFRU1iQ0VUSUJCQkEzUWhGUU5BUVFBaEN3TkFJQVlpQ1NnQ0FDSUdCRUFDUUNBR1FaQ0FnQUZ4RFFBZ0JrSHZBM0VpQVVVTkFDQURJQVVnQkNnQ2JDQUJhaTBBQUVFQ2RHb2lEQ2dDQUNJS0tBSUFJZ0ZySVFNQ2Z5QUJJQUpCRUhaTkJFQWdBaUFCUVJCMGF5RUNJQU5CZ0lBQ2NRUkFJQW9vQWdRTUFnc2dDaWdDQkNFT0lBd2dDa0VNUVFnZ0FTQURTeUlTRzJvb0FnQTJBZ0FEUUFKQUlBZ05BQ0FFS0FJUUlnaEJBV29oQ2lBSUxRQUJJUUVnQ0MwQUFFSC9BVWNFUUNBRUlBbzJBaEJCQ0NFSUlBRkJDSFFnQW1vaEFnd0JDeUFCUVk4QlRRUkFJQVFnQ2pZQ0VDQUJRUWwwSUFKcUlRSkJCeUVJREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFnTElBaEJBV3NoQ0NBQ1FRRjBJUUlnQTBFQmRDSURRWUNBQWtrTkFBc2dEa1VnRGlBU0d3d0JDeUFLS0FJRUlRNGdEQ0FLUVFoQkRDQUJJQU5MSWhJYmFpZ0NBRFlDQUFOQUFrQWdDQTBBSUFRb0FoQWlDRUVCYWlFS0lBZ3RBQUVoQXlBSUxRQUFRZjhCUndSQUlBUWdDallDRUVFSUlRZ2dBMEVJZENBQ2FpRUNEQUVMSUFOQmp3Rk5CRUFnQkNBS05nSVFJQU5CQ1hRZ0Ftb2hBa0VISVFnTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaENBc2dDRUVCYXlFSUlBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFCSVFNZ0RpQU9SU0FTR3dzRWZ5QURJQVVnQ1NnQ0JFRVJka0VFY1NBSlFRUnJJZzRvQWdCQkUzWkJBWEVnQmtFT2RrRVFjU0FHUVJCMlFjQUFjU0FHUWFvQmNYSnljbklpRWtIZ3VRRnFMUUFBUVFKMGFpSU1LQUlBSWdvb0FnQWlBV3NoQXlBU1FlQzdBV290QUFBaEdDQVJJQlFnRFFKL0lBRWdBa0VRZGswRVFDQUNJQUZCRUhScklRSWdBMEdBZ0FKeEJFQWdDaWdDQkF3Q0N5QUtLQUlFSVJJZ0RDQUtRUXhCQ0NBQklBTkxJaHNiYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVLSUFndEFBRWhBU0FJTFFBQVFmOEJSd1JBSUFRZ0NqWUNFRUVJSVFnZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FLTmdJUUlBRkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0FzZ0NFRUJheUVJSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QVNSU0FTSUJzYkRBRUxJQW9vQWdRaEVpQU1JQXBCQ0VFTUlBRWdBMHNpR3h0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFvZ0NDMEFBU0VESUFndEFBQkIvd0ZIQkVBZ0JDQUtOZ0lRUVFnaENDQURRUWgwSUFKcUlRSU1BUXNnQTBHUEFVMEVRQ0FFSUFvMkFoQWdBMEVKZENBQ2FpRUNRUWNoQ0F3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSUN5QUlRUUZySVFnZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQUVoQXlBU0lCSkZJQnNiQ3lBWWN5SUJHellDQUNBT0lBNG9BZ0JCSUhJMkFnQWdDU0FKS0FJRVFRaHlOZ0lFSUFZZ0FVRVRkSEpCRUhJRklBWUxRWUNBZ0FGeUlRWUxBa0FnQmtHQWdZQUljUTBBSUFaQitCNXhSUTBBSUFNZ0JTQUVLQUpzSUFaQkEzWWlFa0h2QTNGcUxRQUFRUUowYWlJTUtBSUFJZ29vQWdBaUFXc2hBd0ovSUFFZ0FrRVFkazBFUUNBQ0lBRkJFSFJySVFJZ0EwR0FnQUp4QkVBZ0NpZ0NCQXdDQ3lBS0tBSUVJUTRnRENBS1FReEJDQ0FCSUFOTEloZ2JhaWdDQURZQ0FBTkFBa0FnQ0EwQUlBUW9BaEFpQ0VFQmFpRUtJQWd0QUFFaEFTQUlMUUFBUWY4QlJ3UkFJQVFnQ2pZQ0VFRUlJUWdnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUtOZ0lRSUFGQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXNnQ0VFQmF5RUlJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBT1JTQU9JQmdiREFFTElBb29BZ1FoRGlBTUlBcEJDRUVNSUFFZ0Ewc2lHQnRxS0FJQU5nSUFBMEFDUUNBSURRQWdCQ2dDRUNJSVFRRnFJUW9nQ0MwQUFTRURJQWd0QUFCQi93RkhCRUFnQkNBS05nSVFRUWdoQ0NBRFFRaDBJQUpxSVFJTUFRc2dBMEdQQVUwRVFDQUVJQW8yQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VJQ3lBSVFRRnJJUWdnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBRWhBeUFPSUE1RklCZ2JDd1IvSUFNZ0JTQUpLQUlFUVJSMlFRUnhJQWxCQkdzaURpZ0NBRUVXZGtFQmNTQUdRUTkyUVJCeElBWkJFM1pCd0FCeElCSkJxZ0Z4Y25KeWNpSVNRZUM1QVdvdEFBQkJBblJxSWd3b0FnQWlDaWdDQUNJQmF5RURJQkpCNExzQmFpMEFBQ0VZSUJFZ0VFRUNkR29nRkNBTkFuOGdBU0FDUVJCMlRRUkFJQUlnQVVFUWRHc2hBaUFEUVlDQUFuRUVRQ0FLS0FJRURBSUxJQW9vQWdRaEVpQU1JQXBCREVFSUlBRWdBMHNpR3h0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFvZ0NDMEFBU0VCSUFndEFBQkIvd0ZIQkVBZ0JDQUtOZ0lRUVFnaENDQUJRUWgwSUFKcUlRSU1BUXNnQVVHUEFVMEVRQ0FFSUFvMkFoQWdBVUVKZENBQ2FpRUNRUWNoQ0F3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSUN5QUlRUUZySVFnZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQkpGSUJJZ0d4c01BUXNnQ2lnQ0JDRVNJQXdnQ2tFSVFRd2dBU0FEU3lJYkcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaENpQUlMUUFCSVFNZ0NDMEFBRUgvQVVjRVFDQUVJQW8yQWhCQkNDRUlJQU5CQ0hRZ0Ftb2hBZ3dCQ3lBRFFZOEJUUVJBSUFRZ0NqWUNFQ0FEUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ0xJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElCSWdFa1VnR3hzTElCaHpJZ0ViTmdJQUlBNGdEaWdDQUVHQUFuSTJBZ0FnQ1NBSktBSUVRY0FBY2pZQ0JDQUdJQUZCRm5SeVFZQUJjZ1VnQmd0QmdJQ0FDSEloQmdzQ1FDQUdRWUNJZ01BQWNRMEFJQVpCd1BjQmNVVU5BQ0FESUFVZ0JDZ0NiQ0FHUVFaMkloSkI3d054YWkwQUFFRUNkR29pRENnQ0FDSUtLQUlBSWdGcklRTUNmeUFCSUFKQkVIWk5CRUFnQWlBQlFSQjBheUVDSUFOQmdJQUNjUVJBSUFvb0FnUU1BZ3NnQ2lnQ0JDRU9JQXdnQ2tFTVFRZ2dBU0FEU3lJWUcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaENpQUlMUUFCSVFFZ0NDMEFBRUgvQVVjRVFDQUVJQW8yQWhCQkNDRUlJQUZCQ0hRZ0Ftb2hBZ3dCQ3lBQlFZOEJUUVJBSUFRZ0NqWUNFQ0FCUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ0xJQWhCQVdzaENDQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnRGtVZ0RpQVlHd3dCQ3lBS0tBSUVJUTRnRENBS1FRaEJEQ0FCSUFOTEloZ2JhaWdDQURZQ0FBTkFBa0FnQ0EwQUlBUW9BaEFpQ0VFQmFpRUtJQWd0QUFFaEF5QUlMUUFBUWY4QlJ3UkFJQVFnQ2pZQ0VFRUlJUWdnQTBFSWRDQUNhaUVDREFFTElBTkJqd0ZOQkVBZ0JDQUtOZ0lRSUFOQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXNnQ0VFQmF5RUlJQUpCQVhRaEFpQUJRUUYwSWdGQmdJQUNTUTBBQ3lBQklRTWdEaUFPUlNBWUd3c0VmeUFESUFVZ0NTZ0NCRUVYZGtFRWNTQUpRUVJySWc0b0FnQkJHWFpCQVhFZ0JrRVNka0VRY1NBR1FSWjJRY0FBY1NBU1Fhb0JjWEp5Y25JaUVrSGd1UUZxTFFBQVFRSjBhaUlNS0FJQUlnb29BZ0FpQVdzaEF5QVNRZUM3QVdvdEFBQWhHQ0FSSUJWcUlCUWdEUUovSUFFZ0FrRVFkazBFUUNBQ0lBRkJFSFJySVFJZ0EwR0FnQUp4QkVBZ0NpZ0NCQXdDQ3lBS0tBSUVJUklnRENBS1FReEJDQ0FCSUFOTEloc2JhaWdDQURZQ0FBTkFBa0FnQ0EwQUlBUW9BaEFpQ0VFQmFpRUtJQWd0QUFFaEFTQUlMUUFBUWY4QlJ3UkFJQVFnQ2pZQ0VFRUlJUWdnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUtOZ0lRSUFGQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXNnQ0VFQmF5RUlJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBU1JTQVNJQnNiREFFTElBb29BZ1FoRWlBTUlBcEJDRUVNSUFFZ0Ewc2lHeHRxS0FJQU5nSUFBMEFDUUNBSURRQWdCQ2dDRUNJSVFRRnFJUW9nQ0MwQUFTRURJQWd0QUFCQi93RkhCRUFnQkNBS05nSVFRUWdoQ0NBRFFRaDBJQUpxSVFJTUFRc2dBMEdQQVUwRVFDQUVJQW8yQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VJQ3lBSVFRRnJJUWdnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBRWhBeUFTSUJKRklCc2JDeUFZY3lJQkd6WUNBQ0FPSUE0b0FnQkJnQkJ5TmdJQUlBa2dDU2dDQkVHQUJISTJBZ1FnQmlBQlFSbDBja0dBQ0hJRklBWUxRWUNBZ01BQWNpRUdDd0pBSUFaQmdNQ0FnQVJ4RFFBZ0JrR0F2QTl4UlEwQUlBTWdCU0FFS0FKc0lBWkJDWFlpRWtIdkEzRnFMUUFBUVFKMGFpSU1LQUlBSWdvb0FnQWlBV3NoQXdKL0lBRWdBa0VRZGswRVFDQUNJQUZCRUhScklRSWdBMEdBZ0FKeEJFQWdDaWdDQkF3Q0N5QUtLQUlFSVE0Z0RDQUtRUXhCQ0NBQklBTkxJaGdiYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVLSUFndEFBRWhBU0FJTFFBQVFmOEJSd1JBSUFRZ0NqWUNFRUVJSVFnZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FLTmdJUUlBRkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0FzZ0NFRUJheUVJSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QU9SU0FPSUJnYkRBRUxJQW9vQWdRaERpQU1JQXBCQ0VFTUlBRWdBMHNpR0J0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFvZ0NDMEFBU0VESUFndEFBQkIvd0ZIQkVBZ0JDQUtOZ0lRUVFnaENDQURRUWgwSUFKcUlRSU1BUXNnQTBHUEFVMEVRQ0FFSUFvMkFoQWdBMEVKZENBQ2FpRUNRUWNoQ0F3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSUN5QUlRUUZySVFnZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQUVoQXlBT0lBNUZJQmdiQ3dSL0lBTWdCU0FKS0FJRVFScDJRUVJ4SUFsQkJHc2lEaWdDQUVFY2RrRUJjU0FHUVJWMlFSQnhJQVpCR1haQndBQnhJQkpCcWdGeGNuSnljaUlTUWVDNUFXb3RBQUJCQW5ScUlnd29BZ0FpQ2lnQ0FDSUJheUVESUJKQjRMc0JhaTBBQUNFWUlCRWdFMm9nRkNBTkFuOGdBU0FDUVJCMlRRUkFJQUlnQVVFUWRHc2hBaUFEUVlDQUFuRUVRQ0FLS0FJRURBSUxJQW9vQWdRaEVpQU1JQXBCREVFSUlBRWdBMHNpR3h0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFvZ0NDMEFBU0VCSUFndEFBQkIvd0ZIQkVBZ0JDQUtOZ0lRUVFnaENDQUJRUWgwSUFKcUlRSU1BUXNnQVVHUEFVMEVRQ0FFSUFvMkFoQWdBVUVKZENBQ2FpRUNRUWNoQ0F3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSUN5QUlRUUZySVFnZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQkpGSUJJZ0d4c01BUXNnQ2lnQ0JDRVNJQXdnQ2tFSVFRd2dBU0FEU3lJYkcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaENpQUlMUUFCSVFNZ0NDMEFBRUgvQVVjRVFDQUVJQW8yQWhCQkNDRUlJQU5CQ0hRZ0Ftb2hBZ3dCQ3lBRFFZOEJUUVJBSUFRZ0NqWUNFQ0FEUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ0xJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElCSWdFa1VnR3hzTElCaHpJZ29iTmdJQUlBNGdEaWdDQUVHQWdBRnlOZ0lBSUFrZ0NTZ0NCRUdBSUhJMkFnUWdCQ2dDZkVFQ2RDQUphaUlCSUFFb0FnUkJCSEkyQWdRZ0FTQUJLQUlNUVFGeU5nSU1JQUVnQVNnQ0NDQUtRUkowY2tFQ2NqWUNDQ0FHSUFwQkhIUnlRWURBQUhJRklBWUxRWUNBZ0lBRWNpRUdDeUFKSUFZMkFnQUxJQWxCQkdvaEJpQVJRUVJxSVJFZ0MwRUJhaUlMSUJCSERRQUxJQWxCREdvaEJpQVJJQk5xSVJFZ0IwRUVhaUlISUFRb0FvQUJJZ0ZCZkhGSkRRQUxEQUVMUVFRZ0FVRjhjU0lHSUFaQkJFMGJRUUZySWdaQmZIRkJCR29oQnlBSklBWkJBWFJCZUhGcVFSUnFJUVlMSUFRZ0NEWUNDQ0FFSUFNMkFnUWdCQ0FDTmdJQUlBUWdERFlDYUNBUVJRMEJJQUVnQjAwTkFRTkFJQUVnQjBZaFVrRUFJUWdnQnlFQklGSkZCRUFEUUNBRUlBWWdFU0FJSUJCc1FRSjBhaUFOSUFnZ0JDZ0NmRUVDYWtFQkVGSWdDRUVCYWlJSUlBUW9Bb0FCSWdFZ0IydEpEUUFMQ3lBR1FRUnFJUVlnRVVFRWFpRVJJQmRCQVdvaUZ5QVFSdzBBQ3d3QkN3SkFJQUZCQkVrTkFDQVFCRUJCQUNBTmF5RVVJQVJCSEdvaEJTQVFRUXhzSVJNZ0VFRURkQ0VWQTBCQkFDRUxBMEFnQmlJSktBSUFJZ1lFUUFKQUlBWkJrSUNBQVhFTkFDQUdRZThEY1NJQlJRMEFJQU1nQlNBRUtBSnNJQUZxTFFBQVFRSjBhaUlNS0FJQUlnb29BZ0FpQVdzaEF3Si9JQUVnQWtFUWRrMEVRQ0FDSUFGQkVIUnJJUUlnQTBHQWdBSnhCRUFnQ2lnQ0JBd0NDeUFLS0FJRUlRNGdEQ0FLUVF4QkNDQUJJQU5MSWhJYmFpZ0NBRFlDQUFOQUFrQWdDQTBBSUFRb0FoQWlDRUVCYWlFS0lBZ3RBQUVoQVNBSUxRQUFRZjhCUndSQUlBUWdDallDRUVFSUlRZ2dBVUVJZENBQ2FpRUNEQUVMSUFGQmp3Rk5CRUFnQkNBS05nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFnTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaENBc2dDRUVCYXlFSUlBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFPUlNBT0lCSWJEQUVMSUFvb0FnUWhEaUFNSUFwQkNFRU1JQUVnQTBzaUVodHFLQUlBTmdJQUEwQUNRQ0FJRFFBZ0JDZ0NFQ0lJUVFGcUlRb2dDQzBBQVNFRElBZ3RBQUJCL3dGSEJFQWdCQ0FLTmdJUVFRZ2hDQ0FEUVFoMElBSnFJUUlNQVFzZ0EwR1BBVTBFUUNBRUlBbzJBaEFnQTBFSmRDQUNhaUVDUVFjaENBd0JDeUFFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUlDeUFJUVFGcklRZ2dBa0VCZENFQ0lBRkJBWFFpQVVHQWdBSkpEUUFMSUFFaEF5QU9JQTVGSUJJYkN3Ui9JQU1nQlNBSktBSUVRUkYyUVFSeElBbEJCR3NpRGlnQ0FFRVRka0VCY1NBR1FRNTJRUkJ4SUFaQkVIWkJ3QUJ4SUFaQnFnRnhjbkp5Y2lJU1FlQzVBV290QUFCQkFuUnFJZ3dvQWdBaUNpZ0NBQ0lCYXlFRElCSkI0THNCYWkwQUFDRVlJQkVnRkNBTkFuOGdBU0FDUVJCMlRRUkFJQUlnQVVFUWRHc2hBaUFEUVlDQUFuRUVRQ0FLS0FJRURBSUxJQW9vQWdRaEVpQU1JQXBCREVFSUlBRWdBMHNpR3h0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFvZ0NDMEFBU0VCSUFndEFBQkIvd0ZIQkVBZ0JDQUtOZ0lRUVFnaENDQUJRUWgwSUFKcUlRSU1BUXNnQVVHUEFVMEVRQ0FFSUFvMkFoQWdBVUVKZENBQ2FpRUNRUWNoQ0F3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSUN5QUlRUUZySVFnZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQkpGSUJJZ0d4c01BUXNnQ2lnQ0JDRVNJQXdnQ2tFSVFRd2dBU0FEU3lJYkcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaENpQUlMUUFCSVFNZ0NDMEFBRUgvQVVjRVFDQUVJQW8yQWhCQkNDRUlJQU5CQ0hRZ0Ftb2hBZ3dCQ3lBRFFZOEJUUVJBSUFRZ0NqWUNFQ0FEUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ0xJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElCSWdFa1VnR3hzTElCaHpJZ29iTmdJQUlBNGdEaWdDQUVFZ2NqWUNBQ0FKSUFrb0FnUkJDSEkyQWdRZ0NVRitJQVFvQW54clFRSjBhaUlCSUFFb0FnUkJnSUFDY2pZQ0JDQUJJQUVvQWdBZ0NrRWZkSEpCZ0lBRWNqWUNBQ0FCUVFScklnRWdBU2dDQUVHQWdBaHlOZ0lBSUFZZ0NrRVRkSEpCRUhJRklBWUxRWUNBZ0FGeUlRWUxBa0FnQmtHQWdZQUljUTBBSUFaQitCNXhSUTBBSUFNZ0JTQUVLQUpzSUFaQkEzWWlFa0h2QTNGcUxRQUFRUUowYWlJTUtBSUFJZ29vQWdBaUFXc2hBd0ovSUFFZ0FrRVFkazBFUUNBQ0lBRkJFSFJySVFJZ0EwR0FnQUp4QkVBZ0NpZ0NCQXdDQ3lBS0tBSUVJUTRnRENBS1FReEJDQ0FCSUFOTEloZ2JhaWdDQURZQ0FBTkFBa0FnQ0EwQUlBUW9BaEFpQ0VFQmFpRUtJQWd0QUFFaEFTQUlMUUFBUWY4QlJ3UkFJQVFnQ2pZQ0VFRUlJUWdnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUtOZ0lRSUFGQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXNnQ0VFQmF5RUlJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBT1JTQU9JQmdiREFFTElBb29BZ1FoRGlBTUlBcEJDRUVNSUFFZ0Ewc2lHQnRxS0FJQU5nSUFBMEFDUUNBSURRQWdCQ2dDRUNJSVFRRnFJUW9nQ0MwQUFTRURJQWd0QUFCQi93RkhCRUFnQkNBS05nSVFRUWdoQ0NBRFFRaDBJQUpxSVFJTUFRc2dBMEdQQVUwRVFDQUVJQW8yQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VJQ3lBSVFRRnJJUWdnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBRWhBeUFPSUE1RklCZ2JDd1IvSUFNZ0JTQUpLQUlFUVJSMlFRUnhJQWxCQkdzaURpZ0NBRUVXZGtFQmNTQUdRUTkyUVJCeElBWkJFM1pCd0FCeElCSkJxZ0Z4Y25KeWNpSVNRZUM1QVdvdEFBQkJBblJxSWd3b0FnQWlDaWdDQUNJQmF5RURJQkpCNExzQmFpMEFBQ0VZSUJFZ0VFRUNkR29nRkNBTkFuOGdBU0FDUVJCMlRRUkFJQUlnQVVFUWRHc2hBaUFEUVlDQUFuRUVRQ0FLS0FJRURBSUxJQW9vQWdRaEVpQU1JQXBCREVFSUlBRWdBMHNpR3h0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFvZ0NDMEFBU0VCSUFndEFBQkIvd0ZIQkVBZ0JDQUtOZ0lRUVFnaENDQUJRUWgwSUFKcUlRSU1BUXNnQVVHUEFVMEVRQ0FFSUFvMkFoQWdBVUVKZENBQ2FpRUNRUWNoQ0F3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSUN5QUlRUUZySVFnZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQkpGSUJJZ0d4c01BUXNnQ2lnQ0JDRVNJQXdnQ2tFSVFRd2dBU0FEU3lJYkcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaENpQUlMUUFCSVFNZ0NDMEFBRUgvQVVjRVFDQUVJQW8yQWhCQkNDRUlJQU5CQ0hRZ0Ftb2hBZ3dCQ3lBRFFZOEJUUVJBSUFRZ0NqWUNFQ0FEUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ0xJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElCSWdFa1VnR3hzTElCaHpJZ0ViTmdJQUlBNGdEaWdDQUVHQUFuSTJBZ0FnQ1NBSktBSUVRY0FBY2pZQ0JDQUdJQUZCRm5SeVFZQUJjZ1VnQmd0QmdJQ0FDSEloQmdzQ1FDQUdRWUNJZ01BQWNRMEFJQVpCd1BjQmNVVU5BQ0FESUFVZ0JDZ0NiQ0FHUVFaMkloSkI3d054YWkwQUFFRUNkR29pRENnQ0FDSUtLQUlBSWdGcklRTUNmeUFCSUFKQkVIWk5CRUFnQWlBQlFSQjBheUVDSUFOQmdJQUNjUVJBSUFvb0FnUU1BZ3NnQ2lnQ0JDRU9JQXdnQ2tFTVFRZ2dBU0FEU3lJWUcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaENpQUlMUUFCSVFFZ0NDMEFBRUgvQVVjRVFDQUVJQW8yQWhCQkNDRUlJQUZCQ0hRZ0Ftb2hBZ3dCQ3lBQlFZOEJUUVJBSUFRZ0NqWUNFQ0FCUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ0xJQWhCQVdzaENDQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnRGtVZ0RpQVlHd3dCQ3lBS0tBSUVJUTRnRENBS1FRaEJEQ0FCSUFOTEloZ2JhaWdDQURZQ0FBTkFBa0FnQ0EwQUlBUW9BaEFpQ0VFQmFpRUtJQWd0QUFFaEF5QUlMUUFBUWY4QlJ3UkFJQVFnQ2pZQ0VFRUlJUWdnQTBFSWRDQUNhaUVDREFFTElBTkJqd0ZOQkVBZ0JDQUtOZ0lRSUFOQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXNnQ0VFQmF5RUlJQUpCQVhRaEFpQUJRUUYwSWdGQmdJQUNTUTBBQ3lBQklRTWdEaUFPUlNBWUd3c0VmeUFESUFVZ0NTZ0NCRUVYZGtFRWNTQUpRUVJySWc0b0FnQkJHWFpCQVhFZ0JrRVNka0VRY1NBR1FSWjJRY0FBY1NBU1Fhb0JjWEp5Y25JaUVrSGd1UUZxTFFBQVFRSjBhaUlNS0FJQUlnb29BZ0FpQVdzaEF5QVNRZUM3QVdvdEFBQWhHQ0FSSUJWcUlCUWdEUUovSUFFZ0FrRVFkazBFUUNBQ0lBRkJFSFJySVFJZ0EwR0FnQUp4QkVBZ0NpZ0NCQXdDQ3lBS0tBSUVJUklnRENBS1FReEJDQ0FCSUFOTEloc2JhaWdDQURZQ0FBTkFBa0FnQ0EwQUlBUW9BaEFpQ0VFQmFpRUtJQWd0QUFFaEFTQUlMUUFBUWY4QlJ3UkFJQVFnQ2pZQ0VFRUlJUWdnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUtOZ0lRSUFGQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXNnQ0VFQmF5RUlJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBU1JTQVNJQnNiREFFTElBb29BZ1FoRWlBTUlBcEJDRUVNSUFFZ0Ewc2lHeHRxS0FJQU5nSUFBMEFDUUNBSURRQWdCQ2dDRUNJSVFRRnFJUW9nQ0MwQUFTRURJQWd0QUFCQi93RkhCRUFnQkNBS05nSVFRUWdoQ0NBRFFRaDBJQUpxSVFJTUFRc2dBMEdQQVUwRVFDQUVJQW8yQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VJQ3lBSVFRRnJJUWdnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBRWhBeUFTSUJKRklCc2JDeUFZY3lJQkd6WUNBQ0FPSUE0b0FnQkJnQkJ5TmdJQUlBa2dDU2dDQkVHQUJISTJBZ1FnQmlBQlFSbDBja0dBQ0hJRklBWUxRWUNBZ01BQWNpRUdDd0pBSUFaQmdNQ0FnQVJ4RFFBZ0JrR0F2QTl4UlEwQUlBTWdCU0FFS0FKc0lBWkJDWFlpRWtIdkEzRnFMUUFBUVFKMGFpSU1LQUlBSWdvb0FnQWlBV3NoQXdKL0lBRWdBa0VRZGswRVFDQUNJQUZCRUhScklRSWdBMEdBZ0FKeEJFQWdDaWdDQkF3Q0N5QUtLQUlFSVE0Z0RDQUtRUXhCQ0NBQklBTkxJaGdiYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVLSUFndEFBRWhBU0FJTFFBQVFmOEJSd1JBSUFRZ0NqWUNFRUVJSVFnZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FLTmdJUUlBRkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0FzZ0NFRUJheUVJSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QU9SU0FPSUJnYkRBRUxJQW9vQWdRaERpQU1JQXBCQ0VFTUlBRWdBMHNpR0J0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFvZ0NDMEFBU0VESUFndEFBQkIvd0ZIQkVBZ0JDQUtOZ0lRUVFnaENDQURRUWgwSUFKcUlRSU1BUXNnQTBHUEFVMEVRQ0FFSUFvMkFoQWdBMEVKZENBQ2FpRUNRUWNoQ0F3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSUN5QUlRUUZySVFnZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQUVoQXlBT0lBNUZJQmdiQ3dSL0lBTWdCU0FKS0FJRVFScDJRUVJ4SUFsQkJHc2lEaWdDQUVFY2RrRUJjU0FHUVJWMlFSQnhJQVpCR1haQndBQnhJQkpCcWdGeGNuSnljaUlTUWVDNUFXb3RBQUJCQW5ScUlnd29BZ0FpQ2lnQ0FDSUJheUVESUJKQjRMc0JhaTBBQUNFWUlCRWdFMm9nRkNBTkFuOGdBU0FDUVJCMlRRUkFJQUlnQVVFUWRHc2hBaUFEUVlDQUFuRUVRQ0FLS0FJRURBSUxJQW9vQWdRaEVpQU1JQXBCREVFSUlBRWdBMHNpR3h0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFvZ0NDMEFBU0VCSUFndEFBQkIvd0ZIQkVBZ0JDQUtOZ0lRUVFnaENDQUJRUWgwSUFKcUlRSU1BUXNnQVVHUEFVMEVRQ0FFSUFvMkFoQWdBVUVKZENBQ2FpRUNRUWNoQ0F3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSUN5QUlRUUZySVFnZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQkpGSUJJZ0d4c01BUXNnQ2lnQ0JDRVNJQXdnQ2tFSVFRd2dBU0FEU3lJYkcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaENpQUlMUUFCSVFNZ0NDMEFBRUgvQVVjRVFDQUVJQW8yQWhCQkNDRUlJQU5CQ0hRZ0Ftb2hBZ3dCQ3lBRFFZOEJUUVJBSUFRZ0NqWUNFQ0FEUVFsMElBSnFJUUpCQnlFSURBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRZ0xJQWhCQVdzaENDQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQVNFRElCSWdFa1VnR3hzTElCaHpJZ29iTmdJQUlBNGdEaWdDQUVHQWdBRnlOZ0lBSUFrZ0NTZ0NCRUdBSUhJMkFnUWdCQ2dDZkVFQ2RDQUphaUlCSUFFb0FnUkJCSEkyQWdRZ0FTQUJLQUlNUVFGeU5nSU1JQUVnQVNnQ0NDQUtRUkowY2tFQ2NqWUNDQ0FHSUFwQkhIUnlRWURBQUhJRklBWUxRWUNBZ0lBRWNpRUdDeUFKSUFZMkFnQUxJQWxCQkdvaEJpQVJRUVJxSVJFZ0MwRUJhaUlMSUJCSERRQUxJQWxCREdvaEJpQVJJQk5xSVJFZ0IwRUVhaUlISUFRb0FvQUJJZ0ZCZkhGSkRRQUxEQUVMUVFRZ0FVRjhjU0lHSUFaQkJFMGJRUUZySWdaQmZIRkJCR29oQnlBSklBWkJBWFJCZUhGcVFSUnFJUVlMSUFRZ0NEWUNDQ0FFSUFNMkFnUWdCQ0FDTmdJQUlBUWdERFlDYUNBUVJRMEFJQUVnQjAwTkFBTkFJQUVnQjBZaFUwRUFJUWdnQnlFQklGTkZCRUFEUUNBRUlBWWdFU0FJSUJCc1FRSjBhaUFOSUFnZ0JDZ0NmRUVDYWtFQUVGSWdDRUVCYWlJSUlBUW9Bb0FCSWdFZ0IydEpEUUFMQ3lBR1FRUnFJUVlnRVVFRWFpRVJJQmRCQVdvaUZ5QVFSdzBBQ3dzTUFnc0RRRUVBSVJjRFFDQUJJUWtnQmlJSEtBSUFJZ1lFUUFKQUlBWkJrSUNBQVhFTkFDQUdRZThEY1NJQlJRMEFJQU1nRUNBRUtBSnNJQUZxTFFBQVFRSjBhaUlNS0FJQUlnc29BZ0FpQVdzaEF3Si9JQUVnQWtFUWRrc0VRQ0FMS0FJRUlRb2dEQ0FMUVFoQkRDQUJJQU5MSWhRYmFpZ0NBRFlDQUFOQUFrQWdDQTBBSUFRb0FoQWlDRUVCYWlFTElBZ3RBQUVoQXlBSUxRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0F3Q0N5QUVJQXMyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBczJBaEJCQ0NFSUlBTkJDSFFnQW1vaEFnc2dDRUVCYXlFSUlBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFCSVFNZ0NpQUtSU0FVR3d3QkN5QUNJQUZCRUhScklRSWdBMEdBZ0FKeFJRUkFJQXNvQWdRaENpQU1JQXRCREVFSUlBRWdBMHNpRkJ0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFzZ0NDMEFBU0VCSUFndEFBQkIvd0ZHQkVBZ0FVR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VJREFJTElBUWdDellDRUNBQlFRbDBJQUpxSVFKQkJ5RUlEQUVMSUFRZ0N6WUNFRUVJSVFnZ0FVRUlkQ0FDYWlFQ0N5QUlRUUZySVFnZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQXBGSUFvZ0ZCc01BUXNnQ3lnQ0JBc0VmeUFESUJBZ0J5Z0NCRUVSZGtFRWNTQUhRUVJySWdvb0FnQkJFM1pCQVhFZ0JrRU9ka0VRY1NBR1FSQjJRY0FBY1NBR1Fhb0JjWEp5Y25JaUZFSGd1UUZxTFFBQVFRSjBhaUlNS0FJQUlnc29BZ0FpQVdzaEF5QVVRZUM3QVdvdEFBQWhFeUFKSUFVZ0VRSi9JQUVnQWtFUWRrc0VRQ0FMS0FJRUlSUWdEQ0FMUVFoQkRDQUJJQU5MSWc0YmFpZ0NBRFlDQUFOQUFrQWdDQTBBSUFRb0FoQWlDRUVCYWlFTElBZ3RBQUVoQXlBSUxRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQ0F3Q0N5QUVJQXMyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hDQXdCQ3lBRUlBczJBaEJCQ0NFSUlBTkJDSFFnQW1vaEFnc2dDRUVCYXlFSUlBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFCSVFNZ0ZDQVVSU0FPR3d3QkN5QUNJQUZCRUhScklRSWdBMEdBZ0FKeFJRUkFJQXNvQWdRaEZDQU1JQXRCREVFSUlBRWdBMHNpRGh0cUtBSUFOZ0lBQTBBQ1FDQUlEUUFnQkNnQ0VDSUlRUUZxSVFzZ0NDMEFBU0VCSUFndEFBQkIvd0ZHQkVBZ0FVR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VJREFJTElBUWdDellDRUNBQlFRbDBJQUpxSVFKQkJ5RUlEQUVMSUFRZ0N6WUNFRUVJSVFnZ0FVRUlkQ0FDYWlFQ0N5QUlRUUZySVFnZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQlJGSUJRZ0Roc01BUXNnQ3lnQ0JBc2dFM01pQVJzMkFnQWdDaUFLS0FJQVFTQnlOZ0lBSUFjZ0J5Z0NCRUVJY2pZQ0JDQUdJQUZCRTNSeVFSQnlCU0FHQzBHQWdJQUJjaUVHQ3dKQUlBWkJnSUdBQ0hFTkFDQUdRZmdlY1VVTkFDQURJQkFnQkNnQ2JDQUdRUU4ySWhSQjd3TnhhaTBBQUVFQ2RHb2lEQ2dDQUNJTEtBSUFJZ0ZySVFNQ2Z5QUJJQUpCRUhaTEJFQWdDeWdDQkNFS0lBd2dDMEVJUVF3Z0FTQURTeUlURzJvb0FnQTJBZ0FEUUFKQUlBZ05BQ0FFS0FJUUlnaEJBV29oQ3lBSUxRQUJJUU1nQ0MwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUWdNQWdzZ0JDQUxOZ0lRSUFOQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBTE5nSVFRUWdoQ0NBRFFRaDBJQUpxSVFJTElBaEJBV3NoQ0NBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dBU0VESUFvZ0NrVWdFeHNNQVFzZ0FpQUJRUkIwYXlFQ0lBTkJnSUFDY1VVRVFDQUxLQUlFSVFvZ0RDQUxRUXhCQ0NBQklBTkxJaE1iYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVMSUFndEFBRWhBU0FJTFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXdDQ3lBRUlBczJBaEFnQVVFSmRDQUNhaUVDUVFjaENBd0JDeUFFSUFzMkFoQkJDQ0VJSUFGQkNIUWdBbW9oQWdzZ0NFRUJheUVJSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QUtSU0FLSUJNYkRBRUxJQXNvQWdRTEJIOGdBeUFRSUFjb0FnUkJGSFpCQkhFZ0IwRUVheUlLS0FJQVFSWjJRUUZ4SUFaQkQzWkJFSEVnQmtFVGRrSEFBSEVnRkVHcUFYRnljbkp5SWhSQjRMa0JhaTBBQUVFQ2RHb2lEQ2dDQUNJTEtBSUFJZ0ZySVFNZ0ZFSGd1d0ZxTFFBQUlSTWdDU0FGSUJFQ2Z5QUJJQUpCRUhaTEJFQWdDeWdDQkNFVUlBd2dDMEVJUVF3Z0FTQURTeUlPRzJvb0FnQTJBZ0FEUUFKQUlBZ05BQ0FFS0FJUUlnaEJBV29oQ3lBSUxRQUJJUU1nQ0MwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUWdNQWdzZ0JDQUxOZ0lRSUFOQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBTE5nSVFRUWdoQ0NBRFFRaDBJQUpxSVFJTElBaEJBV3NoQ0NBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dBU0VESUJRZ0ZFVWdEaHNNQVFzZ0FpQUJRUkIwYXlFQ0lBTkJnSUFDY1VVRVFDQUxLQUlFSVJRZ0RDQUxRUXhCQ0NBQklBTkxJZzRiYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVMSUFndEFBRWhBU0FJTFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXdDQ3lBRUlBczJBaEFnQVVFSmRDQUNhaUVDUVFjaENBd0JDeUFFSUFzMkFoQkJDQ0VJSUFGQkNIUWdBbW9oQWdzZ0NFRUJheUVJSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QVVSU0FVSUE0YkRBRUxJQXNvQWdRTElCTnpJZ0ViTmdLQUFpQUtJQW9vQWdCQmdBSnlOZ0lBSUFjZ0J5Z0NCRUhBQUhJMkFnUWdCaUFCUVJaMGNrR0FBWElGSUFZTFFZQ0FnQWh5SVFZTEFrQWdCa0dBaUlEQUFIRU5BQ0FHUWNEM0FYRkZEUUFnQXlBUUlBUW9BbXdnQmtFR2RpSVVRZThEY1dvdEFBQkJBblJxSWd3b0FnQWlDeWdDQUNJQmF5RURBbjhnQVNBQ1FSQjJTd1JBSUFzb0FnUWhDaUFNSUF0QkNFRU1JQUVnQTBzaUV4dHFLQUlBTmdJQUEwQUNRQ0FJRFFBZ0JDZ0NFQ0lJUVFGcUlRc2dDQzBBQVNFRElBZ3RBQUJCL3dGR0JFQWdBMEdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSURBSUxJQVFnQ3pZQ0VDQURRUWwwSUFKcUlRSkJCeUVJREFFTElBUWdDellDRUVFSUlRZ2dBMEVJZENBQ2FpRUNDeUFJUVFGcklRZ2dBa0VCZENFQ0lBRkJBWFFpQVVHQWdBSkpEUUFMSUFFaEF5QUtJQXBGSUJNYkRBRUxJQUlnQVVFUWRHc2hBaUFEUVlDQUFuRkZCRUFnQ3lnQ0JDRUtJQXdnQzBFTVFRZ2dBU0FEU3lJVEcyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaEN5QUlMUUFCSVFFZ0NDMEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFnTUFnc2dCQ0FMTmdJUUlBRkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUxOZ0lRUVFnaENDQUJRUWgwSUFKcUlRSUxJQWhCQVdzaENDQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnQ2tVZ0NpQVRHd3dCQ3lBTEtBSUVDd1IvSUFNZ0VDQUhLQUlFUVJkMlFRUnhJQWRCQkdzaUNpZ0NBRUVaZGtFQmNTQUdRUkoyUVJCeElBWkJGblpCd0FCeElCUkJxZ0Z4Y25KeWNpSVVRZUM1QVdvdEFBQkJBblJxSWd3b0FnQWlDeWdDQUNJQmF5RURJQlJCNExzQmFpMEFBQ0VUSUFrZ0JTQVJBbjhnQVNBQ1FSQjJTd1JBSUFzb0FnUWhGQ0FNSUF0QkNFRU1JQUVnQTBzaURodHFLQUlBTmdJQUEwQUNRQ0FJRFFBZ0JDZ0NFQ0lJUVFGcUlRc2dDQzBBQVNFRElBZ3RBQUJCL3dGR0JFQWdBMEdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFSURBSUxJQVFnQ3pZQ0VDQURRUWwwSUFKcUlRSkJCeUVJREFFTElBUWdDellDRUVFSUlRZ2dBMEVJZENBQ2FpRUNDeUFJUVFGcklRZ2dBa0VCZENFQ0lBRkJBWFFpQVVHQWdBSkpEUUFMSUFFaEF5QVVJQlJGSUE0YkRBRUxJQUlnQVVFUWRHc2hBaUFEUVlDQUFuRkZCRUFnQ3lnQ0JDRVVJQXdnQzBFTVFRZ2dBU0FEU3lJT0cyb29BZ0EyQWdBRFFBSkFJQWdOQUNBRUtBSVFJZ2hCQVdvaEN5QUlMUUFCSVFFZ0NDMEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFnTUFnc2dCQ0FMTmdJUUlBRkJDWFFnQW1vaEFrRUhJUWdNQVFzZ0JDQUxOZ0lRUVFnaENDQUJRUWgwSUFKcUlRSUxJQWhCQVdzaENDQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnRkVVZ0ZDQU9Hd3dCQ3lBTEtBSUVDeUFUY3lJQkd6WUNnQVFnQ2lBS0tBSUFRWUFRY2pZQ0FDQUhJQWNvQWdSQmdBUnlOZ0lFSUFZZ0FVRVpkSEpCZ0FoeUJTQUdDMEdBZ0lEQUFISWhCZ3NDUUNBR1FZREFnSUFFY1EwQUlBWkJnTHdQY1VVTkFDQURJQkFnQkNnQ2JDQUdRUWwySWhSQjd3TnhhaTBBQUVFQ2RHb2lEQ2dDQUNJTEtBSUFJZ0ZySVFNQ2Z5QUJJQUpCRUhaTEJFQWdDeWdDQkNFS0lBd2dDMEVJUVF3Z0FTQURTeUlURzJvb0FnQTJBZ0FEUUFKQUlBZ05BQ0FFS0FJUUlnaEJBV29oQ3lBSUxRQUJJUU1nQ0MwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUWdNQWdzZ0JDQUxOZ0lRSUFOQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBTE5nSVFRUWdoQ0NBRFFRaDBJQUpxSVFJTElBaEJBV3NoQ0NBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dBU0VESUFvZ0NrVWdFeHNNQVFzZ0FpQUJRUkIwYXlFQ0lBTkJnSUFDY1VVRVFDQUxLQUlFSVFvZ0RDQUxRUXhCQ0NBQklBTkxJaE1iYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVMSUFndEFBRWhBU0FJTFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXdDQ3lBRUlBczJBaEFnQVVFSmRDQUNhaUVDUVFjaENBd0JDeUFFSUFzMkFoQkJDQ0VJSUFGQkNIUWdBbW9oQWdzZ0NFRUJheUVJSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QUtSU0FLSUJNYkRBRUxJQXNvQWdRTEJIOGdBeUFRSUFjb0FnUkJHblpCQkhFZ0IwRUVheUlLS0FJQVFSeDJRUUZ4SUFaQkZYWkJFSEVnQmtFWmRrSEFBSEVnRkVHcUFYRnljbkp5SWhSQjRMa0JhaTBBQUVFQ2RHb2lEQ2dDQUNJTEtBSUFJZ0ZySVFNZ0ZFSGd1d0ZxTFFBQUlSTWdDU0FGSUJFQ2Z5QUJJQUpCRUhaTEJFQWdDeWdDQkNFVUlBd2dDMEVJUVF3Z0FTQURTeUlPRzJvb0FnQTJBZ0FEUUFKQUlBZ05BQ0FFS0FJUUlnaEJBV29oQ3lBSUxRQUJJUU1nQ0MwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUWdNQWdzZ0JDQUxOZ0lRSUFOQkNYUWdBbW9oQWtFSElRZ01BUXNnQkNBTE5nSVFRUWdoQ0NBRFFRaDBJQUpxSVFJTElBaEJBV3NoQ0NBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dBU0VESUJRZ0ZFVWdEaHNNQVFzZ0FpQUJRUkIwYXlFQ0lBTkJnSUFDY1VVRVFDQUxLQUlFSVJRZ0RDQUxRUXhCQ0NBQklBTkxJZzRiYWlnQ0FEWUNBQU5BQWtBZ0NBMEFJQVFvQWhBaUNFRUJhaUVMSUFndEFBRWhBU0FJTFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hDQXdDQ3lBRUlBczJBaEFnQVVFSmRDQUNhaUVDUVFjaENBd0JDeUFFSUFzMkFoQkJDQ0VJSUFGQkNIUWdBbW9oQWdzZ0NFRUJheUVJSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QVVSU0FVSUE0YkRBRUxJQXNvQWdRTElCTnpJZ0ViTmdLQUJpQUtJQW9vQWdCQmdJQUJjallDQUNBSElBY29BZ1JCZ0NCeU5nSUVJQWNnQnlnQ2hBSkJCSEkyQW9RQ0lBY2dCeWdDakFKQkFYSTJBb3dDSUFjZ0J5Z0NpQUlnQVVFU2RISkJBbkkyQW9nQ0lBWWdBVUVjZEhKQmdNQUFjZ1VnQmd0QmdJQ0FnQVJ5SVFZTElBY2dCallDQUFzZ0IwRUVhaUVHSUFsQkJHb2hBU0FYUVFGcUloZEJ3QUJIRFFBTElBZEJER29oQmlBSlFZUUdhaUVCSUExQlBFa2hWQ0FOUVFScUlRMGdWQTBBQ3dzZ0JDQUlOZ0lJSUFRZ0F6WUNCQ0FFSUFJMkFnQWdCQ0FNTmdKb0N3d0NDeUFpQkVCQkFTQVpkRUVCZGlFSklBUW9BbndpRVVFQ2RDSU1JQVFvQW5ocVFReHFJUUVnQkNnQ2RDRUdRUUFoRFNBRUtBS0FBU0lEUVFSUEJFQWdFVVVOQkNBUlFRTnNJUVVnRVVFQmRDRUxRUUFnQ1dzaEFnTkFJQXRCQW5RaENrRUFJUU1EUUFKQUlBRWlCeWdDQUNJQlJRMEFJQUZCa0lDQUFYRkJFRVlFUUNBRUtBSUFJUUVDUUNBRUtBSUlJaEFOQUNBQlFmOEJSaUVRSUFRb0FoQWlDQzBBQUNFQkFrQWdFRVVFUUNBRUlBRTJBZ0FnQkNBSVFRRnFOZ0lRREFFTElBRkJqd0ZOQkVBZ0JDQUJOZ0lBSUFRZ0NFRUJhallDRUVFSElSQU1BZ3RCL3dFaEFTQUVRZjhCTmdJQUMwRUlJUkFMSUFRZ0VFRUJheUlJTmdJSUlBWWdBaUFKSUFFZ0NIWkJBWEVnQmlnQ0FDSUJRUjkyUmhzZ0FXbzJBZ0FnQnlBSEtBSUFRWUNBd0FCeUlnRTJBZ0FMSUFGQmdJR0FDSEZCZ0FGR0JFQWdCQ2dDQUNFQkFrQWdCQ2dDQ0NJUURRQWdBVUgvQVVZaEVDQUVLQUlRSWdndEFBQWhBUUpBSUJCRkJFQWdCQ0FCTmdJQUlBUWdDRUVCYWpZQ0VBd0JDeUFCUVk4QlRRUkFJQVFnQVRZQ0FDQUVJQWhCQVdvMkFoQkJCeUVRREFJTFFmOEJJUUVnQkVIL0FUWUNBQXRCQ0NFUUN5QUVJQkJCQVdzaUNEWUNDQ0FHSUF4cUloQWdBaUFKSUFFZ0NIWkJBWEVnRUNnQ0FDSUJRUjkyUmhzZ0FXbzJBZ0FnQnlBSEtBSUFRWUNBZ0FSeUlnRTJBZ0FMSUFGQmdJaUF3QUJ4UVlBSVJnUkFJQVFvQWdBaEFRSkFJQVFvQWdnaUVBMEFJQUZCL3dGR0lSQWdCQ2dDRUNJSUxRQUFJUUVDUUNBUVJRUkFJQVFnQVRZQ0FDQUVJQWhCQVdvMkFoQU1BUXNnQVVHUEFVMEVRQ0FFSUFFMkFnQWdCQ0FJUVFGcU5nSVFRUWNoRUF3Q0MwSC9BU0VCSUFSQi93RTJBZ0FMUVFnaEVBc2dCQ0FRUVFGcklnZzJBZ2dnQmlBS2FpSVFJQUlnQ1NBQklBaDJRUUZ4SUJBb0FnQWlBVUVmZGtZYklBRnFOZ0lBSUFjZ0J5Z0NBRUdBZ0lBZ2NpSUJOZ0lBQ3lBQlFZREFnSUFFY1VHQXdBQkhEUUFnQmlBRlFRSjBhaUVRSUFRb0FnQWhBUUpBSUFRb0FnZ2lDQTBBSUFGQi93RkdJUlFnQkNnQ0VDSUlMUUFBSVFFQ1FDQVVSUVJBSUFRZ0FUWUNBQ0FFSUFoQkFXbzJBaEFNQVFzZ0FVR1BBVTBFUUNBRUlBRTJBZ0FnQkNBSVFRRnFOZ0lRUVFjaENBd0NDMEgvQVNFQklBUkIvd0UyQWdBTFFRZ2hDQXNnQkNBSVFRRnJJZ2cyQWdnZ0VDQUNJQWtnQVNBSWRrRUJjU0FRS0FJQUlnRkJIM1pHR3lBQmFqWUNBQ0FISUFjb0FnQkJnSUNBZ0FKeU5nSUFDeUFHUVFScUlRWWdCMEVFYWlFQklBTkJBV29pQXlBUlJ3MEFDeUFIUVF4cUlRRWdCaUFGUVFKMGFpRUdJQTFCQkdvaURTQUVLQUtBQVNJRFFYeHhTUTBBQ3dzZ0F5QU5UUTBDSUJGRkRRSkJBQ0VUUVFBZ0NXc2hCU0FESVFjRFFBSkFJQWNnRFVZRVFDQU5JUWNNQVFzZ0FTZ0NBQ0VRUVFBaEFnTkFRWkNBZ0FFZ0FrRURiQ0lIZENBUWNVRVFJQWQwUmdSQUlBWWdBaUFSYkVFQ2RHb2hFQ0FFS0FJQUlRTUNRQ0FFS0FJSUlnZ05BQ0FEUWY4QlJ5RU1JQVFvQWhBaUNDMEFBQ0VEQWtBZ0RFVUVRQ0FEUVpBQlR3UkFRZjhCSVFNZ0JFSC9BVFlDQUF3Q0N5QUVJQU0yQWdBZ0JDQUlRUUZxTmdJUVFRY2hDQXdDQ3lBRUlBTTJBZ0FnQkNBSVFRRnFOZ0lRQzBFSUlRZ0xJQVFnQ0VFQmF5SUlOZ0lJSUJBZ0JTQUpJQU1nQ0haQkFYRWdFQ2dDQUNJRFFSOTJSaHNnQTJvMkFnQWdBU0FCS0FJQVFZQ0F3QUFnQjNSeUloQTJBZ0FnQkNnQ2dBRWhBd3NnQXlFSElBSkJBV29pQWlBRElBMXJTUTBBQ3dzZ0JrRUVhaUVHSUFGQkJHb2hBU0FUUVFGcUloTWdFVWNOQUFzTUFnc2dCQ2dDZUNFSUlBUW9BblFoQnlBRUtBS0FBU0VEQWtBZ0JDZ0NmQ0lNUWNBQVJ3MEFJQU5Cd0FCSERRQWdDRUdNQW1vaEEwRUFJUk5CQUVFQklCbDBRUUYySWdWcklRd2dCQ2dDQ0NFQ0lBUW9BZ1FoQmlBRUtBSUFJUUVnQkNnQ2FDRU5BMEJCQUNFSUEwQWdCeUVKSUFNaUVDZ0NBQ0lIQkVBZ0F5RlZJQWRCa0lDQUFYRkJFRVlFUUNBR0lBOUJFRUVQUVE0Z0IwSHZBM0ViSUFkQmdJREFBSEViUVFKMGFpSU5LQUlBSWhFb0FnQWlBMnNoQmdKL0lBTWdBVUVRZGtzRVFDQVJLQUlFSVFzZ0RTQVJRUWhCRENBRElBWkxJZ29iYWlnQ0FEWUNBQU5BQWtBZ0FnMEFJQVFvQWhBaUFrRUJhaUVSSUFJdEFBRWhCaUFDTFFBQVFmOEJSZ1JBSUFaQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBRkJnUDREYWlFQlFRZ2hBZ3dDQ3lBRUlCRTJBaEFnQmtFSmRDQUJhaUVCUVFjaEFnd0JDeUFFSUJFMkFoQkJDQ0VDSUFaQkNIUWdBV29oQVFzZ0FrRUJheUVDSUFGQkFYUWhBU0FEUVFGMElnTkJnSUFDU1EwQUN5QURJUVlnQ3lBTFJTQUtHd3dCQ3lBQklBTkJFSFJySVFFZ0JrR0FnQUp4UlFSQUlCRW9BZ1FoQ3lBTklCRkJERUVJSUFNZ0Jrc2lDaHRxS0FJQU5nSUFBMEFDUUNBQ0RRQWdCQ2dDRUNJQ1FRRnFJUkVnQWkwQUFTRURJQUl0QUFCQi93RkdCRUFnQTBHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FVR0EvZ05xSVFGQkNDRUNEQUlMSUFRZ0VUWUNFQ0FEUVFsMElBRnFJUUZCQnlFQ0RBRUxJQVFnRVRZQ0VFRUlJUUlnQTBFSWRDQUJhaUVCQ3lBQ1FRRnJJUUlnQVVFQmRDRUJJQVpCQVhRaUJrR0FnQUpKRFFBTElBdEZJQXNnQ2hzTUFRc2dFU2dDQkFzaEF5QUpJQXdnQlNBRElBa29BZ0FpRVVFZmRrWWJJQkZxTmdJQUlBZEJnSURBQUhJaEJ3c2dCMEdBZ1lBSWNVR0FBVVlFUUNBR0lBOUJFRUVQUVE0Z0IwSDRIbkViSUFkQmdJQ0FCSEViUVFKMGFpSU5LQUlBSWhFb0FnQWlBMnNoQmdKL0lBTWdBVUVRZGtzRVFDQVJLQUlFSVFzZ0RTQVJRUWhCRENBRElBWkxJZ29iYWlnQ0FEWUNBQU5BQWtBZ0FnMEFJQVFvQWhBaUFrRUJhaUVSSUFJdEFBRWhCaUFDTFFBQVFmOEJSZ1JBSUFaQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBRkJnUDREYWlFQlFRZ2hBZ3dDQ3lBRUlCRTJBaEFnQmtFSmRDQUJhaUVCUVFjaEFnd0JDeUFFSUJFMkFoQkJDQ0VDSUFaQkNIUWdBV29oQVFzZ0FrRUJheUVDSUFGQkFYUWhBU0FEUVFGMElnTkJnSUFDU1EwQUN5QURJUVlnQ3lBTFJTQUtHd3dCQ3lBQklBTkJFSFJySVFFZ0JrR0FnQUp4UlFSQUlCRW9BZ1FoQ3lBTklCRkJERUVJSUFNZ0Jrc2lDaHRxS0FJQU5nSUFBMEFDUUNBQ0RRQWdCQ2dDRUNJQ1FRRnFJUkVnQWkwQUFTRURJQUl0QUFCQi93RkdCRUFnQTBHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FVR0EvZ05xSVFGQkNDRUNEQUlMSUFRZ0VUWUNFQ0FEUVFsMElBRnFJUUZCQnlFQ0RBRUxJQVFnRVRZQ0VFRUlJUUlnQTBFSWRDQUJhaUVCQ3lBQ1FRRnJJUUlnQVVFQmRDRUJJQVpCQVhRaUJrR0FnQUpKRFFBTElBdEZJQXNnQ2hzTUFRc2dFU2dDQkFzaEF5QUpJQXdnQlNBRElBa29Bb0FDSWhGQkgzWkdHeUFSYWpZQ2dBSWdCMEdBZ0lBRWNpRUhDeUFIUVlDSWdNQUFjVUdBQ0VZRVFDQUdJQTlCRUVFUFFRNGdCMEhBOXdGeEd5QUhRWUNBZ0NCeEcwRUNkR29pRFNnQ0FDSVJLQUlBSWdOcklRWUNmeUFESUFGQkVIWkxCRUFnRVNnQ0JDRUxJQTBnRVVFSVFRd2dBeUFHU3lJS0cyb29BZ0EyQWdBRFFBSkFJQUlOQUNBRUtBSVFJZ0pCQVdvaEVTQUNMUUFCSVFZZ0FpMEFBRUgvQVVZRVFDQUdRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FCUVlEK0Eyb2hBVUVJSVFJTUFnc2dCQ0FSTmdJUUlBWkJDWFFnQVdvaEFVRUhJUUlNQVFzZ0JDQVJOZ0lRUVFnaEFpQUdRUWgwSUFGcUlRRUxJQUpCQVdzaEFpQUJRUUYwSVFFZ0EwRUJkQ0lEUVlDQUFra05BQXNnQXlFR0lBc2dDMFVnQ2hzTUFRc2dBU0FEUVJCMGF5RUJJQVpCZ0lBQ2NVVUVRQ0FSS0FJRUlRc2dEU0FSUVF4QkNDQURJQVpMSWdvYmFpZ0NBRFlDQUFOQUFrQWdBZzBBSUFRb0FoQWlBa0VCYWlFUklBSXRBQUVoQXlBQ0xRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUZCZ1A0RGFpRUJRUWdoQWd3Q0N5QUVJQkUyQWhBZ0EwRUpkQ0FCYWlFQlFRY2hBZ3dCQ3lBRUlCRTJBaEJCQ0NFQ0lBTkJDSFFnQVdvaEFRc2dBa0VCYXlFQ0lBRkJBWFFoQVNBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFMUlNBTElBb2JEQUVMSUJFb0FnUUxJUU1nQ1NBTUlBVWdBeUFKS0FLQUJDSVJRUjkyUmhzZ0VXbzJBb0FFSUFkQmdJQ0FJSEloQndzZ1ZTQUhRWURBZ0lBRWNVR0F3QUJHQkg4Z0JpQVBRUkJCRDBFT0lBZEJnTHdQY1JzZ0IwR0FnSUNBQW5FYlFRSjBhaUlOS0FJQUloRW9BZ0FpQTJzaEJnSi9JQU1nQVVFUWRrc0VRQ0FSS0FJRUlRc2dEU0FSUVFoQkRDQURJQVpMSWdvYmFpZ0NBRFlDQUFOQUFrQWdBZzBBSUFRb0FoQWlBa0VCYWlFUklBSXRBQUVoQmlBQ0xRQUFRZjhCUmdSQUlBWkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUZCZ1A0RGFpRUJRUWdoQWd3Q0N5QUVJQkUyQWhBZ0JrRUpkQ0FCYWlFQlFRY2hBZ3dCQ3lBRUlCRTJBaEJCQ0NFQ0lBWkJDSFFnQVdvaEFRc2dBa0VCYXlFQ0lBRkJBWFFoQVNBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFESVFZZ0N5QUxSU0FLR3d3QkN5QUJJQU5CRUhScklRRWdCa0dBZ0FKeFJRUkFJQkVvQWdRaEN5QU5JQkZCREVFSUlBTWdCa3NpQ2h0cUtBSUFOZ0lBQTBBQ1FDQUNEUUFnQkNnQ0VDSUNRUUZxSVJFZ0FpMEFBU0VESUFJdEFBQkIvd0ZHQkVBZ0EwR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBVUdBL2dOcUlRRkJDQ0VDREFJTElBUWdFVFlDRUNBRFFRbDBJQUZxSVFGQkJ5RUNEQUVMSUFRZ0VUWUNFRUVJSVFJZ0EwRUlkQ0FCYWlFQkN5QUNRUUZySVFJZ0FVRUJkQ0VCSUFaQkFYUWlCa0dBZ0FKSkRRQUxJQXRGSUFzZ0Noc01BUXNnRVNnQ0JBc2hBeUFKSUF3Z0JTQURJQWtvQW9BR0loRkJIM1pHR3lBUmFqWUNnQVlnQjBHQWdJQ0FBbklGSUFjTE5nSUFDeUFRUVFScUlRTWdDVUVFYWlFSElBaEJBV29pQ0VIQUFFY05BQXNnRUVFTWFpRURJQWxCaEFacUlRY2dFMEU4U1NGV0lCTkJCR29oRXlCV0RRQUxJQVFnQWpZQ0NDQUVJQVkyQWdRZ0JDQUJOZ0lBSUFRZ0RUWUNhQXdDQzBFQklCbDBRUUYySVFzZ0NDQU1RUUowSWc1cVFReHFJUWtnQkNnQ0NDRUNJQVFvQWdRaEJpQUVLQUlBSVFFZ0JDZ0NhQ0VOUVFBaEVRSkFJQU5CQkVrTkFDQU1CRUFnREVFRGJDRVVJQXhCQVhRaEYwRUFJQXRySVFvRFFDQVhRUUowSVJKQkFDRUlBMEFnQ1NJRktBSUFJaEFFUUNBUVFaQ0FnQUZ4UVJCR0JFQWdCaUFQUVJCQkQwRU9JQkJCN3dOeEd5QVFRWUNBd0FCeEcwRUNkR29pRFNnQ0FDSUpLQUlBSWdOcklRWUNmeUFESUFGQkVIWk5CRUFnQVNBRFFSQjBheUVCSUFaQmdJQUNjUVJBSUFrb0FnUU1BZ3NnQ1NnQ0JDRVRJQTBnQ1VFTVFRZ2dBeUFHU3lJVkcyb29BZ0EyQWdBRFFBSkFJQUlOQUNBRUtBSVFJZ2xCQVdvaEFpQUpMUUFCSVFNZ0NTMEFBRUgvQVVjRVFDQUVJQUkyQWhCQkNDRUNJQU5CQ0hRZ0FXb2hBUXdCQ3lBRFFZOEJUUVJBSUFRZ0FqWUNFQ0FEUVFsMElBRnFJUUZCQnlFQ0RBRUxJQVFnQkNnQ0RFRUJhallDRENBQlFZRCtBMm9oQVVFSUlRSUxJQUpCQVdzaEFpQUJRUUYwSVFFZ0JrRUJkQ0lHUVlDQUFra05BQXNnRTBVZ0V5QVZHd3dCQ3lBSktBSUVJUk1nRFNBSlFRaEJEQ0FESUFaTEloVWJhaWdDQURZQ0FBTkFBa0FnQWcwQUlBUW9BaEFpQ1VFQmFpRUNJQWt0QUFFaEJpQUpMUUFBUWY4QlJ3UkFJQVFnQWpZQ0VFRUlJUUlnQmtFSWRDQUJhaUVCREFFTElBWkJqd0ZOQkVBZ0JDQUNOZ0lRSUFaQkNYUWdBV29oQVVFSElRSU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBRkJnUDREYWlFQlFRZ2hBZ3NnQWtFQmF5RUNJQUZCQVhRaEFTQURRUUYwSWdOQmdJQUNTUTBBQ3lBRElRWWdFeUFUUlNBVkd3c2hBeUFISUFvZ0N5QURJQWNvQWdBaUNVRWZka1liSUFscU5nSUFJQkJCZ0lEQUFISWhFQXNnRUVHQWdZQUljVUdBQVVZRVFDQUdJQTlCRUVFUFFRNGdFRUg0SG5FYklCQkJnSUNBQkhFYlFRSjBhaUlOS0FJQUlna29BZ0FpQTJzaEJnSi9JQU1nQVVFUWRrMEVRQ0FCSUFOQkVIUnJJUUVnQmtHQWdBSnhCRUFnQ1NnQ0JBd0NDeUFKS0FJRUlSTWdEU0FKUVF4QkNDQURJQVpMSWhVYmFpZ0NBRFlDQUFOQUFrQWdBZzBBSUFRb0FoQWlDVUVCYWlFQ0lBa3RBQUVoQXlBSkxRQUFRZjhCUndSQUlBUWdBallDRUVFSUlRSWdBMEVJZENBQmFpRUJEQUVMSUFOQmp3Rk5CRUFnQkNBQ05nSVFJQU5CQ1hRZ0FXb2hBVUVISVFJTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFGQmdQNERhaUVCUVFnaEFnc2dBa0VCYXlFQ0lBRkJBWFFoQVNBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFUUlNBVElCVWJEQUVMSUFrb0FnUWhFeUFOSUFsQkNFRU1JQU1nQmtzaUZSdHFLQUlBTmdJQUEwQUNRQ0FDRFFBZ0JDZ0NFQ0lKUVFGcUlRSWdDUzBBQVNFR0lBa3RBQUJCL3dGSEJFQWdCQ0FDTmdJUVFRZ2hBaUFHUVFoMElBRnFJUUVNQVFzZ0JrR1BBVTBFUUNBRUlBSTJBaEFnQmtFSmRDQUJhaUVCUVFjaEFnd0JDeUFFSUFRb0FneEJBV28yQWd3Z0FVR0EvZ05xSVFGQkNDRUNDeUFDUVFGcklRSWdBVUVCZENFQklBTkJBWFFpQTBHQWdBSkpEUUFMSUFNaEJpQVRJQk5GSUJVYkN5RURJQWNnRG1vaUNTQUtJQXNnQXlBSktBSUFJZ2xCSDNaR0d5QUphallDQUNBUVFZQ0FnQVJ5SVJBTElCQkJnSWlBd0FCeFFZQUlSZ1JBSUFZZ0QwRVFRUTlCRGlBUVFjRDNBWEViSUJCQmdJQ0FJSEViUVFKMGFpSU5LQUlBSWdrb0FnQWlBMnNoQmdKL0lBTWdBVUVRZGswRVFDQUJJQU5CRUhScklRRWdCa0dBZ0FKeEJFQWdDU2dDQkF3Q0N5QUpLQUlFSVJNZ0RTQUpRUXhCQ0NBRElBWkxJaFViYWlnQ0FEWUNBQU5BQWtBZ0FnMEFJQVFvQWhBaUNVRUJhaUVDSUFrdEFBRWhBeUFKTFFBQVFmOEJSd1JBSUFRZ0FqWUNFRUVJSVFJZ0EwRUlkQ0FCYWlFQkRBRUxJQU5CandGTkJFQWdCQ0FDTmdJUUlBTkJDWFFnQVdvaEFVRUhJUUlNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUZCZ1A0RGFpRUJRUWdoQWdzZ0FrRUJheUVDSUFGQkFYUWhBU0FHUVFGMElnWkJnSUFDU1EwQUN5QVRSU0FUSUJVYkRBRUxJQWtvQWdRaEV5QU5JQWxCQ0VFTUlBTWdCa3NpRlJ0cUtBSUFOZ0lBQTBBQ1FDQUNEUUFnQkNnQ0VDSUpRUUZxSVFJZ0NTMEFBU0VHSUFrdEFBQkIvd0ZIQkVBZ0JDQUNOZ0lRUVFnaEFpQUdRUWgwSUFGcUlRRU1BUXNnQmtHUEFVMEVRQ0FFSUFJMkFoQWdCa0VKZENBQmFpRUJRUWNoQWd3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQVVHQS9nTnFJUUZCQ0NFQ0N5QUNRUUZySVFJZ0FVRUJkQ0VCSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQU1oQmlBVElCTkZJQlViQ3lFRElBY2dFbW9pQ1NBS0lBc2dBeUFKS0FJQUlnbEJIM1pHR3lBSmFqWUNBQ0FRUVlDQWdDQnlJUkFMSUFVZ0VFR0F3SUNBQkhGQmdNQUFSZ1IvSUFZZ0QwRVFRUTlCRGlBUVFZQzhEM0ViSUJCQmdJQ0FnQUp4RzBFQ2RHb2lEU2dDQUNJSktBSUFJZ05ySVFZQ2Z5QURJQUZCRUhaTkJFQWdBU0FEUVJCMGF5RUJJQVpCZ0lBQ2NRUkFJQWtvQWdRTUFnc2dDU2dDQkNFVElBMGdDVUVNUVFnZ0F5QUdTeUlWRzJvb0FnQTJBZ0FEUUFKQUlBSU5BQ0FFS0FJUUlnbEJBV29oQWlBSkxRQUJJUU1nQ1MwQUFFSC9BVWNFUUNBRUlBSTJBaEJCQ0NFQ0lBTkJDSFFnQVdvaEFRd0JDeUFEUVk4QlRRUkFJQVFnQWpZQ0VDQURRUWwwSUFGcUlRRkJCeUVDREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FCUVlEK0Eyb2hBVUVJSVFJTElBSkJBV3NoQWlBQlFRRjBJUUVnQmtFQmRDSUdRWUNBQWtrTkFBc2dFMFVnRXlBVkd3d0JDeUFKS0FJRUlSTWdEU0FKUVFoQkRDQURJQVpMSWhVYmFpZ0NBRFlDQUFOQUFrQWdBZzBBSUFRb0FoQWlDVUVCYWlFQ0lBa3RBQUVoQmlBSkxRQUFRZjhCUndSQUlBUWdBallDRUVFSUlRSWdCa0VJZENBQmFpRUJEQUVMSUFaQmp3Rk5CRUFnQkNBQ05nSVFJQVpCQ1hRZ0FXb2hBVUVISVFJTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFGQmdQNERhaUVCUVFnaEFnc2dBa0VCYXlFQ0lBRkJBWFFoQVNBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFESVFZZ0V5QVRSU0FWR3dzaEF5QUhJQlJCQW5ScUlna2dDaUFMSUFNZ0NTZ0NBQ0lKUVI5MlJoc2dDV28yQWdBZ0VFR0FnSUNBQW5JRklCQUxOZ0lBQ3lBRlFRUnFJUWtnQjBFRWFpRUhJQWhCQVdvaUNDQU1SdzBBQ3lBRlFReHFJUWtnQnlBVVFRSjBhaUVISUJGQkJHb2lFU0FFS0FLQUFTSURRWHh4U1EwQUN3d0JDMEVFSUFOQmZIRWlDU0FKUVFSTkcwRUJheUlKUVh4eFFRUnFJUkVnQ0NBSlFRRjBRWGh4YWtFVWFpRUpDeUFFSUFJMkFnZ2dCQ0FHTmdJRUlBUWdBVFlDQUNBRUlBMDJBbWdnREVVTkFTQURJQkZORFFGQkFDRVRRUUFnQzJzaEZDQURJUUVEUUFKQUlBRWdFVVlFUUNBUklRRU1BUXNnQ1NnQ0FDRUNRUUFoRUFOQVFaQ0FnQUVnRUVFRGJDSUlkQ0FDY1VFUUlBaDBSZ1JBSUFjZ0RDQVFiRUVDZEdvaEJTQUVJQTlCRUVFUFFRNGdBaUFJZGlJQlFlOERjUnNnQVVHQWdNQUFjUnRCQW5ScUlnMDJBbWdnQkNBRUtBSUVJQTBvQWdBaUFpZ0NBQ0lCYXlJRE5nSUVBbjhnQVNBRUtBSUFJZ1pCRUhaTEJFQWdBaWdDQkNFS0lBUWdBVFlDQkNBTklBSkJDRUVNSUFFZ0Ewc2lEaHRxS0FJQU5nSUFJQVFvQWdnaEFnTkFBa0FnQWcwQUlBUW9BaEFpQWtFQmFpRU5JQUl0QUFFaEF5QUNMUUFBUWY4QlJnUkFJQU5Ca0FGUEJFQWdCQ0FFS0FJTVFRRnFOZ0lNSUFaQmdQNERhaUVHUVFnaEFnd0NDeUFFSUEwMkFoQWdBMEVKZENBR2FpRUdRUWNoQWd3QkN5QUVJQTAyQWhCQkNDRUNJQU5CQ0hRZ0Jtb2hCZ3NnQkNBQ1FRRnJJZ0kyQWdnZ0JDQUdRUUYwSWdZMkFnQWdCQ0FCUVFGMElnRTJBZ1FnQVVHQWdBSkpEUUFMSUFvZ0NrVWdEaHNNQVFzZ0JDQUdJQUZCRUhScklnWTJBZ0FnQTBHQWdBSnhSUVJBSUFJb0FnUWhDaUFOSUFKQkRFRUlJQUVnQTBzaURodHFLQUlBTmdJQUlBUW9BZ2doQWdOQUFrQWdBZzBBSUFRb0FoQWlBa0VCYWlFTklBSXRBQUVoQVNBQ0xRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQVpCZ1A0RGFpRUdRUWdoQWd3Q0N5QUVJQTAyQWhBZ0FVRUpkQ0FHYWlFR1FRY2hBZ3dCQ3lBRUlBMDJBaEJCQ0NFQ0lBRkJDSFFnQm1vaEJnc2dCQ0FDUVFGcklnSTJBZ2dnQkNBR1FRRjBJZ1kyQWdBZ0JDQURRUUYwSWdNMkFnUWdBMEdBZ0FKSkRRQUxJQXBGSUFvZ0Roc01BUXNnQWlnQ0JBc2hBU0FGSUJRZ0N5QUJJQVVvQWdBaUEwRWZka1liSUFOcU5nSUFJQWtnQ1NnQ0FFR0FnTUFBSUFoMGNpSUNOZ0lBSUFRb0FvQUJJUU1MSUJCQkFXb2lFQ0FESWdFZ0VXdEpEUUFMQ3lBSlFRUnFJUWtnQjBFRWFpRUhJQk5CQVdvaUV5QU1SdzBBQ3d3QkMwRUFJUkZCQUNFWEFrQUNRQUpBQWtBZ0JDZ0NmQ0lVUWNBQVJ3MEFJQVFvQW9BQlFjQUFSdzBBUVFCQkFTQVpkQ0lCUVFGMklBRnlJaFJySVJNZ0JFSGtBR29oQ0NBRVFlQUFhaUVRSUFSQkhHb2hDeUFFS0FKNFFZd0NhaUVHSUFRb0FnZ2hCU0FFS0FJRUlRRWdCQ2dDQUNFQ0lBUW9BbWdoQ1NBRUtBSjBJUU1nRmtFSWNRMEJBMEJCQUNFTUEwQWdBeUVSQWtBQ1FBSi9Ba0FDUUNBR0lnMG9BZ0FpQmtVRVFDQUJJQkFvQWdBaUF5Z0NBQ0lHYXlFQkFuOGdCaUFDUVJCMlN3UkFJQU1vQWdRaEJ5QVFJQU5CQ0VFTUlBRWdCa2tpQ2h0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSURRUUZxSVFrZ0F5MEFBU0VCSUFNdEFBQkIvd0ZHQkVBZ0FVR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdDVFlDRUNBQlFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0NUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFaQkFYUWlCa0dBZ0FKSkRRQUxJQVloQVNBSElBZEZJQW9iREFFTElBSWdCa0VRZEdzaEFpQUJRWUNBQW5GRkJFQWdBeWdDQkNFSElCQWdBMEVNUVFnZ0FTQUdTU0lLRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnWkJBV29oQ1NBR0xRQUJJUU1nQmkwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUpOZ0lRSUFOQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBSk5nSVFRUWdoQlNBRFFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dCMFVnQnlBS0d3d0JDeUFES0FJRUMwVUVRQ0FRSVFrTUJnc2dBU0FJS0FJQUlnTW9BZ0FpQm1zaEFRSi9JQVlnQWtFUWRrc0VRQ0FES0FJRUlRY2dDQ0FEUVFoQkRDQUJJQVpKSWdvYmFpZ0NBQ0lETmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lKUVFGcUlRVWdDUzBBQVNFQklBa3RBQUJCL3dGR0JFQWdBVUdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFRkRBSUxJQVFnQlRZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNDeUFGUVFGcklRVWdBa0VCZENFQ0lBWkJBWFFpQmtHQWdBSkpEUUFMSUFZaEFTQUhJQWRGSUFvYkRBRUxJQUlnQmtFUWRHc2hBaUFCUVlDQUFuRkZCRUFnQXlnQ0JDRUhJQWdnQTBFTVFRZ2dBU0FHU1NJS0cyb29BZ0FpQXpZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQ1VFQmFpRUZJQWt0QUFFaEJpQUpMUUFBUWY4QlJnUkFJQVpCa0FGUEJFQWdCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRd0NDeUFFSUFVMkFoQWdCa0VKZENBQ2FpRUNRUWNoQlF3QkN5QUVJQVUyQWhCQkNDRUZJQVpCQ0hRZ0Ftb2hBZ3NnQlVFQmF5RUZJQUpCQVhRaEFpQUJRUUYwSWdGQmdJQUNTUTBBQ3lBSFJTQUhJQW9iREFFTElBTW9BZ1FMSVFvZ0FTQURLQUlBSWdacklRRUNmeUFHSUFKQkVIWkxCRUFnQXlnQ0JDRUhJQWdnQTBFSVFRd2dBU0FHU1NJT0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ05CQVdvaENTQURMUUFCSVFFZ0F5MEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FKTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUpOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0JrRUJkQ0lHUVlDQUFra05BQXNnQmlFQklBY2dCMFVnRGhzTUFRc2dBaUFHUVJCMGF5RUNJQUZCZ0lBQ2NVVUVRQ0FES0FJRUlRY2dDQ0FEUVF4QkNDQUJJQVpKSWc0YmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCa0VCYWlFSklBWXRBQUVoQXlBR0xRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQWsyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBazJBaEJCQ0NFRklBTkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFIUlNBSElBNGJEQUVMSUFNb0FnUUxJUU5CQUNFR0lBZ2hDUUpBQWtBQ1FBSi9Ba0FDUUNBRElBcEJBWFJ5RGdRQUFRTUZDZ3NnQVNBTElBMG9BZ1JCRVhaQkJIRWdEVUVFYXlJSEtBSUFRUk4yUVFGeGNpSU9RZUM1QVdvdEFBQkJBblJxSWdrb0FnQWlBeWdDQUNJR2F5RUJBbjhnQmlBQ1FSQjJTd1JBSUFNb0FnUWhDaUFKSUFOQkNFRU1JQUVnQmtraUVodHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lEUVFGcUlRa2dBeTBBQVNFQklBTXRBQUJCL3dGR0JFQWdBVUdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFRkRBSUxJQVFnQ1RZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdDVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNDeUFGUVFGcklRVWdBa0VCZENFQ0lBWkJBWFFpQmtHQWdBSkpEUUFMSUFZaEFTQUtJQXBGSUJJYkRBRUxJQUlnQmtFUWRHc2hBaUFCUVlDQUFuRkZCRUFnQXlnQ0JDRUtJQWtnQTBFTVFRZ2dBU0FHU1NJU0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ1pCQVdvaENTQUdMUUFCSVFNZ0JpMEFBRUgvQVVZRVFDQURRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FKTmdJUUlBTkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUpOZ0lRUVFnaEJTQURRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQ2tVZ0NpQVNHd3dCQ3lBREtBSUVDeUVESUJFZ0V5QVVJQU1nRGtIZ3V3RnFMUUFBY3lJREd6WUNBQ0FISUFjb0FnQkJJSEkyQWdBZ0RTQU5LQUlFUVFoeU5nSUVJQTFCakFKcklnWWdCaWdDQUVHQWdBaHlOZ0lBSUExQmhBSnJJZ1lnQmlnQ0FFR0FnQUp5TmdJQUlBMUJpQUpySWdZZ0JpZ0NBQ0FEUVI5MGNrR0FnQVJ5TmdJQUlBTkJFM1FoVnlBQklBc2dCQ2dDYkMwQUFrRUNkR29pQnlnQ0FDSURLQUlBSWdacklRRUNmeUFHSUFKQkVIWkxCRUFnQXlnQ0JDRUpJQWNnQTBFSVFRd2dBU0FHU1NJT0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ05CQVdvaEJ5QURMUUFCSVFFZ0F5MEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FITmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUhOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0JrRUJkQ0lHUVlDQUFra05BQXNnQmlFQklBa2dDVVVnRGhzTUFRc2dBaUFHUVJCMGF5RUNJQUZCZ0lBQ2NVVUVRQ0FES0FJRUlRa2dCeUFEUVF4QkNDQUJJQVpKSWc0YmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCa0VCYWlFSElBWXRBQUVoQXlBR0xRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQWMyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBYzJBaEJCQ0NFRklBTkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFKUlNBSklBNGJEQUVMSUFNb0FnUUxJUU1nVjBFUWNpSUdJQU5GRFFFYUN5QUJJQXNnRFNnQ0JFRVVka0VFY1NBTlFRUnJJZ2tvQWdCQkZuWkJBWEVnQmtFUGRrRVFjU0FHUVJOMlFjQUFjU0FHUVFOMlFhb0JjWEp5Y25JaUVrSGd1UUZxTFFBQVFRSjBhaUlLS0FJQUlnY29BZ0FpQTJzaEFRSi9JQU1nQWtFUWRrc0VRQ0FIS0FJRUlRNGdDaUFIUVFoQkRDQUJJQU5KSWdvYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFESVFFZ0RpQU9SU0FLR3d3QkN5QUNJQU5CRUhScklRSWdBVUdBZ0FKeFJRUkFJQWNvQWdRaERpQUtJQWRCREVFSUlBRWdBMGtpQ2h0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUhRUUZxSVFVZ0J5MEFBU0VESUFjdEFBQkIvd0ZHQkVBZ0EwR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdCVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JUWUNFRUVJSVFVZ0EwRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQTVGSUE0Z0Noc01BUXNnQnlnQ0JBc2hBeUFSSUJNZ0ZDQURJQkpCNExzQmFpMEFBSE1pQXhzMkFvQUNJQWtnQ1NnQ0FFR0FBbkkyQWdBZ0RTQU5LQUlFUWNBQWNqWUNCQ0FHSUFOQkZuUnlRWUFCY2dzaEJpQUJJQXNnQkNnQ2JDQUdRUVoyUWU4RGNXb3RBQUJCQW5ScUlna29BZ0FpQnlnQ0FDSURheUVCQW44Z0F5QUNRUkIyU3dSQUlBY29BZ1FoQ2lBSklBZEJDRUVNSUFFZ0Ewa2lEaHRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJSFFRRnFJUWtnQnkwQUFTRUJJQWN0QUFCQi93RkdCRUFnQVVHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZEQUlMSUFRZ0NUWUNFQ0FCUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQ1RZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQU5CQVhRaUEwR0FnQUpKRFFBTElBTWhBU0FLSUFwRklBNGJEQUVMSUFJZ0EwRVFkR3NoQWlBQlFZQ0FBbkZGQkVBZ0J5Z0NCQ0VLSUFrZ0IwRU1RUWdnQVNBRFNTSU9HMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hDU0FITFFBQklRTWdCeTBBQUVIL0FVWUVRQ0FEUVpBQlR3UkFJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVU1BZ3NnQkNBSk5nSVFJQU5CQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FKTmdJUVFRZ2hCU0FEUVFoMElBSnFJUUlMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0NrVWdDaUFPR3d3QkN5QUhLQUlFQzBVTkFRc2dBU0FMSUEwb0FnUkJGM1pCQkhFZ0RVRUVheUlKS0FJQVFSbDJRUUZ4SUFaQkVuWkJFSEVnQmtFV2RrSEFBSEVnQmtFR2RrR3FBWEZ5Y25KeUloSkI0TGtCYWkwQUFFRUNkR29pQ2lnQ0FDSUhLQUlBSWdOcklRRUNmeUFESUFKQkVIWkxCRUFnQnlnQ0JDRU9JQW9nQjBFSVFRd2dBU0FEU1NJS0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFFZ0J5MEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnQXlFQklBNGdEa1VnQ2hzTUFRc2dBaUFEUVJCMGF5RUNJQUZCZ0lBQ2NVVUVRQ0FIS0FJRUlRNGdDaUFIUVF4QkNDQUJJQU5KSWdvYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQXlBSExRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBTkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFPUlNBT0lBb2JEQUVMSUFjb0FnUUxJUU1nRVNBVElCUWdBeUFTUWVDN0FXb3RBQUJ6SWdNYk5nS0FCQ0FKSUFrb0FnQkJnQkJ5TmdJQUlBMGdEU2dDQkVHQUJISTJBZ1FnQmlBRFFSbDBja0dBQ0hJaEJnc2dBU0FMSUFRb0Ftd2dCa0VKZGtIdkEzRnFMUUFBUVFKMGFpSUpLQUlBSWdjb0FnQWlBMnNoQVFKL0lBTWdBa0VRZGtzRVFDQUhLQUlFSVFvZ0NTQUhRUWhCRENBQklBTkpJZzRiYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBU0FITFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXdDQ3lBRUlBVTJBaEFnQVVFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFVMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWdzZ0JVRUJheUVGSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QURJUUVnQ2lBS1JTQU9Hd3dCQ3lBQ0lBTkJFSFJySVFJZ0FVR0FnQUp4UlFSQUlBY29BZ1FoQ2lBSklBZEJERUVJSUFFZ0Ewa2lEaHRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJSFFRRnFJUVVnQnkwQUFTRURJQWN0QUFCQi93RkdCRUFnQTBHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZEQUlMSUFRZ0JUWUNFQ0FEUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQlRZQ0VFRUlJUVVnQTBFSWRDQUNhaUVDQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBcEZJQW9nRGhzTUFRc2dCeWdDQkF0RkRRVUxJQUVnQ3lBTktBSUVRUnAyUVFSeElBMUJCR3NpRGlnQ0FFRWNka0VCY1NBR1FSVjJRUkJ4SUFaQkdYWkJ3QUJ4SUFaQkNYWkJxZ0Z4Y25KeWNpSUtRZUM1QVdvdEFBQkJBblJxSWdrb0FnQWlCeWdDQUNJRGF5RUJJQU1nQWtFUWRrc0VRQ0FIS0FJRUlSSWdDU0FIUVFoQkRDQUJJQU5KSWhVYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFESVFFZ0VpQVNSU0FWR3d3RUN5QUNJQU5CRUhScklRSWdBVUdBZ0FKeERRRWdCeWdDQkNFU0lBa2dCMEVNUVFnZ0FTQURTU0lWRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUU1nQnkwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUZOZ0lRSUFOQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRk5nSVFRUWdoQlNBRFFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dFa1VnRWlBVkd3d0RDd0pBSUFaQmtJQ0FBWEVOQUNBQklBc2dCQ2dDYkNBR1FlOERjV290QUFCQkFuUnFJZ2tvQWdBaUJ5Z0NBQ0lEYXlFQkFuOGdBeUFDUVJCMlN3UkFJQWNvQWdRaENpQUpJQWRCQ0VFTUlBRWdBMGtpRGh0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUhRUUZxSVFVZ0J5MEFBU0VCSUFjdEFBQkIvd0ZHQkVBZ0FVR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdCVFlDRUNBQlFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQU1oQVNBS0lBcEZJQTRiREFFTElBSWdBMEVRZEdzaEFpQUJRWUNBQW5GRkJFQWdCeWdDQkNFS0lBa2dCMEVNUVFnZ0FTQURTU0lPRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUU1nQnkwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUZOZ0lRSUFOQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRk5nSVFRUWdoQlNBRFFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dDa1VnQ2lBT0d3d0JDeUFIS0FJRUMwVU5BQ0FCSUFzZ0RTZ0NCRUVSZGtFRWNTQU5RUVJySWdvb0FnQkJFM1pCQVhFZ0JrRU9ka0VRY1NBR1FSQjJRY0FBY1NBR1Fhb0JjWEp5Y25JaUVrSGd1UUZxTFFBQVFRSjBhaUlKS0FJQUlnY29BZ0FpQTJzaEFRSi9JQU1nQWtFUWRrc0VRQ0FIS0FJRUlRNGdDU0FIUVFoQkRDQUJJQU5KSWhVYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFESVFFZ0RpQU9SU0FWR3d3QkN5QUNJQU5CRUhScklRSWdBVUdBZ0FKeFJRUkFJQWNvQWdRaERpQUpJQWRCREVFSUlBRWdBMGtpRlJ0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUhRUUZxSVFVZ0J5MEFBU0VESUFjdEFBQkIvd0ZHQkVBZ0EwR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdCVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JUWUNFRUVJSVFVZ0EwRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQTVGSUE0Z0ZSc01BUXNnQnlnQ0JBc2hBeUFSSUJNZ0ZDQURJQkpCNExzQmFpMEFBSE1pQXhzMkFnQWdDaUFLS0FJQVFTQnlOZ0lBSUEwZ0RTZ0NCRUVJY2pZQ0JDQU5RWXdDYXlJSElBY29BZ0JCZ0lBSWNqWUNBQ0FOUVlRQ2F5SUhJQWNvQWdCQmdJQUNjallDQUNBTlFZZ0NheUlISUFjb0FnQWdBMEVmZEhKQmdJQUVjallDQUNBR0lBTkJFM1J5UVJCeUlRWUxBa0FnQmtHQWdZQUljUTBBSUFFZ0N5QUVLQUpzSUFaQkEzWWlEa0h2QTNGcUxRQUFRUUowYWlJSktBSUFJZ2NvQWdBaUEyc2hBUUovSUFNZ0FrRVFka3NFUUNBSEtBSUVJUW9nQ1NBSFFRaEJEQ0FCSUFOSkloSWJhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUZJQWN0QUFFaEFTQUhMUUFBUWY4QlJnUkFJQUZCa0FGUEJFQWdCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRd0NDeUFFSUFVMkFoQWdBVUVKZENBQ2FpRUNRUWNoQlF3QkN5QUVJQVUyQWhCQkNDRUZJQUZCQ0hRZ0Ftb2hBZ3NnQlVFQmF5RUZJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBRElRRWdDaUFLUlNBU0d3d0JDeUFDSUFOQkVIUnJJUUlnQVVHQWdBSnhSUVJBSUFjb0FnUWhDaUFKSUFkQkRFRUlJQUVnQTBraUVodHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lIUVFGcUlRVWdCeTBBQVNFRElBY3RBQUJCL3dGR0JFQWdBMEdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFRkRBSUxJQVFnQlRZQ0VDQURRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCVFlDRUVFSUlRVWdBMEVJZENBQ2FpRUNDeUFGUVFGcklRVWdBa0VCZENFQ0lBRkJBWFFpQVVHQWdBSkpEUUFMSUFwRklBb2dFaHNNQVFzZ0J5Z0NCQXRGRFFBZ0FTQUxJQTBvQWdSQkZIWkJCSEVnRFVFRWF5SUtLQUlBUVJaMlFRRnhJQVpCRDNaQkVIRWdCa0VUZGtIQUFIRWdEa0dxQVhGeWNuSnlJaEpCNExrQmFpMEFBRUVDZEdvaUNTZ0NBQ0lIS0FJQUlnTnJJUUVDZnlBRElBSkJFSFpMQkVBZ0J5Z0NCQ0VPSUFrZ0IwRUlRUXdnQVNBRFNTSVZHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRRWdCeTBBQUVIL0FVWUVRQ0FCUVpBQlR3UkFJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVU1BZ3NnQkNBRk5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FGTmdJUVFRZ2hCU0FCUVFoMElBSnFJUUlMSUFWQkFXc2hCU0FDUVFGMElRSWdBMEVCZENJRFFZQ0FBa2tOQUFzZ0F5RUJJQTRnRGtVZ0ZSc01BUXNnQWlBRFFSQjBheUVDSUFGQmdJQUNjVVVFUUNBSEtBSUVJUTRnQ1NBSFFReEJDQ0FCSUFOSkloVWJhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUZJQWN0QUFFaEF5QUhMUUFBUWY4QlJnUkFJQU5Ca0FGUEJFQWdCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRd0NDeUFFSUFVMkFoQWdBMEVKZENBQ2FpRUNRUWNoQlF3QkN5QUVJQVUyQWhCQkNDRUZJQU5CQ0hRZ0Ftb2hBZ3NnQlVFQmF5RUZJQUpCQVhRaEFpQUJRUUYwSWdGQmdJQUNTUTBBQ3lBT1JTQU9JQlViREFFTElBY29BZ1FMSVFNZ0VTQVRJQlFnQXlBU1FlQzdBV290QUFCeklnTWJOZ0tBQWlBS0lBb29BZ0JCZ0FKeU5nSUFJQTBnRFNnQ0JFSEFBSEkyQWdRZ0JpQURRUlowY2tHQUFYSWhCZ3NDUUNBR1FZQ0lnTUFBY1EwQUlBRWdDeUFFS0FKc0lBWkJCbllpRGtIdkEzRnFMUUFBUVFKMGFpSUpLQUlBSWdjb0FnQWlBMnNoQVFKL0lBTWdBa0VRZGtzRVFDQUhLQUlFSVFvZ0NTQUhRUWhCRENBQklBTkpJaEliYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBU0FITFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXdDQ3lBRUlBVTJBaEFnQVVFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFVMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWdzZ0JVRUJheUVGSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QURJUUVnQ2lBS1JTQVNHd3dCQ3lBQ0lBTkJFSFJySVFJZ0FVR0FnQUp4UlFSQUlBY29BZ1FoQ2lBSklBZEJERUVJSUFFZ0Ewa2lFaHRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJSFFRRnFJUVVnQnkwQUFTRURJQWN0QUFCQi93RkdCRUFnQTBHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZEQUlMSUFRZ0JUWUNFQ0FEUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQlRZQ0VFRUlJUVVnQTBFSWRDQUNhaUVDQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBcEZJQW9nRWhzTUFRc2dCeWdDQkF0RkRRQWdBU0FMSUEwb0FnUkJGM1pCQkhFZ0RVRUVheUlLS0FJQVFSbDJRUUZ4SUFaQkVuWkJFSEVnQmtFV2RrSEFBSEVnRGtHcUFYRnljbkp5SWhKQjRMa0JhaTBBQUVFQ2RHb2lDU2dDQUNJSEtBSUFJZ05ySVFFQ2Z5QURJQUpCRUhaTEJFQWdCeWdDQkNFT0lBa2dCMEVJUVF3Z0FTQURTU0lWRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUUVnQnkwQUFFSC9BVVlFUUNBQlFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRk5nSVFRUWdoQlNBQlFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQTBFQmRDSURRWUNBQWtrTkFBc2dBeUVCSUE0Z0RrVWdGUnNNQVFzZ0FpQURRUkIwYXlFQ0lBRkJnSUFDY1VVRVFDQUhLQUlFSVE0Z0NTQUhRUXhCQ0NBQklBTkpJaFViYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBeUFITFFBQVFmOEJSZ1JBSUFOQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXdDQ3lBRUlBVTJBaEFnQTBFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFVMkFoQkJDQ0VGSUFOQkNIUWdBbW9oQWdzZ0JVRUJheUVGSUFKQkFYUWhBaUFCUVFGMElnRkJnSUFDU1EwQUN5QU9SU0FPSUJVYkRBRUxJQWNvQWdRTElRTWdFU0FUSUJRZ0F5QVNRZUM3QVdvdEFBQnpJZ01iTmdLQUJDQUtJQW9vQWdCQmdCQnlOZ0lBSUEwZ0RTZ0NCRUdBQkhJMkFnUWdCaUFEUVJsMGNrR0FDSEloQmdzZ0JrR0F3SUNBQkhFTkF5QUJJQXNnQkNnQ2JDQUdRUWwySWhKQjd3TnhhaTBBQUVFQ2RHb2lDU2dDQUNJQktBSUFJZ05ySVFjQ2Z5QURJQUpCRUhaTEJFQWdBU2dDQkNFS0lBa2dBVUVJUVF3Z0F5QUhTeUlPRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUUVnQnkwQUFFSC9BVVlFUUNBQlFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRk5nSVFRUWdoQlNBQlFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQTBFQmRDSURRWUNBQWtrTkFBc2dBeUVISUFvZ0NrVWdEaHNNQVFzZ0FpQURRUkIwYXlFQ0lBZEJnSUFDY1VVRVFDQUJLQUlFSVFvZ0NTQUJRUXhCQ0NBRElBZExJZzRiYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUEwRUJhaUVGSUFNdEFBRWhBU0FETFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXdDQ3lBRUlBVTJBaEFnQVVFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFVMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWdzZ0JVRUJheUVGSUFKQkFYUWhBaUFIUVFGMElnZEJnSUFDU1EwQUN5QUtSU0FLSUE0YkRBRUxJQUVvQWdRTFJRUkFJQWNoQVF3RUN5QUhJQXNnRFNnQ0JFRWFka0VFY1NBTlFRUnJJZzRvQWdCQkhIWkJBWEVnQmtFVmRrRVFjU0FHUVJsMlFjQUFjU0FTUWFvQmNYSnljbklpQ2tIZ3VRRnFMUUFBUVFKMGFpSUpLQUlBSWdjb0FnQWlBV3NoQXlBQklBSkJFSFpMQkVBZ0J5Z0NCQ0VTSUFrZ0IwRUlRUXdnQVNBRFN5SVZHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRTWdCeTBBQUVIL0FVWUVRQ0FEUVpBQlR3UkFJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVU1BZ3NnQkNBRk5nSVFJQU5CQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FGTmdJUVFRZ2hCU0FEUVFoMElBSnFJUUlMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0VpQVNSU0FWR3d3REN5QUNJQUZCRUhScklRSWdBMEdBZ0FKeFJRMEJJQU1oQVFzZ0J5Z0NCQXdCQ3lBSEtBSUVJUklnQ1NBSFFReEJDQ0FCSUFOTEloVWJhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUZJQWN0QUFFaEFTQUhMUUFBUWY4QlJnUkFJQUZCa0FGUEJFQWdCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRd0NDeUFFSUFVMkFoQWdBVUVKZENBQ2FpRUNRUWNoQlF3QkN5QUVJQVUyQWhCQkNDRUZJQUZCQ0hRZ0Ftb2hBZ3NnQlVFQmF5RUZJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBRElRRWdFa1VnRWlBVkd3c2hBeUFSSUJNZ0ZDQURJQXBCNExzQmFpMEFBSE1pQXhzMkFvQUdJQTRnRGlnQ0FFR0FnQUZ5TmdJQUlBMGdEU2dDQkVHQUlISTJBZ1FnRFNBTktBS0VBa0VFY2pZQ2hBSWdEU0FOS0FLTUFrRUJjallDakFJZ0RTQU5LQUtJQWlBRFFSSjBja0VDY2pZQ2lBSWdCaUFEUVJ4MGNrR0F3QUJ5SVFZTElBMGdCa0gvLy8rMmUzRTJBZ0FMSUExQkJHb2hCaUFSUVFScUlRTWdERUVCYWlJTVFjQUFSdzBBQ3lBTlFReHFJUVlnRVVHRUJtb2hBeUFYUVR4SklWZ2dGMEVFYWlFWElGZ05BQXNNQWd0QkFTQVpkQ0lCUVFGMklBRnlJUTRnQkNnQ2VDSUhJQlJCQW5ScVFReHFJUU1nQkNnQ2dBRWhCaUFFS0FJSUlRVWdCQ2dDQkNFQklBUW9BZ0FoQWlBRUtBSm9JUWtnQkNnQ2RDRUxBa0FDUUNBV1FRaHhCRUFnQmtFRVNRMENJQlJGRFFFZ0JFSGtBR29oRUNBRVFlQUFhaUVOSUJSQkEyd2hHeUFVUVFGMElTUkJBQ0FPYXlFVklBUkJIR29oRWdOQVFRQWhHQU5BQWtBQ1FBSi9Ba0FnQXlJSUtBSUFJZ01FUUFKQUlBTkJrSUNBQVhFTkFDQUJJQklnQkNnQ2JDQURRZThEY1dvdEFBQkJBblJxSWdrb0FnQWlCeWdDQUNJR2F5RUJBbjhnQmlBQ1FSQjJUUVJBSUFJZ0JrRVFkR3NoQWlBQlFZQ0FBbkVFUUNBSEtBSUVEQUlMSUFjb0FnUWhEQ0FKSUFkQkRFRUlJQUVnQmtraUNodHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lIUVFGcUlRVWdCeTBBQVNFR0lBY3RBQUJCL3dGSEJFQWdCQ0FGTmdJUVFRZ2hCU0FHUVFoMElBSnFJUUlNQVFzZ0JrR1BBVTBFUUNBRUlBVTJBaEFnQmtFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZDeUFGUVFGcklRVWdBa0VCZENFQ0lBRkJBWFFpQVVHQWdBSkpEUUFMSUF4RklBd2dDaHNNQVFzZ0J5Z0NCQ0VNSUFrZ0IwRUlRUXdnQVNBR1NTSUtHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRRWdCeTBBQUVIL0FVY0VRQ0FFSUFVMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWd3QkN5QUJRWThCVFFSQUlBUWdCVFlDRUNBQlFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdCa0VCZENJR1FZQ0FBa2tOQUFzZ0JpRUJJQXdnREVVZ0Noc0xSUTBBSUFFZ0VpQUlLQUlFUVJGMlFRUnhJQWhCQkdzaURDZ0NBRUVUZGtFQmNTQURRUTUyUVJCeElBTkJFSFpCd0FCeElBTkJxZ0Z4Y25KeWNpSVRRZUM1QVdvdEFBQkJBblJxSWdrb0FnQWlCeWdDQUNJR2F5RUJBbjhnQmlBQ1FSQjJUUVJBSUFJZ0JrRVFkR3NoQWlBQlFZQ0FBbkVFUUNBSEtBSUVEQUlMSUFjb0FnUWhDaUFKSUFkQkRFRUlJQUVnQmtraUhCdHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lIUVFGcUlRVWdCeTBBQVNFR0lBY3RBQUJCL3dGSEJFQWdCQ0FGTmdJUVFRZ2hCU0FHUVFoMElBSnFJUUlNQVFzZ0JrR1BBVTBFUUNBRUlBVTJBaEFnQmtFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZDeUFGUVFGcklRVWdBa0VCZENFQ0lBRkJBWFFpQVVHQWdBSkpEUUFMSUFwRklBb2dIQnNNQVFzZ0J5Z0NCQ0VLSUFrZ0IwRUlRUXdnQVNBR1NTSWNHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRRWdCeTBBQUVIL0FVY0VRQ0FFSUFVMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWd3QkN5QUJRWThCVFFSQUlBUWdCVFlDRUNBQlFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdCa0VCZENJR1FZQ0FBa2tOQUFzZ0JpRUJJQW9nQ2tVZ0hCc0xJUVlnQ3lBVklBNGdCaUFUUWVDN0FXb3RBQUJ6SWdZYk5nSUFJQXdnRENnQ0FFRWdjallDQUNBSUlBZ29BZ1JCQ0hJMkFnUWdBeUFHUVJOMGNrRVFjaUVEQ3dKQUlBTkJnSUdBQ0hFTkFDQUJJQklnQkNnQ2JDQURRUU4ySWdwQjd3TnhhaTBBQUVFQ2RHb2lDU2dDQUNJSEtBSUFJZ1pySVFFQ2Z5QUdJQUpCRUhaTkJFQWdBaUFHUVJCMGF5RUNJQUZCZ0lBQ2NRUkFJQWNvQWdRTUFnc2dCeWdDQkNFTUlBa2dCMEVNUVFnZ0FTQUdTU0lURzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUVlnQnkwQUFFSC9BVWNFUUNBRUlBVTJBaEJCQ0NFRklBWkJDSFFnQW1vaEFnd0JDeUFHUVk4QlRRUkFJQVFnQlRZQ0VDQUdRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dERVVnRENBVEd3d0JDeUFIS0FJRUlRd2dDU0FIUVFoQkRDQUJJQVpKSWhNYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUndSQUlBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNEQUVMSUFGQmp3Rk5CRUFnQkNBRk5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0RDQU1SU0FUR3d0RkRRQWdBU0FTSUFnb0FnUkJGSFpCQkhFZ0NFRUVheUlNS0FJQVFSWjJRUUZ4SUFOQkQzWkJFSEVnQTBFVGRrSEFBSEVnQ2tHcUFYRnljbkp5SWhOQjRMa0JhaTBBQUVFQ2RHb2lDU2dDQUNJSEtBSUFJZ1pySVFFQ2Z5QUdJQUpCRUhaTkJFQWdBaUFHUVJCMGF5RUNJQUZCZ0lBQ2NRUkFJQWNvQWdRTUFnc2dCeWdDQkNFS0lBa2dCMEVNUVFnZ0FTQUdTU0ljRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUVlnQnkwQUFFSC9BVWNFUUNBRUlBVTJBaEJCQ0NFRklBWkJDSFFnQW1vaEFnd0JDeUFHUVk4QlRRUkFJQVFnQlRZQ0VDQUdRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dDa1VnQ2lBY0d3d0JDeUFIS0FJRUlRb2dDU0FIUVFoQkRDQUJJQVpKSWh3YmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUndSQUlBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNEQUVMSUFGQmp3Rk5CRUFnQkNBRk5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0NpQUtSU0FjR3dzaEJpQUxJQlJCQW5ScUlCVWdEaUFHSUJOQjRMc0JhaTBBQUhNaUJoczJBZ0FnRENBTUtBSUFRWUFDY2pZQ0FDQUlJQWdvQWdSQndBQnlOZ0lFSUFNZ0JrRVdkSEpCZ0FGeUlRTUxBa0FnQTBHQWlJREFBSEVOQUNBQklCSWdCQ2dDYkNBRFFRWjJJZ3BCN3dOeGFpMEFBRUVDZEdvaUNTZ0NBQ0lIS0FJQUlnWnJJUUVDZnlBR0lBSkJFSFpOQkVBZ0FpQUdRUkIwYXlFQ0lBRkJnSUFDY1FSQUlBY29BZ1FNQWdzZ0J5Z0NCQ0VNSUFrZ0IwRU1RUWdnQVNBR1NTSVRHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRWWdCeTBBQUVIL0FVY0VRQ0FFSUFVMkFoQkJDQ0VGSUFaQkNIUWdBbW9oQWd3QkN5QUdRWThCVFFSQUlBUWdCVFlDRUNBR1FRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0RFVWdEQ0FUR3d3QkN5QUhLQUlFSVF3Z0NTQUhRUWhCRENBQklBWkpJaE1iYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBU0FITFFBQVFmOEJSd1JBSUFRZ0JUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFHUVFGMElnWkJnSUFDU1EwQUN5QUdJUUVnRENBTVJTQVRHd3RGRFFBZ0FTQVNJQWdvQWdSQkYzWkJCSEVnQ0VFRWF5SU1LQUlBUVJsMlFRRnhJQU5CRW5aQkVIRWdBMEVXZGtIQUFIRWdDa0dxQVhGeWNuSnlJaE5CNExrQmFpMEFBRUVDZEdvaUNTZ0NBQ0lIS0FJQUlnWnJJUUVDZnlBR0lBSkJFSFpOQkVBZ0FpQUdRUkIwYXlFQ0lBRkJnSUFDY1FSQUlBY29BZ1FNQWdzZ0J5Z0NCQ0VLSUFrZ0IwRU1RUWdnQVNBR1NTSWNHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRWWdCeTBBQUVIL0FVY0VRQ0FFSUFVMkFoQkJDQ0VGSUFaQkNIUWdBbW9oQWd3QkN5QUdRWThCVFFSQUlBUWdCVFlDRUNBR1FRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0NrVWdDaUFjR3d3QkN5QUhLQUlFSVFvZ0NTQUhRUWhCRENBQklBWkpJaHdiYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBU0FITFFBQVFmOEJSd1JBSUFRZ0JUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFHUVFGMElnWkJnSUFDU1EwQUN5QUdJUUVnQ2lBS1JTQWNHd3NoQmlBTElDUkJBblJxSUJVZ0RpQUdJQk5CNExzQmFpMEFBSE1pQmhzMkFnQWdEQ0FNS0FJQVFZQVFjallDQUNBSUlBZ29BZ1JCZ0FSeU5nSUVJQU1nQmtFWmRISkJnQWh5SVFNTElBTkJnTUNBZ0FSeERRTWdBU0FTSUFRb0Ftd2dBMEVKZGlJS1FlOERjV290QUFCQkFuUnFJZ2tvQWdBaUFTZ0NBQ0lHYXlFSEFuOGdCaUFDUVJCMlRRUkFJQUlnQmtFUWRHc2hBaUFIUVlDQUFuRUVRQ0FCS0FJRURBSUxJQUVvQWdRaERDQUpJQUZCREVFSUlBWWdCMHNpRXh0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUdRUUZxSVFVZ0JpMEFBU0VCSUFZdEFBQkIvd0ZIQkVBZ0JDQUZOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSU1BUXNnQVVHUEFVMEVRQ0FFSUFVMkFoQWdBVUVKZENBQ2FpRUNRUWNoQlF3QkN5QUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFRkN5QUZRUUZySVFVZ0FrRUJkQ0VDSUFkQkFYUWlCMEdBZ0FKSkRRQUxJQXhGSUF3Z0V4c01BUXNnQVNnQ0JDRU1JQWtnQVVFSVFRd2dCaUFIU3lJVEcyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFFZ0J5MEFBRUgvQVVjRVFDQUVJQVUyQWhCQkNDRUZJQUZCQ0hRZ0Ftb2hBZ3dCQ3lBQlFZOEJUUVJBSUFRZ0JUWUNFQ0FCUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0JrRUJkQ0lHUVlDQUFra05BQXNnQmlFSElBd2dERVVnRXhzTFJRUkFJQWNoQVF3RUN5QUhJQklnQ0NnQ0JFRWFka0VFY1NBSVFRUnJJZ3dvQWdCQkhIWkJBWEVnQTBFVmRrRVFjU0FEUVJsMlFjQUFjU0FLUWFvQmNYSnljbklpRTBIZ3VRRnFMUUFBUVFKMGFpSUpLQUlBSWdvb0FnQWlBV3NoQmlBQklBSkJFSFpOQkVBZ0FpQUJRUkIwYXlFQ0lBWkJnSUFDY1FSQUlBWWhBUXdEQ3lBS0tBSUVJUWNnQ1NBS1FReEJDQ0FCSUFaTElod2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQlVFQmFpRUtJQVV0QUFFaEFTQUZMUUFBUWY4QlJ3UkFJQVFnQ2pZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUtOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUdRUUYwSWdaQmdJQUNTUTBBQ3lBR0lRRWdCMFVnQnlBY0d3d0RDeUFLS0FJRUlRY2dDU0FLUVFoQkRDQUJJQVpMSWh3YmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCVUVCYWlFS0lBVXRBQUVoQmlBRkxRQUFRZjhCUndSQUlBUWdDallDRUVFSUlRVWdCa0VJZENBQ2FpRUNEQUVMSUFaQmp3Rk5CRUFnQkNBS05nSVFJQVpCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFISUFkRklCd2JEQUlMSUFFZ0RTZ0NBQ0lHS0FJQUlnTnJJUUVDZnlBRElBSkJFSFpOQkVBZ0FpQURRUkIwYXlFQ0lBRkJnSUFDY1FSQUlBWW9BZ1FNQWdzZ0JpZ0NCQ0VISUEwZ0JrRU1RUWdnQVNBRFNTSU1HMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdaQkFXb2hDU0FHTFFBQklRTWdCaTBBQUVIL0FVY0VRQ0FFSUFrMkFoQkJDQ0VGSUFOQkNIUWdBbW9oQWd3QkN5QURRWThCVFFSQUlBUWdDVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0IwVWdCeUFNR3d3QkN5QUdLQUlFSVFjZ0RTQUdRUWhCRENBQklBTkpJZ3diYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUJrRUJhaUVKSUFZdEFBRWhBU0FHTFFBQVFmOEJSd1JBSUFRZ0NUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FKTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QURJUUVnQnlBSFJTQU1Hd3RGQkVBZ0RTRUpEQVFMSUFFZ0VDZ0NBQ0lHS0FJQUlnTnJJUUVDZnlBRElBSkJFSFpOQkVBZ0FpQURRUkIwYXlFQ0lBRkJnSUFDY1FSQUlBWW9BZ1FNQWdzZ0JpZ0NCQ0VISUJBZ0JrRU1RUWdnQVNBRFNTSU1HMm9vQWdBaUJqWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUNVRUJhaUVGSUFrdEFBRWhBeUFKTFFBQVFmOEJSd1JBSUFRZ0JUWUNFRUVJSVFVZ0EwRUlkQ0FDYWlFQ0RBRUxJQU5CandGTkJFQWdCQ0FGTmdJUUlBTkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFCUVFGMElnRkJnSUFDU1EwQUN5QUhSU0FISUF3YkRBRUxJQVlvQWdRaEJ5QVFJQVpCQ0VFTUlBRWdBMGtpREJ0cUtBSUFJZ1kyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2xCQVdvaEJTQUpMUUFCSVFFZ0NTMEFBRUgvQVVjRVFDQUVJQVUyQWhCQkNDRUZJQUZCQ0hRZ0Ftb2hBZ3dCQ3lBQlFZOEJUUVJBSUFRZ0JUWUNFQ0FCUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnQXlFQklBY2dCMFVnREJzTElRd2dBU0FHS0FJQUlnTnJJUUVDZnlBRElBSkJFSFpOQkVBZ0FpQURRUkIwYXlFQ0lBRkJnSUFDY1FSQUlBWW9BZ1FNQWdzZ0JpZ0NCQ0VISUJBZ0JrRU1RUWdnQVNBRFNTSUtHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdaQkFXb2hDU0FHTFFBQklRTWdCaTBBQUVIL0FVY0VRQ0FFSUFrMkFoQkJDQ0VGSUFOQkNIUWdBbW9oQWd3QkN5QURRWThCVFFSQUlBUWdDVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0IwVWdCeUFLR3d3QkN5QUdLQUlFSVFjZ0VDQUdRUWhCRENBQklBTkpJZ29iYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUJrRUJhaUVKSUFZdEFBRWhBU0FHTFFBQVFmOEJSd1JBSUFRZ0NUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FKTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QURJUUVnQnlBSFJTQUtHd3NoQmtFQUlRTWdFQ0VKQWtBQ1FBSkFBbjhDUUFKQUlBWWdERUVCZEhJT0JBQUJBd1VJQ3lBQklCSWdDQ2dDQkVFUmRrRUVjU0FJUVFScklnY29BZ0JCRTNaQkFYRnlJZ3BCNExrQmFpMEFBRUVDZEdvaUNTZ0NBQ0lHS0FJQUlnTnJJUUVDZnlBRElBSkJFSFpOQkVBZ0FpQURRUkIwYXlFQ0lBRkJnSUFDY1FSQUlBWW9BZ1FNQWdzZ0JpZ0NCQ0VNSUFrZ0JrRU1RUWdnQVNBRFNTSVRHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdaQkFXb2hDU0FHTFFBQklRTWdCaTBBQUVIL0FVY0VRQ0FFSUFrMkFoQkJDQ0VGSUFOQkNIUWdBbW9oQWd3QkN5QURRWThCVFFSQUlBUWdDVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0RFVWdEQ0FUR3d3QkN5QUdLQUlFSVF3Z0NTQUdRUWhCRENBQklBTkpJaE1iYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUJrRUJhaUVKSUFZdEFBRWhBU0FHTFFBQVFmOEJSd1JBSUFRZ0NUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FKTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QURJUUVnRENBTVJTQVRHd3NoQXlBTElCVWdEaUFESUFwQjRMc0JhaTBBQUhNaUF4czJBZ0FnQnlBSEtBSUFRU0J5TmdJQUlBZ2dDQ2dDQkVFSWNqWUNCQ0FEUVJOMElWa2dBU0FTSUFRb0Ftd3RBQUpCQW5ScUlnY29BZ0FpQmlnQ0FDSURheUVCQW44Z0F5QUNRUkIyVFFSQUlBSWdBMEVRZEdzaEFpQUJRWUNBQW5FRVFDQUdLQUlFREFJTElBWW9BZ1FoQ1NBSElBWkJERUVJSUFFZ0Ewa2lDaHRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJR1FRRnFJUWNnQmkwQUFTRURJQVl0QUFCQi93RkhCRUFnQkNBSE5nSVFRUWdoQlNBRFFRaDBJQUpxSVFJTUFRc2dBMEdQQVUwRVFDQUVJQWMyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBbEZJQWtnQ2hzTUFRc2dCaWdDQkNFSklBY2dCa0VJUVF3Z0FTQURTU0lLRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnWkJBV29oQnlBR0xRQUJJUUVnQmkwQUFFSC9BVWNFUUNBRUlBYzJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnd0JDeUFCUVk4QlRRUkFJQVFnQnpZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQTBFQmRDSURRWUNBQWtrTkFBc2dBeUVCSUFrZ0NVVWdDaHNMSVFZZ1dVRVFjaUlESUFaRkRRRWFDeUFCSUJJZ0NDZ0NCRUVVZGtFRWNTQUlRUVJySWdrb0FnQkJGblpCQVhFZ0EwRVBka0VRY1NBRFFSTjJRY0FBY1NBRFFRTjJRYW9CY1hKeWNuSWlFMEhndVFGcUxRQUFRUUowYWlJTUtBSUFJZ2NvQWdBaUJtc2hBUUovSUFZZ0FrRVFkazBFUUNBQ0lBWkJFSFJySVFJZ0FVR0FnQUp4QkVBZ0J5Z0NCQXdDQ3lBSEtBSUVJUW9nRENBSFFReEJDQ0FCSUFaSklnd2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUZJQWN0QUFFaEJpQUhMUUFBUWY4QlJ3UkFJQVFnQlRZQ0VFRUlJUVVnQmtFSWRDQUNhaUVDREFFTElBWkJqd0ZOQkVBZ0JDQUZOZ0lRSUFaQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUJRUUYwSWdGQmdJQUNTUTBBQ3lBS1JTQUtJQXdiREFFTElBY29BZ1FoQ2lBTUlBZEJDRUVNSUFFZ0Jra2lEQnRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJSFFRRnFJUVVnQnkwQUFTRUJJQWN0QUFCQi93RkhCRUFnQkNBRk5nSVFRUWdoQlNBQlFRaDBJQUpxSVFJTUFRc2dBVUdQQVUwRVFDQUVJQVUyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQVpCQVhRaUJrR0FnQUpKRFFBTElBWWhBU0FLSUFwRklBd2JDeUVHSUFzZ0ZFRUNkR29nRlNBT0lBWWdFMEhndXdGcUxRQUFjeUlHR3pZQ0FDQUpJQWtvQWdCQmdBSnlOZ0lBSUFnZ0NDZ0NCRUhBQUhJMkFnUWdBeUFHUVJaMGNrR0FBWElMSVFNZ0FTQVNJQVFvQW13Z0EwRUdka0h2QTNGcUxRQUFRUUowYWlJSktBSUFJZ2NvQWdBaUJtc2hBUUovSUFZZ0FrRVFkazBFUUNBQ0lBWkJFSFJySVFJZ0FVR0FnQUp4QkVBZ0J5Z0NCQXdDQ3lBSEtBSUVJUXdnQ1NBSFFReEJDQ0FCSUFaSklnb2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUpJQWN0QUFFaEJpQUhMUUFBUWY4QlJ3UkFJQVFnQ1RZQ0VFRUlJUVVnQmtFSWRDQUNhaUVDREFFTElBWkJqd0ZOQkVBZ0JDQUpOZ0lRSUFaQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUJRUUYwSWdGQmdJQUNTUTBBQ3lBTVJTQU1JQW9iREFFTElBY29BZ1FoRENBSklBZEJDRUVNSUFFZ0Jra2lDaHRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJSFFRRnFJUWtnQnkwQUFTRUJJQWN0QUFCQi93RkhCRUFnQkNBSk5nSVFRUWdoQlNBQlFRaDBJQUpxSVFJTUFRc2dBVUdQQVUwRVFDQUVJQWsyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQVpCQVhRaUJrR0FnQUpKRFFBTElBWWhBU0FNSUF4RklBb2JDMFVOQVFzZ0FTQVNJQWdvQWdSQkYzWkJCSEVnQ0VFRWF5SUpLQUlBUVJsMlFRRnhJQU5CRW5aQkVIRWdBMEVXZGtIQUFIRWdBMEVHZGtHcUFYRnljbkp5SWhOQjRMa0JhaTBBQUVFQ2RHb2lEQ2dDQUNJSEtBSUFJZ1pySVFFQ2Z5QUdJQUpCRUhaTkJFQWdBaUFHUVJCMGF5RUNJQUZCZ0lBQ2NRUkFJQWNvQWdRTUFnc2dCeWdDQkNFS0lBd2dCMEVNUVFnZ0FTQUdTU0lNRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUVlnQnkwQUFFSC9BVWNFUUNBRUlBVTJBaEJCQ0NFRklBWkJDSFFnQW1vaEFnd0JDeUFHUVk4QlRRUkFJQVFnQlRZQ0VDQUdRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dDa1VnQ2lBTUd3d0JDeUFIS0FJRUlRb2dEQ0FIUVFoQkRDQUJJQVpKSWd3YmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUndSQUlBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNEQUVMSUFGQmp3Rk5CRUFnQkNBRk5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0NpQUtSU0FNR3dzaEJpQUxJQ1JCQW5ScUlCVWdEaUFHSUJOQjRMc0JhaTBBQUhNaUJoczJBZ0FnQ1NBSktBSUFRWUFRY2pZQ0FDQUlJQWdvQWdSQmdBUnlOZ0lFSUFNZ0JrRVpkSEpCZ0FoeUlRTUxJQUVnRWlBRUtBSnNJQU5CQ1haQjd3TnhhaTBBQUVFQ2RHb2lDU2dDQUNJSEtBSUFJZ1pySVFFQ2Z5QUdJQUpCRUhaTkJFQWdBaUFHUVJCMGF5RUNJQUZCZ0lBQ2NRUkFJQWNvQWdRTUFnc2dCeWdDQkNFTUlBa2dCMEVNUVFnZ0FTQUdTU0lLRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUVlnQnkwQUFFSC9BVWNFUUNBRUlBVTJBaEJCQ0NFRklBWkJDSFFnQW1vaEFnd0JDeUFHUVk4QlRRUkFJQVFnQlRZQ0VDQUdRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dERVVnRENBS0d3d0JDeUFIS0FJRUlRd2dDU0FIUVFoQkRDQUJJQVpKSWdvYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUndSQUlBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNEQUVMSUFGQmp3Rk5CRUFnQkNBRk5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0RDQU1SU0FLR3d0RkRRTUxJQUVnRWlBSUtBSUVRUnAyUVFSeElBaEJCR3NpRENnQ0FFRWNka0VCY1NBRFFSVjJRUkJ4SUFOQkdYWkJ3QUJ4SUFOQkNYWkJxZ0Z4Y25KeWNpSVRRZUM1QVdvdEFBQkJBblJxSWdrb0FnQWlDaWdDQUNJR2F5RUJJQVlnQWtFUWRrMEVRQ0FDSUFaQkVIUnJJUUlnQVVHQWdBSnhEUUVnQ2lnQ0JDRUhJQWtnQ2tFTVFRZ2dBU0FHU1NJY0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ1ZCQVdvaENpQUZMUUFCSVFZZ0JTMEFBRUgvQVVjRVFDQUVJQW8yQWhCQkNDRUZJQVpCQ0hRZ0Ftb2hBZ3dCQ3lBR1FZOEJUUVJBSUFRZ0NqWUNFQ0FHUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQjBVZ0J5QWNHd3dDQ3lBS0tBSUVJUWNnQ1NBS1FRaEJEQ0FCSUFaSklod2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQlVFQmFpRUtJQVV0QUFFaEFTQUZMUUFBUWY4QlJ3UkFJQVFnQ2pZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUtOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUdRUUYwSWdaQmdJQUNTUTBBQ3lBR0lRRWdCeUFIUlNBY0d3d0JDeUFLS0FJRUN5RUdJQXNnRzBFQ2RHb2dGU0FPSUFZZ0UwSGd1d0ZxTFFBQWN5SUhHellDQUNBTUlBd29BZ0JCZ0lBQmNqWUNBQ0FJSUFnb0FnUkJnQ0J5TmdJRUlBUW9BbnhCQW5RZ0NHb2lCaUFHS0FJRVFRUnlOZ0lFSUFZZ0JpZ0NERUVCY2pZQ0RDQUdJQVlvQWdnZ0IwRVNkSEpCQW5JMkFnZ2dBeUFIUVJ4MGNrR0F3QUJ5SVFNTElBZ2dBMEgvLy8rMmUzRTJBZ0FMSUFoQkJHb2hBeUFMUVFScUlRc2dHRUVCYWlJWUlCUkhEUUFMSUFoQkRHb2hBeUFMSUJ0QkFuUnFJUXNnRVVFRWFpSVJJQVFvQW9BQklnWkJmSEZKRFFBTERBSUxBa0FnQmtFRVNRMEFJQlFFUUNBRVFlUUFhaUVRSUFSQjRBQnFJUTBnRkVFRGJDRWJJQlJCQVhRaEpFRUFJQTVySVJVZ0JFRWNhaUVTQTBCQkFDRVlBMEFDUUFKQUFuOENRQ0FESWdnb0FnQWlBd1JBQWtBZ0EwR1FnSUFCY1EwQUlBRWdFaUFFS0FKc0lBTkI3d054YWkwQUFFRUNkR29pQ1NnQ0FDSUhLQUlBSWdacklRRUNmeUFHSUFKQkVIWk5CRUFnQWlBR1FSQjBheUVDSUFGQmdJQUNjUVJBSUFjb0FnUU1BZ3NnQnlnQ0JDRU1JQWtnQjBFTVFRZ2dBU0FHU1NJS0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFZZ0J5MEFBRUgvQVVjRVFDQUVJQVUyQWhCQkNDRUZJQVpCQ0hRZ0Ftb2hBZ3dCQ3lBR1FZOEJUUVJBSUFRZ0JUWUNFQ0FHUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnREVVZ0RDQUtHd3dCQ3lBSEtBSUVJUXdnQ1NBSFFRaEJEQ0FCSUFaSklnb2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUZJQWN0QUFFaEFTQUhMUUFBUWY4QlJ3UkFJQVFnQlRZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUdRUUYwSWdaQmdJQUNTUTBBQ3lBR0lRRWdEQ0FNUlNBS0d3dEZEUUFnQVNBU0lBZ29BZ1JCRVhaQkJIRWdDRUVFYXlJTUtBSUFRUk4yUVFGeElBTkJEblpCRUhFZ0EwRVFka0hBQUhFZ0EwR3FBWEZ5Y25KeUloTkI0TGtCYWkwQUFFRUNkR29pQ1NnQ0FDSUhLQUlBSWdacklRRUNmeUFHSUFKQkVIWk5CRUFnQWlBR1FSQjBheUVDSUFGQmdJQUNjUVJBSUFjb0FnUU1BZ3NnQnlnQ0JDRUtJQWtnQjBFTVFRZ2dBU0FHU1NJY0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFZZ0J5MEFBRUgvQVVjRVFDQUVJQVUyQWhCQkNDRUZJQVpCQ0hRZ0Ftb2hBZ3dCQ3lBR1FZOEJUUVJBSUFRZ0JUWUNFQ0FHUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQ2tVZ0NpQWNHd3dCQ3lBSEtBSUVJUW9nQ1NBSFFRaEJEQ0FCSUFaSklod2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUZJQWN0QUFFaEFTQUhMUUFBUWY4QlJ3UkFJQVFnQlRZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUdRUUYwSWdaQmdJQUNTUTBBQ3lBR0lRRWdDaUFLUlNBY0d3c2hCaUFMSUJVZ0RpQUdJQk5CNExzQmFpMEFBSE1pQnhzMkFnQWdEQ0FNS0FJQVFTQnlOZ0lBSUFnZ0NDZ0NCRUVJY2pZQ0JDQUlRWDRnQkNnQ2ZHdEJBblJxSWdZZ0JpZ0NCRUdBZ0FKeU5nSUVJQVlnQmlnQ0FDQUhRUjkwY2tHQWdBUnlOZ0lBSUFaQkJHc2lCaUFHS0FJQVFZQ0FDSEkyQWdBZ0F5QUhRUk4wY2tFUWNpRURDd0pBSUFOQmdJR0FDSEVOQUNBQklCSWdCQ2dDYkNBRFFRTjJJZ3BCN3dOeGFpMEFBRUVDZEdvaUNTZ0NBQ0lIS0FJQUlnWnJJUUVDZnlBR0lBSkJFSFpOQkVBZ0FpQUdRUkIwYXlFQ0lBRkJnSUFDY1FSQUlBY29BZ1FNQWdzZ0J5Z0NCQ0VNSUFrZ0IwRU1RUWdnQVNBR1NTSVRHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRWWdCeTBBQUVIL0FVY0VRQ0FFSUFVMkFoQkJDQ0VGSUFaQkNIUWdBbW9oQWd3QkN5QUdRWThCVFFSQUlBUWdCVFlDRUNBR1FRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0RFVWdEQ0FUR3d3QkN5QUhLQUlFSVF3Z0NTQUhRUWhCRENBQklBWkpJaE1iYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBU0FITFFBQVFmOEJSd1JBSUFRZ0JUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFHUVFGMElnWkJnSUFDU1EwQUN5QUdJUUVnRENBTVJTQVRHd3RGRFFBZ0FTQVNJQWdvQWdSQkZIWkJCSEVnQ0VFRWF5SU1LQUlBUVJaMlFRRnhJQU5CRDNaQkVIRWdBMEVUZGtIQUFIRWdDa0dxQVhGeWNuSnlJaE5CNExrQmFpMEFBRUVDZEdvaUNTZ0NBQ0lIS0FJQUlnWnJJUUVDZnlBR0lBSkJFSFpOQkVBZ0FpQUdRUkIwYXlFQ0lBRkJnSUFDY1FSQUlBY29BZ1FNQWdzZ0J5Z0NCQ0VLSUFrZ0IwRU1RUWdnQVNBR1NTSWNHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRWWdCeTBBQUVIL0FVY0VRQ0FFSUFVMkFoQkJDQ0VGSUFaQkNIUWdBbW9oQWd3QkN5QUdRWThCVFFSQUlBUWdCVFlDRUNBR1FRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdBVUVCZENJQlFZQ0FBa2tOQUFzZ0NrVWdDaUFjR3d3QkN5QUhLQUlFSVFvZ0NTQUhRUWhCRENBQklBWkpJaHdiYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBU0FITFFBQVFmOEJSd1JBSUFRZ0JUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0RBRUxJQUZCandGTkJFQWdCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFHUVFGMElnWkJnSUFDU1EwQUN5QUdJUUVnQ2lBS1JTQWNHd3NoQmlBTElCUkJBblJxSUJVZ0RpQUdJQk5CNExzQmFpMEFBSE1pQmhzMkFnQWdEQ0FNS0FJQVFZQUNjallDQUNBSUlBZ29BZ1JCd0FCeU5nSUVJQU1nQmtFV2RISkJnQUZ5SVFNTEFrQWdBMEdBaUlEQUFIRU5BQ0FCSUJJZ0JDZ0NiQ0FEUVFaMklncEI3d054YWkwQUFFRUNkR29pQ1NnQ0FDSUhLQUlBSWdacklRRUNmeUFHSUFKQkVIWk5CRUFnQWlBR1FSQjBheUVDSUFGQmdJQUNjUVJBSUFjb0FnUU1BZ3NnQnlnQ0JDRU1JQWtnQjBFTVFRZ2dBU0FHU1NJVEcyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFZZ0J5MEFBRUgvQVVjRVFDQUVJQVUyQWhCQkNDRUZJQVpCQ0hRZ0Ftb2hBZ3dCQ3lBR1FZOEJUUVJBSUFRZ0JUWUNFQ0FHUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnREVVZ0RDQVRHd3dCQ3lBSEtBSUVJUXdnQ1NBSFFRaEJEQ0FCSUFaSkloTWJhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUZJQWN0QUFFaEFTQUhMUUFBUWY4QlJ3UkFJQVFnQlRZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUdRUUYwSWdaQmdJQUNTUTBBQ3lBR0lRRWdEQ0FNUlNBVEd3dEZEUUFnQVNBU0lBZ29BZ1JCRjNaQkJIRWdDRUVFYXlJTUtBSUFRUmwyUVFGeElBTkJFblpCRUhFZ0EwRVdka0hBQUhFZ0NrR3FBWEZ5Y25KeUloTkI0TGtCYWkwQUFFRUNkR29pQ1NnQ0FDSUhLQUlBSWdacklRRUNmeUFHSUFKQkVIWk5CRUFnQWlBR1FSQjBheUVDSUFGQmdJQUNjUVJBSUFjb0FnUU1BZ3NnQnlnQ0JDRUtJQWtnQjBFTVFRZ2dBU0FHU1NJY0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFZZ0J5MEFBRUgvQVVjRVFDQUVJQVUyQWhCQkNDRUZJQVpCQ0hRZ0Ftb2hBZ3dCQ3lBR1FZOEJUUVJBSUFRZ0JUWUNFQ0FHUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQ2tVZ0NpQWNHd3dCQ3lBSEtBSUVJUW9nQ1NBSFFRaEJEQ0FCSUFaSklod2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQjBFQmFpRUZJQWN0QUFFaEFTQUhMUUFBUWY4QlJ3UkFJQVFnQlRZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUdRUUYwSWdaQmdJQUNTUTBBQ3lBR0lRRWdDaUFLUlNBY0d3c2hCaUFMSUNSQkFuUnFJQlVnRGlBR0lCTkI0THNCYWkwQUFITWlCaHMyQWdBZ0RDQU1LQUlBUVlBUWNqWUNBQ0FJSUFnb0FnUkJnQVJ5TmdJRUlBTWdCa0VaZEhKQmdBaHlJUU1MSUFOQmdNQ0FnQVJ4RFFNZ0FTQVNJQVFvQW13Z0EwRUpkaUlLUWU4RGNXb3RBQUJCQW5ScUlna29BZ0FpQVNnQ0FDSUdheUVIQW44Z0JpQUNRUkIyVFFSQUlBSWdCa0VRZEdzaEFpQUhRWUNBQW5FRVFDQUJLQUlFREFJTElBRW9BZ1FoRENBSklBRkJERUVJSUFZZ0Iwc2lFeHRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJR1FRRnFJUVVnQmkwQUFTRUJJQVl0QUFCQi93RkhCRUFnQkNBRk5nSVFRUWdoQlNBQlFRaDBJQUpxSVFJTUFRc2dBVUdQQVUwRVFDQUVJQVUyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQWRCQVhRaUIwR0FnQUpKRFFBTElBeEZJQXdnRXhzTUFRc2dBU2dDQkNFTUlBa2dBVUVJUVF3Z0JpQUhTeUlURzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUUVnQnkwQUFFSC9BVWNFUUNBRUlBVTJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnd0JDeUFCUVk4QlRRUkFJQVFnQlRZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQmtFQmRDSUdRWUNBQWtrTkFBc2dCaUVISUF3Z0RFVWdFeHNMUlFSQUlBY2hBUXdFQ3lBSElCSWdDQ2dDQkVFYWRrRUVjU0FJUVFScklnd29BZ0JCSEhaQkFYRWdBMEVWZGtFUWNTQURRUmwyUWNBQWNTQUtRYW9CY1hKeWNuSWlFMEhndVFGcUxRQUFRUUowYWlJSktBSUFJZ29vQWdBaUFXc2hCaUFCSUFKQkVIWk5CRUFnQWlBQlFSQjBheUVDSUFaQmdJQUNjUVJBSUFZaEFRd0RDeUFLS0FJRUlRY2dDU0FLUVF4QkNDQUJJQVpMSWh3YmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCVUVCYWlFS0lBVXRBQUVoQVNBRkxRQUFRZjhCUndSQUlBUWdDallDRUVFSUlRVWdBVUVJZENBQ2FpRUNEQUVMSUFGQmp3Rk5CRUFnQkNBS05nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0IwVWdCeUFjR3d3REN5QUtLQUlFSVFjZ0NTQUtRUWhCRENBQklBWkxJaHdiYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUJVRUJhaUVLSUFVdEFBRWhCaUFGTFFBQVFmOEJSd1JBSUFRZ0NqWUNFRUVJSVFVZ0JrRUlkQ0FDYWlFQ0RBRUxJQVpCandGTkJFQWdCQ0FLTmdJUUlBWkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlFzZ0JVRUJheUVGSUFKQkFYUWhBaUFCUVFGMElnRkJnSUFDU1EwQUN5QUhJQWRGSUJ3YkRBSUxJQUVnRFNnQ0FDSUdLQUlBSWdOcklRRUNmeUFESUFKQkVIWk5CRUFnQWlBRFFSQjBheUVDSUFGQmdJQUNjUVJBSUFZb0FnUU1BZ3NnQmlnQ0JDRUhJQTBnQmtFTVFRZ2dBU0FEU1NJTUcyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ1pCQVdvaENTQUdMUUFCSVFNZ0JpMEFBRUgvQVVjRVFDQUVJQWsyQWhCQkNDRUZJQU5CQ0hRZ0Ftb2hBZ3dCQ3lBRFFZOEJUUVJBSUFRZ0NUWUNFQ0FEUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQjBVZ0J5QU1Hd3dCQ3lBR0tBSUVJUWNnRFNBR1FRaEJEQ0FCSUFOSklnd2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQmtFQmFpRUpJQVl0QUFFaEFTQUdMUUFBUWY4QlJ3UkFJQVFnQ1RZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUpOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBRElRRWdCeUFIUlNBTUd3dEZCRUFnRFNFSkRBUUxJQUVnRUNnQ0FDSUdLQUlBSWdOcklRRUNmeUFESUFKQkVIWk5CRUFnQWlBRFFSQjBheUVDSUFGQmdJQUNjUVJBSUFZb0FnUU1BZ3NnQmlnQ0JDRUhJQkFnQmtFTVFRZ2dBU0FEU1NJTUcyb29BZ0FpQmpZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQ1VFQmFpRUZJQWt0QUFFaEF5QUpMUUFBUWY4QlJ3UkFJQVFnQlRZQ0VFRUlJUVVnQTBFSWRDQUNhaUVDREFFTElBTkJqd0ZOQkVBZ0JDQUZOZ0lRSUFOQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQUJRUUYwSWdGQmdJQUNTUTBBQ3lBSFJTQUhJQXdiREFFTElBWW9BZ1FoQnlBUUlBWkJDRUVNSUFFZ0Ewa2lEQnRxS0FJQUlnWTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnbEJBV29oQlNBSkxRQUJJUUVnQ1MwQUFFSC9BVWNFUUNBRUlBVTJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnd0JDeUFCUVk4QlRRUkFJQVFnQlRZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQTBFQmRDSURRWUNBQWtrTkFBc2dBeUVCSUFjZ0IwVWdEQnNMSVF3Z0FTQUdLQUlBSWdOcklRRUNmeUFESUFKQkVIWk5CRUFnQWlBRFFSQjBheUVDSUFGQmdJQUNjUVJBSUFZb0FnUU1BZ3NnQmlnQ0JDRUhJQkFnQmtFTVFRZ2dBU0FEU1NJS0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ1pCQVdvaENTQUdMUUFCSVFNZ0JpMEFBRUgvQVVjRVFDQUVJQWsyQWhCQkNDRUZJQU5CQ0hRZ0Ftb2hBZ3dCQ3lBRFFZOEJUUVJBSUFRZ0NUWUNFQ0FEUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQjBVZ0J5QUtHd3dCQ3lBR0tBSUVJUWNnRUNBR1FRaEJEQ0FCSUFOSklnb2JhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQmtFQmFpRUpJQVl0QUFFaEFTQUdMUUFBUWY4QlJ3UkFJQVFnQ1RZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUpOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBRElRRWdCeUFIUlNBS0d3c2hCa0VBSVFNZ0VDRUpBa0FDUUFKQUFuOENRQUpBSUFZZ0RFRUJkSElPQkFBQkF3VUlDeUFCSUJJZ0NDZ0NCRUVSZGtFRWNTQUlRUVJySWdjb0FnQkJFM1pCQVhGeUlncEI0TGtCYWkwQUFFRUNkR29pQ1NnQ0FDSUdLQUlBSWdOcklRRUNmeUFESUFKQkVIWk5CRUFnQWlBRFFSQjBheUVDSUFGQmdJQUNjUVJBSUFZb0FnUU1BZ3NnQmlnQ0JDRU1JQWtnQmtFTVFRZ2dBU0FEU1NJVEcyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ1pCQVdvaENTQUdMUUFCSVFNZ0JpMEFBRUgvQVVjRVFDQUVJQWsyQWhCQkNDRUZJQU5CQ0hRZ0Ftb2hBZ3dCQ3lBRFFZOEJUUVJBSUFRZ0NUWUNFQ0FEUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQkNnQ0RFRUJhallDRENBQ1FZRCtBMm9oQWtFSUlRVUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnREVVZ0RDQVRHd3dCQ3lBR0tBSUVJUXdnQ1NBR1FRaEJEQ0FCSUFOSkloTWJhaWdDQURZQ0FBTkFBa0FnQlEwQUlBUW9BaEFpQmtFQmFpRUpJQVl0QUFFaEFTQUdMUUFBUWY4QlJ3UkFJQVFnQ1RZQ0VFRUlJUVVnQVVFSWRDQUNhaUVDREFFTElBRkJqd0ZOQkVBZ0JDQUpOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXNnQlVFQmF5RUZJQUpCQVhRaEFpQURRUUYwSWdOQmdJQUNTUTBBQ3lBRElRRWdEQ0FNUlNBVEd3c2hBeUFMSUJVZ0RpQURJQXBCNExzQmFpMEFBSE1pQmhzMkFnQWdCeUFIS0FJQVFTQnlOZ0lBSUFnZ0NDZ0NCRUVJY2pZQ0JDQUlRWDRnQkNnQ2ZHdEJBblJxSWdNZ0F5Z0NCRUdBZ0FKeU5nSUVJQU1nQXlnQ0FDQUdRUjkwY2tHQWdBUnlOZ0lBSUFOQkJHc2lBeUFES0FJQVFZQ0FDSEkyQWdBZ0JrRVRkQ0ZhSUFFZ0VpQUVLQUpzTFFBQ1FRSjBhaUlIS0FJQUlnWW9BZ0FpQTJzaEFRSi9JQU1nQWtFUWRrMEVRQ0FDSUFOQkVIUnJJUUlnQVVHQWdBSnhCRUFnQmlnQ0JBd0NDeUFHS0FJRUlRa2dCeUFHUVF4QkNDQUJJQU5KSWdvYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCa0VCYWlFSElBWXRBQUVoQXlBR0xRQUFRZjhCUndSQUlBUWdCellDRUVFSUlRVWdBMEVJZENBQ2FpRUNEQUVMSUFOQmp3Rk5CRUFnQkNBSE5nSVFJQU5CQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFKUlNBSklBb2JEQUVMSUFZb0FnUWhDU0FISUFaQkNFRU1JQUVnQTBraUNodHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lHUVFGcUlRY2dCaTBBQVNFQklBWXRBQUJCL3dGSEJFQWdCQ0FITmdJUVFRZ2hCU0FCUVFoMElBSnFJUUlNQVFzZ0FVR1BBVTBFUUNBRUlBYzJBaEFnQVVFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZDeUFGUVFGcklRVWdBa0VCZENFQ0lBTkJBWFFpQTBHQWdBSkpEUUFMSUFNaEFTQUpJQWxGSUFvYkN5RUdJRnBCRUhJaUF5QUdSUTBCR2dzZ0FTQVNJQWdvQWdSQkZIWkJCSEVnQ0VFRWF5SUpLQUlBUVJaMlFRRnhJQU5CRDNaQkVIRWdBMEVUZGtIQUFIRWdBMEVEZGtHcUFYRnljbkp5SWhOQjRMa0JhaTBBQUVFQ2RHb2lEQ2dDQUNJSEtBSUFJZ1pySVFFQ2Z5QUdJQUpCRUhaTkJFQWdBaUFHUVJCMGF5RUNJQUZCZ0lBQ2NRUkFJQWNvQWdRTUFnc2dCeWdDQkNFS0lBd2dCMEVNUVFnZ0FTQUdTU0lNRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUVlnQnkwQUFFSC9BVWNFUUNBRUlBVTJBaEJCQ0NFRklBWkJDSFFnQW1vaEFnd0JDeUFHUVk4QlRRUkFJQVFnQlRZQ0VDQUdRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dDa1VnQ2lBTUd3d0JDeUFIS0FJRUlRb2dEQ0FIUVFoQkRDQUJJQVpKSWd3YmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUndSQUlBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNEQUVMSUFGQmp3Rk5CRUFnQkNBRk5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0NpQUtSU0FNR3dzaEJpQUxJQlJCQW5ScUlCVWdEaUFHSUJOQjRMc0JhaTBBQUhNaUJoczJBZ0FnQ1NBSktBSUFRWUFDY2pZQ0FDQUlJQWdvQWdSQndBQnlOZ0lFSUFNZ0JrRVdkSEpCZ0FGeUN5RURJQUVnRWlBRUtBSnNJQU5CQm5aQjd3TnhhaTBBQUVFQ2RHb2lDU2dDQUNJSEtBSUFJZ1pySVFFQ2Z5QUdJQUpCRUhaTkJFQWdBaUFHUVJCMGF5RUNJQUZCZ0lBQ2NRUkFJQWNvQWdRTUFnc2dCeWdDQkNFTUlBa2dCMEVNUVFnZ0FTQUdTU0lLRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQ1NBSExRQUJJUVlnQnkwQUFFSC9BVWNFUUNBRUlBazJBaEJCQ0NFRklBWkJDSFFnQW1vaEFnd0JDeUFHUVk4QlRRUkFJQVFnQ1RZQ0VDQUdRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dERVVnRENBS0d3d0JDeUFIS0FJRUlRd2dDU0FIUVFoQkRDQUJJQVpKSWdvYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFSklBY3RBQUVoQVNBSExRQUFRZjhCUndSQUlBUWdDVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNEQUVMSUFGQmp3Rk5CRUFnQkNBSk5nSVFJQUZCQ1hRZ0Ftb2hBa0VISVFVTUFRc2dCQ0FFS0FJTVFRRnFOZ0lNSUFKQmdQNERhaUVDUVFnaEJRc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0RDQU1SU0FLR3d0RkRRRUxJQUVnRWlBSUtBSUVRUmQyUVFSeElBaEJCR3NpQ1NnQ0FFRVpka0VCY1NBRFFSSjJRUkJ4SUFOQkZuWkJ3QUJ4SUFOQkJuWkJxZ0Z4Y25KeWNpSVRRZUM1QVdvdEFBQkJBblJxSWd3b0FnQWlCeWdDQUNJR2F5RUJBbjhnQmlBQ1FSQjJUUVJBSUFJZ0JrRVFkR3NoQWlBQlFZQ0FBbkVFUUNBSEtBSUVEQUlMSUFjb0FnUWhDaUFNSUFkQkRFRUlJQUVnQmtraURCdHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lIUVFGcUlRVWdCeTBBQVNFR0lBY3RBQUJCL3dGSEJFQWdCQ0FGTmdJUVFRZ2hCU0FHUVFoMElBSnFJUUlNQVFzZ0JrR1BBVTBFUUNBRUlBVTJBaEFnQmtFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZDeUFGUVFGcklRVWdBa0VCZENFQ0lBRkJBWFFpQVVHQWdBSkpEUUFMSUFwRklBb2dEQnNNQVFzZ0J5Z0NCQ0VLSUF3Z0IwRUlRUXdnQVNBR1NTSU1HMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRRWdCeTBBQUVIL0FVY0VRQ0FFSUFVMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWd3QkN5QUJRWThCVFFSQUlBUWdCVFlDRUNBQlFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdCa0VCZENJR1FZQ0FBa2tOQUFzZ0JpRUJJQW9nQ2tVZ0RCc0xJUVlnQ3lBa1FRSjBhaUFWSUE0Z0JpQVRRZUM3QVdvdEFBQnpJZ1liTmdJQUlBa2dDU2dDQUVHQUVISTJBZ0FnQ0NBSUtBSUVRWUFFY2pZQ0JDQURJQVpCR1hSeVFZQUljaUVEQ3lBQklCSWdCQ2dDYkNBRFFRbDJRZThEY1dvdEFBQkJBblJxSWdrb0FnQWlCeWdDQUNJR2F5RUJBbjhnQmlBQ1FSQjJUUVJBSUFJZ0JrRVFkR3NoQWlBQlFZQ0FBbkVFUUNBSEtBSUVEQUlMSUFjb0FnUWhEQ0FKSUFkQkRFRUlJQUVnQmtraUNodHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lIUVFGcUlRVWdCeTBBQVNFR0lBY3RBQUJCL3dGSEJFQWdCQ0FGTmdJUVFRZ2hCU0FHUVFoMElBSnFJUUlNQVFzZ0JrR1BBVTBFUUNBRUlBVTJBaEFnQmtFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZDeUFGUVFGcklRVWdBa0VCZENFQ0lBRkJBWFFpQVVHQWdBSkpEUUFMSUF4RklBd2dDaHNNQVFzZ0J5Z0NCQ0VNSUFrZ0IwRUlRUXdnQVNBR1NTSUtHMm9vQWdBMkFnQURRQUpBSUFVTkFDQUVLQUlRSWdkQkFXb2hCU0FITFFBQklRRWdCeTBBQUVIL0FVY0VRQ0FFSUFVMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWd3QkN5QUJRWThCVFFSQUlBUWdCVFlDRUNBQlFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVMSUFWQkFXc2hCU0FDUVFGMElRSWdCa0VCZENJR1FZQ0FBa2tOQUFzZ0JpRUJJQXdnREVVZ0Noc0xSUTBEQ3lBQklCSWdDQ2dDQkVFYWRrRUVjU0FJUVFScklnd29BZ0JCSEhaQkFYRWdBMEVWZGtFUWNTQURRUmwyUWNBQWNTQURRUWwyUWFvQmNYSnljbklpRTBIZ3VRRnFMUUFBUVFKMGFpSUpLQUlBSWdvb0FnQWlCbXNoQVNBR0lBSkJFSFpOQkVBZ0FpQUdRUkIwYXlFQ0lBRkJnSUFDY1EwQklBb29BZ1FoQnlBSklBcEJERUVJSUFFZ0Jra2lIQnRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJRlFRRnFJUW9nQlMwQUFTRUdJQVV0QUFCQi93RkhCRUFnQkNBS05nSVFRUWdoQlNBR1FRaDBJQUpxSVFJTUFRc2dCa0dQQVUwRVFDQUVJQW8yQWhBZ0JrRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBZEZJQWNnSEJzTUFnc2dDaWdDQkNFSElBa2dDa0VJUVF3Z0FTQUdTU0ljRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnVkJBV29oQ2lBRkxRQUJJUUVnQlMwQUFFSC9BVWNFUUNBRUlBbzJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnd0JDeUFCUVk4QlRRUkFJQVFnQ2pZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTElBVkJBV3NoQlNBQ1FRRjBJUUlnQmtFQmRDSUdRWUNBQWtrTkFBc2dCaUVCSUFjZ0IwVWdIQnNNQVFzZ0NpZ0NCQXNoQmlBTElCdEJBblJxSUJVZ0RpQUdJQk5CNExzQmFpMEFBSE1pQnhzMkFnQWdEQ0FNS0FJQVFZQ0FBWEkyQWdBZ0NDQUlLQUlFUVlBZ2NqWUNCQ0FFS0FKOFFRSjBJQWhxSWdZZ0JpZ0NCRUVFY2pZQ0JDQUdJQVlvQWd4QkFYSTJBZ3dnQmlBR0tBSUlJQWRCRW5SeVFRSnlOZ0lJSUFNZ0IwRWNkSEpCZ01BQWNpRURDeUFJSUFOQi8vLy90bnR4TmdJQUN5QUlRUVJxSVFNZ0MwRUVhaUVMSUJoQkFXb2lHQ0FVUncwQUN5QUlRUXhxSVFNZ0N5QWJRUUowYWlFTElCRkJCR29pRVNBRUtBS0FBU0lHUVh4eFNRMEFDd3dCQzBFRUlBWkJmSEVpQXlBRFFRUk5HMEVCYXlJRFFYeHhRUVJxSVJFZ0J5QURRUUYwUVhoeGFrRVVhaUVEQ3lBRUlBVTJBZ2dnQkNBQk5nSUVJQVFnQWpZQ0FDQUVJQWsyQW1nZ0ZFVU5CQ0FHSUJGTkRRUURRRUVBSVFVZ0VTQUVLQUtBQVVjRVFBTkFJQVFnQXlBTElBVWdGR3hCQW5ScUlBNGdCVUVBRUZFZ0JVRUJhaUlGSUFRb0FvQUJJQkZyU1EwQUN3c2dBeUFES0FJQVFmLy8vN1o3Y1RZQ0FDQUxRUVJxSVFzZ0EwRUVhaUVESUJkQkFXb2lGeUFVUncwQUN3d0VDMEVFSUFaQmZIRWlBeUFEUVFSTkcwRUJheUlEUVh4eFFRUnFJUkVnQnlBRFFRRjBRWGh4YWtFVWFpRURDeUFFSUFVMkFnZ2dCQ0FCTmdJRUlBUWdBallDQUNBRUlBazJBbWdnRkVVTkFpQUdJQkZORFFJRFFFRUFJUVVnRVNBRUtBS0FBVWNFUUFOQUlBUWdBeUFMSUFVZ0ZHeEJBblJxSUE0Z0JVRUJFRkVnQlVFQmFpSUZJQVFvQW9BQklCRnJTUTBBQ3dzZ0F5QURLQUlBUWYvLy83WjdjVFlDQUNBTFFRUnFJUXNnQTBFRWFpRURJQmRCQVdvaUZ5QVVSdzBBQ3d3Q0N3TkFRUUFoREFOQUlBTWhFUUpBQWtBQ2Z3SkFBa0FnQmlJTktBSUFJZ1pGQkVBZ0FTQVFLQUlBSWdNb0FnQWlCbXNoQVFKL0lBWWdBa0VRZGtzRVFDQURLQUlFSVFjZ0VDQURRUWhCRENBQklBWkpJZ29iYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUEwRUJhaUVKSUFNdEFBRWhBU0FETFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXdDQ3lBRUlBazJBaEFnQVVFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFrMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWdzZ0JVRUJheUVGSUFKQkFYUWhBaUFHUVFGMElnWkJnSUFDU1EwQUN5QUdJUUVnQnlBSFJTQUtHd3dCQ3lBQ0lBWkJFSFJySVFJZ0FVR0FnQUp4UlFSQUlBTW9BZ1FoQnlBUUlBTkJERUVJSUFFZ0Jra2lDaHRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJR1FRRnFJUWtnQmkwQUFTRURJQVl0QUFCQi93RkdCRUFnQTBHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZEQUlMSUFRZ0NUWUNFQ0FEUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQ1RZQ0VFRUlJUVVnQTBFSWRDQUNhaUVDQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBZEZJQWNnQ2hzTUFRc2dBeWdDQkF0RkJFQWdFQ0VKREFZTElBRWdDQ2dDQUNJREtBSUFJZ1pySVFFQ2Z5QUdJQUpCRUhaTEJFQWdBeWdDQkNFSElBZ2dBMEVJUVF3Z0FTQUdTU0lLRzJvb0FnQWlBellDQUFOQUFrQWdCUTBBSUFRb0FoQWlDVUVCYWlFRklBa3RBQUVoQVNBSkxRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0J5QUhSU0FLR3d3QkN5QUNJQVpCRUhScklRSWdBVUdBZ0FKeFJRUkFJQU1vQWdRaEJ5QUlJQU5CREVFSUlBRWdCa2tpQ2h0cUtBSUFJZ00yQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2xCQVdvaEJTQUpMUUFCSVFZZ0NTMEFBRUgvQVVZRVFDQUdRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBWkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQUdRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQjBVZ0J5QUtHd3dCQ3lBREtBSUVDeUVLSUFFZ0F5Z0NBQ0lHYXlFQkFuOGdCaUFDUVJCMlN3UkFJQU1vQWdRaEJ5QUlJQU5CQ0VFTUlBRWdCa2tpRGh0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSURRUUZxSVFrZ0F5MEFBU0VCSUFNdEFBQkIvd0ZHQkVBZ0FVR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdDVFlDRUNBQlFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0NUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFaQkFYUWlCa0dBZ0FKSkRRQUxJQVloQVNBSElBZEZJQTRiREFFTElBSWdCa0VRZEdzaEFpQUJRWUNBQW5GRkJFQWdBeWdDQkNFSElBZ2dBMEVNUVFnZ0FTQUdTU0lPRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnWkJBV29oQ1NBR0xRQUJJUU1nQmkwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUpOZ0lRSUFOQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBSk5nSVFRUWdoQlNBRFFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dCMFVnQnlBT0d3d0JDeUFES0FJRUN5RURRUUFoQmlBSUlRa0NRQUpBQWtBQ2Z3SkFBa0FnQXlBS1FRRjBjZzRFQUFFREJRb0xJQUVnQ3lBTktBSUVRUkYyUVFSeElBMUJCR3NpQnlnQ0FFRVRka0VCY1hJaURrSGd1UUZxTFFBQVFRSjBhaUlKS0FJQUlnTW9BZ0FpQm1zaEFRSi9JQVlnQWtFUWRrc0VRQ0FES0FJRUlRb2dDU0FEUVFoQkRDQUJJQVpKSWhJYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlBMEVCYWlFSklBTXRBQUVoQVNBRExRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQWsyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBazJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBR1FRRjBJZ1pCZ0lBQ1NRMEFDeUFHSVFFZ0NpQUtSU0FTR3d3QkN5QUNJQVpCRUhScklRSWdBVUdBZ0FKeFJRUkFJQU1vQWdRaENpQUpJQU5CREVFSUlBRWdCa2tpRWh0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUdRUUZxSVFrZ0JpMEFBU0VESUFZdEFBQkIvd0ZHQkVBZ0EwR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdDVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0NUWUNFRUVJSVFVZ0EwRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQXBGSUFvZ0Voc01BUXNnQXlnQ0JBc2hBeUFSSUJNZ0ZDQURJQTVCNExzQmFpMEFBSE1pQXhzMkFnQWdCeUFIS0FJQVFTQnlOZ0lBSUEwZ0RTZ0NCRUVJY2pZQ0JDQURRUk4wSVZzZ0FTQUxJQVFvQW13dEFBSkJBblJxSWdjb0FnQWlBeWdDQUNJR2F5RUJBbjhnQmlBQ1FSQjJTd1JBSUFNb0FnUWhDU0FISUFOQkNFRU1JQUVnQmtraURodHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lEUVFGcUlRY2dBeTBBQVNFQklBTXRBQUJCL3dGR0JFQWdBVUdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFRkRBSUxJQVFnQnpZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCellDRUVFSUlRVWdBVUVJZENBQ2FpRUNDeUFGUVFGcklRVWdBa0VCZENFQ0lBWkJBWFFpQmtHQWdBSkpEUUFMSUFZaEFTQUpJQWxGSUE0YkRBRUxJQUlnQmtFUWRHc2hBaUFCUVlDQUFuRkZCRUFnQXlnQ0JDRUpJQWNnQTBFTVFRZ2dBU0FHU1NJT0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ1pCQVdvaEJ5QUdMUUFCSVFNZ0JpMEFBRUgvQVVZRVFDQURRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FITmdJUUlBTkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUhOZ0lRUVFnaEJTQURRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnQ1VVZ0NTQU9Hd3dCQ3lBREtBSUVDeUVESUZ0QkVISWlCaUFEUlEwQkdnc2dBU0FMSUEwb0FnUkJGSFpCQkhFZ0RVRUVheUlKS0FJQVFSWjJRUUZ4SUFaQkQzWkJFSEVnQmtFVGRrSEFBSEVnQmtFRGRrR3FBWEZ5Y25KeUloSkI0TGtCYWkwQUFFRUNkR29pQ2lnQ0FDSUhLQUlBSWdOcklRRUNmeUFESUFKQkVIWkxCRUFnQnlnQ0JDRU9JQW9nQjBFSVFRd2dBU0FEU1NJS0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFFZ0J5MEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnQXlFQklBNGdEa1VnQ2hzTUFRc2dBaUFEUVJCMGF5RUNJQUZCZ0lBQ2NVVUVRQ0FIS0FJRUlRNGdDaUFIUVF4QkNDQUJJQU5KSWdvYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQXlBSExRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBTkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFPUlNBT0lBb2JEQUVMSUFjb0FnUUxJUU1nRVNBVElCUWdBeUFTUWVDN0FXb3RBQUJ6SWdNYk5nS0FBaUFKSUFrb0FnQkJnQUp5TmdJQUlBMGdEU2dDQkVIQUFISTJBZ1FnQmlBRFFSWjBja0dBQVhJTElRWWdBU0FMSUFRb0Ftd2dCa0VHZGtIdkEzRnFMUUFBUVFKMGFpSUpLQUlBSWdjb0FnQWlBMnNoQVFKL0lBTWdBa0VRZGtzRVFDQUhLQUlFSVFvZ0NTQUhRUWhCRENBQklBTkpJZzRiYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVKSUFjdEFBRWhBU0FITFFBQVFmOEJSZ1JBSUFGQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXdDQ3lBRUlBazJBaEFnQVVFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFrMkFoQkJDQ0VGSUFGQkNIUWdBbW9oQWdzZ0JVRUJheUVGSUFKQkFYUWhBaUFEUVFGMElnTkJnSUFDU1EwQUN5QURJUUVnQ2lBS1JTQU9Hd3dCQ3lBQ0lBTkJFSFJySVFJZ0FVR0FnQUp4UlFSQUlBY29BZ1FoQ2lBSklBZEJERUVJSUFFZ0Ewa2lEaHRxS0FJQU5nSUFBMEFDUUNBRkRRQWdCQ2dDRUNJSFFRRnFJUWtnQnkwQUFTRURJQWN0QUFCQi93RkdCRUFnQTBHUUFVOEVRQ0FFSUFRb0FneEJBV28yQWd3Z0FrR0EvZ05xSVFKQkNDRUZEQUlMSUFRZ0NUWUNFQ0FEUVFsMElBSnFJUUpCQnlFRkRBRUxJQVFnQ1RZQ0VFRUlJUVVnQTBFSWRDQUNhaUVDQ3lBRlFRRnJJUVVnQWtFQmRDRUNJQUZCQVhRaUFVR0FnQUpKRFFBTElBcEZJQW9nRGhzTUFRc2dCeWdDQkF0RkRRRUxJQUVnQ3lBTktBSUVRUmQyUVFSeElBMUJCR3NpQ1NnQ0FFRVpka0VCY1NBR1FSSjJRUkJ4SUFaQkZuWkJ3QUJ4SUFaQkJuWkJxZ0Z4Y25KeWNpSVNRZUM1QVdvdEFBQkJBblJxSWdvb0FnQWlCeWdDQUNJRGF5RUJBbjhnQXlBQ1FSQjJTd1JBSUFjb0FnUWhEaUFLSUFkQkNFRU1JQUVnQTBraUNodHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lIUVFGcUlRVWdCeTBBQVNFQklBY3RBQUJCL3dGR0JFQWdBVUdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFRkRBSUxJQVFnQlRZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNDeUFGUVFGcklRVWdBa0VCZENFQ0lBTkJBWFFpQTBHQWdBSkpEUUFMSUFNaEFTQU9JQTVGSUFvYkRBRUxJQUlnQTBFUWRHc2hBaUFCUVlDQUFuRkZCRUFnQnlnQ0JDRU9JQW9nQjBFTVFRZ2dBU0FEU1NJS0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFNZ0J5MEFBRUgvQVVZRVFDQURRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBTkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQURRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnRGtVZ0RpQUtHd3dCQ3lBSEtBSUVDeUVESUJFZ0V5QVVJQU1nRWtIZ3V3RnFMUUFBY3lJREd6WUNnQVFnQ1NBSktBSUFRWUFRY2pZQ0FDQU5JQTBvQWdSQmdBUnlOZ0lFSUFZZ0EwRVpkSEpCZ0FoeUlRWUxJQUVnQ3lBRUtBSnNJQVpCQ1haQjd3TnhhaTBBQUVFQ2RHb2lDU2dDQUNJSEtBSUFJZ05ySVFFQ2Z5QURJQUpCRUhaTEJFQWdCeWdDQkNFS0lBa2dCMEVJUVF3Z0FTQURTU0lPRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUUVnQnkwQUFFSC9BVVlFUUNBQlFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRk5nSVFRUWdoQlNBQlFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQTBFQmRDSURRWUNBQWtrTkFBc2dBeUVCSUFvZ0NrVWdEaHNNQVFzZ0FpQURRUkIwYXlFQ0lBRkJnSUFDY1VVRVFDQUhLQUlFSVFvZ0NTQUhRUXhCQ0NBQklBTkpJZzRiYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBeUFITFFBQVFmOEJSZ1JBSUFOQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXdDQ3lBRUlBVTJBaEFnQTBFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFVMkFoQkJDQ0VGSUFOQkNIUWdBbW9oQWdzZ0JVRUJheUVGSUFKQkFYUWhBaUFCUVFGMElnRkJnSUFDU1EwQUN5QUtSU0FLSUE0YkRBRUxJQWNvQWdRTFJRMEZDeUFCSUFzZ0RTZ0NCRUVhZGtFRWNTQU5RUVJySWc0b0FnQkJISFpCQVhFZ0JrRVZka0VRY1NBR1FSbDJRY0FBY1NBR1FRbDJRYW9CY1hKeWNuSWlDa0hndVFGcUxRQUFRUUowYWlJSktBSUFJZ2NvQWdBaUEyc2hBU0FESUFKQkVIWkxCRUFnQnlnQ0JDRVNJQWtnQjBFSVFRd2dBU0FEU1NJVkcyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFFZ0J5MEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnQXlFQklCSWdFa1VnRlJzTUJBc2dBaUFEUVJCMGF5RUNJQUZCZ0lBQ2NRMEJJQWNvQWdRaEVpQUpJQWRCREVFSUlBRWdBMGtpRlJ0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUhRUUZxSVFVZ0J5MEFBU0VESUFjdEFBQkIvd0ZHQkVBZ0EwR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdCVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JUWUNFRUVJSVFVZ0EwRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQkpGSUJJZ0ZSc01Bd3NDUUNBR1FaQ0FnQUZ4RFFBZ0FTQUxJQVFvQW13Z0JrSHZBM0ZxTFFBQVFRSjBhaUlKS0FJQUlnY29BZ0FpQTJzaEFRSi9JQU1nQWtFUWRrc0VRQ0FIS0FJRUlRb2dDU0FIUVFoQkRDQUJJQU5KSWc0YmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQVNBSExRQUFRZjhCUmdSQUlBRkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0FVRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBRkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBRFFRRjBJZ05CZ0lBQ1NRMEFDeUFESVFFZ0NpQUtSU0FPR3d3QkN5QUNJQU5CRUhScklRSWdBVUdBZ0FKeFJRUkFJQWNvQWdRaENpQUpJQWRCREVFSUlBRWdBMGtpRGh0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUhRUUZxSVFVZ0J5MEFBU0VESUFjdEFBQkIvd0ZHQkVBZ0EwR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdCVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JUWUNFRUVJSVFVZ0EwRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQXBGSUFvZ0Roc01BUXNnQnlnQ0JBdEZEUUFnQVNBTElBMG9BZ1JCRVhaQkJIRWdEVUVFYXlJS0tBSUFRUk4yUVFGeElBWkJEblpCRUhFZ0JrRVFka0hBQUhFZ0JrR3FBWEZ5Y25KeUloSkI0TGtCYWkwQUFFRUNkR29pQ1NnQ0FDSUhLQUlBSWdOcklRRUNmeUFESUFKQkVIWkxCRUFnQnlnQ0JDRU9JQWtnQjBFSVFRd2dBU0FEU1NJVkcyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFFZ0J5MEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnQXlFQklBNGdEa1VnRlJzTUFRc2dBaUFEUVJCMGF5RUNJQUZCZ0lBQ2NVVUVRQ0FIS0FJRUlRNGdDU0FIUVF4QkNDQUJJQU5KSWhVYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQXlBSExRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBTkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFPUlNBT0lCVWJEQUVMSUFjb0FnUUxJUU1nRVNBVElCUWdBeUFTUWVDN0FXb3RBQUJ6SWdNYk5nSUFJQW9nQ2lnQ0FFRWdjallDQUNBTklBMG9BZ1JCQ0hJMkFnUWdCaUFEUVJOMGNrRVFjaUVHQ3dKQUlBWkJnSUdBQ0hFTkFDQUJJQXNnQkNnQ2JDQUdRUU4ySWc1Qjd3TnhhaTBBQUVFQ2RHb2lDU2dDQUNJSEtBSUFJZ05ySVFFQ2Z5QURJQUpCRUhaTEJFQWdCeWdDQkNFS0lBa2dCMEVJUVF3Z0FTQURTU0lTRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUUVnQnkwQUFFSC9BVVlFUUNBQlFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRk5nSVFRUWdoQlNBQlFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQTBFQmRDSURRWUNBQWtrTkFBc2dBeUVCSUFvZ0NrVWdFaHNNQVFzZ0FpQURRUkIwYXlFQ0lBRkJnSUFDY1VVRVFDQUhLQUlFSVFvZ0NTQUhRUXhCQ0NBQklBTkpJaEliYWlnQ0FEWUNBQU5BQWtBZ0JRMEFJQVFvQWhBaUIwRUJhaUVGSUFjdEFBRWhBeUFITFFBQVFmOEJSZ1JBSUFOQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBSkJnUDREYWlFQ1FRZ2hCUXdDQ3lBRUlBVTJBaEFnQTBFSmRDQUNhaUVDUVFjaEJRd0JDeUFFSUFVMkFoQkJDQ0VGSUFOQkNIUWdBbW9oQWdzZ0JVRUJheUVGSUFKQkFYUWhBaUFCUVFGMElnRkJnSUFDU1EwQUN5QUtSU0FLSUJJYkRBRUxJQWNvQWdRTFJRMEFJQUVnQ3lBTktBSUVRUlIyUVFSeElBMUJCR3NpQ2lnQ0FFRVdka0VCY1NBR1FROTJRUkJ4SUFaQkUzWkJ3QUJ4SUE1QnFnRnhjbkp5Y2lJU1FlQzVBV290QUFCQkFuUnFJZ2tvQWdBaUJ5Z0NBQ0lEYXlFQkFuOGdBeUFDUVJCMlN3UkFJQWNvQWdRaERpQUpJQWRCQ0VFTUlBRWdBMGtpRlJ0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUhRUUZxSVFVZ0J5MEFBU0VCSUFjdEFBQkIvd0ZHQkVBZ0FVR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdCVFlDRUNBQlFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JUWUNFRUVJSVFVZ0FVRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFOQkFYUWlBMEdBZ0FKSkRRQUxJQU1oQVNBT0lBNUZJQlViREFFTElBSWdBMEVRZEdzaEFpQUJRWUNBQW5GRkJFQWdCeWdDQkNFT0lBa2dCMEVNUVFnZ0FTQURTU0lWRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUU1nQnkwQUFFSC9BVVlFUUNBRFFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUZOZ0lRSUFOQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRk5nSVFRUWdoQlNBRFFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQVVFQmRDSUJRWUNBQWtrTkFBc2dEa1VnRGlBVkd3d0JDeUFIS0FJRUN5RURJQkVnRXlBVUlBTWdFa0hndXdGcUxRQUFjeUlER3pZQ2dBSWdDaUFLS0FJQVFZQUNjallDQUNBTklBMG9BZ1JCd0FCeU5nSUVJQVlnQTBFV2RISkJnQUZ5SVFZTEFrQWdCa0dBaUlEQUFIRU5BQ0FCSUFzZ0JDZ0NiQ0FHUVFaMklnNUI3d054YWkwQUFFRUNkR29pQ1NnQ0FDSUhLQUlBSWdOcklRRUNmeUFESUFKQkVIWkxCRUFnQnlnQ0JDRUtJQWtnQjBFSVFRd2dBU0FEU1NJU0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFFZ0J5MEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0EwRUJkQ0lEUVlDQUFra05BQXNnQXlFQklBb2dDa1VnRWhzTUFRc2dBaUFEUVJCMGF5RUNJQUZCZ0lBQ2NVVUVRQ0FIS0FJRUlRb2dDU0FIUVF4QkNDQUJJQU5KSWhJYmFpZ0NBRFlDQUFOQUFrQWdCUTBBSUFRb0FoQWlCMEVCYWlFRklBY3RBQUVoQXlBSExRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQUpCZ1A0RGFpRUNRUWdoQlF3Q0N5QUVJQVUyQWhBZ0EwRUpkQ0FDYWlFQ1FRY2hCUXdCQ3lBRUlBVTJBaEJCQ0NFRklBTkJDSFFnQW1vaEFnc2dCVUVCYXlFRklBSkJBWFFoQWlBQlFRRjBJZ0ZCZ0lBQ1NRMEFDeUFLUlNBS0lCSWJEQUVMSUFjb0FnUUxSUTBBSUFFZ0N5QU5LQUlFUVJkMlFRUnhJQTFCQkdzaUNpZ0NBRUVaZGtFQmNTQUdRUkoyUVJCeElBWkJGblpCd0FCeElBNUJxZ0Z4Y25KeWNpSVNRZUM1QVdvdEFBQkJBblJxSWdrb0FnQWlCeWdDQUNJRGF5RUJBbjhnQXlBQ1FSQjJTd1JBSUFjb0FnUWhEaUFKSUFkQkNFRU1JQUVnQTBraUZSdHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lIUVFGcUlRVWdCeTBBQVNFQklBY3RBQUJCL3dGR0JFQWdBVUdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFRkRBSUxJQVFnQlRZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNDeUFGUVFGcklRVWdBa0VCZENFQ0lBTkJBWFFpQTBHQWdBSkpEUUFMSUFNaEFTQU9JQTVGSUJVYkRBRUxJQUlnQTBFUWRHc2hBaUFCUVlDQUFuRkZCRUFnQnlnQ0JDRU9JQWtnQjBFTVFRZ2dBU0FEU1NJVkcyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ2RCQVdvaEJTQUhMUUFCSVFNZ0J5MEFBRUgvQVVZRVFDQURRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBTkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQURRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0FVRUJkQ0lCUVlDQUFra05BQXNnRGtVZ0RpQVZHd3dCQ3lBSEtBSUVDeUVESUJFZ0V5QVVJQU1nRWtIZ3V3RnFMUUFBY3lJREd6WUNnQVFnQ2lBS0tBSUFRWUFRY2pZQ0FDQU5JQTBvQWdSQmdBUnlOZ0lFSUFZZ0EwRVpkSEpCZ0FoeUlRWUxJQVpCZ01DQWdBUnhEUU1nQVNBTElBUW9BbXdnQmtFSmRpSVNRZThEY1dvdEFBQkJBblJxSWdrb0FnQWlBU2dDQUNJRGF5RUhBbjhnQXlBQ1FSQjJTd1JBSUFFb0FnUWhDaUFKSUFGQkNFRU1JQU1nQjBzaURodHFLQUlBTmdJQUEwQUNRQ0FGRFFBZ0JDZ0NFQ0lIUVFGcUlRVWdCeTBBQVNFQklBY3RBQUJCL3dGR0JFQWdBVUdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQWtHQS9nTnFJUUpCQ0NFRkRBSUxJQVFnQlRZQ0VDQUJRUWwwSUFKcUlRSkJCeUVGREFFTElBUWdCVFlDRUVFSUlRVWdBVUVJZENBQ2FpRUNDeUFGUVFGcklRVWdBa0VCZENFQ0lBTkJBWFFpQTBHQWdBSkpEUUFMSUFNaEJ5QUtJQXBGSUE0YkRBRUxJQUlnQTBFUWRHc2hBaUFIUVlDQUFuRkZCRUFnQVNnQ0JDRUtJQWtnQVVFTVFRZ2dBeUFIU3lJT0cyb29BZ0EyQWdBRFFBSkFJQVVOQUNBRUtBSVFJZ05CQVdvaEJTQURMUUFCSVFFZ0F5MEFBRUgvQVVZRVFDQUJRWkFCVHdSQUlBUWdCQ2dDREVFQmFqWUNEQ0FDUVlEK0Eyb2hBa0VJSVFVTUFnc2dCQ0FGTmdJUUlBRkJDWFFnQW1vaEFrRUhJUVVNQVFzZ0JDQUZOZ0lRUVFnaEJTQUJRUWgwSUFKcUlRSUxJQVZCQVdzaEJTQUNRUUYwSVFJZ0IwRUJkQ0lIUVlDQUFra05BQXNnQ2tVZ0NpQU9Hd3dCQ3lBQktBSUVDMFVFUUNBSElRRU1CQXNnQnlBTElBMG9BZ1JCR25aQkJIRWdEVUVFYXlJT0tBSUFRUngyUVFGeElBWkJGWFpCRUhFZ0JrRVpka0hBQUhFZ0VrR3FBWEZ5Y25KeUlncEI0TGtCYWkwQUFFRUNkR29pQ1NnQ0FDSUhLQUlBSWdGcklRTWdBU0FDUVJCMlN3UkFJQWNvQWdRaEVpQUpJQWRCQ0VFTUlBRWdBMHNpRlJ0cUtBSUFOZ0lBQTBBQ1FDQUZEUUFnQkNnQ0VDSUhRUUZxSVFVZ0J5MEFBU0VESUFjdEFBQkIvd0ZHQkVBZ0EwR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dBa0dBL2dOcUlRSkJDQ0VGREFJTElBUWdCVFlDRUNBRFFRbDBJQUpxSVFKQkJ5RUZEQUVMSUFRZ0JUWUNFRUVJSVFVZ0EwRUlkQ0FDYWlFQ0N5QUZRUUZySVFVZ0FrRUJkQ0VDSUFGQkFYUWlBVUdBZ0FKSkRRQUxJQklnRWtVZ0ZSc01Bd3NnQWlBQlFSQjBheUVDSUFOQmdJQUNjVVVOQVNBRElRRUxJQWNvQWdRTUFRc2dCeWdDQkNFU0lBa2dCMEVNUVFnZ0FTQURTeUlWRzJvb0FnQTJBZ0FEUUFKQUlBVU5BQ0FFS0FJUUlnZEJBV29oQlNBSExRQUJJUUVnQnkwQUFFSC9BVVlFUUNBQlFaQUJUd1JBSUFRZ0JDZ0NERUVCYWpZQ0RDQUNRWUQrQTJvaEFrRUlJUVVNQWdzZ0JDQUZOZ0lRSUFGQkNYUWdBbW9oQWtFSElRVU1BUXNnQkNBRk5nSVFRUWdoQlNBQlFRaDBJQUpxSVFJTElBVkJBV3NoQlNBQ1FRRjBJUUlnQTBFQmRDSURRWUNBQWtrTkFBc2dBeUVCSUJKRklCSWdGUnNMSVFNZ0VTQVRJQlFnQXlBS1FlQzdBV290QUFCeklnTWJOZ0tBQmlBT0lBNG9BZ0JCZ0lBQmNqWUNBQ0FOSUEwb0FnUkJnQ0J5TmdJRUlBMGdEU2dDaEFKQkJISTJBb1FDSUEwZ0RTZ0NqQUpCQVhJMkFvd0NJQTBnRFNnQ2lBSWdBMEVTZEhKQkFuSTJBb2dDSUFZZ0EwRWNkSEpCZ01BQWNpRUdDeUFOSUFaQi8vLy90bnR4TmdJQUN5QU5RUVJxSVFZZ0VVRUVhaUVESUF4QkFXb2lERUhBQUVjTkFBc2dEVUVNYWlFR0lCRkJoQVpxSVFNZ0YwRThTU0ZjSUJkQkJHb2hGeUJjRFFBTEN5QUVJQVUyQWdnZ0JDQUJOZ0lFSUFRZ0FqWUNBQ0FFSUFrMkFtZ0xBa0FnRmtFZ2NVVU5BQ0FFSUFSQjVBQnFOZ0pvSUFRZ0JDZ0NCQ0FFS0FKa0lnWW9BZ0FpQVdzaUFqWUNCQUpBSUFFZ0JDZ0NBQ0lGUVJCMlN3UkFJQVFnQVRZQ0JDQUVJQVpCQ0VFTUlBRWdBa3NiYWlnQ0FDSUdOZ0prSUFRb0FnZ2hBZ05BQWtBZ0FnMEFJQVFvQWhBaUIwRUJhaUVKSUFjdEFBRWhBeUFITFFBQVFmOEJSZ1JBSUFOQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBVkJnUDREYWlFRlFRZ2hBZ3dDQ3lBRUlBazJBaEFnQTBFSmRDQUZhaUVGUVFjaEFnd0JDeUFFSUFrMkFoQkJDQ0VDSUFOQkNIUWdCV29oQlFzZ0JDQUNRUUZySWdJMkFnZ2dCQ0FGUVFGMElnVTJBZ0FnQkNBQlFRRjBJZ0UyQWdRZ0FVR0FnQUpKRFFBTElBRWhBZ3dCQ3lBRUlBVWdBVUVRZEdzaUJUWUNBQ0FDUVlDQUFuRU5BQ0FFSUFaQkRFRUlJQUVnQWtzYmFpZ0NBQ0lHTmdKa0lBUW9BZ2doQVFOQUFrQWdBUTBBSUFRb0FoQWlBVUVCYWlFSElBRXRBQUVoQXlBQkxRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQVZCZ1A0RGFpRUZRUWdoQVF3Q0N5QUVJQWMyQWhBZ0EwRUpkQ0FGYWlFRlFRY2hBUXdCQ3lBRUlBYzJBaEJCQ0NFQklBTkJDSFFnQldvaEJRc2dCQ0FCUVFGcklnRTJBZ2dnQkNBRlFRRjBJZ1UyQWdBZ0JDQUNRUUYwSWdJMkFnUWdBa0dBZ0FKSkRRQUxDeUFFSUFJZ0JpZ0NBQ0lCYXlJQ05nSUVBa0FnQVNBRlFSQjJTd1JBSUFRZ0FUWUNCQ0FFSUFaQkNFRU1JQUVnQWtzYmFpZ0NBQ0lHTmdKa0lBUW9BZ2doQWdOQUFrQWdBZzBBSUFRb0FoQWlCMEVCYWlFSklBY3RBQUVoQXlBSExRQUFRZjhCUmdSQUlBTkJrQUZQQkVBZ0JDQUVLQUlNUVFGcU5nSU1JQVZCZ1A0RGFpRUZRUWdoQWd3Q0N5QUVJQWsyQWhBZ0EwRUpkQ0FGYWlFRlFRY2hBZ3dCQ3lBRUlBazJBaEJCQ0NFQ0lBTkJDSFFnQldvaEJRc2dCQ0FDUVFGcklnSTJBZ2dnQkNBRlFRRjBJZ1UyQWdBZ0JDQUJRUUYwSWdFMkFnUWdBVUdBZ0FKSkRRQUxJQUVoQWd3QkN5QUVJQVVnQVVFUWRHc2lCVFlDQUNBQ1FZQ0FBbkVOQUNBRUlBWkJERUVJSUFFZ0Frc2JhaWdDQUNJR05nSmtJQVFvQWdnaEFRTkFBa0FnQVEwQUlBUW9BaEFpQVVFQmFpRUhJQUV0QUFFaEF5QUJMUUFBUWY4QlJnUkFJQU5Ca0FGUEJFQWdCQ0FFS0FJTVFRRnFOZ0lNSUFWQmdQNERhaUVGUVFnaEFRd0NDeUFFSUFjMkFoQWdBMEVKZENBRmFpRUZRUWNoQVF3QkN5QUVJQWMyQWhCQkNDRUJJQU5CQ0hRZ0JXb2hCUXNnQkNBQlFRRnJJZ0UyQWdnZ0JDQUZRUUYwSWdVMkFnQWdCQ0FDUVFGMElnSTJBZ1FnQWtHQWdBSkpEUUFMQ3lBRUlBSWdCaWdDQUNJQmF5SUNOZ0lFQWtBZ0FTQUZRUkIyU3dSQUlBUWdBVFlDQkNBRUlBWkJDRUVNSUFFZ0Frc2JhaWdDQUNJR05nSmtJQVFvQWdnaEFnTkFBa0FnQWcwQUlBUW9BaEFpQjBFQmFpRUpJQWN0QUFFaEF5QUhMUUFBUWY4QlJnUkFJQU5Ca0FGUEJFQWdCQ0FFS0FJTVFRRnFOZ0lNSUFWQmdQNERhaUVGUVFnaEFnd0NDeUFFSUFrMkFoQWdBMEVKZENBRmFpRUZRUWNoQWd3QkN5QUVJQWsyQWhCQkNDRUNJQU5CQ0hRZ0JXb2hCUXNnQkNBQ1FRRnJJZ0kyQWdnZ0JDQUZRUUYwSWdVMkFnQWdCQ0FCUVFGMElnRTJBZ1FnQVVHQWdBSkpEUUFMSUFFaEFnd0JDeUFFSUFVZ0FVRVFkR3NpQlRZQ0FDQUNRWUNBQW5FTkFDQUVJQVpCREVFSUlBRWdBa3NiYWlnQ0FDSUdOZ0prSUFRb0FnZ2hBUU5BQWtBZ0FRMEFJQVFvQWhBaUFVRUJhaUVISUFFdEFBRWhBeUFCTFFBQVFmOEJSZ1JBSUFOQmtBRlBCRUFnQkNBRUtBSU1RUUZxTmdJTUlBVkJnUDREYWlFRlFRZ2hBUXdDQ3lBRUlBYzJBaEFnQTBFSmRDQUZhaUVGUVFjaEFRd0JDeUFFSUFjMkFoQkJDQ0VCSUFOQkNIUWdCV29oQlFzZ0JDQUJRUUZySWdFMkFnZ2dCQ0FGUVFGMElnVTJBZ0FnQkNBQ1FRRjBJZ0kyQWdRZ0FrR0FnQUpKRFFBTEN5QUVJQUlnQmlnQ0FDSUJheUlDTmdJRUlBRWdCVUVRZGtzRVFDQUVJQUUyQWdRZ0JDQUdRUWhCRENBQklBSkxHMm9vQWdBMkFtUWdCQ2dDQ0NFQ0EwQUNRQ0FDRFFBZ0JDZ0NFQ0lHUVFGcUlRY2dCaTBBQVNFRElBWXRBQUJCL3dGR0JFQWdBMEdRQVU4RVFDQUVJQVFvQWd4QkFXbzJBZ3dnQlVHQS9nTnFJUVZCQ0NFQ0RBSUxJQVFnQnpZQ0VDQURRUWwwSUFWcUlRVkJCeUVDREFFTElBUWdCellDRUVFSUlRSWdBMEVJZENBRmFpRUZDeUFFSUFKQkFXc2lBallDQ0NBRUlBVkJBWFFpQlRZQ0FDQUVJQUZCQVhRaUFUWUNCQ0FCUVlDQUFra05BQXNNQVFzZ0JDQUZJQUZCRUhScklnYzJBZ0FnQWtHQWdBSnhEUUFnQkNBR1FReEJDQ0FCSUFKTEcyb29BZ0EyQW1RZ0JDZ0NDQ0VGQTBBQ1FDQUZEUUFnQkNnQ0VDSURRUUZxSVFZZ0F5MEFBU0VCSUFNdEFBQkIvd0ZHQkVBZ0FVR1FBVThFUUNBRUlBUW9BZ3hCQVdvMkFnd2dCMEdBL2dOcUlRZEJDQ0VGREFJTElBUWdCallDRUNBQlFRbDBJQWRxSVFkQkJ5RUZEQUVMSUFRZ0JqWUNFRUVJSVFVZ0FVRUlkQ0FIYWlFSEN5QUVJQVZCQVdzaUJUWUNDQ0FFSUFkQkFYUWlCellDQUNBRUlBSkJBWFFpQWpZQ0JDQUNRWUNBQWtrTkFBc0xDeUFuRFFBZ0JCQlRJQVJCd0trQk5nSmtJQVJCNEo0Qk5nSmdJQVJCZ0o4Qk5nSWNDMEVBSUI5QkFXb2lBU0FCUVFOR0lnRWJJUjhnR1NBQmF5RVpJQ1pCQVdvaUppQWdLQUlJVHcwQklCbEJBRW9OQUFzTElDZ2dLbW9oS0NBRUtBSVlJQVF2QVhBN0FBQWdLVUVCYWlJcElCb29BaXhKRFFBTEN3SkFJQ3RGRFFBQ1FDQUVLQUlZSWdFZ0JDZ0NFQ0lEUVFKcVN3UkFJQ0ZGRFFFZ0l5QUJJQVFvQWhRaUJtczJBamdnSXlBRElBWnJOZ0kwSUNNZ0FTQURhMEVDYXpZQ01DQWRRUUpCb1BJQUlDTkJNR29RQ0F3Q0N5QUVLQUlNSWdGQkEwa05BU0FoQkVBZ0l5QUJOZ0pRSUIxQkFrSHBOU0FqUWRBQWFoQUlEQUlMSUNNZ0FUWUNRQ0FkUVFKQjZUVWdJMEZBYXhBSURBRUxJQ01nQVNBRUtBSVVJZ1pyTmdJb0lDTWdBeUFHYXpZQ0pDQWpJQUVnQTJ0QkFtczJBaUFnSFVFQ1FhRHlBQ0FqUVNCcUVBZ0xJQm9vQWp4RkRRQWdCQ0FzTmdKMEN5QXdLQUlFSVFFZ0dpZ0NEQ0ZkSUJvb0FnZ2dNQ2dDQUdzaENDQXdLQUlRSWdaQkFYRUVRQ0F5S0FJY0lEZEJtQUZzYWlJSFFaQUJheWdDQUNBSWFpQUhRWmdCYXlnQ0FHc2hDQXNnWFNBQmF5RURJQVpCQW5FRVFDQXlLQUljSURkQm1BRnNhaUlCUVl3QmF5Z0NBQ0FEYWlBQlFaUUJheWdDQUdzaEF3c2dHaWdDUENJR0lRSWdCa1VFUUNBRUtBSjBJUUlMSUFRb0FvQUJJUllnQkNnQ2ZDRU5Ba0FnTHlnQ3FBWWlCMFVOQUNBV1JTQU5SWEloQVNBSFFSNU1CRUFnQVEwQlFRQWhFQU5BSUEwZ0VHd2hCRUVBSVFFRFFDQUNJQUVnQkdwQkFuUnFJaEVvQWdBaUNTQUpRUjkxSWdWeklBVnJJZ1VnQjNZRVFDQVJRUUFnQlNBdktBS29CbllpRVdzZ0VTQUpRUUJJR3pZQ0FBc2dBVUVCYWlJQklBMUhEUUFMSUJCQkFXb2lFQ0FXUncwQUN3d0JDeUFCRFFBZ0FrRUFJQTBnRm14QkFuUVFEaG9MSUFZRVFDQU5JQlpzSVFZZ0x5Z0NGRUVCUmdSQUlBWkZEUVZCQUNFQklBWkJCRThFUUNBR1FYeHhJUUZCQUNFRUEwQWdBaUFFUVFKMGFpSURJQVA5QUFJQUlsNzlHd0JCQW0zOUVTQmUvUnNCUVFKdC9Sd0JJRjc5R3dKQkFtMzlIQUlnWHYwYkEwRUNiZjBjQS8wTEFnQWdCRUVFYWlJRUlBRkhEUUFMSUFFZ0JrWU5CZ3NEUUNBQ0lBRkJBblJxSWdNZ0F5Z0NBRUVDYlRZQ0FDQUJRUUZxSWdFZ0JrY05BQXNNQlFzZ0JrVU5CQ0F3S2dJZ1F3QUFBRCtVSVdaQkFDRUVBa0FnQmtFRVNRUkFJQUloQVF3QkN5QUNJQVpCZkhFaUJFRUNkR29oQVNCbS9STWhYa0VBSVFNRFFDQUNJQU5CQW5ScUlnY2dYaUFIL1FBQ0FQMzZBZjNtQWYwTEFnQWdBMEVFYWlJRElBUkhEUUFMSUFRZ0JrWU5CUXNEUUNBQklHWWdBU2dDQUxLVU9BSUFJQUZCQkdvaEFTQUVRUUZxSWdRZ0JrY05BQXNNQkFzZ05pQTFheUVSSUM4b0FoUkJBVWNOQWlBV1JRMERJRElvQWlRaUJpQURJQkZzSWdOQkFuUnFJQWhCQW5ScUlRa2dEVUY4Y1NJTVFRRnJJZ0ZCQkhFaEN5QTJJQTBnTldwclFRSjBJUm9nQVVFQ2RrRUJha0grLy8vL0IzRWhIU0FESUFocVFRSjBJQVpxSUFKcklRcEJBQ0VJSUFGQkEwY2hGQU5BUVFBaEFRSkFJQXhGRFFBZ0NDQU5iQ0VESUFrZ0NDQVJiRUVDZEdvaEJrRUFJUWNnRkFSQUEwQWdCaUFCUVFKMGFpQUNJQUVnQTJwQkFuUnEvUUFDQUNKZS9Sc0FRUUp0L1JFZ1h2MGJBVUVDYmYwY0FTQmUvUnNDUVFKdC9Sd0NJRjc5R3dOQkFtMzlIQVA5Q3dJQUlBWWdBVUVFY2lJRVFRSjBhaUFDSUFNZ0JHcEJBblJxL1FBQ0FDSmUvUnNBUVFKdC9SRWdYdjBiQVVFQ2JmMGNBU0JlL1JzQ1FRSnQvUndDSUY3OUd3TkJBbTM5SEFQOUN3SUFJQUZCQ0dvaEFTQUhRUUpxSWdjZ0hVY05BQXNMSUFzTkFDQUdJQUZCQW5ScUlBSWdBU0FEYWtFQ2RHcjlBQUlBSWw3OUd3QkJBbTM5RVNCZS9Sc0JRUUp0L1J3QklGNzlHd0pCQW0zOUhBSWdYdjBiQTBFQ2JmMGNBLzBMQWdBZ0FVRUVhaUVCQ3dKQUlBRWdEVThOQUNBSUlBMXNJUU1nQ1NBSUlCRnNRUUowYWlFSEFrQWdEU0FCYXlJUVFRUkpCRUFnQVNFRURBRUxJQW9nQ0NBYWJHcEJFRWtFUUNBQklRUU1BUXNnQVNBUVFYeHhJZ1ZxSVFSQkFDRUdBMEFnQnlBQklBWnFJaUZCQW5ScUlBSWdBeUFoYWtFQ2RHcjlBQUlBSWw3OUd3QkJBbTM5RVNCZS9Sc0JRUUp0L1J3QklGNzlHd0pCQW0zOUhBSWdYdjBiQTBFQ2JmMGNBLzBMQWdBZ0JrRUVhaUlHSUFWSERRQUxJQVVnRUVZTkFRc2dCRUVCYWlFQklBMGdCR3RCQVhFRVFDQUhJQVJCQW5ScUlBSWdBeUFFYWtFQ2RHb29BZ0JCQW0wMkFnQWdBU0VFQ3lBQklBMUdEUUFEUUNBSElBUkJBblJxSUFJZ0F5QUVha0VDZEdvb0FnQkJBbTAyQWdBZ0J5QUVRUUZxSWdGQkFuUnFJQUlnQVNBRGFrRUNkR29vQWdCQkFtMDJBZ0FnQkVFQ2FpSUVJQTFIRFFBTEN5QUlRUUZxSWdnZ0ZrY05BQXNNQXdzZ0l5QVpOZ0lBSUIxQkFrSFd3QUFnSXhBSUN5QVFLQUlBUVFBMkFnQU1BUXNnRmtVTkFDQU5SUTBBSURJb0FpUWdBeUFSYkVFQ2RHb2dDRUVDZEdvaEJ5QU5RWHh4SWdOQkFuUWhCaUF3S2dJZ1F3QUFBRCtVSW1iOUV5RmVRUUFoRUNBTlFRUkpJUWdEUUFKQUFrQWdDQVJBSUFJaENTQUhJUUZCQUNFRURBRUxJQVlnQjJvaEFTQUNJQVpxSVFsQkFDRUVBMEFnQnlBRVFRSjBJZ1ZxSUY0Z0FpQUZhdjBBQWdEOStnSDk1Z0g5Q3dJQUlBUkJCR29pQkNBRFJ3MEFDeUFKSVFJZ0F5SUVJQTFHRFFFTElBa2hBZ05BSUFFZ1ppQUNLQUlBc3BRNEFnQWdBVUVFYWlFQklBSkJCR29oQWlBRVFRRnFJZ1FnRFVjTkFBc0xJQWNnRVVFQ2RHb2hCeUFRUVFGcUloQWdGa2NOQUFzTElBQVFDU0FqUWVBQWFpUUFDOVlFQVFsL0lBQW9BaXhCQ0U4RVFDQUFLQUlvSVFWQkNDRUtBMEFnQUNnQ0RFRUZkQ0VJSUFBb0FnQWhCQ0FBS0FJa0lRTUNRQ0FBS0FJVUlnWWdBQ2dDRUNJQlRRMEFJQVFnQ0dvaEJ5QUJRUUZxSVFJZ0JpQUJhMEVCY1FSQUlBY2dBVUVHZEdvaUNTQUZJQUVnQTJ4QkFuUnFJZ0g5QUFJQS9Rc0NBQ0FKSUFIOUFBSVEvUXNDRUNBQ0lRRUxJQUlnQmtZTkFBTkFJQWNnQVVFR2RHb2lBaUFGSUFFZ0EyeEJBblJxSWduOUFBSUEvUXNDQUNBQ0lBbjlBQUlRL1FzQ0VDQUhJQUZCQVdvaUFrRUdkR29pQ1NBRklBSWdBMnhCQW5ScUlnTDlBQUlRL1FzQ0VDQUpJQUw5QUFJQS9Rc0NBQ0FCUVFKcUlnRWdCa2NOQUFzTEFrQWdBQ2dDSENJR0lBQW9BaGdpQVUwTkFDQUVJQWhyUVNCcUlRY2dCU0FBS0FJSUlBTnNRUUowYWlFSUlBRkJBV29oQWlBR0lBRnJRUUZ4QkVBZ0J5QUJRUVowYWlJRUlBZ2dBU0FEYkVFQ2RHb2lBZjBBQWdEOUN3SUFJQVFnQWYwQUFoRDlDd0lRSUFJaEFRc2dBaUFHUmcwQUEwQWdCeUFCUVFaMGFpSUNJQWdnQVNBRGJFRUNkR29pQlAwQUFnRDlDd0lBSUFJZ0JQMEFBaEQ5Q3dJUUlBY2dBVUVCYWlJQ1FRWjBhaUlFSUFnZ0FpQURiRUVDZEdvaUF2MEFBaEQ5Q3dJUUlBUWdBdjBBQWdEOUN3SUFJQUZCQW1vaUFTQUdSdzBBQ3dzZ0FCQWNRUUFoQVNBQUtBSWdCRUFEUUNBRklBQW9BaVFnQVd4QkFuUnFJZ0lnQUNnQ0FDQUJRUVYwYWlJRC9RQUNBUDBMQWdBZ0FpQUQvUUFDRVAwTEFoQWdBVUVCYWlJQklBQW9BaUJKRFFBTEN5QUZRU0JxSVFVZ0NrRUlhaUlLSUFBb0FpeE5EUUFMQ3lBQUtBSUFFQWtnQUJBSkMvY05BU1YvSUFBb0FpeEJDRThFUUNBQUtBSWtJZ3BCQlhRaEhpQUtRUWRzSVJZZ0NrRUdiQ0VYSUFwQkJXd2hHQ0FLUVFOc0lSa2dDa0VCZENFYUlBQW9BaWdpQVNBS1FSeHNhaUVmSUFFZ0NrRVliR29oSUNBQklBcEJGR3hxSVNFZ0FTQUtRUVIwYWlFaUlBRWdDa0VNYkdvaEl5QUJJQXBCQTNRaUpHb2hKU0FCSUFwQkFuUWlHMm9oSmtFSUlSd0RRQ0FBSUFFZ0FDZ0NKRUVJRURRZ0FCQWNBa0FnQUNnQ0lDSUxSUTBBSUIwZ0htd2hDQ0FBS0FJQUlRWkJBQ0VFQWtBQ1FDQUxRZWdDU1EwQUlBWkJER29pRGlBTFFRRnJJZ0pCQlhRaUEyb2dEa2tOQUNBR1FRaHFJZzhnQTJvZ0Qwa05BQ0FESUFacUlBWkpEUUFnQmtFRWFpSVFJQU5xSUJCSkRRQWdBa0gvLy84L1N3MEFJQUVnQ0NBbWFpSURJQXRCQW5RaUJXb2lERWtnQXlBQklBVnFJZ2RKY1EwQUlBRWdDQ0FsYWlJQ0lBVnFJZzFKSUFJZ0IwbHhEUUFnQVNBRklBZ2dJMm9pQ1dvaUJVa2dCeUFKUzNFTkFDQUdJQWRKSUFFZ0JpQUxRUVYwYWlJUlFSeHJJaEpKY1EwQUlBRWdFVUVZYXlJVFNTQUhJQkJMY1EwQUlBRWdFVUVVYXlJVVNTQUhJQTlMY1EwQUlBY2dEa3NnQVNBUlFSQnJJZ2RKY1EwQUlBTWdEVWtnQWlBTVNYRU5BQ0FESUFWSklBa2dERWx4RFFBZ0F5QVNTU0FHSUF4SmNRMEFJQU1nRTBrZ0RDQVFTM0VOQUNBRElCUkpJQXdnRDB0eERRQWdBeUFIU1NBTUlBNUxjUTBBSUFJZ0JVa2dDU0FOU1hFTkFDQUNJQkpKSUFZZ0RVbHhEUUFnQWlBVFNTQU5JQkJMY1EwQUlBSWdGRWtnRFNBUFMzRU5BQ0FDSUFkSklBMGdEa3R4RFFBZ0NTQVNTU0FGSUFaTGNRMEFJQWtnRTBrZ0JTQVFTM0VOQUNBSklCUkpJQVVnRDB0eERRQWdCeUFKU3lBRklBNUxjUTBBSUF0Qi9QLy8vd0J4SVFSQkFDRURBMEFnQVNBRFFRSjBhaUFHSUFOQkJYUnFJZ0w5Q1FJQUlBSXFBaUQ5SUFFZ0FrRkFheW9DQVAwZ0FpQUNLZ0pnL1NBRC9Rc0NBQ0FCSUFNZ0NtcEJBblJxSUFMOUNRSUVJQUlxQWlUOUlBRWdBaW9DUlAwZ0FpQUNLZ0prL1NBRC9Rc0NBQ0FCSUFNZ0dtcEJBblJxSUFMOUNRSUlJQUlxQWlqOUlBRWdBaW9DU1AwZ0FpQUNLZ0pvL1NBRC9Rc0NBQ0FCSUFNZ0dXcEJBblJxSUFMOUNRSU1JQUlxQWl6OUlBRWdBaW9DVFAwZ0FpQUNLZ0pzL1NBRC9Rc0NBQ0FEUVFScUlnTWdCRWNOQUFzZ0JDQUxSZzBCQ3dOQUlBRWdCRUVDZEdvZ0JpQUVRUVYwYWlJREtnSUFPQUlBSUFFZ0JDQUtha0VDZEdvZ0F5b0NCRGdDQUNBQklBUWdHbXBCQW5ScUlBTXFBZ2c0QWdBZ0FTQUVJQmxxUVFKMGFpQURLZ0lNT0FJQUlBUkJBV29pQkNBTFJ3MEFDd3NnQUNnQ0FDRUdRUUFoQkFKQUlBdEIzQUJKRFFBZ0JrRWNhaUlQSUF0QkFXc2lBa0VGZENJRGFpQVBTUTBBSUFaQkdHb2lFQ0FEYWlBUVNRMEFJQVpCRUdvaUVTQURhaUFSU1EwQUlBWkJGR29pRWlBRGFpQVNTUTBBSUFKQi8vLy9QMHNOQUNBSUlDSnFJZ01nQ0NBaGFpSUNJQXRCQW5RaUJXb2lERWtnQWlBRElBVnFJZ2RKY1EwQUlBTWdDQ0FnYWlJSklBVnFJZzFKSUFjZ0NVdHhEUUFnQXlBSUlCOXFJZ2dnQldvaUJVa2dCeUFJUzNFTkFDQURJQVlnQzBFRmRHb2lEa0VNYXlJVFNTQUhJQkZMY1EwQUlBTWdEa0VJYXlJVVNTQUhJQkpMY1EwQUlBTWdEa0VFYXlJVlNTQUhJQkJMY1EwQUlBTWdEa2tnQnlBUFMzRU5BQ0FDSUExSklBa2dERWx4RFFBZ0FpQUZTU0FJSUF4SmNRMEFJQUlnRTBrZ0RDQVJTM0VOQUNBQ0lCUkpJQXdnRWt0eERRQWdBaUFWU1NBTUlCQkxjUTBBSUFJZ0Rra2dEQ0FQUzNFTkFDQUlJQTFKSUFVZ0NVdHhEUUFnQ1NBVFNTQU5JQkZMY1EwQUlBa2dGRWtnRFNBU1MzRU5BQ0FKSUJWSklBMGdFRXR4RFFBZ0NTQU9TU0FOSUE5TGNRMEFJQWdnRTBrZ0JTQVJTM0VOQUNBSUlCUkpJQVVnRWt0eERRQWdDQ0FWU1NBRklCQkxjUTBBSUFnZ0Rra2dCU0FQUzNFTkFDQUxRZnovLy84QWNTRUVRUUFoQXdOQUlBRWdBeUFiYWtFQ2RHb2dCaUFEUVFWMGFpSUMvUWtDRUNBQ0tnSXcvU0FCSUFJcUFsRDlJQUlnQWlvQ2NQMGdBLzBMQWdBZ0FTQURJQmhxUVFKMGFpQUMvUWtDRkNBQ0tnSTAvU0FCSUFJcUFsVDlJQUlnQWlvQ2RQMGdBLzBMQWdBZ0FTQURJQmRxUVFKMGFpQUMvUWtDR0NBQ0tnSTQvU0FCSUFJcUFsajlJQUlnQWlvQ2VQMGdBLzBMQWdBZ0FTQURJQlpxUVFKMGFpQUMvUWtDSENBQ0tnSTgvU0FCSUFJcUFsejlJQUlnQWlvQ2ZQMGdBLzBMQWdBZ0EwRUVhaUlESUFSSERRQUxJQVFnQzBZTkFRc0RRQ0FCSUFRZ0cycEJBblJxSUFZZ0JFRUZkR29pQXlvQ0VEZ0NBQ0FCSUFRZ0dHcEJBblJxSUFNcUFoUTRBZ0FnQVNBRUlCZHFRUUowYWlBREtnSVlPQUlBSUFFZ0JDQVdha0VDZEdvZ0F5b0NIRGdDQUNBRVFRRnFJZ1FnQzBjTkFBc0xJQjFCQVdvaEhTQUJJQ1JCQW5ScUlRRWdIRUVJYWlJY0lBQW9BaXhORFFBTEN5QUFLQUlBRUFrZ0FCQUpDM01CQW44Z0FDZ0NIQ0lCUVFocUlnTWdBQ2dDSUNJQ1RRUkFBMEFnQUNBQUtBSVlJQUZCQW5ScUlBQW9BaFJCQ0JBcklBTWlBVUVJYWlJRElBQW9BaUFpQWswTkFBc0xJQUVnQWtrRVFDQUFJQUFvQWhnZ0FVRUNkR29nQUNnQ0ZDQUNJQUZyRUNzTElBQW9BZ0FRQ1NBQUVBa0xSQUFnQUNnQ0hDSUJJQUFvQWlCSkJFQURRQ0FBSUFBb0FoZ2dBQ2dDRkNBQmJFRUNkR29RVmlBQlFRRnFJZ0VnQUNnQ0lFa05BQXNMSUFBb0FnQVFDU0FBRUFrTHFBRUJCWDhnQUNnQ1ZDSURLQUlBSVFVZ0F5Z0NCQ0lFSUFBb0FoUWdBQ2dDSENJSGF5SUdJQVFnQmtrYklnWUVRQ0FGSUFjZ0JoQUxHaUFESUFNb0FnQWdCbW9pQlRZQ0FDQURJQU1vQWdRZ0Jtc2lCRFlDQkFzZ0JDQUNJQUlnQkVzYklnUUVRQ0FGSUFFZ0JCQUxHaUFESUFNb0FnQWdCR29pQlRZQ0FDQURJQU1vQWdRZ0JHczJBZ1FMSUFWQkFEb0FBQ0FBSUFBb0Fpd2lBVFlDSENBQUlBRTJBaFFnQWd1ZUJRSUdmZ1IvSUFFZ0FTZ0NBRUVIYWtGNGNTSUJRUkJxTmdJQUlBQWhDeUFCS1FNQUlRTWdBU2tEQ0NFSEl3QkJJR3NpQ0NRQUlBZEMvLy8vLy8vL1A0TWhCQUorSUFkQ01JaEMvLzhCZ3lJRnB5SUtRWUg0QUd0Qi9ROU5CRUFnQkVJRWhpQURRanlJaENFQ0lBcEJnUGdBYTYwaEJRSkFJQU5DLy8vLy8vLy8vLzhQZ3lJRFFvR0FnSUNBZ0lDQUNGb0VRQ0FDUWdGOElRSU1BUXNnQTBLQWdJQ0FnSUNBZ0FoU0RRQWdBa0lCZ3lBQ2ZDRUNDMElBSUFJZ0FrTC8vLy8vLy8vL0IxWWlBQnNoQWlBQXJTQUZmQXdCQ3dKQUlBTWdCSVJRRFFBZ0JVTC8vd0ZTRFFBZ0JFSUVoaUFEUWp5SWhFS0FnSUNBZ0lDQUJJUWhBa0wvRHd3QkMwTC9EeUFLUWY2SEFVc05BQnBDQUVHQStBQkJnZmdBSUFWUUlnRWJJZ0FnQ21zaUNVSHdBRW9OQUJvZ0F5RUNJQVFnQkVLQWdJQ0FnSURBQUlRZ0FSc2lCaUVFQWtCQmdBRWdDV3NpQVVIQUFIRUVRQ0FESUFGQlFHcXRoaUVFUWdBaEFnd0JDeUFCUlEwQUlBUWdBYTBpQllZZ0FrSEFBQ0FCYTYySWhDRUVJQUlnQllZaEFnc2dDQ0FDTndNUUlBZ2dCRGNER0FKQUlBbEJ3QUJ4QkVBZ0JpQUpRVUJxcllnaEEwSUFJUVlNQVFzZ0NVVU5BQ0FHUWNBQUlBbHJyWVlnQXlBSnJTSUNpSVFoQXlBR0lBS0lJUVlMSUFnZ0F6Y0RBQ0FJSUFZM0F3Z2dDQ2tEQ0VJRWhpQUlLUU1BSWdKQ1BJaUVJUU1DUUNBQUlBcEhJQWdwQXhBZ0NDa0RHSVJDQUZKeHJTQUNRdi8vLy8vLy8vLy9ENE9FSWdKQ2dZQ0FnSUNBZ0lBSVdnUkFJQU5DQVh3aEF3d0JDeUFDUW9DQWdJQ0FnSUNBQ0ZJTkFDQURRZ0dESUFOOElRTUxJQU5DZ0lDQWdJQ0FnQWlGSUFNZ0EwTC8vLy8vLy8vL0IxWWlBQnNoQWlBQXJRc2hBeUFJUVNCcUpBQWdDeUFIUW9DQWdJQ0FnSUNBZ0grRElBTkNOSWFFSUFLRXZ6a0RBQXVjR0FNVGZ3RjhBMzRqQUVHd0JHc2lEQ1FBSUF4QkFEWUNMQUpBSUFHOUlocENBRk1FUUVFQklSQkJ1Z2doRXlBQm1pSUJ2U0VhREFFTElBUkJnQkJ4QkVCQkFTRVFRYjBJSVJNTUFRdEJ3QWhCdXdnZ0JFRUJjU0lRR3lFVElCQkZJUlVMQWtBZ0drS0FnSUNBZ0lDQStQOEFnMEtBZ0lDQWdJQ0ErUDhBVVFSQUlBQkJJQ0FDSUJCQkEyb2lBeUFFUWYvL2UzRVFGQ0FBSUJNZ0VCQVJJQUJCdHdsQjlnb2dCVUVnY1NJRkcwR2dDa0g2Q2lBRkd5QUJJQUZpRzBFREVCRWdBRUVnSUFJZ0F5QUVRWURBQUhNUUZDQURJQUlnQWlBRFNCc2hDUXdCQ3lBTVFSQnFJUklDUUFKL0FrQWdBU0FNUVN4cUVGOGlBU0FCb0NJQlJBQUFBQUFBQUFBQVlnUkFJQXdnRENnQ0xDSUdRUUZyTmdJc0lBVkJJSElpRGtIaEFFY05BUXdEQ3lBRlFTQnlJZzVCNFFCR0RRSWdEQ2dDTENFS1FRWWdBeUFEUVFCSUd3d0JDeUFNSUFaQkhXc2lDallDTENBQlJBQUFBQUFBQUxCQm9pRUJRUVlnQXlBRFFRQklHd3NoQ3lBTVFUQnFRYUFDUVFBZ0NrRUFUaHRxSWcwaEJ3TkFJQWNDZnlBQlJBQUFBQUFBQVBCQll5QUJSQUFBQUFBQUFBQUFabkVFUUNBQnF3d0JDMEVBQ3lJRE5nSUFJQWRCQkdvaEJ5QUJJQU80b1VRQUFBQUFaYzNOUWFJaUFVUUFBQUFBQUFBQUFHSU5BQXNDUUNBS1FRQk1CRUFnQ2lFRElBY2hCaUFOSVFnTUFRc2dEU0VJSUFvaEF3TkFRUjBnQXlBRFFSMVBHeUVEQWtBZ0IwRUVheUlHSUFoSkRRQWdBNjBoRzBJQUlSb0RRQ0FHSUJwQy8vLy8vdytESUFZMUFnQWdHNFo4SWh4Q2dKVHIzQU9BSWhwQ2dPeVVvd3grSUJ4OFBnSUFJQVpCQkdzaUJpQUlUdzBBQ3lBYXB5SUdSUTBBSUFoQkJHc2lDQ0FHTmdJQUN3TkFJQWdnQnlJR1NRUkFJQVpCQkdzaUJ5Z0NBRVVOQVFzTElBd2dEQ2dDTENBRGF5SUROZ0lzSUFZaEJ5QURRUUJLRFFBTEN5QURRUUJJQkVBZ0MwRVpha0VKYmtFQmFpRVJJQTVCNWdCR0lROERRRUVKUVFBZ0Eyc2lBeUFEUVFsUEd5RUpBa0FnQmlBSVRRUkFJQWdvQWdCRlFRSjBJUWNNQVF0QmdKVHIzQU1nQ1hZaEZFRi9JQWwwUVg5eklSWkJBQ0VESUFnaEJ3TkFJQWNnQXlBSEtBSUFJaGNnQ1hacU5nSUFJQllnRjNFZ0ZHd2hBeUFIUVFScUlnY2dCa2tOQUFzZ0NDZ0NBRVZCQW5RaEJ5QURSUTBBSUFZZ0F6WUNBQ0FHUVFScUlRWUxJQXdnRENnQ0xDQUphaUlETmdJc0lBMGdCeUFJYWlJSUlBOGJJZ2NnRVVFQ2RHb2dCaUFHSUFkclFRSjFJQkZLR3lFR0lBTkJBRWdOQUFzTFFRQWhBd0pBSUFZZ0NFME5BQ0FOSUFoclFRSjFRUWxzSVFOQkNpRUhJQWdvQWdBaUNVRUtTUTBBQTBBZ0EwRUJhaUVESUFrZ0IwRUtiQ0lIVHcwQUN3c2dDeUFEUVFBZ0RrSG1BRWNiYXlBT1FlY0FSaUFMUVFCSGNXc2lCeUFHSUExclFRSjFRUWxzUVFsclNBUkFJQXhCTUdwQkJFR2tBaUFLUVFCSUcyb2dCMEdBeUFCcUlnbEJDVzBpRDBFQ2RHb2lFVUdBSUdzaENrRUtJUWNnRDBGM2JDQUphaUlKUVFkTUJFQURRQ0FIUVFwc0lRY2dDVUVCYWlJSlFRaEhEUUFMQ3dKQUlBb29BZ0FpRHlBUElBZHVJaFFnQjJ3aUNVWWdFVUg4SDJzaUZpQUdSbkVOQUNBUElBbHJJUThDUUNBVVFRRnhSUVJBUkFBQUFBQUFBRUJESVFFZ0IwR0FsT3ZjQTBjTkFTQUlJQXBQRFFFZ0VVR0VJR3N0QUFCQkFYRkZEUUVMUkFFQUFBQUFBRUJESVFFTFJBQUFBQUFBQU9BL1JBQUFBQUFBQVBBL1JBQUFBQUFBQVBnL0lBWWdGa1liUkFBQUFBQUFBUGcvSUE4Z0IwRUJkaUlVUmhzZ0R5QVVTUnNoR1FKQUlCVU5BQ0FUTFFBQVFTMUhEUUFnR1pvaEdTQUJtaUVCQ3lBS0lBazJBZ0FnQVNBWm9DQUJZUTBBSUFvZ0J5QUphaUlETmdJQUlBTkJnSlRyM0FOUEJFQURRQ0FLUVFBMkFnQWdDQ0FLUVFScklncExCRUFnQ0VFRWF5SUlRUUEyQWdBTElBb2dDaWdDQUVFQmFpSUROZ0lBSUFOQi81UHIzQU5MRFFBTEN5QU5JQWhyUVFKMVFRbHNJUU5CQ2lFSElBZ29BZ0FpQ1VFS1NRMEFBMEFnQTBFQmFpRURJQWtnQjBFS2JDSUhUdzBBQ3dzZ0NrRUVhaUlISUFZZ0JpQUhTeHNoQmdzRFFDQUdJZ2NnQ0UwaUNVVUVRQ0FHUVFScklnWW9BZ0JGRFFFTEN3SkFJQTVCNXdCSEJFQWdCRUVJY1NFS0RBRUxJQU5CZjNOQmZ5QUxRUUVnQ3hzaUJpQURTaUFEUVh0S2NTSUtHeUFHYWlFTFFYOUJmaUFLR3lBRmFpRUZJQVJCQ0hFaUNnMEFRWGNoQmdKQUlBa05BQ0FIUVFScktBSUFJZzVGRFFCQkNpRUpRUUFoQmlBT1FRcHdEUUFEUUNBR0lncEJBV29oQmlBT0lBbEJDbXdpQ1hCRkRRQUxJQXBCZjNNaEJnc2dCeUFOYTBFQ2RVRUpiQ0VKSUFWQlgzRkJ4Z0JHQkVCQkFDRUtJQXNnQmlBSmFrRUpheUlHUVFBZ0JrRUFTaHNpQmlBR0lBdEtHeUVMREFFTFFRQWhDaUFMSUFNZ0NXb2dCbXBCQ1dzaUJrRUFJQVpCQUVvYklnWWdCaUFMU2hzaEN3dEJmeUVKSUF0Qi9mLy8vd2RCL3YvLy93Y2dDaUFMY2lJUEcwb05BU0FMSUE5QkFFZHFRUUZxSVE0Q1FDQUZRVjl4SWhWQnhnQkdCRUFnQXlBT1FmLy8vLzhIYzBvTkF5QURRUUFnQTBFQVNoc2hCZ3dCQ3lBU0lBTWdBMEVmZFNJR2N5QUdhNjBnRWhBaklnWnJRUUZNQkVBRFFDQUdRUUZySWdaQk1Eb0FBQ0FTSUFaclFRSklEUUFMQ3lBR1FRSnJJaEVnQlRvQUFDQUdRUUZyUVMxQkt5QURRUUJJR3pvQUFDQVNJQkZySWdZZ0RrSC8vLy8vQjNOS0RRSUxJQVlnRG1vaUF5QVFRZi8vLy84SGMwb05BU0FBUVNBZ0FpQURJQkJxSWdVZ0JCQVVJQUFnRXlBUUVCRWdBRUV3SUFJZ0JTQUVRWUNBQkhNUUZBSkFBa0FDUUNBVlFjWUFSZ1JBSUF4QkVHb2lCa0VJY2lFRElBWkJDWEloQ2lBTklBZ2dDQ0FOU3hzaUNTRUlBMEFnQ0RVQ0FDQUtFQ01oQmdKQUlBZ2dDVWNFUUNBR0lBeEJFR3BORFFFRFFDQUdRUUZySWdaQk1Eb0FBQ0FHSUF4QkVHcExEUUFMREFFTElBWWdDa2NOQUNBTVFUQTZBQmdnQXlFR0N5QUFJQVlnQ2lBR2F4QVJJQWhCQkdvaUNDQU5UUTBBQ3lBUEJFQWdBRUdDREVFQkVCRUxJQWNnQ0UwTkFTQUxRUUJNRFFFRFFDQUlOUUlBSUFvUUl5SUdJQXhCRUdwTEJFQURRQ0FHUVFGcklnWkJNRG9BQUNBR0lBeEJFR3BMRFFBTEN5QUFJQVpCQ1NBTElBdEJDVTRiRUJFZ0MwRUpheUVHSUFoQkJHb2lDQ0FIVHcwRElBdEJDVW9oR0NBR0lRc2dHQTBBQ3d3Q0N3SkFJQXRCQUVnTkFDQUhJQWhCQkdvZ0J5QUlTeHNoQ1NBTVFSQnFJZ1pCQ0hJaEF5QUdRUWx5SVEwZ0NDRUhBMEFnRFNBSE5RSUFJQTBRSXlJR1JnUkFJQXhCTURvQUdDQURJUVlMQWtBZ0J5QUlSd1JBSUFZZ0RFRVFhazBOQVFOQUlBWkJBV3NpQmtFd09nQUFJQVlnREVFUWFrc05BQXNNQVFzZ0FDQUdRUUVRRVNBR1FRRnFJUVlnQ2lBTGNrVU5BQ0FBUVlJTVFRRVFFUXNnQUNBR0lBMGdCbXNpQmlBTElBWWdDMGdiRUJFZ0N5QUdheUVMSUFkQkJHb2lCeUFKVHcwQklBdEJBRTROQUFzTElBQkJNQ0FMUVJKcVFSSkJBQkFVSUFBZ0VTQVNJQkZyRUJFTUFnc2dDeUVHQ3lBQVFUQWdCa0VKYWtFSlFRQVFGQXNnQUVFZ0lBSWdCU0FFUVlEQUFITVFGQ0FGSUFJZ0FpQUZTQnNoQ1F3QkN5QVRJQVZCR25SQkgzVkJDWEZxSVFnQ1FDQURRUXRMRFFCQkRDQURheUVHUkFBQUFBQUFBREJBSVJrRFFDQVpSQUFBQUFBQUFEQkFvaUVaSUFaQkFXc2lCZzBBQ3lBSUxRQUFRUzFHQkVBZ0dTQUJtaUFab2FDYUlRRU1BUXNnQVNBWm9DQVpvU0VCQ3lBUVFRSnlJUXNnQlVFZ2NTRU5JQklnRENnQ0xDSUhJQWRCSDNVaUJuTWdCbXV0SUJJUUl5SUdSZ1JBSUF4Qk1Eb0FEeUFNUVE5cUlRWUxJQVpCQW1zaUNpQUZRUTlxT2dBQUlBWkJBV3RCTFVFcklBZEJBRWdiT2dBQUlBUkJDSEVoQmlBTVFSQnFJUWNEUUNBSElnVUNmeUFCbVVRQUFBQUFBQURnUVdNRVFDQUJxZ3dCQzBHQWdJQ0FlQXNpQjBIZ3hBRnFMUUFBSUExeU9nQUFJQUVnQjdlaFJBQUFBQUFBQURCQW9pRUJBa0FnQlVFQmFpSUhJQXhCRUdwclFRRkhEUUFDUUNBR0RRQWdBMEVBU2cwQUlBRkVBQUFBQUFBQUFBQmhEUUVMSUFWQkxqb0FBU0FGUVFKcUlRY0xJQUZFQUFBQUFBQUFBQUJpRFFBTFFYOGhDVUg5Ly8vL0J5QUxJQklnQ21zaUJtb2lEV3NnQTBnTkFDQUFRU0FnQWlBTklBTkJBbW9nQnlBTVFSQnFJZ2RySWdVZ0JVRUNheUFEU0JzZ0JTQURHeUlKYWlJRElBUVFGQ0FBSUFnZ0N4QVJJQUJCTUNBQ0lBTWdCRUdBZ0FSekVCUWdBQ0FISUFVUUVTQUFRVEFnQ1NBRmEwRUFRUUFRRkNBQUlBb2dCaEFSSUFCQklDQUNJQU1nQkVHQXdBQnpFQlFnQXlBQ0lBSWdBMGdiSVFrTElBeEJzQVJxSkFBZ0NRc0VBRUlBQ3dRQVFRQUxud01CQ1g5QjVnb2hBQUpBQTBBZ0FDMEFBQ0lCUlEwQklBRkJQVVlOQVNBQVFRRnFJZ0JCQTNFTkFBc0NRQUpBUVlDQ2hBZ2dBQ2dDQUNJQ2F5QUNja0dBZ1lLRWVIRkJnSUdDaEhoSERRQURRRUdBZ29RSUlBSkJ2ZnIwNlFOeklnRnJJQUZ5UVlDQmdvUjRjVUdBZ1lLRWVFY05BU0FBS0FJRUlRSWdBRUVFYWlJQklRQWdBa0dBZ29RSUlBSnJja0dBZ1lLRWVIRkJnSUdDaEhoR0RRQUxEQUVMSUFBaEFRc0RRQ0FCSWdBdEFBQWlBa1VOQVNBQVFRRnFJUUVnQWtFOVJ3MEFDd3NnQUNJQlFlWUtSZ1JBUVFBUEN3SkFJQUZCNWdwcklnQkI1Z3BxTFFBQURRQkJzTTRCS0FJQUlnUkZEUUFnQkNnQ0FDSUZSUTBBQTBBQ1FBSi9JQVVoQWtIbUNpRUdRUUFnQUNJQlJRMEFHa0htQ2kwQUFDSURCSDhDUUFOQUlBTWdBaTBBQUNJSFJ3MEJJQWRGRFFFZ0FVRUJheUlCUlEwQklBSkJBV29oQWlBR0xRQUJJUU1nQmtFQmFpRUdJQU1OQUF0QkFDRURDeUFEQlVFQUN5QUNMUUFBYXd0RkJFQWdBQ0FGYWlJQkxRQUFRVDFHRFFFTElBUW9BZ1FoQlNBRVFRUnFJUVFnQlEwQkRBSUxDeUFCUVFGcUlRZ0xJQWdMemdJQkNIOGpBRUVnYXlJREpBQWdBeUFBS0FJY0lnUTJBaEFnQUNnQ0ZDRUZJQU1nQWpZQ0hDQURJQUUyQWhnZ0F5QUZJQVJySWdFMkFoUWdBU0FDYWlFRlFRSWhCaUFEUVJCcUlRRUNmd05BQWtBQ1FBSkFJQUFvQWp3Z0FTQUdJQU5CREdvUUJDSUVCSDlCbE1ZQklBUTJBZ0JCZndWQkFBdEZCRUFnQlNBREtBSU1JZ2RHRFFFZ0IwRUFUZzBDREFNTElBVkJmMGNOQWdzZ0FDQUFLQUlzSWdFMkFod2dBQ0FCTmdJVUlBQWdBU0FBS0FJd2FqWUNFQ0FDREFNTElBRWdCeUFCS0FJRUlnaExJZ2xCQTNScUlnUWdCeUFJUVFBZ0NSdHJJZ2dnQkNnQ0FHbzJBZ0FnQVVFTVFRUWdDUnRxSWdFZ0FTZ0NBQ0FJYXpZQ0FDQUZJQWRySVFVZ0JpQUpheUVHSUFRaEFRd0JDd3NnQUVFQU5nSWNJQUJDQURjREVDQUFJQUFvQWdCQklISTJBZ0JCQUNBR1FRSkdEUUFhSUFJZ0FTZ0NCR3NMSVFvZ0EwRWdhaVFBSUFvTEJnQWdBQkFBQ3dZQUlBQVFCZ3ZQSFFNTmZ3UjdBMzRqQUVIUXdBQnJJZ2trQUNBSlFRQTJBaEJCQWlFRUFrQUNRQ0FBS0FJQUlnTkJqWlNjMUFCR0RRQWdBMEgvbi8yUEJVY0VRQUpBSUFOQmdJQ0E0QUJIRFFBZ0FDZ0NCRUhxb0lHQkFrY05BQ0FBS0FJSVFZMlVuTlFBUmcwQ0MwSE5DQkFBUVFFaEFBd0NDMEVBSVFRTEFuOUJBRUVCUWVBQUVBd2lBMFVOQUJvZ0EwRUJOZ0pNQWtBQ1FBSkFBa0FnQkE0REFBTUJBd3NnQTBIREFEWUNXQ0FEUWNRQU5nSlVJQU5CeFFBMkFsQWdBMEhHQURZQ0VDQURRY2NBTmdJRUlBTkJ5QUEyQWh3Z0EwSEpBRFlDR0NBRFFjb0FOZ0lVSUFOQnl3QTJBZ0FnQTBITUFEWUNYQ0FEUWMwQU5nSXNJQU5CemdBMkFpZ2dBMEhQQURZQ0pDQURRZEFBTmdJZ0lBTkIwUUEyQWd3Z0EwSFNBRFlDQ0NBREVFWWlCRFlDTUNBRURRRU1BZ3NnQTBIVEFEWUNXQ0FEUWRRQU5nSlVJQU5CMVFBMkFsQWdBMEhXQURZQ0VDQURRZGNBTmdJRUlBTkIyQUEyQWx3Z0EwSFpBRFlDTENBRFFkb0FOZ0lvSUFOQjJ3QTJBaVFnQTBIY0FEWUNJQ0FEUWQwQU5nSWNJQU5CM2dBMkFoZ2dBMEhmQURZQ0ZDQURRZUFBTmdJTUlBTkI0UUEyQWdnZ0EwSGlBRFlDQUNBREFuOUJBVUdJQVJBTUlnUUVRQ0FFRUVZaUJUWUNBQUpBSUFWRkRRQWdCUDBNQUFBQUFBQUFBQUFBQUFBQUFBQUFBUDBMQW13Z0JFRUFPZ0I4SUFRUUxpSUZOZ0lFSUFWRkRRQWdCQkF1SWdVMkFnZ2dCVVVOQUNBRURBSUxJQVFRYVF0QkFBc2lCRFlDTUNBRVJRMEJDeUFEUVFFMkFrZ2dBMEVCTmdKQUlBTkJBRFlDUENBRFFnQTNBalFnQTBFQk5nSkVJQU1NQVFzZ0F4QUpRUUFMSWdRRVFDQUVRUUEyQWp3Z0JFSGpBRFlDU0FzZ0JBUkFJQVJCQURZQ09DQUVRZVFBTmdKRUN5QUVCRUFnQkVFQU5nSTBJQVJCNVFBMkFrQUxJQWxCRkdvaUJTSURCRUFnQTBFQVFiakFBQkFPSWdOQkFEWUN1RUFnQTBKL053S0lRQXNnQ1NBQk5nSU1JQWtnQURZQ0NDQUpJQUEyQWdSQkFTRUFRUUFoQXdKQUlBbEJCR29pQ2tVTkFFRUJRY2dBRUF3aUFRUi9BbjhnQVVHQWdNQUFOZ0pBSUFGQmdJREFBQkFOSWdnMkFpQWdDRVVFUUNBQkVBbEJBQXdCQ3lBQklBZzJBaVFnQVVFQ05nSWNJQUZCQXpZQ0dDQUJRUVEyQWhRZ0FVRUZOZ0lRSUFGQkJqWUNMQ0FCUVFnMkFpZ2dBU0FCS0FKRVFRSnlOZ0pFSUFFTEJVRUFDeUlCUlEwQUlBRUVRQ0FCUVFBMkFnUWdBU0FLTmdJQUN5QUtOUUlJSVJRZ0FRUkFJQUVnRkRjRENBc0NRQ0FCUlEwQUlBRXRBRVJCQW5GRkRRQWdBVUUvTmdJUUN5QUJCRUFnQVVIQkFEWUNHQXNnQVFSQUlBRkJ3Z0EyQWh3TElBRWhBd3NDZndKQUlBUkZEUUFnQlVVTkFDQUVLQUpNUlFSQUlBUkJOR3BCQVVHUHlRQkJBQkFJUVFBTUFnc2dCQ2dDTUNBRklBUW9BaGdSQXdCQkFTRUhDeUFIQzBVRVFFR0JDUkFBSUFNUUp5QUVFQ2dNQVFzQ2Z5QUpRUkJxSVFWQkFDRUJBa0FnQTBVTkFDQUVSUTBBSUFRb0FreEZCRUFnQkVFMGFrRUJRZURKQUVFQUVBaEJBQXdDQ3lBRElBUW9BakFnQlNBRVFUUnFJQVFvQWdBUkFRQWhBUXNnQVF0RkJFQkJuUWtRQUNBREVDY2dCQkFvSUFrb0FoQVFHQXdCQ3lBSktBSVFJUUFnQWdSQVFRZ2dBQ2dDRUNJQlFRSjBFQnNoQlFKQUlBRkZEUUJCQUNFQUlBRkJBMHNFUUNBQlFYeHhJUUQ5REFBQUFBQUJBQUFBQWdBQUFBTUFBQUFoRUFOQUlBVWdCa0VDZEdvZ0VQMExBZ0FnRVAwTUJBQUFBQVFBQUFBRUFBQUFCQUFBQVAydUFTRVFJQVpCQkdvaUJpQUFSdzBBQ3lBQUlBRkdEUUVMQTBBZ0JTQUFRUUowYWlBQU5nSUFJQUJCQVdvaUFDQUJSdzBBQ3dzQ2YwRUFJQVJGRFFBYUlBUW9Ba3hGQkVBZ0JFRTBha0VCUWJYSUFFRUFFQWhCQUF3QkN5QUVLQUl3SUFFZ0JTQUVRVFJxSUFRb0Fpd1JBUUFMUlFSQVFkd0lFQUFnQXhBbklBUVFLQ0FKS0FJUUVCZ2dCUkFKUVFFaEFBd0NDeUFGRUFrZ0NTZ0NFQ0VBQzBFQUlRRUNRQ0FFUlEwQUlBTkZEUUFnQkNnQ1RFVU5BQ0FFS0FJd0lBTWdBQ0FFUVRScUlBUW9BZ1FSQVFBaEFRc0NRQ0FCQkVCQkFDRUFBa0FnQkVVTkFDQURSUTBBSUFRb0FreEZEUUFnQkNnQ01DQURJQVJCTkdvZ0JDZ0NFQkVBQUNFQUN5QUFEUUVMUWFRS0VBQWdCQkFvSUFNUUp5QUpLQUlRRUJoQkFTRUFEQUVMSUFNUUp5QUVFQ2hCQ0NBSktBSVFJZ29vQWd3Z0NpZ0NDR3dpQlNBS0tBSVFJZ2RzSWcwUUd5RURBa0FnQWcwQUlBZEZEUUFnQ2lnQ0dDRU9BMEFnRGlBTFFUUnNhaUlHS0FJWUlnQkJDRWNFUUFKQUlBQkJCMDBFUUNBR0tBSU1JQVlvQWdoc0lRRWdCaWdDTENFQ0lBWW9BaUFFUUNBQlJRMENRUUVnQUVFQmEzU3RJUlJCQUNFQUlBRkJCRThFUUNBQlFYeHhJUUFnRlAwU0lSQkJBQ0VFQTBBZ0FpQUVRUUowYWlJSUlBajlBQUlBSWhMOXh3RkJCLzNMQVNJUi9SMEFJQkQ5SFFBaUZYLzlFaUFSL1IwQklCRDlIUUVpRm4vOUhnRWdFaUFRL1EwSUNRb0xEQTBPRHdBQkFnTUFBUUlEL2NjQlFRZjl5d0VpRXYwZEFDQVZmLzBTSUJMOUhRRWdGbi85SGdIOURRQUJBZ01JQ1FvTEVCRVNFeGdaR2h2OUN3SUFJQVJCQkdvaUJDQUFSdzBBQ3lBQUlBRkdEUU1MQTBBZ0FpQUFRUUowYWlJRUlBUTBBZ0JDQjRZZ0ZIOCtBZ0FnQUVFQmFpSUFJQUZIRFFBTERBSUxJQUZGRFFGQmZ5QUFkRUYvYzYwaEZFRUFJUUFnQVVFRVR3UkFJQUZCZkhFaEFDQVUvUkloRUVFQUlRUURRQ0FDSUFSQkFuUnFJZ2dnQ1AwQUFnQWlFdjNKQWYwTS93QUFBQUFBQUFEL0FBQUFBQUFBQVAzVkFTSVIvUjBBSUJEOUhRQWlGWUQ5RWlBUi9SMEJJQkQ5SFFFaUZvRDlIZ0VnRWlBUS9RMElDUW9MREEwT0R3QUJBZ01BQVFJRC9ja0IvUXovQUFBQUFBQUFBUDhBQUFBQUFBQUEvZFVCSWhMOUhRQWdGWUQ5RWlBUy9SMEJJQmFBL1I0Qi9RMEFBUUlEQ0FrS0N4QVJFaE1ZR1JvYi9Rc0NBQ0FFUVFScUlnUWdBRWNOQUFzZ0FDQUJSZzBDQ3dOQUlBSWdBRUVDZEdvaUJDQUVOUUlBUXY4QmZpQVVnRDRDQUNBQVFRRnFJZ0FnQVVjTkFBc01BUXNnQUVFSWF5RUVJQVlvQWd3Z0JpZ0NDR3doQWlBR0tBSXNJUWdnQmlnQ0lBUkFJQUpGRFFGQkFDRUFJQUpCQkU4RVFDQUNRWHh4SVFCQkFDRUJBMEFnQ0NBQlFRSjBhaUlNSUF6OUFBSUFJQVQ5ckFIOUN3SUFJQUZCQkdvaUFTQUFSdzBBQ3lBQUlBSkdEUUlMQTBBZ0NDQUFRUUowYWlJQklBRW9BZ0FnQkhVMkFnQWdBRUVCYWlJQUlBSkhEUUFMREFFTElBSkZEUUJCQUNFQUlBSkJCRThFUUNBQ1FYeHhJUUJCQUNFQkEwQWdDQ0FCUVFKMGFpSU1JQXo5QUFJQUlBVDlyUUg5Q3dJQUlBRkJCR29pQVNBQVJ3MEFDeUFBSUFKR0RRRUxBMEFnQ0NBQVFRSjBhaUlCSUFFb0FnQWdCSFkyQWdBZ0FFRUJhaUlBSUFKSERRQUxDeUFHUVFnMkFoZ0xJQXRCQVdvaUN5QUhSdzBBQ3dzQ1FBSkFBa0FDUUNBSFFRRnJEZ1FBQXdFQ0F3c2dCVVVOQWlBS0tBSVlLQUlzSVFKQkFDRUVRUUFoQVFKQUlBVkJERWtOQUNBQ0lBTWdCV3BKSUFJZ0JVRUNkR29nQTB0eERRQWdCVUY4Y1NFQlFRQWhBQU5BSUFBZ0Eyb2dBaUFBUVFKMGF2MEFBZ0FnRVAwTkFBUUlEQUFBQUFBQUFBQUFBQUFBQVAxYUFBQUFJQUJCQkdvaUFDQUJSdzBBQ3lBQklBVkdEUU1MSUFFaEFDQUZRUU54SWdZRVFBTkFJQUFnQTJvZ0FpQUFRUUowYWlnQ0FEb0FBQ0FBUVFGcUlRQWdCRUVCYWlJRUlBWkhEUUFMQ3lBQklBVnJRWHhMRFFJRFFDQUFJQU5xSUFJZ0FFRUNkR29vQWdBNkFBQWdBeUFBUVFGcUlnRnFJQUlnQVVFQ2RHb29BZ0E2QUFBZ0F5QUFRUUpxSWdGcUlBSWdBVUVDZEdvb0FnQTZBQUFnQXlBQVFRTnFJZ0ZxSUFJZ0FVRUNkR29vQWdBNkFBQWdBRUVFYWlJQUlBVkhEUUFMREFJTElBVkZEUUVnQ2lnQ0dDSUFLQUtVQVNFQklBQW9BbUFoQWlBQUtBSXNJUVJCQUNFQUlBVkJBVWNFUUNBRlFRRnhJUThnQlVGK2NTRUhBMEFnQXlBQVFRTnNhaUlGSUFRZ0FFRUNkQ0lHYWlnQ0FEb0FBQ0FGSUFJZ0Jtb29BZ0E2QUFFZ0JTQUJJQVpxS0FJQU9nQUNJQU1nQUVFQmNpSUdRUU5zYWlJRklBUWdCa0VDZENJR2FpZ0NBRG9BQUNBRklBSWdCbW9vQWdBNkFBRWdCU0FCSUFacUtBSUFPZ0FDSUFCQkFtb2lBQ0FIUncwQUN5QVBSUTBDQ3lBRElBQkJBMnhxSWdVZ0JDQUFRUUowSWdCcUtBSUFPZ0FBSUFVZ0FDQUNhaWdDQURvQUFTQUZJQUFnQVdvb0FnQTZBQUlNQVFzZ0JVVU5BQ0FLS0FJWUlnUW9Bc2dCSVFBZ0JDZ0NsQUVoQVNBRUtBSmdJUUlnQkNnQ0xDRUlRUUFoQkFKQUlBVkIxQUJKRFFBZ0F5QUZRUUZySWdkQkFuUWlCbW9nQTBrTkFDQURRUUZxSWdzZ0Jtb2dDMGtOQUNBRFFRSnFJZ3NnQm1vZ0Mwa05BQ0FHSUFOQkEyb2lDMm9nQzBrTkFDQUhRZi8vLy84RFN3MEFJQU1nQ0NBRlFRSjBJZ1pxU1NBSUlBTWdCbW9pQjBseERRQWdBaUFIU1NBRElBSWdCbXBKY1EwQUlBRWdCMGtnQXlBQklBWnFTWEVOQUNBQUlBZEpJQU1nQUNBR2FrbHhEUUFnQlVIOC8vLy9CM0VoQlAwTUFBQUFBQUVBQUFBQ0FBQUFBd0FBQUNFU1FRQWhCZ05BSUFNZ0VrRUMvYXNCSWhEOUd3QnFJQWdnQmtFQ2RDSUhhdjBBQWdBaUVmMGJBRG9BQUNBRElCRDlHd0ZxSUJIOUd3RTZBQUFnQXlBUS9Sc0NhaUFSL1JzQ09nQUFJQU1nRVAwYkEyb2dFZjBiQXpvQUFDQURJQkQ5REFFQUFBQUJBQUFBQVFBQUFBRUFBQUQ5VUNJUi9Sc0FhaUFDSUFkcS9RQUNBQ0lUL1JzQU9nQUFJQU1nRWYwYkFXb2dFLzBiQVRvQUFDQURJQkg5R3dKcUlCUDlHd0k2QUFBZ0F5QVIvUnNEYWlBVC9Sc0RPZ0FBSUFNZ0VQME1BZ0FBQUFJQUFBQUNBQUFBQWdBQUFQMVFJaEg5R3dCcUlBRWdCMnI5QUFJQUloUDlHd0E2QUFBZ0F5QVIvUnNCYWlBVC9Sc0JPZ0FBSUFNZ0VmMGJBbW9nRS8wYkFqb0FBQ0FESUJIOUd3TnFJQlA5R3dNNkFBQWdBeUFRL1F3REFBQUFBd0FBQUFNQUFBQURBQUFBL1ZBaUVQMGJBR29nQUNBSGF2MEFBZ0FpRWYwYkFEb0FBQ0FESUJEOUd3RnFJQkg5R3dFNkFBQWdBeUFRL1JzQ2FpQVIvUnNDT2dBQUlBTWdFUDBiQTJvZ0VmMGJBem9BQUNBUy9Rd0VBQUFBQkFBQUFBUUFBQUFFQUFBQS9hNEJJUklnQmtFRWFpSUdJQVJIRFFBTElBUWdCVVlOQVFzRFFDQURJQVJCQW5RaUJtb2lCeUFHSUFocUtBSUFPZ0FBSUFjZ0FpQUdhaWdDQURvQUFTQUhJQUVnQm1vb0FnQTZBQUlnQnlBQUlBWnFLQUlBT2dBRElBUkJBV29pQkNBRlJ3MEFDd3NnQ2hBWUlBTWdEUkFISUFNUUNVRUFJUUFMSUFsQjBNQUFhaVFBSUFBTENBQkJDQ0FBRUJzTHF3SUNBbjRDZjBKL0lRTWdBQzBBUkVFSWNVVUVRQ0FBSUFBb0FpQWlCallDSkFKQUFrQUNRQ0FBSUFBb0FqQWlCUVIvQTBBZ0JpQUZJQUFvQWdBZ0FDZ0NGQkVBQUNJRlFYOUdEUUlnQUNBQUtBSWtJQVZxSWdZMkFpUWdBQ0FBS0FJd0lBVnJJZ1UyQWpBZ0JRMEFDeUFBS0FJZ0JTQUdDellDSkNBQlFnQlZEUUZDQUNFRERBSUxJQUFnQUNnQ1JFRUljallDUkNBQ1FRUkJrZlVBUVFBUUNDQUFRUUEyQWpBZ0FDQUFLQUpFUVFoeU5nSkVRbjhQQzBJQUlRTURRQ0FCSUFBb0FnQWdBQ2dDR0JFTEFDSUVRbjlSQkVBZ0FrRUVRWUwxQUVFQUVBZ2dBQ0FBS0FKRVFRaHlOZ0pFSUFBZ0FDa0RPQ0FEZkRjRE9FSi9JQU1nQTFBYkR3c2dBeUFFZkNFRElBRWdCSDBpQVVJQVZRMEFDd3NnQUNBQUtRTTRJQU44TndNNEN5QURDeU1CQVg4Z0FTQUJLQUlBSUFFb0FnZ2lBU0FBcHlJQ0lBRWdBa2tiYWpZQ0JFRUJDendDQW44QmZpQUJLQUlBSUFFb0FnaHFJZ01nQVNnQ0JDSUNSZ1JBUW44UEN5QUJJQUlnQUtkcU5nSUVJQU1nQW11c0lnUWdBQ0FBSUFSVkd3dVlBd0lDZmdKL0lBQW9BakFpQlNBQnB5SUdUd1JBSUFBZ0JTQUdhellDTUNBQUlBQW9BaVFnQm1vMkFpUWdBQ0FBS1FNNElBRjhOd000SUFFUEN5QUFMUUJFUVFSeEJFQWdBRUVBTmdJd0lBQWdBQ2dDSkNBRmFqWUNKQ0FBSUFXdElnRWdBQ2tET0h3M0F6Z2dBVUovSUFVYkR3c0NRQ0FGUlFSQURBRUxJQUJCQURZQ01DQUFJQUFvQWlBMkFpUWdBU0FGclNJRGZTRUJDeUFCUWdCVkJFQURRQ0FBS1FNSUlBQXBBemdnQVNBRGZIeFVCRUFnQWtFRVFhdjFBRUVBRUFnZ0FFRUFOZ0l3SUFBZ0FDZ0NJRFlDSkNBQUlBQXBBemdnQTN3aUF6Y0RPQ0FBS1FNSUlnRWdBMzBoQkNBQklBQW9BZ0FnQUNnQ0hCRUpBQ0VGSUFBb0FrUWhBaUFBSUFVRWZ5QUFJQUUzQXpnZ0FrRjdjUVVnQWd0QkJISTJBa1JDZnlBRUlBRWdBMUViRHdzZ0FTQUFLQUlBSUFBb0FoZ1JDd0FpQkVKL1VRUkFJQUpCQkVHcjlRQkJBQkFJSUFBZ0FDZ0NSRUVFY2pZQ1JDQUFJQUFwQXpnZ0EzdzNBemhDZnlBRElBTlFHdzhMSUFNZ0JId2hBeUFCSUFSOUlnRkNBRlVOQUFzTElBQWdBQ2tET0NBRGZEY0RPQ0FEQzVzQkFRVi9RUUVnQWlnQ0NDSUhJQWRCQVUwYklRUWdBaWdDQkNJRElBSW9BZ0JySVFZRFFDQUVJZ1ZCQVhRaEJDQUZJQVpySUFGSkRRQUxJQVVnQjBjRVFDQUZFQTBpQTBVRVFFRi9Ed3NnQWlnQ0FDSUVCRUFnQXlBRUlBWVFDeG9nQWlnQ0FCQUpDeUFDSUFVMkFnZ2dBaUFETmdJQUlBSWdBeUFHYWlJRE5nSUVDeUFESUFBZ0FSQUxHaUFDSUFJb0FnUWdBV28yQWdRZ0FRdEdBUUovSUFJb0FnQWdBaWdDQ0dvaUJDQUNLQUlFSWdOR0JFQkJmdzhMSUFBZ0F5QUVJQU5ySWdBZ0FTQUFJQUZKR3lJQUVBc2FJQUlnQWlnQ0JDQUFhallDQkNBQUM2b0NBUVIvSXdCQkVHc2lCQ1FBQWtBZ0FDZ0NkQTBBSUFKQkFVMEVRQ0FEUVFGQi9NRUFRUUFRQ0F3QkN5QUJJQVJCREdwQkFoQUtJQVFvQWd3aUJrSC8vd054SWdkRkJFQWdBMEVCUVozQ0FFRUFFQWdNQVFzZ0FpQUhRUVpzUVFKcVNRUkFJQU5CQVVIOHdRQkJBQkFJREFFTElBWkJCbXdRRFNJRFJRMEFJQUJCQ0JBTklnSTJBblFnQWtVRVFDQURFQWtNQVFzZ0FpQUROZ0lBSUFJZ0JDOEJEQ0lDT3dFRUlBSkZCRUJCQVNFRkRBRUxRUUFoQWdOQUlBRkJBbW9nQkVFTWFpSUZRUUlRQ2lBRElBSkJCbXhxSWdZZ0JDZ0NERHNCQUNBQlFRUnFJQVZCQWhBS0lBWWdCQ2dDRERzQkFpQUJRUVpxSWdFZ0JVRUNFQW9nQmlBRUtBSU1Pd0VFUVFFaEJTQUNRUUZxSWdJZ0FDZ0NkQzhCQkVrTkFBc0xJQVJCRUdva0FDQUZDL0FCQVFWL0l3QkJFR3NpQkNRQUFuOGdBQ2dDZUNJRlJRUkFJQU5CQVVIT3dRQkJBQkFJUVFBTUFRc2dCU2dDREFSQUlBTkJBVUcyMVFCQkFCQUlRUUFNQVFzZ0FpQUZMUUFTSWdWQkFuUWlCa2tFUUNBRFFRRkJyY0VBUVFBUUNFRUFEQUVMUVFBZ0JoQU5JZ0pGRFFBYUlBVUVRRUVBSVFNRFFDQUJJQVJCREdvaUIwRUNFQW9nQWlBRFFRSjBhaUlHSUFRb0FndzdBUUFnQVVFQ2FpQUhRUUVRQ2lBR0lBUW9BZ3c2QUFJZ0FVRURhaUFIUVFFUUNpQUdJQVFvQWd3NkFBTWdBVUVFYWlFQklBTkJBV29pQXlBRlJ3MEFDd3NnQUNnQ2VDQUNOZ0lNUVFFTElRZ2dCRUVRYWlRQUlBZ0w4QU1CQ1g4akFFRVFheUlGSkFBQ1FDQUNRUU5KRFFBZ0FDZ0NlQTBBSUFFZ0JVRU1ha0VDRUFvZ0JTOEJEQ0lKUVlFSWEwSC9kMDBFUUNBRklBazJBZ0FnQTBFQlFiUWFJQVVRQ0F3QkN5QUJRUUpxSUFWQkRHcEJBUkFLSUFVdkFRd2lDRVVFUUNBRFFRRkIxQmRCQUJBSURBRUxJQWhCQTJvZ0Frc05BQ0FJSUFsc1FRSjBFQTBpQjBVTkFDQUlFQTBpQ2tVRVFDQUhFQWtNQVFzZ0NCQU5JZ3RGQkVBZ0J4QUpJQW9RQ1F3QkMwRVVFQTBpQmtVRVFDQUhFQWtnQ2hBSklBc1FDUXdCQ3lBQlFRTnFJUU1nQmlBS05nSUlJQVlnQ3pZQ0JDQUdJQWs3QVJBZ0JpQUhOZ0lBSUFVb0Fnd2hEQ0FHUVFBMkFnd2dCaUFNT2dBU0lBQWdCallDZUFOQUlBTWdCVUVNYWtFQkVBb2dCQ0FLYWlBRkxRQU1RZjhBY1VFQmFqb0FBQ0FFSUF0cUlBVW9BZ3hCZ0FGeFFRZDJPZ0FBSUFOQkFXb2hBeUFFUVFGcUlnUWdDRWNOQUFzZ0NVVUVRRUVCSVFRTUFRdEJBQ0VHQTBCQkFDRUVRUUFoQUFOQUlBSkJCQ0FFSUFwcUxRQUFRUWRxUVFOMklnUWdCRUVFVHhzaUJDQURJQUZyYWtnRVFFRUFJUVFNQXdzZ0F5QUZRUXhxSUFRUUNpQUhJQVVvQWd3MkFnQWdCMEVFYWlFSElBTWdCR29oQXlBQVFRRnFJZ0JCLy84RGNTSUVJQWhKRFFBTFFRRWhCQ0FHUVFGcUlnWkIvLzhEY1NBSlNRMEFDd3NnQlVFUWFpUUFJQVFMbUFFQkFuOGpBRUVRYXlJRkpBQWdBQ2dDR0NJRVFmOEJSd1JBSUFVZ0JEWUNBQ0FEUVFKQjVCTWdCUkFJQ3dKQUFrQWdBaUFBS0FJVVJnUkFJQUlOQVVFQklRUU1BZ3RCQUNFRUlBTkJBVUhMN0FCQkFCQUlEQUVMUVFBaEFnTkFRUUVoQkNBQklBQW9Ba2dnQWtFTWJHcEJDR3BCQVJBS0lBRkJBV29oQVNBQ1FRRnFJZ0lnQUNnQ0ZFa05BQXNMSUFWQkVHb2tBQ0FFQzQ0R0FRWi9Jd0JCMEFCcklnUWtBQUpBSUFKQkFrMEVRQ0FEUVFGQnErd0FRUUFRQ0F3QkN5QUFMUUI4QkVBZ0EwRUVRY25TQUVFQUVBaEJBU0VHREFFTFFRRWhCaUFCSUFCQktHcEJBUkFLSUFGQkFXb2dBRUUwYWtFQkVBb2dBVUVDYWlBQVFTeHFRUUVRQ2lBQlFRTnFJUVVDUUFKQUFrQUNRQUpBSUFBb0FpZ2lCMEVCYXc0Q0FBRUNDeUFDUVFaTkJFQWdCQ0FDTmdJUUlBTkJBVUhROFFBZ0JFRVFhaEFJUVFBaEJnd0ZDd0pBSUFKQkIwWU5BQ0FBS0FJd1FRNUdEUUFnQkNBQ05nSXdJQU5CQWtIUThRQWdCRUV3YWhBSUN5QUZJQUJCTUdwQkJCQUtJQUFvQWpCQkRrY05BMEVrRUEwaUJVVUVRRUVBSVFZZ0EwRUJRYk04UVFBUUNBd0ZDeUFGUVE0MkFnQWdCRUVBTmdKQUlBUkJBRFlDT0NBRVFRQTJBa2dnQkVFQU5nSThJQVJCQURZQ1JDQUVRUUEyQWt4QnNPcVFBaUVHSUFSQnNPcVFBallDTkNBRlFZQ01sYUlFTmdJRUFuOGdBa0VIUndSQUlBSkJJMFlFUUNBQlFRZHFJQVJCekFCcVFRUVFDaUFCUVF0cUlBUkJ5QUJxUVFRUUNpQUJRUTlxSUFSQnhBQnFRUVFRQ2lBQlFSTnFJQVJCUUd0QkJCQUtJQUZCRjJvZ0JFRThha0VFRUFvZ0FVRWJhaUFFUVRocVFRUVFDaUFCUVI5cUlBUkJOR3BCQkJBS0lBVkJBRFlDQkNBRUtBSTBJUVlnQkNnQ09DRUNJQVFvQWtBaEF5QUVLQUk4SVFjZ0JDZ0NSQ0VJSUFRb0Frd2hDU0FFS0FKSURBSUxJQVFnQWpZQ0lDQURRUUpCOVBFQUlBUkJJR29RQ0F0QkFDRUNRUUFoQTBFQUlRZEJBQXNoQVNBRklBYzJBaGdnQlNBSU5nSVFJQVVnQ1RZQ0NDQUZJQVkyQWlBZ0JTQUNOZ0ljSUFVZ0F6WUNGQ0FGSUFFMkFnd2dBRUVBTmdKd0lBQWdCVFlDYkF3REN5QUFJQUpCQTJzaUFUWUNjQ0FBUVFFZ0FSQU1JZ00yQW13Z0EwVU5BU0FDUVFOTURRSkJBQ0VDQTBBZ0JTQUVRY3dBYWtFQkVBb2dBQ2dDYkNBQ2FpQUVLQUpNT2dBQUlBVkJBV29oQlNBQ1FRRnFJZ0lnQVVjTkFBc01BZ3NnQjBFRFNRMENJQVFnQnpZQ0FDQURRUVJCNi9jQUlBUVFDQXdDQzBFQUlRWWdBRUVBTmdKd0RBRUxRUUVoQmlBQVFRRTZBSHdMSUFSQjBBQnFKQUFnQmd1MEF3RURmeU1BUVNCcklnUWtBQUpBSUFBb0FrZ0VRQ0FEUVFKQmpUVkJBQkFJUVFFaEFnd0JDeUFDUVE1SEJFQkJBQ0VDSUFOQkFVR0s3QUJCQUJBSURBRUxJQUVnQUVFUWFrRUVFQW9nQVVFRWFpQUFRUXhxUVFRUUNpQUJRUWhxSUFCQkZHcEJBaEFLSUFBb0Fnd2hCUUpBSUFRQ2Z5QUFLQUlRSWdaRkJFQWdBQ2dDRkF3QkN5QUFLQUlVSWdJZ0JVVU5BQm9nQWcwQlFRQUxOZ0lJSUFRZ0JqWUNCQ0FFSUFVMkFnQWdBMEVCUWU3cUFDQUVFQWhCQUNFQ0RBRUxJQUpCZ1lBQmEwSC8vMzVOQkVCQkFDRUNJQU5CQVVHWTZnQkJBQkFJREFFTElBQWdBa0VNRUF3aUFqWUNTQ0FDUlFSQVFRQWhBaUFEUVFGQnZlb0FRUUFRQ0F3QkMwRUJJUUlnQVVFS2FpQUFRUmhxUVFFUUNpQUJRUXRxSUFCQkhHcEJBUkFLSUFBb0Fod2lCVUVIUndSQUlBUWdCVFlDRUNBRFFRUkJyZm9BSUFSQkVHb1FDQXNnQVVFTWFpQUFRU0JxUVFFUUNpQUJRUTFxSUFCQkpHcEJBUkFLSUFBb0FnQWlBU0FCTFFDOEFVSDdBWEVnQUNnQ0dFSC9BVVpCQW5SeU9nQzhBU0FBS0FJQUlnRWdBQ2dDRERZQzJBRWdBU0FBS0FJUU5nTGNBU0FBUVFFNkFJVUJDeUFFUVNCcUpBQWdBZ3U2QkFFR2Z5TUFRUkJySWdZa0FBSi9JQUF0QUdSQkFuRkZCRUFnQTBFQlFlelRBRUVBRUFoQkFBd0JDeUFBUVFBMkFtZ0NRQUpBQWtBZ0FnUkFBMEFnQWtFSFRRUkFJQU5CQVVHNUdVRUFFQWdNQlFzZ0FTQUdRUXhxSWdWQkJCQUtJQVlvQWd3aEJDQUJRUVJxSUFWQkJCQUtRUWdoQnlBR0tBSU1JUVVDUUFKQUFrQUNRQ0FFRGdJQkFBTUxJQUpCRUVrRVFFSGhHU0VFREFjTElBRkJDR29nQmtFSWFrRUVFQW9nQmlnQ0NBUkFRY3MrSVFRTUJ3c2dBVUVNYWlBR1FReHFRUVFRQ2lBR0tBSU1JZ1FOQVVHeUdDRUVEQVlMSUFOQkFVR3lHRUVBRUFnTUJndEJFQ0VIQ3lBRUlBZEpCRUFnQTBFQlFZYkVBRUVBRUFnTUJRc2dBaUFFU1FSQUlBTkJBVUcrd3dCQkFCQUlRUUFNQmdzQ1FBSkFJQUFnQVNBSGFpQUVJQWRySUFNQ2Z3SkFBa0FDUUNBRlFmSFl2WnNHVEFSQUlBVkI0OGJCa3daR0RRRWdCVUhteXBHYkJrWU5BeUFGUWZEQ3Rac0dSdzBGUWZEQUFRd0VDeUFGUWZMWWpZTUhSZzBCUWREQUFTQUZRZkxJb2NzR1JnMERHaUFGUWZMWXZac0dSdzBFUWRqQUFRd0RDMEhnd0FFTUFndEI2TUFCREFFTFFmakFBUXNvQWdRUkFRQU5BVUVBREFjTElBQWdBQ2dDYUVILy8vLy9CM0kyQW1nTFFRRWdDQ0FGUWZMSW9jc0dSaHNoQ0NBQklBUnFJUUVnQWlBRWF5SUNEUUFMSUFnTkFRc2dBMEVCUWRyQ0FFRUFFQWhCQUF3REN5QUFRUUU2QUlRQklBQWdBQ2dDWkVFRWNqWUNaRUVCREFJTElBTkJBU0FFUVFBUUNBc2dBMEVCUVo0T1FRQVFDRUVBQ3lFSklBWkJFR29rQUNBSkMrSUJBUUYvSUFBb0FtUkJBVWNFUUNBRFFRRkJtZFFBUVFBUUNFRUFEd3NDUUNBQ1FRZE5CRUFNQVFzZ0FTQUFRVGhxUVFRUUNpQUJRUVJxSUFCQlBHcEJCQkFLSUFKQkEzRUVRQXdCQ3lBQUlBSkJDR3NpQWtFQ2RpSUVOZ0pBQWtBZ0FrVU5BQ0FBSUFSQkJCQU1JZ0kyQWtRZ0FrVUVRQ0FEUVFGQnFSQkJBQkFJUVFBUEN5QUFLQUpBUlEwQUlBRkJDR29oQTBFQUlRSURRQ0FESUFBb0FrUWdBa0VDZEdwQkJCQUtJQU5CQkdvaEF5QUNRUUZxSWdJZ0FDZ0NRRWtOQUFzTElBQWdBQ2dDWkVFQ2NqWUNaRUVCRHdzZ0EwRUJRYW90UVFBUUNFRUFDOFFCQVFKL0lBQWdBQ2dDSUNJRU5nSWtBa0FnQUNnQ01DSURCRUFEUUNBRUlBTWdBQ2dDQUNBQUtBSVVFUUFBSWdOQmYwWU5BaUFBSUFBb0FpUWdBMm9pQkRZQ0pDQUFJQUFvQWpBZ0Eyc2lBellDTUNBRERRQUxJQUFvQWlBaEJBc2dBRUVBTmdJd0lBQWdCRFlDSkNBQklBQW9BZ0FnQUNnQ0hCRUpBRVVFUUNBQUlBQW9Ba1JCQ0hJMkFrUkJBQThMSUFBZ0FUY0RPRUVCRHdzZ0FDQUFLQUpFUVFoeU5nSkVJQUpCQkVHUjlRQkJBQkFJSUFBZ0FDZ0NSRUVJY2pZQ1JFRUFDNElCQVFKL0l3QkJFR3NpQkNRQUFuOGdBQ2dDWkFSQUlBTkJBVUcyMHdCQkFCQUlRUUFNQVFzZ0FrRUVSd1JBSUFOQkFVSE9MVUVBRUFoQkFBd0JDeUFCSUFSQkRHcEJCQkFLSUFRb0FneEJpbzZxNkFCSEJFQWdBMEVCUWZZbFFRQVFDRUVBREFFTElBQWdBQ2dDWkVFQmNqWUNaRUVCQ3lFRklBUkJFR29rQUNBRkN3MEFJQUFvQWdBZ0FTQUNFRDRMQ1FBZ0FDZ0NBQkJEQ3drQUlBQW9BZ0FRUWdzTkFDQUFLQUlBSUFFZ0FoQkZDMEVCQVg4Z0FnUi9JQU5CQWtHMnl3QkJBQkFJSUFBb0FnQWdBU0FDSUFNZ0JCQS9SUVJBSUFOQkFVR3BMMEVBRUFoQkFBOExJQUFnQWlBREVHb0ZRUUFMQ3hVQUlBQW9BZ0FnQVNBQ0lBTWdCQ0FGSUFZUVJ3c1BBQ0FBS0FJQUlBRWdBaUFERUVnTEV3QWdBQ2dDQUNBQklBSWdBeUFFSUFVUUpBc2RBQ0FBS0FJQUlBRWdBaUFESUFRZ0JTQUdJQWNnQ0NBSklBb1FJQXZxQkFFSGZ3SkFJQUVvQWdoQk5TQURFQjVGRFFBZ0FTZ0NCQ0lIS0FJQUlRVWdCeWdDQ0NFRUFrQWdCUVJBUVFFaEJpQUZRUUZIQkVBZ0JVRitjU0VLQTBBQ2YwRUFJQVpGRFFBYVFRQWdBU0FBSUFNZ0JDZ0NBQkVBQUVVTkFCb2dBU0FBSUFNZ0JDZ0NCQkVBQUVFQVJ3c2hCaUFFUVFocUlRUWdDVUVDYWlJSklBcEhEUUFMQ3dKQUlBVkJBWEVFUUNBR1JRMEJJQUVnQUNBRElBUW9BZ0FSQUFCQkFFY2hCZ3NnQjBFQU5nSUFJQVpGRFFNTUFnc2dCMEVBTmdJQVFRQVBDeUFIUVFBMkFnQUxJQUVvQWdnaUJ5Z0NBQ0VGSUFjb0FnZ2hCQUpBQWtBQ2Z3SkFJQVVFUUVFQklRWWdCVUVCY1NFSUlBVkJBVWNOQVVFQURBSUxJQWRCQURZQ0FBd0NDeUFGUVg1eElRVkJBQ0VKQTBBQ2YwRUFJQVpGRFFBYVFRQWdBU0FBSUFNZ0JDZ0NBQkVBQUVVTkFCb2dBU0FBSUFNZ0JDZ0NCQkVBQUVFQVJ3c2hCaUFFUVFocUlRUWdDVUVDYWlJSklBVkhEUUFMSUFaRkN5RUZJQWdFUUNBRkRRSWdBU0FBSUFNZ0JDZ0NBQkVBQUVFQVJ5RUdDeUFIUVFBMkFnQkJBQ0VJSUFaRkRRSUxJQUV0QUlRQlJRUkFJQU5CQVVITjFnQkJBQkFJUVFBUEN5QUJMUUNGQVVVRVFDQURRUUZCc05ZQVFRQVFDRUVBRHdzZ0FDQUJLQUlBSUFJZ0F4QkpJUWdnQWtVTkFTQUNLQUlBSWdCRkRRRkJBU0VFQWtBQ1FBSkFBa0FDUUFKQUlBRW9BakJCREdzT0RRTUVCQVFGQUFFRUJBUUVCQUlFQzBFQ0lRUU1CQXRCQXlFRURBTUxRUVFoQkF3Q0MwRUZJUVFNQVF0QmZ5RUVDeUFBSUFRMkFoUWdBU2dDYkNJRFJRMEJJQUFnQXpZQ0hDQUNLQUlBSUFFb0FuQTJBaUFnQVVFQU5nSnNJQWdQQ3lBSFFRQTJBZ0JCQUNFSUN5QUlDK1FKQWdwL0FYNGpBRUh3QUdzaUF5UUFRWUFJSVFnQ2Z3SkFRUUZCZ0FnUURDSUdCRUFnQTBIY0FHb2hDeUFEUWV3QWFpRUpBMEFDUUFKQUFrQWdBU0FEUWVnQWFpSUVRUWdnQWhBU1FRaEhEUUFnQkNBRFFkZ0Fha0VFRUFvZ0NTQUxRUVFRQ2tFSUlRVUNRQUpBQWtBQ1FBSkFJQU1vQWxnT0FnQUJCQXNnQVNrRENDSU5VQVIrUWdBRklBMGdBU2tET0gwTElnMUMrUC8vL3c5VERRRWdBa0VCUWNzK1FRQVFDQXdFQ3lBQklBTkI2QUJxSWdSQkNDQUNFQkpCQ0VjTkF5QUVJQU5CNUFCcVFRUVFDaUFES0FKa1JRMEJJQUpCQVVITFBrRUFFQWdNQXdzZ0F5QU5wMEVJYWpZQ1dBd0JDeUFKSUFOQjJBQnFRUVFRQ2tFUUlRVUxJQU1vQWx3aUJFSGo1TURUQmtZRVFDQUFLQUprSWdGQkJIRUVRQ0FBSUFGQkNISTJBbVFNQWdzZ0FrRUJRYTByUVFBUUNDQUdFQWxCQUF3SEN5QURLQUpZSWdkRkJFQWdBa0VCUWJJWVFRQVFDQ0FHRUFsQkFBd0hDeUFGSUFkTEJFQWdBeUFFTmdJRUlBTWdCellDQUNBQ1FRRkJpdWdBSUFNUUNBd0dDd0pBQW44Q2Z3SkFBbjhDUUFKQUFrQUNRQUpBSUFSQjhkaTltd1pNQkVBZ0JFSGp4c0dUQmtZTkFpQUVRZWJLa1pzR1JnMEVJQVJCOE1LMW13WkhEUUZCOE1BQkRBWUxJQVJCbjhEQTBnWk1CRUFnQkVIeTJMMmJCa1lOQlVIUXdBRWdCRUh5eUtITEJrWU5CaG9nQkVIdzh0R3pCa2NOQVVHNHdBRU1DQXNnQkVIeTJJMkRCMFlOQWlBRVFhREF3TklHUmcwR1FjREFBU0FFUWVqa3dOTUdSZzBIR2dzZ0FDZ0NaQ0lFUVFGeERRZ2dBa0VCUWZ3T1FRQVFDQ0FHRUFsQkFBd1BDMEhnd0FFTUF3dEI2TUFCREFJTFFmakFBUXdCQzBIWXdBRUxJUW9nQXlBRVFmOEJjVFlDVENBRElBUkJHSFkyQWtBZ0F5QUVRUWgyUWY4QmNUWUNTQ0FESUFSQkVIWkIvd0Z4TmdKRUlBSkJBa0hKRGlBRFFVQnJFQWdnQnlBRmF5SUZJQUF0QUdSQkJIRU5BaG9nQXlBREtBSmNJZ1JCR0hZMkFqQWdBeUFFUWY4QmNUWUNQQ0FESUFSQkVIWkIvd0Z4TmdJMElBTWdCRUVJZGtIL0FYRTJBamdnQWtFQ1Fkb3pJQU5CTUdvUUNDQUFJQUFvQW1SQi8vLy8vd2R5TmdKa0lBRWdCYTBpRFNBQ0lBRW9BaWdSQ0FBZ0RWRU5CeUFDUVFGQmtoeEJBQkFJSUFZUUNVRUFEQW9MUWJEQUFRc2hDaUFISUFWckN5RUZJQUVwQXdnaURWQUVma0lBQlNBTklBRXBBemg5Q3lBRnJWTUVRQ0FES0FKWUlRUWdBeWdDWENFQUlBTWdBU2tEQ0NJTlVBUitRZ0FGSUEwZ0FTa0RPSDBMUGdJb0lBTWdCVFlDSkNBRElBQkIvd0Z4TmdJZ0lBTWdBRUVZZGpZQ0ZDQURJQVEyQWhBZ0F5QUFRUWgyUWY4QmNUWUNIQ0FESUFCQkVIWkIvd0Z4TmdJWUlBSkJBVUhkOVFBZ0EwRVFhaEFJREFjTElBVWdDRTBFUUNBR0lRUU1CQXNnQlNFSUlBWWdCUkFRSWdRTkF5QUdFQWtnQWtFQlFmOFBRUUFRQ0VFQURBY0xJQVJCQW5GRkJFQWdBa0VCUWNJUFFRQVFDQ0FHRUFsQkFBd0hDeUFBSUFSQi8vLy8vd2R5TmdKa0lBRWdCeUFGYTYwaURTQUNJQUVvQWlnUkNBQWdEVkVOQXlBQUxRQmtRUWh4UlEwQklBSkJBa0dTSEVFQUVBZ0xJQVlRQ1VFQkRBVUxJQUpCQVVHU0hFRUFFQWdnQmhBSlFRQU1CQXNnQVNBRUlBVWdBaEFTSUFWSEJFQWdBa0VCUWNRY1FRQVFDQ0FFRUFsQkFBd0VDeUFBSUFRaUJpQUZJQUlnQ2lnQ0JCRUJBQTBBQ3lBRUVBbEJBQXdDQ3lBQ1FRRkJvaVZCQUJBSVFRQU1BUXNnQmhBSlFRQUxJUXdnQTBId0FHb2tBQ0FNQytZQkFRWi9JQUFvQWdoQk5TQUNFQjRFUUFKQUlBQW9BZ2dpQmlnQ0FDRURJQVlvQWdnaEJRSkFBa0FDZndKQUlBTUVRRUVCSVFRZ0EwRUJjU0VISUFOQkFVY05BVUVBREFJTElBWkJBRFlDQUF3Q0N5QURRWDV4SVFNRFFBSi9RUUFnQkVVTkFCcEJBQ0FBSUFFZ0FpQUZLQUlBRVFBQVJRMEFHaUFBSUFFZ0FpQUZLQUlFRVFBQVFRQkhDeUVFSUFWQkNHb2hCU0FJUVFKcUlnZ2dBMGNOQUFzZ0JFVUxJUU1nQndSQUlBTU5BaUFBSUFFZ0FpQUZLQUlBRVFBQVFRQkhJUVFMSUFaQkFEWUNBQ0FFUlEwQ0N5QUFLQUlBR2tFQkR3c2dCa0VBTmdJQUN3dEJBQXNLQUNBQUtBSUFHa0VBQ3hRQUlBQW9BZ0FpQUFSQUlBQWdBVFlDdUFFTEN5RUFJQUFvQWdBZ0FSQk1JQUJCQURvQWZDQUFJQUVvQXJoQVFRRnhOZ0tBQVFzeUFDQUNSUVJBUVFBUEN5QUFLQUlBSUFFZ0FpQURFRUZGQkVBZ0EwRUJRYWt2UVFBUUNFRUFEd3NnQUNBQ0lBTVFhZ3RwQWdKL0FYd2pBRUVRYXlJREpBQWdBZ1JBQTBBZ0FDQURRUWhxRUQwZ0FRSi9JQU1yQXdnaUJabEVBQUFBQUFBQTRFRmpCRUFnQmFvTUFRdEJnSUNBZ0hnTE5nSUFJQUZCQkdvaEFTQUFRUWhxSVFBZ0JFRUJhaUlFSUFKSERRQUxDeUFEUVJCcUpBQUxoQUVDQW44QmZTTUFRUkJySWdNa0FDQUNCRUFEUUNBRElBQXRBQUE2QUE4Z0F5QUFMUUFCT2dBT0lBTWdBQzBBQWpvQURTQURJQUF0QUFNNkFBd2dBUUovSUFNcUFnd2lCWXREQUFBQVQxMEVRQ0FGcUF3QkMwR0FnSUNBZUFzMkFnQWdBVUVFYWlFQklBQkJCR29oQUNBRVFRRnFJZ1FnQWtjTkFBc0xJQU5CRUdva0FBdExBUUovSXdCQkVHc2lBeVFBSUFJRVFBTkFJQUFnQTBFTWFrRUVFQW9nQVNBREtBSU1OZ0lBSUFGQkJHb2hBU0FBUVFScUlRQWdCRUVCYWlJRUlBSkhEUUFMQ3lBRFFSQnFKQUFMU3dFQ2Z5TUFRUkJySWdNa0FDQUNCRUFEUUNBQUlBTkJER3BCQWhBS0lBRWdBeWdDRERZQ0FDQUJRUVJxSVFFZ0FFRUNhaUVBSUFSQkFXb2lCQ0FDUncwQUN3c2dBMEVRYWlRQUMwb0JBbjhqQUVFUWF5SURKQUFnQWdSQUEwQWdBQ0FEUVFocUVEMGdBU0FES3dNSXRqZ0NBQ0FCUVFScUlRRWdBRUVJYWlFQUlBUkJBV29pQkNBQ1J3MEFDd3NnQTBFUWFpUUFDMmdCQW44akFFRVFheUlESkFBZ0FnUkFBMEFnQXlBQUxRQUFPZ0FQSUFNZ0FDMEFBVG9BRGlBRElBQXRBQUk2QUEwZ0F5QUFMUUFET2dBTUlBRWdBeW9DRERnQ0FDQUJRUVJxSVFFZ0FFRUVhaUVBSUFSQkFXb2lCQ0FDUncwQUN3c2dBMEVRYWlRQUMwd0JBbjhqQUVFUWF5SURKQUFnQWdSQUEwQWdBQ0FEUVF4cVFRUVFDaUFCSUFNb0FneXpPQUlBSUFGQkJHb2hBU0FBUVFScUlRQWdCRUVCYWlJRUlBSkhEUUFMQ3lBRFFSQnFKQUFMVEFFQ2Z5TUFRUkJySWdNa0FDQUNCRUFEUUNBQUlBTkJER3BCQWhBS0lBRWdBeWdDRExNNEFnQWdBVUVFYWlFQklBQkJBbW9oQUNBRVFRRnFJZ1FnQWtjTkFBc0xJQU5CRUdva0FBdXFDQUlOZndGN0l3QkJFR3NpQ0NRQUFuOGdBQ2dDQ0VFUVJnUkFJQUFvQXB3QklBQW9Bc3dCUVl3c2JHb01BUXNnQUNnQ0RBc2hDUUpBSUFKRkJFQWdBMEVCUWZBZlFRQVFDQXdCQ3lBQUtBSklJUVpCQVNFRUlBRWdDRUVJYWtFQkVBb2dDQ2dDQ0NJRlFRSlBCRUFnQTBFQ1FjZkhBRUVBRUFnTUFRc2dBaUFGUVFGcVJ3UkFRUUFoQkNBRFFRSkI4QjlCQUJBSURBRUxBa0FnQmlnQ0VDSURSUTBBSUFrb0F0QXJJUVFnQTBFSVR3UkFJQU5CZUhFaEJrRUFJUUlEUUNBRVFRQTJBcnhESUFSQkFEWUNoRHNnQkVFQU5nTE1NaUFFUVFBMkFwUXFJQVJCQURZQzNDRWdCRUVBTmdLa0dTQUVRUUEyQXV3UUlBUkJBRFlDdEFnZ0JFSEF3d0JxSVFRZ0FrRUlhaUlDSUFaSERRQUxDeUFEUVFkeElnTkZEUUJCQUNFQ0EwQWdCRUVBTmdLMENDQUVRYmdJYWlFRUlBSkJBV29pQWlBRFJ3MEFDd3NnQ1NnQzZDc2lBZ1IvSUFJUUNTQUpRUUEyQXVncklBZ29BZ2dGSUFVTFJRUkFRUUVoQkF3QkN3TkFJQUZCQVdvaUFTQUlRUXhxUVFFUUNnSkFJQWtvQW9Bc1JRMEFJQWtvQXZ3cklnTW9BZ0FnQ0NnQ0RFY05BQ0FES0FJRUlnVWdBQ2dDU0NJR0tBSVFSdzBBSUFNb0FnZ2lBZ1JBUVFBaEJDQUNLQUlRSUFVZ0JXd2lCU0FDS0FJQVFRSjBRZUM5QVdvb0FnQnNSdzBESUFrZ0JVRUNkQkFOSWdjMkF1Z3JJQWRGRFFNZ0FpZ0NEQ0FISUFVZ0FpZ0NBRUVDZEVHUXdBRnFLQUlBRVFVQUN5QURLQUlNSWdKRkRRQkJBQ0VFSUFJb0FoQWdCaWdDRUNJRElBSW9BZ0JCQW5SQjRMMEJhaWdDQUd4SERRSWdBMEVDZEJBTklnVkZEUUlnQWlnQ0RDQUZJQU1nQWlnQ0FFRUNkRUdnd0FGcUtBSUFFUVVBQWtBZ0JpZ0NFQ0lIUlEwQUlBa29BdEFySVFSQkFDRUxBa0FDUUNBSFFRUkpEUUFnQkVHMENHb2lEQ0FGSUFkQkFuUnFTUVJBSUFVZ0JDQUhRYmdJYkdwSkRRRUxJQVJCM0NGcUlRMGdCRUdrR1dvaERpQUVRZXdRYWlFUElBVWdCMEY4Y1NJR1FRSjBhaUVDSUFRZ0JrRzRDR3hxSVFSQkFDRURBMEFnRENBRFFiZ0liQ0lLYWlBRklBTkJBblJxL1FBQ0FDSVIvVm9DQUFBZ0NpQVBhaUFSL1ZvQ0FBRWdDaUFPYWlBUi9Wb0NBQUlnQ2lBTmFpQVIvVm9DQUFNZ0EwRUVhaUlESUFaSERRQUxJQVlnQjBZTkFnd0JDeUFGSVFKQkFDRUdDeUFISUFZaUEydEJCM0VpQ2dSQUEwQWdCQ0FDS0FJQU5nSzBDQ0FEUVFGcUlRTWdCRUc0Q0dvaEJDQUNRUVJxSVFJZ0MwRUJhaUlMSUFwSERRQUxDeUFHSUFkclFYaExEUUFEUUNBRUlBSW9BZ0EyQXJRSUlBUWdBaWdDQkRZQzdCQWdCQ0FDS0FJSU5nS2tHU0FFSUFJb0FndzJBdHdoSUFRZ0FpZ0NFRFlDbENvZ0JDQUNLQUlVTmdMTU1pQUVJQUlvQWhnMkFvUTdJQVFnQWlnQ0hEWUN2RU1nQkVIQXd3QnFJUVFnQWtFZ2FpRUNJQU5CQ0dvaUF5QUhSdzBBQ3dzZ0JSQUpDMEVCSVFRZ0VFRUJhaUlRSUFnb0FnaEpEUUFMQ3lBSVFSQnFKQUFnQkFzRUFFSi9DNzhKQVF0L0l3QkJFR3NpQlNRQUFuOGdBQ2dDQ0VFUVJnUkFJQUFvQXB3QklBQW9Bc3dCUVl3c2JHb01BUXNnQUNnQ0RBc2hCd0ovSUFKQkFVMEVRQ0FEUVFGQjJDTkJBQkFJUVFBTUFRc2dBU0FGUVF4cVFRSVFDaUFGS0FJTUJFQWdBMEVDUWZBc1FRQVFDRUVCREFFTElBSkJCazBFUUNBRFFRRkIyQ05CQUJBSVFRQU1BUXNnQVVFQ2FpQUZRUWhxUVFFUUNpQUhLQUw4S3lJSklRQUNRQUpBQWtBZ0J5Z0NnQ3dpQmtVTkFDQUZLQUlJSVFnRFFDQUFLQUlBSUFoR0RRRWdBRUVVYWlFQUlBUkJBV29pQkNBR1J3MEFDd3dCQ3lBRUlBWkhEUUVMSUFjb0FvUXNJQVpHQkg4Z0J5QUdRUXBxSWdBMkFvUXNJQWtnQUVFVWJCQVFJZ0JGQkVBZ0J5Z0MvQ3NRQ1NBSFFRQTJBb1FzSUFkQ0FEY0MvQ3NnQTBFQlFmSWpRUUFRQ0VFQURBTUxJQWNnQURZQy9Dc2dBQ0FIS0FLQUxDSUVRUlJzYWtFQUlBY29Bb1FzSUFSclFSUnNFQTRhSUFjb0F2d3JJUWtnQnlnQ2dDd0ZJQVlMUVJSc0lBbHFJUUJCQVNFTEN5QUFJQVVvQWdnMkFnQWdBVUVEYWlBRlFReHFRUUlRQ2lBRktBSU1CRUFnQTBFQ1FmQXNRUUFRQ0VFQkRBRUxJQUZCQldvZ0JVRUVha0VDRUFvZ0JTZ0NCQ0lFUVFKUEJFQWdBMEVDUWFnWFFRQVFDRUVCREFFTElBSkJCMnNoQmlBRUJFQWdBVUVIYWlFQ1FRQWhDUU5BSUFaQkFrMEVRQ0FEUVFGQjJDTkJBQkFJUVFBTUF3c2dBaUFGUVF4cVFRRVFDaUFGS0FJTVFRRkhCRUFnQTBFQ1FiSXFRUUFRQ0VFQkRBTUxJQUpCQVdvZ0JVRUNFQW9nQUNBRktBSUFJZ1JCLy84QmNTSUJOZ0lFSUFaQkEyc2lDQ0FFUVE5MlFRRnFJZ1lnQVd4QkFtb2lDa2tFUUNBRFFRRkIyQ05CQUJBSVFRQU1Bd3NnQWtFRGFpRUNRUUFoQkNBQkJFQURRQ0FDSUFWQkRHb2dCaEFLSUFRZ0JTZ0NERWNFUUNBRFFRSkIyaTlCQUJBSVFRRU1CUXNnQWlBR2FpRUNJQVJCQVdvaUJDQUFLQUlFU1EwQUN3c2dBaUFGUVFJUUNpQUZJQVVvQWdBaUJFSC8vd0Z4SWdFMkFnQWdBQ2dDQkNBQlJ3UkFJQU5CQWtIWUdFRUFFQWhCQVF3REN5QUlJQXBySWdvZ0JFRVBka0VCYWlJR0lBRnNRUU5xSWd4SkJFQWdBMEVCUWRnalFRQVFDRUVBREFNTElBSkJBbW9oQWtFQUlRUWdBUVJBQTBBZ0FpQUZRUXhxSUFZUUNpQUVJQVVvQWd4SEJFQWdBMEVDUWRvdlFRQVFDRUVCREFVTElBSWdCbW9oQWlBRVFRRnFJZ1FnQUNnQ0JFa05BQXNMSUFJZ0JVRU1ha0VERUFvZ0JTZ0NEQ0VHSUFCQ0FEY0NDQ0FBSUFaQmdJQUVjVVVnQUMwQUVFSCtBWEZ5T2dBUUlBVWdCa0gvQVhFaUNEWUNDQUpBSUFoRkRRQWdCeWdDOUNzaURRUkFJQWNvQXZBcklRUkJBQ0VCQTBBZ0NDQUVLQUlJUmdSQUlBQWdCRFlDQ0F3REN5QUVRUlJxSVFRZ0FVRUJhaUlCSUExSERRQUxDeUFEUVFGQjJDTkJBQkFJUVFBTUF3c2dCU0FHUVFoMlFmOEJjU0lHTmdJSUFrQWdCa1VOQUNBSEtBTDBLeUlJQkVBZ0J5Z0M4Q3NoQkVFQUlRRURRQ0FHSUFRb0FnaEdCRUFnQUNBRU5nSU1EQU1MSUFSQkZHb2hCQ0FCUVFGcUlnRWdDRWNOQUFzTElBTkJBVUhZSTBFQUVBaEJBQXdEQ3lBS0lBeHJJUVlnQWtFRGFpRUNJQWxCQVdvaUNTQUZLQUlFU1EwQUN3c2dCZ1JBSUFOQkFVSFlJMEVBRUFoQkFBd0JDMEVCSUF0RkRRQWFJQWNnQnlnQ2dDeEJBV28yQW9Bc1FRRUxJUTRnQlVFUWFpUUFJQTRMOVFFQkJYOGpBRUVRYXlJRUpBQUNRQ0FDSUFBb0FrZ29BaEFpQmtFQ2FrY0VRQ0FEUVFGQjhDSkJBQkFJREFFTElBRWdCRUVNYWtFQ0VBb2dCaUFFS0FJTVJ3UkFJQU5CQVVId0lrRUFFQWdNQVFzZ0JrVUVRRUVCSVFVTUFRc2dBVUVDYWlFQ0lBQW9Ba2dvQWhnaEFFRUFJUUVEUUNBQ0lBUkJDR3BCQVJBS0lBQWdCQ2dDQ0NJRlFmOEFjU0lIUVFGcUlnZzJBaGdnQUNBRlFRZDJRUUZ4TmdJZ0lBZEJIMDhFUUNBRUlBZzJBZ1FnQkNBQk5nSUFJQU5CQVVISDh3QWdCQkFJUVFBaEJRd0NDeUFBUVRScUlRQkJBU0VGSUFKQkFXb2hBaUFCUVFGcUlnRWdCa2NOQUFzTElBUkJFR29rQUNBRkM1Z0ZBUXAvSXdCQkVHc2lCeVFBQW44Z0FDZ0NDRUVRUmdSQUlBQW9BcHdCSUFBb0Fzd0JRWXdzYkdvTUFRc2dBQ2dDREFzaEJRSi9JQUpCQVUwRVFDQURRUUZCOFI1QkFCQUlRUUFNQVFzZ0FTQUhRUXhxUVFJUUNnSkFJQWNvQWd3RVFDQURRUUpCaGh0QkFCQUlEQUVMSUFKQkJrMEVRQ0FEUVFGQjhSNUJBQkFJUVFBTUFnc2dBVUVDYWlBSFFReHFRUUlRQ2lBRktBTHdLeUVFSUFjdEFBd2hDZ0pBQWtBQ1FDQUZLQUwwS3lJR1JRUkFJQVFoQUF3QkN5QUVJUUFEUUNBQUtBSUlJQXBHRFFFZ0FFRVVhaUVBSUFoQkFXb2lDQ0FHUncwQUN3d0JDeUFHSUFoSERRRUxJQVVvQXZncklBWkdCRUFnQlNBR1FRcHFJZ0EyQXZncklBUWdBRUVVYkJBUUlRQWdCU2dDOENzaEJDQUFSUVJBSUFRUUNTQUZRUUEyQXZncklBVkNBRGNDOENzZ0EwRUJRWXNmUVFBUUNFRUFEQVFMQWtBZ0FDQUVSZzBBSUFVb0FvQXNJZ3RGRFFBZ0JTZ0MvQ3NoREVFQUlRZ0RRQ0FNSUFoQkZHeHFJZ1lvQWdnaUNRUkFJQVlnQUNBSklBUnJhallDQ0FzZ0JpZ0NEQ0lKQkVBZ0JpQUFJQWtnQkd0cU5nSU1DeUFJUVFGcUlnZ2dDMGNOQUFzTElBVWdBRFlDOENzZ0FDQUZLQUwwS3lJRVFSUnNha0VBSUFVb0F2Z3JJQVJyUVJSc0VBNGFJQVVvQXZRcklRWWdCU2dDOENzaEJBc2dCU0FHUVFGcU5nTDBLeUFFSUFaQkZHeHFJUUFMSUFBb0Fnd2lCQVJBSUFRUUNTQUFRZ0EzQWd3TElBQWdDallDQ0NBQUlBY29BZ3dpQkVFS2RrRURjVFlDQUNBQUlBUkJDSFpCQTNFMkFnUWdBVUVFYWlBSFFReHFRUUlRQ2lBSEtBSU1CRUFnQTBFQ1FiMFdRUUFRQ0F3QkN5QUFJQUpCQm1zaUFoQU5JZ1EyQWd3Z0JFVUVRQ0FEUVFGQjhSNUJBQkFJUVFBTUFnc2dCQ0FCUVFacUlBSVFDeG9nQUNBQ05nSVFDMEVCQ3lFTklBZEJFR29rQUNBTkN5Y0FRUUVoQVNBQ0lBQW9Ba2dvQWhCQkFuUkhCSDhnQTBFQlFkY2hRUUFRQ0VFQUJVRUJDd3VyQXdFRmZ5TUFRUkJySWdZa0FBSi9JQUpCQVUwRVFDQURRUUZCL1IxQkFCQUlRUUFNQVFzZ0FDMEF2QUZCQVhFRVFDQURRUUZCbWQ0QVFRQVFDRUVBREFFTElBQW9BcHdCSUFBb0Fzd0JRWXdzYkdvaUFDQUFMUUNJTEVFQ2Nqb0FpQ3dnQVNBR1FReHFRUUVRQ2dKQUlBQW9BcXdvSWdSRkJFQWdBQ0FHS0FJTVFRRnFJZ1ZCQ0JBTUlnUTJBcXdvSUFSRkJFQWdBMEVCUVpjZVFRQVFDRUVBREFNTElBQWdCVFlDcUNnTUFRc2dCaWdDRENJRklBQW9BcWdvU1EwQUlBUWdCVUVCYWlJRVFRTjBFQkFpQlVVRVFDQURRUUZCbHg1QkFCQUlRUUFNQWdzZ0FDQUZOZ0tzS0NBRklBQW9BcWdvSWdkQkEzUnFRUUFnQkNBSGEwRURkQkFPR2lBQUlBUTJBcWdvSUFBb0Fxd29JUVFMSUFRZ0JpZ0NEQ0lGUVFOMGFpZ0NBQVJBSUFZZ0JUWUNBQ0FEUVFGQnZUVWdCaEFJUVFBTUFRc2dBa0VCYXlJQ0VBMGhCQ0FBS0FLc0tDSUFJQVlvQWd3aUJVRURkR29nQkRZQ0FDQUVSUVJBSUFOQkFVR1hIa0VBRUFoQkFBd0JDeUFBSUFWQkEzUnFJQUkyQWdRZ0FDQUdLQUlNUVFOMGFpZ0NBQ0FCUVFGcUlBSVFDeHBCQVFzaENDQUdRUkJxSkFBZ0NBdjFBZ0VGZnlNQVFSQnJJZ1lrQUFKL0lBSkJBVTBFUUNBRFFRRkJwQ0JCQUJBSVFRQU1BUXNnQUNBQUxRQzhBVUVCY2pvQXZBRWdBU0FHUVF4cVFRRVFDZ0pBSUFBb0FuUWlCRVVFUUNBQUlBWW9BZ3hCQVdvaUJVRUlFQXdpQkRZQ2RDQUVSUVJBSUFOQkFVRytJRUVBRUFoQkFBd0RDeUFBSUFVMkFuQU1BUXNnQmlnQ0RDSUZJQUFvQW5CSkRRQWdCQ0FGUVFGcUlnUkJBM1FRRUNJRlJRUkFJQU5CQVVHK0lFRUFFQWhCQUF3Q0N5QUFJQVUyQW5RZ0JTQUFLQUp3SWdkQkEzUnFRUUFnQkNBSGEwRURkQkFPR2lBQUlBUTJBbkFnQUNnQ2RDRUVDeUFFSUFZb0Fnd2lCVUVEZEdvb0FnQUVRQ0FHSUFVMkFnQWdBMEVCUWRNMUlBWVFDRUVBREFFTElBSkJBV3NpQWhBTklRUWdBQ2dDZENJQUlBWW9BZ3dpQlVFRGRHb2dCRFlDQUNBRVJRUkFJQU5CQVVHK0lFRUFFQWhCQUF3QkN5QUFJQVZCQTNScUlBSTJBZ1FnQUNBR0tBSU1RUU4wYWlnQ0FDQUJRUUZxSUFJUUN4cEJBUXNoQ0NBR1FSQnFKQUFnQ0F1Z0FRRUVmeU1BUVJCcklnUWtBQUovSUFKRkJFQWdBMEVCUWRjZVFRQVFDRUVBREFFTElBRWdCRUVNYWtFQkVBcEJBU0FDUVFGcklnVkZEUUFhUVFBaEFFRUFJUUlEUUNBQlFRRnFJZ0VnQkVFSWFrRUJFQW9nQkNnQ0NDSUdRUmgwUVI5MUlBWkIvd0J4SUFKeVFRZDBjU0VDSUFCQkFXb2lBQ0FGUncwQUMwRUJJQUpGRFFBYUlBTkJBVUhYSGtFQUVBaEJBQXNoQnlBRVFSQnFKQUFnQndzYkFFRUJJUUFnQWdSL1FRRUZJQU5CQVVIK0lFRUFFQWhCQUFzTGdBRUJBWDhqQUVFUWF5SUFKQUJCQVNFRUFrQWdBa0VCVFFSQVFRQWhCQ0FEUVFGQjVDQkJBQkFJREFFTElBRWdBRUVNYWtFQkVBb2dBVUVCYWlBQVFRaHFRUUVRQ2lBQ1FRSnJJQUFvQWdnaUFVRUZka0VDY1NBQlFRUjJRUU54YWtFQ2FuQkZEUUJCQUNFRUlBTkJBVUhrSUVFQUVBZ0xJQUJCRUdva0FDQUVDd1FBUVFBTEMvbTdBUndBUVlBSUM2RjFZMkZ1Ym05MElHRnNiRzlqWVhSbElHOXdhbDkwWTJSZmMyVm5YMlJoZEdGZlkyaDFibXRmZENvZ1lYSnlZWGtBTFNzZ0lDQXdXREI0QUMwd1dDc3dXQ0F3V0Mwd2VDc3dlQ0F3ZUFCVmJtdHViM2R1SUdadmNtMWhkQUJHWVdsc1pXUWdkRzhnYzJWMElIUm9aU0JrWldOdlpHVmtJR052YlhCdmJtVnVkSE1BUm1GcGJHVmtJSFJ2SUhObGRIVndJSFJvWlNCa1pXTnZaR1Z5QUVaaGFXeGxaQ0IwYnlCeVpXRmtJSFJvWlNCb1pXRmtaWElBYm1GdUFDcHNYM1JwYkdWZmJHVnVJRDRnVlVsT1ZGOU5RVmdnTFNCUFVFcGZRMDlOVFU5T1gwTkNURXRmUkVGVVFWOUZXRlJTUVNBdElIQmZhakpyTFQ1dFgzTndaV05wWm1salgzQmhjbUZ0TG0xZlpHVmpiMlJsY2k1dFgzTnZkRjlzWlc1bmRHZ0FhVzVtQUVaaGFXeGxaQ0IwYnlCa1pXTnZaR1VnZEdobElHbHRZV2RsQUVsdWRtRnNhV1FnWVdOalpYTnpJSFJ2SUhCcExUNXBibU5zZFdSbEFFRk1URjlEVUZWVEFFOVFTbDlPVlUxZlZFaFNSVUZFVXdCT1FVNEFTVTVHQUhCZmFqSnJMVDV0WDNOd1pXTnBabWxqWDNCaGNtRnRMbTFmWkdWamIyUmxjaTV0WDNOdmRGOXNaVzVuZEdnZ1BpQlZTVTVVWDAxQldDQXRJRTlRU2w5RFQwMU5UMDVmUTBKTVMxOUVRVlJCWDBWWVZGSkJBQWtKQ1NCd2NtVmpZMmx1ZEhOcGVtVWdLSGNzYUNrOUFBa0pDU0J6ZEdWd2MybDZaWE1nS0cwc1pTazlBQzRBS0c1MWJHd3BBQ2dsWkN3bFpDa2dBQ1Z6ZlFvQUNRa2dmUW9BVzBSRlZsMGdSSFZ0Y0NCaGJpQnBiV0ZuWlY5amIyMXdYMmhsWVdSbGNpQnpkSEoxWTNRZ2V3b0FXMFJGVmwwZ1JIVnRjQ0JoYmlCcGJXRm5aVjlvWldGa1pYSWdjM1J5ZFdOMElIc0tBRWx0WVdkbElHbHVabThnZXdvQUNTQmtaV1poZFd4MElIUnBiR1VnZXdvQUpYTUpJR052YlhCdmJtVnVkQ0FsWkNCN0NnQUpDU0JqYjIxd0lDVmtJSHNLQUFrZ1ZHbHNaU0JwYm1SbGVEb2dld29BQ1NCTllYSnJaWElnYkdsemREb2dld29BUTI5a1pYTjBjbVZoYlNCcGJtUmxlQ0JtY205dElHMWhhVzRnYUdWaFpHVnlPaUI3Q2dCRGIyUmxjM1J5WldGdElHbHVabThnWm5KdmJTQnRZV2x1SUdobFlXUmxjam9nZXdvQVUzUnlaV0Z0SUdWeWNtOXlJSGRvYVd4bElISmxZV1JwYm1jZ1NsQXlJRWhsWVdSbGNpQmliM2dLQUVadmRXNWtJR0VnYldsemNHeGhZMlZrSUNjbFl5VmpKV01sWXljZ1ltOTRJRzkxZEhOcFpHVWdhbkF5YUNCaWIzZ0tBRTFoYkdadmNtMWxaQ0JLVURJZ1ptbHNaU0JtYjNKdFlYUTZJR1pwY25OMElHSnZlQ0J0ZFhOMElHSmxJRXBRUlVjZ01qQXdNQ0J6YVdkdVlYUjFjbVVnWW05NENnQk5ZV3htYjNKdFpXUWdTbEF5SUdacGJHVWdabTl5YldGME9pQnpaV052Ym1RZ1ltOTRJRzExYzNRZ1ltVWdabWxzWlNCMGVYQmxJR0p2ZUFvQVRtOTBJR1Z1YjNWbmFDQnRaVzF2Y25rZ2RHOGdhR0Z1Wkd4bElHcHdaV2N5TURBd0lHSnZlQW9BVG05MElHVnViM1ZuYUNCdFpXMXZjbmtnZDJsMGFDQkdWRmxRSUVKdmVBb0FRU0J0WVhKclpYSWdTVVFnZDJGeklHVjRjR1ZqZEdWa0lDZ3dlR1ptTFMwcElHbHVjM1JsWVdRZ2IyWWdKUzQ0ZUFvQUNRa2diV04wUFNWNENnQUpDUWtnWTJKc2EzTjBlVDBsSTNnS0FBa0pDU0JqYzNSNVBTVWplQW9BQ1FrZ2NISm5QU1VqZUFvQVNXNTBaV2RsY2lCdmRtVnlabXh2ZHdvQUNTQjBaSGc5SlhVc0lIUmtlVDBsZFFvQUNTQjBkejBsZFN3Z2RHZzlKWFVLQUFrZ2RIZ3dQU1YxTENCMGVUQTlKWFVLQUVsdWRtRnNhV1FnWTI5dGNHOXVaVzUwSUdsdVpHVjRPaUFsZFFvQVUzUnlaV0Z0SUhSdmJ5QnphRzl5ZEFvQVRXRnlhMlZ5SUdoaGJtUnNaWElnWm5WdVkzUnBiMjRnWm1GcGJHVmtJSFJ2SUhKbFlXUWdkR2hsSUcxaGNtdGxjaUJ6WldkdFpXNTBDZ0JPYjNRZ1pXNXZkV2RvSUcxbGJXOXllU0JtYjNJZ1kzVnljbVZ1ZENCd2NtVmphVzVqZENCamIyUmxZbXh2WTJzZ1pXeGxiV1Z1ZEFvQVJYSnliM0lnY21WaFpHbHVaeUJUVUVOdlpDQlRVRU52WXlCbGJHVnRaVzUwQ2dCRmNuSnZjaUJ5WldGa2FXNW5JRk5SWTJRZ2IzSWdVMUZqWXlCbGJHVnRaVzUwQ2dCQklFSlFRME1nYUdWaFpHVnlJR0p2ZUNCcGN5QmhkbUZwYkdGaWJHVWdZV3gwYUc5MVoyZ2dRbEJESUdkcGRtVnVJR0o1SUhSb1pTQkpTRVJTSUdKdmVDQW9KV1FwSUdsdVpHbGpZWFJsSUdOdmJYQnZibVZ1ZEhNZ1ltbDBJR1JsY0hSb0lHbHpJR052Ym5OMFlXNTBDZ0JGY25KdmNpQjNhWFJvSUZOSldpQnRZWEpyWlhJNklHbHNiR1ZuWVd3Z2RHbHNaU0J2Wm1aelpYUUtBRWx1ZG1Gc2FXUWdjSEpsWTJsdVkzUUtBRTV2ZENCbGJtOTFaMmdnYldWdGIzSjVJSFJ2SUdoaGJtUnNaU0JpWVc1a0lIQnlaV05wYm5SekNnQkdZV2xzWldRZ2RHOGdaR1ZqYjJSbElHRnNiQ0IxYzJWa0lHTnZiWEJ2Ym1WdWRITUtBRk5wZW1VZ2IyWWdZMjlrWlNCaWJHOWpheUJrWVhSaElHVjRZMlZsWkhNZ2MzbHpkR1Z0SUd4cGJXbDBjd29BVTJsNlpTQnZaaUIwYVd4bElHUmhkR0VnWlhoalpXVmtjeUJ6ZVhOMFpXMGdiR2x0YVhSekNnQkRZVzV1YjNRZ2RHRnJaU0JwYmlCamFHRnlaMlVnYlhWc2RHbHdiR1VnVFVOVUlHMWhjbXRsY25NS0FFTnZjbkoxY0hSbFpDQlFVRTBnYldGeWEyVnljd29BVG05MElHVnViM1ZuYUNCdFpXMXZjbmtnWm05eUlIUnBiR1VnY21WemIyeDFkR2x2Ym5NS0FFTmhibTV2ZENCMFlXdGxJR2x1SUdOb1lYSm5aU0J0ZFd4MGFYQnNaU0JqYjJ4c1pXTjBhVzl1Y3dvQVNXNTJZV3hwWkNCUVEweFNJR0p2ZUM0Z1VtVndiM0owY3lBd0lIQmhiR1YwZEdVZ1kyOXNkVzF1Y3dvQVYyVWdaRzhnYm05MElITjFjSEJ2Y25RZ1VrOUpJR2x1SUdSbFkyOWthVzVuSUVoVUlHTnZaR1ZpYkc5amEzTUtBRU5oYm01dmRDQm9ZVzVrYkdVZ1ltOTRJRzltSUhWdVpHVm1hVzVsWkNCemFYcGxjd29BUTJGdWJtOTBJSFJoYTJVZ2FXNGdZMmhoY21kbElHTnZiR3hsWTNScGIyNXpJSGRwZEdodmRYUWdjMkZ0WlNCdWRXMWlaWElnYjJZZ2FXNWthWGhsY3dvQVNXNTJZV3hwWkNCMGFXeGxZeTArZDJsdVgzaDRlQ0IyWVd4MVpYTUtBRU5oYm01dmRDQm9ZVzVrYkdVZ1ltOTRJRzltSUd4bGMzTWdkR2hoYmlBNElHSjVkR1Z6Q2dCRFlXNXViM1FnYUdGdVpHeGxJRmhNSUdKdmVDQnZaaUJzWlhOeklIUm9ZVzRnTVRZZ1lubDBaWE1LQUVOdmJYQnZibVZ1ZENCcGJtUmxlQ0FsZFNCMWMyVmtJSE5sZG1WeVlXd2dkR2x0WlhNS0FFbHVkbUZzYVdRZ1VFTk1VaUJpYjNndUlGSmxjRzl5ZEhNZ0pXUWdaVzUwY21sbGN3b0FUbTkwSUdWdWIzVm5hQ0J0WlcxdmNua2dkRzhnWTNKbFlYUmxJRlJoWnkxMGNtVmxJRzV2WkdWekNnQkRZVzV1YjNRZ2RHRnJaU0JwYmlCamFHRnlaMlVnYldOMElHUmhkR0VnZDJsMGFHbHVJRzExYkhScGNHeGxJRTFEVkNCeVpXTnZjbVJ6Q2dCRFlXNXViM1FnWkdWamIyUmxJSFJwYkdVc0lHMWxiVzl5ZVNCbGNuSnZjZ29BYjNCcVgyb3lhMTloY0hCc2VWOXVZbDkwYVd4bFgzQmhjblJ6WDJOdmNuSmxZM1JwYjI0Z1pYSnliM0lLQUZCeWIySnNaVzBnZDJsMGFDQnphMmx3Y0dsdVp5QktVRVZITWpBd01DQmliM2dzSUhOMGNtVmhiU0JsY25KdmNnb0FVSEp2WW14bGJTQjNhWFJvSUhKbFlXUnBibWNnU2xCRlJ6SXdNREFnWW05NExDQnpkSEpsWVcwZ1pYSnliM0lLQUZWdWEyNXZkMjRnYldGeWEyVnlDZ0JPYjNRZ1pXNXZkV2RvSUcxbGJXOXllU0IwYnlCaFpHUWdkR3dnYldGeWEyVnlDZ0JPYjNRZ1pXNXZkV2RvSUcxbGJXOXllU0IwYnlCaFpHUWdiV2dnYldGeWEyVnlDZ0JPYjNRZ1pXNXZkV2RvSUcxbGJXOXllU0IwYnlCMFlXdGxJR2x1SUdOb1lYSm5aU0JUU1ZvZ2JXRnlhMlZ5Q2dCRmNuSnZjaUJ5WldGa2FXNW5JRkJRVkNCdFlYSnJaWElLQUU1dmRDQmxibTkxWjJnZ2JXVnRiM0o1SUhSdklISmxZV1FnVUZCVUlHMWhjbXRsY2dvQVJYSnliM0lnY21WaFpHbHVaeUJUVDFRZ2JXRnlhMlZ5Q2dCRmNuSnZjaUJ5WldGa2FXNW5JRkJNVkNCdFlYSnJaWElLQUVWeWNtOXlJSEpsWVdScGJtY2dUVU5VSUcxaGNtdGxjZ29BVG05MElHVnViM1ZuYUNCdFpXMXZjbmtnZEc4Z2NtVmhaQ0JOUTFRZ2JXRnlhMlZ5Q2dCT2IzUWdaVzV2ZFdkb0lITndZV05sSUdadmNpQmxlSEJsWTNSbFpDQlRUMUFnYldGeWEyVnlDZ0JGZUhCbFkzUmxaQ0JUVDFBZ2JXRnlhMlZ5Q2dCRmNuSnZjaUJ5WldGa2FXNW5JRTFEVHlCdFlYSnJaWElLQUVWeWNtOXlJSEpsWVdScGJtY2dVa2RPSUcxaGNtdGxjZ29BUlhKeWIzSWdjbVZoWkdsdVp5QlFVRTBnYldGeWEyVnlDZ0JPYjNRZ1pXNXZkV2RvSUcxbGJXOXllU0IwYnlCeVpXRmtJRkJRVFNCdFlYSnJaWElLQUVWeWNtOXlJSEpsWVdScGJtY2dWRXhOSUcxaGNtdGxjZ29BUlhKeWIzSWdjbVZoWkdsdVp5QlFURTBnYldGeWEyVnlDZ0JPYjNRZ1pXNXZkV2RvSUhOd1lXTmxJR1p2Y2lCbGVIQmxZM1JsWkNCRlVFZ2diV0Z5YTJWeUNnQkZlSEJsWTNSbFpDQkZVRWdnYldGeWEyVnlDZ0JGY25KdmNpQnlaV0ZrYVc1bklFTlNSeUJ0WVhKclpYSUtBRlZ1YTI1dmQyNGdjSEp2WjNKbGMzTnBiMjRnYjNKa1pYSWdhVzRnUTA5RUlHMWhjbXRsY2dvQVZXNXJibTkzYmlCVFkyOWtJSFpoYkhWbElHbHVJRU5QUkNCdFlYSnJaWElLQUVWeWNtOXlJSEpsWVdScGJtY2dRMDlFSUcxaGNtdGxjZ29BUlhKeWIzSWdjbVZoWkdsdVp5QlJRMFFnYldGeWEyVnlDZ0JEY25KdmNpQnlaV0ZrYVc1bklFTkNSQ0J0WVhKclpYSUtBRVZ5Y205eUlISmxZV1JwYm1jZ1VFOURJRzFoY210bGNnb0FSWEp5YjNJZ2NtVmhaR2x1WnlCRFQwTWdiV0Z5YTJWeUNnQkZjbkp2Y2lCeVpXRmthVzVuSUZGRFF5QnRZWEpyWlhJS0FFVnljbTl5SUhKbFlXUnBibWNnVFVORElHMWhjbXRsY2dvQVRtOTBJR1Z1YjNWbmFDQnRaVzF2Y25rZ2RHOGdjbVZoWkNCTlEwTWdiV0Z5YTJWeUNnQnlaWEYxYVhKbFpDQlRTVm9nYldGeWEyVnlJRzV2ZENCbWIzVnVaQ0JwYmlCdFlXbHVJR2hsWVdSbGNnb0FjbVZ4ZFdseVpXUWdRMDlFSUcxaGNtdGxjaUJ1YjNRZ1ptOTFibVFnYVc0Z2JXRnBiaUJvWldGa1pYSUtBSEpsY1hWcGNtVmtJRkZEUkNCdFlYSnJaWElnYm05MElHWnZkVzVrSUdsdUlHMWhhVzRnYUdWaFpHVnlDZ0JPYjNRZ1pXNXZkV2RvSUcxbGJXOXllU0IwYnlCb1lXNWtiR1VnYW5CbFp6SXdNREFnWm1sc1pTQm9aV0ZrWlhJS0FFNXZkQ0JsYm05MVoyZ2diV1Z0YjNKNUlIUnZJSEpsWVdRZ2FHVmhaR1Z5Q2dCRmNuSnZjaUIzYVhSb0lFcFFJRk5wWjI1aGRIVnlaU0E2SUdKaFpDQnRZV2RwWXlCdWRXMWlaWElLQUVsdUlGTlBWQ0J0WVhKclpYSXNJRlJRVTI5MElDZ2xaQ2tnYVhNZ2JtOTBJSFpoYkdsa0lISmxaMkZ5WkhNZ2RHOGdkR2hsSUdOMWNuSmxiblFnYm5WdFltVnlJRzltSUhScGJHVXRjR0Z5ZENBb0pXUXBMQ0JuYVhacGJtY2dkWEFLQUVsdUlGTlBWQ0J0WVhKclpYSXNJRlJRVTI5MElDZ2xaQ2tnYVhNZ2JtOTBJSFpoYkdsa0lISmxaMkZ5WkhNZ2RHOGdkR2hsSUhCeVpYWnBiM1Z6SUc1MWJXSmxjaUJ2WmlCMGFXeGxMWEJoY25RZ0tDVmtLU3dnWjJsMmFXNW5JSFZ3Q2dCSmJpQlRUMVFnYldGeWEyVnlMQ0JVVUZOdmRDQW9KV1FwSUdseklHNXZkQ0IyWVd4cFpDQnlaV2RoY21SeklIUnZJSFJvWlNCamRYSnlaVzUwSUc1MWJXSmxjaUJ2WmlCMGFXeGxMWEJoY25RZ0tHaGxZV1JsY2lrZ0tDVmtLU3dnWjJsMmFXNW5JSFZ3Q2dCMGFXeGxjeUJ5WlhGMWFYSmxJR0YwSUd4bFlYTjBJRzl1WlNCeVpYTnZiSFYwYVc5dUNnQk5ZWEpyWlhJZ2FYTWdibTkwSUdOdmJYQnNhV0Z1ZENCM2FYUm9JR2wwY3lCd2IzTnBkR2x2YmdvQVVISnZZbXhsYlNCM2FYUm9JSE5sWldzZ1puVnVZM1JwYjI0S0FFVnljbTl5SUhKbFlXUnBibWNnVTFCRGIyUWdVMUJEYjJNZ1pXeGxiV1Z1ZEN3Z1NXNTJZV3hwWkNCallteHJkeTlqWW14cmFDQmpiMjFpYVc1aGRHbHZiZ29BU1c1MllXeHBaQ0J0ZFd4MGFYQnNaU0JqYjIxd2IyNWxiblFnZEhKaGJuTm1iM0p0WVhScGIyNEtBRU5oYm01dmRDQjBZV3RsSUdsdUlHTm9ZWEpuWlNCamIyeHNaV04wYVc5dWN5QnZkR2hsY2lCMGFHRnVJR0Z5Y21GNUlHUmxZMjl5Y21Wc1lYUnBiMjRLQUZSdmJ5QnNZWEpuWlNCMllXeDFaU0JtYjNJZ1RuQndiUW9BVG05MElHVnViM1ZuYUNCaWVYUmxjeUIwYnlCeVpXRmtJRTV3Y0cwS0FHSmhaQ0J3YkdGalpXUWdhbkJsWnlCamIyUmxjM1J5WldGdENnQUpJRTFoYVc0Z2FHVmhaR1Z5SUhOMFlYSjBJSEJ2YzJsMGFXOXVQU1ZzYkdrS0NTQk5ZV2x1SUdobFlXUmxjaUJsYm1RZ2NHOXphWFJwYjI0OUpXeHNhUW9BVFdGeWEyVnlJSE5wZW1VZ2FXNWpiMjV6YVhOMFpXNTBJSGRwZEdnZ2MzUnlaV0Z0SUd4bGJtZDBhQW9BVkdsc1pTQndZWEowSUd4bGJtZDBhQ0J6YVhwbElHbHVZMjl1YzJsemRHVnVkQ0IzYVhSb0lITjBjbVZoYlNCc1pXNW5kR2dLQUVOaGJtNXZkQ0IwWVd0bElHbHVJR05vWVhKblpTQnRkV3gwYVhCc1pTQmtZWFJoSUhOd1lXNXVhVzVuQ2dCWGNtOXVaeUJtYkdGbkNnQkZjbkp2Y2lCM2FYUm9JRVpVV1ZBZ2MybG5ibUYwZFhKbElFSnZlQ0J6YVhwbENnQkZjbkp2Y2lCM2FYUm9JRXBRSUhOcFoyNWhkSFZ5WlNCQ2IzZ2djMmw2WlFvQVNXNTJZV3hwWkNCd2NtVmphVzVqZENCemFYcGxDZ0JKYm1OdmJuTnBjM1JsYm5RZ2JXRnlhMlZ5SUhOcGVtVUtBRWx1ZG1Gc2FXUWdiV0Z5YTJWeUlITnBlbVVLQUVWeWNtOXlJSGRwZEdnZ1UwbGFJRzFoY210bGNpQnphWHBsQ2dCT2IzUWdaVzV2ZFdkb0lHMWxiVzl5ZVNCMGJ5QmhaR1FnWVNCdVpYY2dkbUZzYVdSaGRHbHZiaUJ3Y205alpXUjFjbVVLQUU1dmRDQmxibTkxWjJnZ2JXVnRiM0o1SUhSdklHUmxZMjlrWlNCMGFXeGxDZ0JHWVdsc1pXUWdkRzhnWkdWamIyUmxJSFJvWlNCamIyUmxjM1J5WldGdElHbHVJSFJvWlNCS1VESWdabWxzWlFvQVEyRnVibTkwSUhSaGEyVWdhVzRnWTJoaGNtZGxJR052Ykd4bFkzUnBiMjV6SUhkcGRHZ2dhVzVrYVhnZ2MyaDFabVpzWlFvQVEyRnVibTkwSUdGc2JHOWpZWFJsSUZScFpYSWdNU0JvWVc1a2JHVUtBRTV2SUdSbFkyOWtaV1FnWVhKbFlTQndZWEpoYldWMFpYSnpMQ0J6WlhRZ2RHaGxJR1JsWTI5a1pXUWdZWEpsWVNCMGJ5QjBhR1VnZDJodmJHVWdhVzFoWjJVS0FFNXZkQ0JsYm05MVoyZ2diV1Z0YjNKNUlIUnZJR055WldGMFpTQlVZV2N0ZEhKbFpRb0FUbTkwSUdWdWIzVm5hQ0J0WlcxdmNua2dkRzhnY21WcGJtbDBhV0ZzYVhwbElIUm9aU0IwWVdjZ2RISmxaUW9BUlhKeWIzSWdjbVZoWkdsdVp5QlRVRU52WkNCVFVFTnZZeUJsYkdWdFpXNTBMQ0JKYm5aaGJHbGtJSFJ5WVc1elptOXliV0YwYVc5dUlHWnZkVzVrQ2dCRmNuSnZjaUJ5WldGa2FXNW5JRk5RUTI5a0lGTlFRMjlqSUdWc1pXMWxiblF1SUZWdWMzVndjRzl5ZEdWa0lFMXBlR1ZrSUVoVUlHTnZaR1V0WW14dlkyc2djM1I1YkdVZ1ptOTFibVFLQUZScGJHVWdXU0JqYjI5eVpHbHVZWFJsY3lCaGNtVWdibTkwSUhOMWNIQnZjblJsWkFvQVZHbHNaU0JZSUdOdmIzSmthVzVoZEdWeklHRnlaU0J1YjNRZ2MzVndjRzl5ZEdWa0NnQkpiV0ZuWlNCamIyOXlaR2x1WVhSbGN5QmhZbTkyWlNCSlRsUmZUVUZZSUdGeVpTQnViM1FnYzNWd2NHOXlkR1ZrQ2dCS1VFVkhNakF3TUNCSVpXRmtaWElnWW05NElHNXZkQ0J5WldGa0lIbGxkQ3dnSnlWakpXTWxZeVZqSnlCaWIzZ2dkMmxzYkNCaVpTQnBaMjV2Y21Wa0NnQnZjR3BmYWpKclgyMWxjbWRsWDNCd2RDZ3BJR2hoY3lCaGJISmxZV1I1SUdKbFpXNGdZMkZzYkdWa0NnQk9iM1FnWlc1dmRXZG9JRzFsYlc5eWVTQjBieUJ5WldGa0lGTlBWQ0J0WVhKclpYSXVJRlJwYkdVZ2FXNWtaWGdnWVd4c2IyTmhkR2x2YmlCbVlXbHNaV1FLQUVsbmJtOXlhVzVuSUdsb1pISWdZbTk0TGlCR2FYSnpkQ0JwYUdSeUlHSnZlQ0JoYkhKbFlXUjVJSEpsWVdRS0FGcHdjSFFnSlhVZ1lXeHlaV0ZrZVNCeVpXRmtDZ0JhY0hCdElDVjFJR0ZzY21WaFpIa2djbVZoWkFvQVVGUkZVazBnWTJobFkyc2dabUZwYkhWeVpUb2dKV1FnYzNsdWRHaGxkR2w2WldRZ01IaEdSaUJ0WVhKclpYSnpJSEpsWVdRS0FBa0pDU0JqWW14cmR6MHlYaVZrQ2dBSkNRa2dZMkpzYTJnOU1sNGxaQW9BQ1FrSklIRnVkSE4wZVQwbFpBb0FKWE1nWkhnOUpXUXNJR1I1UFNWa0NnQUpDUWtnY205cGMyaHBablE5SldRS0FBa0pDU0J1ZFcxblltbDBjejBsWkFvQUNRa2diblZ0YkdGNVpYSnpQU1ZrQ2dBbGN5QnVkVzFqYjIxd2N6MGxaQW9BYjNCcVgycHdNbDloY0hCc2VWOWpaR1ZtT2lCaFkyNDlKV1FzSUc1MWJXTnZiWEJ6UFNWa0NnQnZjR3BmYW5BeVgyRndjR3g1WDJOa1pXWTZJR051UFNWa0xDQnVkVzFqYjIxd2N6MGxaQW9BQ1FrSklHNTFiWEpsYzI5c2RYUnBiMjV6UFNWa0NnQUpDU0IwZVhCbFBTVWplQ3dnY0c5elBTVnNiR2tzSUd4bGJqMGxaQW9BSlhNZ2MyZHVaRDBsWkFvQUNRa0pJSEZ0Wm1KcFpEMGxaQW9BSlhNZ2NISmxZejBsWkFvQUNRa2dibUlnYjJZZ2RHbHNaUzF3WVhKMElHbHVJSFJwYkdVZ1d5VmtYVDBsWkFvQUpYTWdlREU5SldRc0lIa3hQU1ZrQ2dBbGN5QjRNRDBsWkN3Z2VUQTlKV1FLQUVaaGFXeGxaQ0IwYnlCa1pXTnZaR1VnZEdsc1pTQWxaQzhsWkFvQVUyVjBkR2x1WnlCa1pXTnZaR2x1WnlCaGNtVmhJSFJ2SUNWa0xDVmtMQ1ZrTENWa0NnQkdZV2xzWldRZ2RHOGdaR1ZqYjJSbElHTnZiWEJ2Ym1WdWRDQWxaQW9BU1c1MllXeHBaQ0IyWVd4MVpTQm1iM0lnYm5WdGNtVnpiMngxZEdsdmJuTWdPaUFsWkN3Z2JXRjRJSFpoYkhWbElHbHpJSE5sZENCcGJpQnZjR1Z1YW5CbFp5NW9JR0YwSUNWa0NnQkpiblpoYkdsa0lHTnZiWEJ2Ym1WdWRDQnVkVzFpWlhJNklDVmtMQ0J5WldkaGNtUnBibWNnZEdobElHNTFiV0psY2lCdlppQmpiMjF3YjI1bGJuUnpJQ1ZrQ2dCVWIyOGdiV0Z1ZVNCUVQwTnpJQ1ZrQ2dCSmJuWmhiR2xrSUhScGJHVWdiblZ0WW1WeUlDVmtDZ0JKYm5aaGJHbGtJSFJwYkdVZ2NHRnlkQ0JwYm1SbGVDQm1iM0lnZEdsc1pTQnVkVzFpWlhJZ0pXUXVJRWR2ZENBbFpDd2daWGh3WldOMFpXUWdKV1FLQUVWeWNtOXlJSGRwZEdnZ1UwbGFJRzFoY210bGNqb2diblZ0WW1WeUlHOW1JR052YlhCdmJtVnVkQ0JwY3lCcGJHeGxaMkZzSUMwK0lDVmtDZ0JPYjNRZ1pXNXZkV2RvSUcxbGJXOXllU0JtYjNJZ1kybGxiR0ZpQ2dCRFlXNXViM1FnWVd4c2IyTmhkR1VnWTJKc2F5MCtaR1ZqYjJSbFpGOWtZWFJoQ2dCR1lXbHNaV1FnZEc4Z2JXVnlaMlVnVUZCVUlHUmhkR0VLQUVaaGFXeGxaQ0IwYnlCdFpYSm5aU0JRVUUwZ1pHRjBZUW9BU1c1MllXeHBaQ0J1ZFcxaVpYSWdiMllnYkdGNVpYSnpJR2x1SUVOUFJDQnRZWEpyWlhJZ09pQWxaQ0J1YjNRZ2FXNGdjbUZ1WjJVZ1d6RXROalUxTXpWZENnQlRkSEpsWVcwZ2RHOXZJSE5vYjNKMExDQmxlSEJsWTNSbFpDQlRUMVFLQUZWdVlXSnNaU0IwYnlCelpYUWdkREVnYUdGdVpHeGxJR0Z6SUZSTVV3b0FVM1J5WldGdElHUnZaWE1nYm05MElHVnVaQ0IzYVhSb0lFVlBRd29BUTJGdWJtOTBJR2hoYm1Sc1pTQmliM2dnYzJsNlpYTWdhR2xuYUdWeUlIUm9ZVzRnTWw0ek1nb0FiM0JxWDNCcFgyNWxlSFJmYkhKamNDZ3BPaUJwYm5aaGJHbGtJR052YlhCdWJ6QXZZMjl0Y0c1dk1Rb0FiM0JxWDNCcFgyNWxlSFJmY214amNDZ3BPaUJwYm5aaGJHbGtJR052YlhCdWJ6QXZZMjl0Y0c1dk1Rb0FiM0JxWDNCcFgyNWxlSFJmWTNCeWJDZ3BPaUJwYm5aaGJHbGtJR052YlhCdWJ6QXZZMjl0Y0c1dk1Rb0FiM0JxWDNCcFgyNWxlSFJmY0dOeWJDZ3BPaUJwYm5aaGJHbGtJR052YlhCdWJ6QXZZMjl0Y0c1dk1Rb0FiM0JxWDNCcFgyNWxlSFJmY25CamJDZ3BPaUJwYm5aaGJHbGtJR052YlhCdWJ6QXZZMjl0Y0c1dk1Rb0FiM0JxWDNReFgyUmxZMjlrWlY5allteHJLQ2s2SUhWdWMzVndjRzl5ZEdWa0lHSndibTlmY0d4MWMxOXZibVVnUFNBbFpDQStQU0F6TVFvQVJtRnBiR1ZrSUhSdklHUmxZMjlrWlNCMGFXeGxJREV2TVFvQVNXNXpkV1ptYVdOcFpXNTBJR1JoZEdFZ1ptOXlJRU5OUVZBZ1ltOTRMZ29BVG1WbFpDQjBieUJ5WldGa0lHRWdVRU5NVWlCaWIzZ2dZbVZtYjNKbElIUm9aU0JEVFVGUUlHSnZlQzRLQUVsdWMzVm1abWxqYVdWdWRDQmtZWFJoSUdadmNpQkRSRVZHSUdKdmVDNEtBRTUxYldKbGNpQnZaaUJqYUdGdWJtVnNJR1JsYzJOeWFYQjBhVzl1SUdseklHVnhkV0ZzSUhSdklIcGxjbThnYVc0Z1EwUkZSaUJpYjNndUNnQlRkSEpsWVcwZ1pYSnliM0lnZDJocGJHVWdjbVZoWkdsdVp5QktVRElnU0dWaFpHVnlJR0p2ZURvZ2JtOGdKMmxvWkhJbklHSnZlQzRLQUU1dmJpQmpiMjVtYjNKdFlXNTBJR052WkdWemRISmxZVzBnVkZCemIzUTlQVlJPYzI5MExnb0FVM1J5WldGdElHVnljbTl5SUhkb2FXeGxJSEpsWVdScGJtY2dTbEF5SUVobFlXUmxjaUJpYjNnNklHSnZlQ0JzWlc1bmRHZ2dhWE1nYVc1amIyNXphWE4wWlc1MExnb0FRbTk0SUd4bGJtZDBhQ0JwY3lCcGJtTnZibk5wYzNSbGJuUXVDZ0JTWlhOdmJIVjBhVzl1SUdaaFkzUnZjaUJwY3lCbmNtVmhkR1Z5SUhSb1lXNGdkR2hsSUcxaGVHbHRkVzBnY21WemIyeDFkR2x2YmlCcGJpQjBhR1VnWTI5dGNHOXVaVzUwTGdvQVEyOXRjRzl1Wlc1MElHMWhjSEJwYm1jZ2MyVmxiWE1nZDNKdmJtY3VJRlJ5ZVdsdVp5QjBieUJqYjNKeVpXTjBMZ29BU1c1amIyMXdiR1YwWlNCamFHRnVibVZzSUdSbFptbHVhWFJwYjI1ekxnb0FUV0ZzWm05eWJXVmtJRWhVSUdOdlpHVmliRzlqYXk0Z1NXNTJZV3hwWkNCamIyUmxZbXh2WTJzZ2JHVnVaM1JvSUhaaGJIVmxjeTRLQUZkbElHUnZJRzV2ZENCemRYQndiM0owSUcxdmNtVWdkR2hoYmlBeklHTnZaR2x1WnlCd1lYTnpaWE1nYVc0Z1lXNGdTRlFnWTI5a1pXSnNiMk5yT3lCVWFHbHpJR052WkdWaWJHOWphM01nYUdGeklDVmtJSEJoYzNObGN5NEtBRTFoYkdadmNtMWxaQ0JJVkNCamIyUmxZbXh2WTJzdUlFUmxZMjlrYVc1bklIUm9hWE1nWTI5a1pXSnNiMk5ySUdseklITjBiM0J3WldRdUlGUm9aWEpsSUdGeVpTQWxaQ0I2WlhKdklHSnBkSEJzWVc1bGN5QnBiaUFsWkNCaWFYUndiR0Z1WlhNdUNnQkRZVzV1YjNRZ2RHRnJaU0JwYmlCamFHRnlaMlVnYlhWc2RHbHdiR1VnZEhKaGJuTm1iM0p0WVhScGIyNGdjM1JoWjJWekxnb0FWVzVyYm05M2JpQnRZWEpyWlhJZ2FHRnpJR0psWlc0Z1pHVjBaV04wWldRZ1lXNWtJR2RsYm1WeVlYUmxaQ0JsY25KdmNpNEtBRU52WkdWaklIQnliM1pwWkdWa0lIUnZJSFJvWlNCdmNHcGZjMlYwWDJSbFkyOWtaV1JmWTI5dGNHOXVaVzUwY3lCbWRXNWpkR2x2YmlCcGN5QnViM1FnWVNCa1pXTnZiWEJ5WlhOemIzSWdhR0Z1Wkd4bGNpNEtBRU52WkdWaklIQnliM1pwWkdWa0lIUnZJSFJvWlNCdmNHcGZjMlYwZFhCZlpHVmpiMlJsY2lCbWRXNWpkR2x2YmlCcGN5QnViM1FnWVNCa1pXTnZiWEJ5WlhOemIzSWdhR0Z1Wkd4bGNpNEtBRU52WkdWaklIQnliM1pwWkdWa0lIUnZJSFJvWlNCdmNHcGZjbVZoWkY5b1pXRmtaWElnWm5WdVkzUnBiMjRnYVhNZ2JtOTBJR0VnWkdWamIyMXdjbVZ6YzI5eUlHaGhibVJzWlhJdUNnQlVhV3hsY3lCa2IyNG5kQ0JoYkd3Z2FHRjJaU0IwYUdVZ2MyRnRaU0JrYVcxbGJuTnBiMjR1SUZOcmFYQWdkR2hsSUUxRFZDQnpkR1Z3TGdvQVRuVnRZbVZ5SUc5bUlHTnZiWEJ2Ym1WdWRITWdLQ1ZrS1NCcGN5QnBibU52Ym5OcGMzUmxiblFnZDJsMGFDQmhJRTFEVkM0Z1UydHBjQ0IwYUdVZ1RVTlVJSE4wWlhBdUNnQktVRElnWW05NElIZG9hV05vSUdGeVpTQmhablJsY2lCMGFHVWdZMjlrWlhOMGNtVmhiU0IzYVd4c0lHNXZkQ0JpWlNCeVpXRmtJR0o1SUhSb2FYTWdablZ1WTNScGIyNHVDZ0JOWVd4bWIzSnRaV1FnU0ZRZ1kyOWtaV0pzYjJOckxpQlhhR1Z1SUhSb1pTQnVkVzFpWlhJZ2IyWWdlbVZ5YnlCd2JHRnVaWE1nWW1sMGNHeGhibVZ6SUdseklHVnhkV0ZzSUhSdklIUm9aU0J1ZFcxaVpYSWdiMllnWW1sMGNHeGhibVZ6TENCdmJteDVJSFJvWlNCamJHVmhiblZ3SUhCaGMzTWdiV0ZyWlhNZ2MyVnVjMlVzSUdKMWRDQjNaU0JvWVhabElDVmtJSEJoYzNObGN5QnBiaUIwYUdseklHTnZaR1ZpYkc5amF5NGdWR2hsY21WbWIzSmxMQ0J2Ym14NUlIUm9aU0JqYkdWaGJuVndJSEJoYzNNZ2QybHNiQ0JpWlNCa1pXTnZaR1ZrTGlCVWFHbHpJRzFsYzNOaFoyVWdkMmxzYkNCdWIzUWdZbVVnWkdsemNHeGhlV1ZrSUdGbllXbHVMZ29BU1cxaFoyVWdhR0Z6SUd4bGMzTWdZMjl0Y0c5dVpXNTBjeUIwYUdGdUlHTnZaR1Z6ZEhKbFlXMHVDZ0JPWldWa0lIUnZJR1JsWTI5a1pTQjBhR1VnYldGcGJpQm9aV0ZrWlhJZ1ltVm1iM0psSUdKbFoybHVJSFJ2SUdSbFkyOWtaU0IwYUdVZ2NtVnRZV2x1YVc1bklHTnZaR1Z6ZEhKbFlXMHVDZ0JRYzI5MElIWmhiSFZsSUc5bUlIUm9aU0JqZFhKeVpXNTBJSFJwYkdVdGNHRnlkQ0JwY3lCbGNYVmhiQ0IwYnlCNlpYSnZMQ0IzWlNCaGMzTjFiV2x1WnlCcGRDQnBjeUIwYUdVZ2JHRnpkQ0IwYVd4bExYQmhjblFnYjJZZ2RHaGxJR052WkdWemRISmxZVzB1Q2dCQklHMWhiR1p2Y20xbFpDQmpiMlJsWW14dlkyc2dkR2hoZENCb1lYTWdiVzl5WlNCMGFHRnVJRzl1WlNCamIyUnBibWNnY0dGemN5d2dZblYwSUhwbGNtOGdiR1Z1WjNSb0lHWnZjaUF5Ym1RZ1lXNWtJSEJ2ZEdWdWRHbGhiR3g1SUhSb1pTQXpjbVFnY0dGemN5QnBiaUJoYmlCSVZDQmpiMlJsWW14dlkyc3VDZ0FKQ1FrZ2RHbHNaUzF3WVhKMFd5VmtYVG9nYzNSaGNsOXdiM005Sld4c2FTd2daVzVrWDJobFlXUmxjajBsYkd4cExDQmxibVJmY0c5elBTVnNiR2t1Q2dCVWFXeGxJQ1YxSUdoaGN5QlVVSE52ZENBOVBTQXdJR0Z1WkNCVVRuTnZkQ0E5UFNBd0xDQmlkWFFnYm04Z2IzUm9aWElnZEdsc1pTMXdZWEowY3lCM1pYSmxJR1p2ZFc1a0xpQkZUME1nYVhNZ1lXeHpieUJ0YVhOemFXNW5MZ29BUTI5dGNHOXVaVzUwSUNWa0lHUnZaWE51SjNRZ2FHRjJaU0JoSUcxaGNIQnBibWN1Q2dCQklHTnZibVp2Y20xcGJtY2dTbEF5SUhKbFlXUmxjaUJ6YUdGc2JDQnBaMjV2Y21VZ1lXeHNJRU52Ykc5MWNpQlRjR1ZqYVdacFkyRjBhVzl1SUdKdmVHVnpJR0ZtZEdWeUlIUm9aU0JtYVhKemRDd2djMjhnZDJVZ2FXZHViM0psSUhSb2FYTWdiMjVsTGdvQVZHaGxJSE5wWjI1aGRIVnlaU0JpYjNnZ2JYVnpkQ0JpWlNCMGFHVWdabWx5YzNRZ1ltOTRJR2x1SUhSb1pTQm1hV3hsTGdvQVZHaGxJQ0JpYjNnZ2JYVnpkQ0JpWlNCMGFHVWdabWx5YzNRZ1ltOTRJR2x1SUhSb1pTQm1hV3hsTGdvQVZHaGxJR1owZVhBZ1ltOTRJRzExYzNRZ1ltVWdkR2hsSUhObFkyOXVaQ0JpYjNnZ2FXNGdkR2hsSUdacGJHVXVDZ0JHWVdsc1pXUWdkRzhnWkdWamIyUmxMZ29BVFdGc1ptOXliV1ZrSUVoVUlHTnZaR1ZpYkc5amF5NGdTVzVqYjNKeVpXTjBJRTFGVENCelpXZHRaVzUwSUhObGNYVmxibU5sTGdvQVEyOXRjRzl1Wlc1MElDVmtJR2x6SUcxaGNIQmxaQ0IwZDJsalpTNEtBRTl1YkhrZ2IyNWxJRU5OUVZBZ1ltOTRJR2x6SUdGc2JHOTNaV1F1Q2dCaGNIQnNlVjlqYjJ4dmNsOTBjbUZ1YzJadmNtMXpJRDBnVDFCS1gxUlNWVVVnYVhNZ2JtOTBJSE4xY0hCdmNuUmxaQzRLQUZkbElHNWxaV1FnWVc0Z2FXMWhaMlVnY0hKbGRtbHZkWE5zZVNCamNtVmhkR1ZrTGdvQVNVaEVVaUJpYjNoZmJXbHpjMmx1Wnk0Z1VtVnhkV2x5WldRdUNnQktVREpJSUdKdmVDQnRhWE56YVc1bkxpQlNaWEYxYVhKbFpDNEtBRTV2ZENCemRYSmxJR2h2ZHlCMGFHRjBJR2hoY0hCbGJtVmtMZ29BVFdGcGJpQm9aV0ZrWlhJZ2FHRnpJR0psWlc0Z1kyOXljbVZqZEd4NUlHUmxZMjlrWldRdUNnQlVhV3hsSUNWa0x5VmtJR2hoY3lCaVpXVnVJR1JsWTI5a1pXUXVDZ0JJWldGa1pYSWdiMllnZEdsc1pTQWxaQ0F2SUNWa0lHaGhjeUJpWldWdUlISmxZV1F1Q2dCRmJYQjBlU0JUVDFRZ2JXRnlhMlZ5SUdSbGRHVmpkR1ZrT2lCUWMyOTBQU1ZrTGdvQVJHbHlaV04wSUhWelpTQmhkQ0FqSldRZ2FHOTNaWFpsY2lCd1kyOXNQU1ZrTGdvQVNXMXdiR1Z0Wlc1MFlYUnBiMjRnYkdsdGFYUmhkR2x2YmpvZ1ptOXlJSEJoYkdWMGRHVWdiV0Z3Y0dsdVp5d2djR052YkZzbFpGMGdjMmh2ZFd4a0lHSmxJR1Z4ZFdGc0lIUnZJQ1ZrTENCaWRYUWdhWE1nWlhGMVlXd2dkRzhnSldRdUNnQkpiblpoYkdsa0lHTnZiWEJ2Ym1WdWRDOXdZV3hsZEhSbElHbHVaR1Y0SUdadmNpQmthWEpsWTNRZ2JXRndjR2x1WnlBbFpDNEtBRWx1ZG1Gc2FXUWdkbUZzZFdVZ1ptOXlJR050WVhCYkpXUmRMbTEwZVhBZ1BTQWxaQzRLQUZCemIzUWdkbUZzZFdVZ2FYTWdibTkwSUdOdmNuSmxZM1FnY21WbllYSmtjeUIwYnlCMGFHVWdTbEJGUnpJd01EQWdibTl5YlRvZ0pXUXVDZ0JOWVd4bWIzSnRaV1FnU0ZRZ1kyOWtaV0pzYjJOckxpQldURU1nWTI5a1pTQndjbTlrZFdObGN5QnphV2R1YVdacFkyRnVkQ0J6WVcxd2JHVnpJRzkxZEhOcFpHVWdkR2hsSUdOdlpHVmliRzlqYXlCaGNtVmhMZ29BVlc1bGVIQmxZM1JsWkNCUFQwMHVDZ0F6TWlCaWFYUnpJR0Z5WlNCdWIzUWdaVzV2ZFdkb0lIUnZJR1JsWTI5a1pTQjBhR2x6SUdOdlpHVmliRzlqYXl3Z2MybHVZMlVnZEdobElHNTFiV0psY2lCdlppQmlhWFJ3YkdGdVpTd2dKV1FzSUdseklHeGhjbWRsY2lCMGFHRnVJRE13TGdvQVFtOTBkRzl0SUhCdmMybDBhVzl1SUc5bUlIUm9aU0JrWldOdlpHVmtJR0Z5WldFZ0tISmxaMmx2Ymw5NU1UMGxaQ2tnYzJodmRXeGtJR0psSUQ0Z01DNEtBRkpwWjJoMElIQnZjMmwwYVc5dUlHOW1JSFJvWlNCa1pXTnZaR1ZrSUdGeVpXRWdLSEpsWjJsdmJsOTRNVDBsWkNrZ2MyaHZkV3hrSUdKbElENGdNQzRLQUZWd0lIQnZjMmwwYVc5dUlHOW1JSFJvWlNCa1pXTnZaR1ZrSUdGeVpXRWdLSEpsWjJsdmJsOTVNRDBsWkNrZ2MyaHZkV3hrSUdKbElENDlJREF1Q2dCTVpXWjBJSEJ2YzJsMGFXOXVJRzltSUhSb1pTQmtaV052WkdWa0lHRnlaV0VnS0hKbFoybHZibDk0TUQwbFpDa2djMmh2ZFd4a0lHSmxJRDQ5SURBdUNnQkZjbkp2Y2lCeVpXRmthVzVuSUZCUVZDQnRZWEpyWlhJNklIQmhZMnRsZENCb1pXRmtaWElnYUdGMlpTQmlaV1Z1SUhCeVpYWnBiM1Z6YkhrZ1ptOTFibVFnYVc0Z2RHaGxJRzFoYVc0Z2FHVmhaR1Z5SUNoUVVFMGdiV0Z5YTJWeUtTNEtBRk4wWVhKMElIUnZJSEpsWVdRZ2FqSnJJRzFoYVc0Z2FHVmhaR1Z5SUNnbGJHeGtLUzRLQUVKdmRIUnZiU0J3YjNOcGRHbHZiaUJ2WmlCMGFHVWdaR1ZqYjJSbFpDQmhjbVZoSUNoeVpXZHBiMjVmZVRFOUpXUXBJR2x6SUc5MWRITnBaR1VnZEdobElHbHRZV2RsSUdGeVpXRWdLRmx6YVhvOUpXUXBMZ29BVlhBZ2NHOXphWFJwYjI0Z2IyWWdkR2hsSUdSbFkyOWtaV1FnWVhKbFlTQW9jbVZuYVc5dVgza3dQU1ZrS1NCcGN5QnZkWFJ6YVdSbElIUm9aU0JwYldGblpTQmhjbVZoSUNoWmMybDZQU1ZrS1M0S0FGSnBaMmgwSUhCdmMybDBhVzl1SUc5bUlIUm9aU0JrWldOdlpHVmtJR0Z5WldFZ0tISmxaMmx2Ymw5NE1UMGxaQ2tnYVhNZ2IzVjBjMmxrWlNCMGFHVWdhVzFoWjJVZ1lYSmxZU0FvV0hOcGVqMGxaQ2t1Q2dCTVpXWjBJSEJ2YzJsMGFXOXVJRzltSUhSb1pTQmtaV052WkdWa0lHRnlaV0VnS0hKbFoybHZibDk0TUQwbFpDa2dhWE1nYjNWMGMybGtaU0IwYUdVZ2FXMWhaMlVnWVhKbFlTQW9XSE5wZWowbFpDa3VDZ0JDYjNSMGIyMGdjRzl6YVhScGIyNGdiMllnZEdobElHUmxZMjlrWldRZ1lYSmxZU0FvY21WbmFXOXVYM2t4UFNWa0tTQnBjeUJ2ZFhSemFXUmxJSFJvWlNCcGJXRm5aU0JoY21WaElDaFpUM05wZWowbFpDa3VDZ0JWY0NCd2IzTnBkR2x2YmlCdlppQjBhR1VnWkdWamIyUmxaQ0JoY21WaElDaHlaV2RwYjI1ZmVUQTlKV1FwSUdseklHOTFkSE5wWkdVZ2RHaGxJR2x0WVdkbElHRnlaV0VnS0ZsUGMybDZQU1ZrS1M0S0FGSnBaMmgwSUhCdmMybDBhVzl1SUc5bUlIUm9aU0JrWldOdlpHVmtJR0Z5WldFZ0tISmxaMmx2Ymw5NE1UMGxaQ2tnYVhNZ2IzVjBjMmxrWlNCMGFHVWdhVzFoWjJVZ1lYSmxZU0FvV0U5emFYbzlKV1FwTGdvQVRHVm1kQ0J3YjNOcGRHbHZiaUJ2WmlCMGFHVWdaR1ZqYjJSbFpDQmhjbVZoSUNoeVpXZHBiMjVmZURBOUpXUXBJR2x6SUc5MWRITnBaR1VnZEdobElHbHRZV2RsSUdGeVpXRWdLRmhQYzJsNlBTVmtLUzRLQUZOcGVtVWdlQ0J2WmlCMGFHVWdaR1ZqYjJSbFpDQmpiMjF3YjI1bGJuUWdhVzFoWjJVZ2FYTWdhVzVqYjNKeVpXTjBJQ2hqYjIxd1d5VmtYUzUzUFNWa0tTNEtBRk5wZW1VZ2VTQnZaaUIwYUdVZ1pHVmpiMlJsWkNCamIyMXdiMjVsYm5RZ2FXMWhaMlVnYVhNZ2FXNWpiM0p5WldOMElDaGpiMjF3V3lWa1hTNW9QU1ZrS1M0S0FGUnBiR1VnY21WaFpDd2daR1ZqYjJSbFpDQmhibVFnZFhCa1lYUmxaQ0JwY3lCdWIzUWdkR2hsSUdSbGMybHlaV1FnYjI1bElDZ2xaQ0IyY3lBbFpDa3VDZ0JKYm5aaGJHbGtJR052YlhCdmJtVnVkQ0JwYm1SbGVDQWxaQ0FvUGowZ0pXUXBMZ29BYjNCcVgzSmxZV1JmYUdWaFpHVnlLQ2tnYzJodmRXeGtJR0psSUdOaGJHeGxaQ0JpWldadmNtVWdiM0JxWDNObGRGOWtaV052WkdWa1gyTnZiWEJ2Ym1WdWRITW9LUzRLQUUxbGJXOXllU0JoYkd4dlkyRjBhVzl1SUdaaGFXeDFjbVVnYVc0Z2IzQnFYMnB3TWw5aGNIQnNlVjl3WTJ4eUtDa3VDZ0JwYldGblpTMCtZMjl0Y0hOYkpXUmRMbVJoZEdFZ1BUMGdUbFZNVENCcGJpQnZjR3BmYW5BeVgyRndjR3g1WDNCamJISW9LUzRLQUdsdWRtRnNhV1FnWW05NElITnBlbVVnSldRZ0tDVjRLUW9BUm1GcGJDQjBieUJ5WldGa0lIUm9aU0JqZFhKeVpXNTBJRzFoY210bGNpQnpaV2R0Wlc1MElDZ2xJM2dwQ2dCRmNuSnZjaUIzYVhSb0lGTkpXaUJ0WVhKclpYSTZJRWxJUkZJZ2R5Z2xkU2tnYUNnbGRTa2dkbk11SUZOSldpQjNLQ1YxS1NCb0tDVjFLUW9BUlhKeWIzSWdjbVZoWkdsdVp5QkRUME1nYldGeWEyVnlJQ2hpWVdRZ2JuVnRZbVZ5SUc5bUlHTnZiWEJ2Ym1WdWRITXBDZ0JKYm5aaGJHbGtJRzUxYldKbGNpQnZaaUIwYVd4bGN5QTZJQ1YxSUhnZ0pYVWdLRzFoZUdsdGRXMGdabWw0WldRZ1lua2dhbkJsWnpJd01EQWdibTl5YlNCcGN5QTJOVFV6TlNCMGFXeGxjeWtLQUVsdWRtRnNhV1FnYm5WdFltVnlJRzltSUdOdmJYQnZibVZ1ZEhNZ0tHbG9aSElwQ2dCT2IzUWdaVzV2ZFdkb0lHMWxiVzl5ZVNCMGJ5Qm9ZVzVrYkdVZ2FXMWhaMlVnYUdWaFpHVnlJQ2hwYUdSeUtRb0FWM0p2Ym1jZ2RtRnNkV1Z6SUdadmNqb2dkeWdsWkNrZ2FDZ2xaQ2tnYm5WdFkyOXRjSE1vSldRcElDaHBhR1J5S1FvQVNXNTJZV3hwWkNCMllXeDFaWE1nWm05eUlHTnZiWEFnUFNBbFpDQTZJR1I0UFNWMUlHUjVQU1YxSUNoemFHOTFiR1FnWW1VZ1ltVjBkMlZsYmlBeElHRnVaQ0F5TlRVZ1lXTmpiM0prYVc1bklIUnZJSFJvWlNCS1VFVkhNakF3TUNCdWIzSnRLUW9BUW1Ga0lHbHRZV2RsSUdobFlXUmxjaUJpYjNnZ0tHSmhaQ0J6YVhwbEtRb0FRbUZrSUVOUFRGSWdhR1ZoWkdWeUlHSnZlQ0FvWW1Ga0lITnBlbVVwQ2dCQ1lXUWdRbEJEUXlCb1pXRmtaWElnWW05NElDaGlZV1FnYzJsNlpTa0tBRVZ5Y205eUlIZHBkR2dnVTBsYUlHMWhjbXRsY2pvZ2JtVm5ZWFJwZG1VZ2IzSWdlbVZ5YnlCcGJXRm5aU0J6YVhwbElDZ2xiR3hrSUhnZ0pXeHNaQ2tLQUhOcmFYQTZJSE5sWjIxbGJuUWdkRzl2SUd4dmJtY2dLQ1ZrS1NCM2FYUm9JRzFoZUNBb0pXUXBJR1p2Y2lCamIyUmxZbXh2WTJzZ0pXUWdLSEE5SldRc0lHSTlKV1FzSUhJOUpXUXNJR005SldRcENnQnlaV0ZrT2lCelpXZHRaVzUwSUhSdmJ5QnNiMjVuSUNnbFpDa2dkMmwwYUNCdFlYZ2dLQ1ZrS1NCbWIzSWdZMjlrWldKc2IyTnJJQ1ZrSUNod1BTVmtMQ0JpUFNWa0xDQnlQU1ZrTENCalBTVmtLUW9BUkdWemNHbDBaU0JLVURJZ1FsQkRJVDB5TlRVc0lIQnlaV05wYzJsdmJpQmhibVF2YjNJZ2MyZHVaQ0IyWVd4MVpYTWdabTl5SUdOdmJYQmJKV1JkSUdseklHUnBabVpsY21WdWRDQjBhR0Z1SUdOdmJYQmJNRjA2Q2lBZ0lDQWdJQ0FnV3pCZElIQnlaV01vSldRcElITm5ibVFvSldRcElGc2xaRjBnY0hKbFl5Z2xaQ2tnYzJkdVpDZ2xaQ2tLQUdKaFpDQmpiMjF3YjI1bGJuUWdiblZ0WW1WeUlHbHVJRkpIVGlBb0pXUWdkMmhsYmlCMGFHVnlaU0JoY21VZ2IyNXNlU0FsWkNrS0FFVnljbTl5SUhkcGRHZ2dVMGxhSUcxaGNtdGxjam9nYm5WdFltVnlJRzltSUdOdmJYQnZibVZ1ZENCcGN5QnViM1FnWTI5dGNHRjBhV0pzWlNCM2FYUm9JSFJvWlNCeVpXMWhhVzVwYm1jZ2JuVnRZbVZ5SUc5bUlIQmhjbUZ0WlhSbGNuTWdLQ0FsWkNCMmN5QWxaQ2tLQUVWeWNtOXlJSGRwZEdnZ1UwbGFJRzFoY210bGNqb2dhVzUyWVd4cFpDQjBhV3hsSUhOcGVtVWdLSFJrZURvZ0pXUXNJSFJrZVRvZ0pXUXBDZ0JDWVdRZ1EwOU1VaUJvWldGa1pYSWdZbTk0SUNoaVlXUWdjMmw2WlRvZ0pXUXBDZ0JDWVdRZ1EwOU1VaUJvWldGa1pYSWdZbTk0SUNoRFNVVk1ZV0lzSUdKaFpDQnphWHBsT2lBbFpDa0tBRkJVUlZKTklHTm9aV05ySUdaaGFXeDFjbVU2SUNWa0lISmxiV0ZwYm1sdVp5QmllWFJsY3lCcGJpQmpiMlJsSUdKc2IyTnJJQ2dsWkNCMWMyVmtJQzhnSldRcENnQk5ZV3htYjNKdFpXUWdTRlFnWTI5a1pXSnNiMk5yTGlCUGJtVWdiMllnZEdobElHWnZiR3h2ZDJsdVp5QmpiMjVrYVhScGIyNGdhWE1nYm05MElHMWxkRG9nTWlBOFBTQlRZM1Z3SUR3OUlHMXBiaWhNWTNWd0xDQTBNRGM1S1FvQVNXNTJZV3hwWkNCMllXeDFaWE1nWm05eUlHTnZiWEFnUFNBbFpDQTZJSEJ5WldNOUpYVWdLSE5vYjNWc1pDQmlaU0JpWlhSM1pXVnVJREVnWVc1a0lETTRJR0ZqWTI5eVpHbHVaeUIwYnlCMGFHVWdTbEJGUnpJd01EQWdibTl5YlM0Z1QzQmxia3B3WldjZ2IyNXNlU0J6ZFhCd2IzSjBjeUIxY0NCMGJ5QXpNU2tLQUVsdWRtRnNhV1FnWW1sMElHNTFiV0psY2lBbFpDQnBiaUJ2Y0dwZmRESmZjbVZoWkY5d1lXTnJaWFJmYUdWaFpHVnlLQ2tLQUZOMGNtVmhiU0JsY25KdmNpRUtBRVZ5Y205eUlHOXVJSGR5YVhScGJtY2djM1J5WldGdElRb0FVM1J5WldGdElISmxZV05vWldRZ2FYUnpJR1Z1WkNBaENnQkZlSEJsWTNSbFpDQmhJRk5QUXlCdFlYSnJaWElnQ2dCSmJuWmhiR2xrSUdKdmVDQnphWHBsSUNWa0lHWnZjaUJpYjNnZ0p5VmpKV01sWXlWakp5NGdUbVZsWkNBbFpDQmllWFJsY3l3Z0pXUWdZbmwwWlhNZ2NtVnRZV2x1YVc1bklBb0FUV0ZzWm05eWJXVmtJRWhVSUdOdlpHVmliRzlqYXk0Z1JHVmpiMlJwYm1jZ2RHaHBjeUJqYjJSbFlteHZZMnNnYVhNZ2MzUnZjSEJsWkM0Z1ZWOXhJR2x6SUd4aGNtZGxjaUIwYUdGdUlIcGxjbThnWW1sMGNHeGhibVZ6SUNzZ01TQUtBRTFoYkdadmNtMWxaQ0JJVkNCamIyUmxZbXh2WTJzdUlFUmxZMjlrYVc1bklIUm9hWE1nWTI5a1pXSnNiMk5ySUdseklITjBiM0J3WldRdUlGVmZjU0JwYzJ4aGNtZGxjaUIwYUdGdUlHSnBkSEJzWVc1bGN5QXJJREVnQ2dCRFQweFNJRUpQV0NCdFpYUm9JSFpoYkhWbElHbHpJRzV2ZENCaElISmxaM1ZzWVhJZ2RtRnNkV1VnS0NWa0tTd2djMjhnZDJVZ2QybHNiQ0JwWjI1dmNtVWdkR2hsSUdWdWRHbHlaU0JEYjJ4dmRYSWdVM0JsWTJsbWFXTmhkR2x2YmlCaWIzZ3VJQW9BVjJocGJHVWdjbVZoWkdsdVp5QkRRMUJmVVU1VVUxUlpJR1ZzWlcxbGJuUWdhVzV6YVdSbElGRkRSQ0J2Y2lCUlEwTWdiV0Z5YTJWeUlITmxaMjFsYm5Rc0lHNTFiV0psY2lCdlppQnpkV0ppWVc1a2N5QW9KV1FwSUdseklHZHlaV0YwWlhJZ2RHOGdUMUJLWDBveVMxOU5RVmhDUVU1RVV5QW9KV1FwTGlCVGJ5QjNaU0JzYVcxcGRDQjBhR1VnYm5WdFltVnlJRzltSUdWc1pXMWxiblJ6SUhOMGIzSmxaQ0IwYnlCUFVFcGZTakpMWDAxQldFSkJUa1JUSUNnbFpDa2dZVzVrSUhOcmFYQWdkR2hsSUhKbGMzUXVJQW9BU2xBeUlFbElSRklnWW05NE9pQmpiMjF3Y21WemMybHZiaUIwZVhCbElHbHVaR2xqWVhSbElIUm9ZWFFnZEdobElHWnBiR1VnYVhNZ2JtOTBJR0VnWTI5dVptOXliV2x1WnlCS1VESWdabWxzWlNBb0pXUXBJQW9BVkdsc1pTQnBibVJsZUNCd2NtOTJhV1JsWkNCaWVTQjBhR1VnZFhObGNpQnBjeUJwYm1OdmNuSmxZM1FnSldRZ0tHMWhlQ0E5SUNWa0tTQUtBRVZ5Y205eUlHUmxZMjlrYVc1bklHTnZiWEJ2Ym1WdWRDQWxaQzRLVkdobElHNTFiV0psY2lCdlppQnlaWE52YkhWMGFXOXVjeUIwYnlCeVpXMXZkbVVnS0NWa0tTQnBjeUJuY21WaGRHVnlJRzl5SUdWeGRXRnNJSFJvWVc0Z2RHaGxJRzUxYldKbGNpQnZaaUJ5WlhOdmJIVjBhVzl1Y3lCdlppQjBhR2x6SUdOdmJYQnZibVZ1ZENBb0pXUXBDazF2WkdsbWVTQjBhR1VnWTNCZmNtVmtkV05sSUhCaGNtRnRaWFJsY2k0S0NnQkpiV0ZuWlNCa1lYUmhJR2hoY3lCaVpXVnVJSFZ3WkdGMFpXUWdkMmwwYUNCMGFXeGxJQ1ZrTGdvS0FFR3cvUUFMZ0NBakFLVUFRd0JtQUlNQTdxZ1VBTi9ZSXdDK0VFTUEvL1dEQUg0Z1ZRQmZVU01BTlFCREFFNUVnd0RPeEJRQXo4d2pBUDdpUXdEL21ZTUFsZ0RGQUQ4eEl3Q2xBRU1BWGtTREFNN0lGQURmRVNNQS92UkRBUC84Z3dDZUFGVUFkd0FqQURVQVF3RC84WU1Bcm9nVUFMY0FJd0QrK0VNQTcrU0RBSTZJeFFBZkVTTUFwUUJEQUdZQWd3RHVxQlFBMzFRakFMNFFRd0R2SW9NQWZpQlZBSDhpSXdBMUFFTUFUa1NEQU03RUZBQy9FU01BL3VKREFQY0Fnd0NXQU1VQVB5SWpBS1VBUXdCZVJJTUF6c2dVQU5jQUl3RCs5RU1BLzdxREFKNEFWUUJ2QUNNQU5RQkRBUC9tZ3dDdWlCUUFyNklqQVA3NFF3RG5BSU1Bam9qRkFDOGlBZ0RGQUlRQWZpQUNBTTdFSkFEM0FBSUEvcUpFQUZZQUFnQ2VBQlFBMXdBQ0FMNFFoQUJtQUFJQXJvZ2tBTjhSQWdEdXFFUUFOZ0FDQUk2SUZBQWZFUUlBeFFDRUFHNEFBZ0RPaUNRQS80Z0NBUDY0UkFCT1JBSUFsZ0FVQUxjQUFnRCs1SVFBWGtRQ0FLWUFKQURuQUFJQTNsUkVBQzRpQWdBK0FCUUFkd0FDQU1VQWhBQitJQUlBenNRa0FQL3hBZ0Qrb2tRQVZnQUNBSjRBRkFDL0VRSUF2aENFQUdZQUFnQ3VpQ1FBN3lJQ0FPNm9SQUEyQUFJQWpvZ1VBSDhpQWdERkFJUUFiZ0FDQU02SUpBRHY1QUlBL3JoRUFFNUVBZ0NXQUJRQXI2SUNBUDdraEFCZVJBSUFwZ0FrQU4vWUFnRGVWRVFBTGlJQ0FENEFGQUJmVVFJQVZRQ0VBR1lBQWdEZWlDUUEveklDQVA0UlJBQk9SQUlBcmdBVUFMY0FBZ0IrTVlRQVhsRUNBTVlBSkFEWEFBSUE3aUJFQUI0UkFnQ2VBQlFBZHdBQ0FGVUFoQUJlVkFJQXprUWtBT2NBQWdEKzhVUUFOZ0FDQUtZQUZBQmZWUUlBL25TRUFENFJBZ0MrSUNRQWYzUUNBTjdFUkFELytBSUFsZ0FVQUM4aUFnQlZBSVFBWmdBQ0FONklKQUQzQUFJQS9oRkVBRTVFQWdDdUFCUUFqNGdDQUg0eGhBQmVVUUlBeGdBa0FNL0lBZ0R1SUVRQUhoRUNBSjRBRkFCdkFBSUFWUUNFQUY1VUFnRE9SQ1FBMzlFQ0FQN3hSQUEyQUFJQXBnQVVBSDhpQWdEK2RJUUFQaEVDQUw0Z0pBQy9JZ0lBM3NSRUFPOGlBZ0NXQUJRQVB6SURBTjdVL2ZULy9CUUFQaEZWQUkrSUF3QytNb1VBNXdBbEFGNVIvcXAvY2dNQXprVDkrTzlFRkFCK1pFVUFyNklEQUtZQVhWWGZtZjN4TmdEKzlXOWlBd0RlMGYzMC8rWVVBSDV4VlFDL3NRTUFyb2lGQU4vVkpRQk9SUDd5ZjJZREFNWUEvZmp2NGhRQVhsUkZBSjhSQXdDV0FGMVZ6OGo5OFI0UjdzaG5BQU1BM3RUOTlQL3pGQUErRVZVQXZ4RURBTDR5aFFEZjJDVUFYbEgrcWk4aUF3RE9SUDM0OXdBVUFINWtSUUNmbUFNQXBnQmRWZGNBL2ZFMkFQNzFiMFFEQU43Ui9mVC91UlFBZm5GVkFMY0FBd0N1aUlVQTM5d2xBRTVFL3ZKM0FBTUF4Z0Q5K08va0ZBQmVWRVVBZjNNREFKWUFYVlcvdVAzeEhoSHV5RDh5QWdDbEFJUUFma0FDQU40UUpBRGZFUUlBL25KRUFGWUFBZ0N1cUJRQXY3SUNBSllBaEFCbUFBSUF4Z0FrQU9jQUFnRHV5RVFBTGlJQ0FJNklGQUIzQUFJQXBRQ0VBRzRBQWdET2lDUUE5d0FDQVA2UlJBQTJBQUlBcnFJVUFLK3FBZ0QrdUlRQVhnQUNBTDRBSkFEUHhBSUE3a1JFQVAvMEFnQStJaFFBSHhFQ0FLVUFoQUIrUUFJQTNoQWtBUCtaQWdEK2NrUUFWZ0FDQUs2b0ZBQzNBQUlBbGdDRUFHWUFBZ0RHQUNRQTF3QUNBTzdJUkFBdUlnSUFqb2dVQUU5RUFnQ2xBSVFBYmdBQ0FNNklKQUR2NGdJQS9wRkVBRFlBQWdDdW9oUUFmMFFDQVA2NGhBQmVBQUlBdmdBa0FKOEFBZ0R1UkVRQS8zWUNBRDRpRkFBL01RTUF4Z0NGQVAvWi9mSitaUDd4djVrREFLNmlKUUR2WnYzMFZnRHU0bjl6QXdDK21FVUE5d0Q5K0dZQS9uYWZpQU1Bam9nVkFOL1ZwUUF1SXQ2WVQwUURBTDZ5aFFELy9QM3liaUtXQUxjQUF3Q3VxaVVBMzlIOTlEWUEzdFJ2WkFNQXJxaEZBTy9xL2ZoZVJPN29mM0VEQUQ0eUZRRFB4S1VBLy9yT2lEOHhBd0RHQUlVQS8zZjk4bjVrL3ZHL3N3TUFycUlsQU9jQS9mUldBTzdpZHdBREFMNllSUUR2NVAzNFpnRCtkbjltQXdDT2lCVUExd0NsQUM0aTNwZy9Nd01BdnJLRkFQOTEvZkp1SXBZQW41RURBSzZxSlFEZm1mMzBOZ0RlMUY5UkF3Q3VxRVVBNyt6OStGNUU3dWgvY2dNQVBqSVZBTCt4cFFELzg4NklIeEVEQU41VS9mSWVFUlFBZm1UKytNL01Bd0Mra1VVQTd5SWxBQzRpL3ZPUGlBTUF4Z0NGQVBjQUZBQmVFZjc4cjZnREFLWUFOUURmeVAzeFBqSCtabTlrQXdET3lQM3kvL1VVQUdZQS92Uy91Z01BcmlKRkFPY0FKUUErTXY3cWYzTURBTDZ5aFFEZlZSUUFWZ0IrY1o4UkF3Q1dBRFVBejhUOThUNHo3dWhQUkFNQTNsVDk4aDRSRkFCK1pQNzR2NWtEQUw2UlJRRHY0aVVBTGlMKzgzOW1Bd0RHQUlVQTcrUVVBRjRSL3Z5Zm1BTUFwZ0ExQU5jQS9mRStNZjVtYnlJREFNN0kvZkwvdVJRQVpnRCs5TGNBQXdDdUlrVUEzOUVsQUQ0eS91cDNBQU1BdnJLRkFPL3NGQUJXQUg1eGYzSURBSllBTlFDL3VQM3hQalB1NkY5VS9QSGUwZjM2MXdEOCtCWUEvZjkvZFB6MGZuSDk4Nyt6L1BMdjZ1N29UMFQ4OGE0aUJRQy91UHo0OXdEKy9IY0EvUFJlRWYzMWYzWDg4dC9ZN3VJL00venh2ckw5K3MrSS9Qai8rLzMvZjNQODlHNEEvZk8zQVB6eTcyYisrVDh4L1BHZUFBVUF2N3I4K1AvOS92Wm5BUHowSmdEOTlZK0kvUExmM043VUx5TDg4ZDdSL2ZyUHhQejRGZ0Q5LzM5eS9QUitjZjN6djVuODh1L3M3dWhIQVB6eHJpSUZBS2NBL1BqLzkvNzhWd0Q4OUY0Ui9mV1hBUHp5MzlYdTRqY0EvUEcrc3YzNnh3RDgrUC8rL2Y5L1p2ejBiZ0Q5ODYrby9QTG5BUDc1UHpMODhaNEFCUUMvc2Z6NDcrVCs5bDlVL1BRbUFQMzFod0Q4OHQrWjN0UWZFUk1BWlFCREFONEFnd0NOaUNNQVRrUVRBS1VBUXdDdWlJTUFOUUFqQU5jQUV3REZBRU1BbmdDREFGVUFJd0F1SWhNQWxRQkRBSDRBZ3dEK0VDTUFkd0FUQUdVQVF3RE9pSU1BallnakFCNFJFd0NsQUVNQVhnQ0RBRFVBSXdEbkFCTUF4UUJEQUw0QWd3QlZBQ01BL3hFVEFKVUFRd0ErQUlNQTdrQWpBSytpRXdCbEFFTUEzZ0NEQUkySUl3Qk9SQk1BcFFCREFLNklnd0ExQUNNQTcwUVRBTVVBUXdDZUFJTUFWUUFqQUM0aUV3Q1ZBRU1BZmdDREFQNFFJd0MzQUJNQVpRQkRBTTZJZ3dDTmlDTUFIaEVUQUtVQVF3QmVBSU1BTlFBakFNL0VFd0RGQUVNQXZnQ0RBRlVBSXdEM0FCTUFsUUJEQUQ0QWd3RHVRQ01BYndBQkFJUUFBUUJXQUFFQUZBQUJBTmNBQVFBa0FBRUFsZ0FCQUVVQUFRQjNBQUVBaEFBQkFNWUFBUUFVQUFFQWo0Z0JBQ1FBQVFEM0FBRUFOUUFCQUM4aUFRQ0VBQUVBL2tBQkFCUUFBUUMzQUFFQUpBQUJBTDhBQVFCRkFBRUFad0FCQUlRQUFRQ21BQUVBRkFBQkFFOUVBUUFrQUFFQTV3QUJBRFVBQVFBL0VRRUFoQUFCQUZZQUFRQVVBQUVBendBQkFDUUFBUUNXQUFFQVJRQUJBRzhBQVFDRUFBRUF4Z0FCQUJRQUFRQ2ZBQUVBSkFBQkFPOEFBUUExQUFFQVB6SUJBSVFBQVFEK1FBRUFGQUFCQUs4QUFRQWtBQUVBLzBRQkFFVUFBUUJmQUFFQWhBQUJBS1lBQVFBVUFBRUFmd0FCQUNRQUFRRGZBQUVBTlFBQkFCOFJBUUFrQUFFQVZnQUJBSVVBQVFDL0FBRUFGQUFCQVBjQUFRREdBQUVBZHdBQkFDUUFBUUQvK0FFQVJRQUJBSDhBQVFBVUFBRUEzd0FCQUtZQUFRQS9NUUVBSkFBQkFDNGlBUUNGQUFFQXR3QUJBQlFBQVFEdlJBRUFycUlCQUdjQUFRQWtBQUVBLzFFQkFFVUFBUUNYQUFFQUZBQUJBTThBQVFBMkFBRUFQeUlCQUNRQUFRQldBQUVBaFFBQkFMK3lBUUFVQUFFQTcwQUJBTVlBQVFCdkFBRUFKQUFCQVA5eUFRQkZBQUVBbndBQkFCUUFBUURYQUFFQXBnQUJBRTlFQVFBa0FBRUFMaUlCQUlVQUFRQ3ZxQUVBRkFBQkFPY0FBUUN1b2dFQVh3QUJBQ1FBQVFEL1JBRUFSUUFCQUkrSUFRQVVBQUVBcjZvQkFEWUFBUUFmRVFJQS92Z2tBRllBQWdDMkFJVUEvMllDQU00QUZBQWVFUUlBbGdBMUFLK29BZ0QyQUNRQVBqRUNBS1lBUlFDL3N3SUF2cklVQVAvMUFnQm1BSDVSWDFRQ0FQN3lKQUF1SWdJQXJpS0ZBTzlFQWdER0FCUUEvL1FDQUhZQU5RQi9SQUlBM2tBa0FENHlBZ0NlQUVVQTF3QUNBTDZJRkFELytnSUFYaEgrOFU5RUFnRCsrQ1FBVmdBQ0FMWUFoUUR2eUFJQXpnQVVBQjRSQWdDV0FEVUFqNGdDQVBZQUpBQStNUUlBcGdCRkFOOUVBZ0Mrc2hRQS82Z0NBR1lBZmxGdkFBSUEvdklrQUM0aUFnQ3VJb1VBNXdBQ0FNWUFGQUR2NGdJQWRnQTFBSDl5QWdEZVFDUUFQaklDQUo0QVJRQy9zUUlBdm9nVUFQOXpBZ0JlRWY3eFB6TUJBSVFBQVFEdUlBRUF4UUFCQU0vRUFRQkVBQUVBL3pJQkFCVUFBUUNQaUFFQWhBQUJBR1lBQVFBbEFBRUFyd0FCQUVRQUFRRHZJZ0VBcGdBQkFGOEFBUUNFQUFFQVRrUUJBTVVBQVFEUHpBRUFSQUFCQVBjQUFRQVZBQUVBYndBQkFJUUFBUUJXQUFFQUpRQUJBSjhBQVFCRUFBRUEzd0FCQVA0d0FRQXZJZ0VBaEFBQkFPNGdBUURGQUFFQXo4Z0JBRVFBQVFEL0VRRUFGUUFCQUhjQUFRQ0VBQUVBWmdBQkFDVUFBUUIvQUFFQVJBQUJBT2NBQVFDbUFBRUFOd0FCQUlRQUFRQk9SQUVBeFFBQkFMY0FBUUJFQUFFQXZ3QUJBQlVBQVFBL0FBRUFoQUFCQUZZQUFRQWxBQUVBbHdBQkFFUUFBUURYQUFFQS9qQUJBQjhSQWdEdXFFUUFqb2dDQU5ZQXhRRC84d0lBL3Z3bEFENEFBZ0MyQUZVQTM5Z0NBUDc0UkFCbUFBSUFmaUNGQVArWkFnRG1BUFVBTmdBQ0FLWUFGUUNmQUFJQS92SkVBSFlBQWdET1JNVUEvM1lDQVA3eEpRQk9SQUlBcmdCVkFNL0lBZ0QrOUVRQVhrUUNBTDRRaFFEdjVBSUEzbFQxQUI0UkFnQ1dBQlVBTHlJQ0FPNm9SQUNPaUFJQTFnREZBUC82QWdEKy9DVUFQZ0FDQUxZQVZRQy9FUUlBL3ZoRUFHWUFBZ0IrSUlVQTd5SUNBT1lBOVFBMkFBSUFwZ0FWQUg4aUFnRCs4a1FBZGdBQ0FNNUV4UUQvMVFJQS92RWxBRTVFQWdDdUFGVUFid0FDQVA3MFJBQmVSQUlBdmhDRkFOOFJBZ0RlVlBVQUhoRUNBSllBRlFCZlVRTUE5Z0FVQUI0UlJBQ09pS1VBMzlRREFLNmlWUUQvZGlRQVBpSzJBSytxQXdEbUFCUUEvL1ZFQUdZQWhRRFB6QU1BbmdERkFPOUVKQUEyQVA3NGZ6RURBTzdvRkFELzhVUUFkZ0NsQU0vRUF3QitJbFVBMzlFa0FFNUUvdlJmVVFNQTFnQVVBTy9pUkFCZVJJVUF2eUlEQUpZQXhRRGZ5Q1FBTGlMKzhtOGlBd0QyQUJRQUhoRkVBSTZJcFFDL3NRTUFycUpWQVA4ekpBQStJcllBcjZnREFPWUFGQUQvdVVRQVpnQ0ZBTCtvQXdDZUFNVUE3K1FrQURZQS92aHZaQU1BN3VnVUFQLzhSQUIyQUtVQXo4Z0RBSDRpVlFEdjZpUUFUa1QrOUg5MEF3RFdBQlFBLy9wRUFGNUVoUUMvc2dNQWxnREZBTjlFSkFBdUl2N3lQekh6QVA3Ni9mRTJBQVFBdmpKMUFOOFI4d0RlVlAzeTcrVFZBSDV4L3Z4L2MvTUEvdlA5K0I0UkJBQ1dBRlVBdjdIekFNNEF0UURmMlAzMFpnRCt1VjlVOHdEK2R2M3hKZ0FFQUtZQWRRQ2ZBUE1BcmdEOTh2LzMxUUJHQVA3MWYzVHpBT1lBL2ZnV0FBUUFoZ0JWQUkrSTh3REdBTFVBNytMOTlGNFI3cWcvRWZNQS92cjk4VFlBQkFDK01uVUEzOUh6QU41VS9mTC8rOVVBZm5IKy9IOUU4d0QrOC8zNEhoRUVBSllBVlFCL2N2TUF6Z0MxQU84aS9mUm1BUDY1VDBUekFQNTIvZkVtQUFRQXBnQjFBTDhSOHdDdUFQM3kvLy9WQUVZQS92VS9Ndk1BNWdEOStCWUFCQUNHQUZVQWJ3RHpBTVlBdFFDL3VQMzBYaEh1cUM4aUFFRzhuUUVMcEI0QkFBQUFBUUFBQUFFQUFBQUNBQUFBQWdBQUFBSUFBQUFEQUFBQUF3QUFBQVFBQUFBRkFBQUF0eUZDSVdjaFFpRVJFUkVSTXpNek0zZDNkM2NBQUFBQUFBQUFBQUZXQUFBQUFBQUFJRThBQURCUEFBQUJWZ0FBQVFBQUFEQlBBQUFnVHdBQUFUUUFBQUFBQUFCQVR3QUF3RThBQUFFMEFBQUJBQUFBVUU4QUFOQlBBQUFCR0FBQUFBQUFBR0JQQUFBZ1VBQUFBUmdBQUFFQUFBQndUd0FBTUZBQUFNRUtBQUFBQUFBQWdFOEFBSUJRQUFEQkNnQUFBUUFBQUpCUEFBQ1FVQUFBSVFVQUFBQUFBQUNnVHdBQW9GSUFBQ0VGQUFBQkFBQUFzRThBQUxCU0FBQWhBZ0FBQUFBQUFNQlRBQUFnVXdBQUlRSUFBQUVBQUFEUVV3QUFNRk1BQUFGV0FBQUFBQUFBNEU4QUFOQlBBQUFCVmdBQUFRQUFBUEJQQUFEQVR3QUFBVlFBQUFBQUFBQUFVQUFBd0ZBQUFBRlVBQUFCQUFBQUVGQUFBTkJRQUFBQlNBQUFBQUFBQUNCUUFBREFVQUFBQVVnQUFBRUFBQUF3VUFBQTBGQUFBQUU0QUFBQUFBQUFRRkFBQU1CUUFBQUJPQUFBQVFBQUFGQlFBQURRVUFBQUFUQUFBQUFBQUFCZ1VBQUFJRkVBQUFFd0FBQUJBQUFBY0ZBQUFEQlJBQUFCSkFBQUFBQUFBSUJRQUFCQVVRQUFBU1FBQUFFQUFBQ1FVQUFBVUZFQUFBRWNBQUFBQUFBQW9GQUFBSUJSQUFBQkhBQUFBUUFBQUxCUUFBQ1FVUUFBQVJZQUFBQUFBQUNnVWdBQW9GRUFBQUVXQUFBQkFBQUFzRklBQUxCUkFBQUJWZ0FBQUFBQUFPQlFBQURRVUFBQUFWWUFBQUVBQUFEd1VBQUF3RkFBQUFGVUFBQUFBQUFBQUZFQUFNQlFBQUFCVkFBQUFRQUFBQkJSQUFEUVVBQUFBVkVBQUFBQUFBQWdVUUFBNEZBQUFBRlJBQUFCQUFBQU1GRUFBUEJRQUFBQlNBQUFBQUFBQUVCUkFBQUFVUUFBQVVnQUFBRUFBQUJRVVFBQUVGRUFBQUU0QUFBQUFBQUFZRkVBQUNCUkFBQUJPQUFBQVFBQUFIQlJBQUF3VVFBQUFUUUFBQUFBQUFDQVVRQUFRRkVBQUFFMEFBQUJBQUFBa0ZFQUFGQlJBQUFCTUFBQUFBQUFBS0JSQUFCZ1VRQUFBVEFBQUFFQUFBQ3dVUUFBY0ZFQUFBRW9BQUFBQUFBQXdGRUFBR0JSQUFBQktBQUFBUUFBQU5CUkFBQndVUUFBQVNRQUFBQUFBQURnVVFBQWdGRUFBQUVrQUFBQkFBQUE4RkVBQUpCUkFBQUJJZ0FBQUFBQUFBQlNBQUNnVVFBQUFTSUFBQUVBQUFBUVVnQUFzRkVBQUFFY0FBQUFBQUFBSUZJQUFNQlJBQUFCSEFBQUFRQUFBREJTQUFEUVVRQUFBUmdBQUFBQUFBQkFVZ0FBNEZFQUFBRVlBQUFCQUFBQVVGSUFBUEJSQUFBQkZnQUFBQUFBQUdCU0FBQUFVZ0FBQVJZQUFBRUFBQUJ3VWdBQUVGSUFBQUVVQUFBQUFBQUFnRklBQUNCU0FBQUJGQUFBQVFBQUFKQlNBQUF3VWdBQUFSSUFBQUFBQUFDZ1VnQUFRRklBQUFFU0FBQUJBQUFBc0ZJQUFGQlNBQUFCRVFBQUFBQUFBTUJTQUFCZ1VnQUFBUkVBQUFFQUFBRFFVZ0FBY0ZJQUFNRUtBQUFBQUFBQTRGSUFBSUJTQUFEQkNnQUFBUUFBQVBCU0FBQ1FVZ0FBd1FrQUFBQUFBQUFBVXdBQW9GSUFBTUVKQUFBQkFBQUFFRk1BQUxCU0FBQ2hDQUFBQUFBQUFDQlRBQURBVWdBQW9RZ0FBQUVBQUFBd1V3QUEwRklBQUNFRkFBQUFBQUFBUUZNQUFPQlNBQUFoQlFBQUFRQUFBRkJUQUFEd1VnQUFRUVFBQUFBQUFBQmdVd0FBQUZNQUFFRUVBQUFCQUFBQWNGTUFBQkJUQUFDaEFnQUFBQUFBQUlCVEFBQWdVd0FBb1FJQUFBRUFBQUNRVXdBQU1GTUFBQ0VDQUFBQUFBQUFvRk1BQUVCVEFBQWhBZ0FBQVFBQUFMQlRBQUJRVXdBQVFRRUFBQUFBQUFEQVV3QUFZRk1BQUVFQkFBQUJBQUFBMEZNQUFIQlRBQUFSQVFBQUFBQUFBT0JUQUFDQVV3QUFFUUVBQUFFQUFBRHdVd0FBa0ZNQUFJVUFBQUFBQUFBQUFGUUFBS0JUQUFDRkFBQUFBUUFBQUJCVUFBQ3dVd0FBU1FBQUFBQUFBQUFnVkFBQXdGTUFBRWtBQUFBQkFBQUFNRlFBQU5CVEFBQWxBQUFBQUFBQUFFQlVBQURnVXdBQUpRQUFBQUVBQUFCUVZBQUE4Rk1BQUJVQUFBQUFBQUFBWUZRQUFBQlVBQUFWQUFBQUFRQUFBSEJVQUFBUVZBQUFDUUFBQUFBQUFBQ0FWQUFBSUZRQUFBa0FBQUFCQUFBQWtGUUFBREJVQUFBRkFBQUFBQUFBQUtCVUFBQkFWQUFBQlFBQUFBRUFBQUN3VkFBQVVGUUFBQUVBQUFBQUFBQUFvRlFBQUdCVUFBQUJBQUFBQVFBQUFMQlVBQUJ3VkFBQUFWWUFBQUFBQUFEQVZBQUF3RlFBQUFGV0FBQUJBQUFBMEZRQUFOQlVBQUFBQVFNREFRSURBd1VHQndjR0JnY0hBQUVEQXdFQ0F3TUZCZ2NIQmdZSEJ3VUdCd2NHQmdjSENBZ0lDQWdJQ0FnRkJnY0hCZ1lIQndnSUNBZ0lDQWdJQVFJREF3SUNBd01HQmdjSEJnWUhCd0VDQXdNQ0FnTURCZ1lIQndZR0J3Y0dCZ2NIQmdZSEJ3Z0lDQWdJQ0FnSUJnWUhCd1lHQndjSUNBZ0lDQWdJQ0FNREJBUURBd1FFQndjSEJ3Y0hCd2NEQXdRRUF3TUVCQWNIQndjSEJ3Y0hCd2NIQndjSEJ3Y0lDQWdJQ0FnSUNBY0hCd2NIQndjSENBZ0lDQWdJQ0FnREF3UUVBd01FQkFjSEJ3Y0hCd2NIQXdNRUJBTURCQVFIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hDQWdJQ0FnSUNBZ0hCd2NIQndjSEJ3Z0lDQWdJQ0FnSUFRSURBd0lDQXdNR0JnY0hCZ1lIQndFQ0F3TUNBZ01EQmdZSEJ3WUdCd2NHQmdjSEJnWUhCd2dJQ0FnSUNBZ0lCZ1lIQndZR0J3Y0lDQWdJQ0FnSUNBSUNBd01DQWdNREJnWUhCd1lHQndjQ0FnTURBZ0lEQXdZR0J3Y0dCZ2NIQmdZSEJ3WUdCd2NJQ0FnSUNBZ0lDQVlHQndjR0JnY0hDQWdJQ0FnSUNBZ0RBd1FFQXdNRUJBY0hCd2NIQndjSEF3TUVCQU1EQkFRSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQ0FnSUNBZ0lDQWdIQndjSEJ3Y0hCd2dJQ0FnSUNBZ0lBd01FQkFNREJBUUhCd2NIQndjSEJ3TURCQVFEQXdRRUJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndnSUNBZ0lDQWdJQndjSEJ3Y0hCd2NJQ0FnSUNBZ0lDQUFCQlFZQkFnWUdBd01IQndNREJ3Y0FBUVVHQVFJR0JnTURCd2NEQXdjSEF3TUhCd01EQndjRUJBY0hCQVFIQndNREJ3Y0RBd2NIQkFRSEJ3UUVCd2NCQWdZR0FnSUdCZ01EQndjREF3Y0hBUUlHQmdJQ0JnWURBd2NIQXdNSEJ3TURCd2NEQXdjSEJBUUhCd1FFQndjREF3Y0hBd01IQndRRUJ3Y0VCQWNIQlFZSUNBWUdDQWdIQndnSUJ3Y0lDQVVHQ0FnR0JnZ0lCd2NJQ0FjSENBZ0hCd2dJQndjSUNBY0hDQWdIQndnSUJ3Y0lDQWNIQ0FnSEJ3Z0lCd2NJQ0FZR0NBZ0dCZ2dJQndjSUNBY0hDQWdHQmdnSUJnWUlDQWNIQ0FnSEJ3Z0lCd2NJQ0FjSENBZ0hCd2dJQndjSUNBY0hDQWdIQndnSUJ3Y0lDQWNIQ0FnQkFnWUdBZ0lHQmdNREJ3Y0RBd2NIQVFJR0JnSUNCZ1lEQXdjSEF3TUhCd01EQndjREF3Y0hCQVFIQndRRUJ3Y0RBd2NIQXdNSEJ3UUVCd2NFQkFjSEFnSUdCZ0lDQmdZREF3Y0hBd01IQndJQ0JnWUNBZ1lHQXdNSEJ3TURCd2NEQXdjSEF3TUhCd1FFQndjRUJBY0hBd01IQndNREJ3Y0VCQWNIQkFRSEJ3WUdDQWdHQmdnSUJ3Y0lDQWNIQ0FnR0JnZ0lCZ1lJQ0FjSENBZ0hCd2dJQndjSUNBY0hDQWdIQndnSUJ3Y0lDQWNIQ0FnSEJ3Z0lCd2NJQ0FjSENBZ0dCZ2dJQmdZSUNBY0hDQWdIQndnSUJnWUlDQVlHQ0FnSEJ3Z0lCd2NJQ0FjSENBZ0hCd2dJQndjSUNBY0hDQWdIQndnSUJ3Y0lDQWNIQ0FnSEJ3Z0lBQUVEQXdFQ0F3TUZCZ2NIQmdZSEJ3QUJBd01CQWdNREJRWUhCd1lHQndjRkJnY0hCZ1lIQndnSUNBZ0lDQWdJQlFZSEJ3WUdCd2NJQ0FnSUNBZ0lDQUVDQXdNQ0FnTURCZ1lIQndZR0J3Y0JBZ01EQWdJREF3WUdCd2NHQmdjSEJnWUhCd1lHQndjSUNBZ0lDQWdJQ0FZR0J3Y0dCZ2NIQ0FnSUNBZ0lDQWdEQXdRRUF3TUVCQWNIQndjSEJ3Y0hBd01FQkFNREJBUUhCd2NIQndjSEJ3Y0hCd2NIQndjSENBZ0lDQWdJQ0FnSEJ3Y0hCd2NIQndnSUNBZ0lDQWdJQXdNRUJBTURCQVFIQndjSEJ3Y0hCd01EQkFRREF3UUVCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Z0lDQWdJQ0FnSUJ3Y0hCd2NIQndjSUNBZ0lDQWdJQ0FFQ0F3TUNBZ01EQmdZSEJ3WUdCd2NCQWdNREFnSURBd1lHQndjR0JnY0hCZ1lIQndZR0J3Y0lDQWdJQ0FnSUNBWUdCd2NHQmdjSENBZ0lDQWdJQ0FnQ0FnTURBZ0lEQXdZR0J3Y0dCZ2NIQWdJREF3SUNBd01HQmdjSEJnWUhCd1lHQndjR0JnY0hDQWdJQ0FnSUNBZ0dCZ2NIQmdZSEJ3Z0lDQWdJQ0FnSUF3TUVCQU1EQkFRSEJ3Y0hCd2NIQndNREJBUURBd1FFQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2dJQ0FnSUNBZ0lCd2NIQndjSEJ3Y0lDQWdJQ0FnSUNBTURCQVFEQXdRRUJ3Y0hCd2NIQndjREF3UUVBd01FQkFjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NJQ0FnSUNBZ0lDQWNIQndjSEJ3Y0hDQWdJQ0FnSUNBZ0FBd0VFQXdZRUJ3RUVBZ1VFQndVSEFBTUJCQU1HQkFjQkJBSUZCQWNGQndFRUFnVUVCd1VIQWdVQ0JRVUhCUWNCQkFJRkJBY0ZCd0lGQWdVRkJ3VUhBd1lFQndZSUJ3Z0VCd1VIQndnSENBTUdCQWNHQ0FjSUJBY0ZCd2NJQndnRUJ3VUhCd2dIQ0FVSEJRY0hDQWNJQkFjRkJ3Y0lCd2dGQndVSEJ3Z0hDQUVFQWdVRUJ3VUhBZ1VDQlFVSEJRY0JCQUlGQkFjRkJ3SUZBZ1VGQndVSEFnVUNCUVVIQlFjQ0JRSUZCUWNGQndJRkFnVUZCd1VIQWdVQ0JRVUhCUWNFQndVSEJ3Z0hDQVVIQlFjSENBY0lCQWNGQndjSUJ3Z0ZCd1VIQndnSENBVUhCUWNIQ0FjSUJRY0ZCd2NJQndnRkJ3VUhCd2dIQ0FVSEJRY0hDQWNJQXdZRUJ3WUlCd2dFQndVSEJ3Z0hDQU1HQkFjR0NBY0lCQWNGQndjSUJ3Z0VCd1VIQndnSENBVUhCUWNIQ0FjSUJBY0ZCd2NJQndnRkJ3VUhCd2dIQ0FZSUJ3Z0lDQWdJQndnSENBZ0lDQWdHQ0FjSUNBZ0lDQWNJQndnSUNBZ0lCd2dIQ0FnSUNBZ0hDQWNJQ0FnSUNBY0lCd2dJQ0FnSUJ3Z0hDQWdJQ0FnRUJ3VUhCd2dIQ0FVSEJRY0hDQWNJQkFjRkJ3Y0lCd2dGQndVSEJ3Z0hDQVVIQlFjSENBY0lCUWNGQndjSUJ3Z0ZCd1VIQndnSENBVUhCUWNIQ0FjSUJ3Z0hDQWdJQ0FnSENBY0lDQWdJQ0FjSUJ3Z0lDQWdJQndnSENBZ0lDQWdIQ0FjSUNBZ0lDQWNJQndnSUNBZ0lCd2dIQ0FnSUNBZ0hDQWNJQ0FnSUNBa0pDZ29KQ1FvS0RBd05Dd3dNRFFzSkNRb0tDUWtLQ2d3TUN3ME1EQXNOREF3TkRRd01Dd3NNQ1EwS0NRd0tDd3dNQ3dzTURBME5EQWtMQ2drTUNnMEpDUW9LQ1FrS0Nnd01EUXNNREEwTENRa0tDZ2tKQ2dvTURBc05EQXdMRFF3TURRME1EQXNMREFrTkNna01DZ3NNREFzTERBd05EUXdKQ3dvSkRBb05DZ29LQ2dvS0Nnb05DdzBMRFFzTkN3b0tDUWtLQ2drSkRRc01EQTBMREF3TkRRME5Dd3NMQ3cwS0RRb0tDd29MRFEwTURBc0xEQXdOQ2d3SkNnc0pEQW9LQ1FrS0Nna0pDdzBNREFzTkRBd0tDZ29LQ2dvS0Nnc05DdzBMRFFzTkN3c01EQTBOREF3TENnd0pDZzBKREFzTEN3c05EUTBOQ3dvTENnb05DZzBBUWVtN0FRczNBUUFCQUFFQUFRQUFBUUVBQUFFQkFBRUFBUUFCQUFFQUFBQUFBUUVCQVFBQUFBQUFBUUFCQUFBQUFBRUJBUUVBQUFBQkFBRUJBUUJCcWJ3QkN6Y0JBQUVBQVFBQkFBQUJBUUFBQVFFQUFRQUJBQUVBQVFBQUFBQUJBUUVCQUFBQUFBQUJBQUVBQUFBQUFRRUJBUUFBQUFFQUFRRUJBRUhwdkFFTEJ3RUFBUUFCQUFFQVFmbThBUXVWQWdFQUFRQUJBQUVBQUFBQUFRRUJBUUFBQUFBQUFRQUJBQUFBQUFFQkFRRUFBQUFBQUFFQUFRRUJBQUFCQVFBQUFBRUFBUUFCQUFFQkFRRUJBUUVCQVFBQkFBRUFBUUFCQUFBQUFBRUJBUUVBQVFBQUFRRUFBUUFBQUFBQkFRRUJBQUVBQVFFQkFRRUNBQUFBQkFBQUFBUUFBQUFJQUFBQWtQOEFBQXdBQUFBWUFBQUFVdjhBQUJRQUFBQVpBQUFBVS84QUFCUUFBQUFhQUFBQVh2OEFBQlFBQUFBYkFBQUFYUDhBQUJRQUFBQWNBQUFBWGY4QUFCUUFBQUFkQUFBQVgvOEFBQlFBQUFBZUFBQUFVZjhBQUFJQUFBQWZBQUFBVmY4QUFBUUFBQUFnQUFBQVYvOEFBQVFBQUFBaEFBQUFXUDhBQUJBQUFBQWlBQUFBWVA4QUFBUUFBQUFqQUFBQVlmOEFBQkFBQUFBa0FBQUFrZjhBUVppL0FRdGxZLzhBQUFRQUFBQWxBQUFBWlA4QUFCUUFBQUFtQUFBQWRQOEFBQlFBQUFBbkFBQUFlUDhBQUFRQUFBQW9BQUFBVVA4QUFBUUFBQUFwQUFBQVdmOEFBQVFBQUFBcUFBQUFkZjhBQUJRQUFBQXJBQUFBZC84QUFCUUFBQUFzQUFBQUFBQUFBQlFBUVpEQUFRczFMUUFBQUM0QUFBQXZBQUFBTUFBQUFERUFBQUF5QUFBQU13QUFBRFFBQUFBZ0lGQnFOZ0FBQUhCNWRHWTNBQUFBYURKd2FqZ0FRZERBQVFzeWNtUm9hVGtBQUFCeWJHOWpPZ0FBQUdOamNHSTdBQUFBY214amNEd0FBQUJ3WVcxalBRQUFBR1psWkdNK0FBQUFlR0lBUVpEQkFRdEJHUUFMQUJrWkdRQUFBQUFGQUFBQUFBQUFDUUFBQUFBTEFBQUFBQUFBQUFBWkFBb0tHUmtaQXdvSEFBRUFDUXNZQUFBSkJnc0FBQXNBQmhrQUFBQVpHUmtBUWVIQkFRc2hEZ0FBQUFBQUFBQUFHUUFMRFJrWkdRQU5BQUFDQUFrT0FBQUFDUUFPQUFBT0FFR2J3Z0VMQVF3QVFhZkNBUXNWRXdBQUFBQVRBQUFBQUFrTUFBQUFBQUFNQUFBTUFFSFZ3Z0VMQVJBQVFlSENBUXNWRHdBQUFBUVBBQUFBQUFrUUFBQUFBQUFRQUFBUUFFR1B3d0VMQVJJQVFadkRBUXNlRVFBQUFBQVJBQUFBQUFrU0FBQUFBQUFTQUFBU0FBQWFBQUFBR2hvYUFFSFN3d0VMRGhvQUFBQWFHaG9BQUFBQUFBQUpBRUdEeEFFTEFSUUFRWS9FQVFzVkZ3QUFBQUFYQUFBQUFBa1VBQUFBQUFBVUFBQVVBRUc5eEFFTEFSWUFRY25FQVFzbkZRQUFBQUFWQUFBQUFBa1dBQUFBQUFBV0FBQVdBQUF3TVRJek5EVTJOemc1UVVKRFJFVkdBRUh4eEFFTENHd0JBQUFBQUFBRkFFR0V4UUVMQVdrQVFaekZBUXNPYWdBQUFHc0FBQUQ0WndBQUFBUUFRYlRGQVFzQkFRQkJ4TVVCQ3dYLy8vLy9DZz09IjtmdW5jdGlvbiBpbnN0YW50aWF0ZVN5bmMoZSx0KXt2YXIgaSxhPWZ1bmN0aW9uIGdldEJpbmFyeVN5bmMoZSl7aWYoZT09dSYmZylyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZyk7dmFyIHQ9dHJ5UGFyc2VBc0RhdGFVUkkoZSk7aWYodClyZXR1cm4gdDtpZihzKXJldHVybiBzKGUpO3Rocm93J3N5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkOiB5b3UgY2FuIHByZWxvYWQgaXQgdG8gTW9kdWxlWyJ3YXNtQmluYXJ5Il0gbWFudWFsbHksIG9yIGVtY2MucHkgd2lsbCBkbyB0aGF0IGZvciB5b3Ugd2hlbiBnZW5lcmF0aW5nIEhUTUwgKGJ1dCBub3QgSlMpJ30oZSk7aT1uZXcgV2ViQXNzZW1ibHkuTW9kdWxlKGEpO3JldHVybltuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoaSx0KSxpXX12YXIgRCxjYWxsUnVudGltZUNhbGxiYWNrcz1lPT57Zm9yKDtlLmxlbmd0aD4wOyllLnNoaWZ0KCkoYSl9LEY9KGEubm9FeGl0UnVudGltZSxlPT57dmFyIHQ9KGUtYy5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e2MuZ3Jvdyh0KTt1cGRhdGVNZW1vcnlWaWV3cygpO3JldHVybiAxfWNhdGNoKGUpe319KSxTPXt9LGdldEVudlN0cmluZ3M9KCk9PntpZighZ2V0RW52U3RyaW5ncy5zdHJpbmdzKXt2YXIgZT17VVNFUjoid2ViX3VzZXIiLExPR05BTUU6IndlYl91c2VyIixQQVRIOiIvIixQV0Q6Ii8iLEhPTUU6Ii9ob21lL3dlYl91c2VyIixMQU5HOigib2JqZWN0Ij09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8IkMiKS5yZXBsYWNlKCItIiwiXyIpKyIuVVRGLTgiLF86bnx8Ii4vdGhpcy5wcm9ncmFtIn07Zm9yKHZhciB0IGluIFMpdm9pZCAwPT09U1t0XT9kZWxldGUgZVt0XTplW3RdPVNbdF07dmFyIGk9W107Zm9yKHZhciB0IGluIGUpaS5wdXNoKGAke3R9PSR7ZVt0XX1gKTtnZXRFbnZTdHJpbmdzLnN0cmluZ3M9aX1yZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzfSxrPVtudWxsLFtdLFtdXSxOPSJ1bmRlZmluZWQiIT10eXBlb2YgVGV4dERlY29kZXI/bmV3IFRleHREZWNvZGVyKCJ1dGY4Iik6dm9pZCAwLFVURjhBcnJheVRvU3RyaW5nPShlLHQsaSk9Pntmb3IodmFyIGE9dCtpLHM9dDtlW3NdJiYhKHM+PWEpOykrK3M7aWYocy10PjE2JiZlLmJ1ZmZlciYmTilyZXR1cm4gTi5kZWNvZGUoZS5zdWJhcnJheSh0LHMpKTtmb3IodmFyIHI9IiI7dDxzOyl7dmFyIG49ZVt0KytdO2lmKDEyOCZuKXt2YXIgbz02MyZlW3QrK107aWYoMTkyIT0oMjI0Jm4pKXt2YXIgZz02MyZlW3QrK107aWYoKG49MjI0PT0oMjQwJm4pPygxNSZuKTw8MTJ8bzw8NnxnOig3Jm4pPDwxOHxvPDwxMnxnPDw2fDYzJmVbdCsrXSk8NjU1MzYpcis9U3RyaW5nLmZyb21DaGFyQ29kZShuKTtlbHNle3ZhciBjPW4tNjU1MzY7cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjPj4xMCw1NjMyMHwxMDIzJmMpfX1lbHNlIHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJm4pPDw2fG8pfWVsc2Ugcis9U3RyaW5nLmZyb21DaGFyQ29kZShuKX1yZXR1cm4gcn0scHJpbnRDaGFyPShlLHQpPT57dmFyIGk9a1tlXTtpZigwPT09dHx8MTA9PT10KXsoMT09PWU/UTpFKShVVEY4QXJyYXlUb1N0cmluZyhpLDApKTtpLmxlbmd0aD0wfWVsc2UgaS5wdXNoKHQpfSxVVEY4VG9TdHJpbmc9KGUsdCk9PmU/VVRGOEFycmF5VG9TdHJpbmcoaCxlLHQpOiIiLFI9e2Y6KGUsdCxpKT0+aC5jb3B5V2l0aGluKGUsdCx0K2kpLGI6ZT0+e3ZhciB0PWgubGVuZ3RoLGk9MjE0NzQ4MzY0ODtpZigoZT4+Pj0wKT5pKXJldHVybiExO2Zvcih2YXIgYSxzLHI9MTtyPD00O3IqPTIpe3ZhciBuPXQqKDErLjIvcik7bj1NYXRoLm1pbihuLGUrMTAwNjYzMjk2KTt2YXIgbz1NYXRoLm1pbihpLChhPU1hdGgubWF4KGUsbikpKygocz02NTUzNiktYSVzKSVzKTtpZihGKG8pKXJldHVybiEwfXJldHVybiExfSxjOihlLHQpPT57dmFyIGk9MDtnZXRFbnZTdHJpbmdzKCkuZm9yRWFjaCgoKGEscyk9Pnt2YXIgcj10K2k7bFtlKzQqcz4+Ml09cjsoKGUsdCk9Pntmb3IodmFyIGk9MDtpPGUubGVuZ3RoOysraSlDW3QrK109ZS5jaGFyQ29kZUF0KGkpO0NbdF09MH0pKGEscik7aSs9YS5sZW5ndGgrMX0pKTtyZXR1cm4gMH0sZDooZSx0KT0+e3ZhciBpPWdldEVudlN0cmluZ3MoKTtsW2U+PjJdPWkubGVuZ3RoO3ZhciBhPTA7aS5mb3JFYWNoKChlPT5hKz1lLmxlbmd0aCsxKSk7bFt0Pj4yXT1hO3JldHVybiAwfSxlOihlLHQsaSxhKT0+e2Zvcih2YXIgcz0wLHI9MDtyPGk7cisrKXt2YXIgbj1sW3Q+PjJdLG89bFt0KzQ+PjJdO3QrPTg7Zm9yKHZhciBnPTA7ZzxvO2crKylwcmludENoYXIoZSxoW24rZ10pO3MrPW99bFthPj4yXT1zO3JldHVybiAwfSxnOmZ1bmN0aW9uIF9qc1ByaW50V2FybmluZyhlKXtjb25zdCB0PVVURjhUb1N0cmluZyhlKTsoYS53YXJufHxjb25zb2xlLndhcm4pKGBPcGVuSlBFRzogJHt0fWApfSxoOmZ1bmN0aW9uIF9zZXRJbWFnZURhdGEoZSx0KXthLmltYWdlRGF0YT1uZXcgVWludDhDbGFtcGVkQXJyYXkoYS5IRUFQVTguc3ViYXJyYXkoZSxlK3QpKX0sYTpmdW5jdGlvbiBfc3RvcmVFcnJvck1lc3NhZ2UoZSl7Y29uc3QgdD1VVEY4VG9TdHJpbmcoZSk7YS5lcnJvck1lc3NhZ2VzP2EuZXJyb3JNZXNzYWdlcys9IlxuIit0OmEuZXJyb3JNZXNzYWdlcz10fX0sRz1mdW5jdGlvbiBjcmVhdGVXYXNtKCl7dmFyIGU9e2E6Un07ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGUsdCl7Rz1lLmV4cG9ydHM7Yz1HLmk7dXBkYXRlTWVtb3J5Vmlld3MoKTshZnVuY3Rpb24gYWRkT25Jbml0KGUpe2YudW5zaGlmdChlKX0oRy5qKTshZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShlKXttLS07YS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzPy4obSk7aWYoMD09bSl7aWYobnVsbCE9PXkpe2NsZWFySW50ZXJ2YWwoeSk7eT1udWxsfWlmKHcpe3ZhciB0PXc7dz1udWxsO3QoKX19fSgpO3JldHVybiBHfSFmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGUpe20rKzthLm1vbml0b3JSdW5EZXBlbmRlbmNpZXM/LihtKX0oKTtpZihhLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIGEuaW5zdGFudGlhdGVXYXNtKGUscmVjZWl2ZUluc3RhbmNlKX1jYXRjaChlKXtFKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2V9YCk7aShlKX1yZXR1cm4gcmVjZWl2ZUluc3RhbmNlKGluc3RhbnRpYXRlU3luYyh1LGUpWzBdKX0oKTtHLmosYS5fbWFsbG9jPUcuayxhLl9mcmVlPUcubCxhLl9qcDJfZGVjb2RlPUcubixHLl9lbXNjcmlwdGVuX3N0YWNrX3Jlc3RvcmUsRy5fZW1zY3JpcHRlbl9zdGFja19hbGxvYyxHLmVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQ7dz1mdW5jdGlvbiBydW5DYWxsZXIoKXtEfHxydW4oKTtEfHwodz1ydW5DYWxsZXIpfTtmdW5jdGlvbiBydW4oKXtpZighKG0+MCkpeyFmdW5jdGlvbiBwcmVSdW4oKXtpZihhLnByZVJ1bil7ImZ1bmN0aW9uIj09dHlwZW9mIGEucHJlUnVuJiYoYS5wcmVSdW49W2EucHJlUnVuXSk7Zm9yKDthLnByZVJ1bi5sZW5ndGg7KWU9YS5wcmVSdW4uc2hpZnQoKSxkLnVuc2hpZnQoZSl9dmFyIGU7Y2FsbFJ1bnRpbWVDYWxsYmFja3MoZCl9KCk7aWYoIShtPjApKWlmKGEuc2V0U3RhdHVzKXthLnNldFN0YXR1cygiUnVubmluZy4uLiIpO3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXthLnNldFN0YXR1cygiIil9KSwxKTtkb1J1bigpfSksMSl9ZWxzZSBkb1J1bigpfWZ1bmN0aW9uIGRvUnVuKCl7aWYoIUQpe0Q9ITA7YS5jYWxsZWRSdW49ITA7IWZ1bmN0aW9uIGluaXRSdW50aW1lKCl7Y2FsbFJ1bnRpbWVDYWxsYmFja3MoZil9KCk7dChhKTthLm9uUnVudGltZUluaXRpYWxpemVkJiZhLm9uUnVudGltZUluaXRpYWxpemVkKCk7IWZ1bmN0aW9uIHBvc3RSdW4oKXtpZihhLnBvc3RSdW4peyJmdW5jdGlvbiI9PXR5cGVvZiBhLnBvc3RSdW4mJihhLnBvc3RSdW49W2EucG9zdFJ1bl0pO2Zvcig7YS5wb3N0UnVuLmxlbmd0aDspZT1hLnBvc3RSdW4uc2hpZnQoKSxwLnVuc2hpZnQoZSl9dmFyIGU7Y2FsbFJ1bnRpbWVDYWxsYmFja3MocCl9KCl9fX1pZihhLnByZUluaXQpeyJmdW5jdGlvbiI9PXR5cGVvZiBhLnByZUluaXQmJihhLnByZUluaXQ9W2EucHJlSW5pdF0pO2Zvcig7YS5wcmVJbml0Lmxlbmd0aD4wOylhLnByZUluaXQucG9wKCkoKX1ydW4oKTtyZXR1cm4gZX0pO2NvbnN0IElpPWdpO2NsYXNzIEpweEVycm9yIGV4dGVuZHMgcnR7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiSnB4RXJyb3IiKX19Y2xhc3MgSnB4SW1hZ2V7c3RhdGljI3k9bnVsbDtzdGF0aWMgZGVjb2RlKGUsdD0hMSl7dGhpcy4jeXx8PUlpKHt3YXJufSk7Y29uc3QgaT10aGlzLiN5LmRlY29kZShlLHQpO2lmKCJzdHJpbmciPT10eXBlb2YgaSl0aHJvdyBuZXcgSnB4RXJyb3IoaSk7cmV0dXJuIGl9c3RhdGljIGNsZWFudXAoKXt0aGlzLiN5PW51bGx9c3RhdGljIHBhcnNlSW1hZ2VQcm9wZXJ0aWVzKGUpe2xldCB0PWUuZ2V0Qnl0ZSgpO2Zvcig7dD49MDspe2NvbnN0IGk9dDt0PWUuZ2V0Qnl0ZSgpO2lmKDY1MzYxPT09KGk8PDh8dCkpe2Uuc2tpcCg0KTtjb25zdCB0PWUuZ2V0SW50MzIoKT4+PjAsaT1lLmdldEludDMyKCk+Pj4wLGE9ZS5nZXRJbnQzMigpPj4+MCxzPWUuZ2V0SW50MzIoKT4+PjA7ZS5za2lwKDE2KTtyZXR1cm57d2lkdGg6dC1hLGhlaWdodDppLXMsYml0c1BlckNvbXBvbmVudDo4LGNvbXBvbmVudHNDb3VudDplLmdldFVpbnQxNigpfX19dGhyb3cgbmV3IEpweEVycm9yKCJObyBzaXplIG1hcmtlciBmb3VuZCBpbiBKUFggc3RyZWFtIil9fWNsYXNzIEpweFN0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIodCk7dGhpcy5zdHJlYW09ZTt0aGlzLmRpY3Q9ZS5kaWN0O3RoaXMubWF5YmVMZW5ndGg9dDt0aGlzLnBhcmFtcz1pfWdldCBieXRlcygpe3JldHVybiBzaGFkb3codGhpcywiYnl0ZXMiLHRoaXMuc3RyZWFtLmdldEJ5dGVzKHRoaXMubWF5YmVMZW5ndGgpKX1lbnN1cmVCdWZmZXIoZSl7fXJlYWRCbG9jayhlKXtpZighdGhpcy5lb2Ype3RoaXMuYnVmZmVyPUpweEltYWdlLmRlY29kZSh0aGlzLmJ5dGVzLGUpO3RoaXMuYnVmZmVyTGVuZ3RoPXRoaXMuYnVmZmVyLmxlbmd0aDt0aGlzLmVvZj0hMH19fWNsYXNzIExaV1N0cmVhbSBleHRlbmRzIERlY29kZVN0cmVhbXtjb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIodCk7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O3RoaXMuY2FjaGVkRGF0YT0wO3RoaXMuYml0c0NhY2hlZD0wO2NvbnN0IGE9NDA5NixzPXtlYXJseUNoYW5nZTppLGNvZGVMZW5ndGg6OSxuZXh0Q29kZToyNTgsZGljdGlvbmFyeVZhbHVlczpuZXcgVWludDhBcnJheShhKSxkaWN0aW9uYXJ5TGVuZ3RoczpuZXcgVWludDE2QXJyYXkoYSksZGljdGlvbmFyeVByZXZDb2RlczpuZXcgVWludDE2QXJyYXkoYSksY3VycmVudFNlcXVlbmNlOm5ldyBVaW50OEFycmF5KGEpLGN1cnJlbnRTZXF1ZW5jZUxlbmd0aDowfTtmb3IobGV0IGU9MDtlPDI1NjsrK2Upe3MuZGljdGlvbmFyeVZhbHVlc1tlXT1lO3MuZGljdGlvbmFyeUxlbmd0aHNbZV09MX10aGlzLmx6d1N0YXRlPXN9cmVhZEJpdHMoZSl7bGV0IHQ9dGhpcy5iaXRzQ2FjaGVkLGk9dGhpcy5jYWNoZWREYXRhO2Zvcig7dDxlOyl7Y29uc3QgZT10aGlzLnN0ci5nZXRCeXRlKCk7aWYoLTE9PT1lKXt0aGlzLmVvZj0hMDtyZXR1cm4gbnVsbH1pPWk8PDh8ZTt0Kz04fXRoaXMuYml0c0NhY2hlZD10LT1lO3RoaXMuY2FjaGVkRGF0YT1pO3RoaXMubGFzdENvZGU9bnVsbDtyZXR1cm4gaT4+PnQmKDE8PGUpLTF9cmVhZEJsb2NrKCl7bGV0IGUsdCxpLGE9MTAyNDtjb25zdCBzPXRoaXMubHp3U3RhdGU7aWYoIXMpcmV0dXJuO2NvbnN0IHI9cy5lYXJseUNoYW5nZTtsZXQgbj1zLm5leHRDb2RlO2NvbnN0IG89cy5kaWN0aW9uYXJ5VmFsdWVzLGc9cy5kaWN0aW9uYXJ5TGVuZ3RocyxjPXMuZGljdGlvbmFyeVByZXZDb2RlcztsZXQgQz1zLmNvZGVMZW5ndGgsaD1zLnByZXZDb2RlO2NvbnN0IGw9cy5jdXJyZW50U2VxdWVuY2U7bGV0IFE9cy5jdXJyZW50U2VxdWVuY2VMZW5ndGgsRT0wLHU9dGhpcy5idWZmZXJMZW5ndGgsZD10aGlzLmVuc3VyZUJ1ZmZlcih0aGlzLmJ1ZmZlckxlbmd0aCthKTtmb3IoZT0wO2U8NTEyO2UrKyl7Y29uc3QgZT10aGlzLnJlYWRCaXRzKEMpLHM9UT4wO2lmKGU8MjU2KXtsWzBdPWU7UT0xfWVsc2V7aWYoIShlPj0yNTgpKXtpZigyNTY9PT1lKXtDPTk7bj0yNTg7UT0wO2NvbnRpbnVlfXRoaXMuZW9mPSEwO2RlbGV0ZSB0aGlzLmx6d1N0YXRlO2JyZWFrfWlmKGU8bil7UT1nW2VdO2Zvcih0PVEtMSxpPWU7dD49MDt0LS0pe2xbdF09b1tpXTtpPWNbaV19fWVsc2UgbFtRKytdPWxbMF19aWYocyl7Y1tuXT1oO2dbbl09Z1toXSsxO29bbl09bFswXTtuKys7Qz1uK3ImbityLTE/QzowfE1hdGgubWluKE1hdGgubG9nKG4rcikvLjY5MzE0NzE4MDU1OTk0NTMrMSwxMil9aD1lO0UrPVE7aWYoYTxFKXtkb3thKz01MTJ9d2hpbGUoYTxFKTtkPXRoaXMuZW5zdXJlQnVmZmVyKHRoaXMuYnVmZmVyTGVuZ3RoK2EpfWZvcih0PTA7dDxRO3QrKylkW3UrK109bFt0XX1zLm5leHRDb2RlPW47cy5jb2RlTGVuZ3RoPUM7cy5wcmV2Q29kZT1oO3MuY3VycmVudFNlcXVlbmNlTGVuZ3RoPVE7dGhpcy5idWZmZXJMZW5ndGg9dX19Y2xhc3MgUHJlZGljdG9yU3RyZWFtIGV4dGVuZHMgRGVjb2RlU3RyZWFte2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcih0KTtpZighKGkgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm4gZTtjb25zdCBhPXRoaXMucHJlZGljdG9yPWkuZ2V0KCJQcmVkaWN0b3IiKXx8MTtpZihhPD0xKXJldHVybiBlO2lmKDIhPT1hJiYoYTwxMHx8YT4xNSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwcmVkaWN0b3I6ICR7YX1gKTt0aGlzLnJlYWRCbG9jaz0yPT09YT90aGlzLnJlYWRCbG9ja1RpZmY6dGhpcy5yZWFkQmxvY2tQbmc7dGhpcy5zdHI9ZTt0aGlzLmRpY3Q9ZS5kaWN0O2NvbnN0IHM9dGhpcy5jb2xvcnM9aS5nZXQoIkNvbG9ycyIpfHwxLHI9dGhpcy5iaXRzPWkuZ2V0KCJCUEMiLCJCaXRzUGVyQ29tcG9uZW50Iil8fDgsbj10aGlzLmNvbHVtbnM9aS5nZXQoIkNvbHVtbnMiKXx8MTt0aGlzLnBpeEJ5dGVzPXMqcis3Pj4zO3RoaXMucm93Qnl0ZXM9bipzKnIrNz4+MztyZXR1cm4gdGhpc31yZWFkQmxvY2tUaWZmKCl7Y29uc3QgZT10aGlzLnJvd0J5dGVzLHQ9dGhpcy5idWZmZXJMZW5ndGgsaT10aGlzLmVuc3VyZUJ1ZmZlcih0K2UpLGE9dGhpcy5iaXRzLHM9dGhpcy5jb2xvcnMscj10aGlzLnN0ci5nZXRCeXRlcyhlKTt0aGlzLmVvZj0hci5sZW5ndGg7aWYodGhpcy5lb2YpcmV0dXJuO2xldCBuLG89MCxnPTAsYz0wLEM9MCxoPXQ7aWYoMT09PWEmJjE9PT1zKWZvcihuPTA7bjxlOysrbil7bGV0IGU9cltuXV5vO2VePWU+PjE7ZV49ZT4+MjtlXj1lPj40O289KDEmZSk8PDc7aVtoKytdPWV9ZWxzZSBpZig4PT09YSl7Zm9yKG49MDtuPHM7KytuKWlbaCsrXT1yW25dO2Zvcig7bjxlOysrbil7aVtoXT1pW2gtc10rcltuXTtoKyt9fWVsc2UgaWYoMTY9PT1hKXtjb25zdCB0PTIqcztmb3Iobj0wO248dDsrK24paVtoKytdPXJbbl07Zm9yKDtuPGU7bis9Mil7Y29uc3QgZT0oKDI1NSZyW25dKTw8OCkrKDI1NSZyW24rMV0pKygoMjU1JmlbaC10XSk8PDgpKygyNTUmaVtoLXQrMV0pO2lbaCsrXT1lPj44JjI1NTtpW2grK109MjU1JmV9fWVsc2V7Y29uc3QgZT1uZXcgVWludDhBcnJheShzKzEpLGg9KDE8PGEpLTE7bGV0IGw9MCxRPXQ7Y29uc3QgRT10aGlzLmNvbHVtbnM7Zm9yKG49MDtuPEU7KytuKWZvcihsZXQgdD0wO3Q8czsrK3Qpe2lmKGM8YSl7bz1vPDw4fDI1NSZyW2wrK107Yys9OH1lW3RdPWVbdF0rKG8+PmMtYSkmaDtjLT1hO2c9Zzw8YXxlW3RdO0MrPWE7aWYoQz49OCl7aVtRKytdPWc+PkMtOCYyNTU7Qy09OH19Qz4wJiYoaVtRKytdPShnPDw4LUMpKyhvJigxPDw4LUMpLTEpKX10aGlzLmJ1ZmZlckxlbmd0aCs9ZX1yZWFkQmxvY2tQbmcoKXtjb25zdCBlPXRoaXMucm93Qnl0ZXMsdD10aGlzLnBpeEJ5dGVzLGk9dGhpcy5zdHIuZ2V0Qnl0ZSgpLGE9dGhpcy5zdHIuZ2V0Qnl0ZXMoZSk7dGhpcy5lb2Y9IWEubGVuZ3RoO2lmKHRoaXMuZW9mKXJldHVybjtjb25zdCBzPXRoaXMuYnVmZmVyTGVuZ3RoLHI9dGhpcy5lbnN1cmVCdWZmZXIocytlKTtsZXQgbj1yLnN1YmFycmF5KHMtZSxzKTswPT09bi5sZW5ndGgmJihuPW5ldyBVaW50OEFycmF5KGUpKTtsZXQgbyxnLGMsQz1zO3N3aXRjaChpKXtjYXNlIDA6Zm9yKG89MDtvPGU7KytvKXJbQysrXT1hW29dO2JyZWFrO2Nhc2UgMTpmb3Iobz0wO288dDsrK28pcltDKytdPWFbb107Zm9yKDtvPGU7KytvKXtyW0NdPXJbQy10XSthW29dJjI1NTtDKyt9YnJlYWs7Y2FzZSAyOmZvcihvPTA7bzxlOysrbylyW0MrK109bltvXSthW29dJjI1NTticmVhaztjYXNlIDM6Zm9yKG89MDtvPHQ7KytvKXJbQysrXT0obltvXT4+MSkrYVtvXTtmb3IoO288ZTsrK28pe3JbQ109KG5bb10rcltDLXRdPj4xKSthW29dJjI1NTtDKyt9YnJlYWs7Y2FzZSA0OmZvcihvPTA7bzx0Oysrbyl7Zz1uW29dO2M9YVtvXTtyW0MrK109ZytjfWZvcig7bzxlOysrbyl7Zz1uW29dO2NvbnN0IGU9bltvLXRdLGk9cltDLXRdLHM9aStnLWU7bGV0IGg9cy1pO2g8MCYmKGg9LWgpO2xldCBsPXMtZztsPDAmJihsPS1sKTtsZXQgUT1zLWU7UTwwJiYoUT0tUSk7Yz1hW29dO3JbQysrXT1oPD1sJiZoPD1RP2krYzpsPD1RP2crYzplK2N9YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVuc3VwcG9ydGVkIHByZWRpY3RvcjogJHtpfWApfXRoaXMuYnVmZmVyTGVuZ3RoKz1lfX1jbGFzcyBSdW5MZW5ndGhTdHJlYW0gZXh0ZW5kcyBEZWNvZGVTdHJlYW17Y29uc3RydWN0b3IoZSx0KXtzdXBlcih0KTt0aGlzLnN0cj1lO3RoaXMuZGljdD1lLmRpY3R9cmVhZEJsb2NrKCl7Y29uc3QgZT10aGlzLnN0ci5nZXRCeXRlcygyKTtpZighZXx8ZS5sZW5ndGg8Mnx8MTI4PT09ZVswXSl7dGhpcy5lb2Y9ITA7cmV0dXJufWxldCB0LGk9dGhpcy5idWZmZXJMZW5ndGgsYT1lWzBdO2lmKGE8MTI4KXt0PXRoaXMuZW5zdXJlQnVmZmVyKGkrYSsxKTt0W2krK109ZVsxXTtpZihhPjApe2NvbnN0IGU9dGhpcy5zdHIuZ2V0Qnl0ZXMoYSk7dC5zZXQoZSxpKTtpKz1hfX1lbHNle2E9MjU3LWE7Y29uc3Qgcz1lWzFdO3Q9dGhpcy5lbnN1cmVCdWZmZXIoaSthKzEpO2ZvcihsZXQgZT0wO2U8YTtlKyspdFtpKytdPXN9dGhpcy5idWZmZXJMZW5ndGg9aX19Y2xhc3MgUGFyc2Vye2NvbnN0cnVjdG9yKHtsZXhlcjplLHhyZWY6dCxhbGxvd1N0cmVhbXM6aT0hMSxyZWNvdmVyeU1vZGU6YT0hMX0pe3RoaXMubGV4ZXI9ZTt0aGlzLnhyZWY9dDt0aGlzLmFsbG93U3RyZWFtcz1pO3RoaXMucmVjb3ZlcnlNb2RlPWE7dGhpcy5pbWFnZUNhY2hlPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5faW1hZ2VJZD0wO3RoaXMucmVmaWxsKCl9cmVmaWxsKCl7dGhpcy5idWYxPXRoaXMubGV4ZXIuZ2V0T2JqKCk7dGhpcy5idWYyPXRoaXMubGV4ZXIuZ2V0T2JqKCl9c2hpZnQoKXtpZih0aGlzLmJ1ZjIgaW5zdGFuY2VvZiBDbWQmJiJJRCI9PT10aGlzLmJ1ZjIuY21kKXt0aGlzLmJ1ZjE9dGhpcy5idWYyO3RoaXMuYnVmMj1udWxsfWVsc2V7dGhpcy5idWYxPXRoaXMuYnVmMjt0aGlzLmJ1ZjI9dGhpcy5sZXhlci5nZXRPYmooKX19dHJ5U2hpZnQoKXt0cnl7dGhpcy5zaGlmdCgpO3JldHVybiEwfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO3JldHVybiExfX1nZXRPYmooZT1udWxsKXtjb25zdCB0PXRoaXMuYnVmMTt0aGlzLnNoaWZ0KCk7aWYodCBpbnN0YW5jZW9mIENtZClzd2l0Y2godC5jbWQpe2Nhc2UiQkkiOnJldHVybiB0aGlzLm1ha2VJbmxpbmVJbWFnZShlKTtjYXNlIlsiOmNvbnN0IGk9W107Zm9yKDshaXNDbWQodGhpcy5idWYxLCJdIikmJnRoaXMuYnVmMSE9PXB0OylpLnB1c2godGhpcy5nZXRPYmooZSkpO2lmKHRoaXMuYnVmMT09PXB0KXtpZih0aGlzLnJlY292ZXJ5TW9kZSlyZXR1cm4gaTt0aHJvdyBuZXcgUGFyc2VyRU9GRXhjZXB0aW9uKCJFbmQgb2YgZmlsZSBpbnNpZGUgYXJyYXkuIil9dGhpcy5zaGlmdCgpO3JldHVybiBpO2Nhc2UiPDwiOmNvbnN0IGE9bmV3IERpY3QodGhpcy54cmVmKTtmb3IoOyFpc0NtZCh0aGlzLmJ1ZjEsIj4+IikmJnRoaXMuYnVmMSE9PXB0Oyl7aWYoISh0aGlzLmJ1ZjEgaW5zdGFuY2VvZiBOYW1lKSl7aW5mbygiTWFsZm9ybWVkIGRpY3Rpb25hcnk6IGtleSBtdXN0IGJlIGEgbmFtZSBvYmplY3QiKTt0aGlzLnNoaWZ0KCk7Y29udGludWV9Y29uc3QgdD10aGlzLmJ1ZjEubmFtZTt0aGlzLnNoaWZ0KCk7aWYodGhpcy5idWYxPT09cHQpYnJlYWs7YS5zZXQodCx0aGlzLmdldE9iaihlKSl9aWYodGhpcy5idWYxPT09cHQpe2lmKHRoaXMucmVjb3ZlcnlNb2RlKXJldHVybiBhO3Rocm93IG5ldyBQYXJzZXJFT0ZFeGNlcHRpb24oIkVuZCBvZiBmaWxlIGluc2lkZSBkaWN0aW9uYXJ5LiIpfWlmKGlzQ21kKHRoaXMuYnVmMiwic3RyZWFtIikpcmV0dXJuIHRoaXMuYWxsb3dTdHJlYW1zP3RoaXMubWFrZVN0cmVhbShhLGUpOmE7dGhpcy5zaGlmdCgpO3JldHVybiBhO2RlZmF1bHQ6cmV0dXJuIHR9aWYoTnVtYmVyLmlzSW50ZWdlcih0KSl7aWYoTnVtYmVyLmlzSW50ZWdlcih0aGlzLmJ1ZjEpJiZpc0NtZCh0aGlzLmJ1ZjIsIlIiKSl7Y29uc3QgZT1SZWYuZ2V0KHQsdGhpcy5idWYxKTt0aGlzLnNoaWZ0KCk7dGhpcy5zaGlmdCgpO3JldHVybiBlfXJldHVybiB0fXJldHVybiJzdHJpbmciPT10eXBlb2YgdCYmZT9lLmRlY3J5cHRTdHJpbmcodCk6dH1maW5kRGVmYXVsdElubGluZVN0cmVhbUVuZChlKXtjb25zdHtrbm93bkNvbW1hbmRzOnR9PXRoaXMubGV4ZXIsaT1lLnBvcztsZXQgYSxzLHI9MDtmb3IoOy0xIT09KGE9ZS5nZXRCeXRlKCkpOylpZigwPT09cilyPTY5PT09YT8xOjA7ZWxzZSBpZigxPT09cilyPTczPT09YT8yOjA7ZWxzZSBpZigzMj09PWF8fDEwPT09YXx8MTM9PT1hKXtzPWUucG9zO2NvbnN0IGk9ZS5wZWVrQnl0ZXMoMTUpLG49aS5sZW5ndGg7aWYoMD09PW4pYnJlYWs7Zm9yKGxldCBlPTA7ZTxuO2UrKyl7YT1pW2VdO2lmKCgwIT09YXx8MD09PWlbZSsxXSkmJigxMCE9PWEmJjEzIT09YSYmKGE8MzJ8fGE+MTI3KSkpe3I9MDticmVha319aWYoMiE9PXIpY29udGludWU7aWYoIXQpe3dhcm4oImZpbmREZWZhdWx0SW5saW5lU3RyZWFtRW5kIC0gYGxleGVyLmtub3duQ29tbWFuZHNgIGlzIHVuZGVmaW5lZC4iKTtjb250aW51ZX1jb25zdCBvPW5ldyBMZXhlcihuZXcgU3RyZWFtKGkuc2xpY2UoKSksdCk7by5faGV4U3RyaW5nV2Fybj0oKT0+e307bGV0IGc9MDtmb3IoOzspe2NvbnN0IGU9by5nZXRPYmooKTtpZihlPT09cHQpe3I9MDticmVha31pZihlIGluc3RhbmNlb2YgQ21kKXtjb25zdCBpPXRbZS5jbWRdO2lmKCFpKXtyPTA7YnJlYWt9aWYoaS52YXJpYWJsZUFyZ3M/Zzw9aS5udW1BcmdzOmc9PT1pLm51bUFyZ3MpYnJlYWs7Zz0wfWVsc2UgZysrfWlmKDI9PT1yKWJyZWFrfWVsc2Ugcj0wO2lmKC0xPT09YSl7d2FybigiZmluZERlZmF1bHRJbmxpbmVTdHJlYW1FbmQ6IFJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhvdXQgZmluZGluZyBhIHZhbGlkIEVJIG1hcmtlciIpO2lmKHMpe3dhcm4oJy4uLiB0cnlpbmcgdG8gcmVjb3ZlciBieSB1c2luZyB0aGUgbGFzdCAiRUkiIG9jY3VycmVuY2UuJyk7ZS5za2lwKC0oZS5wb3MtcykpfX1sZXQgbj00O2Uuc2tpcCgtbik7YT1lLnBlZWtCeXRlKCk7ZS5za2lwKG4pO2lzV2hpdGVTcGFjZShhKXx8bi0tO3JldHVybiBlLnBvcy1uLWl9ZmluZERDVERlY29kZUlubGluZVN0cmVhbUVuZChlKXtjb25zdCB0PWUucG9zO2xldCBpLGEscz0hMTtmb3IoOy0xIT09KGk9ZS5nZXRCeXRlKCkpOylpZigyNTU9PT1pKXtzd2l0Y2goZS5nZXRCeXRlKCkpe2Nhc2UgMDpicmVhaztjYXNlIDI1NTplLnNraXAoLTEpO2JyZWFrO2Nhc2UgMjE3OnM9ITA7YnJlYWs7Y2FzZSAxOTI6Y2FzZSAxOTM6Y2FzZSAxOTQ6Y2FzZSAxOTU6Y2FzZSAxOTc6Y2FzZSAxOTg6Y2FzZSAxOTk6Y2FzZSAyMDE6Y2FzZSAyMDI6Y2FzZSAyMDM6Y2FzZSAyMDU6Y2FzZSAyMDY6Y2FzZSAyMDc6Y2FzZSAxOTY6Y2FzZSAyMDQ6Y2FzZSAyMTg6Y2FzZSAyMTk6Y2FzZSAyMjA6Y2FzZSAyMjE6Y2FzZSAyMjI6Y2FzZSAyMjM6Y2FzZSAyMjQ6Y2FzZSAyMjU6Y2FzZSAyMjY6Y2FzZSAyMjc6Y2FzZSAyMjg6Y2FzZSAyMjk6Y2FzZSAyMzA6Y2FzZSAyMzE6Y2FzZSAyMzI6Y2FzZSAyMzM6Y2FzZSAyMzQ6Y2FzZSAyMzU6Y2FzZSAyMzY6Y2FzZSAyMzc6Y2FzZSAyMzg6Y2FzZSAyMzk6Y2FzZSAyNTQ6YT1lLmdldFVpbnQxNigpO2E+Mj9lLnNraXAoYS0yKTplLnNraXAoLTIpfWlmKHMpYnJlYWt9Y29uc3Qgcj1lLnBvcy10O2lmKC0xPT09aSl7d2FybigiSW5saW5lIERDVERlY29kZSBpbWFnZSBzdHJlYW06IEVPSSBtYXJrZXIgbm90IGZvdW5kLCBzZWFyY2hpbmcgZm9yIC9FSS8gaW5zdGVhZC4iKTtlLnNraXAoLXIpO3JldHVybiB0aGlzLmZpbmREZWZhdWx0SW5saW5lU3RyZWFtRW5kKGUpfXRoaXMuaW5saW5lU3RyZWFtU2tpcEVJKGUpO3JldHVybiByfWZpbmRBU0NJSTg1RGVjb2RlSW5saW5lU3RyZWFtRW5kKGUpe2NvbnN0IHQ9ZS5wb3M7bGV0IGk7Zm9yKDstMSE9PShpPWUuZ2V0Qnl0ZSgpKTspaWYoMTI2PT09aSl7Y29uc3QgdD1lLnBvcztpPWUucGVla0J5dGUoKTtmb3IoO2lzV2hpdGVTcGFjZShpKTspe2Uuc2tpcCgpO2k9ZS5wZWVrQnl0ZSgpfWlmKDYyPT09aSl7ZS5za2lwKCk7YnJlYWt9aWYoZS5wb3M+dCl7Y29uc3QgdD1lLnBlZWtCeXRlcygyKTtpZig2OT09PXRbMF0mJjczPT09dFsxXSlicmVha319Y29uc3QgYT1lLnBvcy10O2lmKC0xPT09aSl7d2FybigiSW5saW5lIEFTQ0lJODVEZWNvZGUgaW1hZ2Ugc3RyZWFtOiBFT0QgbWFya2VyIG5vdCBmb3VuZCwgc2VhcmNoaW5nIGZvciAvRUkvIGluc3RlYWQuIik7ZS5za2lwKC1hKTtyZXR1cm4gdGhpcy5maW5kRGVmYXVsdElubGluZVN0cmVhbUVuZChlKX10aGlzLmlubGluZVN0cmVhbVNraXBFSShlKTtyZXR1cm4gYX1maW5kQVNDSUlIZXhEZWNvZGVJbmxpbmVTdHJlYW1FbmQoZSl7Y29uc3QgdD1lLnBvcztsZXQgaTtmb3IoOy0xIT09KGk9ZS5nZXRCeXRlKCkpJiY2MiE9PWk7KTtjb25zdCBhPWUucG9zLXQ7aWYoLTE9PT1pKXt3YXJuKCJJbmxpbmUgQVNDSUlIZXhEZWNvZGUgaW1hZ2Ugc3RyZWFtOiBFT0QgbWFya2VyIG5vdCBmb3VuZCwgc2VhcmNoaW5nIGZvciAvRUkvIGluc3RlYWQuIik7ZS5za2lwKC1hKTtyZXR1cm4gdGhpcy5maW5kRGVmYXVsdElubGluZVN0cmVhbUVuZChlKX10aGlzLmlubGluZVN0cmVhbVNraXBFSShlKTtyZXR1cm4gYX1pbmxpbmVTdHJlYW1Ta2lwRUkoZSl7bGV0IHQsaT0wO2Zvcig7LTEhPT0odD1lLmdldEJ5dGUoKSk7KWlmKDA9PT1pKWk9Njk9PT10PzE6MDtlbHNlIGlmKDE9PT1pKWk9NzM9PT10PzI6MDtlbHNlIGlmKDI9PT1pKWJyZWFrfW1ha2VJbmxpbmVJbWFnZShlKXtjb25zdCB0PXRoaXMubGV4ZXIsaT10LnN0cmVhbSxhPU9iamVjdC5jcmVhdGUobnVsbCk7bGV0IHM7Zm9yKDshaXNDbWQodGhpcy5idWYxLCJJRCIpJiZ0aGlzLmJ1ZjEhPT1wdDspe2lmKCEodGhpcy5idWYxIGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJEaWN0aW9uYXJ5IGtleSBtdXN0IGJlIGEgbmFtZSBvYmplY3QiKTtjb25zdCB0PXRoaXMuYnVmMS5uYW1lO3RoaXMuc2hpZnQoKTtpZih0aGlzLmJ1ZjE9PT1wdClicmVhazthW3RdPXRoaXMuZ2V0T2JqKGUpfS0xIT09dC5iZWdpbklubGluZUltYWdlUG9zJiYocz1pLnBvcy10LmJlZ2luSW5saW5lSW1hZ2VQb3MpO2NvbnN0IHI9dGhpcy54cmVmLmZldGNoSWZSZWYoYS5GfHxhLkZpbHRlcik7bGV0IG47aWYociBpbnN0YW5jZW9mIE5hbWUpbj1yLm5hbWU7ZWxzZSBpZihBcnJheS5pc0FycmF5KHIpKXtjb25zdCBlPXRoaXMueHJlZi5mZXRjaElmUmVmKHJbMF0pO2UgaW5zdGFuY2VvZiBOYW1lJiYobj1lLm5hbWUpfWNvbnN0IG89aS5wb3M7bGV0IGcsYztzd2l0Y2gobil7Y2FzZSJEQ1QiOmNhc2UiRENURGVjb2RlIjpnPXRoaXMuZmluZERDVERlY29kZUlubGluZVN0cmVhbUVuZChpKTticmVhaztjYXNlIkE4NSI6Y2FzZSJBU0NJSTg1RGVjb2RlIjpnPXRoaXMuZmluZEFTQ0lJODVEZWNvZGVJbmxpbmVTdHJlYW1FbmQoaSk7YnJlYWs7Y2FzZSJBSHgiOmNhc2UiQVNDSUlIZXhEZWNvZGUiOmc9dGhpcy5maW5kQVNDSUlIZXhEZWNvZGVJbmxpbmVTdHJlYW1FbmQoaSk7YnJlYWs7ZGVmYXVsdDpnPXRoaXMuZmluZERlZmF1bHRJbmxpbmVTdHJlYW1FbmQoaSl9aWYoZzwxZTMmJnM+MCl7Y29uc3QgZT1pLnBvcztpLnBvcz10LmJlZ2luSW5saW5lSW1hZ2VQb3M7Yz1mdW5jdGlvbiBnZXRJbmxpbmVJbWFnZUNhY2hlS2V5KGUpe2NvbnN0IHQ9W10saT1lLmxlbmd0aDtsZXQgYT0wO2Zvcig7YTxpLTE7KXQucHVzaChlW2ErK108PDh8ZVthKytdKTthPGkmJnQucHVzaChlW2FdKTtyZXR1cm4gaSsiXyIrU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHQpfShpLmdldEJ5dGVzKHMrZykpO2kucG9zPWU7Y29uc3QgYT10aGlzLmltYWdlQ2FjaGVbY107aWYodm9pZCAwIT09YSl7dGhpcy5idWYyPUNtZC5nZXQoIkVJIik7dGhpcy5zaGlmdCgpO2EucmVzZXQoKTtyZXR1cm4gYX19Y29uc3QgQz1uZXcgRGljdCh0aGlzLnhyZWYpO2Zvcihjb25zdCBlIGluIGEpQy5zZXQoZSxhW2VdKTtsZXQgaD1pLm1ha2VTdWJTdHJlYW0obyxnLEMpO2UmJihoPWUuY3JlYXRlU3RyZWFtKGgsZykpO2g9dGhpcy5maWx0ZXIoaCxDLGcpO2guZGljdD1DO2lmKHZvaWQgMCE9PWMpe2guY2FjaGVLZXk9ImlubGluZV9pbWdfIisgKyt0aGlzLl9pbWFnZUlkO3RoaXMuaW1hZ2VDYWNoZVtjXT1ofXRoaXMuYnVmMj1DbWQuZ2V0KCJFSSIpO3RoaXMuc2hpZnQoKTtyZXR1cm4gaH1fZmluZFN0cmVhbUxlbmd0aChlLHQpe2NvbnN0e3N0cmVhbTppfT10aGlzLmxleGVyO2kucG9zPWU7Y29uc3QgYT10Lmxlbmd0aDtmb3IoO2kucG9zPGkuZW5kOyl7Y29uc3Qgcz1pLnBlZWtCeXRlcygyMDQ4KSxyPXMubGVuZ3RoLWE7aWYocjw9MClicmVhaztsZXQgbj0wO2Zvcig7bjxyOyl7bGV0IHI9MDtmb3IoO3I8YSYmc1tuK3JdPT09dFtyXTspcisrO2lmKHI+PWEpe2kucG9zKz1uO3JldHVybiBpLnBvcy1lfW4rK31pLnBvcys9cn1yZXR1cm4tMX1tYWtlU3RyZWFtKGUsdCl7Y29uc3QgaT10aGlzLmxleGVyO2xldCBhPWkuc3RyZWFtO2kuc2tpcFRvTmV4dExpbmUoKTtjb25zdCBzPWEucG9zLTE7bGV0IHI9ZS5nZXQoIkxlbmd0aCIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXtpbmZvKGBCYWQgbGVuZ3RoICIke3ImJnIudG9TdHJpbmcoKX0iIGluIHN0cmVhbS5gKTtyPTB9YS5wb3M9cytyO2kubmV4dENoYXIoKTtpZih0aGlzLnRyeVNoaWZ0KCkmJmlzQ21kKHRoaXMuYnVmMiwiZW5kc3RyZWFtIikpdGhpcy5zaGlmdCgpO2Vsc2V7Y29uc3QgZT1uZXcgVWludDhBcnJheShbMTAxLDExMCwxMDAsMTE1LDExNiwxMTQsMTAxLDk3LDEwOV0pO2xldCB0PXRoaXMuX2ZpbmRTdHJlYW1MZW5ndGgocyxlKTtpZih0PDApe2NvbnN0IGk9MTtmb3IobGV0IHI9MTtyPD1pO3IrKyl7Y29uc3QgaT1lLmxlbmd0aC1yLG49ZS5zbGljZSgwLGkpLG89dGhpcy5fZmluZFN0cmVhbUxlbmd0aChzLG4pO2lmKG8+PTApe2lmKCFpc1doaXRlU3BhY2UoYS5wZWVrQnl0ZXMoaSsxKVtpXSkpYnJlYWs7aW5mbyhgRm91bmQgIiR7Ynl0ZXNUb1N0cmluZyhuKX0iIHdoZW4gc2VhcmNoaW5nIGZvciBlbmRzdHJlYW0gY29tbWFuZC5gKTt0PW87YnJlYWt9fWlmKHQ8MCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk1pc3NpbmcgZW5kc3RyZWFtIGNvbW1hbmQuIil9cj10O2kubmV4dENoYXIoKTt0aGlzLnNoaWZ0KCk7dGhpcy5zaGlmdCgpfXRoaXMuc2hpZnQoKTthPWEubWFrZVN1YlN0cmVhbShzLHIsZSk7dCYmKGE9dC5jcmVhdGVTdHJlYW0oYSxyKSk7YT10aGlzLmZpbHRlcihhLGUscik7YS5kaWN0PWU7cmV0dXJuIGF9ZmlsdGVyKGUsdCxpKXtsZXQgYT10LmdldCgiRiIsIkZpbHRlciIpLHM9dC5nZXQoIkRQIiwiRGVjb2RlUGFybXMiKTtpZihhIGluc3RhbmNlb2YgTmFtZSl7QXJyYXkuaXNBcnJheShzKSYmd2FybigiL0RlY29kZVBhcm1zIHNob3VsZCBub3QgYmUgYW4gQXJyYXksIHdoZW4gL0ZpbHRlciBpcyBhIE5hbWUuIik7cmV0dXJuIHRoaXMubWFrZUZpbHRlcihlLGEubmFtZSxpLHMpfWxldCByPWk7aWYoQXJyYXkuaXNBcnJheShhKSl7Y29uc3QgdD1hLGk9cztmb3IobGV0IG49MCxvPXQubGVuZ3RoO248bzsrK24pe2E9dGhpcy54cmVmLmZldGNoSWZSZWYodFtuXSk7aWYoIShhIGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBCYWQgZmlsdGVyIG5hbWUgIiR7YX0iYCk7cz1udWxsO0FycmF5LmlzQXJyYXkoaSkmJm4gaW4gaSYmKHM9dGhpcy54cmVmLmZldGNoSWZSZWYoaVtuXSkpO2U9dGhpcy5tYWtlRmlsdGVyKGUsYS5uYW1lLHIscyk7cj1udWxsfX1yZXR1cm4gZX1tYWtlRmlsdGVyKGUsdCxpLGEpe2lmKDA9PT1pKXt3YXJuKGBFbXB0eSAiJHt0fSIgc3RyZWFtLmApO3JldHVybiBuZXcgTnVsbFN0cmVhbX10cnl7c3dpdGNoKHQpe2Nhc2UiRmwiOmNhc2UiRmxhdGVEZWNvZGUiOnJldHVybiBhP25ldyBQcmVkaWN0b3JTdHJlYW0obmV3IEZsYXRlU3RyZWFtKGUsaSksaSxhKTpuZXcgRmxhdGVTdHJlYW0oZSxpKTtjYXNlIkxaVyI6Y2FzZSJMWldEZWNvZGUiOmxldCB0PTE7aWYoYSl7YS5oYXMoIkVhcmx5Q2hhbmdlIikmJih0PWEuZ2V0KCJFYXJseUNoYW5nZSIpKTtyZXR1cm4gbmV3IFByZWRpY3RvclN0cmVhbShuZXcgTFpXU3RyZWFtKGUsaSx0KSxpLGEpfXJldHVybiBuZXcgTFpXU3RyZWFtKGUsaSx0KTtjYXNlIkRDVCI6Y2FzZSJEQ1REZWNvZGUiOnJldHVybiBuZXcgSnBlZ1N0cmVhbShlLGksYSk7Y2FzZSJKUFgiOmNhc2UiSlBYRGVjb2RlIjpyZXR1cm4gbmV3IEpweFN0cmVhbShlLGksYSk7Y2FzZSJBODUiOmNhc2UiQVNDSUk4NURlY29kZSI6cmV0dXJuIG5ldyBBc2NpaTg1U3RyZWFtKGUsaSk7Y2FzZSJBSHgiOmNhc2UiQVNDSUlIZXhEZWNvZGUiOnJldHVybiBuZXcgQXNjaWlIZXhTdHJlYW0oZSxpKTtjYXNlIkNDRiI6Y2FzZSJDQ0lUVEZheERlY29kZSI6cmV0dXJuIG5ldyBDQ0lUVEZheFN0cmVhbShlLGksYSk7Y2FzZSJSTCI6Y2FzZSJSdW5MZW5ndGhEZWNvZGUiOnJldHVybiBuZXcgUnVuTGVuZ3RoU3RyZWFtKGUsaSk7Y2FzZSJKQklHMkRlY29kZSI6cmV0dXJuIG5ldyBKYmlnMlN0cmVhbShlLGksYSl9d2FybihgRmlsdGVyICIke3R9IiBpcyBub3Qgc3VwcG9ydGVkLmApO3JldHVybiBlfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO3dhcm4oYEludmFsaWQgc3RyZWFtOiAiJHtlfSJgKTtyZXR1cm4gbmV3IE51bGxTdHJlYW19fX1jb25zdCBjaT1bMSwwLDAsMCwwLDAsMCwwLDAsMSwxLDAsMSwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwyLDAsMCwyLDIsMCwwLDAsMCwwLDIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwwLDIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDAsMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwwLDIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF07ZnVuY3Rpb24gdG9IZXhEaWdpdChlKXtyZXR1cm4gZT49NDgmJmU8PTU3PzE1JmU6ZT49NjUmJmU8PTcwfHxlPj05NyYmZTw9MTAyPzkrKDE1JmUpOi0xfWNsYXNzIExleGVye2NvbnN0cnVjdG9yKGUsdD1udWxsKXt0aGlzLnN0cmVhbT1lO3RoaXMubmV4dENoYXIoKTt0aGlzLnN0ckJ1Zj1bXTt0aGlzLmtub3duQ29tbWFuZHM9dDt0aGlzLl9oZXhTdHJpbmdOdW1XYXJuPTA7dGhpcy5iZWdpbklubGluZUltYWdlUG9zPS0xfW5leHRDaGFyKCl7cmV0dXJuIHRoaXMuY3VycmVudENoYXI9dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpfXBlZWtDaGFyKCl7cmV0dXJuIHRoaXMuc3RyZWFtLnBlZWtCeXRlKCl9Z2V0TnVtYmVyKCl7bGV0IGU9dGhpcy5jdXJyZW50Q2hhcix0PSExLGk9MCxhPTE7aWYoNDU9PT1lKXthPS0xO2U9dGhpcy5uZXh0Q2hhcigpOzQ1PT09ZSYmKGU9dGhpcy5uZXh0Q2hhcigpKX1lbHNlIDQzPT09ZSYmKGU9dGhpcy5uZXh0Q2hhcigpKTtpZigxMD09PWV8fDEzPT09ZSlkb3tlPXRoaXMubmV4dENoYXIoKX13aGlsZSgxMD09PWV8fDEzPT09ZSk7aWYoNDY9PT1lKXtpPTEwO2U9dGhpcy5uZXh0Q2hhcigpfWlmKGU8NDh8fGU+NTcpe2NvbnN0IHQ9YEludmFsaWQgbnVtYmVyOiAke1N0cmluZy5mcm9tQ2hhckNvZGUoZSl9IChjaGFyQ29kZSAke2V9KWA7aWYoaXNXaGl0ZVNwYWNlKGUpfHwtMT09PWUpe2luZm8oYExleGVyLmdldE51bWJlciAtICIke3R9Ii5gKTtyZXR1cm4gMH10aHJvdyBuZXcgRm9ybWF0RXJyb3IodCl9bGV0IHM9ZS00OCxyPTAsbj0xO2Zvcig7KGU9dGhpcy5uZXh0Q2hhcigpKT49MDspaWYoZT49NDgmJmU8PTU3KXtjb25zdCBhPWUtNDg7aWYodClyPTEwKnIrYTtlbHNlezAhPT1pJiYoaSo9MTApO3M9MTAqcythfX1lbHNlIGlmKDQ2PT09ZSl7aWYoMCE9PWkpYnJlYWs7aT0xfWVsc2UgaWYoNDU9PT1lKXdhcm4oIkJhZGx5IGZvcm1hdHRlZCBudW1iZXI6IG1pbnVzIHNpZ24gaW4gdGhlIG1pZGRsZSIpO2Vsc2V7aWYoNjkhPT1lJiYxMDEhPT1lKWJyZWFrO2U9dGhpcy5wZWVrQ2hhcigpO2lmKDQzPT09ZXx8NDU9PT1lKXtuPTQ1PT09ZT8tMToxO3RoaXMubmV4dENoYXIoKX1lbHNlIGlmKGU8NDh8fGU+NTcpYnJlYWs7dD0hMH0wIT09aSYmKHMvPWkpO3QmJihzKj0xMCoqKG4qcikpO3JldHVybiBhKnN9Z2V0U3RyaW5nKCl7bGV0IGU9MSx0PSExO2NvbnN0IGk9dGhpcy5zdHJCdWY7aS5sZW5ndGg9MDtsZXQgYT10aGlzLm5leHRDaGFyKCk7Zm9yKDs7KXtsZXQgcz0hMTtzd2l0Y2goMHxhKXtjYXNlLTE6d2FybigiVW50ZXJtaW5hdGVkIHN0cmluZyIpO3Q9ITA7YnJlYWs7Y2FzZSA0MDorK2U7aS5wdXNoKCIoIik7YnJlYWs7Y2FzZSA0MTppZigwPT0tLWUpe3RoaXMubmV4dENoYXIoKTt0PSEwfWVsc2UgaS5wdXNoKCIpIik7YnJlYWs7Y2FzZSA5MjphPXRoaXMubmV4dENoYXIoKTtzd2l0Y2goYSl7Y2FzZS0xOndhcm4oIlVudGVybWluYXRlZCBzdHJpbmciKTt0PSEwO2JyZWFrO2Nhc2UgMTEwOmkucHVzaCgiXG4iKTticmVhaztjYXNlIDExNDppLnB1c2goIlxyIik7YnJlYWs7Y2FzZSAxMTY6aS5wdXNoKCJcdCIpO2JyZWFrO2Nhc2UgOTg6aS5wdXNoKCJcYiIpO2JyZWFrO2Nhc2UgMTAyOmkucHVzaCgiXGYiKTticmVhaztjYXNlIDkyOmNhc2UgNDA6Y2FzZSA0MTppLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhKSk7YnJlYWs7Y2FzZSA0ODpjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmxldCBlPTE1JmE7YT10aGlzLm5leHRDaGFyKCk7cz0hMDtpZihhPj00OCYmYTw9NTUpe2U9KGU8PDMpKygxNSZhKTthPXRoaXMubmV4dENoYXIoKTtpZihhPj00OCYmYTw9NTUpe3M9ITE7ZT0oZTw8MykrKDE1JmEpfX1pLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShlKSk7YnJlYWs7Y2FzZSAxMzoxMD09PXRoaXMucGVla0NoYXIoKSYmdGhpcy5uZXh0Q2hhcigpO2JyZWFrO2Nhc2UgMTA6YnJlYWs7ZGVmYXVsdDppLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhKSl9YnJlYWs7ZGVmYXVsdDppLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhKSl9aWYodClicmVhaztzfHwoYT10aGlzLm5leHRDaGFyKCkpfXJldHVybiBpLmpvaW4oIiIpfWdldE5hbWUoKXtsZXQgZSx0O2NvbnN0IGk9dGhpcy5zdHJCdWY7aS5sZW5ndGg9MDtmb3IoOyhlPXRoaXMubmV4dENoYXIoKSk+PTAmJiFjaVtlXTspaWYoMzU9PT1lKXtlPXRoaXMubmV4dENoYXIoKTtpZihjaVtlXSl7d2FybigiTGV4ZXJfZ2V0TmFtZTogTlVNQkVSIFNJR04gKCMpIHNob3VsZCBiZSBmb2xsb3dlZCBieSBhIGhleGFkZWNpbWFsIG51bWJlci4iKTtpLnB1c2goIiMiKTticmVha31jb25zdCBhPXRvSGV4RGlnaXQoZSk7aWYoLTEhPT1hKXt0PWU7ZT10aGlzLm5leHRDaGFyKCk7Y29uc3Qgcz10b0hleERpZ2l0KGUpO2lmKC0xPT09cyl7d2FybihgTGV4ZXJfZ2V0TmFtZTogSWxsZWdhbCBkaWdpdCAoJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGUpfSkgaW4gaGV4YWRlY2ltYWwgbnVtYmVyLmApO2kucHVzaCgiIyIsU3RyaW5nLmZyb21DaGFyQ29kZSh0KSk7aWYoY2lbZV0pYnJlYWs7aS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpO2NvbnRpbnVlfWkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGE8PDR8cykpfWVsc2UgaS5wdXNoKCIjIixTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKX1lbHNlIGkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKTtpLmxlbmd0aD4xMjcmJndhcm4oYE5hbWUgdG9rZW4gaXMgbG9uZ2VyIHRoYW4gYWxsb3dlZCBieSB0aGUgc3BlYzogJHtpLmxlbmd0aH1gKTtyZXR1cm4gTmFtZS5nZXQoaS5qb2luKCIiKSl9X2hleFN0cmluZ1dhcm4oZSl7NSE9dGhpcy5faGV4U3RyaW5nTnVtV2FybisrP3RoaXMuX2hleFN0cmluZ051bVdhcm4+NXx8d2FybihgZ2V0SGV4U3RyaW5nIC0gaWdub3JpbmcgaW52YWxpZCBjaGFyYWN0ZXI6ICR7ZX1gKTp3YXJuKCJnZXRIZXhTdHJpbmcgLSBpZ25vcmluZyBhZGRpdGlvbmFsIGludmFsaWQgY2hhcmFjdGVycy4iKX1nZXRIZXhTdHJpbmcoKXtjb25zdCBlPXRoaXMuc3RyQnVmO2UubGVuZ3RoPTA7bGV0IHQsaSxhPXRoaXMuY3VycmVudENoYXIscz0hMDt0aGlzLl9oZXhTdHJpbmdOdW1XYXJuPTA7Zm9yKDs7KXtpZihhPDApe3dhcm4oIlVudGVybWluYXRlZCBoZXggc3RyaW5nIik7YnJlYWt9aWYoNjI9PT1hKXt0aGlzLm5leHRDaGFyKCk7YnJlYWt9aWYoMSE9PWNpW2FdKXtpZihzKXt0PXRvSGV4RGlnaXQoYSk7aWYoLTE9PT10KXt0aGlzLl9oZXhTdHJpbmdXYXJuKGEpO2E9dGhpcy5uZXh0Q2hhcigpO2NvbnRpbnVlfX1lbHNle2k9dG9IZXhEaWdpdChhKTtpZigtMT09PWkpe3RoaXMuX2hleFN0cmluZ1dhcm4oYSk7YT10aGlzLm5leHRDaGFyKCk7Y29udGludWV9ZS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodDw8NHxpKSl9cz0hczthPXRoaXMubmV4dENoYXIoKX1lbHNlIGE9dGhpcy5uZXh0Q2hhcigpfXJldHVybiBlLmpvaW4oIiIpfWdldE9iaigpe2xldCBlPSExLHQ9dGhpcy5jdXJyZW50Q2hhcjtmb3IoOzspe2lmKHQ8MClyZXR1cm4gcHQ7aWYoZSkxMCE9PXQmJjEzIT09dHx8KGU9ITEpO2Vsc2UgaWYoMzc9PT10KWU9ITA7ZWxzZSBpZigxIT09Y2lbdF0pYnJlYWs7dD10aGlzLm5leHRDaGFyKCl9c3dpdGNoKDB8dCl7Y2FzZSA0ODpjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmNhc2UgNTY6Y2FzZSA1NzpjYXNlIDQzOmNhc2UgNDU6Y2FzZSA0NjpyZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtjYXNlIDQwOnJldHVybiB0aGlzLmdldFN0cmluZygpO2Nhc2UgNDc6cmV0dXJuIHRoaXMuZ2V0TmFtZSgpO2Nhc2UgOTE6dGhpcy5uZXh0Q2hhcigpO3JldHVybiBDbWQuZ2V0KCJbIik7Y2FzZSA5Mzp0aGlzLm5leHRDaGFyKCk7cmV0dXJuIENtZC5nZXQoIl0iKTtjYXNlIDYwOnQ9dGhpcy5uZXh0Q2hhcigpO2lmKDYwPT09dCl7dGhpcy5uZXh0Q2hhcigpO3JldHVybiBDbWQuZ2V0KCI8PCIpfXJldHVybiB0aGlzLmdldEhleFN0cmluZygpO2Nhc2UgNjI6dD10aGlzLm5leHRDaGFyKCk7aWYoNjI9PT10KXt0aGlzLm5leHRDaGFyKCk7cmV0dXJuIENtZC5nZXQoIj4+Iil9cmV0dXJuIENtZC5nZXQoIj4iKTtjYXNlIDEyMzp0aGlzLm5leHRDaGFyKCk7cmV0dXJuIENtZC5nZXQoInsiKTtjYXNlIDEyNTp0aGlzLm5leHRDaGFyKCk7cmV0dXJuIENtZC5nZXQoIn0iKTtjYXNlIDQxOnRoaXMubmV4dENoYXIoKTt0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYElsbGVnYWwgY2hhcmFjdGVyOiAke3R9YCl9bGV0IGk9U3RyaW5nLmZyb21DaGFyQ29kZSh0KTtpZih0PDMyfHx0PjEyNyl7Y29uc3QgZT10aGlzLnBlZWtDaGFyKCk7aWYoZT49MzImJmU8PTEyNyl7dGhpcy5uZXh0Q2hhcigpO3JldHVybiBDbWQuZ2V0KGkpfX1jb25zdCBhPXRoaXMua25vd25Db21tYW5kcztsZXQgcz12b2lkIDAhPT1hPy5baV07Zm9yKDsodD10aGlzLm5leHRDaGFyKCkpPj0wJiYhY2lbdF07KXtjb25zdCBlPWkrU3RyaW5nLmZyb21DaGFyQ29kZSh0KTtpZihzJiZ2b2lkIDA9PT1hW2VdKWJyZWFrO2lmKDEyOD09PWkubGVuZ3RoKXRocm93IG5ldyBGb3JtYXRFcnJvcihgQ29tbWFuZCB0b2tlbiB0b28gbG9uZzogJHtpLmxlbmd0aH1gKTtpPWU7cz12b2lkIDAhPT1hPy5baV19aWYoInRydWUiPT09aSlyZXR1cm4hMDtpZigiZmFsc2UiPT09aSlyZXR1cm4hMTtpZigibnVsbCI9PT1pKXJldHVybiBudWxsOyJCSSI9PT1pJiYodGhpcy5iZWdpbklubGluZUltYWdlUG9zPXRoaXMuc3RyZWFtLnBvcyk7cmV0dXJuIENtZC5nZXQoaSl9c2tpcFRvTmV4dExpbmUoKXtsZXQgZT10aGlzLmN1cnJlbnRDaGFyO2Zvcig7ZT49MDspe2lmKDEzPT09ZSl7ZT10aGlzLm5leHRDaGFyKCk7MTA9PT1lJiZ0aGlzLm5leHRDaGFyKCk7YnJlYWt9aWYoMTA9PT1lKXt0aGlzLm5leHRDaGFyKCk7YnJlYWt9ZT10aGlzLm5leHRDaGFyKCl9fX1jbGFzcyBMaW5lYXJpemF0aW9ue3N0YXRpYyBjcmVhdGUoZSl7ZnVuY3Rpb24gZ2V0SW50KGUsdCxpPSExKXtjb25zdCBhPWUuZ2V0KHQpO2lmKE51bWJlci5pc0ludGVnZXIoYSkmJihpP2E+PTA6YT4wKSlyZXR1cm4gYTt0aHJvdyBuZXcgRXJyb3IoYFRoZSAiJHt0fSIgcGFyYW1ldGVyIGluIHRoZSBsaW5lYXJpemF0aW9uIGRpY3Rpb25hcnkgaXMgaW52YWxpZC5gKX1jb25zdCB0PW5ldyBQYXJzZXIoe2xleGVyOm5ldyBMZXhlcihlKSx4cmVmOm51bGx9KSxpPXQuZ2V0T2JqKCksYT10LmdldE9iaigpLHM9dC5nZXRPYmooKSxyPXQuZ2V0T2JqKCk7bGV0IG4sbztpZighKE51bWJlci5pc0ludGVnZXIoaSkmJk51bWJlci5pc0ludGVnZXIoYSkmJmlzQ21kKHMsIm9iaiIpJiZyIGluc3RhbmNlb2YgRGljdCYmIm51bWJlciI9PXR5cGVvZihuPXIuZ2V0KCJMaW5lYXJpemVkIikpJiZuPjApKXJldHVybiBudWxsO2lmKChvPWdldEludChyLCJMIikpIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdUaGUgIkwiIHBhcmFtZXRlciBpbiB0aGUgbGluZWFyaXphdGlvbiBkaWN0aW9uYXJ5IGRvZXMgbm90IGVxdWFsIHRoZSBzdHJlYW0gbGVuZ3RoLicpO3JldHVybntsZW5ndGg6byxoaW50czpmdW5jdGlvbiBnZXRIaW50cyhlKXtjb25zdCB0PWUuZ2V0KCJIIik7bGV0IGk7aWYoQXJyYXkuaXNBcnJheSh0KSYmKDI9PT0oaT10Lmxlbmd0aCl8fDQ9PT1pKSl7Zm9yKGxldCBlPTA7ZTxpO2UrKyl7Y29uc3QgaT10W2VdO2lmKCEoTnVtYmVyLmlzSW50ZWdlcihpKSYmaT4wKSl0aHJvdyBuZXcgRXJyb3IoYEhpbnQgKCR7ZX0pIGluIHRoZSBsaW5lYXJpemF0aW9uIGRpY3Rpb25hcnkgaXMgaW52YWxpZC5gKX1yZXR1cm4gdH10aHJvdyBuZXcgRXJyb3IoIkhpbnQgYXJyYXkgaW4gdGhlIGxpbmVhcml6YXRpb24gZGljdGlvbmFyeSBpcyBpbnZhbGlkLiIpfShyKSxvYmplY3ROdW1iZXJGaXJzdDpnZXRJbnQociwiTyIpLGVuZEZpcnN0OmdldEludChyLCJFIiksbnVtUGFnZXM6Z2V0SW50KHIsIk4iKSxtYWluWFJlZkVudHJpZXNPZmZzZXQ6Z2V0SW50KHIsIlQiKSxwYWdlRmlyc3Q6ci5oYXMoIlAiKT9nZXRJbnQociwiUCIsITApOjB9fX1jb25zdCBDaT1bIkFkb2JlLUdCMS1VQ1MyIiwiQWRvYmUtQ05TMS1VQ1MyIiwiQWRvYmUtSmFwYW4xLVVDUzIiLCJBZG9iZS1Lb3JlYTEtVUNTMiIsIjc4LUVVQy1IIiwiNzgtRVVDLVYiLCI3OC1IIiwiNzgtUktTSi1IIiwiNzgtUktTSi1WIiwiNzgtViIsIjc4bXMtUktTSi1IIiwiNzhtcy1SS1NKLVYiLCI4M3B2LVJLU0otSCIsIjkwbXMtUktTSi1IIiwiOTBtcy1SS1NKLVYiLCI5MG1zcC1SS1NKLUgiLCI5MG1zcC1SS1NKLVYiLCI5MHB2LVJLU0otSCIsIjkwcHYtUktTSi1WIiwiQWRkLUgiLCJBZGQtUktTSi1IIiwiQWRkLVJLU0otViIsIkFkZC1WIiwiQWRvYmUtQ05TMS0wIiwiQWRvYmUtQ05TMS0xIiwiQWRvYmUtQ05TMS0yIiwiQWRvYmUtQ05TMS0zIiwiQWRvYmUtQ05TMS00IiwiQWRvYmUtQ05TMS01IiwiQWRvYmUtQ05TMS02IiwiQWRvYmUtR0IxLTAiLCJBZG9iZS1HQjEtMSIsIkFkb2JlLUdCMS0yIiwiQWRvYmUtR0IxLTMiLCJBZG9iZS1HQjEtNCIsIkFkb2JlLUdCMS01IiwiQWRvYmUtSmFwYW4xLTAiLCJBZG9iZS1KYXBhbjEtMSIsIkFkb2JlLUphcGFuMS0yIiwiQWRvYmUtSmFwYW4xLTMiLCJBZG9iZS1KYXBhbjEtNCIsIkFkb2JlLUphcGFuMS01IiwiQWRvYmUtSmFwYW4xLTYiLCJBZG9iZS1Lb3JlYTEtMCIsIkFkb2JlLUtvcmVhMS0xIiwiQWRvYmUtS29yZWExLTIiLCJCNS1IIiwiQjUtViIsIkI1cGMtSCIsIkI1cGMtViIsIkNOUy1FVUMtSCIsIkNOUy1FVUMtViIsIkNOUzEtSCIsIkNOUzEtViIsIkNOUzItSCIsIkNOUzItViIsIkVUSEstQjUtSCIsIkVUSEstQjUtViIsIkVUZW4tQjUtSCIsIkVUZW4tQjUtViIsIkVUZW5tcy1CNS1IIiwiRVRlbm1zLUI1LVYiLCJFVUMtSCIsIkVVQy1WIiwiRXh0LUgiLCJFeHQtUktTSi1IIiwiRXh0LVJLU0otViIsIkV4dC1WIiwiR0ItRVVDLUgiLCJHQi1FVUMtViIsIkdCLUgiLCJHQi1WIiwiR0JLLUVVQy1IIiwiR0JLLUVVQy1WIiwiR0JLMkstSCIsIkdCSzJLLVYiLCJHQktwLUVVQy1IIiwiR0JLcC1FVUMtViIsIkdCVC1FVUMtSCIsIkdCVC1FVUMtViIsIkdCVC1IIiwiR0JULVYiLCJHQlRwYy1FVUMtSCIsIkdCVHBjLUVVQy1WIiwiR0JwYy1FVUMtSCIsIkdCcGMtRVVDLVYiLCJIIiwiSEtkbGEtQjUtSCIsIkhLZGxhLUI1LVYiLCJIS2RsYi1CNS1IIiwiSEtkbGItQjUtViIsIkhLZ2Njcy1CNS1IIiwiSEtnY2NzLUI1LVYiLCJIS20zMTQtQjUtSCIsIkhLbTMxNC1CNS1WIiwiSEttNDcxLUI1LUgiLCJIS200NzEtQjUtViIsIkhLc2NzLUI1LUgiLCJIS3Njcy1CNS1WIiwiSGFua2FrdSIsIkhpcmFnYW5hIiwiS1NDLUVVQy1IIiwiS1NDLUVVQy1WIiwiS1NDLUgiLCJLU0MtSm9oYWItSCIsIktTQy1Kb2hhYi1WIiwiS1NDLVYiLCJLU0Ntcy1VSEMtSCIsIktTQ21zLVVIQy1IVy1IIiwiS1NDbXMtVUhDLUhXLVYiLCJLU0Ntcy1VSEMtViIsIktTQ3BjLUVVQy1IIiwiS1NDcGMtRVVDLVYiLCJLYXRha2FuYSIsIk5XUC1IIiwiTldQLVYiLCJSS1NKLUgiLCJSS1NKLVYiLCJSb21hbiIsIlVuaUNOUy1VQ1MyLUgiLCJVbmlDTlMtVUNTMi1WIiwiVW5pQ05TLVVURjE2LUgiLCJVbmlDTlMtVVRGMTYtViIsIlVuaUNOUy1VVEYzMi1IIiwiVW5pQ05TLVVURjMyLVYiLCJVbmlDTlMtVVRGOC1IIiwiVW5pQ05TLVVURjgtViIsIlVuaUdCLVVDUzItSCIsIlVuaUdCLVVDUzItViIsIlVuaUdCLVVURjE2LUgiLCJVbmlHQi1VVEYxNi1WIiwiVW5pR0ItVVRGMzItSCIsIlVuaUdCLVVURjMyLVYiLCJVbmlHQi1VVEY4LUgiLCJVbmlHQi1VVEY4LVYiLCJVbmlKSVMtVUNTMi1IIiwiVW5pSklTLVVDUzItSFctSCIsIlVuaUpJUy1VQ1MyLUhXLVYiLCJVbmlKSVMtVUNTMi1WIiwiVW5pSklTLVVURjE2LUgiLCJVbmlKSVMtVVRGMTYtViIsIlVuaUpJUy1VVEYzMi1IIiwiVW5pSklTLVVURjMyLVYiLCJVbmlKSVMtVVRGOC1IIiwiVW5pSklTLVVURjgtViIsIlVuaUpJUzIwMDQtVVRGMTYtSCIsIlVuaUpJUzIwMDQtVVRGMTYtViIsIlVuaUpJUzIwMDQtVVRGMzItSCIsIlVuaUpJUzIwMDQtVVRGMzItViIsIlVuaUpJUzIwMDQtVVRGOC1IIiwiVW5pSklTMjAwNC1VVEY4LVYiLCJVbmlKSVNQcm8tVUNTMi1IVy1WIiwiVW5pSklTUHJvLVVDUzItViIsIlVuaUpJU1Byby1VVEY4LVYiLCJVbmlKSVNYMDIxMy1VVEYzMi1IIiwiVW5pSklTWDAyMTMtVVRGMzItViIsIlVuaUpJU1gwMjEzMjAwNC1VVEYzMi1IIiwiVW5pSklTWDAyMTMyMDA0LVVURjMyLVYiLCJVbmlLUy1VQ1MyLUgiLCJVbmlLUy1VQ1MyLVYiLCJVbmlLUy1VVEYxNi1IIiwiVW5pS1MtVVRGMTYtViIsIlVuaUtTLVVURjMyLUgiLCJVbmlLUy1VVEYzMi1WIiwiVW5pS1MtVVRGOC1IIiwiVW5pS1MtVVRGOC1WIiwiViIsIldQLVN5bWJvbCJdLGhpPTIqKjI0LTE7Y2xhc3MgQ01hcHtjb25zdHJ1Y3RvcihlPSExKXt0aGlzLmNvZGVzcGFjZVJhbmdlcz1bW10sW10sW10sW11dO3RoaXMubnVtQ29kZXNwYWNlUmFuZ2VzPTA7dGhpcy5fbWFwPVtdO3RoaXMubmFtZT0iIjt0aGlzLnZlcnRpY2FsPSExO3RoaXMudXNlQ01hcD1udWxsO3RoaXMuYnVpbHRJbkNNYXA9ZX1hZGRDb2Rlc3BhY2VSYW5nZShlLHQsaSl7dGhpcy5jb2Rlc3BhY2VSYW5nZXNbZS0xXS5wdXNoKHQsaSk7dGhpcy5udW1Db2Rlc3BhY2VSYW5nZXMrK31tYXBDaWRSYW5nZShlLHQsaSl7aWYodC1lPmhpKXRocm93IG5ldyBFcnJvcigibWFwQ2lkUmFuZ2UgLSBpZ25vcmluZyBkYXRhIGFib3ZlIE1BWF9NQVBfUkFOR0UuIik7Zm9yKDtlPD10Oyl0aGlzLl9tYXBbZSsrXT1pKyt9bWFwQmZSYW5nZShlLHQsaSl7aWYodC1lPmhpKXRocm93IG5ldyBFcnJvcigibWFwQmZSYW5nZSAtIGlnbm9yaW5nIGRhdGEgYWJvdmUgTUFYX01BUF9SQU5HRS4iKTtjb25zdCBhPWkubGVuZ3RoLTE7Zm9yKDtlPD10Oyl7dGhpcy5fbWFwW2UrK109aTtjb25zdCB0PWkuY2hhckNvZGVBdChhKSsxO3Q+MjU1P2k9aS5zdWJzdHJpbmcoMCxhLTEpK1N0cmluZy5mcm9tQ2hhckNvZGUoaS5jaGFyQ29kZUF0KGEtMSkrMSkrIlwwIjppPWkuc3Vic3RyaW5nKDAsYSkrU3RyaW5nLmZyb21DaGFyQ29kZSh0KX19bWFwQmZSYW5nZVRvQXJyYXkoZSx0LGkpe2lmKHQtZT5oaSl0aHJvdyBuZXcgRXJyb3IoIm1hcEJmUmFuZ2VUb0FycmF5IC0gaWdub3JpbmcgZGF0YSBhYm92ZSBNQVhfTUFQX1JBTkdFLiIpO2NvbnN0IGE9aS5sZW5ndGg7bGV0IHM9MDtmb3IoO2U8PXQmJnM8YTspe3RoaXMuX21hcFtlXT1pW3MrK107KytlfX1tYXBPbmUoZSx0KXt0aGlzLl9tYXBbZV09dH1sb29rdXAoZSl7cmV0dXJuIHRoaXMuX21hcFtlXX1jb250YWlucyhlKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fbWFwW2VdfWZvckVhY2goZSl7Y29uc3QgdD10aGlzLl9tYXAsaT10Lmxlbmd0aDtpZihpPD02NTUzNilmb3IobGV0IGE9MDthPGk7YSsrKXZvaWQgMCE9PXRbYV0mJmUoYSx0W2FdKTtlbHNlIGZvcihjb25zdCBpIGluIHQpZShpLHRbaV0pfWNoYXJDb2RlT2YoZSl7Y29uc3QgdD10aGlzLl9tYXA7aWYodC5sZW5ndGg8PTY1NTM2KXJldHVybiB0LmluZGV4T2YoZSk7Zm9yKGNvbnN0IGkgaW4gdClpZih0W2ldPT09ZSlyZXR1cm4gMHxpO3JldHVybi0xfWdldE1hcCgpe3JldHVybiB0aGlzLl9tYXB9cmVhZENoYXJDb2RlKGUsdCxpKXtsZXQgYT0wO2NvbnN0IHM9dGhpcy5jb2Rlc3BhY2VSYW5nZXM7Zm9yKGxldCByPTAsbj1zLmxlbmd0aDtyPG47cisrKXthPShhPDw4fGUuY2hhckNvZGVBdCh0K3IpKT4+PjA7Y29uc3Qgbj1zW3JdO2ZvcihsZXQgZT0wLHQ9bi5sZW5ndGg7ZTx0Oyl7Y29uc3QgdD1uW2UrK10scz1uW2UrK107aWYoYT49dCYmYTw9cyl7aS5jaGFyY29kZT1hO2kubGVuZ3RoPXIrMTtyZXR1cm59fX1pLmNoYXJjb2RlPTA7aS5sZW5ndGg9MX1nZXRDaGFyQ29kZUxlbmd0aChlKXtjb25zdCB0PXRoaXMuY29kZXNwYWNlUmFuZ2VzO2ZvcihsZXQgaT0wLGE9dC5sZW5ndGg7aTxhO2krKyl7Y29uc3QgYT10W2ldO2ZvcihsZXQgdD0wLHM9YS5sZW5ndGg7dDxzOyl7Y29uc3Qgcz1hW3QrK10scj1hW3QrK107aWYoZT49cyYmZTw9cilyZXR1cm4gaSsxfX1yZXR1cm4gMX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX21hcC5sZW5ndGh9Z2V0IGlzSWRlbnRpdHlDTWFwKCl7aWYoIklkZW50aXR5LUgiIT09dGhpcy5uYW1lJiYiSWRlbnRpdHktViIhPT10aGlzLm5hbWUpcmV0dXJuITE7aWYoNjU1MzYhPT10aGlzLl9tYXAubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZT0wO2U8NjU1MzY7ZSsrKWlmKHRoaXMuX21hcFtlXSE9PWUpcmV0dXJuITE7cmV0dXJuITB9fWNsYXNzIElkZW50aXR5Q01hcCBleHRlbmRzIENNYXB7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigpO3RoaXMudmVydGljYWw9ZTt0aGlzLmFkZENvZGVzcGFjZVJhbmdlKHQsMCw2NTUzNSl9bWFwQ2lkUmFuZ2UoZSx0LGkpe3VucmVhY2hhYmxlKCJzaG91bGQgbm90IGNhbGwgbWFwQ2lkUmFuZ2UiKX1tYXBCZlJhbmdlKGUsdCxpKXt1bnJlYWNoYWJsZSgic2hvdWxkIG5vdCBjYWxsIG1hcEJmUmFuZ2UiKX1tYXBCZlJhbmdlVG9BcnJheShlLHQsaSl7dW5yZWFjaGFibGUoInNob3VsZCBub3QgY2FsbCBtYXBCZlJhbmdlVG9BcnJheSIpfW1hcE9uZShlLHQpe3VucmVhY2hhYmxlKCJzaG91bGQgbm90IGNhbGwgbWFwQ2lkT25lIil9bG9va3VwKGUpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPD02NTUzNT9lOnZvaWQgMH1jb250YWlucyhlKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihlKSYmZTw9NjU1MzV9Zm9yRWFjaChlKXtmb3IobGV0IHQ9MDt0PD02NTUzNTt0KyspZSh0LHQpfWNoYXJDb2RlT2YoZSl7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSkmJmU8PTY1NTM1P2U6LTF9Z2V0TWFwKCl7Y29uc3QgZT1uZXcgQXJyYXkoNjU1MzYpO2ZvcihsZXQgdD0wO3Q8PTY1NTM1O3QrKyllW3RdPXQ7cmV0dXJuIGV9Z2V0IGxlbmd0aCgpe3JldHVybiA2NTUzNn1nZXQgaXNJZGVudGl0eUNNYXAoKXt1bnJlYWNoYWJsZSgic2hvdWxkIG5vdCBhY2Nlc3MgLmlzSWRlbnRpdHlDTWFwIil9fWZ1bmN0aW9uIHN0clRvSW50KGUpe2xldCB0PTA7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKyspdD10PDw4fGUuY2hhckNvZGVBdChpKTtyZXR1cm4gdD4+PjB9ZnVuY3Rpb24gZXhwZWN0U3RyaW5nKGUpe2lmKCJzdHJpbmciIT10eXBlb2YgZSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk1hbGZvcm1lZCBDTWFwOiBleHBlY3RlZCBzdHJpbmcuIil9ZnVuY3Rpb24gZXhwZWN0SW50KGUpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiTWFsZm9ybWVkIENNYXA6IGV4cGVjdGVkIGludC4iKX1mdW5jdGlvbiBwYXJzZUJmQ2hhcihlLHQpe2Zvcig7Oyl7bGV0IGk9dC5nZXRPYmooKTtpZihpPT09cHQpYnJlYWs7aWYoaXNDbWQoaSwiZW5kYmZjaGFyIikpcmV0dXJuO2V4cGVjdFN0cmluZyhpKTtjb25zdCBhPXN0clRvSW50KGkpO2k9dC5nZXRPYmooKTtleHBlY3RTdHJpbmcoaSk7Y29uc3Qgcz1pO2UubWFwT25lKGEscyl9fWZ1bmN0aW9uIHBhcnNlQmZSYW5nZShlLHQpe2Zvcig7Oyl7bGV0IGk9dC5nZXRPYmooKTtpZihpPT09cHQpYnJlYWs7aWYoaXNDbWQoaSwiZW5kYmZyYW5nZSIpKXJldHVybjtleHBlY3RTdHJpbmcoaSk7Y29uc3QgYT1zdHJUb0ludChpKTtpPXQuZ2V0T2JqKCk7ZXhwZWN0U3RyaW5nKGkpO2NvbnN0IHM9c3RyVG9JbnQoaSk7aT10LmdldE9iaigpO2lmKE51bWJlci5pc0ludGVnZXIoaSl8fCJzdHJpbmciPT10eXBlb2YgaSl7Y29uc3QgdD1OdW1iZXIuaXNJbnRlZ2VyKGkpP1N0cmluZy5mcm9tQ2hhckNvZGUoaSk6aTtlLm1hcEJmUmFuZ2UoYSxzLHQpfWVsc2V7aWYoIWlzQ21kKGksIlsiKSlicmVhazt7aT10LmdldE9iaigpO2NvbnN0IHI9W107Zm9yKDshaXNDbWQoaSwiXSIpJiZpIT09cHQ7KXtyLnB1c2goaSk7aT10LmdldE9iaigpfWUubWFwQmZSYW5nZVRvQXJyYXkoYSxzLHIpfX19dGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIGJmIHJhbmdlLiIpfWZ1bmN0aW9uIHBhcnNlQ2lkQ2hhcihlLHQpe2Zvcig7Oyl7bGV0IGk9dC5nZXRPYmooKTtpZihpPT09cHQpYnJlYWs7aWYoaXNDbWQoaSwiZW5kY2lkY2hhciIpKXJldHVybjtleHBlY3RTdHJpbmcoaSk7Y29uc3QgYT1zdHJUb0ludChpKTtpPXQuZ2V0T2JqKCk7ZXhwZWN0SW50KGkpO2NvbnN0IHM9aTtlLm1hcE9uZShhLHMpfX1mdW5jdGlvbiBwYXJzZUNpZFJhbmdlKGUsdCl7Zm9yKDs7KXtsZXQgaT10LmdldE9iaigpO2lmKGk9PT1wdClicmVhaztpZihpc0NtZChpLCJlbmRjaWRyYW5nZSIpKXJldHVybjtleHBlY3RTdHJpbmcoaSk7Y29uc3QgYT1zdHJUb0ludChpKTtpPXQuZ2V0T2JqKCk7ZXhwZWN0U3RyaW5nKGkpO2NvbnN0IHM9c3RyVG9JbnQoaSk7aT10LmdldE9iaigpO2V4cGVjdEludChpKTtjb25zdCByPWk7ZS5tYXBDaWRSYW5nZShhLHMscil9fWZ1bmN0aW9uIHBhcnNlQ29kZXNwYWNlUmFuZ2UoZSx0KXtmb3IoOzspe2xldCBpPXQuZ2V0T2JqKCk7aWYoaT09PXB0KWJyZWFrO2lmKGlzQ21kKGksImVuZGNvZGVzcGFjZXJhbmdlIikpcmV0dXJuO2lmKCJzdHJpbmciIT10eXBlb2YgaSlicmVhaztjb25zdCBhPXN0clRvSW50KGkpO2k9dC5nZXRPYmooKTtpZigic3RyaW5nIiE9dHlwZW9mIGkpYnJlYWs7Y29uc3Qgcz1zdHJUb0ludChpKTtlLmFkZENvZGVzcGFjZVJhbmdlKGkubGVuZ3RoLGEscyl9dGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIGNvZGVzcGFjZSByYW5nZS4iKX1mdW5jdGlvbiBwYXJzZVdNb2RlKGUsdCl7Y29uc3QgaT10LmdldE9iaigpO051bWJlci5pc0ludGVnZXIoaSkmJihlLnZlcnRpY2FsPSEhaSl9ZnVuY3Rpb24gcGFyc2VDTWFwTmFtZShlLHQpe2NvbnN0IGk9dC5nZXRPYmooKTtpIGluc3RhbmNlb2YgTmFtZSYmKGUubmFtZT1pLm5hbWUpfWFzeW5jIGZ1bmN0aW9uIHBhcnNlQ01hcChlLHQsaSxhKXtsZXQgcyxyO0E6Zm9yKDs7KXRyeXtjb25zdCBpPXQuZ2V0T2JqKCk7aWYoaT09PXB0KWJyZWFrO2lmKGkgaW5zdGFuY2VvZiBOYW1lKXsiV01vZGUiPT09aS5uYW1lP3BhcnNlV01vZGUoZSx0KToiQ01hcE5hbWUiPT09aS5uYW1lJiZwYXJzZUNNYXBOYW1lKGUsdCk7cz1pfWVsc2UgaWYoaSBpbnN0YW5jZW9mIENtZClzd2l0Y2goaS5jbWQpe2Nhc2UiZW5kY21hcCI6YnJlYWsgQTtjYXNlInVzZWNtYXAiOnMgaW5zdGFuY2VvZiBOYW1lJiYocj1zLm5hbWUpO2JyZWFrO2Nhc2UiYmVnaW5jb2Rlc3BhY2VyYW5nZSI6cGFyc2VDb2Rlc3BhY2VSYW5nZShlLHQpO2JyZWFrO2Nhc2UiYmVnaW5iZmNoYXIiOnBhcnNlQmZDaGFyKGUsdCk7YnJlYWs7Y2FzZSJiZWdpbmNpZGNoYXIiOnBhcnNlQ2lkQ2hhcihlLHQpO2JyZWFrO2Nhc2UiYmVnaW5iZnJhbmdlIjpwYXJzZUJmUmFuZ2UoZSx0KTticmVhaztjYXNlImJlZ2luY2lkcmFuZ2UiOnBhcnNlQ2lkUmFuZ2UoZSx0KX19Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybigiSW52YWxpZCBjTWFwIGRhdGE6ICIrZSk7Y29udGludWV9IWEmJnImJihhPXIpO3JldHVybiBhP2V4dGVuZENNYXAoZSxpLGEpOmV9YXN5bmMgZnVuY3Rpb24gZXh0ZW5kQ01hcChlLHQsaSl7ZS51c2VDTWFwPWF3YWl0IGNyZWF0ZUJ1aWx0SW5DTWFwKGksdCk7aWYoMD09PWUubnVtQ29kZXNwYWNlUmFuZ2VzKXtjb25zdCB0PWUudXNlQ01hcC5jb2Rlc3BhY2VSYW5nZXM7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspZS5jb2Rlc3BhY2VSYW5nZXNbaV09dFtpXS5zbGljZSgpO2UubnVtQ29kZXNwYWNlUmFuZ2VzPWUudXNlQ01hcC5udW1Db2Rlc3BhY2VSYW5nZXN9ZS51c2VDTWFwLmZvckVhY2goKGZ1bmN0aW9uKHQsaSl7ZS5jb250YWlucyh0KXx8ZS5tYXBPbmUodCxlLnVzZUNNYXAubG9va3VwKHQpKX0pKTtyZXR1cm4gZX1hc3luYyBmdW5jdGlvbiBjcmVhdGVCdWlsdEluQ01hcChlLHQpe2lmKCJJZGVudGl0eS1IIj09PWUpcmV0dXJuIG5ldyBJZGVudGl0eUNNYXAoITEsMik7aWYoIklkZW50aXR5LVYiPT09ZSlyZXR1cm4gbmV3IElkZW50aXR5Q01hcCghMCwyKTtpZighQ2kuaW5jbHVkZXMoZSkpdGhyb3cgbmV3IEVycm9yKCJVbmtub3duIENNYXAgbmFtZTogIitlKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoIkJ1aWx0LWluIENNYXAgcGFyYW1ldGVycyBhcmUgbm90IHByb3ZpZGVkLiIpO2NvbnN0e2NNYXBEYXRhOmksY29tcHJlc3Npb25UeXBlOmF9PWF3YWl0IHQoZSkscz1uZXcgQ01hcCghMCk7aWYoYT09PW1BLkJJTkFSWSlyZXR1cm4obmV3IEJpbmFyeUNNYXBSZWFkZXIpLnByb2Nlc3MoaSxzLChlPT5leHRlbmRDTWFwKHMsdCxlKSkpO2lmKGE9PT1tQS5OT05FKXtjb25zdCBlPW5ldyBMZXhlcihuZXcgU3RyZWFtKGkpKTtyZXR1cm4gcGFyc2VDTWFwKHMsZSx0LG51bGwpfXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDTWFwICJjb21wcmVzc2lvblR5cGUiIHZhbHVlOiAke2F9YCl9Y2xhc3MgQ01hcEZhY3Rvcnl7c3RhdGljIGFzeW5jIGNyZWF0ZSh7ZW5jb2Rpbmc6ZSxmZXRjaEJ1aWx0SW5DTWFwOnQsdXNlQ01hcDppfSl7aWYoZSBpbnN0YW5jZW9mIE5hbWUpcmV0dXJuIGNyZWF0ZUJ1aWx0SW5DTWFwKGUubmFtZSx0KTtpZihlIGluc3RhbmNlb2YgQmFzZVN0cmVhbSl7Y29uc3QgYT1hd2FpdCBwYXJzZUNNYXAobmV3IENNYXAsbmV3IExleGVyKGUpLHQsaSk7cmV0dXJuIGEuaXNJZGVudGl0eUNNYXA/Y3JlYXRlQnVpbHRJbkNNYXAoYS5uYW1lLHQpOmF9dGhyb3cgbmV3IEVycm9yKCJFbmNvZGluZyByZXF1aXJlZC4iKX19Y29uc3QgbGk9WyIubm90ZGVmIiwic3BhY2UiLCJleGNsYW0iLCJxdW90ZWRibCIsIm51bWJlcnNpZ24iLCJkb2xsYXIiLCJwZXJjZW50IiwiYW1wZXJzYW5kIiwicXVvdGVyaWdodCIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwicXVvdGVsZWZ0IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJicmFjZWxlZnQiLCJiYXIiLCJicmFjZXJpZ2h0IiwiYXNjaWl0aWxkZSIsImV4Y2xhbWRvd24iLCJjZW50Iiwic3RlcmxpbmciLCJmcmFjdGlvbiIsInllbiIsImZsb3JpbiIsInNlY3Rpb24iLCJjdXJyZW5jeSIsInF1b3Rlc2luZ2xlIiwicXVvdGVkYmxsZWZ0IiwiZ3VpbGxlbW90bGVmdCIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCJlbmRhc2giLCJkYWdnZXIiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsInBhcmFncmFwaCIsImJ1bGxldCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicXVvdGVkYmxyaWdodCIsImd1aWxsZW1vdHJpZ2h0IiwiZWxsaXBzaXMiLCJwZXJ0aG91c2FuZCIsInF1ZXN0aW9uZG93biIsImdyYXZlIiwiYWN1dGUiLCJjaXJjdW1mbGV4IiwidGlsZGUiLCJtYWNyb24iLCJicmV2ZSIsImRvdGFjY2VudCIsImRpZXJlc2lzIiwicmluZyIsImNlZGlsbGEiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiIsImVtZGFzaCIsIkFFIiwib3JkZmVtaW5pbmUiLCJMc2xhc2giLCJPc2xhc2giLCJPRSIsIm9yZG1hc2N1bGluZSIsImFlIiwiZG90bGVzc2kiLCJsc2xhc2giLCJvc2xhc2giLCJvZSIsImdlcm1hbmRibHMiLCJvbmVzdXBlcmlvciIsImxvZ2ljYWxub3QiLCJtdSIsInRyYWRlbWFyayIsIkV0aCIsIm9uZWhhbGYiLCJwbHVzbWludXMiLCJUaG9ybiIsIm9uZXF1YXJ0ZXIiLCJkaXZpZGUiLCJicm9rZW5iYXIiLCJkZWdyZWUiLCJ0aG9ybiIsInRocmVlcXVhcnRlcnMiLCJ0d29zdXBlcmlvciIsInJlZ2lzdGVyZWQiLCJtaW51cyIsImV0aCIsIm11bHRpcGx5IiwidGhyZWVzdXBlcmlvciIsImNvcHlyaWdodCIsIkFhY3V0ZSIsIkFjaXJjdW1mbGV4IiwiQWRpZXJlc2lzIiwiQWdyYXZlIiwiQXJpbmciLCJBdGlsZGUiLCJDY2VkaWxsYSIsIkVhY3V0ZSIsIkVjaXJjdW1mbGV4IiwiRWRpZXJlc2lzIiwiRWdyYXZlIiwiSWFjdXRlIiwiSWNpcmN1bWZsZXgiLCJJZGllcmVzaXMiLCJJZ3JhdmUiLCJOdGlsZGUiLCJPYWN1dGUiLCJPY2lyY3VtZmxleCIsIk9kaWVyZXNpcyIsIk9ncmF2ZSIsIk90aWxkZSIsIlNjYXJvbiIsIlVhY3V0ZSIsIlVjaXJjdW1mbGV4IiwiVWRpZXJlc2lzIiwiVWdyYXZlIiwiWWFjdXRlIiwiWWRpZXJlc2lzIiwiWmNhcm9uIiwiYWFjdXRlIiwiYWNpcmN1bWZsZXgiLCJhZGllcmVzaXMiLCJhZ3JhdmUiLCJhcmluZyIsImF0aWxkZSIsImNjZWRpbGxhIiwiZWFjdXRlIiwiZWNpcmN1bWZsZXgiLCJlZGllcmVzaXMiLCJlZ3JhdmUiLCJpYWN1dGUiLCJpY2lyY3VtZmxleCIsImlkaWVyZXNpcyIsImlncmF2ZSIsIm50aWxkZSIsIm9hY3V0ZSIsIm9jaXJjdW1mbGV4Iiwib2RpZXJlc2lzIiwib2dyYXZlIiwib3RpbGRlIiwic2Nhcm9uIiwidWFjdXRlIiwidWNpcmN1bWZsZXgiLCJ1ZGllcmVzaXMiLCJ1Z3JhdmUiLCJ5YWN1dGUiLCJ5ZGllcmVzaXMiLCJ6Y2Fyb24iXSxCaT1bIi5ub3RkZWYiLCJzcGFjZSIsImV4Y2xhbXNtYWxsIiwiSHVuZ2FydW1sYXV0c21hbGwiLCJkb2xsYXJvbGRzdHlsZSIsImRvbGxhcnN1cGVyaW9yIiwiYW1wZXJzYW5kc21hbGwiLCJBY3V0ZXNtYWxsIiwicGFyZW5sZWZ0c3VwZXJpb3IiLCJwYXJlbnJpZ2h0c3VwZXJpb3IiLCJ0d29kb3RlbmxlYWRlciIsIm9uZWRvdGVubGVhZGVyIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJmcmFjdGlvbiIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbG9uIiwic2VtaWNvbG9uIiwiY29tbWFzdXBlcmlvciIsInRocmVlcXVhcnRlcnNlbWRhc2giLCJwZXJpb2RzdXBlcmlvciIsInF1ZXN0aW9uc21hbGwiLCJhc3VwZXJpb3IiLCJic3VwZXJpb3IiLCJjZW50c3VwZXJpb3IiLCJkc3VwZXJpb3IiLCJlc3VwZXJpb3IiLCJpc3VwZXJpb3IiLCJsc3VwZXJpb3IiLCJtc3VwZXJpb3IiLCJuc3VwZXJpb3IiLCJvc3VwZXJpb3IiLCJyc3VwZXJpb3IiLCJzc3VwZXJpb3IiLCJ0c3VwZXJpb3IiLCJmZiIsImZpIiwiZmwiLCJmZmkiLCJmZmwiLCJwYXJlbmxlZnRpbmZlcmlvciIsInBhcmVucmlnaHRpbmZlcmlvciIsIkNpcmN1bWZsZXhzbWFsbCIsImh5cGhlbnN1cGVyaW9yIiwiR3JhdmVzbWFsbCIsIkFzbWFsbCIsIkJzbWFsbCIsIkNzbWFsbCIsIkRzbWFsbCIsIkVzbWFsbCIsIkZzbWFsbCIsIkdzbWFsbCIsIkhzbWFsbCIsIklzbWFsbCIsIkpzbWFsbCIsIktzbWFsbCIsIkxzbWFsbCIsIk1zbWFsbCIsIk5zbWFsbCIsIk9zbWFsbCIsIlBzbWFsbCIsIlFzbWFsbCIsIlJzbWFsbCIsIlNzbWFsbCIsIlRzbWFsbCIsIlVzbWFsbCIsIlZzbWFsbCIsIldzbWFsbCIsIlhzbWFsbCIsIllzbWFsbCIsIlpzbWFsbCIsImNvbG9ubW9uZXRhcnkiLCJvbmVmaXR0ZWQiLCJydXBpYWgiLCJUaWxkZXNtYWxsIiwiZXhjbGFtZG93bnNtYWxsIiwiY2VudG9sZHN0eWxlIiwiTHNsYXNoc21hbGwiLCJTY2Fyb25zbWFsbCIsIlpjYXJvbnNtYWxsIiwiRGllcmVzaXNzbWFsbCIsIkJyZXZlc21hbGwiLCJDYXJvbnNtYWxsIiwiRG90YWNjZW50c21hbGwiLCJNYWNyb25zbWFsbCIsImZpZ3VyZWRhc2giLCJoeXBoZW5pbmZlcmlvciIsIk9nb25la3NtYWxsIiwiUmluZ3NtYWxsIiwiQ2VkaWxsYXNtYWxsIiwib25lcXVhcnRlciIsIm9uZWhhbGYiLCJ0aHJlZXF1YXJ0ZXJzIiwicXVlc3Rpb25kb3duc21hbGwiLCJvbmVlaWdodGgiLCJ0aHJlZWVpZ2h0aHMiLCJmaXZlZWlnaHRocyIsInNldmVuZWlnaHRocyIsIm9uZXRoaXJkIiwidHdvdGhpcmRzIiwiemVyb3N1cGVyaW9yIiwib25lc3VwZXJpb3IiLCJ0d29zdXBlcmlvciIsInRocmVlc3VwZXJpb3IiLCJmb3Vyc3VwZXJpb3IiLCJmaXZlc3VwZXJpb3IiLCJzaXhzdXBlcmlvciIsInNldmVuc3VwZXJpb3IiLCJlaWdodHN1cGVyaW9yIiwibmluZXN1cGVyaW9yIiwiemVyb2luZmVyaW9yIiwib25laW5mZXJpb3IiLCJ0d29pbmZlcmlvciIsInRocmVlaW5mZXJpb3IiLCJmb3VyaW5mZXJpb3IiLCJmaXZlaW5mZXJpb3IiLCJzaXhpbmZlcmlvciIsInNldmVuaW5mZXJpb3IiLCJlaWdodGluZmVyaW9yIiwibmluZWluZmVyaW9yIiwiY2VudGluZmVyaW9yIiwiZG9sbGFyaW5mZXJpb3IiLCJwZXJpb2RpbmZlcmlvciIsImNvbW1haW5mZXJpb3IiLCJBZ3JhdmVzbWFsbCIsIkFhY3V0ZXNtYWxsIiwiQWNpcmN1bWZsZXhzbWFsbCIsIkF0aWxkZXNtYWxsIiwiQWRpZXJlc2lzc21hbGwiLCJBcmluZ3NtYWxsIiwiQUVzbWFsbCIsIkNjZWRpbGxhc21hbGwiLCJFZ3JhdmVzbWFsbCIsIkVhY3V0ZXNtYWxsIiwiRWNpcmN1bWZsZXhzbWFsbCIsIkVkaWVyZXNpc3NtYWxsIiwiSWdyYXZlc21hbGwiLCJJYWN1dGVzbWFsbCIsIkljaXJjdW1mbGV4c21hbGwiLCJJZGllcmVzaXNzbWFsbCIsIkV0aHNtYWxsIiwiTnRpbGRlc21hbGwiLCJPZ3JhdmVzbWFsbCIsIk9hY3V0ZXNtYWxsIiwiT2NpcmN1bWZsZXhzbWFsbCIsIk90aWxkZXNtYWxsIiwiT2RpZXJlc2lzc21hbGwiLCJPRXNtYWxsIiwiT3NsYXNoc21hbGwiLCJVZ3JhdmVzbWFsbCIsIlVhY3V0ZXNtYWxsIiwiVWNpcmN1bWZsZXhzbWFsbCIsIlVkaWVyZXNpc3NtYWxsIiwiWWFjdXRlc21hbGwiLCJUaG9ybnNtYWxsIiwiWWRpZXJlc2lzc21hbGwiXSxRaT1bIi5ub3RkZWYiLCJzcGFjZSIsImRvbGxhcm9sZHN0eWxlIiwiZG9sbGFyc3VwZXJpb3IiLCJwYXJlbmxlZnRzdXBlcmlvciIsInBhcmVucmlnaHRzdXBlcmlvciIsInR3b2RvdGVubGVhZGVyIiwib25lZG90ZW5sZWFkZXIiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsImZyYWN0aW9uIiwiemVyb29sZHN0eWxlIiwib25lb2xkc3R5bGUiLCJ0d29vbGRzdHlsZSIsInRocmVlb2xkc3R5bGUiLCJmb3Vyb2xkc3R5bGUiLCJmaXZlb2xkc3R5bGUiLCJzaXhvbGRzdHlsZSIsInNldmVub2xkc3R5bGUiLCJlaWdodG9sZHN0eWxlIiwibmluZW9sZHN0eWxlIiwiY29sb24iLCJzZW1pY29sb24iLCJjb21tYXN1cGVyaW9yIiwidGhyZWVxdWFydGVyc2VtZGFzaCIsInBlcmlvZHN1cGVyaW9yIiwiYXN1cGVyaW9yIiwiYnN1cGVyaW9yIiwiY2VudHN1cGVyaW9yIiwiZHN1cGVyaW9yIiwiZXN1cGVyaW9yIiwiaXN1cGVyaW9yIiwibHN1cGVyaW9yIiwibXN1cGVyaW9yIiwibnN1cGVyaW9yIiwib3N1cGVyaW9yIiwicnN1cGVyaW9yIiwic3N1cGVyaW9yIiwidHN1cGVyaW9yIiwiZmYiLCJmaSIsImZsIiwiZmZpIiwiZmZsIiwicGFyZW5sZWZ0aW5mZXJpb3IiLCJwYXJlbnJpZ2h0aW5mZXJpb3IiLCJoeXBoZW5zdXBlcmlvciIsImNvbG9ubW9uZXRhcnkiLCJvbmVmaXR0ZWQiLCJydXBpYWgiLCJjZW50b2xkc3R5bGUiLCJmaWd1cmVkYXNoIiwiaHlwaGVuaW5mZXJpb3IiLCJvbmVxdWFydGVyIiwib25laGFsZiIsInRocmVlcXVhcnRlcnMiLCJvbmVlaWdodGgiLCJ0aHJlZWVpZ2h0aHMiLCJmaXZlZWlnaHRocyIsInNldmVuZWlnaHRocyIsIm9uZXRoaXJkIiwidHdvdGhpcmRzIiwiemVyb3N1cGVyaW9yIiwib25lc3VwZXJpb3IiLCJ0d29zdXBlcmlvciIsInRocmVlc3VwZXJpb3IiLCJmb3Vyc3VwZXJpb3IiLCJmaXZlc3VwZXJpb3IiLCJzaXhzdXBlcmlvciIsInNldmVuc3VwZXJpb3IiLCJlaWdodHN1cGVyaW9yIiwibmluZXN1cGVyaW9yIiwiemVyb2luZmVyaW9yIiwib25laW5mZXJpb3IiLCJ0d29pbmZlcmlvciIsInRocmVlaW5mZXJpb3IiLCJmb3VyaW5mZXJpb3IiLCJmaXZlaW5mZXJpb3IiLCJzaXhpbmZlcmlvciIsInNldmVuaW5mZXJpb3IiLCJlaWdodGluZmVyaW9yIiwibmluZWluZmVyaW9yIiwiY2VudGluZmVyaW9yIiwiZG9sbGFyaW5mZXJpb3IiLCJwZXJpb2RpbmZlcmlvciIsImNvbW1haW5mZXJpb3IiXSxFaT1bIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsInNwYWNlIiwiZXhjbGFtc21hbGwiLCJIdW5nYXJ1bWxhdXRzbWFsbCIsIiIsImRvbGxhcm9sZHN0eWxlIiwiZG9sbGFyc3VwZXJpb3IiLCJhbXBlcnNhbmRzbWFsbCIsIkFjdXRlc21hbGwiLCJwYXJlbmxlZnRzdXBlcmlvciIsInBhcmVucmlnaHRzdXBlcmlvciIsInR3b2RvdGVubGVhZGVyIiwib25lZG90ZW5sZWFkZXIiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsImZyYWN0aW9uIiwiemVyb29sZHN0eWxlIiwib25lb2xkc3R5bGUiLCJ0d29vbGRzdHlsZSIsInRocmVlb2xkc3R5bGUiLCJmb3Vyb2xkc3R5bGUiLCJmaXZlb2xkc3R5bGUiLCJzaXhvbGRzdHlsZSIsInNldmVub2xkc3R5bGUiLCJlaWdodG9sZHN0eWxlIiwibmluZW9sZHN0eWxlIiwiY29sb24iLCJzZW1pY29sb24iLCJjb21tYXN1cGVyaW9yIiwidGhyZWVxdWFydGVyc2VtZGFzaCIsInBlcmlvZHN1cGVyaW9yIiwicXVlc3Rpb25zbWFsbCIsIiIsImFzdXBlcmlvciIsImJzdXBlcmlvciIsImNlbnRzdXBlcmlvciIsImRzdXBlcmlvciIsImVzdXBlcmlvciIsIiIsIiIsIiIsImlzdXBlcmlvciIsIiIsIiIsImxzdXBlcmlvciIsIm1zdXBlcmlvciIsIm5zdXBlcmlvciIsIm9zdXBlcmlvciIsIiIsIiIsInJzdXBlcmlvciIsInNzdXBlcmlvciIsInRzdXBlcmlvciIsIiIsImZmIiwiZmkiLCJmbCIsImZmaSIsImZmbCIsInBhcmVubGVmdGluZmVyaW9yIiwiIiwicGFyZW5yaWdodGluZmVyaW9yIiwiQ2lyY3VtZmxleHNtYWxsIiwiaHlwaGVuc3VwZXJpb3IiLCJHcmF2ZXNtYWxsIiwiQXNtYWxsIiwiQnNtYWxsIiwiQ3NtYWxsIiwiRHNtYWxsIiwiRXNtYWxsIiwiRnNtYWxsIiwiR3NtYWxsIiwiSHNtYWxsIiwiSXNtYWxsIiwiSnNtYWxsIiwiS3NtYWxsIiwiTHNtYWxsIiwiTXNtYWxsIiwiTnNtYWxsIiwiT3NtYWxsIiwiUHNtYWxsIiwiUXNtYWxsIiwiUnNtYWxsIiwiU3NtYWxsIiwiVHNtYWxsIiwiVXNtYWxsIiwiVnNtYWxsIiwiV3NtYWxsIiwiWHNtYWxsIiwiWXNtYWxsIiwiWnNtYWxsIiwiY29sb25tb25ldGFyeSIsIm9uZWZpdHRlZCIsInJ1cGlhaCIsIlRpbGRlc21hbGwiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJleGNsYW1kb3duc21hbGwiLCJjZW50b2xkc3R5bGUiLCJMc2xhc2hzbWFsbCIsIiIsIiIsIlNjYXJvbnNtYWxsIiwiWmNhcm9uc21hbGwiLCJEaWVyZXNpc3NtYWxsIiwiQnJldmVzbWFsbCIsIkNhcm9uc21hbGwiLCIiLCJEb3RhY2NlbnRzbWFsbCIsIiIsIiIsIk1hY3JvbnNtYWxsIiwiIiwiIiwiZmlndXJlZGFzaCIsImh5cGhlbmluZmVyaW9yIiwiIiwiIiwiT2dvbmVrc21hbGwiLCJSaW5nc21hbGwiLCJDZWRpbGxhc21hbGwiLCIiLCIiLCIiLCJvbmVxdWFydGVyIiwib25laGFsZiIsInRocmVlcXVhcnRlcnMiLCJxdWVzdGlvbmRvd25zbWFsbCIsIm9uZWVpZ2h0aCIsInRocmVlZWlnaHRocyIsImZpdmVlaWdodGhzIiwic2V2ZW5laWdodGhzIiwib25ldGhpcmQiLCJ0d290aGlyZHMiLCIiLCIiLCJ6ZXJvc3VwZXJpb3IiLCJvbmVzdXBlcmlvciIsInR3b3N1cGVyaW9yIiwidGhyZWVzdXBlcmlvciIsImZvdXJzdXBlcmlvciIsImZpdmVzdXBlcmlvciIsInNpeHN1cGVyaW9yIiwic2V2ZW5zdXBlcmlvciIsImVpZ2h0c3VwZXJpb3IiLCJuaW5lc3VwZXJpb3IiLCJ6ZXJvaW5mZXJpb3IiLCJvbmVpbmZlcmlvciIsInR3b2luZmVyaW9yIiwidGhyZWVpbmZlcmlvciIsImZvdXJpbmZlcmlvciIsImZpdmVpbmZlcmlvciIsInNpeGluZmVyaW9yIiwic2V2ZW5pbmZlcmlvciIsImVpZ2h0aW5mZXJpb3IiLCJuaW5laW5mZXJpb3IiLCJjZW50aW5mZXJpb3IiLCJkb2xsYXJpbmZlcmlvciIsInBlcmlvZGluZmVyaW9yIiwiY29tbWFpbmZlcmlvciIsIkFncmF2ZXNtYWxsIiwiQWFjdXRlc21hbGwiLCJBY2lyY3VtZmxleHNtYWxsIiwiQXRpbGRlc21hbGwiLCJBZGllcmVzaXNzbWFsbCIsIkFyaW5nc21hbGwiLCJBRXNtYWxsIiwiQ2NlZGlsbGFzbWFsbCIsIkVncmF2ZXNtYWxsIiwiRWFjdXRlc21hbGwiLCJFY2lyY3VtZmxleHNtYWxsIiwiRWRpZXJlc2lzc21hbGwiLCJJZ3JhdmVzbWFsbCIsIklhY3V0ZXNtYWxsIiwiSWNpcmN1bWZsZXhzbWFsbCIsIklkaWVyZXNpc3NtYWxsIiwiRXRoc21hbGwiLCJOdGlsZGVzbWFsbCIsIk9ncmF2ZXNtYWxsIiwiT2FjdXRlc21hbGwiLCJPY2lyY3VtZmxleHNtYWxsIiwiT3RpbGRlc21hbGwiLCJPZGllcmVzaXNzbWFsbCIsIk9Fc21hbGwiLCJPc2xhc2hzbWFsbCIsIlVncmF2ZXNtYWxsIiwiVWFjdXRlc21hbGwiLCJVY2lyY3VtZmxleHNtYWxsIiwiVWRpZXJlc2lzc21hbGwiLCJZYWN1dGVzbWFsbCIsIlRob3Juc21hbGwiLCJZZGllcmVzaXNzbWFsbCJdLHVpPVsiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwic3BhY2UiLCJleGNsYW1zbWFsbCIsIkh1bmdhcnVtbGF1dHNtYWxsIiwiY2VudG9sZHN0eWxlIiwiZG9sbGFyb2xkc3R5bGUiLCJkb2xsYXJzdXBlcmlvciIsImFtcGVyc2FuZHNtYWxsIiwiQWN1dGVzbWFsbCIsInBhcmVubGVmdHN1cGVyaW9yIiwicGFyZW5yaWdodHN1cGVyaW9yIiwidHdvZG90ZW5sZWFkZXIiLCJvbmVkb3RlbmxlYWRlciIsImNvbW1hIiwiaHlwaGVuIiwicGVyaW9kIiwiZnJhY3Rpb24iLCJ6ZXJvb2xkc3R5bGUiLCJvbmVvbGRzdHlsZSIsInR3b29sZHN0eWxlIiwidGhyZWVvbGRzdHlsZSIsImZvdXJvbGRzdHlsZSIsImZpdmVvbGRzdHlsZSIsInNpeG9sZHN0eWxlIiwic2V2ZW5vbGRzdHlsZSIsImVpZ2h0b2xkc3R5bGUiLCJuaW5lb2xkc3R5bGUiLCJjb2xvbiIsInNlbWljb2xvbiIsIiIsInRocmVlcXVhcnRlcnNlbWRhc2giLCIiLCJxdWVzdGlvbnNtYWxsIiwiIiwiIiwiIiwiIiwiRXRoc21hbGwiLCIiLCIiLCJvbmVxdWFydGVyIiwib25laGFsZiIsInRocmVlcXVhcnRlcnMiLCJvbmVlaWdodGgiLCJ0aHJlZWVpZ2h0aHMiLCJmaXZlZWlnaHRocyIsInNldmVuZWlnaHRocyIsIm9uZXRoaXJkIiwidHdvdGhpcmRzIiwiIiwiIiwiIiwiIiwiIiwiIiwiZmYiLCJmaSIsImZsIiwiZmZpIiwiZmZsIiwicGFyZW5sZWZ0aW5mZXJpb3IiLCIiLCJwYXJlbnJpZ2h0aW5mZXJpb3IiLCJDaXJjdW1mbGV4c21hbGwiLCJoeXBoZW5pbmZlcmlvciIsIkdyYXZlc21hbGwiLCJBc21hbGwiLCJCc21hbGwiLCJDc21hbGwiLCJEc21hbGwiLCJFc21hbGwiLCJGc21hbGwiLCJHc21hbGwiLCJIc21hbGwiLCJJc21hbGwiLCJKc21hbGwiLCJLc21hbGwiLCJMc21hbGwiLCJNc21hbGwiLCJOc21hbGwiLCJPc21hbGwiLCJQc21hbGwiLCJRc21hbGwiLCJSc21hbGwiLCJTc21hbGwiLCJUc21hbGwiLCJVc21hbGwiLCJWc21hbGwiLCJXc21hbGwiLCJYc21hbGwiLCJZc21hbGwiLCJac21hbGwiLCJjb2xvbm1vbmV0YXJ5Iiwib25lZml0dGVkIiwicnVwaWFoIiwiVGlsZGVzbWFsbCIsIiIsIiIsImFzdXBlcmlvciIsImNlbnRzdXBlcmlvciIsIiIsIiIsIiIsIiIsIkFhY3V0ZXNtYWxsIiwiQWdyYXZlc21hbGwiLCJBY2lyY3VtZmxleHNtYWxsIiwiQWRpZXJlc2lzc21hbGwiLCJBdGlsZGVzbWFsbCIsIkFyaW5nc21hbGwiLCJDY2VkaWxsYXNtYWxsIiwiRWFjdXRlc21hbGwiLCJFZ3JhdmVzbWFsbCIsIkVjaXJjdW1mbGV4c21hbGwiLCJFZGllcmVzaXNzbWFsbCIsIklhY3V0ZXNtYWxsIiwiSWdyYXZlc21hbGwiLCJJY2lyY3VtZmxleHNtYWxsIiwiSWRpZXJlc2lzc21hbGwiLCJOdGlsZGVzbWFsbCIsIk9hY3V0ZXNtYWxsIiwiT2dyYXZlc21hbGwiLCJPY2lyY3VtZmxleHNtYWxsIiwiT2RpZXJlc2lzc21hbGwiLCJPdGlsZGVzbWFsbCIsIlVhY3V0ZXNtYWxsIiwiVWdyYXZlc21hbGwiLCJVY2lyY3VtZmxleHNtYWxsIiwiVWRpZXJlc2lzc21hbGwiLCIiLCJlaWdodHN1cGVyaW9yIiwiZm91cmluZmVyaW9yIiwidGhyZWVpbmZlcmlvciIsInNpeGluZmVyaW9yIiwiZWlnaHRpbmZlcmlvciIsInNldmVuaW5mZXJpb3IiLCJTY2Fyb25zbWFsbCIsIiIsImNlbnRpbmZlcmlvciIsInR3b2luZmVyaW9yIiwiIiwiRGllcmVzaXNzbWFsbCIsIiIsIkNhcm9uc21hbGwiLCJvc3VwZXJpb3IiLCJmaXZlaW5mZXJpb3IiLCIiLCJjb21tYWluZmVyaW9yIiwicGVyaW9kaW5mZXJpb3IiLCJZYWN1dGVzbWFsbCIsIiIsImRvbGxhcmluZmVyaW9yIiwiIiwiIiwiVGhvcm5zbWFsbCIsIiIsIm5pbmVpbmZlcmlvciIsInplcm9pbmZlcmlvciIsIlpjYXJvbnNtYWxsIiwiQUVzbWFsbCIsIk9zbGFzaHNtYWxsIiwicXVlc3Rpb25kb3duc21hbGwiLCJvbmVpbmZlcmlvciIsIkxzbGFzaHNtYWxsIiwiIiwiIiwiIiwiIiwiIiwiIiwiQ2VkaWxsYXNtYWxsIiwiIiwiIiwiIiwiIiwiIiwiT0VzbWFsbCIsImZpZ3VyZWRhc2giLCJoeXBoZW5zdXBlcmlvciIsIiIsIiIsIiIsIiIsImV4Y2xhbWRvd25zbWFsbCIsIiIsIllkaWVyZXNpc3NtYWxsIiwiIiwib25lc3VwZXJpb3IiLCJ0d29zdXBlcmlvciIsInRocmVlc3VwZXJpb3IiLCJmb3Vyc3VwZXJpb3IiLCJmaXZlc3VwZXJpb3IiLCJzaXhzdXBlcmlvciIsInNldmVuc3VwZXJpb3IiLCJuaW5lc3VwZXJpb3IiLCJ6ZXJvc3VwZXJpb3IiLCIiLCJlc3VwZXJpb3IiLCJyc3VwZXJpb3IiLCJ0c3VwZXJpb3IiLCIiLCIiLCJpc3VwZXJpb3IiLCJzc3VwZXJpb3IiLCJkc3VwZXJpb3IiLCIiLCIiLCIiLCIiLCIiLCJsc3VwZXJpb3IiLCJPZ29uZWtzbWFsbCIsIkJyZXZlc21hbGwiLCJNYWNyb25zbWFsbCIsImJzdXBlcmlvciIsIm5zdXBlcmlvciIsIm1zdXBlcmlvciIsImNvbW1hc3VwZXJpb3IiLCJwZXJpb2RzdXBlcmlvciIsIkRvdGFjY2VudHNtYWxsIiwiUmluZ3NtYWxsIiwiIiwiIiwiIiwiIl0sZGk9WyIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJzcGFjZSIsImV4Y2xhbSIsInF1b3RlZGJsIiwibnVtYmVyc2lnbiIsImRvbGxhciIsInBlcmNlbnQiLCJhbXBlcnNhbmQiLCJxdW90ZXNpbmdsZSIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwiZ3JhdmUiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsImJyYWNlbGVmdCIsImJhciIsImJyYWNlcmlnaHQiLCJhc2NpaXRpbGRlIiwiIiwiQWRpZXJlc2lzIiwiQXJpbmciLCJDY2VkaWxsYSIsIkVhY3V0ZSIsIk50aWxkZSIsIk9kaWVyZXNpcyIsIlVkaWVyZXNpcyIsImFhY3V0ZSIsImFncmF2ZSIsImFjaXJjdW1mbGV4IiwiYWRpZXJlc2lzIiwiYXRpbGRlIiwiYXJpbmciLCJjY2VkaWxsYSIsImVhY3V0ZSIsImVncmF2ZSIsImVjaXJjdW1mbGV4IiwiZWRpZXJlc2lzIiwiaWFjdXRlIiwiaWdyYXZlIiwiaWNpcmN1bWZsZXgiLCJpZGllcmVzaXMiLCJudGlsZGUiLCJvYWN1dGUiLCJvZ3JhdmUiLCJvY2lyY3VtZmxleCIsIm9kaWVyZXNpcyIsIm90aWxkZSIsInVhY3V0ZSIsInVncmF2ZSIsInVjaXJjdW1mbGV4IiwidWRpZXJlc2lzIiwiZGFnZ2VyIiwiZGVncmVlIiwiY2VudCIsInN0ZXJsaW5nIiwic2VjdGlvbiIsImJ1bGxldCIsInBhcmFncmFwaCIsImdlcm1hbmRibHMiLCJyZWdpc3RlcmVkIiwiY29weXJpZ2h0IiwidHJhZGVtYXJrIiwiYWN1dGUiLCJkaWVyZXNpcyIsIm5vdGVxdWFsIiwiQUUiLCJPc2xhc2giLCJpbmZpbml0eSIsInBsdXNtaW51cyIsImxlc3NlcXVhbCIsImdyZWF0ZXJlcXVhbCIsInllbiIsIm11IiwicGFydGlhbGRpZmYiLCJzdW1tYXRpb24iLCJwcm9kdWN0IiwicGkiLCJpbnRlZ3JhbCIsIm9yZGZlbWluaW5lIiwib3JkbWFzY3VsaW5lIiwiT21lZ2EiLCJhZSIsIm9zbGFzaCIsInF1ZXN0aW9uZG93biIsImV4Y2xhbWRvd24iLCJsb2dpY2Fsbm90IiwicmFkaWNhbCIsImZsb3JpbiIsImFwcHJveGVxdWFsIiwiRGVsdGEiLCJndWlsbGVtb3RsZWZ0IiwiZ3VpbGxlbW90cmlnaHQiLCJlbGxpcHNpcyIsInNwYWNlIiwiQWdyYXZlIiwiQXRpbGRlIiwiT3RpbGRlIiwiT0UiLCJvZSIsImVuZGFzaCIsImVtZGFzaCIsInF1b3RlZGJsbGVmdCIsInF1b3RlZGJscmlnaHQiLCJxdW90ZWxlZnQiLCJxdW90ZXJpZ2h0IiwiZGl2aWRlIiwibG96ZW5nZSIsInlkaWVyZXNpcyIsIllkaWVyZXNpcyIsImZyYWN0aW9uIiwiY3VycmVuY3kiLCJndWlsc2luZ2xsZWZ0IiwiZ3VpbHNpbmdscmlnaHQiLCJmaSIsImZsIiwiZGFnZ2VyZGJsIiwicGVyaW9kY2VudGVyZWQiLCJxdW90ZXNpbmdsYmFzZSIsInF1b3RlZGJsYmFzZSIsInBlcnRob3VzYW5kIiwiQWNpcmN1bWZsZXgiLCJFY2lyY3VtZmxleCIsIkFhY3V0ZSIsIkVkaWVyZXNpcyIsIkVncmF2ZSIsIklhY3V0ZSIsIkljaXJjdW1mbGV4IiwiSWRpZXJlc2lzIiwiSWdyYXZlIiwiT2FjdXRlIiwiT2NpcmN1bWZsZXgiLCJhcHBsZSIsIk9ncmF2ZSIsIlVhY3V0ZSIsIlVjaXJjdW1mbGV4IiwiVWdyYXZlIiwiZG90bGVzc2kiLCJjaXJjdW1mbGV4IiwidGlsZGUiLCJtYWNyb24iLCJicmV2ZSIsImRvdGFjY2VudCIsInJpbmciLCJjZWRpbGxhIiwiaHVuZ2FydW1sYXV0Iiwib2dvbmVrIiwiY2Fyb24iXSxmaT1bIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsInNwYWNlIiwiZXhjbGFtIiwicXVvdGVkYmwiLCJudW1iZXJzaWduIiwiZG9sbGFyIiwicGVyY2VudCIsImFtcGVyc2FuZCIsInF1b3RlcmlnaHQiLCJwYXJlbmxlZnQiLCJwYXJlbnJpZ2h0IiwiYXN0ZXJpc2siLCJwbHVzIiwiY29tbWEiLCJoeXBoZW4iLCJwZXJpb2QiLCJzbGFzaCIsInplcm8iLCJvbmUiLCJ0d28iLCJ0aHJlZSIsImZvdXIiLCJmaXZlIiwic2l4Iiwic2V2ZW4iLCJlaWdodCIsIm5pbmUiLCJjb2xvbiIsInNlbWljb2xvbiIsImxlc3MiLCJlcXVhbCIsImdyZWF0ZXIiLCJxdWVzdGlvbiIsImF0IiwiQSIsIkIiLCJDIiwiRCIsIkUiLCJGIiwiRyIsIkgiLCJJIiwiSiIsIksiLCJMIiwiTSIsIk4iLCJPIiwiUCIsIlEiLCJSIiwiUyIsIlQiLCJVIiwiViIsIlciLCJYIiwiWSIsIloiLCJicmFja2V0bGVmdCIsImJhY2tzbGFzaCIsImJyYWNrZXRyaWdodCIsImFzY2lpY2lyY3VtIiwidW5kZXJzY29yZSIsInF1b3RlbGVmdCIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiYnJhY2VsZWZ0IiwiYmFyIiwiYnJhY2VyaWdodCIsImFzY2lpdGlsZGUiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJleGNsYW1kb3duIiwiY2VudCIsInN0ZXJsaW5nIiwiZnJhY3Rpb24iLCJ5ZW4iLCJmbG9yaW4iLCJzZWN0aW9uIiwiY3VycmVuY3kiLCJxdW90ZXNpbmdsZSIsInF1b3RlZGJsbGVmdCIsImd1aWxsZW1vdGxlZnQiLCJndWlsc2luZ2xsZWZ0IiwiZ3VpbHNpbmdscmlnaHQiLCJmaSIsImZsIiwiIiwiZW5kYXNoIiwiZGFnZ2VyIiwiZGFnZ2VyZGJsIiwicGVyaW9kY2VudGVyZWQiLCIiLCJwYXJhZ3JhcGgiLCJidWxsZXQiLCJxdW90ZXNpbmdsYmFzZSIsInF1b3RlZGJsYmFzZSIsInF1b3RlZGJscmlnaHQiLCJndWlsbGVtb3RyaWdodCIsImVsbGlwc2lzIiwicGVydGhvdXNhbmQiLCIiLCJxdWVzdGlvbmRvd24iLCIiLCJncmF2ZSIsImFjdXRlIiwiY2lyY3VtZmxleCIsInRpbGRlIiwibWFjcm9uIiwiYnJldmUiLCJkb3RhY2NlbnQiLCJkaWVyZXNpcyIsIiIsInJpbmciLCJjZWRpbGxhIiwiIiwiaHVuZ2FydW1sYXV0Iiwib2dvbmVrIiwiY2Fyb24iLCJlbWRhc2giLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJBRSIsIiIsIm9yZGZlbWluaW5lIiwiIiwiIiwiIiwiIiwiTHNsYXNoIiwiT3NsYXNoIiwiT0UiLCJvcmRtYXNjdWxpbmUiLCIiLCIiLCIiLCIiLCIiLCJhZSIsIiIsIiIsIiIsImRvdGxlc3NpIiwiIiwiIiwibHNsYXNoIiwib3NsYXNoIiwib2UiLCJnZXJtYW5kYmxzIiwiIiwiIiwiIiwiIl0scGk9WyIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJzcGFjZSIsImV4Y2xhbSIsInF1b3RlZGJsIiwibnVtYmVyc2lnbiIsImRvbGxhciIsInBlcmNlbnQiLCJhbXBlcnNhbmQiLCJxdW90ZXNpbmdsZSIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwiZ3JhdmUiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsImJyYWNlbGVmdCIsImJhciIsImJyYWNlcmlnaHQiLCJhc2NpaXRpbGRlIiwiYnVsbGV0IiwiRXVybyIsImJ1bGxldCIsInF1b3Rlc2luZ2xiYXNlIiwiZmxvcmluIiwicXVvdGVkYmxiYXNlIiwiZWxsaXBzaXMiLCJkYWdnZXIiLCJkYWdnZXJkYmwiLCJjaXJjdW1mbGV4IiwicGVydGhvdXNhbmQiLCJTY2Fyb24iLCJndWlsc2luZ2xsZWZ0IiwiT0UiLCJidWxsZXQiLCJaY2Fyb24iLCJidWxsZXQiLCJidWxsZXQiLCJxdW90ZWxlZnQiLCJxdW90ZXJpZ2h0IiwicXVvdGVkYmxsZWZ0IiwicXVvdGVkYmxyaWdodCIsImJ1bGxldCIsImVuZGFzaCIsImVtZGFzaCIsInRpbGRlIiwidHJhZGVtYXJrIiwic2Nhcm9uIiwiZ3VpbHNpbmdscmlnaHQiLCJvZSIsImJ1bGxldCIsInpjYXJvbiIsIllkaWVyZXNpcyIsInNwYWNlIiwiZXhjbGFtZG93biIsImNlbnQiLCJzdGVybGluZyIsImN1cnJlbmN5IiwieWVuIiwiYnJva2VuYmFyIiwic2VjdGlvbiIsImRpZXJlc2lzIiwiY29weXJpZ2h0Iiwib3JkZmVtaW5pbmUiLCJndWlsbGVtb3RsZWZ0IiwibG9naWNhbG5vdCIsImh5cGhlbiIsInJlZ2lzdGVyZWQiLCJtYWNyb24iLCJkZWdyZWUiLCJwbHVzbWludXMiLCJ0d29zdXBlcmlvciIsInRocmVlc3VwZXJpb3IiLCJhY3V0ZSIsIm11IiwicGFyYWdyYXBoIiwicGVyaW9kY2VudGVyZWQiLCJjZWRpbGxhIiwib25lc3VwZXJpb3IiLCJvcmRtYXNjdWxpbmUiLCJndWlsbGVtb3RyaWdodCIsIm9uZXF1YXJ0ZXIiLCJvbmVoYWxmIiwidGhyZWVxdWFydGVycyIsInF1ZXN0aW9uZG93biIsIkFncmF2ZSIsIkFhY3V0ZSIsIkFjaXJjdW1mbGV4IiwiQXRpbGRlIiwiQWRpZXJlc2lzIiwiQXJpbmciLCJBRSIsIkNjZWRpbGxhIiwiRWdyYXZlIiwiRWFjdXRlIiwiRWNpcmN1bWZsZXgiLCJFZGllcmVzaXMiLCJJZ3JhdmUiLCJJYWN1dGUiLCJJY2lyY3VtZmxleCIsIklkaWVyZXNpcyIsIkV0aCIsIk50aWxkZSIsIk9ncmF2ZSIsIk9hY3V0ZSIsIk9jaXJjdW1mbGV4IiwiT3RpbGRlIiwiT2RpZXJlc2lzIiwibXVsdGlwbHkiLCJPc2xhc2giLCJVZ3JhdmUiLCJVYWN1dGUiLCJVY2lyY3VtZmxleCIsIlVkaWVyZXNpcyIsIllhY3V0ZSIsIlRob3JuIiwiZ2VybWFuZGJscyIsImFncmF2ZSIsImFhY3V0ZSIsImFjaXJjdW1mbGV4IiwiYXRpbGRlIiwiYWRpZXJlc2lzIiwiYXJpbmciLCJhZSIsImNjZWRpbGxhIiwiZWdyYXZlIiwiZWFjdXRlIiwiZWNpcmN1bWZsZXgiLCJlZGllcmVzaXMiLCJpZ3JhdmUiLCJpYWN1dGUiLCJpY2lyY3VtZmxleCIsImlkaWVyZXNpcyIsImV0aCIsIm50aWxkZSIsIm9ncmF2ZSIsIm9hY3V0ZSIsIm9jaXJjdW1mbGV4Iiwib3RpbGRlIiwib2RpZXJlc2lzIiwiZGl2aWRlIiwib3NsYXNoIiwidWdyYXZlIiwidWFjdXRlIiwidWNpcmN1bWZsZXgiLCJ1ZGllcmVzaXMiLCJ5YWN1dGUiLCJ0aG9ybiIsInlkaWVyZXNpcyJdLG1pPVsiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwiIiwic3BhY2UiLCJleGNsYW0iLCJ1bml2ZXJzYWwiLCJudW1iZXJzaWduIiwiZXhpc3RlbnRpYWwiLCJwZXJjZW50IiwiYW1wZXJzYW5kIiwic3VjaHRoYXQiLCJwYXJlbmxlZnQiLCJwYXJlbnJpZ2h0IiwiYXN0ZXJpc2ttYXRoIiwicGx1cyIsImNvbW1hIiwibWludXMiLCJwZXJpb2QiLCJzbGFzaCIsInplcm8iLCJvbmUiLCJ0d28iLCJ0aHJlZSIsImZvdXIiLCJmaXZlIiwic2l4Iiwic2V2ZW4iLCJlaWdodCIsIm5pbmUiLCJjb2xvbiIsInNlbWljb2xvbiIsImxlc3MiLCJlcXVhbCIsImdyZWF0ZXIiLCJxdWVzdGlvbiIsImNvbmdydWVudCIsIkFscGhhIiwiQmV0YSIsIkNoaSIsIkRlbHRhIiwiRXBzaWxvbiIsIlBoaSIsIkdhbW1hIiwiRXRhIiwiSW90YSIsInRoZXRhMSIsIkthcHBhIiwiTGFtYmRhIiwiTXUiLCJOdSIsIk9taWNyb24iLCJQaSIsIlRoZXRhIiwiUmhvIiwiU2lnbWEiLCJUYXUiLCJVcHNpbG9uIiwic2lnbWExIiwiT21lZ2EiLCJYaSIsIlBzaSIsIlpldGEiLCJicmFja2V0bGVmdCIsInRoZXJlZm9yZSIsImJyYWNrZXRyaWdodCIsInBlcnBlbmRpY3VsYXIiLCJ1bmRlcnNjb3JlIiwicmFkaWNhbGV4IiwiYWxwaGEiLCJiZXRhIiwiY2hpIiwiZGVsdGEiLCJlcHNpbG9uIiwicGhpIiwiZ2FtbWEiLCJldGEiLCJpb3RhIiwicGhpMSIsImthcHBhIiwibGFtYmRhIiwibXUiLCJudSIsIm9taWNyb24iLCJwaSIsInRoZXRhIiwicmhvIiwic2lnbWEiLCJ0YXUiLCJ1cHNpbG9uIiwib21lZ2ExIiwib21lZ2EiLCJ4aSIsInBzaSIsInpldGEiLCJicmFjZWxlZnQiLCJiYXIiLCJicmFjZXJpZ2h0Iiwic2ltaWxhciIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIiIsIkV1cm8iLCJVcHNpbG9uMSIsIm1pbnV0ZSIsImxlc3NlcXVhbCIsImZyYWN0aW9uIiwiaW5maW5pdHkiLCJmbG9yaW4iLCJjbHViIiwiZGlhbW9uZCIsImhlYXJ0Iiwic3BhZGUiLCJhcnJvd2JvdGgiLCJhcnJvd2xlZnQiLCJhcnJvd3VwIiwiYXJyb3dyaWdodCIsImFycm93ZG93biIsImRlZ3JlZSIsInBsdXNtaW51cyIsInNlY29uZCIsImdyZWF0ZXJlcXVhbCIsIm11bHRpcGx5IiwicHJvcG9ydGlvbmFsIiwicGFydGlhbGRpZmYiLCJidWxsZXQiLCJkaXZpZGUiLCJub3RlcXVhbCIsImVxdWl2YWxlbmNlIiwiYXBwcm94ZXF1YWwiLCJlbGxpcHNpcyIsImFycm93dmVydGV4IiwiYXJyb3dob3JpemV4IiwiY2FycmlhZ2VyZXR1cm4iLCJhbGVwaCIsIklmcmFrdHVyIiwiUmZyYWt0dXIiLCJ3ZWllcnN0cmFzcyIsImNpcmNsZW11bHRpcGx5IiwiY2lyY2xlcGx1cyIsImVtcHR5c2V0IiwiaW50ZXJzZWN0aW9uIiwidW5pb24iLCJwcm9wZXJzdXBlcnNldCIsInJlZmxleHN1cGVyc2V0Iiwibm90c3Vic2V0IiwicHJvcGVyc3Vic2V0IiwicmVmbGV4c3Vic2V0IiwiZWxlbWVudCIsIm5vdGVsZW1lbnQiLCJhbmdsZSIsImdyYWRpZW50IiwicmVnaXN0ZXJzZXJpZiIsImNvcHlyaWdodHNlcmlmIiwidHJhZGVtYXJrc2VyaWYiLCJwcm9kdWN0IiwicmFkaWNhbCIsImRvdG1hdGgiLCJsb2dpY2Fsbm90IiwibG9naWNhbGFuZCIsImxvZ2ljYWxvciIsImFycm93ZGJsYm90aCIsImFycm93ZGJsbGVmdCIsImFycm93ZGJsdXAiLCJhcnJvd2RibHJpZ2h0IiwiYXJyb3dkYmxkb3duIiwibG96ZW5nZSIsImFuZ2xlbGVmdCIsInJlZ2lzdGVyc2FucyIsImNvcHlyaWdodHNhbnMiLCJ0cmFkZW1hcmtzYW5zIiwic3VtbWF0aW9uIiwicGFyZW5sZWZ0dHAiLCJwYXJlbmxlZnRleCIsInBhcmVubGVmdGJ0IiwiYnJhY2tldGxlZnR0cCIsImJyYWNrZXRsZWZ0ZXgiLCJicmFja2V0bGVmdGJ0IiwiYnJhY2VsZWZ0dHAiLCJicmFjZWxlZnRtaWQiLCJicmFjZWxlZnRidCIsImJyYWNlZXgiLCIiLCJhbmdsZXJpZ2h0IiwiaW50ZWdyYWwiLCJpbnRlZ3JhbHRwIiwiaW50ZWdyYWxleCIsImludGVncmFsYnQiLCJwYXJlbnJpZ2h0dHAiLCJwYXJlbnJpZ2h0ZXgiLCJwYXJlbnJpZ2h0YnQiLCJicmFja2V0cmlnaHR0cCIsImJyYWNrZXRyaWdodGV4IiwiYnJhY2tldHJpZ2h0YnQiLCJicmFjZXJpZ2h0dHAiLCJicmFjZXJpZ2h0bWlkIiwiYnJhY2VyaWdodGJ0IiwiIl0seWk9WyIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJzcGFjZSIsImExIiwiYTIiLCJhMjAyIiwiYTMiLCJhNCIsImE1IiwiYTExOSIsImExMTgiLCJhMTE3IiwiYTExIiwiYTEyIiwiYTEzIiwiYTE0IiwiYTE1IiwiYTE2IiwiYTEwNSIsImExNyIsImExOCIsImExOSIsImEyMCIsImEyMSIsImEyMiIsImEyMyIsImEyNCIsImEyNSIsImEyNiIsImEyNyIsImEyOCIsImE2IiwiYTciLCJhOCIsImE5IiwiYTEwIiwiYTI5IiwiYTMwIiwiYTMxIiwiYTMyIiwiYTMzIiwiYTM0IiwiYTM1IiwiYTM2IiwiYTM3IiwiYTM4IiwiYTM5IiwiYTQwIiwiYTQxIiwiYTQyIiwiYTQzIiwiYTQ0IiwiYTQ1IiwiYTQ2IiwiYTQ3IiwiYTQ4IiwiYTQ5IiwiYTUwIiwiYTUxIiwiYTUyIiwiYTUzIiwiYTU0IiwiYTU1IiwiYTU2IiwiYTU3IiwiYTU4IiwiYTU5IiwiYTYwIiwiYTYxIiwiYTYyIiwiYTYzIiwiYTY0IiwiYTY1IiwiYTY2IiwiYTY3IiwiYTY4IiwiYTY5IiwiYTcwIiwiYTcxIiwiYTcyIiwiYTczIiwiYTc0IiwiYTIwMyIsImE3NSIsImEyMDQiLCJhNzYiLCJhNzciLCJhNzgiLCJhNzkiLCJhODEiLCJhODIiLCJhODMiLCJhODQiLCJhOTciLCJhOTgiLCJhOTkiLCJhMTAwIiwiIiwiYTg5IiwiYTkwIiwiYTkzIiwiYTk0IiwiYTkxIiwiYTkyIiwiYTIwNSIsImE4NSIsImEyMDYiLCJhODYiLCJhODciLCJhODgiLCJhOTUiLCJhOTYiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCIiLCJhMTAxIiwiYTEwMiIsImExMDMiLCJhMTA0IiwiYTEwNiIsImExMDciLCJhMTA4IiwiYTExMiIsImExMTEiLCJhMTEwIiwiYTEwOSIsImExMjAiLCJhMTIxIiwiYTEyMiIsImExMjMiLCJhMTI0IiwiYTEyNSIsImExMjYiLCJhMTI3IiwiYTEyOCIsImExMjkiLCJhMTMwIiwiYTEzMSIsImExMzIiLCJhMTMzIiwiYTEzNCIsImExMzUiLCJhMTM2IiwiYTEzNyIsImExMzgiLCJhMTM5IiwiYTE0MCIsImExNDEiLCJhMTQyIiwiYTE0MyIsImExNDQiLCJhMTQ1IiwiYTE0NiIsImExNDciLCJhMTQ4IiwiYTE0OSIsImExNTAiLCJhMTUxIiwiYTE1MiIsImExNTMiLCJhMTU0IiwiYTE1NSIsImExNTYiLCJhMTU3IiwiYTE1OCIsImExNTkiLCJhMTYwIiwiYTE2MSIsImExNjMiLCJhMTY0IiwiYTE5NiIsImExNjUiLCJhMTkyIiwiYTE2NiIsImExNjciLCJhMTY4IiwiYTE2OSIsImExNzAiLCJhMTcxIiwiYTE3MiIsImExNzMiLCJhMTYyIiwiYTE3NCIsImExNzUiLCJhMTc2IiwiYTE3NyIsImExNzgiLCJhMTc5IiwiYTE5MyIsImExODAiLCJhMTk5IiwiYTE4MSIsImEyMDAiLCJhMTgyIiwiIiwiYTIwMSIsImExODMiLCJhMTg0IiwiYTE5NyIsImExODUiLCJhMTk0IiwiYTE5OCIsImExODYiLCJhMTk1IiwiYTE4NyIsImExODgiLCJhMTg5IiwiYTE5MCIsImExOTEiLCIiXTtmdW5jdGlvbiBnZXRFbmNvZGluZyhlKXtzd2l0Y2goZSl7Y2FzZSJXaW5BbnNpRW5jb2RpbmciOnJldHVybiBwaTtjYXNlIlN0YW5kYXJkRW5jb2RpbmciOnJldHVybiBmaTtjYXNlIk1hY1JvbWFuRW5jb2RpbmciOnJldHVybiBkaTtjYXNlIlN5bWJvbFNldEVuY29kaW5nIjpyZXR1cm4gbWk7Y2FzZSJaYXBmRGluZ2JhdHNFbmNvZGluZyI6cmV0dXJuIHlpO2Nhc2UiRXhwZXJ0RW5jb2RpbmciOnJldHVybiBFaTtjYXNlIk1hY0V4cGVydEVuY29kaW5nIjpyZXR1cm4gdWk7ZGVmYXVsdDpyZXR1cm4gbnVsbH19Y29uc3Qgd2k9WyIubm90ZGVmIiwic3BhY2UiLCJleGNsYW0iLCJxdW90ZWRibCIsIm51bWJlcnNpZ24iLCJkb2xsYXIiLCJwZXJjZW50IiwiYW1wZXJzYW5kIiwicXVvdGVyaWdodCIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwicXVvdGVsZWZ0IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJicmFjZWxlZnQiLCJiYXIiLCJicmFjZXJpZ2h0IiwiYXNjaWl0aWxkZSIsImV4Y2xhbWRvd24iLCJjZW50Iiwic3RlcmxpbmciLCJmcmFjdGlvbiIsInllbiIsImZsb3JpbiIsInNlY3Rpb24iLCJjdXJyZW5jeSIsInF1b3Rlc2luZ2xlIiwicXVvdGVkYmxsZWZ0IiwiZ3VpbGxlbW90bGVmdCIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCJlbmRhc2giLCJkYWdnZXIiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsInBhcmFncmFwaCIsImJ1bGxldCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicXVvdGVkYmxyaWdodCIsImd1aWxsZW1vdHJpZ2h0IiwiZWxsaXBzaXMiLCJwZXJ0aG91c2FuZCIsInF1ZXN0aW9uZG93biIsImdyYXZlIiwiYWN1dGUiLCJjaXJjdW1mbGV4IiwidGlsZGUiLCJtYWNyb24iLCJicmV2ZSIsImRvdGFjY2VudCIsImRpZXJlc2lzIiwicmluZyIsImNlZGlsbGEiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiIsImVtZGFzaCIsIkFFIiwib3JkZmVtaW5pbmUiLCJMc2xhc2giLCJPc2xhc2giLCJPRSIsIm9yZG1hc2N1bGluZSIsImFlIiwiZG90bGVzc2kiLCJsc2xhc2giLCJvc2xhc2giLCJvZSIsImdlcm1hbmRibHMiLCJvbmVzdXBlcmlvciIsImxvZ2ljYWxub3QiLCJtdSIsInRyYWRlbWFyayIsIkV0aCIsIm9uZWhhbGYiLCJwbHVzbWludXMiLCJUaG9ybiIsIm9uZXF1YXJ0ZXIiLCJkaXZpZGUiLCJicm9rZW5iYXIiLCJkZWdyZWUiLCJ0aG9ybiIsInRocmVlcXVhcnRlcnMiLCJ0d29zdXBlcmlvciIsInJlZ2lzdGVyZWQiLCJtaW51cyIsImV0aCIsIm11bHRpcGx5IiwidGhyZWVzdXBlcmlvciIsImNvcHlyaWdodCIsIkFhY3V0ZSIsIkFjaXJjdW1mbGV4IiwiQWRpZXJlc2lzIiwiQWdyYXZlIiwiQXJpbmciLCJBdGlsZGUiLCJDY2VkaWxsYSIsIkVhY3V0ZSIsIkVjaXJjdW1mbGV4IiwiRWRpZXJlc2lzIiwiRWdyYXZlIiwiSWFjdXRlIiwiSWNpcmN1bWZsZXgiLCJJZGllcmVzaXMiLCJJZ3JhdmUiLCJOdGlsZGUiLCJPYWN1dGUiLCJPY2lyY3VtZmxleCIsIk9kaWVyZXNpcyIsIk9ncmF2ZSIsIk90aWxkZSIsIlNjYXJvbiIsIlVhY3V0ZSIsIlVjaXJjdW1mbGV4IiwiVWRpZXJlc2lzIiwiVWdyYXZlIiwiWWFjdXRlIiwiWWRpZXJlc2lzIiwiWmNhcm9uIiwiYWFjdXRlIiwiYWNpcmN1bWZsZXgiLCJhZGllcmVzaXMiLCJhZ3JhdmUiLCJhcmluZyIsImF0aWxkZSIsImNjZWRpbGxhIiwiZWFjdXRlIiwiZWNpcmN1bWZsZXgiLCJlZGllcmVzaXMiLCJlZ3JhdmUiLCJpYWN1dGUiLCJpY2lyY3VtZmxleCIsImlkaWVyZXNpcyIsImlncmF2ZSIsIm50aWxkZSIsIm9hY3V0ZSIsIm9jaXJjdW1mbGV4Iiwib2RpZXJlc2lzIiwib2dyYXZlIiwib3RpbGRlIiwic2Nhcm9uIiwidWFjdXRlIiwidWNpcmN1bWZsZXgiLCJ1ZGllcmVzaXMiLCJ1Z3JhdmUiLCJ5YWN1dGUiLCJ5ZGllcmVzaXMiLCJ6Y2Fyb24iLCJleGNsYW1zbWFsbCIsIkh1bmdhcnVtbGF1dHNtYWxsIiwiZG9sbGFyb2xkc3R5bGUiLCJkb2xsYXJzdXBlcmlvciIsImFtcGVyc2FuZHNtYWxsIiwiQWN1dGVzbWFsbCIsInBhcmVubGVmdHN1cGVyaW9yIiwicGFyZW5yaWdodHN1cGVyaW9yIiwidHdvZG90ZW5sZWFkZXIiLCJvbmVkb3RlbmxlYWRlciIsInplcm9vbGRzdHlsZSIsIm9uZW9sZHN0eWxlIiwidHdvb2xkc3R5bGUiLCJ0aHJlZW9sZHN0eWxlIiwiZm91cm9sZHN0eWxlIiwiZml2ZW9sZHN0eWxlIiwic2l4b2xkc3R5bGUiLCJzZXZlbm9sZHN0eWxlIiwiZWlnaHRvbGRzdHlsZSIsIm5pbmVvbGRzdHlsZSIsImNvbW1hc3VwZXJpb3IiLCJ0aHJlZXF1YXJ0ZXJzZW1kYXNoIiwicGVyaW9kc3VwZXJpb3IiLCJxdWVzdGlvbnNtYWxsIiwiYXN1cGVyaW9yIiwiYnN1cGVyaW9yIiwiY2VudHN1cGVyaW9yIiwiZHN1cGVyaW9yIiwiZXN1cGVyaW9yIiwiaXN1cGVyaW9yIiwibHN1cGVyaW9yIiwibXN1cGVyaW9yIiwibnN1cGVyaW9yIiwib3N1cGVyaW9yIiwicnN1cGVyaW9yIiwic3N1cGVyaW9yIiwidHN1cGVyaW9yIiwiZmYiLCJmZmkiLCJmZmwiLCJwYXJlbmxlZnRpbmZlcmlvciIsInBhcmVucmlnaHRpbmZlcmlvciIsIkNpcmN1bWZsZXhzbWFsbCIsImh5cGhlbnN1cGVyaW9yIiwiR3JhdmVzbWFsbCIsIkFzbWFsbCIsIkJzbWFsbCIsIkNzbWFsbCIsIkRzbWFsbCIsIkVzbWFsbCIsIkZzbWFsbCIsIkdzbWFsbCIsIkhzbWFsbCIsIklzbWFsbCIsIkpzbWFsbCIsIktzbWFsbCIsIkxzbWFsbCIsIk1zbWFsbCIsIk5zbWFsbCIsIk9zbWFsbCIsIlBzbWFsbCIsIlFzbWFsbCIsIlJzbWFsbCIsIlNzbWFsbCIsIlRzbWFsbCIsIlVzbWFsbCIsIlZzbWFsbCIsIldzbWFsbCIsIlhzbWFsbCIsIllzbWFsbCIsIlpzbWFsbCIsImNvbG9ubW9uZXRhcnkiLCJvbmVmaXR0ZWQiLCJydXBpYWgiLCJUaWxkZXNtYWxsIiwiZXhjbGFtZG93bnNtYWxsIiwiY2VudG9sZHN0eWxlIiwiTHNsYXNoc21hbGwiLCJTY2Fyb25zbWFsbCIsIlpjYXJvbnNtYWxsIiwiRGllcmVzaXNzbWFsbCIsIkJyZXZlc21hbGwiLCJDYXJvbnNtYWxsIiwiRG90YWNjZW50c21hbGwiLCJNYWNyb25zbWFsbCIsImZpZ3VyZWRhc2giLCJoeXBoZW5pbmZlcmlvciIsIk9nb25la3NtYWxsIiwiUmluZ3NtYWxsIiwiQ2VkaWxsYXNtYWxsIiwicXVlc3Rpb25kb3duc21hbGwiLCJvbmVlaWdodGgiLCJ0aHJlZWVpZ2h0aHMiLCJmaXZlZWlnaHRocyIsInNldmVuZWlnaHRocyIsIm9uZXRoaXJkIiwidHdvdGhpcmRzIiwiemVyb3N1cGVyaW9yIiwiZm91cnN1cGVyaW9yIiwiZml2ZXN1cGVyaW9yIiwic2l4c3VwZXJpb3IiLCJzZXZlbnN1cGVyaW9yIiwiZWlnaHRzdXBlcmlvciIsIm5pbmVzdXBlcmlvciIsInplcm9pbmZlcmlvciIsIm9uZWluZmVyaW9yIiwidHdvaW5mZXJpb3IiLCJ0aHJlZWluZmVyaW9yIiwiZm91cmluZmVyaW9yIiwiZml2ZWluZmVyaW9yIiwic2l4aW5mZXJpb3IiLCJzZXZlbmluZmVyaW9yIiwiZWlnaHRpbmZlcmlvciIsIm5pbmVpbmZlcmlvciIsImNlbnRpbmZlcmlvciIsImRvbGxhcmluZmVyaW9yIiwicGVyaW9kaW5mZXJpb3IiLCJjb21tYWluZmVyaW9yIiwiQWdyYXZlc21hbGwiLCJBYWN1dGVzbWFsbCIsIkFjaXJjdW1mbGV4c21hbGwiLCJBdGlsZGVzbWFsbCIsIkFkaWVyZXNpc3NtYWxsIiwiQXJpbmdzbWFsbCIsIkFFc21hbGwiLCJDY2VkaWxsYXNtYWxsIiwiRWdyYXZlc21hbGwiLCJFYWN1dGVzbWFsbCIsIkVjaXJjdW1mbGV4c21hbGwiLCJFZGllcmVzaXNzbWFsbCIsIklncmF2ZXNtYWxsIiwiSWFjdXRlc21hbGwiLCJJY2lyY3VtZmxleHNtYWxsIiwiSWRpZXJlc2lzc21hbGwiLCJFdGhzbWFsbCIsIk50aWxkZXNtYWxsIiwiT2dyYXZlc21hbGwiLCJPYWN1dGVzbWFsbCIsIk9jaXJjdW1mbGV4c21hbGwiLCJPdGlsZGVzbWFsbCIsIk9kaWVyZXNpc3NtYWxsIiwiT0VzbWFsbCIsIk9zbGFzaHNtYWxsIiwiVWdyYXZlc21hbGwiLCJVYWN1dGVzbWFsbCIsIlVjaXJjdW1mbGV4c21hbGwiLCJVZGllcmVzaXNzbWFsbCIsIllhY3V0ZXNtYWxsIiwiVGhvcm5zbWFsbCIsIllkaWVyZXNpc3NtYWxsIiwiMDAxLjAwMCIsIjAwMS4wMDEiLCIwMDEuMDAyIiwiMDAxLjAwMyIsIkJsYWNrIiwiQm9sZCIsIkJvb2siLCJMaWdodCIsIk1lZGl1bSIsIlJlZ3VsYXIiLCJSb21hbiIsIlNlbWlib2xkIl0sYmk9MzkxLERpPVtudWxsLHtpZDoiaHN0ZW0iLG1pbjoyLHN0YWNrQ2xlYXJpbmc6ITAsc3RlbTohMH0sbnVsbCx7aWQ6InZzdGVtIixtaW46MixzdGFja0NsZWFyaW5nOiEwLHN0ZW06ITB9LHtpZDoidm1vdmV0byIsbWluOjEsc3RhY2tDbGVhcmluZzohMH0se2lkOiJybGluZXRvIixtaW46MixyZXNldFN0YWNrOiEwfSx7aWQ6ImhsaW5ldG8iLG1pbjoxLHJlc2V0U3RhY2s6ITB9LHtpZDoidmxpbmV0byIsbWluOjEscmVzZXRTdGFjazohMH0se2lkOiJycmN1cnZldG8iLG1pbjo2LHJlc2V0U3RhY2s6ITB9LG51bGwse2lkOiJjYWxsc3ViciIsbWluOjEsdW5kZWZTdGFjazohMH0se2lkOiJyZXR1cm4iLG1pbjowLHVuZGVmU3RhY2s6ITB9LG51bGwsbnVsbCx7aWQ6ImVuZGNoYXIiLG1pbjowLHN0YWNrQ2xlYXJpbmc6ITB9LG51bGwsbnVsbCxudWxsLHtpZDoiaHN0ZW1obSIsbWluOjIsc3RhY2tDbGVhcmluZzohMCxzdGVtOiEwfSx7aWQ6ImhpbnRtYXNrIixtaW46MCxzdGFja0NsZWFyaW5nOiEwfSx7aWQ6ImNudHJtYXNrIixtaW46MCxzdGFja0NsZWFyaW5nOiEwfSx7aWQ6InJtb3ZldG8iLG1pbjoyLHN0YWNrQ2xlYXJpbmc6ITB9LHtpZDoiaG1vdmV0byIsbWluOjEsc3RhY2tDbGVhcmluZzohMH0se2lkOiJ2c3RlbWhtIixtaW46MixzdGFja0NsZWFyaW5nOiEwLHN0ZW06ITB9LHtpZDoicmN1cnZlbGluZSIsbWluOjgscmVzZXRTdGFjazohMH0se2lkOiJybGluZWN1cnZlIixtaW46OCxyZXNldFN0YWNrOiEwfSx7aWQ6InZ2Y3VydmV0byIsbWluOjQscmVzZXRTdGFjazohMH0se2lkOiJoaGN1cnZldG8iLG1pbjo0LHJlc2V0U3RhY2s6ITB9LG51bGwse2lkOiJjYWxsZ3N1YnIiLG1pbjoxLHVuZGVmU3RhY2s6ITB9LHtpZDoidmhjdXJ2ZXRvIixtaW46NCxyZXNldFN0YWNrOiEwfSx7aWQ6Imh2Y3VydmV0byIsbWluOjQscmVzZXRTdGFjazohMH1dLEZpPVtudWxsLG51bGwsbnVsbCx7aWQ6ImFuZCIsbWluOjIsc3RhY2tEZWx0YTotMX0se2lkOiJvciIsbWluOjIsc3RhY2tEZWx0YTotMX0se2lkOiJub3QiLG1pbjoxLHN0YWNrRGVsdGE6MH0sbnVsbCxudWxsLG51bGwse2lkOiJhYnMiLG1pbjoxLHN0YWNrRGVsdGE6MH0se2lkOiJhZGQiLG1pbjoyLHN0YWNrRGVsdGE6LTEsc3RhY2tGbihlLHQpe2VbdC0yXT1lW3QtMl0rZVt0LTFdfX0se2lkOiJzdWIiLG1pbjoyLHN0YWNrRGVsdGE6LTEsc3RhY2tGbihlLHQpe2VbdC0yXT1lW3QtMl0tZVt0LTFdfX0se2lkOiJkaXYiLG1pbjoyLHN0YWNrRGVsdGE6LTEsc3RhY2tGbihlLHQpe2VbdC0yXT1lW3QtMl0vZVt0LTFdfX0sbnVsbCx7aWQ6Im5lZyIsbWluOjEsc3RhY2tEZWx0YTowLHN0YWNrRm4oZSx0KXtlW3QtMV09LWVbdC0xXX19LHtpZDoiZXEiLG1pbjoyLHN0YWNrRGVsdGE6LTF9LG51bGwsbnVsbCx7aWQ6ImRyb3AiLG1pbjoxLHN0YWNrRGVsdGE6LTF9LG51bGwse2lkOiJwdXQiLG1pbjoyLHN0YWNrRGVsdGE6LTJ9LHtpZDoiZ2V0IixtaW46MSxzdGFja0RlbHRhOjB9LHtpZDoiaWZlbHNlIixtaW46NCxzdGFja0RlbHRhOi0zfSx7aWQ6InJhbmRvbSIsbWluOjAsc3RhY2tEZWx0YToxfSx7aWQ6Im11bCIsbWluOjIsc3RhY2tEZWx0YTotMSxzdGFja0ZuKGUsdCl7ZVt0LTJdPWVbdC0yXSplW3QtMV19fSxudWxsLHtpZDoic3FydCIsbWluOjEsc3RhY2tEZWx0YTowfSx7aWQ6ImR1cCIsbWluOjEsc3RhY2tEZWx0YToxfSx7aWQ6ImV4Y2giLG1pbjoyLHN0YWNrRGVsdGE6MH0se2lkOiJpbmRleCIsbWluOjIsc3RhY2tEZWx0YTowfSx7aWQ6InJvbGwiLG1pbjozLHN0YWNrRGVsdGE6LTJ9LG51bGwsbnVsbCxudWxsLHtpZDoiaGZsZXgiLG1pbjo3LHJlc2V0U3RhY2s6ITB9LHtpZDoiZmxleCIsbWluOjEzLHJlc2V0U3RhY2s6ITB9LHtpZDoiaGZsZXgxIixtaW46OSxyZXNldFN0YWNrOiEwfSx7aWQ6ImZsZXgxIixtaW46MTEscmVzZXRTdGFjazohMH1dO2NsYXNzIENGRlBhcnNlcntjb25zdHJ1Y3RvcihlLHQsaSl7dGhpcy5ieXRlcz1lLmdldEJ5dGVzKCk7dGhpcy5wcm9wZXJ0aWVzPXQ7dGhpcy5zZWFjQW5hbHlzaXNFbmFibGVkPSEhaX1wYXJzZSgpe2NvbnN0IGU9dGhpcy5wcm9wZXJ0aWVzLHQ9bmV3IENGRjt0aGlzLmNmZj10O2NvbnN0IGk9dGhpcy5wYXJzZUhlYWRlcigpLGE9dGhpcy5wYXJzZUluZGV4KGkuZW5kUG9zKSxzPXRoaXMucGFyc2VJbmRleChhLmVuZFBvcykscj10aGlzLnBhcnNlSW5kZXgocy5lbmRQb3MpLG49dGhpcy5wYXJzZUluZGV4KHIuZW5kUG9zKSxvPXRoaXMucGFyc2VEaWN0KHMub2JqLmdldCgwKSksZz10aGlzLmNyZWF0ZURpY3QoQ0ZGVG9wRGljdCxvLHQuc3RyaW5ncyk7dC5oZWFkZXI9aS5vYmo7dC5uYW1lcz10aGlzLnBhcnNlTmFtZUluZGV4KGEub2JqKTt0LnN0cmluZ3M9dGhpcy5wYXJzZVN0cmluZ0luZGV4KHIub2JqKTt0LnRvcERpY3Q9Zzt0Lmdsb2JhbFN1YnJJbmRleD1uLm9iajt0aGlzLnBhcnNlUHJpdmF0ZURpY3QodC50b3BEaWN0KTt0LmlzQ0lERm9udD1nLmhhc05hbWUoIlJPUyIpO2NvbnN0IGM9Zy5nZXRCeU5hbWUoIkNoYXJTdHJpbmdzIiksQz10aGlzLnBhcnNlSW5kZXgoYykub2JqLGg9Zy5nZXRCeU5hbWUoIkZvbnRNYXRyaXgiKTtoJiYoZS5mb250TWF0cml4PWgpO2NvbnN0IGw9Zy5nZXRCeU5hbWUoIkZvbnRCQm94Iik7aWYobCl7ZS5hc2NlbnQ9TWF0aC5tYXgobFszXSxsWzFdKTtlLmRlc2NlbnQ9TWF0aC5taW4obFsxXSxsWzNdKTtlLmFzY2VudFNjYWxlZD0hMH1sZXQgUSxFO2lmKHQuaXNDSURGb250KXtjb25zdCBlPXRoaXMucGFyc2VJbmRleChnLmdldEJ5TmFtZSgiRkRBcnJheSIpKS5vYmo7Zm9yKGxldCBpPTAsYT1lLmNvdW50O2k8YTsrK2kpe2NvbnN0IGE9ZS5nZXQoaSkscz10aGlzLmNyZWF0ZURpY3QoQ0ZGVG9wRGljdCx0aGlzLnBhcnNlRGljdChhKSx0LnN0cmluZ3MpO3RoaXMucGFyc2VQcml2YXRlRGljdChzKTt0LmZkQXJyYXkucHVzaChzKX1FPW51bGw7UT10aGlzLnBhcnNlQ2hhcnNldHMoZy5nZXRCeU5hbWUoImNoYXJzZXQiKSxDLmNvdW50LHQuc3RyaW5ncywhMCk7dC5mZFNlbGVjdD10aGlzLnBhcnNlRkRTZWxlY3QoZy5nZXRCeU5hbWUoIkZEU2VsZWN0IiksQy5jb3VudCl9ZWxzZXtRPXRoaXMucGFyc2VDaGFyc2V0cyhnLmdldEJ5TmFtZSgiY2hhcnNldCIpLEMuY291bnQsdC5zdHJpbmdzLCExKTtFPXRoaXMucGFyc2VFbmNvZGluZyhnLmdldEJ5TmFtZSgiRW5jb2RpbmciKSxlLHQuc3RyaW5ncyxRLmNoYXJzZXQpfXQuY2hhcnNldD1RO3QuZW5jb2Rpbmc9RTtjb25zdCB1PXRoaXMucGFyc2VDaGFyU3RyaW5ncyh7Y2hhclN0cmluZ3M6Qyxsb2NhbFN1YnJJbmRleDpnLnByaXZhdGVEaWN0LnN1YnJzSW5kZXgsZ2xvYmFsU3VickluZGV4Om4ub2JqLGZkU2VsZWN0OnQuZmRTZWxlY3QsZmRBcnJheTp0LmZkQXJyYXkscHJpdmF0ZURpY3Q6Zy5wcml2YXRlRGljdH0pO3QuY2hhclN0cmluZ3M9dS5jaGFyU3RyaW5nczt0LnNlYWNzPXUuc2VhY3M7dC53aWR0aHM9dS53aWR0aHM7cmV0dXJuIHR9cGFyc2VIZWFkZXIoKXtsZXQgZT10aGlzLmJ5dGVzO2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IGk9MDtmb3IoO2k8dCYmMSE9PWVbaV07KSsraTtpZihpPj10KXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBDRkYgaGVhZGVyIik7aWYoMCE9PWkpe2luZm8oImNmZiBkYXRhIGlzIHNoaWZ0ZWQiKTtlPWUuc3ViYXJyYXkoaSk7dGhpcy5ieXRlcz1lfWNvbnN0IGE9ZVswXSxzPWVbMV0scj1lWzJdLG49ZVszXTtyZXR1cm57b2JqOm5ldyBDRkZIZWFkZXIoYSxzLHIsbiksZW5kUG9zOnJ9fXBhcnNlRGljdChlKXtsZXQgdD0wO2Z1bmN0aW9uIHBhcnNlT3BlcmFuZCgpe2xldCBpPWVbdCsrXTtpZigzMD09PWkpcmV0dXJuIGZ1bmN0aW9uIHBhcnNlRmxvYXRPcGVyYW5kKCl7bGV0IGk9IiI7Y29uc3QgYT0xNSxzPVsiMCIsIjEiLCIyIiwiMyIsIjQiLCI1IiwiNiIsIjciLCI4IiwiOSIsIi4iLCJFIiwiRS0iLG51bGwsIi0iXSxyPWUubGVuZ3RoO2Zvcig7dDxyOyl7Y29uc3Qgcj1lW3QrK10sbj1yPj40LG89MTUmcjtpZihuPT09YSlicmVhaztpKz1zW25dO2lmKG89PT1hKWJyZWFrO2krPXNbb119cmV0dXJuIHBhcnNlRmxvYXQoaSl9KCk7aWYoMjg9PT1pKXtpPWVbdCsrXTtpPShpPDwyNHxlW3QrK108PDE2KT4+MTY7cmV0dXJuIGl9aWYoMjk9PT1pKXtpPWVbdCsrXTtpPWk8PDh8ZVt0KytdO2k9aTw8OHxlW3QrK107aT1pPDw4fGVbdCsrXTtyZXR1cm4gaX1pZihpPj0zMiYmaTw9MjQ2KXJldHVybiBpLTEzOTtpZihpPj0yNDcmJmk8PTI1MClyZXR1cm4gMjU2KihpLTI0NykrZVt0KytdKzEwODtpZihpPj0yNTEmJmk8PTI1NClyZXR1cm4tMjU2KihpLTI1MSktZVt0KytdLTEwODt3YXJuKCdDRkZQYXJzZXJfcGFyc2VEaWN0OiAiJytpKyciIGlzIGEgcmVzZXJ2ZWQgY29tbWFuZC4nKTtyZXR1cm4gTmFOfWxldCBpPVtdO2NvbnN0IGE9W107dD0wO2NvbnN0IHM9ZS5sZW5ndGg7Zm9yKDt0PHM7KXtsZXQgcz1lW3RdO2lmKHM8PTIxKXsxMj09PXMmJihzPXM8PDh8ZVsrK3RdKTthLnB1c2goW3MsaV0pO2k9W107Kyt0fWVsc2UgaS5wdXNoKHBhcnNlT3BlcmFuZCgpKX1yZXR1cm4gYX1wYXJzZUluZGV4KGUpe2NvbnN0IHQ9bmV3IENGRkluZGV4LGk9dGhpcy5ieXRlcyxhPWlbZSsrXTw8OHxpW2UrK10scz1bXTtsZXQgcixuLG89ZTtpZigwIT09YSl7Y29uc3QgdD1pW2UrK10sZz1lKyhhKzEpKnQtMTtmb3Iocj0wLG49YSsxO3I8bjsrK3Ipe2xldCBhPTA7Zm9yKGxldCBzPTA7czx0Oysrcyl7YTw8PTg7YSs9aVtlKytdfXMucHVzaChnK2EpfW89c1thXX1mb3Iocj0wLG49cy5sZW5ndGgtMTtyPG47KytyKXtjb25zdCBlPXNbcl0sYT1zW3IrMV07dC5hZGQoaS5zdWJhcnJheShlLGEpKX1yZXR1cm57b2JqOnQsZW5kUG9zOm99fXBhcnNlTmFtZUluZGV4KGUpe2NvbnN0IHQ9W107Zm9yKGxldCBpPTAsYT1lLmNvdW50O2k8YTsrK2kpe2NvbnN0IGE9ZS5nZXQoaSk7dC5wdXNoKGJ5dGVzVG9TdHJpbmcoYSkpfXJldHVybiB0fXBhcnNlU3RyaW5nSW5kZXgoZSl7Y29uc3QgdD1uZXcgQ0ZGU3RyaW5ncztmb3IobGV0IGk9MCxhPWUuY291bnQ7aTxhOysraSl7Y29uc3QgYT1lLmdldChpKTt0LmFkZChieXRlc1RvU3RyaW5nKGEpKX1yZXR1cm4gdH1jcmVhdGVEaWN0KGUsdCxpKXtjb25zdCBhPW5ldyBlKGkpO2Zvcihjb25zdFtlLGldb2YgdClhLnNldEJ5S2V5KGUsaSk7cmV0dXJuIGF9cGFyc2VDaGFyU3RyaW5nKGUsdCxpLGEpe2lmKCF0fHxlLmNhbGxEZXB0aD4xMClyZXR1cm4hMTtsZXQgcz1lLnN0YWNrU2l6ZTtjb25zdCByPWUuc3RhY2s7bGV0IG49dC5sZW5ndGg7Zm9yKGxldCBvPTA7bzxuOyl7Y29uc3QgZz10W28rK107bGV0IGM9bnVsbDtpZigxMj09PWcpe2NvbnN0IGU9dFtvKytdO2lmKDA9PT1lKXt0W28tMl09MTM5O3Rbby0xXT0yMjtzPTB9ZWxzZSBjPUZpW2VdfWVsc2UgaWYoMjg9PT1nKXtyW3NdPSh0W29dPDwyNHx0W28rMV08PDE2KT4+MTY7bys9MjtzKyt9ZWxzZSBpZigxND09PWcpe2lmKHM+PTQpe3MtPTQ7aWYodGhpcy5zZWFjQW5hbHlzaXNFbmFibGVkKXtlLnNlYWM9ci5zbGljZShzLHMrNCk7cmV0dXJuITF9fWM9RGlbZ119ZWxzZSBpZihnPj0zMiYmZzw9MjQ2KXtyW3NdPWctMTM5O3MrK31lbHNlIGlmKGc+PTI0NyYmZzw9MjU0KXtyW3NdPWc8MjUxPyhnLTI0Nzw8OCkrdFtvXSsxMDg6LShnLTI1MTw8OCktdFtvXS0xMDg7bysrO3MrK31lbHNlIGlmKDI1NT09PWcpe3Jbc109KHRbb108PDI0fHRbbysxXTw8MTZ8dFtvKzJdPDw4fHRbbyszXSkvNjU1MzY7bys9NDtzKyt9ZWxzZSBpZigxOT09PWd8fDIwPT09Zyl7ZS5oaW50cys9cz4+MTtpZigwPT09ZS5oaW50cyl7dC5jb3B5V2l0aGluKG8tMSxvLC0xKTtvLT0xO24tPTE7Y29udGludWV9bys9ZS5oaW50cys3Pj4zO3MlPTI7Yz1EaVtnXX1lbHNle2lmKDEwPT09Z3x8Mjk9PT1nKXtjb25zdCB0PTEwPT09Zz9pOmE7aWYoIXQpe2M9RGlbZ107d2FybigiTWlzc2luZyBzdWJyc0luZGV4IGZvciAiK2MuaWQpO3JldHVybiExfWxldCBuPTMyNzY4O3QuY291bnQ8MTI0MD9uPTEwNzp0LmNvdW50PDMzOTAwJiYobj0xMTMxKTtjb25zdCBvPXJbLS1zXStuO2lmKG88MHx8bz49dC5jb3VudHx8aXNOYU4obykpe2M9RGlbZ107d2FybigiT3V0IG9mIGJvdW5kcyBzdWJySW5kZXggZm9yICIrYy5pZCk7cmV0dXJuITF9ZS5zdGFja1NpemU9cztlLmNhbGxEZXB0aCsrO2lmKCF0aGlzLnBhcnNlQ2hhclN0cmluZyhlLHQuZ2V0KG8pLGksYSkpcmV0dXJuITE7ZS5jYWxsRGVwdGgtLTtzPWUuc3RhY2tTaXplO2NvbnRpbnVlfWlmKDExPT09Zyl7ZS5zdGFja1NpemU9cztyZXR1cm4hMH1pZigwPT09ZyYmbz09PXQubGVuZ3RoKXt0W28tMV09MTQ7Yz1EaVsxNF19ZWxzZXtpZig5PT09Zyl7dC5jb3B5V2l0aGluKG8tMSxvLC0xKTtvLT0xO24tPTE7Y29udGludWV9Yz1EaVtnXX19aWYoYyl7aWYoYy5zdGVtKXtlLmhpbnRzKz1zPj4xO2lmKDM9PT1nfHwyMz09PWcpZS5oYXNWU3RlbXM9ITA7ZWxzZSBpZihlLmhhc1ZTdGVtcyYmKDE9PT1nfHwxOD09PWcpKXt3YXJuKCJDRkYgc3RlbSBoaW50cyBhcmUgaW4gd3Jvbmcgb3JkZXIiKTt0W28tMV09MT09PWc/MzoyM319aWYoIm1pbiJpbiBjJiYhZS51bmRlZlN0YWNrJiZzPGMubWluKXt3YXJuKCJOb3QgZW5vdWdoIHBhcmFtZXRlcnMgZm9yICIrYy5pZCsiOyBhY3R1YWw6ICIrcysiLCBleHBlY3RlZDogIitjLm1pbik7aWYoMD09PXMpe3Rbby0xXT0xNDtyZXR1cm4hMH1yZXR1cm4hMX1pZihlLmZpcnN0U3RhY2tDbGVhcmluZyYmYy5zdGFja0NsZWFyaW5nKXtlLmZpcnN0U3RhY2tDbGVhcmluZz0hMTtzLT1jLm1pbjtzPj0yJiZjLnN0ZW0/cyU9MjpzPjEmJndhcm4oIkZvdW5kIHRvbyBtYW55IHBhcmFtZXRlcnMgZm9yIHN0YWNrLWNsZWFyaW5nIGNvbW1hbmQiKTtzPjAmJihlLndpZHRoPXJbcy0xXSl9aWYoInN0YWNrRGVsdGEiaW4gYyl7InN0YWNrRm4iaW4gYyYmYy5zdGFja0ZuKHIscyk7cys9Yy5zdGFja0RlbHRhfWVsc2UgaWYoYy5zdGFja0NsZWFyaW5nKXM9MDtlbHNlIGlmKGMucmVzZXRTdGFjayl7cz0wO2UudW5kZWZTdGFjaz0hMX1lbHNlIGlmKGMudW5kZWZTdGFjayl7cz0wO2UudW5kZWZTdGFjaz0hMDtlLmZpcnN0U3RhY2tDbGVhcmluZz0hMX19fW48dC5sZW5ndGgmJnQuZmlsbCgxNCxuKTtlLnN0YWNrU2l6ZT1zO3JldHVybiEwfXBhcnNlQ2hhclN0cmluZ3Moe2NoYXJTdHJpbmdzOmUsbG9jYWxTdWJySW5kZXg6dCxnbG9iYWxTdWJySW5kZXg6aSxmZFNlbGVjdDphLGZkQXJyYXk6cyxwcml2YXRlRGljdDpyfSl7Y29uc3Qgbj1bXSxvPVtdLGc9ZS5jb3VudDtmb3IobGV0IGM9MDtjPGc7YysrKXtjb25zdCBnPWUuZ2V0KGMpLEM9e2NhbGxEZXB0aDowLHN0YWNrU2l6ZTowLHN0YWNrOltdLHVuZGVmU3RhY2s6ITAsaGludHM6MCxmaXJzdFN0YWNrQ2xlYXJpbmc6ITAsc2VhYzpudWxsLHdpZHRoOm51bGwsaGFzVlN0ZW1zOiExfTtsZXQgaD0hMCxsPW51bGwsUT1yO2lmKGEmJnMubGVuZ3RoKXtjb25zdCBlPWEuZ2V0RkRJbmRleChjKTtpZigtMT09PWUpe3dhcm4oIkdseXBoIGluZGV4IGlzIG5vdCBpbiBmZCBzZWxlY3QuIik7aD0hMX1pZihlPj1zLmxlbmd0aCl7d2FybigiSW52YWxpZCBmZCBpbmRleCBmb3IgZ2x5cGggaW5kZXguIik7aD0hMX1pZihoKXtRPXNbZV0ucHJpdmF0ZURpY3Q7bD1RLnN1YnJzSW5kZXh9fWVsc2UgdCYmKGw9dCk7aCYmKGg9dGhpcy5wYXJzZUNoYXJTdHJpbmcoQyxnLGwsaSkpO2lmKG51bGwhPT1DLndpZHRoKXtjb25zdCBlPVEuZ2V0QnlOYW1lKCJub21pbmFsV2lkdGhYIik7b1tjXT1lK0Mud2lkdGh9ZWxzZXtjb25zdCBlPVEuZ2V0QnlOYW1lKCJkZWZhdWx0V2lkdGhYIik7b1tjXT1lfW51bGwhPT1DLnNlYWMmJihuW2NdPUMuc2VhYyk7aHx8ZS5zZXQoYyxuZXcgVWludDhBcnJheShbMTRdKSl9cmV0dXJue2NoYXJTdHJpbmdzOmUsc2VhY3M6bix3aWR0aHM6b319ZW1wdHlQcml2YXRlRGljdGlvbmFyeShlKXtjb25zdCB0PXRoaXMuY3JlYXRlRGljdChDRkZQcml2YXRlRGljdCxbXSxlLnN0cmluZ3MpO2Uuc2V0QnlLZXkoMTgsWzAsMF0pO2UucHJpdmF0ZURpY3Q9dH1wYXJzZVByaXZhdGVEaWN0KGUpe2lmKCFlLmhhc05hbWUoIlByaXZhdGUiKSl7dGhpcy5lbXB0eVByaXZhdGVEaWN0aW9uYXJ5KGUpO3JldHVybn1jb25zdCB0PWUuZ2V0QnlOYW1lKCJQcml2YXRlIik7aWYoIUFycmF5LmlzQXJyYXkodCl8fDIhPT10Lmxlbmd0aCl7ZS5yZW1vdmVCeU5hbWUoIlByaXZhdGUiKTtyZXR1cm59Y29uc3QgaT10WzBdLGE9dFsxXTtpZigwPT09aXx8YT49dGhpcy5ieXRlcy5sZW5ndGgpe3RoaXMuZW1wdHlQcml2YXRlRGljdGlvbmFyeShlKTtyZXR1cm59Y29uc3Qgcz1hK2kscj10aGlzLmJ5dGVzLnN1YmFycmF5KGEscyksbj10aGlzLnBhcnNlRGljdChyKSxvPXRoaXMuY3JlYXRlRGljdChDRkZQcml2YXRlRGljdCxuLGUuc3RyaW5ncyk7ZS5wcml2YXRlRGljdD1vOzA9PT1vLmdldEJ5TmFtZSgiRXhwYW5zaW9uRmFjdG9yIikmJm8uc2V0QnlOYW1lKCJFeHBhbnNpb25GYWN0b3IiLC4wNik7aWYoIW8uZ2V0QnlOYW1lKCJTdWJycyIpKXJldHVybjtjb25zdCBnPW8uZ2V0QnlOYW1lKCJTdWJycyIpLGM9YStnO2lmKDA9PT1nfHxjPj10aGlzLmJ5dGVzLmxlbmd0aCl7dGhpcy5lbXB0eVByaXZhdGVEaWN0aW9uYXJ5KGUpO3JldHVybn1jb25zdCBDPXRoaXMucGFyc2VJbmRleChjKTtvLnN1YnJzSW5kZXg9Qy5vYmp9cGFyc2VDaGFyc2V0cyhlLHQsaSxhKXtpZigwPT09ZSlyZXR1cm4gbmV3IENGRkNoYXJzZXQoITAsTmkuSVNPX0FET0JFLGxpKTtpZigxPT09ZSlyZXR1cm4gbmV3IENGRkNoYXJzZXQoITAsTmkuRVhQRVJULEJpKTtpZigyPT09ZSlyZXR1cm4gbmV3IENGRkNoYXJzZXQoITAsTmkuRVhQRVJUX1NVQlNFVCxRaSk7Y29uc3Qgcz10aGlzLmJ5dGVzLHI9ZSxuPXNbZSsrXSxvPVthPzA6Ii5ub3RkZWYiXTtsZXQgZyxjLEM7dC09MTtzd2l0Y2gobil7Y2FzZSAwOmZvcihDPTA7Qzx0O0MrKyl7Zz1zW2UrK108PDh8c1tlKytdO28ucHVzaChhP2c6aS5nZXQoZykpfWJyZWFrO2Nhc2UgMTpmb3IoO28ubGVuZ3RoPD10Oyl7Zz1zW2UrK108PDh8c1tlKytdO2M9c1tlKytdO2ZvcihDPTA7Qzw9YztDKyspby5wdXNoKGE/ZysrOmkuZ2V0KGcrKykpfWJyZWFrO2Nhc2UgMjpmb3IoO28ubGVuZ3RoPD10Oyl7Zz1zW2UrK108PDh8c1tlKytdO2M9c1tlKytdPDw4fHNbZSsrXTtmb3IoQz0wO0M8PWM7QysrKW8ucHVzaChhP2crKzppLmdldChnKyspKX1icmVhaztkZWZhdWx0OnRocm93IG5ldyBGb3JtYXRFcnJvcigiVW5rbm93biBjaGFyc2V0IGZvcm1hdCIpfWNvbnN0IGg9ZSxsPXMuc3ViYXJyYXkocixoKTtyZXR1cm4gbmV3IENGRkNoYXJzZXQoITEsbixvLGwpfXBhcnNlRW5jb2RpbmcoZSx0LGksYSl7Y29uc3Qgcz1PYmplY3QuY3JlYXRlKG51bGwpLHI9dGhpcy5ieXRlcztsZXQgbixvLGcsYz0hMSxDPW51bGw7aWYoMD09PWV8fDE9PT1lKXtjPSEwO249ZTtjb25zdCB0PWU/RWk6Zmk7Zm9yKG89MCxnPWEubGVuZ3RoO288ZztvKyspe2NvbnN0IGU9dC5pbmRleE9mKGFbb10pOy0xIT09ZSYmKHNbZV09byl9fWVsc2V7Y29uc3QgdD1lO249cltlKytdO3N3aXRjaCgxMjcmbil7Y2FzZSAwOmNvbnN0IHQ9cltlKytdO2ZvcihvPTE7bzw9dDtvKyspc1tyW2UrK11dPW87YnJlYWs7Y2FzZSAxOmNvbnN0IGk9cltlKytdO2xldCBhPTE7Zm9yKG89MDtvPGk7bysrKXtjb25zdCB0PXJbZSsrXSxpPXJbZSsrXTtmb3IobGV0IGU9dDtlPD10K2k7ZSsrKXNbZV09YSsrfWJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbmtub3duIGVuY29kaW5nIGZvcm1hdDogJHtufSBpbiBDRkZgKX1jb25zdCBnPWU7aWYoMTI4Jm4pe3JbdF0mPTEyNzshZnVuY3Rpb24gcmVhZFN1cHBsZW1lbnQoKXtjb25zdCB0PXJbZSsrXTtmb3Iobz0wO288dDtvKyspe2NvbnN0IHQ9cltlKytdLG49KHJbZSsrXTw8OCkrKDI1NSZyW2UrK10pO3NbdF09YS5pbmRleE9mKGkuZ2V0KG4pKX19KCl9Qz1yLnN1YmFycmF5KHQsZyl9biY9MTI3O3JldHVybiBuZXcgQ0ZGRW5jb2RpbmcoYyxuLHMsQyl9cGFyc2VGRFNlbGVjdChlLHQpe2NvbnN0IGk9dGhpcy5ieXRlcyxhPWlbZSsrXSxzPVtdO2xldCByO3N3aXRjaChhKXtjYXNlIDA6Zm9yKHI9MDtyPHQ7KytyKXtjb25zdCB0PWlbZSsrXTtzLnB1c2godCl9YnJlYWs7Y2FzZSAzOmNvbnN0IG49aVtlKytdPDw4fGlbZSsrXTtmb3Iocj0wO3I8bjsrK3Ipe2xldCB0PWlbZSsrXTw8OHxpW2UrK107aWYoMD09PXImJjAhPT10KXt3YXJuKCJwYXJzZUZEU2VsZWN0OiBUaGUgZmlyc3QgcmFuZ2UgbXVzdCBoYXZlIGEgZmlyc3QgR0lEIG9mIDAgLS0gdHJ5aW5nIHRvIHJlY292ZXIuIik7dD0wfWNvbnN0IGE9aVtlKytdLG49aVtlXTw8OHxpW2UrMV07Zm9yKGxldCBlPXQ7ZTxuOysrZSlzLnB1c2goYSl9ZSs9MjticmVhaztkZWZhdWx0OnRocm93IG5ldyBGb3JtYXRFcnJvcihgcGFyc2VGRFNlbGVjdDogVW5rbm93biBmb3JtYXQgIiR7YX0iLmApfWlmKHMubGVuZ3RoIT09dCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoInBhcnNlRkRTZWxlY3Q6IEludmFsaWQgZm9udCBkYXRhLiIpO3JldHVybiBuZXcgQ0ZGRkRTZWxlY3QoYSxzKX19Y2xhc3MgQ0ZGe2NvbnN0cnVjdG9yKCl7dGhpcy5oZWFkZXI9bnVsbDt0aGlzLm5hbWVzPVtdO3RoaXMudG9wRGljdD1udWxsO3RoaXMuc3RyaW5ncz1uZXcgQ0ZGU3RyaW5nczt0aGlzLmdsb2JhbFN1YnJJbmRleD1udWxsO3RoaXMuZW5jb2Rpbmc9bnVsbDt0aGlzLmNoYXJzZXQ9bnVsbDt0aGlzLmNoYXJTdHJpbmdzPW51bGw7dGhpcy5mZEFycmF5PVtdO3RoaXMuZmRTZWxlY3Q9bnVsbDt0aGlzLmlzQ0lERm9udD0hMX1kdXBsaWNhdGVGaXJzdEdseXBoKCl7aWYodGhpcy5jaGFyU3RyaW5ncy5jb3VudD49NjU1MzUpe3dhcm4oIk5vdCBlbm91Z2ggc3BhY2UgaW4gY2hhcnN0cmluZ3MgdG8gZHVwbGljYXRlIGZpcnN0IGdseXBoLiIpO3JldHVybn1jb25zdCBlPXRoaXMuY2hhclN0cmluZ3MuZ2V0KDApO3RoaXMuY2hhclN0cmluZ3MuYWRkKGUpO3RoaXMuaXNDSURGb250JiZ0aGlzLmZkU2VsZWN0LmZkU2VsZWN0LnB1c2godGhpcy5mZFNlbGVjdC5mZFNlbGVjdFswXSl9aGFzR2x5cGhJZChlKXtpZihlPDB8fGU+PXRoaXMuY2hhclN0cmluZ3MuY291bnQpcmV0dXJuITE7cmV0dXJuIHRoaXMuY2hhclN0cmluZ3MuZ2V0KGUpLmxlbmd0aD4wfX1jbGFzcyBDRkZIZWFkZXJ7Y29uc3RydWN0b3IoZSx0LGksYSl7dGhpcy5tYWpvcj1lO3RoaXMubWlub3I9dDt0aGlzLmhkclNpemU9aTt0aGlzLm9mZlNpemU9YX19Y2xhc3MgQ0ZGU3RyaW5nc3tjb25zdHJ1Y3Rvcigpe3RoaXMuc3RyaW5ncz1bXX1nZXQoZSl7cmV0dXJuIGU+PTAmJmU8PTM5MD93aVtlXTplLWJpPD10aGlzLnN0cmluZ3MubGVuZ3RoP3RoaXMuc3RyaW5nc1tlLWJpXTp3aVswXX1nZXRTSUQoZSl7bGV0IHQ9d2kuaW5kZXhPZihlKTtpZigtMSE9PXQpcmV0dXJuIHQ7dD10aGlzLnN0cmluZ3MuaW5kZXhPZihlKTtyZXR1cm4tMSE9PXQ/dCtiaTotMX1hZGQoZSl7dGhpcy5zdHJpbmdzLnB1c2goZSl9Z2V0IGNvdW50KCl7cmV0dXJuIHRoaXMuc3RyaW5ncy5sZW5ndGh9fWNsYXNzIENGRkluZGV4e2NvbnN0cnVjdG9yKCl7dGhpcy5vYmplY3RzPVtdO3RoaXMubGVuZ3RoPTB9YWRkKGUpe3RoaXMubGVuZ3RoKz1lLmxlbmd0aDt0aGlzLm9iamVjdHMucHVzaChlKX1zZXQoZSx0KXt0aGlzLmxlbmd0aCs9dC5sZW5ndGgtdGhpcy5vYmplY3RzW2VdLmxlbmd0aDt0aGlzLm9iamVjdHNbZV09dH1nZXQoZSl7cmV0dXJuIHRoaXMub2JqZWN0c1tlXX1nZXQgY291bnQoKXtyZXR1cm4gdGhpcy5vYmplY3RzLmxlbmd0aH19Y2xhc3MgQ0ZGRGljdHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMua2V5VG9OYW1lTWFwPWUua2V5VG9OYW1lTWFwO3RoaXMubmFtZVRvS2V5TWFwPWUubmFtZVRvS2V5TWFwO3RoaXMuZGVmYXVsdHM9ZS5kZWZhdWx0czt0aGlzLnR5cGVzPWUudHlwZXM7dGhpcy5vcGNvZGVzPWUub3Bjb2Rlczt0aGlzLm9yZGVyPWUub3JkZXI7dGhpcy5zdHJpbmdzPXQ7dGhpcy52YWx1ZXM9T2JqZWN0LmNyZWF0ZShudWxsKX1zZXRCeUtleShlLHQpe2lmKCEoZSBpbiB0aGlzLmtleVRvTmFtZU1hcCkpcmV0dXJuITE7aWYoMD09PXQubGVuZ3RoKXJldHVybiEwO2Zvcihjb25zdCBpIG9mIHQpaWYoaXNOYU4oaSkpe3dhcm4oYEludmFsaWQgQ0ZGRGljdCB2YWx1ZTogIiR7dH0iIGZvciBrZXkgIiR7ZX0iLmApO3JldHVybiEwfWNvbnN0IGk9dGhpcy50eXBlc1tlXTsibnVtIiE9PWkmJiJzaWQiIT09aSYmIm9mZnNldCIhPT1pfHwodD10WzBdKTt0aGlzLnZhbHVlc1tlXT10O3JldHVybiEwfXNldEJ5TmFtZShlLHQpe2lmKCEoZSBpbiB0aGlzLm5hbWVUb0tleU1hcCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIGRpY3Rpb25hcnkgbmFtZSAiJHtlfSJgKTt0aGlzLnZhbHVlc1t0aGlzLm5hbWVUb0tleU1hcFtlXV09dH1oYXNOYW1lKGUpe3JldHVybiB0aGlzLm5hbWVUb0tleU1hcFtlXWluIHRoaXMudmFsdWVzfWdldEJ5TmFtZShlKXtpZighKGUgaW4gdGhpcy5uYW1lVG9LZXlNYXApKXRocm93IG5ldyBGb3JtYXRFcnJvcihgSW52YWxpZCBkaWN0aW9uYXJ5IG5hbWUgJHtlfSJgKTtjb25zdCB0PXRoaXMubmFtZVRvS2V5TWFwW2VdO3JldHVybiB0IGluIHRoaXMudmFsdWVzP3RoaXMudmFsdWVzW3RdOnRoaXMuZGVmYXVsdHNbdF19cmVtb3ZlQnlOYW1lKGUpe2RlbGV0ZSB0aGlzLnZhbHVlc1t0aGlzLm5hbWVUb0tleU1hcFtlXV19c3RhdGljIGNyZWF0ZVRhYmxlcyhlKXtjb25zdCB0PXtrZXlUb05hbWVNYXA6e30sbmFtZVRvS2V5TWFwOnt9LGRlZmF1bHRzOnt9LHR5cGVzOnt9LG9wY29kZXM6e30sb3JkZXI6W119O2Zvcihjb25zdCBpIG9mIGUpe2NvbnN0IGU9QXJyYXkuaXNBcnJheShpWzBdKT8oaVswXVswXTw8OCkraVswXVsxXTppWzBdO3Qua2V5VG9OYW1lTWFwW2VdPWlbMV07dC5uYW1lVG9LZXlNYXBbaVsxXV09ZTt0LnR5cGVzW2VdPWlbMl07dC5kZWZhdWx0c1tlXT1pWzNdO3Qub3Bjb2Rlc1tlXT1BcnJheS5pc0FycmF5KGlbMF0pP2lbMF06W2lbMF1dO3Qub3JkZXIucHVzaChlKX1yZXR1cm4gdH19Y29uc3QgU2k9W1tbMTIsMzBdLCJST1MiLFsic2lkIiwic2lkIiwibnVtIl0sbnVsbF0sW1sxMiwyMF0sIlN5bnRoZXRpY0Jhc2UiLCJudW0iLG51bGxdLFswLCJ2ZXJzaW9uIiwic2lkIixudWxsXSxbMSwiTm90aWNlIiwic2lkIixudWxsXSxbWzEyLDBdLCJDb3B5cmlnaHQiLCJzaWQiLG51bGxdLFsyLCJGdWxsTmFtZSIsInNpZCIsbnVsbF0sWzMsIkZhbWlseU5hbWUiLCJzaWQiLG51bGxdLFs0LCJXZWlnaHQiLCJzaWQiLG51bGxdLFtbMTIsMV0sImlzRml4ZWRQaXRjaCIsIm51bSIsMF0sW1sxMiwyXSwiSXRhbGljQW5nbGUiLCJudW0iLDBdLFtbMTIsM10sIlVuZGVybGluZVBvc2l0aW9uIiwibnVtIiwtMTAwXSxbWzEyLDRdLCJVbmRlcmxpbmVUaGlja25lc3MiLCJudW0iLDUwXSxbWzEyLDVdLCJQYWludFR5cGUiLCJudW0iLDBdLFtbMTIsNl0sIkNoYXJzdHJpbmdUeXBlIiwibnVtIiwyXSxbWzEyLDddLCJGb250TWF0cml4IixbIm51bSIsIm51bSIsIm51bSIsIm51bSIsIm51bSIsIm51bSJdLFsuMDAxLDAsMCwuMDAxLDAsMF1dLFsxMywiVW5pcXVlSUQiLCJudW0iLG51bGxdLFs1LCJGb250QkJveCIsWyJudW0iLCJudW0iLCJudW0iLCJudW0iXSxbMCwwLDAsMF1dLFtbMTIsOF0sIlN0cm9rZVdpZHRoIiwibnVtIiwwXSxbMTQsIlhVSUQiLCJhcnJheSIsbnVsbF0sWzE1LCJjaGFyc2V0Iiwib2Zmc2V0IiwwXSxbMTYsIkVuY29kaW5nIiwib2Zmc2V0IiwwXSxbMTcsIkNoYXJTdHJpbmdzIiwib2Zmc2V0IiwwXSxbMTgsIlByaXZhdGUiLFsib2Zmc2V0Iiwib2Zmc2V0Il0sbnVsbF0sW1sxMiwyMV0sIlBvc3RTY3JpcHQiLCJzaWQiLG51bGxdLFtbMTIsMjJdLCJCYXNlRm9udE5hbWUiLCJzaWQiLG51bGxdLFtbMTIsMjNdLCJCYXNlRm9udEJsZW5kIiwiZGVsdGEiLG51bGxdLFtbMTIsMzFdLCJDSURGb250VmVyc2lvbiIsIm51bSIsMF0sW1sxMiwzMl0sIkNJREZvbnRSZXZpc2lvbiIsIm51bSIsMF0sW1sxMiwzM10sIkNJREZvbnRUeXBlIiwibnVtIiwwXSxbWzEyLDM0XSwiQ0lEQ291bnQiLCJudW0iLDg3MjBdLFtbMTIsMzVdLCJVSURCYXNlIiwibnVtIixudWxsXSxbWzEyLDM3XSwiRkRTZWxlY3QiLCJvZmZzZXQiLG51bGxdLFtbMTIsMzZdLCJGREFycmF5Iiwib2Zmc2V0IixudWxsXSxbWzEyLDM4XSwiRm9udE5hbWUiLCJzaWQiLG51bGxdXTtjbGFzcyBDRkZUb3BEaWN0IGV4dGVuZHMgQ0ZGRGljdHtzdGF0aWMgZ2V0IHRhYmxlcygpe3JldHVybiBzaGFkb3codGhpcywidGFibGVzIix0aGlzLmNyZWF0ZVRhYmxlcyhTaSkpfWNvbnN0cnVjdG9yKGUpe3N1cGVyKENGRlRvcERpY3QudGFibGVzLGUpO3RoaXMucHJpdmF0ZURpY3Q9bnVsbH19Y29uc3Qga2k9W1s2LCJCbHVlVmFsdWVzIiwiZGVsdGEiLG51bGxdLFs3LCJPdGhlckJsdWVzIiwiZGVsdGEiLG51bGxdLFs4LCJGYW1pbHlCbHVlcyIsImRlbHRhIixudWxsXSxbOSwiRmFtaWx5T3RoZXJCbHVlcyIsImRlbHRhIixudWxsXSxbWzEyLDldLCJCbHVlU2NhbGUiLCJudW0iLC4wMzk2MjVdLFtbMTIsMTBdLCJCbHVlU2hpZnQiLCJudW0iLDddLFtbMTIsMTFdLCJCbHVlRnV6eiIsIm51bSIsMV0sWzEwLCJTdGRIVyIsIm51bSIsbnVsbF0sWzExLCJTdGRWVyIsIm51bSIsbnVsbF0sW1sxMiwxMl0sIlN0ZW1TbmFwSCIsImRlbHRhIixudWxsXSxbWzEyLDEzXSwiU3RlbVNuYXBWIiwiZGVsdGEiLG51bGxdLFtbMTIsMTRdLCJGb3JjZUJvbGQiLCJudW0iLDBdLFtbMTIsMTddLCJMYW5ndWFnZUdyb3VwIiwibnVtIiwwXSxbWzEyLDE4XSwiRXhwYW5zaW9uRmFjdG9yIiwibnVtIiwuMDZdLFtbMTIsMTldLCJpbml0aWFsUmFuZG9tU2VlZCIsIm51bSIsMF0sWzIwLCJkZWZhdWx0V2lkdGhYIiwibnVtIiwwXSxbMjEsIm5vbWluYWxXaWR0aFgiLCJudW0iLDBdLFsxOSwiU3VicnMiLCJvZmZzZXQiLG51bGxdXTtjbGFzcyBDRkZQcml2YXRlRGljdCBleHRlbmRzIENGRkRpY3R7c3RhdGljIGdldCB0YWJsZXMoKXtyZXR1cm4gc2hhZG93KHRoaXMsInRhYmxlcyIsdGhpcy5jcmVhdGVUYWJsZXMoa2kpKX1jb25zdHJ1Y3RvcihlKXtzdXBlcihDRkZQcml2YXRlRGljdC50YWJsZXMsZSk7dGhpcy5zdWJyc0luZGV4PW51bGx9fWNvbnN0IE5pPXtJU09fQURPQkU6MCxFWFBFUlQ6MSxFWFBFUlRfU1VCU0VUOjJ9O2NsYXNzIENGRkNoYXJzZXR7Y29uc3RydWN0b3IoZSx0LGksYSl7dGhpcy5wcmVkZWZpbmVkPWU7dGhpcy5mb3JtYXQ9dDt0aGlzLmNoYXJzZXQ9aTt0aGlzLnJhdz1hfX1jbGFzcyBDRkZFbmNvZGluZ3tjb25zdHJ1Y3RvcihlLHQsaSxhKXt0aGlzLnByZWRlZmluZWQ9ZTt0aGlzLmZvcm1hdD10O3RoaXMuZW5jb2Rpbmc9aTt0aGlzLnJhdz1hfX1jbGFzcyBDRkZGRFNlbGVjdHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuZm9ybWF0PWU7dGhpcy5mZFNlbGVjdD10fWdldEZESW5kZXgoZSl7cmV0dXJuIGU8MHx8ZT49dGhpcy5mZFNlbGVjdC5sZW5ndGg/LTE6dGhpcy5mZFNlbGVjdFtlXX19Y2xhc3MgQ0ZGT2Zmc2V0VHJhY2tlcntjb25zdHJ1Y3Rvcigpe3RoaXMub2Zmc2V0cz1PYmplY3QuY3JlYXRlKG51bGwpfWlzVHJhY2tpbmcoZSl7cmV0dXJuIGUgaW4gdGhpcy5vZmZzZXRzfXRyYWNrKGUsdCl7aWYoZSBpbiB0aGlzLm9mZnNldHMpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBBbHJlYWR5IHRyYWNraW5nIGxvY2F0aW9uIG9mICR7ZX1gKTt0aGlzLm9mZnNldHNbZV09dH1vZmZzZXQoZSl7Zm9yKGNvbnN0IHQgaW4gdGhpcy5vZmZzZXRzKXRoaXMub2Zmc2V0c1t0XSs9ZX1zZXRFbnRyeUxvY2F0aW9uKGUsdCxpKXtpZighKGUgaW4gdGhpcy5vZmZzZXRzKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYE5vdCB0cmFja2luZyBsb2NhdGlvbiBvZiAke2V9YCk7Y29uc3QgYT1pLmRhdGEscz10aGlzLm9mZnNldHNbZV07Zm9yKGxldCBlPTAsaT10Lmxlbmd0aDtlPGk7KytlKXtjb25zdCBpPTUqZStzLHI9aSsxLG49aSsyLG89aSszLGc9aSs0O2lmKDI5IT09YVtpXXx8MCE9PWFbcl18fDAhPT1hW25dfHwwIT09YVtvXXx8MCE9PWFbZ10pdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJ3cml0aW5nIHRvIGFuIG9mZnNldCB0aGF0IGlzIG5vdCBlbXB0eSIpO2NvbnN0IGM9dFtlXTthW2ldPTI5O2Fbcl09Yz4+MjQmMjU1O2Fbbl09Yz4+MTYmMjU1O2Fbb109Yz4+OCYyNTU7YVtnXT0yNTUmY319fWNsYXNzIENGRkNvbXBpbGVye2NvbnN0cnVjdG9yKGUpe3RoaXMuY2ZmPWV9Y29tcGlsZSgpe2NvbnN0IGU9dGhpcy5jZmYsdD17ZGF0YTpbXSxsZW5ndGg6MCxhZGQoZSl7dHJ5e3RoaXMuZGF0YS5wdXNoKC4uLmUpfWNhdGNoe3RoaXMuZGF0YT10aGlzLmRhdGEuY29uY2F0KGUpfXRoaXMubGVuZ3RoPXRoaXMuZGF0YS5sZW5ndGh9fSxpPXRoaXMuY29tcGlsZUhlYWRlcihlLmhlYWRlcik7dC5hZGQoaSk7Y29uc3QgYT10aGlzLmNvbXBpbGVOYW1lSW5kZXgoZS5uYW1lcyk7dC5hZGQoYSk7aWYoZS5pc0NJREZvbnQmJmUudG9wRGljdC5oYXNOYW1lKCJGb250TWF0cml4Iikpe2NvbnN0IHQ9ZS50b3BEaWN0LmdldEJ5TmFtZSgiRm9udE1hdHJpeCIpO2UudG9wRGljdC5yZW1vdmVCeU5hbWUoIkZvbnRNYXRyaXgiKTtmb3IoY29uc3QgaSBvZiBlLmZkQXJyYXkpe2xldCBlPXQuc2xpY2UoMCk7aS5oYXNOYW1lKCJGb250TWF0cml4IikmJihlPVV0aWwudHJhbnNmb3JtKGUsaS5nZXRCeU5hbWUoIkZvbnRNYXRyaXgiKSkpO2kuc2V0QnlOYW1lKCJGb250TWF0cml4IixlKX19Y29uc3Qgcz1lLnRvcERpY3QuZ2V0QnlOYW1lKCJYVUlEIik7cz8ubGVuZ3RoPjE2JiZlLnRvcERpY3QucmVtb3ZlQnlOYW1lKCJYVUlEIik7ZS50b3BEaWN0LnNldEJ5TmFtZSgiY2hhcnNldCIsMCk7bGV0IHI9dGhpcy5jb21waWxlVG9wRGljdHMoW2UudG9wRGljdF0sdC5sZW5ndGgsZS5pc0NJREZvbnQpO3QuYWRkKHIub3V0cHV0KTtjb25zdCBuPXIudHJhY2tlcnNbMF0sbz10aGlzLmNvbXBpbGVTdHJpbmdJbmRleChlLnN0cmluZ3Muc3RyaW5ncyk7dC5hZGQobyk7Y29uc3QgZz10aGlzLmNvbXBpbGVJbmRleChlLmdsb2JhbFN1YnJJbmRleCk7dC5hZGQoZyk7aWYoZS5lbmNvZGluZyYmZS50b3BEaWN0Lmhhc05hbWUoIkVuY29kaW5nIikpaWYoZS5lbmNvZGluZy5wcmVkZWZpbmVkKW4uc2V0RW50cnlMb2NhdGlvbigiRW5jb2RpbmciLFtlLmVuY29kaW5nLmZvcm1hdF0sdCk7ZWxzZXtjb25zdCBpPXRoaXMuY29tcGlsZUVuY29kaW5nKGUuZW5jb2RpbmcpO24uc2V0RW50cnlMb2NhdGlvbigiRW5jb2RpbmciLFt0Lmxlbmd0aF0sdCk7dC5hZGQoaSl9Y29uc3QgYz10aGlzLmNvbXBpbGVDaGFyc2V0KGUuY2hhcnNldCxlLmNoYXJTdHJpbmdzLmNvdW50LGUuc3RyaW5ncyxlLmlzQ0lERm9udCk7bi5zZXRFbnRyeUxvY2F0aW9uKCJjaGFyc2V0IixbdC5sZW5ndGhdLHQpO3QuYWRkKGMpO2NvbnN0IEM9dGhpcy5jb21waWxlQ2hhclN0cmluZ3MoZS5jaGFyU3RyaW5ncyk7bi5zZXRFbnRyeUxvY2F0aW9uKCJDaGFyU3RyaW5ncyIsW3QubGVuZ3RoXSx0KTt0LmFkZChDKTtpZihlLmlzQ0lERm9udCl7bi5zZXRFbnRyeUxvY2F0aW9uKCJGRFNlbGVjdCIsW3QubGVuZ3RoXSx0KTtjb25zdCBpPXRoaXMuY29tcGlsZUZEU2VsZWN0KGUuZmRTZWxlY3QpO3QuYWRkKGkpO3I9dGhpcy5jb21waWxlVG9wRGljdHMoZS5mZEFycmF5LHQubGVuZ3RoLCEwKTtuLnNldEVudHJ5TG9jYXRpb24oIkZEQXJyYXkiLFt0Lmxlbmd0aF0sdCk7dC5hZGQoci5vdXRwdXQpO2NvbnN0IGE9ci50cmFja2Vyczt0aGlzLmNvbXBpbGVQcml2YXRlRGljdHMoZS5mZEFycmF5LGEsdCl9dGhpcy5jb21waWxlUHJpdmF0ZURpY3RzKFtlLnRvcERpY3RdLFtuXSx0KTt0LmFkZChbMF0pO3JldHVybiB0LmRhdGF9ZW5jb2RlTnVtYmVyKGUpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGUpP3RoaXMuZW5jb2RlSW50ZWdlcihlKTp0aGlzLmVuY29kZUZsb2F0KGUpfXN0YXRpYyBnZXQgRW5jb2RlRmxvYXRSZWdFeHAoKXtyZXR1cm4gc2hhZG93KHRoaXMsIkVuY29kZUZsb2F0UmVnRXhwIiwvXC4oXGQqPykoPzo5ezUsMjB9fDB7NSwyMH0pXGR7MCwyfSg/OmUoLispfCQpLyl9ZW5jb2RlRmxvYXQoZSl7bGV0IHQ9ZS50b1N0cmluZygpO2NvbnN0IGk9Q0ZGQ29tcGlsZXIuRW5jb2RlRmxvYXRSZWdFeHAuZXhlYyh0KTtpZihpKXtjb25zdCBhPXBhcnNlRmxvYXQoIjFlIisoKGlbMl0/K2lbMl06MCkraVsxXS5sZW5ndGgpKTt0PShNYXRoLnJvdW5kKGUqYSkvYSkudG9TdHJpbmcoKX1sZXQgYSxzLHI9IiI7Zm9yKGE9MCxzPXQubGVuZ3RoO2E8czsrK2Epe2NvbnN0IGU9dFthXTtyKz0iZSI9PT1lPyItIj09PXRbKythXT8iYyI6ImIiOiIuIj09PWU/ImEiOiItIj09PWU/ImUiOmV9cis9MSZyLmxlbmd0aD8iZiI6ImZmIjtjb25zdCBuPVszMF07Zm9yKGE9MCxzPXIubGVuZ3RoO2E8czthKz0yKW4ucHVzaChwYXJzZUludChyLnN1YnN0cmluZyhhLGErMiksMTYpKTtyZXR1cm4gbn1lbmNvZGVJbnRlZ2VyKGUpe2xldCB0O3Q9ZT49LTEwNyYmZTw9MTA3P1tlKzEzOV06ZT49MTA4JiZlPD0xMTMxP1syNDcrKChlLT0xMDgpPj44KSwyNTUmZV06ZT49LTExMzEmJmU8PS0xMDg/WzI1MSsoKGU9LWUtMTA4KT4+OCksMjU1JmVdOmU+PS0zMjc2OCYmZTw9MzI3Njc/WzI4LGU+PjgmMjU1LDI1NSZlXTpbMjksZT4+MjQmMjU1LGU+PjE2JjI1NSxlPj44JjI1NSwyNTUmZV07cmV0dXJuIHR9Y29tcGlsZUhlYWRlcihlKXtyZXR1cm5bZS5tYWpvcixlLm1pbm9yLDQsZS5vZmZTaXplXX1jb21waWxlTmFtZUluZGV4KGUpe2NvbnN0IHQ9bmV3IENGRkluZGV4O2Zvcihjb25zdCBpIG9mIGUpe2NvbnN0IGU9TWF0aC5taW4oaS5sZW5ndGgsMTI3KTtsZXQgYT1uZXcgQXJyYXkoZSk7Zm9yKGxldCB0PTA7dDxlO3QrKyl7bGV0IGU9aVt0XTsoZTwiISJ8fGU+In4ifHwiWyI9PT1lfHwiXSI9PT1lfHwiKCI9PT1lfHwiKSI9PT1lfHwieyI9PT1lfHwifSI9PT1lfHwiPCI9PT1lfHwiPiI9PT1lfHwiLyI9PT1lfHwiJSI9PT1lKSYmKGU9Il8iKTthW3RdPWV9YT1hLmpvaW4oIiIpOyIiPT09YSYmKGE9IkJhZF9Gb250X05hbWUiKTt0LmFkZChzdHJpbmdUb0J5dGVzKGEpKX1yZXR1cm4gdGhpcy5jb21waWxlSW5kZXgodCl9Y29tcGlsZVRvcERpY3RzKGUsdCxpKXtjb25zdCBhPVtdO2xldCBzPW5ldyBDRkZJbmRleDtmb3IoY29uc3QgciBvZiBlKXtpZihpKXtyLnJlbW92ZUJ5TmFtZSgiQ0lERm9udFZlcnNpb24iKTtyLnJlbW92ZUJ5TmFtZSgiQ0lERm9udFJldmlzaW9uIik7ci5yZW1vdmVCeU5hbWUoIkNJREZvbnRUeXBlIik7ci5yZW1vdmVCeU5hbWUoIkNJRENvdW50Iik7ci5yZW1vdmVCeU5hbWUoIlVJREJhc2UiKX1jb25zdCBlPW5ldyBDRkZPZmZzZXRUcmFja2VyLG49dGhpcy5jb21waWxlRGljdChyLGUpO2EucHVzaChlKTtzLmFkZChuKTtlLm9mZnNldCh0KX1zPXRoaXMuY29tcGlsZUluZGV4KHMsYSk7cmV0dXJue3RyYWNrZXJzOmEsb3V0cHV0OnN9fWNvbXBpbGVQcml2YXRlRGljdHMoZSx0LGkpe2ZvcihsZXQgYT0wLHM9ZS5sZW5ndGg7YTxzOysrYSl7Y29uc3Qgcz1lW2FdLHI9cy5wcml2YXRlRGljdDtpZighcnx8IXMuaGFzTmFtZSgiUHJpdmF0ZSIpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiVGhlcmUgbXVzdCBiZSBhIHByaXZhdGUgZGljdGlvbmFyeS4iKTtjb25zdCBuPW5ldyBDRkZPZmZzZXRUcmFja2VyLG89dGhpcy5jb21waWxlRGljdChyLG4pO2xldCBnPWkubGVuZ3RoO24ub2Zmc2V0KGcpO28ubGVuZ3RofHwoZz0wKTt0W2FdLnNldEVudHJ5TG9jYXRpb24oIlByaXZhdGUiLFtvLmxlbmd0aCxnXSxpKTtpLmFkZChvKTtpZihyLnN1YnJzSW5kZXgmJnIuaGFzTmFtZSgiU3VicnMiKSl7Y29uc3QgZT10aGlzLmNvbXBpbGVJbmRleChyLnN1YnJzSW5kZXgpO24uc2V0RW50cnlMb2NhdGlvbigiU3VicnMiLFtvLmxlbmd0aF0saSk7aS5hZGQoZSl9fX1jb21waWxlRGljdChlLHQpe2NvbnN0IGk9W107Zm9yKGNvbnN0IGEgb2YgZS5vcmRlcil7aWYoIShhIGluIGUudmFsdWVzKSljb250aW51ZTtsZXQgcz1lLnZhbHVlc1thXSxyPWUudHlwZXNbYV07QXJyYXkuaXNBcnJheShyKXx8KHI9W3JdKTtBcnJheS5pc0FycmF5KHMpfHwocz1bc10pO2lmKDAhPT1zLmxlbmd0aCl7Zm9yKGxldCBuPTAsbz1yLmxlbmd0aDtuPG87KytuKXtjb25zdCBvPXJbbl0sZz1zW25dO3N3aXRjaChvKXtjYXNlIm51bSI6Y2FzZSJzaWQiOmkucHVzaCguLi50aGlzLmVuY29kZU51bWJlcihnKSk7YnJlYWs7Y2FzZSJvZmZzZXQiOmNvbnN0IHI9ZS5rZXlUb05hbWVNYXBbYV07dC5pc1RyYWNraW5nKHIpfHx0LnRyYWNrKHIsaS5sZW5ndGgpO2kucHVzaCgyOSwwLDAsMCwwKTticmVhaztjYXNlImFycmF5IjpjYXNlImRlbHRhIjppLnB1c2goLi4udGhpcy5lbmNvZGVOdW1iZXIoZykpO2ZvcihsZXQgZT0xLHQ9cy5sZW5ndGg7ZTx0OysrZSlpLnB1c2goLi4udGhpcy5lbmNvZGVOdW1iZXIoc1tlXSkpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbmtub3duIGRhdGEgdHlwZSBvZiAke299YCl9fWkucHVzaCguLi5lLm9wY29kZXNbYV0pfX1yZXR1cm4gaX1jb21waWxlU3RyaW5nSW5kZXgoZSl7Y29uc3QgdD1uZXcgQ0ZGSW5kZXg7Zm9yKGNvbnN0IGkgb2YgZSl0LmFkZChzdHJpbmdUb0J5dGVzKGkpKTtyZXR1cm4gdGhpcy5jb21waWxlSW5kZXgodCl9Y29tcGlsZUNoYXJTdHJpbmdzKGUpe2NvbnN0IHQ9bmV3IENGRkluZGV4O2ZvcihsZXQgaT0wO2k8ZS5jb3VudDtpKyspe2NvbnN0IGE9ZS5nZXQoaSk7MCE9PWEubGVuZ3RoP3QuYWRkKGEpOnQuYWRkKG5ldyBVaW50OEFycmF5KFsxMzksMTRdKSl9cmV0dXJuIHRoaXMuY29tcGlsZUluZGV4KHQpfWNvbXBpbGVDaGFyc2V0KGUsdCxpLGEpe2xldCBzO2NvbnN0IHI9dC0xO2lmKGEpcz1uZXcgVWludDhBcnJheShbMiwwLDAscj4+OCYyNTUsMjU1JnJdKTtlbHNle3M9bmV3IFVpbnQ4QXJyYXkoMSsyKnIpO3NbMF09MDtsZXQgdD0wO2NvbnN0IGE9ZS5jaGFyc2V0Lmxlbmd0aDtsZXQgbj0hMTtmb3IobGV0IHI9MTtyPHMubGVuZ3RoO3IrPTIpe2xldCBvPTA7aWYodDxhKXtjb25zdCBhPWUuY2hhcnNldFt0KytdO289aS5nZXRTSUQoYSk7aWYoLTE9PT1vKXtvPTA7aWYoIW4pe249ITA7d2FybihgQ291bGRuJ3QgZmluZCAke2F9IGluIENGRiBzdHJpbmdzYCl9fX1zW3JdPW8+PjgmMjU1O3NbcisxXT0yNTUmb319cmV0dXJuIHRoaXMuY29tcGlsZVR5cGVkQXJyYXkocyl9Y29tcGlsZUVuY29kaW5nKGUpe3JldHVybiB0aGlzLmNvbXBpbGVUeXBlZEFycmF5KGUucmF3KX1jb21waWxlRkRTZWxlY3QoZSl7Y29uc3QgdD1lLmZvcm1hdDtsZXQgaSxhO3N3aXRjaCh0KXtjYXNlIDA6aT1uZXcgVWludDhBcnJheSgxK2UuZmRTZWxlY3QubGVuZ3RoKTtpWzBdPXQ7Zm9yKGE9MDthPGUuZmRTZWxlY3QubGVuZ3RoO2ErKylpW2ErMV09ZS5mZFNlbGVjdFthXTticmVhaztjYXNlIDM6Y29uc3Qgcz0wO2xldCByPWUuZmRTZWxlY3RbMF07Y29uc3Qgbj1bdCwwLDAscz4+OCYyNTUsMjU1JnMscl07Zm9yKGE9MTthPGUuZmRTZWxlY3QubGVuZ3RoO2ErKyl7Y29uc3QgdD1lLmZkU2VsZWN0W2FdO2lmKHQhPT1yKXtuLnB1c2goYT4+OCYyNTUsMjU1JmEsdCk7cj10fX1jb25zdCBvPShuLmxlbmd0aC0zKS8zO25bMV09bz4+OCYyNTU7blsyXT0yNTUmbztuLnB1c2goYT4+OCYyNTUsMjU1JmEpO2k9bmV3IFVpbnQ4QXJyYXkobil9cmV0dXJuIHRoaXMuY29tcGlsZVR5cGVkQXJyYXkoaSl9Y29tcGlsZVR5cGVkQXJyYXkoZSl7cmV0dXJuIEFycmF5LmZyb20oZSl9Y29tcGlsZUluZGV4KGUsdD1bXSl7Y29uc3QgaT1lLm9iamVjdHMsYT1pLmxlbmd0aDtpZigwPT09YSlyZXR1cm5bMCwwXTtjb25zdCBzPVthPj44JjI1NSwyNTUmYV07bGV0IHIsbixvPTE7Zm9yKHI9MDtyPGE7KytyKW8rPWlbcl0ubGVuZ3RoO249bzwyNTY/MTpvPDY1NTM2PzI6bzwxNjc3NzIxNj8zOjQ7cy5wdXNoKG4pO2xldCBnPTE7Zm9yKHI9MDtyPGErMTtyKyspezE9PT1uP3MucHVzaCgyNTUmZyk6Mj09PW4/cy5wdXNoKGc+PjgmMjU1LDI1NSZnKTozPT09bj9zLnB1c2goZz4+MTYmMjU1LGc+PjgmMjU1LDI1NSZnKTpzLnB1c2goZz4+PjI0JjI1NSxnPj4xNiYyNTUsZz4+OCYyNTUsMjU1JmcpO2lbcl0mJihnKz1pW3JdLmxlbmd0aCl9Zm9yKHI9MDtyPGE7cisrKXt0W3JdJiZ0W3JdLm9mZnNldChzLmxlbmd0aCk7cy5wdXNoKC4uLmlbcl0pfXJldHVybiBzfX1jb25zdCBSaT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2UuQT02NTtlLkFFPTE5ODtlLkFFYWN1dGU9NTA4O2UuQUVtYWNyb249NDgyO2UuQUVzbWFsbD02MzQ2MjtlLkFhY3V0ZT0xOTM7ZS5BYWN1dGVzbWFsbD02MzQ1NztlLkFicmV2ZT0yNTg7ZS5BYnJldmVhY3V0ZT03ODU0O2UuQWJyZXZlY3lyaWxsaWM9MTIzMjtlLkFicmV2ZWRvdGJlbG93PTc4NjI7ZS5BYnJldmVncmF2ZT03ODU2O2UuQWJyZXZlaG9va2Fib3ZlPTc4NTg7ZS5BYnJldmV0aWxkZT03ODYwO2UuQWNhcm9uPTQ2MTtlLkFjaXJjbGU9OTM5ODtlLkFjaXJjdW1mbGV4PTE5NDtlLkFjaXJjdW1mbGV4YWN1dGU9Nzg0NDtlLkFjaXJjdW1mbGV4ZG90YmVsb3c9Nzg1MjtlLkFjaXJjdW1mbGV4Z3JhdmU9Nzg0NjtlLkFjaXJjdW1mbGV4aG9va2Fib3ZlPTc4NDg7ZS5BY2lyY3VtZmxleHNtYWxsPTYzNDU4O2UuQWNpcmN1bWZsZXh0aWxkZT03ODUwO2UuQWN1dGU9NjMxNzc7ZS5BY3V0ZXNtYWxsPTYzNDEyO2UuQWN5cmlsbGljPTEwNDA7ZS5BZGJsZ3JhdmU9NTEyO2UuQWRpZXJlc2lzPTE5NjtlLkFkaWVyZXNpc2N5cmlsbGljPTEyMzQ7ZS5BZGllcmVzaXNtYWNyb249NDc4O2UuQWRpZXJlc2lzc21hbGw9NjM0NjA7ZS5BZG90YmVsb3c9Nzg0MDtlLkFkb3RtYWNyb249NDgwO2UuQWdyYXZlPTE5MjtlLkFncmF2ZXNtYWxsPTYzNDU2O2UuQWhvb2thYm92ZT03ODQyO2UuQWllY3lyaWxsaWM9MTIzNjtlLkFpbnZlcnRlZGJyZXZlPTUxNDtlLkFscGhhPTkxMztlLkFscGhhdG9ub3M9OTAyO2UuQW1hY3Jvbj0yNTY7ZS5BbW9ub3NwYWNlPTY1MzEzO2UuQW9nb25laz0yNjA7ZS5BcmluZz0xOTc7ZS5BcmluZ2FjdXRlPTUwNjtlLkFyaW5nYmVsb3c9NzY4MDtlLkFyaW5nc21hbGw9NjM0NjE7ZS5Bc21hbGw9NjMzMjk7ZS5BdGlsZGU9MTk1O2UuQXRpbGRlc21hbGw9NjM0NTk7ZS5BeWJhcm1lbmlhbj0xMzI5O2UuQj02NjtlLkJjaXJjbGU9OTM5OTtlLkJkb3RhY2NlbnQ9NzY4MjtlLkJkb3RiZWxvdz03Njg0O2UuQmVjeXJpbGxpYz0xMDQxO2UuQmVuYXJtZW5pYW49MTMzMDtlLkJldGE9OTE0O2UuQmhvb2s9Mzg1O2UuQmxpbmViZWxvdz03Njg2O2UuQm1vbm9zcGFjZT02NTMxNDtlLkJyZXZlc21hbGw9NjMyMjA7ZS5Cc21hbGw9NjMzMzA7ZS5CdG9wYmFyPTM4NjtlLkM9Njc7ZS5DYWFybWVuaWFuPTEzNDI7ZS5DYWN1dGU9MjYyO2UuQ2Fyb249NjMxNzg7ZS5DYXJvbnNtYWxsPTYzMjIxO2UuQ2Nhcm9uPTI2ODtlLkNjZWRpbGxhPTE5OTtlLkNjZWRpbGxhYWN1dGU9NzY4ODtlLkNjZWRpbGxhc21hbGw9NjM0NjM7ZS5DY2lyY2xlPTk0MDA7ZS5DY2lyY3VtZmxleD0yNjQ7ZS5DZG90PTI2NjtlLkNkb3RhY2NlbnQ9MjY2O2UuQ2VkaWxsYXNtYWxsPTYzNDE2O2UuQ2hhYXJtZW5pYW49MTM1MztlLkNoZWFia2hhc2lhbmN5cmlsbGljPTEyMTI7ZS5DaGVjeXJpbGxpYz0xMDYzO2UuQ2hlZGVzY2VuZGVyYWJraGFzaWFuY3lyaWxsaWM9MTIxNDtlLkNoZWRlc2NlbmRlcmN5cmlsbGljPTEyMDY7ZS5DaGVkaWVyZXNpc2N5cmlsbGljPTEyNjg7ZS5DaGVoYXJtZW5pYW49MTM0NztlLkNoZWtoYWthc3NpYW5jeXJpbGxpYz0xMjI3O2UuQ2hldmVydGljYWxzdHJva2VjeXJpbGxpYz0xMjA4O2UuQ2hpPTkzNTtlLkNob29rPTM5MTtlLkNpcmN1bWZsZXhzbWFsbD02MzIyMjtlLkNtb25vc3BhY2U9NjUzMTU7ZS5Db2FybWVuaWFuPTEzNjE7ZS5Dc21hbGw9NjMzMzE7ZS5EPTY4O2UuRFo9NDk3O2UuRFpjYXJvbj00NTI7ZS5EYWFybWVuaWFuPTEzMzI7ZS5EYWZyaWNhbj0zOTM7ZS5EY2Fyb249MjcwO2UuRGNlZGlsbGE9NzY5NjtlLkRjaXJjbGU9OTQwMTtlLkRjaXJjdW1mbGV4YmVsb3c9NzY5ODtlLkRjcm9hdD0yNzI7ZS5EZG90YWNjZW50PTc2OTA7ZS5EZG90YmVsb3c9NzY5MjtlLkRlY3lyaWxsaWM9MTA0NDtlLkRlaWNvcHRpYz0xMDA2O2UuRGVsdGE9ODcxMDtlLkRlbHRhZ3JlZWs9OTE2O2UuRGhvb2s9Mzk0O2UuRGllcmVzaXM9NjMxNzk7ZS5EaWVyZXNpc0FjdXRlPTYzMTgwO2UuRGllcmVzaXNHcmF2ZT02MzE4MTtlLkRpZXJlc2lzc21hbGw9NjM0MDA7ZS5EaWdhbW1hZ3JlZWs9OTg4O2UuRGplY3lyaWxsaWM9MTAyNjtlLkRsaW5lYmVsb3c9NzY5NDtlLkRtb25vc3BhY2U9NjUzMTY7ZS5Eb3RhY2NlbnRzbWFsbD02MzIyMztlLkRzbGFzaD0yNzI7ZS5Ec21hbGw9NjMzMzI7ZS5EdG9wYmFyPTM5NTtlLkR6PTQ5ODtlLkR6Y2Fyb249NDUzO2UuRHplYWJraGFzaWFuY3lyaWxsaWM9MTI0ODtlLkR6ZWN5cmlsbGljPTEwMjk7ZS5EemhlY3lyaWxsaWM9MTAzOTtlLkU9Njk7ZS5FYWN1dGU9MjAxO2UuRWFjdXRlc21hbGw9NjM0NjU7ZS5FYnJldmU9Mjc2O2UuRWNhcm9uPTI4MjtlLkVjZWRpbGxhYnJldmU9NzcwODtlLkVjaGFybWVuaWFuPTEzMzM7ZS5FY2lyY2xlPTk0MDI7ZS5FY2lyY3VtZmxleD0yMDI7ZS5FY2lyY3VtZmxleGFjdXRlPTc4NzA7ZS5FY2lyY3VtZmxleGJlbG93PTc3MDQ7ZS5FY2lyY3VtZmxleGRvdGJlbG93PTc4Nzg7ZS5FY2lyY3VtZmxleGdyYXZlPTc4NzI7ZS5FY2lyY3VtZmxleGhvb2thYm92ZT03ODc0O2UuRWNpcmN1bWZsZXhzbWFsbD02MzQ2NjtlLkVjaXJjdW1mbGV4dGlsZGU9Nzg3NjtlLkVjeXJpbGxpYz0xMDI4O2UuRWRibGdyYXZlPTUxNjtlLkVkaWVyZXNpcz0yMDM7ZS5FZGllcmVzaXNzbWFsbD02MzQ2NztlLkVkb3Q9Mjc4O2UuRWRvdGFjY2VudD0yNzg7ZS5FZG90YmVsb3c9Nzg2NDtlLkVmY3lyaWxsaWM9MTA2MDtlLkVncmF2ZT0yMDA7ZS5FZ3JhdmVzbWFsbD02MzQ2NDtlLkVoYXJtZW5pYW49MTMzNTtlLkVob29rYWJvdmU9Nzg2NjtlLkVpZ2h0cm9tYW49ODU1MTtlLkVpbnZlcnRlZGJyZXZlPTUxODtlLkVpb3RpZmllZGN5cmlsbGljPTExMjQ7ZS5FbGN5cmlsbGljPTEwNTE7ZS5FbGV2ZW5yb21hbj04NTU0O2UuRW1hY3Jvbj0yNzQ7ZS5FbWFjcm9uYWN1dGU9NzcwMjtlLkVtYWNyb25ncmF2ZT03NzAwO2UuRW1jeXJpbGxpYz0xMDUyO2UuRW1vbm9zcGFjZT02NTMxNztlLkVuY3lyaWxsaWM9MTA1MztlLkVuZGVzY2VuZGVyY3lyaWxsaWM9MTE4NjtlLkVuZz0zMzA7ZS5FbmdoZWN5cmlsbGljPTExODg7ZS5Fbmhvb2tjeXJpbGxpYz0xMjIzO2UuRW9nb25laz0yODA7ZS5Fb3Blbj00MDA7ZS5FcHNpbG9uPTkxNztlLkVwc2lsb250b25vcz05MDQ7ZS5FcmN5cmlsbGljPTEwNTY7ZS5FcmV2ZXJzZWQ9Mzk4O2UuRXJldmVyc2VkY3lyaWxsaWM9MTA2OTtlLkVzY3lyaWxsaWM9MTA1NztlLkVzZGVzY2VuZGVyY3lyaWxsaWM9MTE5NDtlLkVzaD00MjU7ZS5Fc21hbGw9NjMzMzM7ZS5FdGE9OTE5O2UuRXRhcm1lbmlhbj0xMzM2O2UuRXRhdG9ub3M9OTA1O2UuRXRoPTIwODtlLkV0aHNtYWxsPTYzNDcyO2UuRXRpbGRlPTc4Njg7ZS5FdGlsZGViZWxvdz03NzA2O2UuRXVybz04MzY0O2UuRXpoPTQzOTtlLkV6aGNhcm9uPTQ5NDtlLkV6aHJldmVyc2VkPTQ0MDtlLkY9NzA7ZS5GY2lyY2xlPTk0MDM7ZS5GZG90YWNjZW50PTc3MTA7ZS5GZWhhcm1lbmlhbj0xMzY2O2UuRmVpY29wdGljPTk5NjtlLkZob29rPTQwMTtlLkZpdGFjeXJpbGxpYz0xMTM4O2UuRml2ZXJvbWFuPTg1NDg7ZS5GbW9ub3NwYWNlPTY1MzE4O2UuRm91cnJvbWFuPTg1NDc7ZS5Gc21hbGw9NjMzMzQ7ZS5HPTcxO2UuR0JzcXVhcmU9MTMxOTE7ZS5HYWN1dGU9NTAwO2UuR2FtbWE9OTE1O2UuR2FtbWFhZnJpY2FuPTQwNDtlLkdhbmdpYWNvcHRpYz0xMDAyO2UuR2JyZXZlPTI4NjtlLkdjYXJvbj00ODY7ZS5HY2VkaWxsYT0yOTA7ZS5HY2lyY2xlPTk0MDQ7ZS5HY2lyY3VtZmxleD0yODQ7ZS5HY29tbWFhY2NlbnQ9MjkwO2UuR2RvdD0yODg7ZS5HZG90YWNjZW50PTI4ODtlLkdlY3lyaWxsaWM9MTA0MztlLkdoYWRhcm1lbmlhbj0xMzQ2O2UuR2hlbWlkZGxlaG9va2N5cmlsbGljPTExNzI7ZS5HaGVzdHJva2VjeXJpbGxpYz0xMTcwO2UuR2hldXB0dXJuY3lyaWxsaWM9MTE2ODtlLkdob29rPTQwMztlLkdpbWFybWVuaWFuPTEzMzE7ZS5HamVjeXJpbGxpYz0xMDI3O2UuR21hY3Jvbj03NzEyO2UuR21vbm9zcGFjZT02NTMxOTtlLkdyYXZlPTYzMTgyO2UuR3JhdmVzbWFsbD02MzMyODtlLkdzbWFsbD02MzMzNTtlLkdzbWFsbGhvb2s9NjY3O2UuR3N0cm9rZT00ODQ7ZS5IPTcyO2UuSDE4NTMzPTk2Nzk7ZS5IMTg1NDM9OTY0MjtlLkgxODU1MT05NjQzO2UuSDIyMDczPTk2MzM7ZS5IUHNxdWFyZT0xMzI1OTtlLkhhYWJraGFzaWFuY3lyaWxsaWM9MTE5MjtlLkhhZGVzY2VuZGVyY3lyaWxsaWM9MTIwMjtlLkhhcmRzaWduY3lyaWxsaWM9MTA2NjtlLkhiYXI9Mjk0O2UuSGJyZXZlYmVsb3c9NzcyMjtlLkhjZWRpbGxhPTc3MjA7ZS5IY2lyY2xlPTk0MDU7ZS5IY2lyY3VtZmxleD0yOTI7ZS5IZGllcmVzaXM9NzcxODtlLkhkb3RhY2NlbnQ9NzcxNDtlLkhkb3RiZWxvdz03NzE2O2UuSG1vbm9zcGFjZT02NTMyMDtlLkhvYXJtZW5pYW49MTM0NDtlLkhvcmljb3B0aWM9MWUzO2UuSHNtYWxsPTYzMzM2O2UuSHVuZ2FydW1sYXV0PTYzMTgzO2UuSHVuZ2FydW1sYXV0c21hbGw9NjMyMjQ7ZS5IenNxdWFyZT0xMzIwMDtlLkk9NzM7ZS5JQWN5cmlsbGljPTEwNzE7ZS5JSj0zMDY7ZS5JVWN5cmlsbGljPTEwNzA7ZS5JYWN1dGU9MjA1O2UuSWFjdXRlc21hbGw9NjM0Njk7ZS5JYnJldmU9MzAwO2UuSWNhcm9uPTQ2MztlLkljaXJjbGU9OTQwNjtlLkljaXJjdW1mbGV4PTIwNjtlLkljaXJjdW1mbGV4c21hbGw9NjM0NzA7ZS5JY3lyaWxsaWM9MTAzMDtlLklkYmxncmF2ZT01MjA7ZS5JZGllcmVzaXM9MjA3O2UuSWRpZXJlc2lzYWN1dGU9NzcyNjtlLklkaWVyZXNpc2N5cmlsbGljPTEyNTI7ZS5JZGllcmVzaXNzbWFsbD02MzQ3MTtlLklkb3Q9MzA0O2UuSWRvdGFjY2VudD0zMDQ7ZS5JZG90YmVsb3c9Nzg4MjtlLkllYnJldmVjeXJpbGxpYz0xMjM4O2UuSWVjeXJpbGxpYz0xMDQ1O2UuSWZyYWt0dXI9ODQ2NTtlLklncmF2ZT0yMDQ7ZS5JZ3JhdmVzbWFsbD02MzQ2ODtlLklob29rYWJvdmU9Nzg4MDtlLklpY3lyaWxsaWM9MTA0ODtlLklpbnZlcnRlZGJyZXZlPTUyMjtlLklpc2hvcnRjeXJpbGxpYz0xMDQ5O2UuSW1hY3Jvbj0yOTg7ZS5JbWFjcm9uY3lyaWxsaWM9MTI1MDtlLkltb25vc3BhY2U9NjUzMjE7ZS5Jbmlhcm1lbmlhbj0xMzM5O2UuSW9jeXJpbGxpYz0xMDI1O2UuSW9nb25laz0zMDI7ZS5Jb3RhPTkyMTtlLklvdGFhZnJpY2FuPTQwNjtlLklvdGFkaWVyZXNpcz05Mzg7ZS5Jb3RhdG9ub3M9OTA2O2UuSXNtYWxsPTYzMzM3O2UuSXN0cm9rZT00MDc7ZS5JdGlsZGU9Mjk2O2UuSXRpbGRlYmVsb3c9NzcyNDtlLkl6aGl0c2FjeXJpbGxpYz0xMTQwO2UuSXpoaXRzYWRibGdyYXZlY3lyaWxsaWM9MTE0MjtlLko9NzQ7ZS5KYWFybWVuaWFuPTEzNDU7ZS5KY2lyY2xlPTk0MDc7ZS5KY2lyY3VtZmxleD0zMDg7ZS5KZWN5cmlsbGljPTEwMzI7ZS5KaGVoYXJtZW5pYW49MTM1NTtlLkptb25vc3BhY2U9NjUzMjI7ZS5Kc21hbGw9NjMzMzg7ZS5LPTc1O2UuS0JzcXVhcmU9MTMxODk7ZS5LS3NxdWFyZT0xMzI2MTtlLkthYmFzaGtpcmN5cmlsbGljPTExODQ7ZS5LYWN1dGU9NzcyODtlLkthY3lyaWxsaWM9MTA1MDtlLkthZGVzY2VuZGVyY3lyaWxsaWM9MTE3ODtlLkthaG9va2N5cmlsbGljPTEyMTk7ZS5LYXBwYT05MjI7ZS5LYXN0cm9rZWN5cmlsbGljPTExODI7ZS5LYXZlcnRpY2Fsc3Ryb2tlY3lyaWxsaWM9MTE4MDtlLktjYXJvbj00ODg7ZS5LY2VkaWxsYT0zMTA7ZS5LY2lyY2xlPTk0MDg7ZS5LY29tbWFhY2NlbnQ9MzEwO2UuS2RvdGJlbG93PTc3MzA7ZS5LZWhhcm1lbmlhbj0xMzY0O2UuS2VuYXJtZW5pYW49MTM0MztlLktoYWN5cmlsbGljPTEwNjE7ZS5LaGVpY29wdGljPTk5ODtlLktob29rPTQwODtlLktqZWN5cmlsbGljPTEwMzY7ZS5LbGluZWJlbG93PTc3MzI7ZS5LbW9ub3NwYWNlPTY1MzIzO2UuS29wcGFjeXJpbGxpYz0xMTUyO2UuS29wcGFncmVlaz05OTA7ZS5Lc2ljeXJpbGxpYz0xMTM0O2UuS3NtYWxsPTYzMzM5O2UuTD03NjtlLkxKPTQ1NTtlLkxMPTYzMTY3O2UuTGFjdXRlPTMxMztlLkxhbWJkYT05MjM7ZS5MY2Fyb249MzE3O2UuTGNlZGlsbGE9MzE1O2UuTGNpcmNsZT05NDA5O2UuTGNpcmN1bWZsZXhiZWxvdz03NzQwO2UuTGNvbW1hYWNjZW50PTMxNTtlLkxkb3Q9MzE5O2UuTGRvdGFjY2VudD0zMTk7ZS5MZG90YmVsb3c9NzczNDtlLkxkb3RiZWxvd21hY3Jvbj03NzM2O2UuTGl3bmFybWVuaWFuPTEzNDA7ZS5Maj00NTY7ZS5MamVjeXJpbGxpYz0xMDMzO2UuTGxpbmViZWxvdz03NzM4O2UuTG1vbm9zcGFjZT02NTMyNDtlLkxzbGFzaD0zMjE7ZS5Mc2xhc2hzbWFsbD02MzIyNTtlLkxzbWFsbD02MzM0MDtlLk09Nzc7ZS5NQnNxdWFyZT0xMzE5MDtlLk1hY3Jvbj02MzE4NDtlLk1hY3JvbnNtYWxsPTYzNDA3O2UuTWFjdXRlPTc3NDI7ZS5NY2lyY2xlPTk0MTA7ZS5NZG90YWNjZW50PTc3NDQ7ZS5NZG90YmVsb3c9Nzc0NjtlLk1lbmFybWVuaWFuPTEzNDg7ZS5NbW9ub3NwYWNlPTY1MzI1O2UuTXNtYWxsPTYzMzQxO2UuTXR1cm5lZD00MTI7ZS5NdT05MjQ7ZS5OPTc4O2UuTko9NDU4O2UuTmFjdXRlPTMyMztlLk5jYXJvbj0zMjc7ZS5OY2VkaWxsYT0zMjU7ZS5OY2lyY2xlPTk0MTE7ZS5OY2lyY3VtZmxleGJlbG93PTc3NTQ7ZS5OY29tbWFhY2NlbnQ9MzI1O2UuTmRvdGFjY2VudD03NzQ4O2UuTmRvdGJlbG93PTc3NTA7ZS5OaG9va2xlZnQ9NDEzO2UuTmluZXJvbWFuPTg1NTI7ZS5Oaj00NTk7ZS5OamVjeXJpbGxpYz0xMDM0O2UuTmxpbmViZWxvdz03NzUyO2UuTm1vbm9zcGFjZT02NTMyNjtlLk5vd2FybWVuaWFuPTEzNTA7ZS5Oc21hbGw9NjMzNDI7ZS5OdGlsZGU9MjA5O2UuTnRpbGRlc21hbGw9NjM0NzM7ZS5OdT05MjU7ZS5PPTc5O2UuT0U9MzM4O2UuT0VzbWFsbD02MzIyNjtlLk9hY3V0ZT0yMTE7ZS5PYWN1dGVzbWFsbD02MzQ3NTtlLk9iYXJyZWRjeXJpbGxpYz0xMjU2O2UuT2JhcnJlZGRpZXJlc2lzY3lyaWxsaWM9MTI1ODtlLk9icmV2ZT0zMzQ7ZS5PY2Fyb249NDY1O2UuT2NlbnRlcmVkdGlsZGU9NDE1O2UuT2NpcmNsZT05NDEyO2UuT2NpcmN1bWZsZXg9MjEyO2UuT2NpcmN1bWZsZXhhY3V0ZT03ODg4O2UuT2NpcmN1bWZsZXhkb3RiZWxvdz03ODk2O2UuT2NpcmN1bWZsZXhncmF2ZT03ODkwO2UuT2NpcmN1bWZsZXhob29rYWJvdmU9Nzg5MjtlLk9jaXJjdW1mbGV4c21hbGw9NjM0NzY7ZS5PY2lyY3VtZmxleHRpbGRlPTc4OTQ7ZS5PY3lyaWxsaWM9MTA1NDtlLk9kYmxhY3V0ZT0zMzY7ZS5PZGJsZ3JhdmU9NTI0O2UuT2RpZXJlc2lzPTIxNDtlLk9kaWVyZXNpc2N5cmlsbGljPTEyNTQ7ZS5PZGllcmVzaXNzbWFsbD02MzQ3ODtlLk9kb3RiZWxvdz03ODg0O2UuT2dvbmVrc21hbGw9NjMyMjc7ZS5PZ3JhdmU9MjEwO2UuT2dyYXZlc21hbGw9NjM0NzQ7ZS5PaGFybWVuaWFuPTEzNjU7ZS5PaG09ODQ4NjtlLk9ob29rYWJvdmU9Nzg4NjtlLk9ob3JuPTQxNjtlLk9ob3JuYWN1dGU9Nzg5ODtlLk9ob3JuZG90YmVsb3c9NzkwNjtlLk9ob3JuZ3JhdmU9NzkwMDtlLk9ob3JuaG9va2Fib3ZlPTc5MDI7ZS5PaG9ybnRpbGRlPTc5MDQ7ZS5PaHVuZ2FydW1sYXV0PTMzNjtlLk9pPTQxODtlLk9pbnZlcnRlZGJyZXZlPTUyNjtlLk9tYWNyb249MzMyO2UuT21hY3JvbmFjdXRlPTc3NjI7ZS5PbWFjcm9uZ3JhdmU9Nzc2MDtlLk9tZWdhPTg0ODY7ZS5PbWVnYWN5cmlsbGljPTExMjA7ZS5PbWVnYWdyZWVrPTkzNztlLk9tZWdhcm91bmRjeXJpbGxpYz0xMTQ2O2UuT21lZ2F0aXRsb2N5cmlsbGljPTExNDg7ZS5PbWVnYXRvbm9zPTkxMTtlLk9taWNyb249OTI3O2UuT21pY3JvbnRvbm9zPTkwODtlLk9tb25vc3BhY2U9NjUzMjc7ZS5PbmVyb21hbj04NTQ0O2UuT29nb25laz00OTA7ZS5Pb2dvbmVrbWFjcm9uPTQ5MjtlLk9vcGVuPTM5MDtlLk9zbGFzaD0yMTY7ZS5Pc2xhc2hhY3V0ZT01MTA7ZS5Pc2xhc2hzbWFsbD02MzQ4MDtlLk9zbWFsbD02MzM0MztlLk9zdHJva2VhY3V0ZT01MTA7ZS5PdGN5cmlsbGljPTExNTA7ZS5PdGlsZGU9MjEzO2UuT3RpbGRlYWN1dGU9Nzc1NjtlLk90aWxkZWRpZXJlc2lzPTc3NTg7ZS5PdGlsZGVzbWFsbD02MzQ3NztlLlA9ODA7ZS5QYWN1dGU9Nzc2NDtlLlBjaXJjbGU9OTQxMztlLlBkb3RhY2NlbnQ9Nzc2NjtlLlBlY3lyaWxsaWM9MTA1NTtlLlBlaGFybWVuaWFuPTEzNTQ7ZS5QZW1pZGRsZWhvb2tjeXJpbGxpYz0xMTkwO2UuUGhpPTkzNDtlLlBob29rPTQyMDtlLlBpPTkyODtlLlBpd3Jhcm1lbmlhbj0xMzYzO2UuUG1vbm9zcGFjZT02NTMyODtlLlBzaT05MzY7ZS5Qc2ljeXJpbGxpYz0xMTM2O2UuUHNtYWxsPTYzMzQ0O2UuUT04MTtlLlFjaXJjbGU9OTQxNDtlLlFtb25vc3BhY2U9NjUzMjk7ZS5Rc21hbGw9NjMzNDU7ZS5SPTgyO2UuUmFhcm1lbmlhbj0xMzU2O2UuUmFjdXRlPTM0MDtlLlJjYXJvbj0zNDQ7ZS5SY2VkaWxsYT0zNDI7ZS5SY2lyY2xlPTk0MTU7ZS5SY29tbWFhY2NlbnQ9MzQyO2UuUmRibGdyYXZlPTUyODtlLlJkb3RhY2NlbnQ9Nzc2ODtlLlJkb3RiZWxvdz03NzcwO2UuUmRvdGJlbG93bWFjcm9uPTc3NzI7ZS5SZWhhcm1lbmlhbj0xMzYwO2UuUmZyYWt0dXI9ODQ3NjtlLlJobz05Mjk7ZS5SaW5nc21hbGw9NjMyMjg7ZS5SaW52ZXJ0ZWRicmV2ZT01MzA7ZS5SbGluZWJlbG93PTc3NzQ7ZS5SbW9ub3NwYWNlPTY1MzMwO2UuUnNtYWxsPTYzMzQ2O2UuUnNtYWxsaW52ZXJ0ZWQ9NjQxO2UuUnNtYWxsaW52ZXJ0ZWRzdXBlcmlvcj02OTQ7ZS5TPTgzO2UuU0YwMTAwMDA9OTQ4NDtlLlNGMDIwMDAwPTk0OTI7ZS5TRjAzMDAwMD05NDg4O2UuU0YwNDAwMDA9OTQ5NjtlLlNGMDUwMDAwPTk1MzI7ZS5TRjA2MDAwMD05NTE2O2UuU0YwNzAwMDA9OTUyNDtlLlNGMDgwMDAwPTk1MDA7ZS5TRjA5MDAwMD05NTA4O2UuU0YxMDAwMDA9OTQ3MjtlLlNGMTEwMDAwPTk0NzQ7ZS5TRjE5MDAwMD05NTY5O2UuU0YyMDAwMDA9OTU3MDtlLlNGMjEwMDAwPTk1NTg7ZS5TRjIyMDAwMD05NTU3O2UuU0YyMzAwMDA9OTU3MTtlLlNGMjQwMDAwPTk1NTM7ZS5TRjI1MDAwMD05NTU5O2UuU0YyNjAwMDA9OTU2NTtlLlNGMjcwMDAwPTk1NjQ7ZS5TRjI4MDAwMD05NTYzO2UuU0YzNjAwMDA9OTU2NjtlLlNGMzcwMDAwPTk1Njc7ZS5TRjM4MDAwMD05NTYyO2UuU0YzOTAwMDA9OTU1NjtlLlNGNDAwMDAwPTk1Nzc7ZS5TRjQxMDAwMD05NTc0O2UuU0Y0MjAwMDA9OTU2ODtlLlNGNDMwMDAwPTk1NTI7ZS5TRjQ0MDAwMD05NTgwO2UuU0Y0NTAwMDA9OTU3NTtlLlNGNDYwMDAwPTk1NzY7ZS5TRjQ3MDAwMD05NTcyO2UuU0Y0ODAwMDA9OTU3MztlLlNGNDkwMDAwPTk1NjE7ZS5TRjUwMDAwMD05NTYwO2UuU0Y1MTAwMDA9OTU1NDtlLlNGNTIwMDAwPTk1NTU7ZS5TRjUzMDAwMD05NTc5O2UuU0Y1NDAwMDA9OTU3ODtlLlNhY3V0ZT0zNDY7ZS5TYWN1dGVkb3RhY2NlbnQ9Nzc4MDtlLlNhbXBpZ3JlZWs9OTkyO2UuU2Nhcm9uPTM1MjtlLlNjYXJvbmRvdGFjY2VudD03NzgyO2UuU2Nhcm9uc21hbGw9NjMyMjk7ZS5TY2VkaWxsYT0zNTA7ZS5TY2h3YT0zOTk7ZS5TY2h3YWN5cmlsbGljPTEyNDA7ZS5TY2h3YWRpZXJlc2lzY3lyaWxsaWM9MTI0MjtlLlNjaXJjbGU9OTQxNjtlLlNjaXJjdW1mbGV4PTM0ODtlLlNjb21tYWFjY2VudD01MzY7ZS5TZG90YWNjZW50PTc3NzY7ZS5TZG90YmVsb3c9Nzc3ODtlLlNkb3RiZWxvd2RvdGFjY2VudD03Nzg0O2UuU2VoYXJtZW5pYW49MTM1NztlLlNldmVucm9tYW49ODU1MDtlLlNoYWFybWVuaWFuPTEzNTE7ZS5TaGFjeXJpbGxpYz0xMDY0O2UuU2hjaGFjeXJpbGxpYz0xMDY1O2UuU2hlaWNvcHRpYz05OTQ7ZS5TaGhhY3lyaWxsaWM9MTIxMDtlLlNoaW1hY29wdGljPTEwMDQ7ZS5TaWdtYT05MzE7ZS5TaXhyb21hbj04NTQ5O2UuU21vbm9zcGFjZT02NTMzMTtlLlNvZnRzaWduY3lyaWxsaWM9MTA2ODtlLlNzbWFsbD02MzM0NztlLlN0aWdtYWdyZWVrPTk4NjtlLlQ9ODQ7ZS5UYXU9OTMyO2UuVGJhcj0zNTg7ZS5UY2Fyb249MzU2O2UuVGNlZGlsbGE9MzU0O2UuVGNpcmNsZT05NDE3O2UuVGNpcmN1bWZsZXhiZWxvdz03NzkyO2UuVGNvbW1hYWNjZW50PTM1NDtlLlRkb3RhY2NlbnQ9Nzc4NjtlLlRkb3RiZWxvdz03Nzg4O2UuVGVjeXJpbGxpYz0xMDU4O2UuVGVkZXNjZW5kZXJjeXJpbGxpYz0xMTk2O2UuVGVucm9tYW49ODU1MztlLlRldHNlY3lyaWxsaWM9MTIwNDtlLlRoZXRhPTkyMDtlLlRob29rPTQyODtlLlRob3JuPTIyMjtlLlRob3Juc21hbGw9NjM0ODY7ZS5UaHJlZXJvbWFuPTg1NDY7ZS5UaWxkZXNtYWxsPTYzMjMwO2UuVGl3bmFybWVuaWFuPTEzNTk7ZS5UbGluZWJlbG93PTc3OTA7ZS5UbW9ub3NwYWNlPTY1MzMyO2UuVG9hcm1lbmlhbj0xMzM3O2UuVG9uZWZpdmU9NDQ0O2UuVG9uZXNpeD0zODg7ZS5Ub25ldHdvPTQyMztlLlRyZXRyb2ZsZXhob29rPTQzMDtlLlRzZWN5cmlsbGljPTEwNjI7ZS5Uc2hlY3lyaWxsaWM9MTAzNTtlLlRzbWFsbD02MzM0ODtlLlR3ZWx2ZXJvbWFuPTg1NTU7ZS5Ud29yb21hbj04NTQ1O2UuVT04NTtlLlVhY3V0ZT0yMTg7ZS5VYWN1dGVzbWFsbD02MzQ4MjtlLlVicmV2ZT0zNjQ7ZS5VY2Fyb249NDY3O2UuVWNpcmNsZT05NDE4O2UuVWNpcmN1bWZsZXg9MjE5O2UuVWNpcmN1bWZsZXhiZWxvdz03Nzk4O2UuVWNpcmN1bWZsZXhzbWFsbD02MzQ4MztlLlVjeXJpbGxpYz0xMDU5O2UuVWRibGFjdXRlPTM2ODtlLlVkYmxncmF2ZT01MzI7ZS5VZGllcmVzaXM9MjIwO2UuVWRpZXJlc2lzYWN1dGU9NDcxO2UuVWRpZXJlc2lzYmVsb3c9Nzc5NDtlLlVkaWVyZXNpc2Nhcm9uPTQ3MztlLlVkaWVyZXNpc2N5cmlsbGljPTEyNjQ7ZS5VZGllcmVzaXNncmF2ZT00NzU7ZS5VZGllcmVzaXNtYWNyb249NDY5O2UuVWRpZXJlc2lzc21hbGw9NjM0ODQ7ZS5VZG90YmVsb3c9NzkwODtlLlVncmF2ZT0yMTc7ZS5VZ3JhdmVzbWFsbD02MzQ4MTtlLlVob29rYWJvdmU9NzkxMDtlLlVob3JuPTQzMTtlLlVob3JuYWN1dGU9NzkxMjtlLlVob3JuZG90YmVsb3c9NzkyMDtlLlVob3JuZ3JhdmU9NzkxNDtlLlVob3JuaG9va2Fib3ZlPTc5MTY7ZS5VaG9ybnRpbGRlPTc5MTg7ZS5VaHVuZ2FydW1sYXV0PTM2ODtlLlVodW5nYXJ1bWxhdXRjeXJpbGxpYz0xMjY2O2UuVWludmVydGVkYnJldmU9NTM0O2UuVWtjeXJpbGxpYz0xMTQ0O2UuVW1hY3Jvbj0zNjI7ZS5VbWFjcm9uY3lyaWxsaWM9MTI2MjtlLlVtYWNyb25kaWVyZXNpcz03ODAyO2UuVW1vbm9zcGFjZT02NTMzMztlLlVvZ29uZWs9MzcwO2UuVXBzaWxvbj05MzM7ZS5VcHNpbG9uMT05Nzg7ZS5VcHNpbG9uYWN1dGVob29rc3ltYm9sZ3JlZWs9OTc5O2UuVXBzaWxvbmFmcmljYW49NDMzO2UuVXBzaWxvbmRpZXJlc2lzPTkzOTtlLlVwc2lsb25kaWVyZXNpc2hvb2tzeW1ib2xncmVlaz05ODA7ZS5VcHNpbG9uaG9va3N5bWJvbD05Nzg7ZS5VcHNpbG9udG9ub3M9OTEwO2UuVXJpbmc9MzY2O2UuVXNob3J0Y3lyaWxsaWM9MTAzODtlLlVzbWFsbD02MzM0OTtlLlVzdHJhaWdodGN5cmlsbGljPTExOTg7ZS5Vc3RyYWlnaHRzdHJva2VjeXJpbGxpYz0xMjAwO2UuVXRpbGRlPTM2MDtlLlV0aWxkZWFjdXRlPTc4MDA7ZS5VdGlsZGViZWxvdz03Nzk2O2UuVj04NjtlLlZjaXJjbGU9OTQxOTtlLlZkb3RiZWxvdz03ODA2O2UuVmVjeXJpbGxpYz0xMDQyO2UuVmV3YXJtZW5pYW49MTM1ODtlLlZob29rPTQzNDtlLlZtb25vc3BhY2U9NjUzMzQ7ZS5Wb2FybWVuaWFuPTEzNTI7ZS5Wc21hbGw9NjMzNTA7ZS5WdGlsZGU9NzgwNDtlLlc9ODc7ZS5XYWN1dGU9NzgxMDtlLldjaXJjbGU9OTQyMDtlLldjaXJjdW1mbGV4PTM3MjtlLldkaWVyZXNpcz03ODEyO2UuV2RvdGFjY2VudD03ODE0O2UuV2RvdGJlbG93PTc4MTY7ZS5XZ3JhdmU9NzgwODtlLldtb25vc3BhY2U9NjUzMzU7ZS5Xc21hbGw9NjMzNTE7ZS5YPTg4O2UuWGNpcmNsZT05NDIxO2UuWGRpZXJlc2lzPTc4MjA7ZS5YZG90YWNjZW50PTc4MTg7ZS5YZWhhcm1lbmlhbj0xMzQxO2UuWGk9OTI2O2UuWG1vbm9zcGFjZT02NTMzNjtlLlhzbWFsbD02MzM1MjtlLlk9ODk7ZS5ZYWN1dGU9MjIxO2UuWWFjdXRlc21hbGw9NjM0ODU7ZS5ZYXRjeXJpbGxpYz0xMTIyO2UuWWNpcmNsZT05NDIyO2UuWWNpcmN1bWZsZXg9Mzc0O2UuWWRpZXJlc2lzPTM3NjtlLllkaWVyZXNpc3NtYWxsPTYzNDg3O2UuWWRvdGFjY2VudD03ODIyO2UuWWRvdGJlbG93PTc5MjQ7ZS5ZZXJpY3lyaWxsaWM9MTA2NztlLlllcnVkaWVyZXNpc2N5cmlsbGljPTEyNzI7ZS5ZZ3JhdmU9NzkyMjtlLllob29rPTQzNTtlLllob29rYWJvdmU9NzkyNjtlLllpYXJtZW5pYW49MTM0OTtlLllpY3lyaWxsaWM9MTAzMTtlLllpd25hcm1lbmlhbj0xMzYyO2UuWW1vbm9zcGFjZT02NTMzNztlLllzbWFsbD02MzM1MztlLll0aWxkZT03OTI4O2UuWXVzYmlnY3lyaWxsaWM9MTEzMDtlLll1c2JpZ2lvdGlmaWVkY3lyaWxsaWM9MTEzMjtlLll1c2xpdHRsZWN5cmlsbGljPTExMjY7ZS5ZdXNsaXR0bGVpb3RpZmllZGN5cmlsbGljPTExMjg7ZS5aPTkwO2UuWmFhcm1lbmlhbj0xMzM0O2UuWmFjdXRlPTM3NztlLlpjYXJvbj0zODE7ZS5aY2Fyb25zbWFsbD02MzIzMTtlLlpjaXJjbGU9OTQyMztlLlpjaXJjdW1mbGV4PTc4MjQ7ZS5aZG90PTM3OTtlLlpkb3RhY2NlbnQ9Mzc5O2UuWmRvdGJlbG93PTc4MjY7ZS5aZWN5cmlsbGljPTEwNDc7ZS5aZWRlc2NlbmRlcmN5cmlsbGljPTExNzY7ZS5aZWRpZXJlc2lzY3lyaWxsaWM9MTI0NjtlLlpldGE9OTE4O2UuWmhlYXJtZW5pYW49MTMzODtlLlpoZWJyZXZlY3lyaWxsaWM9MTIxNztlLlpoZWN5cmlsbGljPTEwNDY7ZS5aaGVkZXNjZW5kZXJjeXJpbGxpYz0xMTc0O2UuWmhlZGllcmVzaXNjeXJpbGxpYz0xMjQ0O2UuWmxpbmViZWxvdz03ODI4O2UuWm1vbm9zcGFjZT02NTMzODtlLlpzbWFsbD02MzM1NDtlLlpzdHJva2U9NDM3O2UuYT05NztlLmFhYmVuZ2FsaT0yNDM4O2UuYWFjdXRlPTIyNTtlLmFhZGV2YT0yMzEwO2UuYWFndWphcmF0aT0yNjk0O2UuYWFndXJtdWtoaT0yNTY2O2UuYWFtYXRyYWd1cm11a2hpPTI2MjI7ZS5hYXJ1c3F1YXJlPTEzMDU5O2UuYWF2b3dlbHNpZ25iZW5nYWxpPTI0OTQ7ZS5hYXZvd2Vsc2lnbmRldmE9MjM2NjtlLmFhdm93ZWxzaWduZ3VqYXJhdGk9Mjc1MDtlLmFiYnJldmlhdGlvbm1hcmthcm1lbmlhbj0xMzc1O2UuYWJicmV2aWF0aW9uc2lnbmRldmE9MjQxNjtlLmFiZW5nYWxpPTI0Mzc7ZS5hYm9wb21vZm89MTI1NzA7ZS5hYnJldmU9MjU5O2UuYWJyZXZlYWN1dGU9Nzg1NTtlLmFicmV2ZWN5cmlsbGljPTEyMzM7ZS5hYnJldmVkb3RiZWxvdz03ODYzO2UuYWJyZXZlZ3JhdmU9Nzg1NztlLmFicmV2ZWhvb2thYm92ZT03ODU5O2UuYWJyZXZldGlsZGU9Nzg2MTtlLmFjYXJvbj00NjI7ZS5hY2lyY2xlPTk0MjQ7ZS5hY2lyY3VtZmxleD0yMjY7ZS5hY2lyY3VtZmxleGFjdXRlPTc4NDU7ZS5hY2lyY3VtZmxleGRvdGJlbG93PTc4NTM7ZS5hY2lyY3VtZmxleGdyYXZlPTc4NDc7ZS5hY2lyY3VtZmxleGhvb2thYm92ZT03ODQ5O2UuYWNpcmN1bWZsZXh0aWxkZT03ODUxO2UuYWN1dGU9MTgwO2UuYWN1dGViZWxvd2NtYj03OTE7ZS5hY3V0ZWNtYj03Njk7ZS5hY3V0ZWNvbWI9NzY5O2UuYWN1dGVkZXZhPTIzODg7ZS5hY3V0ZWxvd21vZD03MTk7ZS5hY3V0ZXRvbmVjbWI9ODMzO2UuYWN5cmlsbGljPTEwNzI7ZS5hZGJsZ3JhdmU9NTEzO2UuYWRkYWtndXJtdWtoaT0yNjczO2UuYWRldmE9MjMwOTtlLmFkaWVyZXNpcz0yMjg7ZS5hZGllcmVzaXNjeXJpbGxpYz0xMjM1O2UuYWRpZXJlc2lzbWFjcm9uPTQ3OTtlLmFkb3RiZWxvdz03ODQxO2UuYWRvdG1hY3Jvbj00ODE7ZS5hZT0yMzA7ZS5hZWFjdXRlPTUwOTtlLmFla29yZWFuPTEyNjI0O2UuYWVtYWNyb249NDgzO2UuYWZpaTAwMjA4PTgyMTM7ZS5hZmlpMDg5NDE9ODM1NjtlLmFmaWkxMDAxNz0xMDQwO2UuYWZpaTEwMDE4PTEwNDE7ZS5hZmlpMTAwMTk9MTA0MjtlLmFmaWkxMDAyMD0xMDQzO2UuYWZpaTEwMDIxPTEwNDQ7ZS5hZmlpMTAwMjI9MTA0NTtlLmFmaWkxMDAyMz0xMDI1O2UuYWZpaTEwMDI0PTEwNDY7ZS5hZmlpMTAwMjU9MTA0NztlLmFmaWkxMDAyNj0xMDQ4O2UuYWZpaTEwMDI3PTEwNDk7ZS5hZmlpMTAwMjg9MTA1MDtlLmFmaWkxMDAyOT0xMDUxO2UuYWZpaTEwMDMwPTEwNTI7ZS5hZmlpMTAwMzE9MTA1MztlLmFmaWkxMDAzMj0xMDU0O2UuYWZpaTEwMDMzPTEwNTU7ZS5hZmlpMTAwMzQ9MTA1NjtlLmFmaWkxMDAzNT0xMDU3O2UuYWZpaTEwMDM2PTEwNTg7ZS5hZmlpMTAwMzc9MTA1OTtlLmFmaWkxMDAzOD0xMDYwO2UuYWZpaTEwMDM5PTEwNjE7ZS5hZmlpMTAwNDA9MTA2MjtlLmFmaWkxMDA0MT0xMDYzO2UuYWZpaTEwMDQyPTEwNjQ7ZS5hZmlpMTAwNDM9MTA2NTtlLmFmaWkxMDA0ND0xMDY2O2UuYWZpaTEwMDQ1PTEwNjc7ZS5hZmlpMTAwNDY9MTA2ODtlLmFmaWkxMDA0Nz0xMDY5O2UuYWZpaTEwMDQ4PTEwNzA7ZS5hZmlpMTAwNDk9MTA3MTtlLmFmaWkxMDA1MD0xMTY4O2UuYWZpaTEwMDUxPTEwMjY7ZS5hZmlpMTAwNTI9MTAyNztlLmFmaWkxMDA1Mz0xMDI4O2UuYWZpaTEwMDU0PTEwMjk7ZS5hZmlpMTAwNTU9MTAzMDtlLmFmaWkxMDA1Nj0xMDMxO2UuYWZpaTEwMDU3PTEwMzI7ZS5hZmlpMTAwNTg9MTAzMztlLmFmaWkxMDA1OT0xMDM0O2UuYWZpaTEwMDYwPTEwMzU7ZS5hZmlpMTAwNjE9MTAzNjtlLmFmaWkxMDA2Mj0xMDM4O2UuYWZpaTEwMDYzPTYzMTcyO2UuYWZpaTEwMDY0PTYzMTczO2UuYWZpaTEwMDY1PTEwNzI7ZS5hZmlpMTAwNjY9MTA3MztlLmFmaWkxMDA2Nz0xMDc0O2UuYWZpaTEwMDY4PTEwNzU7ZS5hZmlpMTAwNjk9MTA3NjtlLmFmaWkxMDA3MD0xMDc3O2UuYWZpaTEwMDcxPTExMDU7ZS5hZmlpMTAwNzI9MTA3ODtlLmFmaWkxMDA3Mz0xMDc5O2UuYWZpaTEwMDc0PTEwODA7ZS5hZmlpMTAwNzU9MTA4MTtlLmFmaWkxMDA3Nj0xMDgyO2UuYWZpaTEwMDc3PTEwODM7ZS5hZmlpMTAwNzg9MTA4NDtlLmFmaWkxMDA3OT0xMDg1O2UuYWZpaTEwMDgwPTEwODY7ZS5hZmlpMTAwODE9MTA4NztlLmFmaWkxMDA4Mj0xMDg4O2UuYWZpaTEwMDgzPTEwODk7ZS5hZmlpMTAwODQ9MTA5MDtlLmFmaWkxMDA4NT0xMDkxO2UuYWZpaTEwMDg2PTEwOTI7ZS5hZmlpMTAwODc9MTA5MztlLmFmaWkxMDA4OD0xMDk0O2UuYWZpaTEwMDg5PTEwOTU7ZS5hZmlpMTAwOTA9MTA5NjtlLmFmaWkxMDA5MT0xMDk3O2UuYWZpaTEwMDkyPTEwOTg7ZS5hZmlpMTAwOTM9MTA5OTtlLmFmaWkxMDA5ND0xMTAwO2UuYWZpaTEwMDk1PTExMDE7ZS5hZmlpMTAwOTY9MTEwMjtlLmFmaWkxMDA5Nz0xMTAzO2UuYWZpaTEwMDk4PTExNjk7ZS5hZmlpMTAwOTk9MTEwNjtlLmFmaWkxMDEwMD0xMTA3O2UuYWZpaTEwMTAxPTExMDg7ZS5hZmlpMTAxMDI9MTEwOTtlLmFmaWkxMDEwMz0xMTEwO2UuYWZpaTEwMTA0PTExMTE7ZS5hZmlpMTAxMDU9MTExMjtlLmFmaWkxMDEwNj0xMTEzO2UuYWZpaTEwMTA3PTExMTQ7ZS5hZmlpMTAxMDg9MTExNTtlLmFmaWkxMDEwOT0xMTE2O2UuYWZpaTEwMTEwPTExMTg7ZS5hZmlpMTAxNDU9MTAzOTtlLmFmaWkxMDE0Nj0xMTIyO2UuYWZpaTEwMTQ3PTExMzg7ZS5hZmlpMTAxNDg9MTE0MDtlLmFmaWkxMDE5Mj02MzE3NDtlLmFmaWkxMDE5Mz0xMTE5O2UuYWZpaTEwMTk0PTExMjM7ZS5hZmlpMTAxOTU9MTEzOTtlLmFmaWkxMDE5Nj0xMTQxO2UuYWZpaTEwODMxPTYzMTc1O2UuYWZpaTEwODMyPTYzMTc2O2UuYWZpaTEwODQ2PTEyNDE7ZS5hZmlpMjk5PTgyMDY7ZS5hZmlpMzAwPTgyMDc7ZS5hZmlpMzAxPTgyMDU7ZS5hZmlpNTczODE9MTY0MjtlLmFmaWk1NzM4OD0xNTQ4O2UuYWZpaTU3MzkyPTE2MzI7ZS5hZmlpNTczOTM9MTYzMztlLmFmaWk1NzM5ND0xNjM0O2UuYWZpaTU3Mzk1PTE2MzU7ZS5hZmlpNTczOTY9MTYzNjtlLmFmaWk1NzM5Nz0xNjM3O2UuYWZpaTU3Mzk4PTE2Mzg7ZS5hZmlpNTczOTk9MTYzOTtlLmFmaWk1NzQwMD0xNjQwO2UuYWZpaTU3NDAxPTE2NDE7ZS5hZmlpNTc0MDM9MTU2MztlLmFmaWk1NzQwNz0xNTY3O2UuYWZpaTU3NDA5PTE1Njk7ZS5hZmlpNTc0MTA9MTU3MDtlLmFmaWk1NzQxMT0xNTcxO2UuYWZpaTU3NDEyPTE1NzI7ZS5hZmlpNTc0MTM9MTU3MztlLmFmaWk1NzQxND0xNTc0O2UuYWZpaTU3NDE1PTE1NzU7ZS5hZmlpNTc0MTY9MTU3NjtlLmFmaWk1NzQxNz0xNTc3O2UuYWZpaTU3NDE4PTE1Nzg7ZS5hZmlpNTc0MTk9MTU3OTtlLmFmaWk1NzQyMD0xNTgwO2UuYWZpaTU3NDIxPTE1ODE7ZS5hZmlpNTc0MjI9MTU4MjtlLmFmaWk1NzQyMz0xNTgzO2UuYWZpaTU3NDI0PTE1ODQ7ZS5hZmlpNTc0MjU9MTU4NTtlLmFmaWk1NzQyNj0xNTg2O2UuYWZpaTU3NDI3PTE1ODc7ZS5hZmlpNTc0Mjg9MTU4ODtlLmFmaWk1NzQyOT0xNTg5O2UuYWZpaTU3NDMwPTE1OTA7ZS5hZmlpNTc0MzE9MTU5MTtlLmFmaWk1NzQzMj0xNTkyO2UuYWZpaTU3NDMzPTE1OTM7ZS5hZmlpNTc0MzQ9MTU5NDtlLmFmaWk1NzQ0MD0xNjAwO2UuYWZpaTU3NDQxPTE2MDE7ZS5hZmlpNTc0NDI9MTYwMjtlLmFmaWk1NzQ0Mz0xNjAzO2UuYWZpaTU3NDQ0PTE2MDQ7ZS5hZmlpNTc0NDU9MTYwNTtlLmFmaWk1NzQ0Nj0xNjA2O2UuYWZpaTU3NDQ4PTE2MDg7ZS5hZmlpNTc0NDk9MTYwOTtlLmFmaWk1NzQ1MD0xNjEwO2UuYWZpaTU3NDUxPTE2MTE7ZS5hZmlpNTc0NTI9MTYxMjtlLmFmaWk1NzQ1Mz0xNjEzO2UuYWZpaTU3NDU0PTE2MTQ7ZS5hZmlpNTc0NTU9MTYxNTtlLmFmaWk1NzQ1Nj0xNjE2O2UuYWZpaTU3NDU3PTE2MTc7ZS5hZmlpNTc0NTg9MTYxODtlLmFmaWk1NzQ3MD0xNjA3O2UuYWZpaTU3NTA1PTE3MDA7ZS5hZmlpNTc1MDY9MTY2MjtlLmFmaWk1NzUwNz0xNjcwO2UuYWZpaTU3NTA4PTE2ODg7ZS5hZmlpNTc1MDk9MTcxMTtlLmFmaWk1NzUxMT0xNjU3O2UuYWZpaTU3NTEyPTE2NzI7ZS5hZmlpNTc1MTM9MTY4MTtlLmFmaWk1NzUxND0xNzIyO2UuYWZpaTU3NTE5PTE3NDY7ZS5hZmlpNTc1MzQ9MTc0OTtlLmFmaWk1NzYzNj04MzYyO2UuYWZpaTU3NjQ1PTE0NzA7ZS5hZmlpNTc2NTg9MTQ3NTtlLmFmaWk1NzY2ND0xNDg4O2UuYWZpaTU3NjY1PTE0ODk7ZS5hZmlpNTc2NjY9MTQ5MDtlLmFmaWk1NzY2Nz0xNDkxO2UuYWZpaTU3NjY4PTE0OTI7ZS5hZmlpNTc2Njk9MTQ5MztlLmFmaWk1NzY3MD0xNDk0O2UuYWZpaTU3NjcxPTE0OTU7ZS5hZmlpNTc2NzI9MTQ5NjtlLmFmaWk1NzY3Mz0xNDk3O2UuYWZpaTU3Njc0PTE0OTg7ZS5hZmlpNTc2NzU9MTQ5OTtlLmFmaWk1NzY3Nj0xNTAwO2UuYWZpaTU3Njc3PTE1MDE7ZS5hZmlpNTc2Nzg9MTUwMjtlLmFmaWk1NzY3OT0xNTAzO2UuYWZpaTU3NjgwPTE1MDQ7ZS5hZmlpNTc2ODE9MTUwNTtlLmFmaWk1NzY4Mj0xNTA2O2UuYWZpaTU3NjgzPTE1MDc7ZS5hZmlpNTc2ODQ9MTUwODtlLmFmaWk1NzY4NT0xNTA5O2UuYWZpaTU3Njg2PTE1MTA7ZS5hZmlpNTc2ODc9MTUxMTtlLmFmaWk1NzY4OD0xNTEyO2UuYWZpaTU3Njg5PTE1MTM7ZS5hZmlpNTc2OTA9MTUxNDtlLmFmaWk1NzY5ND02NDI5ODtlLmFmaWk1NzY5NT02NDI5OTtlLmFmaWk1NzcwMD02NDMzMTtlLmFmaWk1NzcwNT02NDI4NztlLmFmaWk1NzcxNj0xNTIwO2UuYWZpaTU3NzE3PTE1MjE7ZS5hZmlpNTc3MTg9MTUyMjtlLmFmaWk1NzcyMz02NDMwOTtlLmFmaWk1Nzc5Mz0xNDYwO2UuYWZpaTU3Nzk0PTE0NjE7ZS5hZmlpNTc3OTU9MTQ2MjtlLmFmaWk1Nzc5Nj0xNDY3O2UuYWZpaTU3Nzk3PTE0NjQ7ZS5hZmlpNTc3OTg9MTQ2MztlLmFmaWk1Nzc5OT0xNDU2O2UuYWZpaTU3ODAwPTE0NTg7ZS5hZmlpNTc4MDE9MTQ1NztlLmFmaWk1NzgwMj0xNDU5O2UuYWZpaTU3ODAzPTE0NzQ7ZS5hZmlpNTc4MDQ9MTQ3MztlLmFmaWk1NzgwNj0xNDY1O2UuYWZpaTU3ODA3PTE0Njg7ZS5hZmlpNTc4Mzk9MTQ2OTtlLmFmaWk1Nzg0MT0xNDcxO2UuYWZpaTU3ODQyPTE0NzI7ZS5hZmlpNTc5Mjk9NzAwO2UuYWZpaTYxMjQ4PTg0NTM7ZS5hZmlpNjEyODk9ODQ2NztlLmFmaWk2MTM1Mj04NDcwO2UuYWZpaTYxNTczPTgyMzY7ZS5hZmlpNjE1NzQ9ODIzNztlLmFmaWk2MTU3NT04MjM4O2UuYWZpaTYxNjY0PTgyMDQ7ZS5hZmlpNjMxNjc9MTY0NTtlLmFmaWk2NDkzNz03MDE7ZS5hZ3JhdmU9MjI0O2UuYWd1amFyYXRpPTI2OTM7ZS5hZ3VybXVraGk9MjU2NTtlLmFoaXJhZ2FuYT0xMjM1NDtlLmFob29rYWJvdmU9Nzg0MztlLmFpYmVuZ2FsaT0yNDQ4O2UuYWlib3BvbW9mbz0xMjU3NDtlLmFpZGV2YT0yMzIwO2UuYWllY3lyaWxsaWM9MTIzNztlLmFpZ3VqYXJhdGk9MjcwNDtlLmFpZ3VybXVraGk9MjU3NjtlLmFpbWF0cmFndXJtdWtoaT0yNjMyO2UuYWluYXJhYmljPTE1OTM7ZS5haW5maW5hbGFyYWJpYz02NTIyNjtlLmFpbmluaXRpYWxhcmFiaWM9NjUyMjc7ZS5haW5tZWRpYWxhcmFiaWM9NjUyMjg7ZS5haW52ZXJ0ZWRicmV2ZT01MTU7ZS5haXZvd2Vsc2lnbmJlbmdhbGk9MjUwNDtlLmFpdm93ZWxzaWduZGV2YT0yMzc2O2UuYWl2b3dlbHNpZ25ndWphcmF0aT0yNzYwO2UuYWthdGFrYW5hPTEyNDUwO2UuYWthdGFrYW5haGFsZndpZHRoPTY1MzkzO2UuYWtvcmVhbj0xMjYyMztlLmFsZWY9MTQ4ODtlLmFsZWZhcmFiaWM9MTU3NTtlLmFsZWZkYWdlc2hoZWJyZXc9NjQzMDQ7ZS5hbGVmZmluYWxhcmFiaWM9NjUxNjY7ZS5hbGVmaGFtemFhYm92ZWFyYWJpYz0xNTcxO2UuYWxlZmhhbXphYWJvdmVmaW5hbGFyYWJpYz02NTE1NjtlLmFsZWZoYW16YWJlbG93YXJhYmljPTE1NzM7ZS5hbGVmaGFtemFiZWxvd2ZpbmFsYXJhYmljPTY1MTYwO2UuYWxlZmhlYnJldz0xNDg4O2UuYWxlZmxhbWVkaGVicmV3PTY0MzM1O2UuYWxlZm1hZGRhYWJvdmVhcmFiaWM9MTU3MDtlLmFsZWZtYWRkYWFib3ZlZmluYWxhcmFiaWM9NjUxNTQ7ZS5hbGVmbWFrc3VyYWFyYWJpYz0xNjA5O2UuYWxlZm1ha3N1cmFmaW5hbGFyYWJpYz02NTI2NDtlLmFsZWZtYWtzdXJhaW5pdGlhbGFyYWJpYz02NTI2NztlLmFsZWZtYWtzdXJhbWVkaWFsYXJhYmljPTY1MjY4O2UuYWxlZnBhdGFoaGVicmV3PTY0MzAyO2UuYWxlZnFhbWF0c2hlYnJldz02NDMwMztlLmFsZXBoPTg1MDE7ZS5hbGxlcXVhbD04NzgwO2UuYWxwaGE9OTQ1O2UuYWxwaGF0b25vcz05NDA7ZS5hbWFjcm9uPTI1NztlLmFtb25vc3BhY2U9NjUzNDU7ZS5hbXBlcnNhbmQ9Mzg7ZS5hbXBlcnNhbmRtb25vc3BhY2U9NjUyODY7ZS5hbXBlcnNhbmRzbWFsbD02MzI3MDtlLmFtc3F1YXJlPTEzMjUwO2UuYW5ib3BvbW9mbz0xMjU3ODtlLmFuZ2JvcG9tb2ZvPTEyNTgwO2UuYW5nYnJhY2tldGxlZnQ9MTIyOTY7ZS5hbmdicmFja2V0cmlnaHQ9MTIyOTc7ZS5hbmdraGFua2h1dGhhaT0zNjc0O2UuYW5nbGU9ODczNjtlLmFuZ2xlYnJhY2tldGxlZnQ9MTIyOTY7ZS5hbmdsZWJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODc7ZS5hbmdsZWJyYWNrZXRyaWdodD0xMjI5NztlLmFuZ2xlYnJhY2tldHJpZ2h0dmVydGljYWw9NjUwODg7ZS5hbmdsZWxlZnQ9OTAwMTtlLmFuZ2xlcmlnaHQ9OTAwMjtlLmFuZ3N0cm9tPTg0OTE7ZS5hbm90ZWxlaWE9OTAzO2UuYW51ZGF0dGFkZXZhPTIzODY7ZS5hbnVzdmFyYWJlbmdhbGk9MjQzNDtlLmFudXN2YXJhZGV2YT0yMzA2O2UuYW51c3ZhcmFndWphcmF0aT0yNjkwO2UuYW9nb25laz0yNjE7ZS5hcGFhdG9zcXVhcmU9MTMwNTY7ZS5hcGFyZW49OTM3MjtlLmFwb3N0cm9waGVhcm1lbmlhbj0xMzcwO2UuYXBvc3Ryb3BoZW1vZD03MDA7ZS5hcHBsZT02Mzc0MztlLmFwcHJvYWNoZXM9ODc4NDtlLmFwcHJveGVxdWFsPTg3NzY7ZS5hcHByb3hlcXVhbG9yaW1hZ2U9ODc4NjtlLmFwcHJveGltYXRlbHllcXVhbD04NzczO2UuYXJhZWFla29yZWFuPTEyNjg2O2UuYXJhZWFrb3JlYW49MTI2ODU7ZS5hcmM9ODk3ODtlLmFyaWdodGhhbGZyaW5nPTc4MzQ7ZS5hcmluZz0yMjk7ZS5hcmluZ2FjdXRlPTUwNztlLmFyaW5nYmVsb3c9NzY4MTtlLmFycm93Ym90aD04NTk2O2UuYXJyb3dkYXNoZG93bj04Njc1O2UuYXJyb3dkYXNobGVmdD04NjcyO2UuYXJyb3dkYXNocmlnaHQ9ODY3NDtlLmFycm93ZGFzaHVwPTg2NzM7ZS5hcnJvd2RibGJvdGg9ODY2MDtlLmFycm93ZGJsZG93bj04NjU5O2UuYXJyb3dkYmxsZWZ0PTg2NTY7ZS5hcnJvd2RibHJpZ2h0PTg2NTg7ZS5hcnJvd2RibHVwPTg2NTc7ZS5hcnJvd2Rvd249ODU5NTtlLmFycm93ZG93bmxlZnQ9ODYwMTtlLmFycm93ZG93bnJpZ2h0PTg2MDA7ZS5hcnJvd2Rvd253aGl0ZT04NjgxO2UuYXJyb3doZWFkZG93bm1vZD03MDk7ZS5hcnJvd2hlYWRsZWZ0bW9kPTcwNjtlLmFycm93aGVhZHJpZ2h0bW9kPTcwNztlLmFycm93aGVhZHVwbW9kPTcwODtlLmFycm93aG9yaXpleD02MzcxOTtlLmFycm93bGVmdD04NTkyO2UuYXJyb3dsZWZ0ZGJsPTg2NTY7ZS5hcnJvd2xlZnRkYmxzdHJva2U9ODY1MztlLmFycm93bGVmdG92ZXJyaWdodD04NjQ2O2UuYXJyb3dsZWZ0d2hpdGU9ODY3ODtlLmFycm93cmlnaHQ9ODU5NDtlLmFycm93cmlnaHRkYmxzdHJva2U9ODY1NTtlLmFycm93cmlnaHRoZWF2eT0xMDE0MjtlLmFycm93cmlnaHRvdmVybGVmdD04NjQ0O2UuYXJyb3dyaWdodHdoaXRlPTg2ODA7ZS5hcnJvd3RhYmxlZnQ9ODY3NjtlLmFycm93dGFicmlnaHQ9ODY3NztlLmFycm93dXA9ODU5MztlLmFycm93dXBkbj04NTk3O2UuYXJyb3d1cGRuYnNlPTg2MTY7ZS5hcnJvd3VwZG93bmJhc2U9ODYxNjtlLmFycm93dXBsZWZ0PTg1OTg7ZS5hcnJvd3VwbGVmdG9mZG93bj04NjQ1O2UuYXJyb3d1cHJpZ2h0PTg1OTk7ZS5hcnJvd3Vwd2hpdGU9ODY3OTtlLmFycm93dmVydGV4PTYzNzE4O2UuYXNjaWljaXJjdW09OTQ7ZS5hc2NpaWNpcmN1bW1vbm9zcGFjZT02NTM0MjtlLmFzY2lpdGlsZGU9MTI2O2UuYXNjaWl0aWxkZW1vbm9zcGFjZT02NTM3NDtlLmFzY3JpcHQ9NTkzO2UuYXNjcmlwdHR1cm5lZD01OTQ7ZS5hc21hbGxoaXJhZ2FuYT0xMjM1MztlLmFzbWFsbGthdGFrYW5hPTEyNDQ5O2UuYXNtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODM7ZS5hc3Rlcmlzaz00MjtlLmFzdGVyaXNrYWx0b25lYXJhYmljPTE2NDU7ZS5hc3Rlcmlza2FyYWJpYz0xNjQ1O2UuYXN0ZXJpc2ttYXRoPTg3Mjc7ZS5hc3Rlcmlza21vbm9zcGFjZT02NTI5MDtlLmFzdGVyaXNrc21hbGw9NjUxMjE7ZS5hc3RlcmlzbT04MjU4O2UuYXN1cGVyaW9yPTYzMjA5O2UuYXN5bXB0b3RpY2FsbHllcXVhbD04NzcxO2UuYXQ9NjQ7ZS5hdGlsZGU9MjI3O2UuYXRtb25vc3BhY2U9NjUzMTI7ZS5hdHNtYWxsPTY1MTMxO2UuYXR1cm5lZD01OTI7ZS5hdWJlbmdhbGk9MjQ1MjtlLmF1Ym9wb21vZm89MTI1NzY7ZS5hdWRldmE9MjMyNDtlLmF1Z3VqYXJhdGk9MjcwODtlLmF1Z3VybXVraGk9MjU4MDtlLmF1bGVuZ3RobWFya2JlbmdhbGk9MjUxOTtlLmF1bWF0cmFndXJtdWtoaT0yNjM2O2UuYXV2b3dlbHNpZ25iZW5nYWxpPTI1MDg7ZS5hdXZvd2Vsc2lnbmRldmE9MjM4MDtlLmF1dm93ZWxzaWduZ3VqYXJhdGk9Mjc2NDtlLmF2YWdyYWhhZGV2YT0yMzY1O2UuYXliYXJtZW5pYW49MTM3NztlLmF5aW49MTUwNjtlLmF5aW5hbHRvbmVoZWJyZXc9NjQyODg7ZS5heWluaGVicmV3PTE1MDY7ZS5iPTk4O2UuYmFiZW5nYWxpPTI0NzY7ZS5iYWNrc2xhc2g9OTI7ZS5iYWNrc2xhc2htb25vc3BhY2U9NjUzNDA7ZS5iYWRldmE9MjM0ODtlLmJhZ3VqYXJhdGk9MjczMjtlLmJhZ3VybXVraGk9MjYwNDtlLmJhaGlyYWdhbmE9MTI0MDA7ZS5iYWh0dGhhaT0zNjQ3O2UuYmFrYXRha2FuYT0xMjQ5NjtlLmJhcj0xMjQ7ZS5iYXJtb25vc3BhY2U9NjUzNzI7ZS5iYm9wb21vZm89MTI1NDk7ZS5iY2lyY2xlPTk0MjU7ZS5iZG90YWNjZW50PTc2ODM7ZS5iZG90YmVsb3c9NzY4NTtlLmJlYW1lZHNpeHRlZW50aG5vdGVzPTk4MzY7ZS5iZWNhdXNlPTg3NTc7ZS5iZWN5cmlsbGljPTEwNzM7ZS5iZWhhcmFiaWM9MTU3NjtlLmJlaGZpbmFsYXJhYmljPTY1MTY4O2UuYmVoaW5pdGlhbGFyYWJpYz02NTE2OTtlLmJlaGlyYWdhbmE9MTI0MDk7ZS5iZWhtZWRpYWxhcmFiaWM9NjUxNzA7ZS5iZWhtZWVtaW5pdGlhbGFyYWJpYz02NDY3MTtlLmJlaG1lZW1pc29sYXRlZGFyYWJpYz02NDUyMDtlLmJlaG5vb25maW5hbGFyYWJpYz02NDYyMTtlLmJla2F0YWthbmE9MTI1MDU7ZS5iZW5hcm1lbmlhbj0xMzc4O2UuYmV0PTE0ODk7ZS5iZXRhPTk0NjtlLmJldGFzeW1ib2xncmVlaz05NzY7ZS5iZXRkYWdlc2g9NjQzMDU7ZS5iZXRkYWdlc2hoZWJyZXc9NjQzMDU7ZS5iZXRoZWJyZXc9MTQ4OTtlLmJldHJhZmVoZWJyZXc9NjQzMzI7ZS5iaGFiZW5nYWxpPTI0Nzc7ZS5iaGFkZXZhPTIzNDk7ZS5iaGFndWphcmF0aT0yNzMzO2UuYmhhZ3VybXVraGk9MjYwNTtlLmJob29rPTU5NTtlLmJpaGlyYWdhbmE9MTI0MDM7ZS5iaWthdGFrYW5hPTEyNDk5O2UuYmlsYWJpYWxjbGljaz02NjQ7ZS5iaW5kaWd1cm11a2hpPTI1NjI7ZS5iaXJ1c3F1YXJlPTEzMTA1O2UuYmxhY2tjaXJjbGU9OTY3OTtlLmJsYWNrZGlhbW9uZD05NjcwO2UuYmxhY2tkb3ducG9pbnRpbmd0cmlhbmdsZT05NjYwO2UuYmxhY2tsZWZ0cG9pbnRpbmdwb2ludGVyPTk2Njg7ZS5ibGFja2xlZnRwb2ludGluZ3RyaWFuZ2xlPTk2NjQ7ZS5ibGFja2xlbnRpY3VsYXJicmFja2V0bGVmdD0xMjMwNDtlLmJsYWNrbGVudGljdWxhcmJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODM7ZS5ibGFja2xlbnRpY3VsYXJicmFja2V0cmlnaHQ9MTIzMDU7ZS5ibGFja2xlbnRpY3VsYXJicmFja2V0cmlnaHR2ZXJ0aWNhbD02NTA4NDtlLmJsYWNrbG93ZXJsZWZ0dHJpYW5nbGU9OTY5OTtlLmJsYWNrbG93ZXJyaWdodHRyaWFuZ2xlPTk2OTg7ZS5ibGFja3JlY3RhbmdsZT05NjQ0O2UuYmxhY2tyaWdodHBvaW50aW5ncG9pbnRlcj05NjU4O2UuYmxhY2tyaWdodHBvaW50aW5ndHJpYW5nbGU9OTY1NDtlLmJsYWNrc21hbGxzcXVhcmU9OTY0MjtlLmJsYWNrc21pbGluZ2ZhY2U9OTc4NztlLmJsYWNrc3F1YXJlPTk2MzI7ZS5ibGFja3N0YXI9OTczMztlLmJsYWNrdXBwZXJsZWZ0dHJpYW5nbGU9OTcwMDtlLmJsYWNrdXBwZXJyaWdodHRyaWFuZ2xlPTk3MDE7ZS5ibGFja3VwcG9pbnRpbmdzbWFsbHRyaWFuZ2xlPTk2NTI7ZS5ibGFja3VwcG9pbnRpbmd0cmlhbmdsZT05NjUwO2UuYmxhbms9OTI1MTtlLmJsaW5lYmVsb3c9NzY4NztlLmJsb2NrPTk2MDg7ZS5ibW9ub3NwYWNlPTY1MzQ2O2UuYm9iYWltYWl0aGFpPTM2MTA7ZS5ib2hpcmFnYW5hPTEyNDEyO2UuYm9rYXRha2FuYT0xMjUwODtlLmJwYXJlbj05MzczO2UuYnFzcXVhcmU9MTMyNTE7ZS5icmFjZWV4PTYzNzMyO2UuYnJhY2VsZWZ0PTEyMztlLmJyYWNlbGVmdGJ0PTYzNzMxO2UuYnJhY2VsZWZ0bWlkPTYzNzMwO2UuYnJhY2VsZWZ0bW9ub3NwYWNlPTY1MzcxO2UuYnJhY2VsZWZ0c21hbGw9NjUxMTU7ZS5icmFjZWxlZnR0cD02MzcyOTtlLmJyYWNlbGVmdHZlcnRpY2FsPTY1MDc5O2UuYnJhY2VyaWdodD0xMjU7ZS5icmFjZXJpZ2h0YnQ9NjM3NDI7ZS5icmFjZXJpZ2h0bWlkPTYzNzQxO2UuYnJhY2VyaWdodG1vbm9zcGFjZT02NTM3MztlLmJyYWNlcmlnaHRzbWFsbD02NTExNjtlLmJyYWNlcmlnaHR0cD02Mzc0MDtlLmJyYWNlcmlnaHR2ZXJ0aWNhbD02NTA4MDtlLmJyYWNrZXRsZWZ0PTkxO2UuYnJhY2tldGxlZnRidD02MzcyODtlLmJyYWNrZXRsZWZ0ZXg9NjM3Mjc7ZS5icmFja2V0bGVmdG1vbm9zcGFjZT02NTMzOTtlLmJyYWNrZXRsZWZ0dHA9NjM3MjY7ZS5icmFja2V0cmlnaHQ9OTM7ZS5icmFja2V0cmlnaHRidD02MzczOTtlLmJyYWNrZXRyaWdodGV4PTYzNzM4O2UuYnJhY2tldHJpZ2h0bW9ub3NwYWNlPTY1MzQxO2UuYnJhY2tldHJpZ2h0dHA9NjM3Mzc7ZS5icmV2ZT03Mjg7ZS5icmV2ZWJlbG93Y21iPTgxNDtlLmJyZXZlY21iPTc3NDtlLmJyZXZlaW52ZXJ0ZWRiZWxvd2NtYj04MTU7ZS5icmV2ZWludmVydGVkY21iPTc4NTtlLmJyZXZlaW52ZXJ0ZWRkb3VibGVjbWI9ODY1O2UuYnJpZGdlYmVsb3djbWI9ODEwO2UuYnJpZGdlaW52ZXJ0ZWRiZWxvd2NtYj04MjY7ZS5icm9rZW5iYXI9MTY2O2UuYnN0cm9rZT0zODQ7ZS5ic3VwZXJpb3I9NjMyMTA7ZS5idG9wYmFyPTM4NztlLmJ1aGlyYWdhbmE9MTI0MDY7ZS5idWthdGFrYW5hPTEyNTAyO2UuYnVsbGV0PTgyMjY7ZS5idWxsZXRpbnZlcnNlPTk2ODg7ZS5idWxsZXRvcGVyYXRvcj04NzI5O2UuYnVsbHNleWU9OTY3ODtlLmM9OTk7ZS5jYWFybWVuaWFuPTEzOTA7ZS5jYWJlbmdhbGk9MjQ1ODtlLmNhY3V0ZT0yNjM7ZS5jYWRldmE9MjMzMDtlLmNhZ3VqYXJhdGk9MjcxNDtlLmNhZ3VybXVraGk9MjU4NjtlLmNhbHNxdWFyZT0xMzE5MjtlLmNhbmRyYWJpbmR1YmVuZ2FsaT0yNDMzO2UuY2FuZHJhYmluZHVjbWI9Nzg0O2UuY2FuZHJhYmluZHVkZXZhPTIzMDU7ZS5jYW5kcmFiaW5kdWd1amFyYXRpPTI2ODk7ZS5jYXBzbG9jaz04NjgyO2UuY2FyZW9mPTg0NTM7ZS5jYXJvbj03MTE7ZS5jYXJvbmJlbG93Y21iPTgxMjtlLmNhcm9uY21iPTc4MDtlLmNhcnJpYWdlcmV0dXJuPTg2Mjk7ZS5jYm9wb21vZm89MTI1Njg7ZS5jY2Fyb249MjY5O2UuY2NlZGlsbGE9MjMxO2UuY2NlZGlsbGFhY3V0ZT03Njg5O2UuY2NpcmNsZT05NDI2O2UuY2NpcmN1bWZsZXg9MjY1O2UuY2N1cmw9NTk3O2UuY2RvdD0yNjc7ZS5jZG90YWNjZW50PTI2NztlLmNkc3F1YXJlPTEzMjUzO2UuY2VkaWxsYT0xODQ7ZS5jZWRpbGxhY21iPTgwNztlLmNlbnQ9MTYyO2UuY2VudGlncmFkZT04NDUxO2UuY2VudGluZmVyaW9yPTYzMTk5O2UuY2VudG1vbm9zcGFjZT02NTUwNDtlLmNlbnRvbGRzdHlsZT02MzM5NDtlLmNlbnRzdXBlcmlvcj02MzIwMDtlLmNoYWFybWVuaWFuPTE0MDE7ZS5jaGFiZW5nYWxpPTI0NTk7ZS5jaGFkZXZhPTIzMzE7ZS5jaGFndWphcmF0aT0yNzE1O2UuY2hhZ3VybXVraGk9MjU4NztlLmNoYm9wb21vZm89MTI1NjQ7ZS5jaGVhYmtoYXNpYW5jeXJpbGxpYz0xMjEzO2UuY2hlY2ttYXJrPTEwMDAzO2UuY2hlY3lyaWxsaWM9MTA5NTtlLmNoZWRlc2NlbmRlcmFia2hhc2lhbmN5cmlsbGljPTEyMTU7ZS5jaGVkZXNjZW5kZXJjeXJpbGxpYz0xMjA3O2UuY2hlZGllcmVzaXNjeXJpbGxpYz0xMjY5O2UuY2hlaGFybWVuaWFuPTEzOTU7ZS5jaGVraGFrYXNzaWFuY3lyaWxsaWM9MTIyODtlLmNoZXZlcnRpY2Fsc3Ryb2tlY3lyaWxsaWM9MTIwOTtlLmNoaT05Njc7ZS5jaGlldWNoYWNpcmNsZWtvcmVhbj0xMjkxOTtlLmNoaWV1Y2hhcGFyZW5rb3JlYW49MTI4MjM7ZS5jaGlldWNoY2lyY2xla29yZWFuPTEyOTA1O2UuY2hpZXVjaGtvcmVhbj0xMjYxODtlLmNoaWV1Y2hwYXJlbmtvcmVhbj0xMjgwOTtlLmNob2NoYW5ndGhhaT0zNTk0O2UuY2hvY2hhbnRoYWk9MzU5MjtlLmNob2NoaW5ndGhhaT0zNTkzO2UuY2hvY2hvZXRoYWk9MzU5NjtlLmNob29rPTM5MjtlLmNpZXVjYWNpcmNsZWtvcmVhbj0xMjkxODtlLmNpZXVjYXBhcmVua29yZWFuPTEyODIyO2UuY2lldWNjaXJjbGVrb3JlYW49MTI5MDQ7ZS5jaWV1Y2tvcmVhbj0xMjYxNjtlLmNpZXVjcGFyZW5rb3JlYW49MTI4MDg7ZS5jaWV1Y3VwYXJlbmtvcmVhbj0xMjgyODtlLmNpcmNsZT05Njc1O2UuY2lyY2xlY29weXJ0PTE2OTtlLmNpcmNsZW11bHRpcGx5PTg4NTU7ZS5jaXJjbGVvdD04ODU3O2UuY2lyY2xlcGx1cz04ODUzO2UuY2lyY2xlcG9zdGFsbWFyaz0xMjM0MjtlLmNpcmNsZXdpdGhsZWZ0aGFsZmJsYWNrPTk2ODA7ZS5jaXJjbGV3aXRocmlnaHRoYWxmYmxhY2s9OTY4MTtlLmNpcmN1bWZsZXg9NzEwO2UuY2lyY3VtZmxleGJlbG93Y21iPTgxMztlLmNpcmN1bWZsZXhjbWI9NzcwO2UuY2xlYXI9ODk5OTtlLmNsaWNrYWx2ZW9sYXI9NDUwO2UuY2xpY2tkZW50YWw9NDQ4O2UuY2xpY2tsYXRlcmFsPTQ0OTtlLmNsaWNrcmV0cm9mbGV4PTQ1MTtlLmNsdWI9OTgyNztlLmNsdWJzdWl0YmxhY2s9OTgyNztlLmNsdWJzdWl0d2hpdGU9OTgzMTtlLmNtY3ViZWRzcXVhcmU9MTMyMjA7ZS5jbW9ub3NwYWNlPTY1MzQ3O2UuY21zcXVhcmVkc3F1YXJlPTEzMjE2O2UuY29hcm1lbmlhbj0xNDA5O2UuY29sb249NTg7ZS5jb2xvbm1vbmV0YXJ5PTgzNTM7ZS5jb2xvbm1vbm9zcGFjZT02NTMwNjtlLmNvbG9uc2lnbj04MzUzO2UuY29sb25zbWFsbD02NTEwOTtlLmNvbG9udHJpYW5ndWxhcmhhbGZtb2Q9NzIxO2UuY29sb250cmlhbmd1bGFybW9kPTcyMDtlLmNvbW1hPTQ0O2UuY29tbWFhYm92ZWNtYj03ODc7ZS5jb21tYWFib3ZlcmlnaHRjbWI9Nzg5O2UuY29tbWFhY2NlbnQ9NjMxNzE7ZS5jb21tYWFyYWJpYz0xNTQ4O2UuY29tbWFhcm1lbmlhbj0xMzczO2UuY29tbWFpbmZlcmlvcj02MzIwMTtlLmNvbW1hbW9ub3NwYWNlPTY1MjkyO2UuY29tbWFyZXZlcnNlZGFib3ZlY21iPTc4ODtlLmNvbW1hcmV2ZXJzZWRtb2Q9NzAxO2UuY29tbWFzbWFsbD02NTEwNDtlLmNvbW1hc3VwZXJpb3I9NjMyMDI7ZS5jb21tYXR1cm5lZGFib3ZlY21iPTc4NjtlLmNvbW1hdHVybmVkbW9kPTY5OTtlLmNvbXBhc3M9OTc4ODtlLmNvbmdydWVudD04NzczO2UuY29udG91cmludGVncmFsPTg3NTA7ZS5jb250cm9sPTg5NjM7ZS5jb250cm9sQUNLPTY7ZS5jb250cm9sQkVMPTc7ZS5jb250cm9sQlM9ODtlLmNvbnRyb2xDQU49MjQ7ZS5jb250cm9sQ1I9MTM7ZS5jb250cm9sREMxPTE3O2UuY29udHJvbERDMj0xODtlLmNvbnRyb2xEQzM9MTk7ZS5jb250cm9sREM0PTIwO2UuY29udHJvbERFTD0xMjc7ZS5jb250cm9sRExFPTE2O2UuY29udHJvbEVNPTI1O2UuY29udHJvbEVOUT01O2UuY29udHJvbEVPVD00O2UuY29udHJvbEVTQz0yNztlLmNvbnRyb2xFVEI9MjM7ZS5jb250cm9sRVRYPTM7ZS5jb250cm9sRkY9MTI7ZS5jb250cm9sRlM9Mjg7ZS5jb250cm9sR1M9Mjk7ZS5jb250cm9sSFQ9OTtlLmNvbnRyb2xMRj0xMDtlLmNvbnRyb2xOQUs9MjE7ZS5jb250cm9sTlVMTD0wO2UuY29udHJvbFJTPTMwO2UuY29udHJvbFNJPTE1O2UuY29udHJvbFNPPTE0O2UuY29udHJvbFNPVD0yO2UuY29udHJvbFNUWD0xO2UuY29udHJvbFNVQj0yNjtlLmNvbnRyb2xTWU49MjI7ZS5jb250cm9sVVM9MzE7ZS5jb250cm9sVlQ9MTE7ZS5jb3B5cmlnaHQ9MTY5O2UuY29weXJpZ2h0c2Fucz02MzcyMTtlLmNvcHlyaWdodHNlcmlmPTYzMTkzO2UuY29ybmVyYnJhY2tldGxlZnQ9MTIzMDA7ZS5jb3JuZXJicmFja2V0bGVmdGhhbGZ3aWR0aD02NTM3ODtlLmNvcm5lcmJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODk7ZS5jb3JuZXJicmFja2V0cmlnaHQ9MTIzMDE7ZS5jb3JuZXJicmFja2V0cmlnaHRoYWxmd2lkdGg9NjUzNzk7ZS5jb3JuZXJicmFja2V0cmlnaHR2ZXJ0aWNhbD02NTA5MDtlLmNvcnBvcmF0aW9uc3F1YXJlPTEzMTgzO2UuY29zcXVhcmU9MTMyNTU7ZS5jb3Zlcmtnc3F1YXJlPTEzMjU0O2UuY3BhcmVuPTkzNzQ7ZS5jcnV6ZWlybz04MzU0O2UuY3N0cmV0Y2hlZD02NjM7ZS5jdXJseWFuZD04OTExO2UuY3VybHlvcj04OTEwO2UuY3VycmVuY3k9MTY0O2UuY3lyQnJldmU9NjMxODU7ZS5jeXJGbGV4PTYzMTg2O2UuY3lyYnJldmU9NjMxODg7ZS5jeXJmbGV4PTYzMTg5O2UuZD0xMDA7ZS5kYWFybWVuaWFuPTEzODA7ZS5kYWJlbmdhbGk9MjQ3MDtlLmRhZGFyYWJpYz0xNTkwO2UuZGFkZXZhPTIzNDI7ZS5kYWRmaW5hbGFyYWJpYz02NTIxNDtlLmRhZGluaXRpYWxhcmFiaWM9NjUyMTU7ZS5kYWRtZWRpYWxhcmFiaWM9NjUyMTY7ZS5kYWdlc2g9MTQ2ODtlLmRhZ2VzaGhlYnJldz0xNDY4O2UuZGFnZ2VyPTgyMjQ7ZS5kYWdnZXJkYmw9ODIyNTtlLmRhZ3VqYXJhdGk9MjcyNjtlLmRhZ3VybXVraGk9MjU5ODtlLmRhaGlyYWdhbmE9MTIzODQ7ZS5kYWthdGFrYW5hPTEyNDgwO2UuZGFsYXJhYmljPTE1ODM7ZS5kYWxldD0xNDkxO2UuZGFsZXRkYWdlc2g9NjQzMDc7ZS5kYWxldGRhZ2VzaGhlYnJldz02NDMwNztlLmRhbGV0aGVicmV3PTE0OTE7ZS5kYWxmaW5hbGFyYWJpYz02NTE5NDtlLmRhbW1hYXJhYmljPTE2MTU7ZS5kYW1tYWxvd2FyYWJpYz0xNjE1O2UuZGFtbWF0YW5hbHRvbmVhcmFiaWM9MTYxMjtlLmRhbW1hdGFuYXJhYmljPTE2MTI7ZS5kYW5kYT0yNDA0O2UuZGFyZ2FoZWJyZXc9MTQ0NztlLmRhcmdhbGVmdGhlYnJldz0xNDQ3O2UuZGFzaWFwbmV1bWF0YWN5cmlsbGljY21iPTExNTc7ZS5kYmxHcmF2ZT02MzE4NztlLmRibGFuZ2xlYnJhY2tldGxlZnQ9MTIyOTg7ZS5kYmxhbmdsZWJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODU7ZS5kYmxhbmdsZWJyYWNrZXRyaWdodD0xMjI5OTtlLmRibGFuZ2xlYnJhY2tldHJpZ2h0dmVydGljYWw9NjUwODY7ZS5kYmxhcmNoaW52ZXJ0ZWRiZWxvd2NtYj04MTE7ZS5kYmxhcnJvd2xlZnQ9ODY2MDtlLmRibGFycm93cmlnaHQ9ODY1ODtlLmRibGRhbmRhPTI0MDU7ZS5kYmxncmF2ZT02MzE5MDtlLmRibGdyYXZlY21iPTc4MztlLmRibGludGVncmFsPTg3NDg7ZS5kYmxsb3dsaW5lPTgyMTU7ZS5kYmxsb3dsaW5lY21iPTgxOTtlLmRibG92ZXJsaW5lY21iPTgzMTtlLmRibHByaW1lbW9kPTY5ODtlLmRibHZlcnRpY2FsYmFyPTgyMTQ7ZS5kYmx2ZXJ0aWNhbGxpbmVhYm92ZWNtYj03ODI7ZS5kYm9wb21vZm89MTI1NTM7ZS5kYnNxdWFyZT0xMzI1NjtlLmRjYXJvbj0yNzE7ZS5kY2VkaWxsYT03Njk3O2UuZGNpcmNsZT05NDI3O2UuZGNpcmN1bWZsZXhiZWxvdz03Njk5O2UuZGNyb2F0PTI3MztlLmRkYWJlbmdhbGk9MjQ2NTtlLmRkYWRldmE9MjMzNztlLmRkYWd1amFyYXRpPTI3MjE7ZS5kZGFndXJtdWtoaT0yNTkzO2UuZGRhbGFyYWJpYz0xNjcyO2UuZGRhbGZpbmFsYXJhYmljPTY0MzkzO2UuZGRkaGFkZXZhPTIzOTY7ZS5kZGhhYmVuZ2FsaT0yNDY2O2UuZGRoYWRldmE9MjMzODtlLmRkaGFndWphcmF0aT0yNzIyO2UuZGRoYWd1cm11a2hpPTI1OTQ7ZS5kZG90YWNjZW50PTc2OTE7ZS5kZG90YmVsb3c9NzY5MztlLmRlY2ltYWxzZXBhcmF0b3JhcmFiaWM9MTY0MztlLmRlY2ltYWxzZXBhcmF0b3JwZXJzaWFuPTE2NDM7ZS5kZWN5cmlsbGljPTEwNzY7ZS5kZWdyZWU9MTc2O2UuZGVoaWhlYnJldz0xNDUzO2UuZGVoaXJhZ2FuYT0xMjM5MTtlLmRlaWNvcHRpYz0xMDA3O2UuZGVrYXRha2FuYT0xMjQ4NztlLmRlbGV0ZWxlZnQ9OTAwMztlLmRlbGV0ZXJpZ2h0PTg5OTg7ZS5kZWx0YT05NDg7ZS5kZWx0YXR1cm5lZD0zOTc7ZS5kZW5vbWluYXRvcm1pbnVzb25lbnVtZXJhdG9yYmVuZ2FsaT0yNTUyO2UuZGV6aD02NzY7ZS5kaGFiZW5nYWxpPTI0NzE7ZS5kaGFkZXZhPTIzNDM7ZS5kaGFndWphcmF0aT0yNzI3O2UuZGhhZ3VybXVraGk9MjU5OTtlLmRob29rPTU5OTtlLmRpYWx5dGlrYXRvbm9zPTkwMTtlLmRpYWx5dGlrYXRvbm9zY21iPTgzNjtlLmRpYW1vbmQ9OTgzMDtlLmRpYW1vbmRzdWl0d2hpdGU9OTgyNjtlLmRpZXJlc2lzPTE2ODtlLmRpZXJlc2lzYWN1dGU9NjMxOTE7ZS5kaWVyZXNpc2JlbG93Y21iPTgwNDtlLmRpZXJlc2lzY21iPTc3NjtlLmRpZXJlc2lzZ3JhdmU9NjMxOTI7ZS5kaWVyZXNpc3Rvbm9zPTkwMTtlLmRpaGlyYWdhbmE9MTIzODY7ZS5kaWthdGFrYW5hPTEyNDgyO2UuZGl0dG9tYXJrPTEyMjkxO2UuZGl2aWRlPTI0NztlLmRpdmlkZXM9ODczOTtlLmRpdmlzaW9uc2xhc2g9ODcyNTtlLmRqZWN5cmlsbGljPTExMDY7ZS5ka3NoYWRlPTk2MTk7ZS5kbGluZWJlbG93PTc2OTU7ZS5kbHNxdWFyZT0xMzIwNztlLmRtYWNyb249MjczO2UuZG1vbm9zcGFjZT02NTM0ODtlLmRuYmxvY2s9OTYwNDtlLmRvY2hhZGF0aGFpPTM1OTg7ZS5kb2Rla3RoYWk9MzYwNDtlLmRvaGlyYWdhbmE9MTIzOTM7ZS5kb2thdGFrYW5hPTEyNDg5O2UuZG9sbGFyPTM2O2UuZG9sbGFyaW5mZXJpb3I9NjMyMDM7ZS5kb2xsYXJtb25vc3BhY2U9NjUyODQ7ZS5kb2xsYXJvbGRzdHlsZT02MzI2ODtlLmRvbGxhcnNtYWxsPTY1MTI5O2UuZG9sbGFyc3VwZXJpb3I9NjMyMDQ7ZS5kb25nPTgzNjM7ZS5kb3J1c3F1YXJlPTEzMDk0O2UuZG90YWNjZW50PTcyOTtlLmRvdGFjY2VudGNtYj03NzU7ZS5kb3RiZWxvd2NtYj04MDM7ZS5kb3RiZWxvd2NvbWI9ODAzO2UuZG90a2F0YWthbmE9MTI1Mzk7ZS5kb3RsZXNzaT0zMDU7ZS5kb3RsZXNzaj02MzE2NjtlLmRvdGxlc3Nqc3Ryb2tlaG9vaz02NDQ7ZS5kb3RtYXRoPTg5MDE7ZS5kb3R0ZWRjaXJjbGU9OTY3NjtlLmRvdWJsZXlvZHBhdGFoPTY0Mjg3O2UuZG91YmxleW9kcGF0YWhoZWJyZXc9NjQyODc7ZS5kb3dudGFja2JlbG93Y21iPTc5ODtlLmRvd250YWNrbW9kPTcyNTtlLmRwYXJlbj05Mzc1O2UuZHN1cGVyaW9yPTYzMjExO2UuZHRhaWw9NTk4O2UuZHRvcGJhcj0zOTY7ZS5kdWhpcmFnYW5hPTEyMzg5O2UuZHVrYXRha2FuYT0xMjQ4NTtlLmR6PTQ5OTtlLmR6YWx0b25lPTY3NTtlLmR6Y2Fyb249NDU0O2UuZHpjdXJsPTY3NztlLmR6ZWFia2hhc2lhbmN5cmlsbGljPTEyNDk7ZS5kemVjeXJpbGxpYz0xMTA5O2UuZHpoZWN5cmlsbGljPTExMTk7ZS5lPTEwMTtlLmVhY3V0ZT0yMzM7ZS5lYXJ0aD05NzkzO2UuZWJlbmdhbGk9MjQ0NztlLmVib3BvbW9mbz0xMjU3MjtlLmVicmV2ZT0yNzc7ZS5lY2FuZHJhZGV2YT0yMzE3O2UuZWNhbmRyYWd1amFyYXRpPTI3MDE7ZS5lY2FuZHJhdm93ZWxzaWduZGV2YT0yMzczO2UuZWNhbmRyYXZvd2Vsc2lnbmd1amFyYXRpPTI3NTc7ZS5lY2Fyb249MjgzO2UuZWNlZGlsbGFicmV2ZT03NzA5O2UuZWNoYXJtZW5pYW49MTM4MTtlLmVjaHlpd25hcm1lbmlhbj0xNDE1O2UuZWNpcmNsZT05NDI4O2UuZWNpcmN1bWZsZXg9MjM0O2UuZWNpcmN1bWZsZXhhY3V0ZT03ODcxO2UuZWNpcmN1bWZsZXhiZWxvdz03NzA1O2UuZWNpcmN1bWZsZXhkb3RiZWxvdz03ODc5O2UuZWNpcmN1bWZsZXhncmF2ZT03ODczO2UuZWNpcmN1bWZsZXhob29rYWJvdmU9Nzg3NTtlLmVjaXJjdW1mbGV4dGlsZGU9Nzg3NztlLmVjeXJpbGxpYz0xMTA4O2UuZWRibGdyYXZlPTUxNztlLmVkZXZhPTIzMTk7ZS5lZGllcmVzaXM9MjM1O2UuZWRvdD0yNzk7ZS5lZG90YWNjZW50PTI3OTtlLmVkb3RiZWxvdz03ODY1O2UuZWVndXJtdWtoaT0yNTc1O2UuZWVtYXRyYWd1cm11a2hpPTI2MzE7ZS5lZmN5cmlsbGljPTEwOTI7ZS5lZ3JhdmU9MjMyO2UuZWd1amFyYXRpPTI3MDM7ZS5laGFybWVuaWFuPTEzODM7ZS5laGJvcG9tb2ZvPTEyNTczO2UuZWhpcmFnYW5hPTEyMzYwO2UuZWhvb2thYm92ZT03ODY3O2UuZWlib3BvbW9mbz0xMjU3NTtlLmVpZ2h0PTU2O2UuZWlnaHRhcmFiaWM9MTY0MDtlLmVpZ2h0YmVuZ2FsaT0yNTQyO2UuZWlnaHRjaXJjbGU9OTMxOTtlLmVpZ2h0Y2lyY2xlaW52ZXJzZXNhbnNzZXJpZj0xMDEyOTtlLmVpZ2h0ZGV2YT0yNDE0O2UuZWlnaHRlZW5jaXJjbGU9OTMyOTtlLmVpZ2h0ZWVucGFyZW49OTM0OTtlLmVpZ2h0ZWVucGVyaW9kPTkzNjk7ZS5laWdodGd1amFyYXRpPTI3OTg7ZS5laWdodGd1cm11a2hpPTI2NzA7ZS5laWdodGhhY2thcmFiaWM9MTY0MDtlLmVpZ2h0aGFuZ3pob3U9MTIzMjg7ZS5laWdodGhub3RlYmVhbWVkPTk4MzU7ZS5laWdodGlkZW9ncmFwaGljcGFyZW49MTI4Mzk7ZS5laWdodGluZmVyaW9yPTgzMjg7ZS5laWdodG1vbm9zcGFjZT02NTMwNDtlLmVpZ2h0b2xkc3R5bGU9NjMyODg7ZS5laWdodHBhcmVuPTkzMzk7ZS5laWdodHBlcmlvZD05MzU5O2UuZWlnaHRwZXJzaWFuPTE3ODQ7ZS5laWdodHJvbWFuPTg1Njc7ZS5laWdodHN1cGVyaW9yPTgzMTI7ZS5laWdodHRoYWk9MzY3MjtlLmVpbnZlcnRlZGJyZXZlPTUxOTtlLmVpb3RpZmllZGN5cmlsbGljPTExMjU7ZS5la2F0YWthbmE9MTI0NTY7ZS5la2F0YWthbmFoYWxmd2lkdGg9NjUzOTY7ZS5la29ua2FyZ3VybXVraGk9MjY3NjtlLmVrb3JlYW49MTI2Mjg7ZS5lbGN5cmlsbGljPTEwODM7ZS5lbGVtZW50PTg3MTI7ZS5lbGV2ZW5jaXJjbGU9OTMyMjtlLmVsZXZlbnBhcmVuPTkzNDI7ZS5lbGV2ZW5wZXJpb2Q9OTM2MjtlLmVsZXZlbnJvbWFuPTg1NzA7ZS5lbGxpcHNpcz04MjMwO2UuZWxsaXBzaXN2ZXJ0aWNhbD04OTQyO2UuZW1hY3Jvbj0yNzU7ZS5lbWFjcm9uYWN1dGU9NzcwMztlLmVtYWNyb25ncmF2ZT03NzAxO2UuZW1jeXJpbGxpYz0xMDg0O2UuZW1kYXNoPTgyMTI7ZS5lbWRhc2h2ZXJ0aWNhbD02NTA3MztlLmVtb25vc3BhY2U9NjUzNDk7ZS5lbXBoYXNpc21hcmthcm1lbmlhbj0xMzcxO2UuZW1wdHlzZXQ9ODcwOTtlLmVuYm9wb21vZm89MTI1Nzk7ZS5lbmN5cmlsbGljPTEwODU7ZS5lbmRhc2g9ODIxMTtlLmVuZGFzaHZlcnRpY2FsPTY1MDc0O2UuZW5kZXNjZW5kZXJjeXJpbGxpYz0xMTg3O2UuZW5nPTMzMTtlLmVuZ2JvcG9tb2ZvPTEyNTgxO2UuZW5naGVjeXJpbGxpYz0xMTg5O2UuZW5ob29rY3lyaWxsaWM9MTIyNDtlLmVuc3BhY2U9ODE5NDtlLmVvZ29uZWs9MjgxO2UuZW9rb3JlYW49MTI2Mjc7ZS5lb3Blbj02MDM7ZS5lb3BlbmNsb3NlZD02NjY7ZS5lb3BlbnJldmVyc2VkPTYwNDtlLmVvcGVucmV2ZXJzZWRjbG9zZWQ9NjA2O2UuZW9wZW5yZXZlcnNlZGhvb2s9NjA1O2UuZXBhcmVuPTkzNzY7ZS5lcHNpbG9uPTk0OTtlLmVwc2lsb250b25vcz05NDE7ZS5lcXVhbD02MTtlLmVxdWFsbW9ub3NwYWNlPTY1MzA5O2UuZXF1YWxzbWFsbD02NTEyNjtlLmVxdWFsc3VwZXJpb3I9ODMxNjtlLmVxdWl2YWxlbmNlPTg4MDE7ZS5lcmJvcG9tb2ZvPTEyNTgyO2UuZXJjeXJpbGxpYz0xMDg4O2UuZXJldmVyc2VkPTYwMDtlLmVyZXZlcnNlZGN5cmlsbGljPTExMDE7ZS5lc2N5cmlsbGljPTEwODk7ZS5lc2Rlc2NlbmRlcmN5cmlsbGljPTExOTU7ZS5lc2g9NjQzO2UuZXNoY3VybD02NDY7ZS5lc2hvcnRkZXZhPTIzMTg7ZS5lc2hvcnR2b3dlbHNpZ25kZXZhPTIzNzQ7ZS5lc2hyZXZlcnNlZGxvb3A9NDI2O2UuZXNoc3F1YXRyZXZlcnNlZD02NDU7ZS5lc21hbGxoaXJhZ2FuYT0xMjM1OTtlLmVzbWFsbGthdGFrYW5hPTEyNDU1O2UuZXNtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODY7ZS5lc3RpbWF0ZWQ9ODQ5NDtlLmVzdXBlcmlvcj02MzIxMjtlLmV0YT05NTE7ZS5ldGFybWVuaWFuPTEzODQ7ZS5ldGF0b25vcz05NDI7ZS5ldGg9MjQwO2UuZXRpbGRlPTc4Njk7ZS5ldGlsZGViZWxvdz03NzA3O2UuZXRuYWh0YWZvdWtoaGVicmV3PTE0MjU7ZS5ldG5haHRhZm91a2hsZWZ0aGVicmV3PTE0MjU7ZS5ldG5haHRhaGVicmV3PTE0MjU7ZS5ldG5haHRhbGVmdGhlYnJldz0xNDI1O2UuZXR1cm5lZD00Nzc7ZS5ldWtvcmVhbj0xMjY0MTtlLmV1cm89ODM2NDtlLmV2b3dlbHNpZ25iZW5nYWxpPTI1MDM7ZS5ldm93ZWxzaWduZGV2YT0yMzc1O2UuZXZvd2Vsc2lnbmd1amFyYXRpPTI3NTk7ZS5leGNsYW09MzM7ZS5leGNsYW1hcm1lbmlhbj0xMzcyO2UuZXhjbGFtZGJsPTgyNTI7ZS5leGNsYW1kb3duPTE2MTtlLmV4Y2xhbWRvd25zbWFsbD02MzM5MztlLmV4Y2xhbW1vbm9zcGFjZT02NTI4MTtlLmV4Y2xhbXNtYWxsPTYzMjY1O2UuZXhpc3RlbnRpYWw9ODcwNztlLmV6aD02NTg7ZS5lemhjYXJvbj00OTU7ZS5lemhjdXJsPTY1OTtlLmV6aHJldmVyc2VkPTQ0MTtlLmV6aHRhaWw9NDQyO2UuZj0xMDI7ZS5mYWRldmE9MjM5ODtlLmZhZ3VybXVraGk9MjY1NDtlLmZhaHJlbmhlaXQ9ODQ1NztlLmZhdGhhYXJhYmljPTE2MTQ7ZS5mYXRoYWxvd2FyYWJpYz0xNjE0O2UuZmF0aGF0YW5hcmFiaWM9MTYxMTtlLmZib3BvbW9mbz0xMjU1MjtlLmZjaXJjbGU9OTQyOTtlLmZkb3RhY2NlbnQ9NzcxMTtlLmZlaGFyYWJpYz0xNjAxO2UuZmVoYXJtZW5pYW49MTQxNDtlLmZlaGZpbmFsYXJhYmljPTY1MjM0O2UuZmVoaW5pdGlhbGFyYWJpYz02NTIzNTtlLmZlaG1lZGlhbGFyYWJpYz02NTIzNjtlLmZlaWNvcHRpYz05OTc7ZS5mZW1hbGU9OTc5MjtlLmZmPTY0MjU2O2UuZl9mPTY0MjU2O2UuZmZpPTY0MjU5O2UuZl9mX2k9NjQyNTk7ZS5mZmw9NjQyNjA7ZS5mX2ZfbD02NDI2MDtlLmZpPTY0MjU3O2UuZl9pPTY0MjU3O2UuZmlmdGVlbmNpcmNsZT05MzI2O2UuZmlmdGVlbnBhcmVuPTkzNDY7ZS5maWZ0ZWVucGVyaW9kPTkzNjY7ZS5maWd1cmVkYXNoPTgyMTA7ZS5maWxsZWRib3g9OTYzMjtlLmZpbGxlZHJlY3Q9OTY0NDtlLmZpbmFsa2FmPTE0OTg7ZS5maW5hbGthZmRhZ2VzaD02NDMxNDtlLmZpbmFsa2FmZGFnZXNoaGVicmV3PTY0MzE0O2UuZmluYWxrYWZoZWJyZXc9MTQ5ODtlLmZpbmFsbWVtPTE1MDE7ZS5maW5hbG1lbWhlYnJldz0xNTAxO2UuZmluYWxudW49MTUwMztlLmZpbmFsbnVuaGVicmV3PTE1MDM7ZS5maW5hbHBlPTE1MDc7ZS5maW5hbHBlaGVicmV3PTE1MDc7ZS5maW5hbHRzYWRpPTE1MDk7ZS5maW5hbHRzYWRpaGVicmV3PTE1MDk7ZS5maXJzdHRvbmVjaGluZXNlPTcxMztlLmZpc2hleWU9OTY3MztlLmZpdGFjeXJpbGxpYz0xMTM5O2UuZml2ZT01MztlLmZpdmVhcmFiaWM9MTYzNztlLmZpdmViZW5nYWxpPTI1Mzk7ZS5maXZlY2lyY2xlPTkzMTY7ZS5maXZlY2lyY2xlaW52ZXJzZXNhbnNzZXJpZj0xMDEyNjtlLmZpdmVkZXZhPTI0MTE7ZS5maXZlZWlnaHRocz04NTQxO2UuZml2ZWd1amFyYXRpPTI3OTU7ZS5maXZlZ3VybXVraGk9MjY2NztlLmZpdmVoYWNrYXJhYmljPTE2Mzc7ZS5maXZlaGFuZ3pob3U9MTIzMjU7ZS5maXZlaWRlb2dyYXBoaWNwYXJlbj0xMjgzNjtlLmZpdmVpbmZlcmlvcj04MzI1O2UuZml2ZW1vbm9zcGFjZT02NTMwMTtlLmZpdmVvbGRzdHlsZT02MzI4NTtlLmZpdmVwYXJlbj05MzM2O2UuZml2ZXBlcmlvZD05MzU2O2UuZml2ZXBlcnNpYW49MTc4MTtlLmZpdmVyb21hbj04NTY0O2UuZml2ZXN1cGVyaW9yPTgzMDk7ZS5maXZldGhhaT0zNjY5O2UuZmw9NjQyNTg7ZS5mX2w9NjQyNTg7ZS5mbG9yaW49NDAyO2UuZm1vbm9zcGFjZT02NTM1MDtlLmZtc3F1YXJlPTEzMjA5O2UuZm9mYW50aGFpPTM2MTU7ZS5mb2ZhdGhhaT0zNjEzO2UuZm9uZ21hbnRoYWk9MzY2MztlLmZvcmFsbD04NzA0O2UuZm91cj01MjtlLmZvdXJhcmFiaWM9MTYzNjtlLmZvdXJiZW5nYWxpPTI1Mzg7ZS5mb3VyY2lyY2xlPTkzMTU7ZS5mb3VyY2lyY2xlaW52ZXJzZXNhbnNzZXJpZj0xMDEyNTtlLmZvdXJkZXZhPTI0MTA7ZS5mb3VyZ3VqYXJhdGk9Mjc5NDtlLmZvdXJndXJtdWtoaT0yNjY2O2UuZm91cmhhY2thcmFiaWM9MTYzNjtlLmZvdXJoYW5nemhvdT0xMjMyNDtlLmZvdXJpZGVvZ3JhcGhpY3BhcmVuPTEyODM1O2UuZm91cmluZmVyaW9yPTgzMjQ7ZS5mb3VybW9ub3NwYWNlPTY1MzAwO2UuZm91cm51bWVyYXRvcmJlbmdhbGk9MjU1MTtlLmZvdXJvbGRzdHlsZT02MzI4NDtlLmZvdXJwYXJlbj05MzM1O2UuZm91cnBlcmlvZD05MzU1O2UuZm91cnBlcnNpYW49MTc4MDtlLmZvdXJyb21hbj04NTYzO2UuZm91cnN1cGVyaW9yPTgzMDg7ZS5mb3VydGVlbmNpcmNsZT05MzI1O2UuZm91cnRlZW5wYXJlbj05MzQ1O2UuZm91cnRlZW5wZXJpb2Q9OTM2NTtlLmZvdXJ0aGFpPTM2Njg7ZS5mb3VydGh0b25lY2hpbmVzZT03MTU7ZS5mcGFyZW49OTM3NztlLmZyYWN0aW9uPTgyNjA7ZS5mcmFuYz04MzU1O2UuZz0xMDM7ZS5nYWJlbmdhbGk9MjQ1NTtlLmdhY3V0ZT01MDE7ZS5nYWRldmE9MjMyNztlLmdhZmFyYWJpYz0xNzExO2UuZ2FmZmluYWxhcmFiaWM9NjQ0MDM7ZS5nYWZpbml0aWFsYXJhYmljPTY0NDA0O2UuZ2FmbWVkaWFsYXJhYmljPTY0NDA1O2UuZ2FndWphcmF0aT0yNzExO2UuZ2FndXJtdWtoaT0yNTgzO2UuZ2FoaXJhZ2FuYT0xMjM2NDtlLmdha2F0YWthbmE9MTI0NjA7ZS5nYW1tYT05NDc7ZS5nYW1tYWxhdGluc21hbGw9NjExO2UuZ2FtbWFzdXBlcmlvcj03MzY7ZS5nYW5naWFjb3B0aWM9MTAwMztlLmdib3BvbW9mbz0xMjU1NztlLmdicmV2ZT0yODc7ZS5nY2Fyb249NDg3O2UuZ2NlZGlsbGE9MjkxO2UuZ2NpcmNsZT05NDMwO2UuZ2NpcmN1bWZsZXg9Mjg1O2UuZ2NvbW1hYWNjZW50PTI5MTtlLmdkb3Q9Mjg5O2UuZ2RvdGFjY2VudD0yODk7ZS5nZWN5cmlsbGljPTEwNzU7ZS5nZWhpcmFnYW5hPTEyMzcwO2UuZ2VrYXRha2FuYT0xMjQ2NjtlLmdlb21ldHJpY2FsbHllcXVhbD04Nzg1O2UuZ2VyZXNoYWNjZW50aGVicmV3PTE0MzY7ZS5nZXJlc2hoZWJyZXc9MTUyMztlLmdlcmVzaG11cWRhbWhlYnJldz0xNDM3O2UuZ2VybWFuZGJscz0yMjM7ZS5nZXJzaGF5aW1hY2NlbnRoZWJyZXc9MTQzODtlLmdlcnNoYXlpbWhlYnJldz0xNTI0O2UuZ2V0YW1hcms9MTIzMDc7ZS5naGFiZW5nYWxpPTI0NTY7ZS5naGFkYXJtZW5pYW49MTM5NDtlLmdoYWRldmE9MjMyODtlLmdoYWd1amFyYXRpPTI3MTI7ZS5naGFndXJtdWtoaT0yNTg0O2UuZ2hhaW5hcmFiaWM9MTU5NDtlLmdoYWluZmluYWxhcmFiaWM9NjUyMzA7ZS5naGFpbmluaXRpYWxhcmFiaWM9NjUyMzE7ZS5naGFpbm1lZGlhbGFyYWJpYz02NTIzMjtlLmdoZW1pZGRsZWhvb2tjeXJpbGxpYz0xMTczO2UuZ2hlc3Ryb2tlY3lyaWxsaWM9MTE3MTtlLmdoZXVwdHVybmN5cmlsbGljPTExNjk7ZS5naGhhZGV2YT0yMzk0O2UuZ2hoYWd1cm11a2hpPTI2NTA7ZS5naG9vaz02MDg7ZS5naHpzcXVhcmU9MTMyMDM7ZS5naWhpcmFnYW5hPTEyMzY2O2UuZ2lrYXRha2FuYT0xMjQ2MjtlLmdpbWFybWVuaWFuPTEzNzk7ZS5naW1lbD0xNDkwO2UuZ2ltZWxkYWdlc2g9NjQzMDY7ZS5naW1lbGRhZ2VzaGhlYnJldz02NDMwNjtlLmdpbWVsaGVicmV3PTE0OTA7ZS5namVjeXJpbGxpYz0xMTA3O2UuZ2xvdHRhbGludmVydGVkc3Ryb2tlPTQ0NjtlLmdsb3R0YWxzdG9wPTY2MDtlLmdsb3R0YWxzdG9waW52ZXJ0ZWQ9NjYyO2UuZ2xvdHRhbHN0b3Btb2Q9NzA0O2UuZ2xvdHRhbHN0b3ByZXZlcnNlZD02NjE7ZS5nbG90dGFsc3RvcHJldmVyc2VkbW9kPTcwNTtlLmdsb3R0YWxzdG9wcmV2ZXJzZWRzdXBlcmlvcj03NDA7ZS5nbG90dGFsc3RvcHN0cm9rZT02NzM7ZS5nbG90dGFsc3RvcHN0cm9rZXJldmVyc2VkPTY3NDtlLmdtYWNyb249NzcxMztlLmdtb25vc3BhY2U9NjUzNTE7ZS5nb2hpcmFnYW5hPTEyMzcyO2UuZ29rYXRha2FuYT0xMjQ2ODtlLmdwYXJlbj05Mzc4O2UuZ3Bhc3F1YXJlPTEzMjI4O2UuZ3JhZGllbnQ9ODcxMTtlLmdyYXZlPTk2O2UuZ3JhdmViZWxvd2NtYj03OTA7ZS5ncmF2ZWNtYj03Njg7ZS5ncmF2ZWNvbWI9NzY4O2UuZ3JhdmVkZXZhPTIzODc7ZS5ncmF2ZWxvd21vZD03MTg7ZS5ncmF2ZW1vbm9zcGFjZT02NTM0NDtlLmdyYXZldG9uZWNtYj04MzI7ZS5ncmVhdGVyPTYyO2UuZ3JlYXRlcmVxdWFsPTg4MDU7ZS5ncmVhdGVyZXF1YWxvcmxlc3M9ODkyMztlLmdyZWF0ZXJtb25vc3BhY2U9NjUzMTA7ZS5ncmVhdGVyb3JlcXVpdmFsZW50PTg4MTk7ZS5ncmVhdGVyb3JsZXNzPTg4MjM7ZS5ncmVhdGVyb3ZlcmVxdWFsPTg4MDc7ZS5ncmVhdGVyc21hbGw9NjUxMjU7ZS5nc2NyaXB0PTYwOTtlLmdzdHJva2U9NDg1O2UuZ3VoaXJhZ2FuYT0xMjM2ODtlLmd1aWxsZW1vdGxlZnQ9MTcxO2UuZ3VpbGxlbW90cmlnaHQ9MTg3O2UuZ3VpbHNpbmdsbGVmdD04MjQ5O2UuZ3VpbHNpbmdscmlnaHQ9ODI1MDtlLmd1a2F0YWthbmE9MTI0NjQ7ZS5ndXJhbXVzcXVhcmU9MTMwODA7ZS5neXNxdWFyZT0xMzI1NztlLmg9MTA0O2UuaGFhYmtoYXNpYW5jeXJpbGxpYz0xMTkzO2UuaGFhbHRvbmVhcmFiaWM9MTcyOTtlLmhhYmVuZ2FsaT0yNDg5O2UuaGFkZXNjZW5kZXJjeXJpbGxpYz0xMjAzO2UuaGFkZXZhPTIzNjE7ZS5oYWd1amFyYXRpPTI3NDU7ZS5oYWd1cm11a2hpPTI2MTc7ZS5oYWhhcmFiaWM9MTU4MTtlLmhhaGZpbmFsYXJhYmljPTY1MTg2O2UuaGFoaW5pdGlhbGFyYWJpYz02NTE4NztlLmhhaGlyYWdhbmE9MTIzOTk7ZS5oYWhtZWRpYWxhcmFiaWM9NjUxODg7ZS5oYWl0dXNxdWFyZT0xMzA5ODtlLmhha2F0YWthbmE9MTI0OTU7ZS5oYWthdGFrYW5haGFsZndpZHRoPTY1NDE4O2UuaGFsYW50Z3VybXVraGk9MjYzNztlLmhhbXphYXJhYmljPTE1Njk7ZS5oYW16YWxvd2FyYWJpYz0xNTY5O2UuaGFuZ3VsZmlsbGVyPTEyNjQ0O2UuaGFyZHNpZ25jeXJpbGxpYz0xMDk4O2UuaGFycG9vbmxlZnRiYXJidXA9ODYzNjtlLmhhcnBvb25yaWdodGJhcmJ1cD04NjQwO2UuaGFzcXVhcmU9MTMyNTg7ZS5oYXRhZnBhdGFoPTE0NTg7ZS5oYXRhZnBhdGFoMTY9MTQ1ODtlLmhhdGFmcGF0YWgyMz0xNDU4O2UuaGF0YWZwYXRhaDJmPTE0NTg7ZS5oYXRhZnBhdGFoaGVicmV3PTE0NTg7ZS5oYXRhZnBhdGFobmFycm93aGVicmV3PTE0NTg7ZS5oYXRhZnBhdGFocXVhcnRlcmhlYnJldz0xNDU4O2UuaGF0YWZwYXRhaHdpZGVoZWJyZXc9MTQ1ODtlLmhhdGFmcWFtYXRzPTE0NTk7ZS5oYXRhZnFhbWF0czFiPTE0NTk7ZS5oYXRhZnFhbWF0czI4PTE0NTk7ZS5oYXRhZnFhbWF0czM0PTE0NTk7ZS5oYXRhZnFhbWF0c2hlYnJldz0xNDU5O2UuaGF0YWZxYW1hdHNuYXJyb3doZWJyZXc9MTQ1OTtlLmhhdGFmcWFtYXRzcXVhcnRlcmhlYnJldz0xNDU5O2UuaGF0YWZxYW1hdHN3aWRlaGVicmV3PTE0NTk7ZS5oYXRhZnNlZ29sPTE0NTc7ZS5oYXRhZnNlZ29sMTc9MTQ1NztlLmhhdGFmc2Vnb2wyND0xNDU3O2UuaGF0YWZzZWdvbDMwPTE0NTc7ZS5oYXRhZnNlZ29saGVicmV3PTE0NTc7ZS5oYXRhZnNlZ29sbmFycm93aGVicmV3PTE0NTc7ZS5oYXRhZnNlZ29scXVhcnRlcmhlYnJldz0xNDU3O2UuaGF0YWZzZWdvbHdpZGVoZWJyZXc9MTQ1NztlLmhiYXI9Mjk1O2UuaGJvcG9tb2ZvPTEyNTU5O2UuaGJyZXZlYmVsb3c9NzcyMztlLmhjZWRpbGxhPTc3MjE7ZS5oY2lyY2xlPTk0MzE7ZS5oY2lyY3VtZmxleD0yOTM7ZS5oZGllcmVzaXM9NzcxOTtlLmhkb3RhY2NlbnQ9NzcxNTtlLmhkb3RiZWxvdz03NzE3O2UuaGU9MTQ5MjtlLmhlYXJ0PTk4Mjk7ZS5oZWFydHN1aXRibGFjaz05ODI5O2UuaGVhcnRzdWl0d2hpdGU9OTgyNTtlLmhlZGFnZXNoPTY0MzA4O2UuaGVkYWdlc2hoZWJyZXc9NjQzMDg7ZS5oZWhhbHRvbmVhcmFiaWM9MTcyOTtlLmhlaGFyYWJpYz0xNjA3O2UuaGVoZWJyZXc9MTQ5MjtlLmhlaGZpbmFsYWx0b25lYXJhYmljPTY0NDIzO2UuaGVoZmluYWxhbHR0d29hcmFiaWM9NjUyNTg7ZS5oZWhmaW5hbGFyYWJpYz02NTI1ODtlLmhlaGhhbXphYWJvdmVmaW5hbGFyYWJpYz02NDQyMTtlLmhlaGhhbXphYWJvdmVpc29sYXRlZGFyYWJpYz02NDQyMDtlLmhlaGluaXRpYWxhbHRvbmVhcmFiaWM9NjQ0MjQ7ZS5oZWhpbml0aWFsYXJhYmljPTY1MjU5O2UuaGVoaXJhZ2FuYT0xMjQwODtlLmhlaG1lZGlhbGFsdG9uZWFyYWJpYz02NDQyNTtlLmhlaG1lZGlhbGFyYWJpYz02NTI2MDtlLmhlaXNlaWVyYXNxdWFyZT0xMzE3OTtlLmhla2F0YWthbmE9MTI1MDQ7ZS5oZWthdGFrYW5haGFsZndpZHRoPTY1NDIxO2UuaGVrdXRhYXJ1c3F1YXJlPTEzMTEwO2UuaGVuZ2hvb2s9NjE1O2UuaGVydXR1c3F1YXJlPTEzMTEzO2UuaGV0PTE0OTU7ZS5oZXRoZWJyZXc9MTQ5NTtlLmhob29rPTYxNDtlLmhob29rc3VwZXJpb3I9Njg5O2UuaGlldWhhY2lyY2xla29yZWFuPTEyOTIzO2UuaGlldWhhcGFyZW5rb3JlYW49MTI4Mjc7ZS5oaWV1aGNpcmNsZWtvcmVhbj0xMjkwOTtlLmhpZXVoa29yZWFuPTEyNjIyO2UuaGlldWhwYXJlbmtvcmVhbj0xMjgxMztlLmhpaGlyYWdhbmE9MTI0MDI7ZS5oaWthdGFrYW5hPTEyNDk4O2UuaGlrYXRha2FuYWhhbGZ3aWR0aD02NTQxOTtlLmhpcmlxPTE0NjA7ZS5oaXJpcTE0PTE0NjA7ZS5oaXJpcTIxPTE0NjA7ZS5oaXJpcTJkPTE0NjA7ZS5oaXJpcWhlYnJldz0xNDYwO2UuaGlyaXFuYXJyb3doZWJyZXc9MTQ2MDtlLmhpcmlxcXVhcnRlcmhlYnJldz0xNDYwO2UuaGlyaXF3aWRlaGVicmV3PTE0NjA7ZS5obGluZWJlbG93PTc4MzA7ZS5obW9ub3NwYWNlPTY1MzUyO2UuaG9hcm1lbmlhbj0xMzkyO2UuaG9oaXB0aGFpPTM2Mjc7ZS5ob2hpcmFnYW5hPTEyNDExO2UuaG9rYXRha2FuYT0xMjUwNztlLmhva2F0YWthbmFoYWxmd2lkdGg9NjU0MjI7ZS5ob2xhbT0xNDY1O2UuaG9sYW0xOT0xNDY1O2UuaG9sYW0yNj0xNDY1O2UuaG9sYW0zMj0xNDY1O2UuaG9sYW1oZWJyZXc9MTQ2NTtlLmhvbGFtbmFycm93aGVicmV3PTE0NjU7ZS5ob2xhbXF1YXJ0ZXJoZWJyZXc9MTQ2NTtlLmhvbGFtd2lkZWhlYnJldz0xNDY1O2UuaG9ub2todWt0aGFpPTM2MzA7ZS5ob29rYWJvdmVjb21iPTc3NztlLmhvb2tjbWI9Nzc3O2UuaG9va3BhbGF0YWxpemVkYmVsb3djbWI9ODAxO2UuaG9va3JldHJvZmxleGJlbG93Y21iPTgwMjtlLmhvb25zcXVhcmU9MTMxMjI7ZS5ob3JpY29wdGljPTEwMDE7ZS5ob3Jpem9udGFsYmFyPTgyMTM7ZS5ob3JuY21iPTc5NTtlLmhvdHNwcmluZ3M9OTgzMjtlLmhvdXNlPTg5NjI7ZS5ocGFyZW49OTM3OTtlLmhzdXBlcmlvcj02ODg7ZS5odHVybmVkPTYxMztlLmh1aGlyYWdhbmE9MTI0MDU7ZS5odWlpdG9zcXVhcmU9MTMxMDc7ZS5odWthdGFrYW5hPTEyNTAxO2UuaHVrYXRha2FuYWhhbGZ3aWR0aD02NTQyMDtlLmh1bmdhcnVtbGF1dD03MzM7ZS5odW5nYXJ1bWxhdXRjbWI9Nzc5O2UuaHY9NDA1O2UuaHlwaGVuPTQ1O2UuaHlwaGVuaW5mZXJpb3I9NjMyMDU7ZS5oeXBoZW5tb25vc3BhY2U9NjUyOTM7ZS5oeXBoZW5zbWFsbD02NTEyMztlLmh5cGhlbnN1cGVyaW9yPTYzMjA2O2UuaHlwaGVudHdvPTgyMDg7ZS5pPTEwNTtlLmlhY3V0ZT0yMzc7ZS5pYWN5cmlsbGljPTExMDM7ZS5pYmVuZ2FsaT0yNDM5O2UuaWJvcG9tb2ZvPTEyNTgzO2UuaWJyZXZlPTMwMTtlLmljYXJvbj00NjQ7ZS5pY2lyY2xlPTk0MzI7ZS5pY2lyY3VtZmxleD0yMzg7ZS5pY3lyaWxsaWM9MTExMDtlLmlkYmxncmF2ZT01MjE7ZS5pZGVvZ3JhcGhlYXJ0aGNpcmNsZT0xMjk0MztlLmlkZW9ncmFwaGZpcmVjaXJjbGU9MTI5Mzk7ZS5pZGVvZ3JhcGhpY2FsbGlhbmNlcGFyZW49MTI4NjM7ZS5pZGVvZ3JhcGhpY2NhbGxwYXJlbj0xMjg1ODtlLmlkZW9ncmFwaGljY2VudHJlY2lyY2xlPTEyOTY1O2UuaWRlb2dyYXBoaWNjbG9zZT0xMjI5NDtlLmlkZW9ncmFwaGljY29tbWE9MTIyODk7ZS5pZGVvZ3JhcGhpY2NvbW1hbGVmdD02NTM4MDtlLmlkZW9ncmFwaGljY29uZ3JhdHVsYXRpb25wYXJlbj0xMjg1NTtlLmlkZW9ncmFwaGljY29ycmVjdGNpcmNsZT0xMjk2MztlLmlkZW9ncmFwaGljZWFydGhwYXJlbj0xMjg0NztlLmlkZW9ncmFwaGljZW50ZXJwcmlzZXBhcmVuPTEyODYxO2UuaWRlb2dyYXBoaWNleGNlbGxlbnRjaXJjbGU9MTI5NTc7ZS5pZGVvZ3JhcGhpY2Zlc3RpdmFscGFyZW49MTI4NjQ7ZS5pZGVvZ3JhcGhpY2ZpbmFuY2lhbGNpcmNsZT0xMjk1MDtlLmlkZW9ncmFwaGljZmluYW5jaWFscGFyZW49MTI4NTQ7ZS5pZGVvZ3JhcGhpY2ZpcmVwYXJlbj0xMjg0MztlLmlkZW9ncmFwaGljaGF2ZXBhcmVuPTEyODUwO2UuaWRlb2dyYXBoaWNoaWdoY2lyY2xlPTEyOTY0O2UuaWRlb2dyYXBoaWNpdGVyYXRpb25tYXJrPTEyMjkzO2UuaWRlb2dyYXBoaWNsYWJvcmNpcmNsZT0xMjk1MjtlLmlkZW9ncmFwaGljbGFib3JwYXJlbj0xMjg1NjtlLmlkZW9ncmFwaGljbGVmdGNpcmNsZT0xMjk2NztlLmlkZW9ncmFwaGljbG93Y2lyY2xlPTEyOTY2O2UuaWRlb2dyYXBoaWNtZWRpY2luZWNpcmNsZT0xMjk2OTtlLmlkZW9ncmFwaGljbWV0YWxwYXJlbj0xMjg0NjtlLmlkZW9ncmFwaGljbW9vbnBhcmVuPTEyODQyO2UuaWRlb2dyYXBoaWNuYW1lcGFyZW49MTI4NTI7ZS5pZGVvZ3JhcGhpY3BlcmlvZD0xMjI5MDtlLmlkZW9ncmFwaGljcHJpbnRjaXJjbGU9MTI5NTg7ZS5pZGVvZ3JhcGhpY3JlYWNocGFyZW49MTI4Njc7ZS5pZGVvZ3JhcGhpY3JlcHJlc2VudHBhcmVuPTEyODU3O2UuaWRlb2dyYXBoaWNyZXNvdXJjZXBhcmVuPTEyODYyO2UuaWRlb2dyYXBoaWNyaWdodGNpcmNsZT0xMjk2ODtlLmlkZW9ncmFwaGljc2VjcmV0Y2lyY2xlPTEyOTUzO2UuaWRlb2dyYXBoaWNzZWxmcGFyZW49MTI4NjY7ZS5pZGVvZ3JhcGhpY3NvY2lldHlwYXJlbj0xMjg1MTtlLmlkZW9ncmFwaGljc3BhY2U9MTIyODg7ZS5pZGVvZ3JhcGhpY3NwZWNpYWxwYXJlbj0xMjg1MztlLmlkZW9ncmFwaGljc3RvY2twYXJlbj0xMjg0OTtlLmlkZW9ncmFwaGljc3R1ZHlwYXJlbj0xMjg1OTtlLmlkZW9ncmFwaGljc3VucGFyZW49MTI4NDg7ZS5pZGVvZ3JhcGhpY3N1cGVydmlzZXBhcmVuPTEyODYwO2UuaWRlb2dyYXBoaWN3YXRlcnBhcmVuPTEyODQ0O2UuaWRlb2dyYXBoaWN3b29kcGFyZW49MTI4NDU7ZS5pZGVvZ3JhcGhpY3plcm89MTIyOTU7ZS5pZGVvZ3JhcGhtZXRhbGNpcmNsZT0xMjk0MjtlLmlkZW9ncmFwaG1vb25jaXJjbGU9MTI5Mzg7ZS5pZGVvZ3JhcGhuYW1lY2lyY2xlPTEyOTQ4O2UuaWRlb2dyYXBoc3VuY2lyY2xlPTEyOTQ0O2UuaWRlb2dyYXBod2F0ZXJjaXJjbGU9MTI5NDA7ZS5pZGVvZ3JhcGh3b29kY2lyY2xlPTEyOTQxO2UuaWRldmE9MjMxMTtlLmlkaWVyZXNpcz0yMzk7ZS5pZGllcmVzaXNhY3V0ZT03NzI3O2UuaWRpZXJlc2lzY3lyaWxsaWM9MTI1MztlLmlkb3RiZWxvdz03ODgzO2UuaWVicmV2ZWN5cmlsbGljPTEyMzk7ZS5pZWN5cmlsbGljPTEwNzc7ZS5pZXVuZ2FjaXJjbGVrb3JlYW49MTI5MTc7ZS5pZXVuZ2FwYXJlbmtvcmVhbj0xMjgyMTtlLmlldW5nY2lyY2xla29yZWFuPTEyOTAzO2UuaWV1bmdrb3JlYW49MTI2MTU7ZS5pZXVuZ3BhcmVua29yZWFuPTEyODA3O2UuaWdyYXZlPTIzNjtlLmlndWphcmF0aT0yNjk1O2UuaWd1cm11a2hpPTI1Njc7ZS5paGlyYWdhbmE9MTIzNTY7ZS5paG9va2Fib3ZlPTc4ODE7ZS5paWJlbmdhbGk9MjQ0MDtlLmlpY3lyaWxsaWM9MTA4MDtlLmlpZGV2YT0yMzEyO2UuaWlndWphcmF0aT0yNjk2O2UuaWlndXJtdWtoaT0yNTY4O2UuaWltYXRyYWd1cm11a2hpPTI2MjQ7ZS5paW52ZXJ0ZWRicmV2ZT01MjM7ZS5paXNob3J0Y3lyaWxsaWM9MTA4MTtlLmlpdm93ZWxzaWduYmVuZ2FsaT0yNDk2O2UuaWl2b3dlbHNpZ25kZXZhPTIzNjg7ZS5paXZvd2Vsc2lnbmd1amFyYXRpPTI3NTI7ZS5paj0zMDc7ZS5pa2F0YWthbmE9MTI0NTI7ZS5pa2F0YWthbmFoYWxmd2lkdGg9NjUzOTQ7ZS5pa29yZWFuPTEyNjQzO2UuaWxkZT03MzI7ZS5pbHV5aGVicmV3PTE0NTI7ZS5pbWFjcm9uPTI5OTtlLmltYWNyb25jeXJpbGxpYz0xMjUxO2UuaW1hZ2VvcmFwcHJveGltYXRlbHllcXVhbD04Nzg3O2UuaW1hdHJhZ3VybXVraGk9MjYyMztlLmltb25vc3BhY2U9NjUzNTM7ZS5pbmNyZW1lbnQ9ODcxMDtlLmluZmluaXR5PTg3MzQ7ZS5pbmlhcm1lbmlhbj0xMzg3O2UuaW50ZWdyYWw9ODc0NztlLmludGVncmFsYm90dG9tPTg5OTM7ZS5pbnRlZ3JhbGJ0PTg5OTM7ZS5pbnRlZ3JhbGV4PTYzNzMzO2UuaW50ZWdyYWx0b3A9ODk5MjtlLmludGVncmFsdHA9ODk5MjtlLmludGVyc2VjdGlvbj04NzQ1O2UuaW50aXNxdWFyZT0xMzA2MTtlLmludmJ1bGxldD05Njg4O2UuaW52Y2lyY2xlPTk2ODk7ZS5pbnZzbWlsZWZhY2U9OTc4NztlLmlvY3lyaWxsaWM9MTEwNTtlLmlvZ29uZWs9MzAzO2UuaW90YT05NTM7ZS5pb3RhZGllcmVzaXM9OTcwO2UuaW90YWRpZXJlc2lzdG9ub3M9OTEyO2UuaW90YWxhdGluPTYxNztlLmlvdGF0b25vcz05NDM7ZS5pcGFyZW49OTM4MDtlLmlyaWd1cm11a2hpPTI2NzQ7ZS5pc21hbGxoaXJhZ2FuYT0xMjM1NTtlLmlzbWFsbGthdGFrYW5hPTEyNDUxO2UuaXNtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODQ7ZS5pc3NoYXJiZW5nYWxpPTI1NTQ7ZS5pc3Ryb2tlPTYxNjtlLmlzdXBlcmlvcj02MzIxMztlLml0ZXJhdGlvbmhpcmFnYW5hPTEyNDQ1O2UuaXRlcmF0aW9ua2F0YWthbmE9MTI1NDE7ZS5pdGlsZGU9Mjk3O2UuaXRpbGRlYmVsb3c9NzcyNTtlLml1Ym9wb21vZm89MTI1ODU7ZS5pdWN5cmlsbGljPTExMDI7ZS5pdm93ZWxzaWduYmVuZ2FsaT0yNDk1O2UuaXZvd2Vsc2lnbmRldmE9MjM2NztlLml2b3dlbHNpZ25ndWphcmF0aT0yNzUxO2UuaXpoaXRzYWN5cmlsbGljPTExNDE7ZS5pemhpdHNhZGJsZ3JhdmVjeXJpbGxpYz0xMTQzO2Uuaj0xMDY7ZS5qYWFybWVuaWFuPTEzOTM7ZS5qYWJlbmdhbGk9MjQ2MDtlLmphZGV2YT0yMzMyO2UuamFndWphcmF0aT0yNzE2O2UuamFndXJtdWtoaT0yNTg4O2UuamJvcG9tb2ZvPTEyNTYwO2UuamNhcm9uPTQ5NjtlLmpjaXJjbGU9OTQzMztlLmpjaXJjdW1mbGV4PTMwOTtlLmpjcm9zc2VkdGFpbD02Njk7ZS5qZG90bGVzc3N0cm9rZT02MDc7ZS5qZWN5cmlsbGljPTExMTI7ZS5qZWVtYXJhYmljPTE1ODA7ZS5qZWVtZmluYWxhcmFiaWM9NjUxODI7ZS5qZWVtaW5pdGlhbGFyYWJpYz02NTE4MztlLmplZW1tZWRpYWxhcmFiaWM9NjUxODQ7ZS5qZWhhcmFiaWM9MTY4ODtlLmplaGZpbmFsYXJhYmljPTY0Mzk1O2UuamhhYmVuZ2FsaT0yNDYxO2UuamhhZGV2YT0yMzMzO2UuamhhZ3VqYXJhdGk9MjcxNztlLmpoYWd1cm11a2hpPTI1ODk7ZS5qaGVoYXJtZW5pYW49MTQwMztlLmppcz0xMjI5MjtlLmptb25vc3BhY2U9NjUzNTQ7ZS5qcGFyZW49OTM4MTtlLmpzdXBlcmlvcj02OTA7ZS5rPTEwNztlLmthYmFzaGtpcmN5cmlsbGljPTExODU7ZS5rYWJlbmdhbGk9MjQ1MztlLmthY3V0ZT03NzI5O2Uua2FjeXJpbGxpYz0xMDgyO2Uua2FkZXNjZW5kZXJjeXJpbGxpYz0xMTc5O2Uua2FkZXZhPTIzMjU7ZS5rYWY9MTQ5OTtlLmthZmFyYWJpYz0xNjAzO2Uua2FmZGFnZXNoPTY0MzE1O2Uua2FmZGFnZXNoaGVicmV3PTY0MzE1O2Uua2FmZmluYWxhcmFiaWM9NjUyNDI7ZS5rYWZoZWJyZXc9MTQ5OTtlLmthZmluaXRpYWxhcmFiaWM9NjUyNDM7ZS5rYWZtZWRpYWxhcmFiaWM9NjUyNDQ7ZS5rYWZyYWZlaGVicmV3PTY0MzMzO2Uua2FndWphcmF0aT0yNzA5O2Uua2FndXJtdWtoaT0yNTgxO2Uua2FoaXJhZ2FuYT0xMjM2MztlLmthaG9va2N5cmlsbGljPTEyMjA7ZS5rYWthdGFrYW5hPTEyNDU5O2Uua2FrYXRha2FuYWhhbGZ3aWR0aD02NTM5ODtlLmthcHBhPTk1NDtlLmthcHBhc3ltYm9sZ3JlZWs9MTAwODtlLmthcHllb3VubWlldW1rb3JlYW49MTI2NTc7ZS5rYXB5ZW91bnBoaWV1cGhrb3JlYW49MTI2NzY7ZS5rYXB5ZW91bnBpZXVwa29yZWFuPTEyNjY0O2Uua2FweWVvdW5zc2FuZ3BpZXVwa29yZWFuPTEyNjY1O2Uua2Fyb3JpaXNxdWFyZT0xMzA2OTtlLmthc2hpZGFhdXRvYXJhYmljPTE2MDA7ZS5rYXNoaWRhYXV0b25vc2lkZWJlYXJpbmdhcmFiaWM9MTYwMDtlLmthc21hbGxrYXRha2FuYT0xMjUzMztlLmthc3F1YXJlPTEzMTg4O2Uua2FzcmFhcmFiaWM9MTYxNjtlLmthc3JhdGFuYXJhYmljPTE2MTM7ZS5rYXN0cm9rZWN5cmlsbGljPTExODM7ZS5rYXRhaGlyYXByb2xvbmdtYXJraGFsZndpZHRoPTY1MzkyO2Uua2F2ZXJ0aWNhbHN0cm9rZWN5cmlsbGljPTExODE7ZS5rYm9wb21vZm89MTI1NTg7ZS5rY2Fsc3F1YXJlPTEzMTkzO2Uua2Nhcm9uPTQ4OTtlLmtjZWRpbGxhPTMxMTtlLmtjaXJjbGU9OTQzNDtlLmtjb21tYWFjY2VudD0zMTE7ZS5rZG90YmVsb3c9NzczMTtlLmtlaGFybWVuaWFuPTE0MTI7ZS5rZWhpcmFnYW5hPTEyMzY5O2Uua2VrYXRha2FuYT0xMjQ2NTtlLmtla2F0YWthbmFoYWxmd2lkdGg9NjU0MDE7ZS5rZW5hcm1lbmlhbj0xMzkxO2Uua2VzbWFsbGthdGFrYW5hPTEyNTM0O2Uua2dyZWVubGFuZGljPTMxMjtlLmtoYWJlbmdhbGk9MjQ1NDtlLmtoYWN5cmlsbGljPTEwOTM7ZS5raGFkZXZhPTIzMjY7ZS5raGFndWphcmF0aT0yNzEwO2Uua2hhZ3VybXVraGk9MjU4MjtlLmtoYWhhcmFiaWM9MTU4MjtlLmtoYWhmaW5hbGFyYWJpYz02NTE5MDtlLmtoYWhpbml0aWFsYXJhYmljPTY1MTkxO2Uua2hhaG1lZGlhbGFyYWJpYz02NTE5MjtlLmtoZWljb3B0aWM9OTk5O2Uua2hoYWRldmE9MjM5MztlLmtoaGFndXJtdWtoaT0yNjQ5O2Uua2hpZXVraGFjaXJjbGVrb3JlYW49MTI5MjA7ZS5raGlldWtoYXBhcmVua29yZWFuPTEyODI0O2Uua2hpZXVraGNpcmNsZWtvcmVhbj0xMjkwNjtlLmtoaWV1a2hrb3JlYW49MTI2MTk7ZS5raGlldWtocGFyZW5rb3JlYW49MTI4MTA7ZS5raG9raGFpdGhhaT0zNTg2O2Uua2hva2hvbnRoYWk9MzU4OTtlLmtob2todWF0dGhhaT0zNTg3O2Uua2hva2h3YWl0aGFpPTM1ODg7ZS5raG9tdXR0aGFpPTM2NzU7ZS5raG9vaz00MDk7ZS5raG9yYWtoYW5ndGhhaT0zNTkwO2Uua2h6c3F1YXJlPTEzMjAxO2Uua2loaXJhZ2FuYT0xMjM2NTtlLmtpa2F0YWthbmE9MTI0NjE7ZS5raWthdGFrYW5haGFsZndpZHRoPTY1Mzk5O2Uua2lyb2d1cmFtdXNxdWFyZT0xMzA3NztlLmtpcm9tZWV0b3J1c3F1YXJlPTEzMDc4O2Uua2lyb3NxdWFyZT0xMzA3NjtlLmtpeWVva2FjaXJjbGVrb3JlYW49MTI5MTA7ZS5raXllb2thcGFyZW5rb3JlYW49MTI4MTQ7ZS5raXllb2tjaXJjbGVrb3JlYW49MTI4OTY7ZS5raXllb2trb3JlYW49MTI1OTM7ZS5raXllb2twYXJlbmtvcmVhbj0xMjgwMDtlLmtpeWVva3Npb3Nrb3JlYW49MTI1OTU7ZS5ramVjeXJpbGxpYz0xMTE2O2Uua2xpbmViZWxvdz03NzMzO2Uua2xzcXVhcmU9MTMyMDg7ZS5rbWN1YmVkc3F1YXJlPTEzMjIyO2Uua21vbm9zcGFjZT02NTM1NTtlLmttc3F1YXJlZHNxdWFyZT0xMzIxODtlLmtvaGlyYWdhbmE9MTIzNzE7ZS5rb2htc3F1YXJlPTEzMjQ4O2Uua29rYWl0aGFpPTM1ODU7ZS5rb2thdGFrYW5hPTEyNDY3O2Uua29rYXRha2FuYWhhbGZ3aWR0aD02NTQwMjtlLmtvb3Bvc3F1YXJlPTEzMDg2O2Uua29wcGFjeXJpbGxpYz0xMTUzO2Uua29yZWFuc3RhbmRhcmRzeW1ib2w9MTI5Mjc7ZS5rb3JvbmlzY21iPTgzNTtlLmtwYXJlbj05MzgyO2Uua3Bhc3F1YXJlPTEzMjI2O2Uua3NpY3lyaWxsaWM9MTEzNTtlLmt0c3F1YXJlPTEzMjYzO2Uua3R1cm5lZD02NzA7ZS5rdWhpcmFnYW5hPTEyMzY3O2Uua3VrYXRha2FuYT0xMjQ2MztlLmt1a2F0YWthbmFoYWxmd2lkdGg9NjU0MDA7ZS5rdnNxdWFyZT0xMzI0MDtlLmt3c3F1YXJlPTEzMjQ2O2UubD0xMDg7ZS5sYWJlbmdhbGk9MjQ4MjtlLmxhY3V0ZT0zMTQ7ZS5sYWRldmE9MjM1NDtlLmxhZ3VqYXJhdGk9MjczODtlLmxhZ3VybXVraGk9MjYxMDtlLmxha2toYW5neWFvdGhhaT0zNjUzO2UubGFtYWxlZmZpbmFsYXJhYmljPTY1Mjc2O2UubGFtYWxlZmhhbXphYWJvdmVmaW5hbGFyYWJpYz02NTI3MjtlLmxhbWFsZWZoYW16YWFib3ZlaXNvbGF0ZWRhcmFiaWM9NjUyNzE7ZS5sYW1hbGVmaGFtemFiZWxvd2ZpbmFsYXJhYmljPTY1Mjc0O2UubGFtYWxlZmhhbXphYmVsb3dpc29sYXRlZGFyYWJpYz02NTI3MztlLmxhbWFsZWZpc29sYXRlZGFyYWJpYz02NTI3NTtlLmxhbWFsZWZtYWRkYWFib3ZlZmluYWxhcmFiaWM9NjUyNzA7ZS5sYW1hbGVmbWFkZGFhYm92ZWlzb2xhdGVkYXJhYmljPTY1MjY5O2UubGFtYXJhYmljPTE2MDQ7ZS5sYW1iZGE9OTU1O2UubGFtYmRhc3Ryb2tlPTQxMTtlLmxhbWVkPTE1MDA7ZS5sYW1lZGRhZ2VzaD02NDMxNjtlLmxhbWVkZGFnZXNoaGVicmV3PTY0MzE2O2UubGFtZWRoZWJyZXc9MTUwMDtlLmxhbWZpbmFsYXJhYmljPTY1MjQ2O2UubGFtaGFoaW5pdGlhbGFyYWJpYz02NDcxNDtlLmxhbWluaXRpYWxhcmFiaWM9NjUyNDc7ZS5sYW1qZWVtaW5pdGlhbGFyYWJpYz02NDcxMztlLmxhbWtoYWhpbml0aWFsYXJhYmljPTY0NzE1O2UubGFtbGFtaGVoaXNvbGF0ZWRhcmFiaWM9NjUwMTA7ZS5sYW1tZWRpYWxhcmFiaWM9NjUyNDg7ZS5sYW1tZWVtaGFoaW5pdGlhbGFyYWJpYz02NDkwNDtlLmxhbW1lZW1pbml0aWFsYXJhYmljPTY0NzE2O2UubGFyZ2VjaXJjbGU9OTcxMTtlLmxiYXI9NDEwO2UubGJlbHQ9NjIwO2UubGJvcG9tb2ZvPTEyNTU2O2UubGNhcm9uPTMxODtlLmxjZWRpbGxhPTMxNjtlLmxjaXJjbGU9OTQzNTtlLmxjaXJjdW1mbGV4YmVsb3c9Nzc0MTtlLmxjb21tYWFjY2VudD0zMTY7ZS5sZG90PTMyMDtlLmxkb3RhY2NlbnQ9MzIwO2UubGRvdGJlbG93PTc3MzU7ZS5sZG90YmVsb3dtYWNyb249NzczNztlLmxlZnRhbmdsZWFib3ZlY21iPTc5NDtlLmxlZnR0YWNrYmVsb3djbWI9NzkyO2UubGVzcz02MDtlLmxlc3NlcXVhbD04ODA0O2UubGVzc2VxdWFsb3JncmVhdGVyPTg5MjI7ZS5sZXNzbW9ub3NwYWNlPTY1MzA4O2UubGVzc29yZXF1aXZhbGVudD04ODE4O2UubGVzc29yZ3JlYXRlcj04ODIyO2UubGVzc292ZXJlcXVhbD04ODA2O2UubGVzc3NtYWxsPTY1MTI0O2UubGV6aD02MjI7ZS5sZmJsb2NrPTk2MTI7ZS5saG9va3JldHJvZmxleD02MjE7ZS5saXJhPTgzNTY7ZS5saXduYXJtZW5pYW49MTM4ODtlLmxqPTQ1NztlLmxqZWN5cmlsbGljPTExMTM7ZS5sbD02MzE2ODtlLmxsYWRldmE9MjM1NTtlLmxsYWd1amFyYXRpPTI3Mzk7ZS5sbGluZWJlbG93PTc3Mzk7ZS5sbGxhZGV2YT0yMzU2O2UubGx2b2NhbGljYmVuZ2FsaT0yNTI5O2UubGx2b2NhbGljZGV2YT0yNDAxO2UubGx2b2NhbGljdm93ZWxzaWduYmVuZ2FsaT0yNTMxO2UubGx2b2NhbGljdm93ZWxzaWduZGV2YT0yNDAzO2UubG1pZGRsZXRpbGRlPTYxOTtlLmxtb25vc3BhY2U9NjUzNTY7ZS5sbXNxdWFyZT0xMzI2NDtlLmxvY2h1bGF0aGFpPTM2Mjg7ZS5sb2dpY2FsYW5kPTg3NDM7ZS5sb2dpY2Fsbm90PTE3MjtlLmxvZ2ljYWxub3RyZXZlcnNlZD04OTc2O2UubG9naWNhbG9yPTg3NDQ7ZS5sb2xpbmd0aGFpPTM2MjE7ZS5sb25ncz0zODM7ZS5sb3dsaW5lY2VudGVybGluZT02NTEwMjtlLmxvd2xpbmVjbWI9ODE4O2UubG93bGluZWRhc2hlZD02NTEwMTtlLmxvemVuZ2U9OTY3NDtlLmxwYXJlbj05MzgzO2UubHNsYXNoPTMyMjtlLmxzcXVhcmU9ODQ2NztlLmxzdXBlcmlvcj02MzIxNDtlLmx0c2hhZGU9OTYxNztlLmx1dGhhaT0zNjIyO2UubHZvY2FsaWNiZW5nYWxpPTI0NDQ7ZS5sdm9jYWxpY2RldmE9MjMxNjtlLmx2b2NhbGljdm93ZWxzaWduYmVuZ2FsaT0yNTMwO2UubHZvY2FsaWN2b3dlbHNpZ25kZXZhPTI0MDI7ZS5seHNxdWFyZT0xMzI2NztlLm09MTA5O2UubWFiZW5nYWxpPTI0Nzg7ZS5tYWNyb249MTc1O2UubWFjcm9uYmVsb3djbWI9ODE3O2UubWFjcm9uY21iPTc3MjtlLm1hY3Jvbmxvd21vZD03MTc7ZS5tYWNyb25tb25vc3BhY2U9NjU1MDc7ZS5tYWN1dGU9Nzc0MztlLm1hZGV2YT0yMzUwO2UubWFndWphcmF0aT0yNzM0O2UubWFndXJtdWtoaT0yNjA2O2UubWFoYXBha2hoZWJyZXc9MTQ0NDtlLm1haGFwYWtobGVmdGhlYnJldz0xNDQ0O2UubWFoaXJhZ2FuYT0xMjQxNDtlLm1haWNoYXR0YXdhbG93bGVmdHRoYWk9NjM2Mzc7ZS5tYWljaGF0dGF3YWxvd3JpZ2h0dGhhaT02MzYzNjtlLm1haWNoYXR0YXdhdGhhaT0zNjU5O2UubWFpY2hhdHRhd2F1cHBlcmxlZnR0aGFpPTYzNjM1O2UubWFpZWtsb3dsZWZ0dGhhaT02MzYyODtlLm1haWVrbG93cmlnaHR0aGFpPTYzNjI3O2UubWFpZWt0aGFpPTM2NTY7ZS5tYWlla3VwcGVybGVmdHRoYWk9NjM2MjY7ZS5tYWloYW5ha2F0bGVmdHRoYWk9NjM2MjA7ZS5tYWloYW5ha2F0dGhhaT0zNjMzO2UubWFpdGFpa2h1bGVmdHRoYWk9NjM2MjU7ZS5tYWl0YWlraHV0aGFpPTM2NTU7ZS5tYWl0aG9sb3dsZWZ0dGhhaT02MzYzMTtlLm1haXRob2xvd3JpZ2h0dGhhaT02MzYzMDtlLm1haXRob3RoYWk9MzY1NztlLm1haXRob3VwcGVybGVmdHRoYWk9NjM2Mjk7ZS5tYWl0cmlsb3dsZWZ0dGhhaT02MzYzNDtlLm1haXRyaWxvd3JpZ2h0dGhhaT02MzYzMztlLm1haXRyaXRoYWk9MzY1ODtlLm1haXRyaXVwcGVybGVmdHRoYWk9NjM2MzI7ZS5tYWl5YW1va3RoYWk9MzY1NDtlLm1ha2F0YWthbmE9MTI1MTA7ZS5tYWthdGFrYW5haGFsZndpZHRoPTY1NDIzO2UubWFsZT05Nzk0O2UubWFuc3lvbnNxdWFyZT0xMzEyNztlLm1hcWFmaGVicmV3PTE0NzA7ZS5tYXJzPTk3OTQ7ZS5tYXNvcmFjaXJjbGVoZWJyZXc9MTQ1NTtlLm1hc3F1YXJlPTEzMTg3O2UubWJvcG9tb2ZvPTEyNTUxO2UubWJzcXVhcmU9MTMyNjg7ZS5tY2lyY2xlPTk0MzY7ZS5tY3ViZWRzcXVhcmU9MTMyMjE7ZS5tZG90YWNjZW50PTc3NDU7ZS5tZG90YmVsb3c9Nzc0NztlLm1lZW1hcmFiaWM9MTYwNTtlLm1lZW1maW5hbGFyYWJpYz02NTI1MDtlLm1lZW1pbml0aWFsYXJhYmljPTY1MjUxO2UubWVlbW1lZGlhbGFyYWJpYz02NTI1MjtlLm1lZW1tZWVtaW5pdGlhbGFyYWJpYz02NDcyMTtlLm1lZW1tZWVtaXNvbGF0ZWRhcmFiaWM9NjQ1ODQ7ZS5tZWV0b3J1c3F1YXJlPTEzMTMzO2UubWVoaXJhZ2FuYT0xMjQxNztlLm1laXppZXJhc3F1YXJlPTEzMTgyO2UubWVrYXRha2FuYT0xMjUxMztlLm1la2F0YWthbmFoYWxmd2lkdGg9NjU0MjY7ZS5tZW09MTUwMjtlLm1lbWRhZ2VzaD02NDMxODtlLm1lbWRhZ2VzaGhlYnJldz02NDMxODtlLm1lbWhlYnJldz0xNTAyO2UubWVuYXJtZW5pYW49MTM5NjtlLm1lcmtoYWhlYnJldz0xNDQ1O2UubWVya2hha2VmdWxhaGVicmV3PTE0NDY7ZS5tZXJraGFrZWZ1bGFsZWZ0aGVicmV3PTE0NDY7ZS5tZXJraGFsZWZ0aGVicmV3PTE0NDU7ZS5taG9vaz02MjU7ZS5taHpzcXVhcmU9MTMyMDI7ZS5taWRkbGVkb3RrYXRha2FuYWhhbGZ3aWR0aD02NTM4MTtlLm1pZGRvdD0xODM7ZS5taWV1bWFjaXJjbGVrb3JlYW49MTI5MTQ7ZS5taWV1bWFwYXJlbmtvcmVhbj0xMjgxODtlLm1pZXVtY2lyY2xla29yZWFuPTEyOTAwO2UubWlldW1rb3JlYW49MTI2MDk7ZS5taWV1bXBhbnNpb3Nrb3JlYW49MTI2NTY7ZS5taWV1bXBhcmVua29yZWFuPTEyODA0O2UubWlldW1waWV1cGtvcmVhbj0xMjY1NDtlLm1pZXVtc2lvc2tvcmVhbj0xMjY1NTtlLm1paGlyYWdhbmE9MTI0MTU7ZS5taWthdGFrYW5hPTEyNTExO2UubWlrYXRha2FuYWhhbGZ3aWR0aD02NTQyNDtlLm1pbnVzPTg3MjI7ZS5taW51c2JlbG93Y21iPTgwMDtlLm1pbnVzY2lyY2xlPTg4NTQ7ZS5taW51c21vZD03Mjc7ZS5taW51c3BsdXM9ODcyMztlLm1pbnV0ZT04MjQyO2UubWlyaWJhYXJ1c3F1YXJlPTEzMTMwO2UubWlyaXNxdWFyZT0xMzEyOTtlLm1sb25nbGVndHVybmVkPTYyNDtlLm1sc3F1YXJlPTEzMjA2O2UubW1jdWJlZHNxdWFyZT0xMzIxOTtlLm1tb25vc3BhY2U9NjUzNTc7ZS5tbXNxdWFyZWRzcXVhcmU9MTMyMTU7ZS5tb2hpcmFnYW5hPTEyNDE4O2UubW9obXNxdWFyZT0xMzI0OTtlLm1va2F0YWthbmE9MTI1MTQ7ZS5tb2thdGFrYW5haGFsZndpZHRoPTY1NDI3O2UubW9sc3F1YXJlPTEzMjcwO2UubW9tYXRoYWk9MzYxNztlLm1vdmVyc3NxdWFyZT0xMzIyMztlLm1vdmVyc3NxdWFyZWRzcXVhcmU9MTMyMjQ7ZS5tcGFyZW49OTM4NDtlLm1wYXNxdWFyZT0xMzIyNztlLm1zc3F1YXJlPTEzMjM1O2UubXN1cGVyaW9yPTYzMjE1O2UubXR1cm5lZD02MjM7ZS5tdT0xODE7ZS5tdTE9MTgxO2UubXVhc3F1YXJlPTEzMTg2O2UubXVjaGdyZWF0ZXI9ODgxMTtlLm11Y2hsZXNzPTg4MTA7ZS5tdWZzcXVhcmU9MTMxOTY7ZS5tdWdyZWVrPTk1NjtlLm11Z3NxdWFyZT0xMzE5NztlLm11aGlyYWdhbmE9MTI0MTY7ZS5tdWthdGFrYW5hPTEyNTEyO2UubXVrYXRha2FuYWhhbGZ3aWR0aD02NTQyNTtlLm11bHNxdWFyZT0xMzIwNTtlLm11bHRpcGx5PTIxNTtlLm11bXNxdWFyZT0xMzIxMTtlLm11bmFoaGVicmV3PTE0NDM7ZS5tdW5haGxlZnRoZWJyZXc9MTQ0MztlLm11c2ljYWxub3RlPTk4MzQ7ZS5tdXNpY2Fsbm90ZWRibD05ODM1O2UubXVzaWNmbGF0c2lnbj05ODM3O2UubXVzaWNzaGFycHNpZ249OTgzOTtlLm11c3NxdWFyZT0xMzIzNDtlLm11dnNxdWFyZT0xMzIzODtlLm11d3NxdWFyZT0xMzI0NDtlLm12bWVnYXNxdWFyZT0xMzI0MTtlLm12c3F1YXJlPTEzMjM5O2UubXdtZWdhc3F1YXJlPTEzMjQ3O2UubXdzcXVhcmU9MTMyNDU7ZS5uPTExMDtlLm5hYmVuZ2FsaT0yNDcyO2UubmFibGE9ODcxMTtlLm5hY3V0ZT0zMjQ7ZS5uYWRldmE9MjM0NDtlLm5hZ3VqYXJhdGk9MjcyODtlLm5hZ3VybXVraGk9MjYwMDtlLm5haGlyYWdhbmE9MTIzOTQ7ZS5uYWthdGFrYW5hPTEyNDkwO2UubmFrYXRha2FuYWhhbGZ3aWR0aD02NTQxMztlLm5hcG9zdHJvcGhlPTMyOTtlLm5hc3F1YXJlPTEzMTg1O2UubmJvcG9tb2ZvPTEyNTU1O2UubmJzcGFjZT0xNjA7ZS5uY2Fyb249MzI4O2UubmNlZGlsbGE9MzI2O2UubmNpcmNsZT05NDM3O2UubmNpcmN1bWZsZXhiZWxvdz03NzU1O2UubmNvbW1hYWNjZW50PTMyNjtlLm5kb3RhY2NlbnQ9Nzc0OTtlLm5kb3RiZWxvdz03NzUxO2UubmVoaXJhZ2FuYT0xMjM5NztlLm5la2F0YWthbmE9MTI0OTM7ZS5uZWthdGFrYW5haGFsZndpZHRoPTY1NDE2O2UubmV3c2hlcWVsc2lnbj04MzYyO2UubmZzcXVhcmU9MTMxOTU7ZS5uZ2FiZW5nYWxpPTI0NTc7ZS5uZ2FkZXZhPTIzMjk7ZS5uZ2FndWphcmF0aT0yNzEzO2UubmdhZ3VybXVraGk9MjU4NTtlLm5nb25ndXRoYWk9MzU5MTtlLm5oaXJhZ2FuYT0xMjQzNTtlLm5ob29rbGVmdD02MjY7ZS5uaG9va3JldHJvZmxleD02Mjc7ZS5uaWV1bmFjaXJjbGVrb3JlYW49MTI5MTE7ZS5uaWV1bmFwYXJlbmtvcmVhbj0xMjgxNTtlLm5pZXVuY2lldWNrb3JlYW49MTI1OTc7ZS5uaWV1bmNpcmNsZWtvcmVhbj0xMjg5NztlLm5pZXVuaGlldWhrb3JlYW49MTI1OTg7ZS5uaWV1bmtvcmVhbj0xMjU5NjtlLm5pZXVucGFuc2lvc2tvcmVhbj0xMjY0ODtlLm5pZXVucGFyZW5rb3JlYW49MTI4MDE7ZS5uaWV1bnNpb3Nrb3JlYW49MTI2NDc7ZS5uaWV1bnRpa2V1dGtvcmVhbj0xMjY0NjtlLm5paGlyYWdhbmE9MTIzOTU7ZS5uaWthdGFrYW5hPTEyNDkxO2UubmlrYXRha2FuYWhhbGZ3aWR0aD02NTQxNDtlLm5pa2hhaGl0bGVmdHRoYWk9NjM2NDE7ZS5uaWtoYWhpdHRoYWk9MzY2MTtlLm5pbmU9NTc7ZS5uaW5lYXJhYmljPTE2NDE7ZS5uaW5lYmVuZ2FsaT0yNTQzO2UubmluZWNpcmNsZT05MzIwO2UubmluZWNpcmNsZWludmVyc2VzYW5zc2VyaWY9MTAxMzA7ZS5uaW5lZGV2YT0yNDE1O2UubmluZWd1amFyYXRpPTI3OTk7ZS5uaW5lZ3VybXVraGk9MjY3MTtlLm5pbmVoYWNrYXJhYmljPTE2NDE7ZS5uaW5laGFuZ3pob3U9MTIzMjk7ZS5uaW5laWRlb2dyYXBoaWNwYXJlbj0xMjg0MDtlLm5pbmVpbmZlcmlvcj04MzI5O2UubmluZW1vbm9zcGFjZT02NTMwNTtlLm5pbmVvbGRzdHlsZT02MzI4OTtlLm5pbmVwYXJlbj05MzQwO2UubmluZXBlcmlvZD05MzYwO2UubmluZXBlcnNpYW49MTc4NTtlLm5pbmVyb21hbj04NTY4O2UubmluZXN1cGVyaW9yPTgzMTM7ZS5uaW5ldGVlbmNpcmNsZT05MzMwO2UubmluZXRlZW5wYXJlbj05MzUwO2UubmluZXRlZW5wZXJpb2Q9OTM3MDtlLm5pbmV0aGFpPTM2NzM7ZS5uaj00NjA7ZS5uamVjeXJpbGxpYz0xMTE0O2UubmthdGFrYW5hPTEyNTMxO2UubmthdGFrYW5haGFsZndpZHRoPTY1NDM3O2UubmxlZ3JpZ2h0bG9uZz00MTQ7ZS5ubGluZWJlbG93PTc3NTM7ZS5ubW9ub3NwYWNlPTY1MzU4O2Uubm1zcXVhcmU9MTMyMTA7ZS5ubmFiZW5nYWxpPTI0Njc7ZS5ubmFkZXZhPTIzMzk7ZS5ubmFndWphcmF0aT0yNzIzO2Uubm5hZ3VybXVraGk9MjU5NTtlLm5ubmFkZXZhPTIzNDU7ZS5ub2hpcmFnYW5hPTEyMzk4O2Uubm9rYXRha2FuYT0xMjQ5NDtlLm5va2F0YWthbmFoYWxmd2lkdGg9NjU0MTc7ZS5ub25icmVha2luZ3NwYWNlPTE2MDtlLm5vbmVudGhhaT0zNjAzO2Uubm9udXRoYWk9MzYwOTtlLm5vb25hcmFiaWM9MTYwNjtlLm5vb25maW5hbGFyYWJpYz02NTI1NDtlLm5vb25naHVubmFhcmFiaWM9MTcyMjtlLm5vb25naHVubmFmaW5hbGFyYWJpYz02NDQxNTtlLm5vb25pbml0aWFsYXJhYmljPTY1MjU1O2Uubm9vbmplZW1pbml0aWFsYXJhYmljPTY0NzIyO2Uubm9vbmplZW1pc29sYXRlZGFyYWJpYz02NDU4NztlLm5vb25tZWRpYWxhcmFiaWM9NjUyNTY7ZS5ub29ubWVlbWluaXRpYWxhcmFiaWM9NjQ3MjU7ZS5ub29ubWVlbWlzb2xhdGVkYXJhYmljPTY0NTkwO2Uubm9vbm5vb25maW5hbGFyYWJpYz02NDY1MztlLm5vdGNvbnRhaW5zPTg3MTY7ZS5ub3RlbGVtZW50PTg3MTM7ZS5ub3RlbGVtZW50b2Y9ODcxMztlLm5vdGVxdWFsPTg4MDA7ZS5ub3RncmVhdGVyPTg4MTU7ZS5ub3RncmVhdGVybm9yZXF1YWw9ODgxNztlLm5vdGdyZWF0ZXJub3JsZXNzPTg4MjU7ZS5ub3RpZGVudGljYWw9ODgwMjtlLm5vdGxlc3M9ODgxNDtlLm5vdGxlc3Nub3JlcXVhbD04ODE2O2Uubm90cGFyYWxsZWw9ODc0MjtlLm5vdHByZWNlZGVzPTg4MzI7ZS5ub3RzdWJzZXQ9ODgzNjtlLm5vdHN1Y2NlZWRzPTg4MzM7ZS5ub3RzdXBlcnNldD04ODM3O2Uubm93YXJtZW5pYW49MTM5ODtlLm5wYXJlbj05Mzg1O2UubnNzcXVhcmU9MTMyMzM7ZS5uc3VwZXJpb3I9ODMxOTtlLm50aWxkZT0yNDE7ZS5udT05NTc7ZS5udWhpcmFnYW5hPTEyMzk2O2UubnVrYXRha2FuYT0xMjQ5MjtlLm51a2F0YWthbmFoYWxmd2lkdGg9NjU0MTU7ZS5udWt0YWJlbmdhbGk9MjQ5MjtlLm51a3RhZGV2YT0yMzY0O2UubnVrdGFndWphcmF0aT0yNzQ4O2UubnVrdGFndXJtdWtoaT0yNjIwO2UubnVtYmVyc2lnbj0zNTtlLm51bWJlcnNpZ25tb25vc3BhY2U9NjUyODM7ZS5udW1iZXJzaWduc21hbGw9NjUxMTk7ZS5udW1lcmFsc2lnbmdyZWVrPTg4NDtlLm51bWVyYWxzaWdubG93ZXJncmVlaz04ODU7ZS5udW1lcm89ODQ3MDtlLm51bj0xNTA0O2UubnVuZGFnZXNoPTY0MzIwO2UubnVuZGFnZXNoaGVicmV3PTY0MzIwO2UubnVuaGVicmV3PTE1MDQ7ZS5udnNxdWFyZT0xMzIzNztlLm53c3F1YXJlPTEzMjQzO2UubnlhYmVuZ2FsaT0yNDYyO2UubnlhZGV2YT0yMzM0O2UubnlhZ3VqYXJhdGk9MjcxODtlLm55YWd1cm11a2hpPTI1OTA7ZS5vPTExMTtlLm9hY3V0ZT0yNDM7ZS5vYW5ndGhhaT0zNjI5O2Uub2JhcnJlZD02Mjk7ZS5vYmFycmVkY3lyaWxsaWM9MTI1NztlLm9iYXJyZWRkaWVyZXNpc2N5cmlsbGljPTEyNTk7ZS5vYmVuZ2FsaT0yNDUxO2Uub2JvcG9tb2ZvPTEyNTcxO2Uub2JyZXZlPTMzNTtlLm9jYW5kcmFkZXZhPTIzMjE7ZS5vY2FuZHJhZ3VqYXJhdGk9MjcwNTtlLm9jYW5kcmF2b3dlbHNpZ25kZXZhPTIzNzc7ZS5vY2FuZHJhdm93ZWxzaWduZ3VqYXJhdGk9Mjc2MTtlLm9jYXJvbj00NjY7ZS5vY2lyY2xlPTk0Mzg7ZS5vY2lyY3VtZmxleD0yNDQ7ZS5vY2lyY3VtZmxleGFjdXRlPTc4ODk7ZS5vY2lyY3VtZmxleGRvdGJlbG93PTc4OTc7ZS5vY2lyY3VtZmxleGdyYXZlPTc4OTE7ZS5vY2lyY3VtZmxleGhvb2thYm92ZT03ODkzO2Uub2NpcmN1bWZsZXh0aWxkZT03ODk1O2Uub2N5cmlsbGljPTEwODY7ZS5vZGJsYWN1dGU9MzM3O2Uub2RibGdyYXZlPTUyNTtlLm9kZXZhPTIzMjM7ZS5vZGllcmVzaXM9MjQ2O2Uub2RpZXJlc2lzY3lyaWxsaWM9MTI1NTtlLm9kb3RiZWxvdz03ODg1O2Uub2U9MzM5O2Uub2Vrb3JlYW49MTI2MzQ7ZS5vZ29uZWs9NzMxO2Uub2dvbmVrY21iPTgwODtlLm9ncmF2ZT0yNDI7ZS5vZ3VqYXJhdGk9MjcwNztlLm9oYXJtZW5pYW49MTQxMztlLm9oaXJhZ2FuYT0xMjM2MjtlLm9ob29rYWJvdmU9Nzg4NztlLm9ob3JuPTQxNztlLm9ob3JuYWN1dGU9Nzg5OTtlLm9ob3JuZG90YmVsb3c9NzkwNztlLm9ob3JuZ3JhdmU9NzkwMTtlLm9ob3JuaG9va2Fib3ZlPTc5MDM7ZS5vaG9ybnRpbGRlPTc5MDU7ZS5vaHVuZ2FydW1sYXV0PTMzNztlLm9pPTQxOTtlLm9pbnZlcnRlZGJyZXZlPTUyNztlLm9rYXRha2FuYT0xMjQ1ODtlLm9rYXRha2FuYWhhbGZ3aWR0aD02NTM5NztlLm9rb3JlYW49MTI2MzE7ZS5vbGVoZWJyZXc9MTQ1MTtlLm9tYWNyb249MzMzO2Uub21hY3JvbmFjdXRlPTc3NjM7ZS5vbWFjcm9uZ3JhdmU9Nzc2MTtlLm9tZGV2YT0yMzg0O2Uub21lZ2E9OTY5O2Uub21lZ2ExPTk4MjtlLm9tZWdhY3lyaWxsaWM9MTEyMTtlLm9tZWdhbGF0aW5jbG9zZWQ9NjMxO2Uub21lZ2Fyb3VuZGN5cmlsbGljPTExNDc7ZS5vbWVnYXRpdGxvY3lyaWxsaWM9MTE0OTtlLm9tZWdhdG9ub3M9OTc0O2Uub21ndWphcmF0aT0yNzY4O2Uub21pY3Jvbj05NTk7ZS5vbWljcm9udG9ub3M9OTcyO2Uub21vbm9zcGFjZT02NTM1OTtlLm9uZT00OTtlLm9uZWFyYWJpYz0xNjMzO2Uub25lYmVuZ2FsaT0yNTM1O2Uub25lY2lyY2xlPTkzMTI7ZS5vbmVjaXJjbGVpbnZlcnNlc2Fuc3NlcmlmPTEwMTIyO2Uub25lZGV2YT0yNDA3O2Uub25lZG90ZW5sZWFkZXI9ODIyODtlLm9uZWVpZ2h0aD04NTM5O2Uub25lZml0dGVkPTYzMTk2O2Uub25lZ3VqYXJhdGk9Mjc5MTtlLm9uZWd1cm11a2hpPTI2NjM7ZS5vbmVoYWNrYXJhYmljPTE2MzM7ZS5vbmVoYWxmPTE4OTtlLm9uZWhhbmd6aG91PTEyMzIxO2Uub25laWRlb2dyYXBoaWNwYXJlbj0xMjgzMjtlLm9uZWluZmVyaW9yPTgzMjE7ZS5vbmVtb25vc3BhY2U9NjUyOTc7ZS5vbmVudW1lcmF0b3JiZW5nYWxpPTI1NDg7ZS5vbmVvbGRzdHlsZT02MzI4MTtlLm9uZXBhcmVuPTkzMzI7ZS5vbmVwZXJpb2Q9OTM1MjtlLm9uZXBlcnNpYW49MTc3NztlLm9uZXF1YXJ0ZXI9MTg4O2Uub25lcm9tYW49ODU2MDtlLm9uZXN1cGVyaW9yPTE4NTtlLm9uZXRoYWk9MzY2NTtlLm9uZXRoaXJkPTg1MzE7ZS5vb2dvbmVrPTQ5MTtlLm9vZ29uZWttYWNyb249NDkzO2Uub29ndXJtdWtoaT0yNTc5O2Uub29tYXRyYWd1cm11a2hpPTI2MzU7ZS5vb3Blbj01OTY7ZS5vcGFyZW49OTM4NjtlLm9wZW5idWxsZXQ9OTcwMjtlLm9wdGlvbj04OTk3O2Uub3JkZmVtaW5pbmU9MTcwO2Uub3JkbWFzY3VsaW5lPTE4NjtlLm9ydGhvZ29uYWw9ODczNTtlLm9zaG9ydGRldmE9MjMyMjtlLm9zaG9ydHZvd2Vsc2lnbmRldmE9MjM3ODtlLm9zbGFzaD0yNDg7ZS5vc2xhc2hhY3V0ZT01MTE7ZS5vc21hbGxoaXJhZ2FuYT0xMjM2MTtlLm9zbWFsbGthdGFrYW5hPTEyNDU3O2Uub3NtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODc7ZS5vc3Ryb2tlYWN1dGU9NTExO2Uub3N1cGVyaW9yPTYzMjE2O2Uub3RjeXJpbGxpYz0xMTUxO2Uub3RpbGRlPTI0NTtlLm90aWxkZWFjdXRlPTc3NTc7ZS5vdGlsZGVkaWVyZXNpcz03NzU5O2Uub3Vib3BvbW9mbz0xMjU3NztlLm92ZXJsaW5lPTgyNTQ7ZS5vdmVybGluZWNlbnRlcmxpbmU9NjUwOTg7ZS5vdmVybGluZWNtYj03NzM7ZS5vdmVybGluZWRhc2hlZD02NTA5NztlLm92ZXJsaW5lZGJsd2F2eT02NTEwMDtlLm92ZXJsaW5ld2F2eT02NTA5OTtlLm92ZXJzY29yZT0xNzU7ZS5vdm93ZWxzaWduYmVuZ2FsaT0yNTA3O2Uub3Zvd2Vsc2lnbmRldmE9MjM3OTtlLm92b3dlbHNpZ25ndWphcmF0aT0yNzYzO2UucD0xMTI7ZS5wYWFtcHNzcXVhcmU9MTMxODQ7ZS5wYWFzZW50b3NxdWFyZT0xMzA5OTtlLnBhYmVuZ2FsaT0yNDc0O2UucGFjdXRlPTc3NjU7ZS5wYWRldmE9MjM0NjtlLnBhZ2Vkb3duPTg2NzE7ZS5wYWdldXA9ODY3MDtlLnBhZ3VqYXJhdGk9MjczMDtlLnBhZ3VybXVraGk9MjYwMjtlLnBhaGlyYWdhbmE9MTI0MDE7ZS5wYWl5YW5ub2l0aGFpPTM2MzE7ZS5wYWthdGFrYW5hPTEyNDk3O2UucGFsYXRhbGl6YXRpb25jeXJpbGxpY2NtYj0xMTU2O2UucGFsb2Noa2FjeXJpbGxpYz0xMjE2O2UucGFuc2lvc2tvcmVhbj0xMjY3MTtlLnBhcmFncmFwaD0xODI7ZS5wYXJhbGxlbD04NzQxO2UucGFyZW5sZWZ0PTQwO2UucGFyZW5sZWZ0YWx0b25lYXJhYmljPTY0ODMwO2UucGFyZW5sZWZ0YnQ9NjM3MjU7ZS5wYXJlbmxlZnRleD02MzcyNDtlLnBhcmVubGVmdGluZmVyaW9yPTgzMzM7ZS5wYXJlbmxlZnRtb25vc3BhY2U9NjUyODg7ZS5wYXJlbmxlZnRzbWFsbD02NTExMztlLnBhcmVubGVmdHN1cGVyaW9yPTgzMTc7ZS5wYXJlbmxlZnR0cD02MzcyMztlLnBhcmVubGVmdHZlcnRpY2FsPTY1MDc3O2UucGFyZW5yaWdodD00MTtlLnBhcmVucmlnaHRhbHRvbmVhcmFiaWM9NjQ4MzE7ZS5wYXJlbnJpZ2h0YnQ9NjM3MzY7ZS5wYXJlbnJpZ2h0ZXg9NjM3MzU7ZS5wYXJlbnJpZ2h0aW5mZXJpb3I9ODMzNDtlLnBhcmVucmlnaHRtb25vc3BhY2U9NjUyODk7ZS5wYXJlbnJpZ2h0c21hbGw9NjUxMTQ7ZS5wYXJlbnJpZ2h0c3VwZXJpb3I9ODMxODtlLnBhcmVucmlnaHR0cD02MzczNDtlLnBhcmVucmlnaHR2ZXJ0aWNhbD02NTA3ODtlLnBhcnRpYWxkaWZmPTg3MDY7ZS5wYXNlcWhlYnJldz0xNDcyO2UucGFzaHRhaGVicmV3PTE0MzM7ZS5wYXNxdWFyZT0xMzIyNTtlLnBhdGFoPTE0NjM7ZS5wYXRhaDExPTE0NjM7ZS5wYXRhaDFkPTE0NjM7ZS5wYXRhaDJhPTE0NjM7ZS5wYXRhaGhlYnJldz0xNDYzO2UucGF0YWhuYXJyb3doZWJyZXc9MTQ2MztlLnBhdGFocXVhcnRlcmhlYnJldz0xNDYzO2UucGF0YWh3aWRlaGVicmV3PTE0NjM7ZS5wYXplcmhlYnJldz0xNDQxO2UucGJvcG9tb2ZvPTEyNTUwO2UucGNpcmNsZT05NDM5O2UucGRvdGFjY2VudD03NzY3O2UucGU9MTUwODtlLnBlY3lyaWxsaWM9MTA4NztlLnBlZGFnZXNoPTY0MzI0O2UucGVkYWdlc2hoZWJyZXc9NjQzMjQ7ZS5wZWV6aXNxdWFyZT0xMzExNTtlLnBlZmluYWxkYWdlc2hoZWJyZXc9NjQzMjM7ZS5wZWhhcmFiaWM9MTY2MjtlLnBlaGFybWVuaWFuPTE0MDI7ZS5wZWhlYnJldz0xNTA4O2UucGVoZmluYWxhcmFiaWM9NjQzNDM7ZS5wZWhpbml0aWFsYXJhYmljPTY0MzQ0O2UucGVoaXJhZ2FuYT0xMjQxMDtlLnBlaG1lZGlhbGFyYWJpYz02NDM0NTtlLnBla2F0YWthbmE9MTI1MDY7ZS5wZW1pZGRsZWhvb2tjeXJpbGxpYz0xMTkxO2UucGVyYWZlaGVicmV3PTY0MzM0O2UucGVyY2VudD0zNztlLnBlcmNlbnRhcmFiaWM9MTY0MjtlLnBlcmNlbnRtb25vc3BhY2U9NjUyODU7ZS5wZXJjZW50c21hbGw9NjUxMzA7ZS5wZXJpb2Q9NDY7ZS5wZXJpb2Rhcm1lbmlhbj0xNDE3O2UucGVyaW9kY2VudGVyZWQ9MTgzO2UucGVyaW9kaGFsZndpZHRoPTY1Mzc3O2UucGVyaW9kaW5mZXJpb3I9NjMyMDc7ZS5wZXJpb2Rtb25vc3BhY2U9NjUyOTQ7ZS5wZXJpb2RzbWFsbD02NTEwNjtlLnBlcmlvZHN1cGVyaW9yPTYzMjA4O2UucGVyaXNwb21lbmlncmVla2NtYj04MzQ7ZS5wZXJwZW5kaWN1bGFyPTg4Njk7ZS5wZXJ0aG91c2FuZD04MjQwO2UucGVzZXRhPTgzNTk7ZS5wZnNxdWFyZT0xMzE5NDtlLnBoYWJlbmdhbGk9MjQ3NTtlLnBoYWRldmE9MjM0NztlLnBoYWd1amFyYXRpPTI3MzE7ZS5waGFndXJtdWtoaT0yNjAzO2UucGhpPTk2NjtlLnBoaTE9OTgxO2UucGhpZXVwaGFjaXJjbGVrb3JlYW49MTI5MjI7ZS5waGlldXBoYXBhcmVua29yZWFuPTEyODI2O2UucGhpZXVwaGNpcmNsZWtvcmVhbj0xMjkwODtlLnBoaWV1cGhrb3JlYW49MTI2MjE7ZS5waGlldXBocGFyZW5rb3JlYW49MTI4MTI7ZS5waGlsYXRpbj02MzI7ZS5waGludGh1dGhhaT0zNjQyO2UucGhpc3ltYm9sZ3JlZWs9OTgxO2UucGhvb2s9NDIxO2UucGhvcGhhbnRoYWk9MzYxNDtlLnBob3BodW5ndGhhaT0zNjEyO2UucGhvc2FtcGhhb3RoYWk9MzYxNjtlLnBpPTk2MDtlLnBpZXVwYWNpcmNsZWtvcmVhbj0xMjkxNTtlLnBpZXVwYXBhcmVua29yZWFuPTEyODE5O2UucGlldXBjaWV1Y2tvcmVhbj0xMjY2MjtlLnBpZXVwY2lyY2xla29yZWFuPTEyOTAxO2UucGlldXBraXllb2trb3JlYW49MTI2NTg7ZS5waWV1cGtvcmVhbj0xMjYxMDtlLnBpZXVwcGFyZW5rb3JlYW49MTI4MDU7ZS5waWV1cHNpb3NraXllb2trb3JlYW49MTI2NjA7ZS5waWV1cHNpb3Nrb3JlYW49MTI2MTI7ZS5waWV1cHNpb3N0aWtldXRrb3JlYW49MTI2NjE7ZS5waWV1cHRoaWV1dGhrb3JlYW49MTI2NjM7ZS5waWV1cHRpa2V1dGtvcmVhbj0xMjY1OTtlLnBpaGlyYWdhbmE9MTI0MDQ7ZS5waWthdGFrYW5hPTEyNTAwO2UucGlzeW1ib2xncmVlaz05ODI7ZS5waXdyYXJtZW5pYW49MTQxMTtlLnBsYW5ja292ZXIycGk9ODQ2MztlLnBsYW5ja292ZXIycGkxPTg0NjM7ZS5wbHVzPTQzO2UucGx1c2JlbG93Y21iPTc5OTtlLnBsdXNjaXJjbGU9ODg1MztlLnBsdXNtaW51cz0xNzc7ZS5wbHVzbW9kPTcyNjtlLnBsdXNtb25vc3BhY2U9NjUyOTE7ZS5wbHVzc21hbGw9NjUxMjI7ZS5wbHVzc3VwZXJpb3I9ODMxNDtlLnBtb25vc3BhY2U9NjUzNjA7ZS5wbXNxdWFyZT0xMzI3MjtlLnBvaGlyYWdhbmE9MTI0MTM7ZS5wb2ludGluZ2luZGV4ZG93bndoaXRlPTk3NTk7ZS5wb2ludGluZ2luZGV4bGVmdHdoaXRlPTk3NTY7ZS5wb2ludGluZ2luZGV4cmlnaHR3aGl0ZT05NzU4O2UucG9pbnRpbmdpbmRleHVwd2hpdGU9OTc1NztlLnBva2F0YWthbmE9MTI1MDk7ZS5wb3BsYXRoYWk9MzYxMTtlLnBvc3RhbG1hcms9MTIzMDY7ZS5wb3N0YWxtYXJrZmFjZT0xMjMyMDtlLnBwYXJlbj05Mzg3O2UucHJlY2VkZXM9ODgyNjtlLnByZXNjcmlwdGlvbj04NDc4O2UucHJpbWVtb2Q9Njk3O2UucHJpbWVyZXZlcnNlZD04MjQ1O2UucHJvZHVjdD04NzE5O2UucHJvamVjdGl2ZT04OTY1O2UucHJvbG9uZ2Vka2FuYT0xMjU0MDtlLnByb3BlbGxvcj04OTg0O2UucHJvcGVyc3Vic2V0PTg4MzQ7ZS5wcm9wZXJzdXBlcnNldD04ODM1O2UucHJvcG9ydGlvbj04NzU5O2UucHJvcG9ydGlvbmFsPTg3MzM7ZS5wc2k9OTY4O2UucHNpY3lyaWxsaWM9MTEzNztlLnBzaWxpcG5ldW1hdGFjeXJpbGxpY2NtYj0xMTU4O2UucHNzcXVhcmU9MTMyMzI7ZS5wdWhpcmFnYW5hPTEyNDA3O2UucHVrYXRha2FuYT0xMjUwMztlLnB2c3F1YXJlPTEzMjM2O2UucHdzcXVhcmU9MTMyNDI7ZS5xPTExMztlLnFhZGV2YT0yMzkyO2UucWFkbWFoZWJyZXc9MTQ0ODtlLnFhZmFyYWJpYz0xNjAyO2UucWFmZmluYWxhcmFiaWM9NjUyMzg7ZS5xYWZpbml0aWFsYXJhYmljPTY1MjM5O2UucWFmbWVkaWFsYXJhYmljPTY1MjQwO2UucWFtYXRzPTE0NjQ7ZS5xYW1hdHMxMD0xNDY0O2UucWFtYXRzMWE9MTQ2NDtlLnFhbWF0czFjPTE0NjQ7ZS5xYW1hdHMyNz0xNDY0O2UucWFtYXRzMjk9MTQ2NDtlLnFhbWF0czMzPTE0NjQ7ZS5xYW1hdHNkZT0xNDY0O2UucWFtYXRzaGVicmV3PTE0NjQ7ZS5xYW1hdHNuYXJyb3doZWJyZXc9MTQ2NDtlLnFhbWF0c3FhdGFuaGVicmV3PTE0NjQ7ZS5xYW1hdHNxYXRhbm5hcnJvd2hlYnJldz0xNDY0O2UucWFtYXRzcWF0YW5xdWFydGVyaGVicmV3PTE0NjQ7ZS5xYW1hdHNxYXRhbndpZGVoZWJyZXc9MTQ2NDtlLnFhbWF0c3F1YXJ0ZXJoZWJyZXc9MTQ2NDtlLnFhbWF0c3dpZGVoZWJyZXc9MTQ2NDtlLnFhcm5leXBhcmFoZWJyZXc9MTQzOTtlLnFib3BvbW9mbz0xMjU2MTtlLnFjaXJjbGU9OTQ0MDtlLnFob29rPTY3MjtlLnFtb25vc3BhY2U9NjUzNjE7ZS5xb2Y9MTUxMTtlLnFvZmRhZ2VzaD02NDMyNztlLnFvZmRhZ2VzaGhlYnJldz02NDMyNztlLnFvZmhlYnJldz0xNTExO2UucXBhcmVuPTkzODg7ZS5xdWFydGVybm90ZT05ODMzO2UucXVidXRzPTE0Njc7ZS5xdWJ1dHMxOD0xNDY3O2UucXVidXRzMjU9MTQ2NztlLnF1YnV0czMxPTE0Njc7ZS5xdWJ1dHNoZWJyZXc9MTQ2NztlLnF1YnV0c25hcnJvd2hlYnJldz0xNDY3O2UucXVidXRzcXVhcnRlcmhlYnJldz0xNDY3O2UucXVidXRzd2lkZWhlYnJldz0xNDY3O2UucXVlc3Rpb249NjM7ZS5xdWVzdGlvbmFyYWJpYz0xNTY3O2UucXVlc3Rpb25hcm1lbmlhbj0xMzc0O2UucXVlc3Rpb25kb3duPTE5MTtlLnF1ZXN0aW9uZG93bnNtYWxsPTYzNDIzO2UucXVlc3Rpb25ncmVlaz04OTQ7ZS5xdWVzdGlvbm1vbm9zcGFjZT02NTMxMTtlLnF1ZXN0aW9uc21hbGw9NjMyOTU7ZS5xdW90ZWRibD0zNDtlLnF1b3RlZGJsYmFzZT04MjIyO2UucXVvdGVkYmxsZWZ0PTgyMjA7ZS5xdW90ZWRibG1vbm9zcGFjZT02NTI4MjtlLnF1b3RlZGJscHJpbWU9MTIzMTg7ZS5xdW90ZWRibHByaW1lcmV2ZXJzZWQ9MTIzMTc7ZS5xdW90ZWRibHJpZ2h0PTgyMjE7ZS5xdW90ZWxlZnQ9ODIxNjtlLnF1b3RlbGVmdHJldmVyc2VkPTgyMTk7ZS5xdW90ZXJldmVyc2VkPTgyMTk7ZS5xdW90ZXJpZ2h0PTgyMTc7ZS5xdW90ZXJpZ2h0bj0zMjk7ZS5xdW90ZXNpbmdsYmFzZT04MjE4O2UucXVvdGVzaW5nbGU9Mzk7ZS5xdW90ZXNpbmdsZW1vbm9zcGFjZT02NTI4NztlLnI9MTE0O2UucmFhcm1lbmlhbj0xNDA0O2UucmFiZW5nYWxpPTI0ODA7ZS5yYWN1dGU9MzQxO2UucmFkZXZhPTIzNTI7ZS5yYWRpY2FsPTg3MzA7ZS5yYWRpY2FsZXg9NjM3MTc7ZS5yYWRvdmVyc3NxdWFyZT0xMzIzMDtlLnJhZG92ZXJzc3F1YXJlZHNxdWFyZT0xMzIzMTtlLnJhZHNxdWFyZT0xMzIyOTtlLnJhZmU9MTQ3MTtlLnJhZmVoZWJyZXc9MTQ3MTtlLnJhZ3VqYXJhdGk9MjczNjtlLnJhZ3VybXVraGk9MjYwODtlLnJhaGlyYWdhbmE9MTI0MjU7ZS5yYWthdGFrYW5hPTEyNTIxO2UucmFrYXRha2FuYWhhbGZ3aWR0aD02NTQzMTtlLnJhbG93ZXJkaWFnb25hbGJlbmdhbGk9MjU0NTtlLnJhbWlkZGxlZGlhZ29uYWxiZW5nYWxpPTI1NDQ7ZS5yYW1zaG9ybj02MTI7ZS5yYXRpbz04NzU4O2UucmJvcG9tb2ZvPTEyNTY2O2UucmNhcm9uPTM0NTtlLnJjZWRpbGxhPTM0MztlLnJjaXJjbGU9OTQ0MTtlLnJjb21tYWFjY2VudD0zNDM7ZS5yZGJsZ3JhdmU9NTI5O2UucmRvdGFjY2VudD03NzY5O2UucmRvdGJlbG93PTc3NzE7ZS5yZG90YmVsb3dtYWNyb249Nzc3MztlLnJlZmVyZW5jZW1hcms9ODI1MTtlLnJlZmxleHN1YnNldD04ODM4O2UucmVmbGV4c3VwZXJzZXQ9ODgzOTtlLnJlZ2lzdGVyZWQ9MTc0O2UucmVnaXN0ZXJzYW5zPTYzNzIwO2UucmVnaXN0ZXJzZXJpZj02MzE5NDtlLnJlaGFyYWJpYz0xNTg1O2UucmVoYXJtZW5pYW49MTQwODtlLnJlaGZpbmFsYXJhYmljPTY1MTk4O2UucmVoaXJhZ2FuYT0xMjQyODtlLnJla2F0YWthbmE9MTI1MjQ7ZS5yZWthdGFrYW5haGFsZndpZHRoPTY1NDM0O2UucmVzaD0xNTEyO2UucmVzaGRhZ2VzaGhlYnJldz02NDMyODtlLnJlc2hoZWJyZXc9MTUxMjtlLnJldmVyc2VkdGlsZGU9ODc2NTtlLnJldmlhaGVicmV3PTE0MzE7ZS5yZXZpYW11Z3Jhc2hoZWJyZXc9MTQzMTtlLnJldmxvZ2ljYWxub3Q9ODk3NjtlLnJmaXNoaG9vaz02Mzg7ZS5yZmlzaGhvb2tyZXZlcnNlZD02Mzk7ZS5yaGFiZW5nYWxpPTI1MjU7ZS5yaGFkZXZhPTIzOTc7ZS5yaG89OTYxO2Uucmhvb2s9NjM3O2Uucmhvb2t0dXJuZWQ9NjM1O2Uucmhvb2t0dXJuZWRzdXBlcmlvcj02OTM7ZS5yaG9zeW1ib2xncmVlaz0xMDA5O2UucmhvdGljaG9va21vZD03MzQ7ZS5yaWV1bGFjaXJjbGVrb3JlYW49MTI5MTM7ZS5yaWV1bGFwYXJlbmtvcmVhbj0xMjgxNztlLnJpZXVsY2lyY2xla29yZWFuPTEyODk5O2UucmlldWxoaWV1aGtvcmVhbj0xMjYwODtlLnJpZXVsa2l5ZW9ra29yZWFuPTEyNjAyO2UucmlldWxraXllb2tzaW9za29yZWFuPTEyNjQ5O2UucmlldWxrb3JlYW49MTI2MDE7ZS5yaWV1bG1pZXVta29yZWFuPTEyNjAzO2UucmlldWxwYW5zaW9za29yZWFuPTEyNjUyO2UucmlldWxwYXJlbmtvcmVhbj0xMjgwMztlLnJpZXVscGhpZXVwaGtvcmVhbj0xMjYwNztlLnJpZXVscGlldXBrb3JlYW49MTI2MDQ7ZS5yaWV1bHBpZXVwc2lvc2tvcmVhbj0xMjY1MTtlLnJpZXVsc2lvc2tvcmVhbj0xMjYwNTtlLnJpZXVsdGhpZXV0aGtvcmVhbj0xMjYwNjtlLnJpZXVsdGlrZXV0a29yZWFuPTEyNjUwO2UucmlldWx5ZW9yaW5oaWV1aGtvcmVhbj0xMjY1MztlLnJpZ2h0YW5nbGU9ODczNTtlLnJpZ2h0dGFja2JlbG93Y21iPTc5MztlLnJpZ2h0dHJpYW5nbGU9ODg5NTtlLnJpaGlyYWdhbmE9MTI0MjY7ZS5yaWthdGFrYW5hPTEyNTIyO2UucmlrYXRha2FuYWhhbGZ3aWR0aD02NTQzMjtlLnJpbmc9NzMwO2UucmluZ2JlbG93Y21iPTgwNTtlLnJpbmdjbWI9Nzc4O2UucmluZ2hhbGZsZWZ0PTcwMztlLnJpbmdoYWxmbGVmdGFybWVuaWFuPTEzNjk7ZS5yaW5naGFsZmxlZnRiZWxvd2NtYj03OTY7ZS5yaW5naGFsZmxlZnRjZW50ZXJlZD03MjM7ZS5yaW5naGFsZnJpZ2h0PTcwMjtlLnJpbmdoYWxmcmlnaHRiZWxvd2NtYj04MjU7ZS5yaW5naGFsZnJpZ2h0Y2VudGVyZWQ9NzIyO2UucmludmVydGVkYnJldmU9NTMxO2Uucml0dG9ydXNxdWFyZT0xMzEzNztlLnJsaW5lYmVsb3c9Nzc3NTtlLnJsb25nbGVnPTYzNjtlLnJsb25nbGVndHVybmVkPTYzNDtlLnJtb25vc3BhY2U9NjUzNjI7ZS5yb2hpcmFnYW5hPTEyNDI5O2Uucm9rYXRha2FuYT0xMjUyNTtlLnJva2F0YWthbmFoYWxmd2lkdGg9NjU0MzU7ZS5yb3J1YXRoYWk9MzYxOTtlLnJwYXJlbj05Mzg5O2UucnJhYmVuZ2FsaT0yNTI0O2UucnJhZGV2YT0yMzUzO2UucnJhZ3VybXVraGk9MjY1MjtlLnJyZWhhcmFiaWM9MTY4MTtlLnJyZWhmaW5hbGFyYWJpYz02NDM5NztlLnJydm9jYWxpY2JlbmdhbGk9MjUyODtlLnJydm9jYWxpY2RldmE9MjQwMDtlLnJydm9jYWxpY2d1amFyYXRpPTI3ODQ7ZS5ycnZvY2FsaWN2b3dlbHNpZ25iZW5nYWxpPTI1MDA7ZS5ycnZvY2FsaWN2b3dlbHNpZ25kZXZhPTIzNzI7ZS5ycnZvY2FsaWN2b3dlbHNpZ25ndWphcmF0aT0yNzU2O2UucnN1cGVyaW9yPTYzMjE3O2UucnRibG9jaz05NjE2O2UucnR1cm5lZD02MzM7ZS5ydHVybmVkc3VwZXJpb3I9NjkyO2UucnVoaXJhZ2FuYT0xMjQyNztlLnJ1a2F0YWthbmE9MTI1MjM7ZS5ydWthdGFrYW5haGFsZndpZHRoPTY1NDMzO2UucnVwZWVtYXJrYmVuZ2FsaT0yNTQ2O2UucnVwZWVzaWduYmVuZ2FsaT0yNTQ3O2UucnVwaWFoPTYzMTk3O2UucnV0aGFpPTM2MjA7ZS5ydm9jYWxpY2JlbmdhbGk9MjQ0MztlLnJ2b2NhbGljZGV2YT0yMzE1O2UucnZvY2FsaWNndWphcmF0aT0yNjk5O2UucnZvY2FsaWN2b3dlbHNpZ25iZW5nYWxpPTI0OTk7ZS5ydm9jYWxpY3Zvd2Vsc2lnbmRldmE9MjM3MTtlLnJ2b2NhbGljdm93ZWxzaWduZ3VqYXJhdGk9Mjc1NTtlLnM9MTE1O2Uuc2FiZW5nYWxpPTI0ODg7ZS5zYWN1dGU9MzQ3O2Uuc2FjdXRlZG90YWNjZW50PTc3ODE7ZS5zYWRhcmFiaWM9MTU4OTtlLnNhZGV2YT0yMzYwO2Uuc2FkZmluYWxhcmFiaWM9NjUyMTA7ZS5zYWRpbml0aWFsYXJhYmljPTY1MjExO2Uuc2FkbWVkaWFsYXJhYmljPTY1MjEyO2Uuc2FndWphcmF0aT0yNzQ0O2Uuc2FndXJtdWtoaT0yNjE2O2Uuc2FoaXJhZ2FuYT0xMjM3MztlLnNha2F0YWthbmE9MTI0Njk7ZS5zYWthdGFrYW5haGFsZndpZHRoPTY1NDAzO2Uuc2FsbGFsbGFob3VhbGF5aGV3YXNhbGxhbWFyYWJpYz02NTAxODtlLnNhbWVraD0xNTA1O2Uuc2FtZWtoZGFnZXNoPTY0MzIxO2Uuc2FtZWtoZGFnZXNoaGVicmV3PTY0MzIxO2Uuc2FtZWtoaGVicmV3PTE1MDU7ZS5zYXJhYWF0aGFpPTM2MzQ7ZS5zYXJhYWV0aGFpPTM2NDk7ZS5zYXJhYWltYWltYWxhaXRoYWk9MzY1MjtlLnNhcmFhaW1haW11YW50aGFpPTM2NTE7ZS5zYXJhYW10aGFpPTM2MzU7ZS5zYXJhYXRoYWk9MzYzMjtlLnNhcmFldGhhaT0zNjQ4O2Uuc2FyYWlpbGVmdHRoYWk9NjM2MjI7ZS5zYXJhaWl0aGFpPTM2Mzc7ZS5zYXJhaWxlZnR0aGFpPTYzNjIxO2Uuc2FyYWl0aGFpPTM2MzY7ZS5zYXJhb3RoYWk9MzY1MDtlLnNhcmF1ZWVsZWZ0dGhhaT02MzYyNDtlLnNhcmF1ZWV0aGFpPTM2Mzk7ZS5zYXJhdWVsZWZ0dGhhaT02MzYyMztlLnNhcmF1ZXRoYWk9MzYzODtlLnNhcmF1dGhhaT0zNjQwO2Uuc2FyYXV1dGhhaT0zNjQxO2Uuc2JvcG9tb2ZvPTEyNTY5O2Uuc2Nhcm9uPTM1MztlLnNjYXJvbmRvdGFjY2VudD03NzgzO2Uuc2NlZGlsbGE9MzUxO2Uuc2Nod2E9NjAxO2Uuc2Nod2FjeXJpbGxpYz0xMjQxO2Uuc2Nod2FkaWVyZXNpc2N5cmlsbGljPTEyNDM7ZS5zY2h3YWhvb2s9NjAyO2Uuc2NpcmNsZT05NDQyO2Uuc2NpcmN1bWZsZXg9MzQ5O2Uuc2NvbW1hYWNjZW50PTUzNztlLnNkb3RhY2NlbnQ9Nzc3NztlLnNkb3RiZWxvdz03Nzc5O2Uuc2RvdGJlbG93ZG90YWNjZW50PTc3ODU7ZS5zZWFndWxsYmVsb3djbWI9ODI4O2Uuc2Vjb25kPTgyNDM7ZS5zZWNvbmR0b25lY2hpbmVzZT03MTQ7ZS5zZWN0aW9uPTE2NztlLnNlZW5hcmFiaWM9MTU4NztlLnNlZW5maW5hbGFyYWJpYz02NTIwMjtlLnNlZW5pbml0aWFsYXJhYmljPTY1MjAzO2Uuc2Vlbm1lZGlhbGFyYWJpYz02NTIwNDtlLnNlZ29sPTE0NjI7ZS5zZWdvbDEzPTE0NjI7ZS5zZWdvbDFmPTE0NjI7ZS5zZWdvbDJjPTE0NjI7ZS5zZWdvbGhlYnJldz0xNDYyO2Uuc2Vnb2xuYXJyb3doZWJyZXc9MTQ2MjtlLnNlZ29scXVhcnRlcmhlYnJldz0xNDYyO2Uuc2Vnb2x0YWhlYnJldz0xNDI2O2Uuc2Vnb2x3aWRlaGVicmV3PTE0NjI7ZS5zZWhhcm1lbmlhbj0xNDA1O2Uuc2VoaXJhZ2FuYT0xMjM3OTtlLnNla2F0YWthbmE9MTI0NzU7ZS5zZWthdGFrYW5haGFsZndpZHRoPTY1NDA2O2Uuc2VtaWNvbG9uPTU5O2Uuc2VtaWNvbG9uYXJhYmljPTE1NjM7ZS5zZW1pY29sb25tb25vc3BhY2U9NjUzMDc7ZS5zZW1pY29sb25zbWFsbD02NTEwODtlLnNlbWl2b2ljZWRtYXJra2FuYT0xMjQ0NDtlLnNlbWl2b2ljZWRtYXJra2FuYWhhbGZ3aWR0aD02NTQzOTtlLnNlbnRpc3F1YXJlPTEzMDkwO2Uuc2VudG9zcXVhcmU9MTMwOTE7ZS5zZXZlbj01NTtlLnNldmVuYXJhYmljPTE2Mzk7ZS5zZXZlbmJlbmdhbGk9MjU0MTtlLnNldmVuY2lyY2xlPTkzMTg7ZS5zZXZlbmNpcmNsZWludmVyc2VzYW5zc2VyaWY9MTAxMjg7ZS5zZXZlbmRldmE9MjQxMztlLnNldmVuZWlnaHRocz04NTQyO2Uuc2V2ZW5ndWphcmF0aT0yNzk3O2Uuc2V2ZW5ndXJtdWtoaT0yNjY5O2Uuc2V2ZW5oYWNrYXJhYmljPTE2Mzk7ZS5zZXZlbmhhbmd6aG91PTEyMzI3O2Uuc2V2ZW5pZGVvZ3JhcGhpY3BhcmVuPTEyODM4O2Uuc2V2ZW5pbmZlcmlvcj04MzI3O2Uuc2V2ZW5tb25vc3BhY2U9NjUzMDM7ZS5zZXZlbm9sZHN0eWxlPTYzMjg3O2Uuc2V2ZW5wYXJlbj05MzM4O2Uuc2V2ZW5wZXJpb2Q9OTM1ODtlLnNldmVucGVyc2lhbj0xNzgzO2Uuc2V2ZW5yb21hbj04NTY2O2Uuc2V2ZW5zdXBlcmlvcj04MzExO2Uuc2V2ZW50ZWVuY2lyY2xlPTkzMjg7ZS5zZXZlbnRlZW5wYXJlbj05MzQ4O2Uuc2V2ZW50ZWVucGVyaW9kPTkzNjg7ZS5zZXZlbnRoYWk9MzY3MTtlLnNmdGh5cGhlbj0xNzM7ZS5zaGFhcm1lbmlhbj0xMzk5O2Uuc2hhYmVuZ2FsaT0yNDg2O2Uuc2hhY3lyaWxsaWM9MTA5NjtlLnNoYWRkYWFyYWJpYz0xNjE3O2Uuc2hhZGRhZGFtbWFhcmFiaWM9NjQ2MDk7ZS5zaGFkZGFkYW1tYXRhbmFyYWJpYz02NDYwNjtlLnNoYWRkYWZhdGhhYXJhYmljPTY0NjA4O2Uuc2hhZGRha2FzcmFhcmFiaWM9NjQ2MTA7ZS5zaGFkZGFrYXNyYXRhbmFyYWJpYz02NDYwNztlLnNoYWRlPTk2MTg7ZS5zaGFkZWRhcms9OTYxOTtlLnNoYWRlbGlnaHQ9OTYxNztlLnNoYWRlbWVkaXVtPTk2MTg7ZS5zaGFkZXZhPTIzNTg7ZS5zaGFndWphcmF0aT0yNzQyO2Uuc2hhZ3VybXVraGk9MjYxNDtlLnNoYWxzaGVsZXRoZWJyZXc9MTQyNztlLnNoYm9wb21vZm89MTI1NjU7ZS5zaGNoYWN5cmlsbGljPTEwOTc7ZS5zaGVlbmFyYWJpYz0xNTg4O2Uuc2hlZW5maW5hbGFyYWJpYz02NTIwNjtlLnNoZWVuaW5pdGlhbGFyYWJpYz02NTIwNztlLnNoZWVubWVkaWFsYXJhYmljPTY1MjA4O2Uuc2hlaWNvcHRpYz05OTU7ZS5zaGVxZWw9ODM2MjtlLnNoZXFlbGhlYnJldz04MzYyO2Uuc2hldmE9MTQ1NjtlLnNoZXZhMTE1PTE0NTY7ZS5zaGV2YTE1PTE0NTY7ZS5zaGV2YTIyPTE0NTY7ZS5zaGV2YTJlPTE0NTY7ZS5zaGV2YWhlYnJldz0xNDU2O2Uuc2hldmFuYXJyb3doZWJyZXc9MTQ1NjtlLnNoZXZhcXVhcnRlcmhlYnJldz0xNDU2O2Uuc2hldmF3aWRlaGVicmV3PTE0NTY7ZS5zaGhhY3lyaWxsaWM9MTIxMTtlLnNoaW1hY29wdGljPTEwMDU7ZS5zaGluPTE1MTM7ZS5zaGluZGFnZXNoPTY0MzI5O2Uuc2hpbmRhZ2VzaGhlYnJldz02NDMyOTtlLnNoaW5kYWdlc2hzaGluZG90PTY0MzAwO2Uuc2hpbmRhZ2VzaHNoaW5kb3RoZWJyZXc9NjQzMDA7ZS5zaGluZGFnZXNoc2luZG90PTY0MzAxO2Uuc2hpbmRhZ2VzaHNpbmRvdGhlYnJldz02NDMwMTtlLnNoaW5kb3RoZWJyZXc9MTQ3MztlLnNoaW5oZWJyZXc9MTUxMztlLnNoaW5zaGluZG90PTY0Mjk4O2Uuc2hpbnNoaW5kb3RoZWJyZXc9NjQyOTg7ZS5zaGluc2luZG90PTY0Mjk5O2Uuc2hpbnNpbmRvdGhlYnJldz02NDI5OTtlLnNob29rPTY0MjtlLnNpZ21hPTk2MztlLnNpZ21hMT05NjI7ZS5zaWdtYWZpbmFsPTk2MjtlLnNpZ21hbHVuYXRlc3ltYm9sZ3JlZWs9MTAxMDtlLnNpaGlyYWdhbmE9MTIzNzU7ZS5zaWthdGFrYW5hPTEyNDcxO2Uuc2lrYXRha2FuYWhhbGZ3aWR0aD02NTQwNDtlLnNpbHVxaGVicmV3PTE0Njk7ZS5zaWx1cWxlZnRoZWJyZXc9MTQ2OTtlLnNpbWlsYXI9ODc2NDtlLnNpbmRvdGhlYnJldz0xNDc0O2Uuc2lvc2FjaXJjbGVrb3JlYW49MTI5MTY7ZS5zaW9zYXBhcmVua29yZWFuPTEyODIwO2Uuc2lvc2NpZXVja29yZWFuPTEyNjcwO2Uuc2lvc2NpcmNsZWtvcmVhbj0xMjkwMjtlLnNpb3NraXllb2trb3JlYW49MTI2NjY7ZS5zaW9za29yZWFuPTEyNjEzO2Uuc2lvc25pZXVua29yZWFuPTEyNjY3O2Uuc2lvc3BhcmVua29yZWFuPTEyODA2O2Uuc2lvc3BpZXVwa29yZWFuPTEyNjY5O2Uuc2lvc3Rpa2V1dGtvcmVhbj0xMjY2ODtlLnNpeD01NDtlLnNpeGFyYWJpYz0xNjM4O2Uuc2l4YmVuZ2FsaT0yNTQwO2Uuc2l4Y2lyY2xlPTkzMTc7ZS5zaXhjaXJjbGVpbnZlcnNlc2Fuc3NlcmlmPTEwMTI3O2Uuc2l4ZGV2YT0yNDEyO2Uuc2l4Z3VqYXJhdGk9Mjc5NjtlLnNpeGd1cm11a2hpPTI2Njg7ZS5zaXhoYWNrYXJhYmljPTE2Mzg7ZS5zaXhoYW5nemhvdT0xMjMyNjtlLnNpeGlkZW9ncmFwaGljcGFyZW49MTI4Mzc7ZS5zaXhpbmZlcmlvcj04MzI2O2Uuc2l4bW9ub3NwYWNlPTY1MzAyO2Uuc2l4b2xkc3R5bGU9NjMyODY7ZS5zaXhwYXJlbj05MzM3O2Uuc2l4cGVyaW9kPTkzNTc7ZS5zaXhwZXJzaWFuPTE3ODI7ZS5zaXhyb21hbj04NTY1O2Uuc2l4c3VwZXJpb3I9ODMxMDtlLnNpeHRlZW5jaXJjbGU9OTMyNztlLnNpeHRlZW5jdXJyZW5jeWRlbm9taW5hdG9yYmVuZ2FsaT0yNTUzO2Uuc2l4dGVlbnBhcmVuPTkzNDc7ZS5zaXh0ZWVucGVyaW9kPTkzNjc7ZS5zaXh0aGFpPTM2NzA7ZS5zbGFzaD00NztlLnNsYXNobW9ub3NwYWNlPTY1Mjk1O2Uuc2xvbmc9MzgzO2Uuc2xvbmdkb3RhY2NlbnQ9NzgzNTtlLnNtaWxlZmFjZT05Nzg2O2Uuc21vbm9zcGFjZT02NTM2MztlLnNvZnBhc3VxaGVicmV3PTE0NzU7ZS5zb2Z0aHlwaGVuPTE3MztlLnNvZnRzaWduY3lyaWxsaWM9MTEwMDtlLnNvaGlyYWdhbmE9MTIzODE7ZS5zb2thdGFrYW5hPTEyNDc3O2Uuc29rYXRha2FuYWhhbGZ3aWR0aD02NTQwNztlLnNvbGlkdXNsb25nb3ZlcmxheWNtYj04MjQ7ZS5zb2xpZHVzc2hvcnRvdmVybGF5Y21iPTgyMztlLnNvcnVzaXRoYWk9MzYyNTtlLnNvc2FsYXRoYWk9MzYyNDtlLnNvc290aGFpPTM1OTU7ZS5zb3N1YXRoYWk9MzYyNjtlLnNwYWNlPTMyO2Uuc3BhY2VoYWNrYXJhYmljPTMyO2Uuc3BhZGU9OTgyNDtlLnNwYWRlc3VpdGJsYWNrPTk4MjQ7ZS5zcGFkZXN1aXR3aGl0ZT05ODI4O2Uuc3BhcmVuPTkzOTA7ZS5zcXVhcmViZWxvd2NtYj04Mjc7ZS5zcXVhcmVjYz0xMzI1MjtlLnNxdWFyZWNtPTEzMjEzO2Uuc3F1YXJlZGlhZ29uYWxjcm9zc2hhdGNoZmlsbD05NjQxO2Uuc3F1YXJlaG9yaXpvbnRhbGZpbGw9OTYzNjtlLnNxdWFyZWtnPTEzMTk5O2Uuc3F1YXJla209MTMyMTQ7ZS5zcXVhcmVrbWNhcGl0YWw9MTMyNjI7ZS5zcXVhcmVsbj0xMzI2NTtlLnNxdWFyZWxvZz0xMzI2NjtlLnNxdWFyZW1nPTEzMTk4O2Uuc3F1YXJlbWlsPTEzMjY5O2Uuc3F1YXJlbW09MTMyMTI7ZS5zcXVhcmVtc3F1YXJlZD0xMzIxNztlLnNxdWFyZW9ydGhvZ29uYWxjcm9zc2hhdGNoZmlsbD05NjM4O2Uuc3F1YXJldXBwZXJsZWZ0dG9sb3dlcnJpZ2h0ZmlsbD05NjM5O2Uuc3F1YXJldXBwZXJyaWdodHRvbG93ZXJsZWZ0ZmlsbD05NjQwO2Uuc3F1YXJldmVydGljYWxmaWxsPTk2Mzc7ZS5zcXVhcmV3aGl0ZXdpdGhzbWFsbGJsYWNrPTk2MzU7ZS5zcnNxdWFyZT0xMzI3NTtlLnNzYWJlbmdhbGk9MjQ4NztlLnNzYWRldmE9MjM1OTtlLnNzYWd1amFyYXRpPTI3NDM7ZS5zc2FuZ2NpZXVja29yZWFuPTEyNjE3O2Uuc3NhbmdoaWV1aGtvcmVhbj0xMjY3NztlLnNzYW5naWV1bmdrb3JlYW49MTI2NzI7ZS5zc2FuZ2tpeWVva2tvcmVhbj0xMjU5NDtlLnNzYW5nbmlldW5rb3JlYW49MTI2NDU7ZS5zc2FuZ3BpZXVwa29yZWFuPTEyNjExO2Uuc3NhbmdzaW9za29yZWFuPTEyNjE0O2Uuc3Nhbmd0aWtldXRrb3JlYW49MTI2MDA7ZS5zc3VwZXJpb3I9NjMyMTg7ZS5zdGVybGluZz0xNjM7ZS5zdGVybGluZ21vbm9zcGFjZT02NTUwNTtlLnN0cm9rZWxvbmdvdmVybGF5Y21iPTgyMjtlLnN0cm9rZXNob3J0b3ZlcmxheWNtYj04MjE7ZS5zdWJzZXQ9ODgzNDtlLnN1YnNldG5vdGVxdWFsPTg4NDI7ZS5zdWJzZXRvcmVxdWFsPTg4Mzg7ZS5zdWNjZWVkcz04ODI3O2Uuc3VjaHRoYXQ9ODcxNTtlLnN1aGlyYWdhbmE9MTIzNzc7ZS5zdWthdGFrYW5hPTEyNDczO2Uuc3VrYXRha2FuYWhhbGZ3aWR0aD02NTQwNTtlLnN1a3VuYXJhYmljPTE2MTg7ZS5zdW1tYXRpb249ODcyMTtlLnN1bj05Nzg4O2Uuc3VwZXJzZXQ9ODgzNTtlLnN1cGVyc2V0bm90ZXF1YWw9ODg0MztlLnN1cGVyc2V0b3JlcXVhbD04ODM5O2Uuc3ZzcXVhcmU9MTMyNzY7ZS5zeW91d2FlcmFzcXVhcmU9MTMxODA7ZS50PTExNjtlLnRhYmVuZ2FsaT0yNDY4O2UudGFja2Rvd249ODg2ODtlLnRhY2tsZWZ0PTg4Njc7ZS50YWRldmE9MjM0MDtlLnRhZ3VqYXJhdGk9MjcyNDtlLnRhZ3VybXVraGk9MjU5NjtlLnRhaGFyYWJpYz0xNTkxO2UudGFoZmluYWxhcmFiaWM9NjUyMTg7ZS50YWhpbml0aWFsYXJhYmljPTY1MjE5O2UudGFoaXJhZ2FuYT0xMjM4MztlLnRhaG1lZGlhbGFyYWJpYz02NTIyMDtlLnRhaXN5b3VlcmFzcXVhcmU9MTMxODE7ZS50YWthdGFrYW5hPTEyNDc5O2UudGFrYXRha2FuYWhhbGZ3aWR0aD02NTQwODtlLnRhdHdlZWxhcmFiaWM9MTYwMDtlLnRhdT05NjQ7ZS50YXY9MTUxNDtlLnRhdmRhZ2VzPTY0MzMwO2UudGF2ZGFnZXNoPTY0MzMwO2UudGF2ZGFnZXNoaGVicmV3PTY0MzMwO2UudGF2aGVicmV3PTE1MTQ7ZS50YmFyPTM1OTtlLnRib3BvbW9mbz0xMjU1NDtlLnRjYXJvbj0zNTc7ZS50Y2N1cmw9NjgwO2UudGNlZGlsbGE9MzU1O2UudGNoZWhhcmFiaWM9MTY3MDtlLnRjaGVoZmluYWxhcmFiaWM9NjQzNzk7ZS50Y2hlaGluaXRpYWxhcmFiaWM9NjQzODA7ZS50Y2hlaG1lZGlhbGFyYWJpYz02NDM4MTtlLnRjaXJjbGU9OTQ0MztlLnRjaXJjdW1mbGV4YmVsb3c9Nzc5MztlLnRjb21tYWFjY2VudD0zNTU7ZS50ZGllcmVzaXM9NzgzMTtlLnRkb3RhY2NlbnQ9Nzc4NztlLnRkb3RiZWxvdz03Nzg5O2UudGVjeXJpbGxpYz0xMDkwO2UudGVkZXNjZW5kZXJjeXJpbGxpYz0xMTk3O2UudGVoYXJhYmljPTE1Nzg7ZS50ZWhmaW5hbGFyYWJpYz02NTE3NDtlLnRlaGhhaGluaXRpYWxhcmFiaWM9NjQ2NzQ7ZS50ZWhoYWhpc29sYXRlZGFyYWJpYz02NDUyNDtlLnRlaGluaXRpYWxhcmFiaWM9NjUxNzU7ZS50ZWhpcmFnYW5hPTEyMzkwO2UudGVoamVlbWluaXRpYWxhcmFiaWM9NjQ2NzM7ZS50ZWhqZWVtaXNvbGF0ZWRhcmFiaWM9NjQ1MjM7ZS50ZWhtYXJidXRhYXJhYmljPTE1Nzc7ZS50ZWhtYXJidXRhZmluYWxhcmFiaWM9NjUxNzI7ZS50ZWhtZWRpYWxhcmFiaWM9NjUxNzY7ZS50ZWhtZWVtaW5pdGlhbGFyYWJpYz02NDY3NjtlLnRlaG1lZW1pc29sYXRlZGFyYWJpYz02NDUyNjtlLnRlaG5vb25maW5hbGFyYWJpYz02NDYyNztlLnRla2F0YWthbmE9MTI0ODY7ZS50ZWthdGFrYW5haGFsZndpZHRoPTY1NDExO2UudGVsZXBob25lPTg0ODE7ZS50ZWxlcGhvbmVibGFjaz05NzQyO2UudGVsaXNoYWdlZG9sYWhlYnJldz0xNDQwO2UudGVsaXNoYXFldGFuYWhlYnJldz0xNDQ5O2UudGVuY2lyY2xlPTkzMjE7ZS50ZW5pZGVvZ3JhcGhpY3BhcmVuPTEyODQxO2UudGVucGFyZW49OTM0MTtlLnRlbnBlcmlvZD05MzYxO2UudGVucm9tYW49ODU2OTtlLnRlc2g9Njc5O2UudGV0PTE0OTY7ZS50ZXRkYWdlc2g9NjQzMTI7ZS50ZXRkYWdlc2hoZWJyZXc9NjQzMTI7ZS50ZXRoZWJyZXc9MTQ5NjtlLnRldHNlY3lyaWxsaWM9MTIwNTtlLnRldmlyaGVicmV3PTE0MzU7ZS50ZXZpcmxlZnRoZWJyZXc9MTQzNTtlLnRoYWJlbmdhbGk9MjQ2OTtlLnRoYWRldmE9MjM0MTtlLnRoYWd1amFyYXRpPTI3MjU7ZS50aGFndXJtdWtoaT0yNTk3O2UudGhhbGFyYWJpYz0xNTg0O2UudGhhbGZpbmFsYXJhYmljPTY1MTk2O2UudGhhbnRoYWtoYXRsb3dsZWZ0dGhhaT02MzY0MDtlLnRoYW50aGFraGF0bG93cmlnaHR0aGFpPTYzNjM5O2UudGhhbnRoYWtoYXR0aGFpPTM2NjA7ZS50aGFudGhha2hhdHVwcGVybGVmdHRoYWk9NjM2Mzg7ZS50aGVoYXJhYmljPTE1Nzk7ZS50aGVoZmluYWxhcmFiaWM9NjUxNzg7ZS50aGVoaW5pdGlhbGFyYWJpYz02NTE3OTtlLnRoZWhtZWRpYWxhcmFiaWM9NjUxODA7ZS50aGVyZWV4aXN0cz04NzA3O2UudGhlcmVmb3JlPTg3NTY7ZS50aGV0YT05NTI7ZS50aGV0YTE9OTc3O2UudGhldGFzeW1ib2xncmVlaz05Nzc7ZS50aGlldXRoYWNpcmNsZWtvcmVhbj0xMjkyMTtlLnRoaWV1dGhhcGFyZW5rb3JlYW49MTI4MjU7ZS50aGlldXRoY2lyY2xla29yZWFuPTEyOTA3O2UudGhpZXV0aGtvcmVhbj0xMjYyMDtlLnRoaWV1dGhwYXJlbmtvcmVhbj0xMjgxMTtlLnRoaXJ0ZWVuY2lyY2xlPTkzMjQ7ZS50aGlydGVlbnBhcmVuPTkzNDQ7ZS50aGlydGVlbnBlcmlvZD05MzY0O2UudGhvbmFuZ21vbnRob3RoYWk9MzYwMTtlLnRob29rPTQyOTtlLnRob3BodXRoYW90aGFpPTM2MDI7ZS50aG9ybj0yNTQ7ZS50aG90aGFoYW50aGFpPTM2MDc7ZS50aG90aGFudGhhaT0zNjAwO2UudGhvdGhvbmd0aGFpPTM2MDg7ZS50aG90aHVuZ3RoYWk9MzYwNjtlLnRob3VzYW5kY3lyaWxsaWM9MTE1NDtlLnRob3VzYW5kc3NlcGFyYXRvcmFyYWJpYz0xNjQ0O2UudGhvdXNhbmRzc2VwYXJhdG9ycGVyc2lhbj0xNjQ0O2UudGhyZWU9NTE7ZS50aHJlZWFyYWJpYz0xNjM1O2UudGhyZWViZW5nYWxpPTI1Mzc7ZS50aHJlZWNpcmNsZT05MzE0O2UudGhyZWVjaXJjbGVpbnZlcnNlc2Fuc3NlcmlmPTEwMTI0O2UudGhyZWVkZXZhPTI0MDk7ZS50aHJlZWVpZ2h0aHM9ODU0MDtlLnRocmVlZ3VqYXJhdGk9Mjc5MztlLnRocmVlZ3VybXVraGk9MjY2NTtlLnRocmVlaGFja2FyYWJpYz0xNjM1O2UudGhyZWVoYW5nemhvdT0xMjMyMztlLnRocmVlaWRlb2dyYXBoaWNwYXJlbj0xMjgzNDtlLnRocmVlaW5mZXJpb3I9ODMyMztlLnRocmVlbW9ub3NwYWNlPTY1Mjk5O2UudGhyZWVudW1lcmF0b3JiZW5nYWxpPTI1NTA7ZS50aHJlZW9sZHN0eWxlPTYzMjgzO2UudGhyZWVwYXJlbj05MzM0O2UudGhyZWVwZXJpb2Q9OTM1NDtlLnRocmVlcGVyc2lhbj0xNzc5O2UudGhyZWVxdWFydGVycz0xOTA7ZS50aHJlZXF1YXJ0ZXJzZW1kYXNoPTYzMTk4O2UudGhyZWVyb21hbj04NTYyO2UudGhyZWVzdXBlcmlvcj0xNzk7ZS50aHJlZXRoYWk9MzY2NztlLnRoenNxdWFyZT0xMzIwNDtlLnRpaGlyYWdhbmE9MTIzODU7ZS50aWthdGFrYW5hPTEyNDgxO2UudGlrYXRha2FuYWhhbGZ3aWR0aD02NTQwOTtlLnRpa2V1dGFjaXJjbGVrb3JlYW49MTI5MTI7ZS50aWtldXRhcGFyZW5rb3JlYW49MTI4MTY7ZS50aWtldXRjaXJjbGVrb3JlYW49MTI4OTg7ZS50aWtldXRrb3JlYW49MTI1OTk7ZS50aWtldXRwYXJlbmtvcmVhbj0xMjgwMjtlLnRpbGRlPTczMjtlLnRpbGRlYmVsb3djbWI9ODE2O2UudGlsZGVjbWI9NzcxO2UudGlsZGVjb21iPTc3MTtlLnRpbGRlZG91YmxlY21iPTg2NDtlLnRpbGRlb3BlcmF0b3I9ODc2NDtlLnRpbGRlb3ZlcmxheWNtYj04MjA7ZS50aWxkZXZlcnRpY2FsY21iPTgzMDtlLnRpbWVzY2lyY2xlPTg4NTU7ZS50aXBlaGFoZWJyZXc9MTQzMDtlLnRpcGVoYWxlZnRoZWJyZXc9MTQzMDtlLnRpcHBpZ3VybXVraGk9MjY3MjtlLnRpdGxvY3lyaWxsaWNjbWI9MTE1NTtlLnRpd25hcm1lbmlhbj0xNDA3O2UudGxpbmViZWxvdz03NzkxO2UudG1vbm9zcGFjZT02NTM2NDtlLnRvYXJtZW5pYW49MTM4NTtlLnRvaGlyYWdhbmE9MTIzOTI7ZS50b2thdGFrYW5hPTEyNDg4O2UudG9rYXRha2FuYWhhbGZ3aWR0aD02NTQxMjtlLnRvbmViYXJleHRyYWhpZ2htb2Q9NzQxO2UudG9uZWJhcmV4dHJhbG93bW9kPTc0NTtlLnRvbmViYXJoaWdobW9kPTc0MjtlLnRvbmViYXJsb3dtb2Q9NzQ0O2UudG9uZWJhcm1pZG1vZD03NDM7ZS50b25lZml2ZT00NDU7ZS50b25lc2l4PTM4OTtlLnRvbmV0d289NDI0O2UudG9ub3M9OTAwO2UudG9uc3F1YXJlPTEzMDk1O2UudG9wYXRha3RoYWk9MzU5OTtlLnRvcnRvaXNlc2hlbGxicmFja2V0bGVmdD0xMjMwODtlLnRvcnRvaXNlc2hlbGxicmFja2V0bGVmdHNtYWxsPTY1MTE3O2UudG9ydG9pc2VzaGVsbGJyYWNrZXRsZWZ0dmVydGljYWw9NjUwODE7ZS50b3J0b2lzZXNoZWxsYnJhY2tldHJpZ2h0PTEyMzA5O2UudG9ydG9pc2VzaGVsbGJyYWNrZXRyaWdodHNtYWxsPTY1MTE4O2UudG9ydG9pc2VzaGVsbGJyYWNrZXRyaWdodHZlcnRpY2FsPTY1MDgyO2UudG90YW90aGFpPTM2MDU7ZS50cGFsYXRhbGhvb2s9NDI3O2UudHBhcmVuPTkzOTE7ZS50cmFkZW1hcms9ODQ4MjtlLnRyYWRlbWFya3NhbnM9NjM3MjI7ZS50cmFkZW1hcmtzZXJpZj02MzE5NTtlLnRyZXRyb2ZsZXhob29rPTY0ODtlLnRyaWFnZG49OTY2MDtlLnRyaWFnbGY9OTY2ODtlLnRyaWFncnQ9OTY1ODtlLnRyaWFndXA9OTY1MDtlLnRzPTY3ODtlLnRzYWRpPTE1MTA7ZS50c2FkaWRhZ2VzaD02NDMyNjtlLnRzYWRpZGFnZXNoaGVicmV3PTY0MzI2O2UudHNhZGloZWJyZXc9MTUxMDtlLnRzZWN5cmlsbGljPTEwOTQ7ZS50c2VyZT0xNDYxO2UudHNlcmUxMj0xNDYxO2UudHNlcmUxZT0xNDYxO2UudHNlcmUyYj0xNDYxO2UudHNlcmVoZWJyZXc9MTQ2MTtlLnRzZXJlbmFycm93aGVicmV3PTE0NjE7ZS50c2VyZXF1YXJ0ZXJoZWJyZXc9MTQ2MTtlLnRzZXJld2lkZWhlYnJldz0xNDYxO2UudHNoZWN5cmlsbGljPTExMTU7ZS50c3VwZXJpb3I9NjMyMTk7ZS50dGFiZW5nYWxpPTI0NjM7ZS50dGFkZXZhPTIzMzU7ZS50dGFndWphcmF0aT0yNzE5O2UudHRhZ3VybXVraGk9MjU5MTtlLnR0ZWhhcmFiaWM9MTY1NztlLnR0ZWhmaW5hbGFyYWJpYz02NDM1OTtlLnR0ZWhpbml0aWFsYXJhYmljPTY0MzYwO2UudHRlaG1lZGlhbGFyYWJpYz02NDM2MTtlLnR0aGFiZW5nYWxpPTI0NjQ7ZS50dGhhZGV2YT0yMzM2O2UudHRoYWd1amFyYXRpPTI3MjA7ZS50dGhhZ3VybXVraGk9MjU5MjtlLnR0dXJuZWQ9NjQ3O2UudHVoaXJhZ2FuYT0xMjM4ODtlLnR1a2F0YWthbmE9MTI0ODQ7ZS50dWthdGFrYW5haGFsZndpZHRoPTY1NDEwO2UudHVzbWFsbGhpcmFnYW5hPTEyMzg3O2UudHVzbWFsbGthdGFrYW5hPTEyNDgzO2UudHVzbWFsbGthdGFrYW5haGFsZndpZHRoPTY1MzkxO2UudHdlbHZlY2lyY2xlPTkzMjM7ZS50d2VsdmVwYXJlbj05MzQzO2UudHdlbHZlcGVyaW9kPTkzNjM7ZS50d2VsdmVyb21hbj04NTcxO2UudHdlbnR5Y2lyY2xlPTkzMzE7ZS50d2VudHloYW5nemhvdT0yMTMxNjtlLnR3ZW50eXBhcmVuPTkzNTE7ZS50d2VudHlwZXJpb2Q9OTM3MTtlLnR3bz01MDtlLnR3b2FyYWJpYz0xNjM0O2UudHdvYmVuZ2FsaT0yNTM2O2UudHdvY2lyY2xlPTkzMTM7ZS50d29jaXJjbGVpbnZlcnNlc2Fuc3NlcmlmPTEwMTIzO2UudHdvZGV2YT0yNDA4O2UudHdvZG90ZW5sZWFkZXI9ODIyOTtlLnR3b2RvdGxlYWRlcj04MjI5O2UudHdvZG90bGVhZGVydmVydGljYWw9NjUwNzI7ZS50d29ndWphcmF0aT0yNzkyO2UudHdvZ3VybXVraGk9MjY2NDtlLnR3b2hhY2thcmFiaWM9MTYzNDtlLnR3b2hhbmd6aG91PTEyMzIyO2UudHdvaWRlb2dyYXBoaWNwYXJlbj0xMjgzMztlLnR3b2luZmVyaW9yPTgzMjI7ZS50d29tb25vc3BhY2U9NjUyOTg7ZS50d29udW1lcmF0b3JiZW5nYWxpPTI1NDk7ZS50d29vbGRzdHlsZT02MzI4MjtlLnR3b3BhcmVuPTkzMzM7ZS50d29wZXJpb2Q9OTM1MztlLnR3b3BlcnNpYW49MTc3ODtlLnR3b3JvbWFuPTg1NjE7ZS50d29zdHJva2U9NDQzO2UudHdvc3VwZXJpb3I9MTc4O2UudHdvdGhhaT0zNjY2O2UudHdvdGhpcmRzPTg1MzI7ZS51PTExNztlLnVhY3V0ZT0yNTA7ZS51YmFyPTY0OTtlLnViZW5nYWxpPTI0NDE7ZS51Ym9wb21vZm89MTI1ODQ7ZS51YnJldmU9MzY1O2UudWNhcm9uPTQ2ODtlLnVjaXJjbGU9OTQ0NDtlLnVjaXJjdW1mbGV4PTI1MTtlLnVjaXJjdW1mbGV4YmVsb3c9Nzc5OTtlLnVjeXJpbGxpYz0xMDkxO2UudWRhdHRhZGV2YT0yMzg1O2UudWRibGFjdXRlPTM2OTtlLnVkYmxncmF2ZT01MzM7ZS51ZGV2YT0yMzEzO2UudWRpZXJlc2lzPTI1MjtlLnVkaWVyZXNpc2FjdXRlPTQ3MjtlLnVkaWVyZXNpc2JlbG93PTc3OTU7ZS51ZGllcmVzaXNjYXJvbj00NzQ7ZS51ZGllcmVzaXNjeXJpbGxpYz0xMjY1O2UudWRpZXJlc2lzZ3JhdmU9NDc2O2UudWRpZXJlc2lzbWFjcm9uPTQ3MDtlLnVkb3RiZWxvdz03OTA5O2UudWdyYXZlPTI0OTtlLnVndWphcmF0aT0yNjk3O2UudWd1cm11a2hpPTI1Njk7ZS51aGlyYWdhbmE9MTIzNTg7ZS51aG9va2Fib3ZlPTc5MTE7ZS51aG9ybj00MzI7ZS51aG9ybmFjdXRlPTc5MTM7ZS51aG9ybmRvdGJlbG93PTc5MjE7ZS51aG9ybmdyYXZlPTc5MTU7ZS51aG9ybmhvb2thYm92ZT03OTE3O2UudWhvcm50aWxkZT03OTE5O2UudWh1bmdhcnVtbGF1dD0zNjk7ZS51aHVuZ2FydW1sYXV0Y3lyaWxsaWM9MTI2NztlLnVpbnZlcnRlZGJyZXZlPTUzNTtlLnVrYXRha2FuYT0xMjQ1NDtlLnVrYXRha2FuYWhhbGZ3aWR0aD02NTM5NTtlLnVrY3lyaWxsaWM9MTE0NTtlLnVrb3JlYW49MTI2MzY7ZS51bWFjcm9uPTM2MztlLnVtYWNyb25jeXJpbGxpYz0xMjYzO2UudW1hY3JvbmRpZXJlc2lzPTc4MDM7ZS51bWF0cmFndXJtdWtoaT0yNjI1O2UudW1vbm9zcGFjZT02NTM2NTtlLnVuZGVyc2NvcmU9OTU7ZS51bmRlcnNjb3JlZGJsPTgyMTU7ZS51bmRlcnNjb3JlbW9ub3NwYWNlPTY1MzQzO2UudW5kZXJzY29yZXZlcnRpY2FsPTY1MDc1O2UudW5kZXJzY29yZXdhdnk9NjUxMDM7ZS51bmlvbj04NzQ2O2UudW5pdmVyc2FsPTg3MDQ7ZS51b2dvbmVrPTM3MTtlLnVwYXJlbj05MzkyO2UudXBibG9jaz05NjAwO2UudXBwZXJkb3RoZWJyZXc9MTQ3NjtlLnVwc2lsb249OTY1O2UudXBzaWxvbmRpZXJlc2lzPTk3MTtlLnVwc2lsb25kaWVyZXNpc3Rvbm9zPTk0NDtlLnVwc2lsb25sYXRpbj02NTA7ZS51cHNpbG9udG9ub3M9OTczO2UudXB0YWNrYmVsb3djbWI9Nzk3O2UudXB0YWNrbW9kPTcyNDtlLnVyYWd1cm11a2hpPTI2NzU7ZS51cmluZz0zNjc7ZS51c2hvcnRjeXJpbGxpYz0xMTE4O2UudXNtYWxsaGlyYWdhbmE9MTIzNTc7ZS51c21hbGxrYXRha2FuYT0xMjQ1MztlLnVzbWFsbGthdGFrYW5haGFsZndpZHRoPTY1Mzg1O2UudXN0cmFpZ2h0Y3lyaWxsaWM9MTE5OTtlLnVzdHJhaWdodHN0cm9rZWN5cmlsbGljPTEyMDE7ZS51dGlsZGU9MzYxO2UudXRpbGRlYWN1dGU9NzgwMTtlLnV0aWxkZWJlbG93PTc3OTc7ZS51dWJlbmdhbGk9MjQ0MjtlLnV1ZGV2YT0yMzE0O2UudXVndWphcmF0aT0yNjk4O2UudXVndXJtdWtoaT0yNTcwO2UudXVtYXRyYWd1cm11a2hpPTI2MjY7ZS51dXZvd2Vsc2lnbmJlbmdhbGk9MjQ5ODtlLnV1dm93ZWxzaWduZGV2YT0yMzcwO2UudXV2b3dlbHNpZ25ndWphcmF0aT0yNzU0O2UudXZvd2Vsc2lnbmJlbmdhbGk9MjQ5NztlLnV2b3dlbHNpZ25kZXZhPTIzNjk7ZS51dm93ZWxzaWduZ3VqYXJhdGk9Mjc1MztlLnY9MTE4O2UudmFkZXZhPTIzNTc7ZS52YWd1amFyYXRpPTI3NDE7ZS52YWd1cm11a2hpPTI2MTM7ZS52YWthdGFrYW5hPTEyNTM1O2UudmF2PTE0OTM7ZS52YXZkYWdlc2g9NjQzMDk7ZS52YXZkYWdlc2g2NT02NDMwOTtlLnZhdmRhZ2VzaGhlYnJldz02NDMwOTtlLnZhdmhlYnJldz0xNDkzO2UudmF2aG9sYW09NjQzMzE7ZS52YXZob2xhbWhlYnJldz02NDMzMTtlLnZhdnZhdmhlYnJldz0xNTIwO2UudmF2eW9kaGVicmV3PTE1MjE7ZS52Y2lyY2xlPTk0NDU7ZS52ZG90YmVsb3c9NzgwNztlLnZlY3lyaWxsaWM9MTA3NDtlLnZlaGFyYWJpYz0xNzAwO2UudmVoZmluYWxhcmFiaWM9NjQzNjM7ZS52ZWhpbml0aWFsYXJhYmljPTY0MzY0O2UudmVobWVkaWFsYXJhYmljPTY0MzY1O2UudmVrYXRha2FuYT0xMjUzNztlLnZlbnVzPTk3OTI7ZS52ZXJ0aWNhbGJhcj0xMjQ7ZS52ZXJ0aWNhbGxpbmVhYm92ZWNtYj03ODE7ZS52ZXJ0aWNhbGxpbmViZWxvd2NtYj04MDk7ZS52ZXJ0aWNhbGxpbmVsb3dtb2Q9NzE2O2UudmVydGljYWxsaW5lbW9kPTcxMjtlLnZld2FybWVuaWFuPTE0MDY7ZS52aG9vaz02NTE7ZS52aWthdGFrYW5hPTEyNTM2O2UudmlyYW1hYmVuZ2FsaT0yNTA5O2UudmlyYW1hZGV2YT0yMzgxO2UudmlyYW1hZ3VqYXJhdGk9Mjc2NTtlLnZpc2FyZ2FiZW5nYWxpPTI0MzU7ZS52aXNhcmdhZGV2YT0yMzA3O2UudmlzYXJnYWd1amFyYXRpPTI2OTE7ZS52bW9ub3NwYWNlPTY1MzY2O2Uudm9hcm1lbmlhbj0xNDAwO2Uudm9pY2VkaXRlcmF0aW9uaGlyYWdhbmE9MTI0NDY7ZS52b2ljZWRpdGVyYXRpb25rYXRha2FuYT0xMjU0MjtlLnZvaWNlZG1hcmtrYW5hPTEyNDQzO2Uudm9pY2VkbWFya2thbmFoYWxmd2lkdGg9NjU0Mzg7ZS52b2thdGFrYW5hPTEyNTM4O2UudnBhcmVuPTkzOTM7ZS52dGlsZGU9NzgwNTtlLnZ0dXJuZWQ9NjUyO2UudnVoaXJhZ2FuYT0xMjQzNjtlLnZ1a2F0YWthbmE9MTI1MzI7ZS53PTExOTtlLndhY3V0ZT03ODExO2Uud2Fla29yZWFuPTEyNjMzO2Uud2FoaXJhZ2FuYT0xMjQzMTtlLndha2F0YWthbmE9MTI1Mjc7ZS53YWthdGFrYW5haGFsZndpZHRoPTY1NDM2O2Uud2Frb3JlYW49MTI2MzI7ZS53YXNtYWxsaGlyYWdhbmE9MTI0MzA7ZS53YXNtYWxsa2F0YWthbmE9MTI1MjY7ZS53YXR0b3NxdWFyZT0xMzE0MztlLndhdmVkYXNoPTEyMzE2O2Uud2F2eXVuZGVyc2NvcmV2ZXJ0aWNhbD02NTA3NjtlLndhd2FyYWJpYz0xNjA4O2Uud2F3ZmluYWxhcmFiaWM9NjUyNjI7ZS53YXdoYW16YWFib3ZlYXJhYmljPTE1NzI7ZS53YXdoYW16YWFib3ZlZmluYWxhcmFiaWM9NjUxNTg7ZS53YnNxdWFyZT0xMzI3NztlLndjaXJjbGU9OTQ0NjtlLndjaXJjdW1mbGV4PTM3MztlLndkaWVyZXNpcz03ODEzO2Uud2RvdGFjY2VudD03ODE1O2Uud2RvdGJlbG93PTc4MTc7ZS53ZWhpcmFnYW5hPTEyNDMzO2Uud2VpZXJzdHJhc3M9ODQ3MjtlLndla2F0YWthbmE9MTI1Mjk7ZS53ZWtvcmVhbj0xMjYzODtlLndlb2tvcmVhbj0xMjYzNztlLndncmF2ZT03ODA5O2Uud2hpdGVidWxsZXQ9OTcwMjtlLndoaXRlY2lyY2xlPTk2NzU7ZS53aGl0ZWNpcmNsZWludmVyc2U9OTY4OTtlLndoaXRlY29ybmVyYnJhY2tldGxlZnQ9MTIzMDI7ZS53aGl0ZWNvcm5lcmJyYWNrZXRsZWZ0dmVydGljYWw9NjUwOTE7ZS53aGl0ZWNvcm5lcmJyYWNrZXRyaWdodD0xMjMwMztlLndoaXRlY29ybmVyYnJhY2tldHJpZ2h0dmVydGljYWw9NjUwOTI7ZS53aGl0ZWRpYW1vbmQ9OTY3MTtlLndoaXRlZGlhbW9uZGNvbnRhaW5pbmdibGFja3NtYWxsZGlhbW9uZD05NjcyO2Uud2hpdGVkb3ducG9pbnRpbmdzbWFsbHRyaWFuZ2xlPTk2NjM7ZS53aGl0ZWRvd25wb2ludGluZ3RyaWFuZ2xlPTk2NjE7ZS53aGl0ZWxlZnRwb2ludGluZ3NtYWxsdHJpYW5nbGU9OTY2NztlLndoaXRlbGVmdHBvaW50aW5ndHJpYW5nbGU9OTY2NTtlLndoaXRlbGVudGljdWxhcmJyYWNrZXRsZWZ0PTEyMzEwO2Uud2hpdGVsZW50aWN1bGFyYnJhY2tldHJpZ2h0PTEyMzExO2Uud2hpdGVyaWdodHBvaW50aW5nc21hbGx0cmlhbmdsZT05NjU3O2Uud2hpdGVyaWdodHBvaW50aW5ndHJpYW5nbGU9OTY1NTtlLndoaXRlc21hbGxzcXVhcmU9OTY0MztlLndoaXRlc21pbGluZ2ZhY2U9OTc4NjtlLndoaXRlc3F1YXJlPTk2MzM7ZS53aGl0ZXN0YXI9OTczNDtlLndoaXRldGVsZXBob25lPTk3NDM7ZS53aGl0ZXRvcnRvaXNlc2hlbGxicmFja2V0bGVmdD0xMjMxMjtlLndoaXRldG9ydG9pc2VzaGVsbGJyYWNrZXRyaWdodD0xMjMxMztlLndoaXRldXBwb2ludGluZ3NtYWxsdHJpYW5nbGU9OTY1MztlLndoaXRldXBwb2ludGluZ3RyaWFuZ2xlPTk2NTE7ZS53aWhpcmFnYW5hPTEyNDMyO2Uud2lrYXRha2FuYT0xMjUyODtlLndpa29yZWFuPTEyNjM5O2Uud21vbm9zcGFjZT02NTM2NztlLndvaGlyYWdhbmE9MTI0MzQ7ZS53b2thdGFrYW5hPTEyNTMwO2Uud29rYXRha2FuYWhhbGZ3aWR0aD02NTM4MjtlLndvbj04MzYxO2Uud29ubW9ub3NwYWNlPTY1NTEwO2Uud293YWVudGhhaT0zNjIzO2Uud3BhcmVuPTkzOTQ7ZS53cmluZz03ODMyO2Uud3N1cGVyaW9yPTY5NTtlLnd0dXJuZWQ9NjUzO2Uud3lubj00NDc7ZS54PTEyMDtlLnhhYm92ZWNtYj04Mjk7ZS54Ym9wb21vZm89MTI1NjI7ZS54Y2lyY2xlPTk0NDc7ZS54ZGllcmVzaXM9NzgyMTtlLnhkb3RhY2NlbnQ9NzgxOTtlLnhlaGFybWVuaWFuPTEzODk7ZS54aT05NTg7ZS54bW9ub3NwYWNlPTY1MzY4O2UueHBhcmVuPTkzOTU7ZS54c3VwZXJpb3I9NzM5O2UueT0xMjE7ZS55YWFkb3NxdWFyZT0xMzEzNDtlLnlhYmVuZ2FsaT0yNDc5O2UueWFjdXRlPTI1MztlLnlhZGV2YT0yMzUxO2UueWFla29yZWFuPTEyNjI2O2UueWFndWphcmF0aT0yNzM1O2UueWFndXJtdWtoaT0yNjA3O2UueWFoaXJhZ2FuYT0xMjQyMDtlLnlha2F0YWthbmE9MTI1MTY7ZS55YWthdGFrYW5haGFsZndpZHRoPTY1NDI4O2UueWFrb3JlYW49MTI2MjU7ZS55YW1ha2thbnRoYWk9MzY2MjtlLnlhc21hbGxoaXJhZ2FuYT0xMjQxOTtlLnlhc21hbGxrYXRha2FuYT0xMjUxNTtlLnlhc21hbGxrYXRha2FuYWhhbGZ3aWR0aD02NTM4ODtlLnlhdGN5cmlsbGljPTExMjM7ZS55Y2lyY2xlPTk0NDg7ZS55Y2lyY3VtZmxleD0zNzU7ZS55ZGllcmVzaXM9MjU1O2UueWRvdGFjY2VudD03ODIzO2UueWRvdGJlbG93PTc5MjU7ZS55ZWhhcmFiaWM9MTYxMDtlLnllaGJhcnJlZWFyYWJpYz0xNzQ2O2UueWVoYmFycmVlZmluYWxhcmFiaWM9NjQ0MzE7ZS55ZWhmaW5hbGFyYWJpYz02NTI2NjtlLnllaGhhbXphYWJvdmVhcmFiaWM9MTU3NDtlLnllaGhhbXphYWJvdmVmaW5hbGFyYWJpYz02NTE2MjtlLnllaGhhbXphYWJvdmVpbml0aWFsYXJhYmljPTY1MTYzO2UueWVoaGFtemFhYm92ZW1lZGlhbGFyYWJpYz02NTE2NDtlLnllaGluaXRpYWxhcmFiaWM9NjUyNjc7ZS55ZWhtZWRpYWxhcmFiaWM9NjUyNjg7ZS55ZWhtZWVtaW5pdGlhbGFyYWJpYz02NDczMztlLnllaG1lZW1pc29sYXRlZGFyYWJpYz02NDYwMDtlLnllaG5vb25maW5hbGFyYWJpYz02NDY2MDtlLnllaHRocmVlZG90c2JlbG93YXJhYmljPTE3NDU7ZS55ZWtvcmVhbj0xMjYzMDtlLnllbj0xNjU7ZS55ZW5tb25vc3BhY2U9NjU1MDk7ZS55ZW9rb3JlYW49MTI2Mjk7ZS55ZW9yaW5oaWV1aGtvcmVhbj0xMjY3ODtlLnllcmFoYmVueW9tb2hlYnJldz0xNDUwO2UueWVyYWhiZW55b21vbGVmdGhlYnJldz0xNDUwO2UueWVyaWN5cmlsbGljPTEwOTk7ZS55ZXJ1ZGllcmVzaXNjeXJpbGxpYz0xMjczO2UueWVzaWV1bmdrb3JlYW49MTI2NzM7ZS55ZXNpZXVuZ3BhbnNpb3Nrb3JlYW49MTI2NzU7ZS55ZXNpZXVuZ3Npb3Nrb3JlYW49MTI2NzQ7ZS55ZXRpdmhlYnJldz0xNDM0O2UueWdyYXZlPTc5MjM7ZS55aG9vaz00MzY7ZS55aG9va2Fib3ZlPTc5Mjc7ZS55aWFybWVuaWFuPTEzOTc7ZS55aWN5cmlsbGljPTExMTE7ZS55aWtvcmVhbj0xMjY0MjtlLnlpbnlhbmc9OTc3NTtlLnlpd25hcm1lbmlhbj0xNDEwO2UueW1vbm9zcGFjZT02NTM2OTtlLnlvZD0xNDk3O2UueW9kZGFnZXNoPTY0MzEzO2UueW9kZGFnZXNoaGVicmV3PTY0MzEzO2UueW9kaGVicmV3PTE0OTc7ZS55b2R5b2RoZWJyZXc9MTUyMjtlLnlvZHlvZHBhdGFoaGVicmV3PTY0Mjg3O2UueW9oaXJhZ2FuYT0xMjQyNDtlLnlvaWtvcmVhbj0xMjY4MTtlLnlva2F0YWthbmE9MTI1MjA7ZS55b2thdGFrYW5haGFsZndpZHRoPTY1NDMwO2UueW9rb3JlYW49MTI2MzU7ZS55b3NtYWxsaGlyYWdhbmE9MTI0MjM7ZS55b3NtYWxsa2F0YWthbmE9MTI1MTk7ZS55b3NtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzOTA7ZS55b3RncmVlaz0xMDExO2UueW95YWVrb3JlYW49MTI2ODA7ZS55b3lha29yZWFuPTEyNjc5O2UueW95YWt0aGFpPTM2MTg7ZS55b3lpbmd0aGFpPTM1OTc7ZS55cGFyZW49OTM5NjtlLnlwb2dlZ3JhbW1lbmk9ODkwO2UueXBvZ2VncmFtbWVuaWdyZWVrY21iPTgzNztlLnlyPTQyMjtlLnlyaW5nPTc4MzM7ZS55c3VwZXJpb3I9Njk2O2UueXRpbGRlPTc5Mjk7ZS55dHVybmVkPTY1NDtlLnl1aGlyYWdhbmE9MTI0MjI7ZS55dWlrb3JlYW49MTI2ODQ7ZS55dWthdGFrYW5hPTEyNTE4O2UueXVrYXRha2FuYWhhbGZ3aWR0aD02NTQyOTtlLnl1a29yZWFuPTEyNjQwO2UueXVzYmlnY3lyaWxsaWM9MTEzMTtlLnl1c2JpZ2lvdGlmaWVkY3lyaWxsaWM9MTEzMztlLnl1c2xpdHRsZWN5cmlsbGljPTExMjc7ZS55dXNsaXR0bGVpb3RpZmllZGN5cmlsbGljPTExMjk7ZS55dXNtYWxsaGlyYWdhbmE9MTI0MjE7ZS55dXNtYWxsa2F0YWthbmE9MTI1MTc7ZS55dXNtYWxsa2F0YWthbmFoYWxmd2lkdGg9NjUzODk7ZS55dXlla29yZWFuPTEyNjgzO2UueXV5ZW9rb3JlYW49MTI2ODI7ZS55eWFiZW5nYWxpPTI1Mjc7ZS55eWFkZXZhPTIzOTk7ZS56PTEyMjtlLnphYXJtZW5pYW49MTM4MjtlLnphY3V0ZT0zNzg7ZS56YWRldmE9MjM5NTtlLnphZ3VybXVraGk9MjY1MTtlLnphaGFyYWJpYz0xNTkyO2UuemFoZmluYWxhcmFiaWM9NjUyMjI7ZS56YWhpbml0aWFsYXJhYmljPTY1MjIzO2UuemFoaXJhZ2FuYT0xMjM3NDtlLnphaG1lZGlhbGFyYWJpYz02NTIyNDtlLnphaW5hcmFiaWM9MTU4NjtlLnphaW5maW5hbGFyYWJpYz02NTIwMDtlLnpha2F0YWthbmE9MTI0NzA7ZS56YXFlZmdhZG9saGVicmV3PTE0Mjk7ZS56YXFlZnFhdGFuaGVicmV3PTE0Mjg7ZS56YXJxYWhlYnJldz0xNDMyO2UuemF5aW49MTQ5NDtlLnpheWluZGFnZXNoPTY0MzEwO2UuemF5aW5kYWdlc2hoZWJyZXc9NjQzMTA7ZS56YXlpbmhlYnJldz0xNDk0O2UuemJvcG9tb2ZvPTEyNTY3O2UuemNhcm9uPTM4MjtlLnpjaXJjbGU9OTQ0OTtlLnpjaXJjdW1mbGV4PTc4MjU7ZS56Y3VybD02NTc7ZS56ZG90PTM4MDtlLnpkb3RhY2NlbnQ9MzgwO2UuemRvdGJlbG93PTc4Mjc7ZS56ZWN5cmlsbGljPTEwNzk7ZS56ZWRlc2NlbmRlcmN5cmlsbGljPTExNzc7ZS56ZWRpZXJlc2lzY3lyaWxsaWM9MTI0NztlLnplaGlyYWdhbmE9MTIzODA7ZS56ZWthdGFrYW5hPTEyNDc2O2UuemVybz00ODtlLnplcm9hcmFiaWM9MTYzMjtlLnplcm9iZW5nYWxpPTI1MzQ7ZS56ZXJvZGV2YT0yNDA2O2UuemVyb2d1amFyYXRpPTI3OTA7ZS56ZXJvZ3VybXVraGk9MjY2MjtlLnplcm9oYWNrYXJhYmljPTE2MzI7ZS56ZXJvaW5mZXJpb3I9ODMyMDtlLnplcm9tb25vc3BhY2U9NjUyOTY7ZS56ZXJvb2xkc3R5bGU9NjMyODA7ZS56ZXJvcGVyc2lhbj0xNzc2O2UuemVyb3N1cGVyaW9yPTgzMDQ7ZS56ZXJvdGhhaT0zNjY0O2UuemVyb3dpZHRoam9pbmVyPTY1Mjc5O2UuemVyb3dpZHRobm9uam9pbmVyPTgyMDQ7ZS56ZXJvd2lkdGhzcGFjZT04MjAzO2UuemV0YT05NTA7ZS56aGJvcG9tb2ZvPTEyNTYzO2UuemhlYXJtZW5pYW49MTM4NjtlLnpoZWJyZXZlY3lyaWxsaWM9MTIxODtlLnpoZWN5cmlsbGljPTEwNzg7ZS56aGVkZXNjZW5kZXJjeXJpbGxpYz0xMTc1O2UuemhlZGllcmVzaXNjeXJpbGxpYz0xMjQ1O2UuemloaXJhZ2FuYT0xMjM3NjtlLnppa2F0YWthbmE9MTI0NzI7ZS56aW5vcmhlYnJldz0xNDU0O2UuemxpbmViZWxvdz03ODI5O2Uuem1vbm9zcGFjZT02NTM3MDtlLnpvaGlyYWdhbmE9MTIzODI7ZS56b2thdGFrYW5hPTEyNDc4O2UuenBhcmVuPTkzOTc7ZS56cmV0cm9mbGV4aG9vaz02NTY7ZS56c3Ryb2tlPTQzODtlLnp1aGlyYWdhbmE9MTIzNzg7ZS56dWthdGFrYW5hPTEyNDc0O2VbIi5ub3RkZWYiXT0wO2UuYW5nYnJhY2tldGxlZnRiaWc9OTAwMTtlLmFuZ2JyYWNrZXRsZWZ0QmlnPTkwMDE7ZS5hbmdicmFja2V0bGVmdGJpZ2c9OTAwMTtlLmFuZ2JyYWNrZXRsZWZ0QmlnZz05MDAxO2UuYW5nYnJhY2tldHJpZ2h0QmlnPTkwMDI7ZS5hbmdicmFja2V0cmlnaHRiaWc9OTAwMjtlLmFuZ2JyYWNrZXRyaWdodEJpZ2c9OTAwMjtlLmFuZ2JyYWNrZXRyaWdodGJpZ2c9OTAwMjtlLmFycm93aG9va2xlZnQ9ODYxODtlLmFycm93aG9va3JpZ2h0PTg2MTc7ZS5hcnJvd2xlZnR0b3BoYWxmPTg2MzY7ZS5hcnJvd2xlZnRib3RoYWxmPTg2Mzc7ZS5hcnJvd25vcnRoZWFzdD04NTk5O2UuYXJyb3dub3J0aHdlc3Q9ODU5ODtlLmFycm93cmlnaHR0b3BoYWxmPTg2NDA7ZS5hcnJvd3JpZ2h0Ym90aGFsZj04NjQxO2UuYXJyb3dzb3V0aGVhc3Q9ODYwMDtlLmFycm93c291dGh3ZXN0PTg2MDE7ZS5iYWNrc2xhc2hiaWc9ODcyNjtlLmJhY2tzbGFzaEJpZz04NzI2O2UuYmFja3NsYXNoQmlnZz04NzI2O2UuYmFja3NsYXNoYmlnZz04NzI2O2UuYmFyZGJsPTgyMTQ7ZS5icmFjZWh0aXBkb3dubGVmdD02NTA3OTtlLmJyYWNlaHRpcGRvd25yaWdodD02NTA3OTtlLmJyYWNlaHRpcHVwbGVmdD02NTA4MDtlLmJyYWNlaHRpcHVwcmlnaHQ9NjUwODA7ZS5icmFjZWxlZnRCaWc9MTIzO2UuYnJhY2VsZWZ0YmlnPTEyMztlLmJyYWNlbGVmdGJpZ2c9MTIzO2UuYnJhY2VsZWZ0QmlnZz0xMjM7ZS5icmFjZXJpZ2h0QmlnPTEyNTtlLmJyYWNlcmlnaHRiaWc9MTI1O2UuYnJhY2VyaWdodGJpZ2c9MTI1O2UuYnJhY2VyaWdodEJpZ2c9MTI1O2UuYnJhY2tldGxlZnRiaWc9OTE7ZS5icmFja2V0bGVmdEJpZz05MTtlLmJyYWNrZXRsZWZ0YmlnZz05MTtlLmJyYWNrZXRsZWZ0QmlnZz05MTtlLmJyYWNrZXRyaWdodEJpZz05MztlLmJyYWNrZXRyaWdodGJpZz05MztlLmJyYWNrZXRyaWdodGJpZ2c9OTM7ZS5icmFja2V0cmlnaHRCaWdnPTkzO2UuY2VpbGluZ2xlZnRiaWc9ODk2ODtlLmNlaWxpbmdsZWZ0QmlnPTg5Njg7ZS5jZWlsaW5nbGVmdEJpZ2c9ODk2ODtlLmNlaWxpbmdsZWZ0YmlnZz04OTY4O2UuY2VpbGluZ3JpZ2h0YmlnPTg5Njk7ZS5jZWlsaW5ncmlnaHRCaWc9ODk2OTtlLmNlaWxpbmdyaWdodGJpZ2c9ODk2OTtlLmNlaWxpbmdyaWdodEJpZ2c9ODk2OTtlLmNpcmNsZWRvdGRpc3BsYXk9ODg1NztlLmNpcmNsZWRvdHRleHQ9ODg1NztlLmNpcmNsZW11bHRpcGx5ZGlzcGxheT04ODU1O2UuY2lyY2xlbXVsdGlwbHl0ZXh0PTg4NTU7ZS5jaXJjbGVwbHVzZGlzcGxheT04ODUzO2UuY2lyY2xlcGx1c3RleHQ9ODg1MztlLmNvbnRpbnRlZ3JhbGRpc3BsYXk9ODc1MDtlLmNvbnRpbnRlZ3JhbHRleHQ9ODc1MDtlLmNvcHJvZHVjdGRpc3BsYXk9ODcyMDtlLmNvcHJvZHVjdHRleHQ9ODcyMDtlLmZsb29ybGVmdEJpZz04OTcwO2UuZmxvb3JsZWZ0YmlnPTg5NzA7ZS5mbG9vcmxlZnRiaWdnPTg5NzA7ZS5mbG9vcmxlZnRCaWdnPTg5NzA7ZS5mbG9vcnJpZ2h0YmlnPTg5NzE7ZS5mbG9vcnJpZ2h0QmlnPTg5NzE7ZS5mbG9vcnJpZ2h0QmlnZz04OTcxO2UuZmxvb3JyaWdodGJpZ2c9ODk3MTtlLmhhdHdpZGU9NzcwO2UuaGF0d2lkZXI9NzcwO2UuaGF0d2lkZXN0PTc3MDtlLmludGVyY2FsPTc0ODg7ZS5pbnRlZ3JhbGRpc3BsYXk9ODc0NztlLmludGVncmFsdGV4dD04NzQ3O2UuaW50ZXJzZWN0aW9uZGlzcGxheT04ODk4O2UuaW50ZXJzZWN0aW9udGV4dD04ODk4O2UubG9naWNhbGFuZGRpc3BsYXk9ODc0MztlLmxvZ2ljYWxhbmR0ZXh0PTg3NDM7ZS5sb2dpY2Fsb3JkaXNwbGF5PTg3NDQ7ZS5sb2dpY2Fsb3J0ZXh0PTg3NDQ7ZS5wYXJlbmxlZnRCaWc9NDA7ZS5wYXJlbmxlZnRiaWc9NDA7ZS5wYXJlbmxlZnRCaWdnPTQwO2UucGFyZW5sZWZ0YmlnZz00MDtlLnBhcmVucmlnaHRCaWc9NDE7ZS5wYXJlbnJpZ2h0YmlnPTQxO2UucGFyZW5yaWdodEJpZ2c9NDE7ZS5wYXJlbnJpZ2h0YmlnZz00MTtlLnByaW1lPTgyNDI7ZS5wcm9kdWN0ZGlzcGxheT04NzE5O2UucHJvZHVjdHRleHQ9ODcxOTtlLnJhZGljYWxiaWc9ODczMDtlLnJhZGljYWxCaWc9ODczMDtlLnJhZGljYWxCaWdnPTg3MzA7ZS5yYWRpY2FsYmlnZz04NzMwO2UucmFkaWNhbGJ0PTg3MzA7ZS5yYWRpY2FsdHA9ODczMDtlLnJhZGljYWx2ZXJ0ZXg9ODczMDtlLnNsYXNoYmlnPTQ3O2Uuc2xhc2hCaWc9NDc7ZS5zbGFzaEJpZ2c9NDc7ZS5zbGFzaGJpZ2c9NDc7ZS5zdW1tYXRpb25kaXNwbGF5PTg3MjE7ZS5zdW1tYXRpb250ZXh0PTg3MjE7ZS50aWxkZXdpZGU9NzMyO2UudGlsZGV3aWRlcj03MzI7ZS50aWxkZXdpZGVzdD03MzI7ZS51bmlvbmRpc3BsYXk9ODg5OTtlLnVuaW9ubXVsdGlkaXNwbGF5PTg4NDY7ZS51bmlvbm11bHRpdGV4dD04ODQ2O2UudW5pb25zcWRpc3BsYXk9ODg1MjtlLnVuaW9uc3F0ZXh0PTg4NTI7ZS51bmlvbnRleHQ9ODg5OTtlLnZleHRlbmRkb3VibGU9ODc0MTtlLnZleHRlbmRzaW5nbGU9ODczOX0pKSxHaT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9MzI7ZS5hMT05OTg1O2UuYTI9OTk4NjtlLmEyMDI9OTk4NztlLmEzPTk5ODg7ZS5hND05NzQyO2UuYTU9OTk5MDtlLmExMTk9OTk5MTtlLmExMTg9OTk5MjtlLmExMTc9OTk5MztlLmExMT05NzU1O2UuYTEyPTk3NTg7ZS5hMTM9OTk5NjtlLmExND05OTk3O2UuYTE1PTk5OTg7ZS5hMTY9OTk5OTtlLmExMDU9MWU0O2UuYTE3PTEwMDAxO2UuYTE4PTEwMDAyO2UuYTE5PTEwMDAzO2UuYTIwPTEwMDA0O2UuYTIxPTEwMDA1O2UuYTIyPTEwMDA2O2UuYTIzPTEwMDA3O2UuYTI0PTEwMDA4O2UuYTI1PTEwMDA5O2UuYTI2PTEwMDEwO2UuYTI3PTEwMDExO2UuYTI4PTEwMDEyO2UuYTY9MTAwMTM7ZS5hNz0xMDAxNDtlLmE4PTEwMDE1O2UuYTk9MTAwMTY7ZS5hMTA9MTAwMTc7ZS5hMjk9MTAwMTg7ZS5hMzA9MTAwMTk7ZS5hMzE9MTAwMjA7ZS5hMzI9MTAwMjE7ZS5hMzM9MTAwMjI7ZS5hMzQ9MTAwMjM7ZS5hMzU9OTczMztlLmEzNj0xMDAyNTtlLmEzNz0xMDAyNjtlLmEzOD0xMDAyNztlLmEzOT0xMDAyODtlLmE0MD0xMDAyOTtlLmE0MT0xMDAzMDtlLmE0Mj0xMDAzMTtlLmE0Mz0xMDAzMjtlLmE0ND0xMDAzMztlLmE0NT0xMDAzNDtlLmE0Nj0xMDAzNTtlLmE0Nz0xMDAzNjtlLmE0OD0xMDAzNztlLmE0OT0xMDAzODtlLmE1MD0xMDAzOTtlLmE1MT0xMDA0MDtlLmE1Mj0xMDA0MTtlLmE1Mz0xMDA0MjtlLmE1ND0xMDA0MztlLmE1NT0xMDA0NDtlLmE1Nj0xMDA0NTtlLmE1Nz0xMDA0NjtlLmE1OD0xMDA0NztlLmE1OT0xMDA0ODtlLmE2MD0xMDA0OTtlLmE2MT0xMDA1MDtlLmE2Mj0xMDA1MTtlLmE2Mz0xMDA1MjtlLmE2ND0xMDA1MztlLmE2NT0xMDA1NDtlLmE2Nj0xMDA1NTtlLmE2Nz0xMDA1NjtlLmE2OD0xMDA1NztlLmE2OT0xMDA1ODtlLmE3MD0xMDA1OTtlLmE3MT05Njc5O2UuYTcyPTEwMDYxO2UuYTczPTk2MzI7ZS5hNzQ9MTAwNjM7ZS5hMjAzPTEwMDY0O2UuYTc1PTEwMDY1O2UuYTIwND0xMDA2NjtlLmE3Nj05NjUwO2UuYTc3PTk2NjA7ZS5hNzg9OTY3MDtlLmE3OT0xMDA3MDtlLmE4MT05Njg3O2UuYTgyPTEwMDcyO2UuYTgzPTEwMDczO2UuYTg0PTEwMDc0O2UuYTk3PTEwMDc1O2UuYTk4PTEwMDc2O2UuYTk5PTEwMDc3O2UuYTEwMD0xMDA3ODtlLmExMDE9MTAwODE7ZS5hMTAyPTEwMDgyO2UuYTEwMz0xMDA4MztlLmExMDQ9MTAwODQ7ZS5hMTA2PTEwMDg1O2UuYTEwNz0xMDA4NjtlLmExMDg9MTAwODc7ZS5hMTEyPTk4Mjc7ZS5hMTExPTk4MzA7ZS5hMTEwPTk4Mjk7ZS5hMTA5PTk4MjQ7ZS5hMTIwPTkzMTI7ZS5hMTIxPTkzMTM7ZS5hMTIyPTkzMTQ7ZS5hMTIzPTkzMTU7ZS5hMTI0PTkzMTY7ZS5hMTI1PTkzMTc7ZS5hMTI2PTkzMTg7ZS5hMTI3PTkzMTk7ZS5hMTI4PTkzMjA7ZS5hMTI5PTkzMjE7ZS5hMTMwPTEwMTAyO2UuYTEzMT0xMDEwMztlLmExMzI9MTAxMDQ7ZS5hMTMzPTEwMTA1O2UuYTEzND0xMDEwNjtlLmExMzU9MTAxMDc7ZS5hMTM2PTEwMTA4O2UuYTEzNz0xMDEwOTtlLmExMzg9MTAxMTA7ZS5hMTM5PTEwMTExO2UuYTE0MD0xMDExMjtlLmExNDE9MTAxMTM7ZS5hMTQyPTEwMTE0O2UuYTE0Mz0xMDExNTtlLmExNDQ9MTAxMTY7ZS5hMTQ1PTEwMTE3O2UuYTE0Nj0xMDExODtlLmExNDc9MTAxMTk7ZS5hMTQ4PTEwMTIwO2UuYTE0OT0xMDEyMTtlLmExNTA9MTAxMjI7ZS5hMTUxPTEwMTIzO2UuYTE1Mj0xMDEyNDtlLmExNTM9MTAxMjU7ZS5hMTU0PTEwMTI2O2UuYTE1NT0xMDEyNztlLmExNTY9MTAxMjg7ZS5hMTU3PTEwMTI5O2UuYTE1OD0xMDEzMDtlLmExNTk9MTAxMzE7ZS5hMTYwPTEwMTMyO2UuYTE2MT04NTk0O2UuYTE2Mz04NTk2O2UuYTE2ND04NTk3O2UuYTE5Nj0xMDEzNjtlLmExNjU9MTAxMzc7ZS5hMTkyPTEwMTM4O2UuYTE2Nj0xMDEzOTtlLmExNjc9MTAxNDA7ZS5hMTY4PTEwMTQxO2UuYTE2OT0xMDE0MjtlLmExNzA9MTAxNDM7ZS5hMTcxPTEwMTQ0O2UuYTE3Mj0xMDE0NTtlLmExNzM9MTAxNDY7ZS5hMTYyPTEwMTQ3O2UuYTE3ND0xMDE0ODtlLmExNzU9MTAxNDk7ZS5hMTc2PTEwMTUwO2UuYTE3Nz0xMDE1MTtlLmExNzg9MTAxNTI7ZS5hMTc5PTEwMTUzO2UuYTE5Mz0xMDE1NDtlLmExODA9MTAxNTU7ZS5hMTk5PTEwMTU2O2UuYTE4MT0xMDE1NztlLmEyMDA9MTAxNTg7ZS5hMTgyPTEwMTU5O2UuYTIwMT0xMDE2MTtlLmExODM9MTAxNjI7ZS5hMTg0PTEwMTYzO2UuYTE5Nz0xMDE2NDtlLmExODU9MTAxNjU7ZS5hMTk0PTEwMTY2O2UuYTE5OD0xMDE2NztlLmExODY9MTAxNjg7ZS5hMTk1PTEwMTY5O2UuYTE4Nz0xMDE3MDtlLmExODg9MTAxNzE7ZS5hMTg5PTEwMTcyO2UuYTE5MD0xMDE3MztlLmExOTE9MTAxNzQ7ZS5hODk9MTAwODg7ZS5hOTA9MTAwODk7ZS5hOTM9MTAwOTA7ZS5hOTQ9MTAwOTE7ZS5hOTE9MTAwOTI7ZS5hOTI9MTAwOTM7ZS5hMjA1PTEwMDk0O2UuYTg1PTEwMDk1O2UuYTIwNj0xMDA5NjtlLmE4Nj0xMDA5NztlLmE4Nz0xMDA5ODtlLmE4OD0xMDA5OTtlLmE5NT0xMDEwMDtlLmE5Nj0xMDEwMTtlWyIubm90ZGVmIl09MH0pKSx4aT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2VbNjM3MjFdPTE2OTtlWzYzMTkzXT0xNjk7ZVs2MzcyMF09MTc0O2VbNjMxOTRdPTE3NDtlWzYzNzIyXT04NDgyO2VbNjMxOTVdPTg0ODI7ZVs2MzcyOV09OTEyNztlWzYzNzMwXT05MTI4O2VbNjM3MzFdPTkxMjk7ZVs2Mzc0MF09OTEzMTtlWzYzNzQxXT05MTMyO2VbNjM3NDJdPTkxMzM7ZVs2MzcyNl09OTEyMTtlWzYzNzI3XT05MTIyO2VbNjM3MjhdPTkxMjM7ZVs2MzczN109OTEyNDtlWzYzNzM4XT05MTI1O2VbNjM3MzldPTkxMjY7ZVs2MzcyM109OTExNTtlWzYzNzI0XT05MTE2O2VbNjM3MjVdPTkxMTc7ZVs2MzczNF09OTExODtlWzYzNzM1XT05MTE5O2VbNjM3MzZdPTkxMjB9KSk7ZnVuY3Rpb24gZ2V0VW5pY29kZUZvckdseXBoKGUsdCl7bGV0IGk9dFtlXTtpZih2b2lkIDAhPT1pKXJldHVybiBpO2lmKCFlKXJldHVybi0xO2lmKCJ1Ij09PWVbMF0pe2NvbnN0IHQ9ZS5sZW5ndGg7bGV0IGE7aWYoNz09PXQmJiJuIj09PWVbMV0mJiJpIj09PWVbMl0pYT1lLnN1YnN0cmluZygzKTtlbHNle2lmKCEodD49NSYmdDw9NykpcmV0dXJuLTE7YT1lLnN1YnN0cmluZygxKX1pZihhPT09YS50b1VwcGVyQ2FzZSgpKXtpPXBhcnNlSW50KGEsMTYpO2lmKGk+PTApcmV0dXJuIGl9fXJldHVybi0xfWNvbnN0IE1pPVtbMCwxMjddLFsxMjgsMjU1XSxbMjU2LDM4M10sWzM4NCw1OTFdLFs1OTIsNjg3LDc0MjQsNzU1MSw3NTUyLDc2MTVdLFs2ODgsNzY3LDQyNzUyLDQyNzgzXSxbNzY4LDg3OSw3NjE2LDc2NzldLFs4ODAsMTAyM10sWzExMzkyLDExNTE5XSxbMTAyNCwxMjc5LDEyODAsMTMyNywxMTc0NCwxMTc3NSw0MjU2MCw0MjY1NV0sWzEzMjgsMTQyM10sWzE0MjQsMTUzNV0sWzQyMjQwLDQyNTU5XSxbMTUzNiwxNzkxLDE4NzIsMTkxOV0sWzE5ODQsMjA0N10sWzIzMDQsMjQzMV0sWzI0MzIsMjU1OV0sWzI1NjAsMjY4N10sWzI2ODgsMjgxNV0sWzI4MTYsMjk0M10sWzI5NDQsMzA3MV0sWzMwNzIsMzE5OV0sWzMyMDAsMzMyN10sWzMzMjgsMzQ1NV0sWzM1ODQsMzcxMV0sWzM3MTIsMzgzOV0sWzQyNTYsNDM1MSwxMTUyMCwxMTU2N10sWzY5MTIsNzAzOV0sWzQzNTIsNDYwN10sWzc2ODAsNzkzNSwxMTM2MCwxMTM5MSw0Mjc4NCw0MzAwN10sWzc5MzYsODE5MV0sWzgxOTIsODMwMywxMTc3NiwxMTkwM10sWzgzMDQsODM1MV0sWzgzNTIsODM5OV0sWzg0MDAsODQ0N10sWzg0NDgsODUyN10sWzg1MjgsODU5MV0sWzg1OTIsODcwMywxMDIyNCwxMDIzOSwxMDQ5NiwxMDYyMywxMTAwOCwxMTI2M10sWzg3MDQsODk1OSwxMDc1MiwxMTAwNywxMDE3NiwxMDIyMywxMDYyNCwxMDc1MV0sWzg5NjAsOTIxNV0sWzkyMTYsOTI3OV0sWzkyODAsOTMxMV0sWzkzMTIsOTQ3MV0sWzk0NzIsOTU5OV0sWzk2MDAsOTYzMV0sWzk2MzIsOTcyN10sWzk3MjgsOTk4M10sWzk5ODQsMTAxNzVdLFsxMjI4OCwxMjM1MV0sWzEyMzUyLDEyNDQ3XSxbMTI0NDgsMTI1NDMsMTI3ODQsMTI3OTldLFsxMjU0NCwxMjU5MSwxMjcwNCwxMjczNV0sWzEyNTkyLDEyNjg3XSxbNDMwNzIsNDMxMzVdLFsxMjgwMCwxMzA1NV0sWzEzMDU2LDEzMzExXSxbNDQwMzIsNTUyMTVdLFs1NTI5Niw1NzM0M10sWzY3ODQwLDY3ODcxXSxbMTk5NjgsNDA5NTksMTE5MDQsMTIwMzEsMTIwMzIsMTIyNTUsMTIyNzIsMTIyODcsMTMzMTIsMTk5MDMsMTMxMDcyLDE3Mzc5MSwxMjY4OCwxMjcwM10sWzU3MzQ0LDYzNzQzXSxbMTI3MzYsMTI3ODMsNjM3NDQsNjQyNTUsMTk0NTYwLDE5NTEwM10sWzY0MjU2LDY0MzM1XSxbNjQzMzYsNjUwMjNdLFs2NTA1Niw2NTA3MV0sWzY1MDQwLDY1MDU1XSxbNjUxMDQsNjUxMzVdLFs2NTEzNiw2NTI3OV0sWzY1MjgwLDY1NTE5XSxbNjU1MjAsNjU1MzVdLFszODQwLDQwOTVdLFsxNzkyLDE4NzFdLFsxOTIwLDE5ODNdLFszNDU2LDM1ODNdLFs0MDk2LDQyNTVdLFs0NjA4LDQ5OTEsNDk5Miw1MDIzLDExNjQ4LDExNzQzXSxbNTAyNCw1MTE5XSxbNTEyMCw1NzU5XSxbNTc2MCw1NzkxXSxbNTc5Miw1ODg3XSxbNjAxNiw2MTQzXSxbNjE0NCw2MzE5XSxbMTAyNDAsMTA0OTVdLFs0MDk2MCw0MjEyN10sWzU4ODgsNTkxOSw1OTIwLDU5NTEsNTk1Miw1OTgzLDU5ODQsNjAxNV0sWzY2MzA0LDY2MzUxXSxbNjYzNTIsNjYzODNdLFs2NjU2MCw2NjYzOV0sWzExODc4NCwxMTkwMzksMTE5MDQwLDExOTI5NSwxMTkyOTYsMTE5Mzc1XSxbMTE5ODA4LDEyMDgzMV0sWzEwNDQ0ODAsMTA0ODU3M10sWzY1MDI0LDY1MDM5LDkxNzc2MCw5MTc5OTldLFs5MTc1MDQsOTE3NjMxXSxbNjQwMCw2NDc5XSxbNjQ4MCw2NTI3XSxbNjUyOCw2NjIzXSxbNjY1Niw2Njg3XSxbMTEyNjQsMTEzNTldLFsxMTU2OCwxMTY0N10sWzE5OTA0LDE5OTY3XSxbNDMwMDgsNDMwNTVdLFs2NTUzNiw2NTY2Myw2NTY2NCw2NTc5MSw2NTc5Miw2NTg1NV0sWzY1ODU2LDY1OTM1XSxbNjY0MzIsNjY0NjNdLFs2NjQ2NCw2NjUyN10sWzY2NjQwLDY2Njg3XSxbNjY2ODgsNjY3MzVdLFs2NzU4NCw2NzY0N10sWzY4MDk2LDY4MTkxXSxbMTE5NTUyLDExOTY0N10sWzczNzI4LDc0NzUxLDc0NzUyLDc0ODc5XSxbMTE5NjQ4LDExOTY3OV0sWzcwNDAsNzEwM10sWzcxNjgsNzI0N10sWzcyNDgsNzI5NV0sWzQzMTM2LDQzMjMxXSxbNDMyNjQsNDMzMTFdLFs0MzMxMiw0MzM1OV0sWzQzNTIwLDQzNjE1XSxbNjU5MzYsNjU5OTldLFs2NmUzLDY2MDQ3XSxbNjYyMDgsNjYyNzEsNjYxNzYsNjYyMDcsNjc4NzIsNjc5MDNdLFsxMjcwMjQsMTI3MTM1LDEyNjk3NiwxMjcwMjNdXTtmdW5jdGlvbiBnZXRVbmljb2RlUmFuZ2VGb3IoZSx0PS0xKXtpZigtMSE9PXQpe2NvbnN0IGk9TWlbdF07Zm9yKGxldCBhPTAscz1pLmxlbmd0aDthPHM7YSs9MilpZihlPj1pW2FdJiZlPD1pW2ErMV0pcmV0dXJuIHR9Zm9yKGxldCB0PTAsaT1NaS5sZW5ndGg7dDxpO3QrKyl7Y29uc3QgaT1NaVt0XTtmb3IobGV0IGE9MCxzPWkubGVuZ3RoO2E8czthKz0yKWlmKGU+PWlbYV0mJmU8PWlbYSsxXSlyZXR1cm4gdH1yZXR1cm4tMX1jb25zdCBIaT1uZXcgUmVnRXhwKCJeKFxccyl8KFxccHtNbn0pfChcXHB7Q2Z9KSQiLCJ1IiksSmk9bmV3IE1hcDtjb25zdCBZaT0hMCx2aT0xLEtpPTIsVGk9NCxxaT0zMixPaT1bIi5ub3RkZWYiLCIubnVsbCIsIm5vbm1hcmtpbmdyZXR1cm4iLCJzcGFjZSIsImV4Y2xhbSIsInF1b3RlZGJsIiwibnVtYmVyc2lnbiIsImRvbGxhciIsInBlcmNlbnQiLCJhbXBlcnNhbmQiLCJxdW90ZXNpbmdsZSIsInBhcmVubGVmdCIsInBhcmVucmlnaHQiLCJhc3RlcmlzayIsInBsdXMiLCJjb21tYSIsImh5cGhlbiIsInBlcmlvZCIsInNsYXNoIiwiemVybyIsIm9uZSIsInR3byIsInRocmVlIiwiZm91ciIsImZpdmUiLCJzaXgiLCJzZXZlbiIsImVpZ2h0IiwibmluZSIsImNvbG9uIiwic2VtaWNvbG9uIiwibGVzcyIsImVxdWFsIiwiZ3JlYXRlciIsInF1ZXN0aW9uIiwiYXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiWiIsImJyYWNrZXRsZWZ0IiwiYmFja3NsYXNoIiwiYnJhY2tldHJpZ2h0IiwiYXNjaWljaXJjdW0iLCJ1bmRlcnNjb3JlIiwiZ3JhdmUiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsImJyYWNlbGVmdCIsImJhciIsImJyYWNlcmlnaHQiLCJhc2NpaXRpbGRlIiwiQWRpZXJlc2lzIiwiQXJpbmciLCJDY2VkaWxsYSIsIkVhY3V0ZSIsIk50aWxkZSIsIk9kaWVyZXNpcyIsIlVkaWVyZXNpcyIsImFhY3V0ZSIsImFncmF2ZSIsImFjaXJjdW1mbGV4IiwiYWRpZXJlc2lzIiwiYXRpbGRlIiwiYXJpbmciLCJjY2VkaWxsYSIsImVhY3V0ZSIsImVncmF2ZSIsImVjaXJjdW1mbGV4IiwiZWRpZXJlc2lzIiwiaWFjdXRlIiwiaWdyYXZlIiwiaWNpcmN1bWZsZXgiLCJpZGllcmVzaXMiLCJudGlsZGUiLCJvYWN1dGUiLCJvZ3JhdmUiLCJvY2lyY3VtZmxleCIsIm9kaWVyZXNpcyIsIm90aWxkZSIsInVhY3V0ZSIsInVncmF2ZSIsInVjaXJjdW1mbGV4IiwidWRpZXJlc2lzIiwiZGFnZ2VyIiwiZGVncmVlIiwiY2VudCIsInN0ZXJsaW5nIiwic2VjdGlvbiIsImJ1bGxldCIsInBhcmFncmFwaCIsImdlcm1hbmRibHMiLCJyZWdpc3RlcmVkIiwiY29weXJpZ2h0IiwidHJhZGVtYXJrIiwiYWN1dGUiLCJkaWVyZXNpcyIsIm5vdGVxdWFsIiwiQUUiLCJPc2xhc2giLCJpbmZpbml0eSIsInBsdXNtaW51cyIsImxlc3NlcXVhbCIsImdyZWF0ZXJlcXVhbCIsInllbiIsIm11IiwicGFydGlhbGRpZmYiLCJzdW1tYXRpb24iLCJwcm9kdWN0IiwicGkiLCJpbnRlZ3JhbCIsIm9yZGZlbWluaW5lIiwib3JkbWFzY3VsaW5lIiwiT21lZ2EiLCJhZSIsIm9zbGFzaCIsInF1ZXN0aW9uZG93biIsImV4Y2xhbWRvd24iLCJsb2dpY2Fsbm90IiwicmFkaWNhbCIsImZsb3JpbiIsImFwcHJveGVxdWFsIiwiRGVsdGEiLCJndWlsbGVtb3RsZWZ0IiwiZ3VpbGxlbW90cmlnaHQiLCJlbGxpcHNpcyIsIm5vbmJyZWFraW5nc3BhY2UiLCJBZ3JhdmUiLCJBdGlsZGUiLCJPdGlsZGUiLCJPRSIsIm9lIiwiZW5kYXNoIiwiZW1kYXNoIiwicXVvdGVkYmxsZWZ0IiwicXVvdGVkYmxyaWdodCIsInF1b3RlbGVmdCIsInF1b3RlcmlnaHQiLCJkaXZpZGUiLCJsb3plbmdlIiwieWRpZXJlc2lzIiwiWWRpZXJlc2lzIiwiZnJhY3Rpb24iLCJjdXJyZW5jeSIsImd1aWxzaW5nbGxlZnQiLCJndWlsc2luZ2xyaWdodCIsImZpIiwiZmwiLCJkYWdnZXJkYmwiLCJwZXJpb2RjZW50ZXJlZCIsInF1b3Rlc2luZ2xiYXNlIiwicXVvdGVkYmxiYXNlIiwicGVydGhvdXNhbmQiLCJBY2lyY3VtZmxleCIsIkVjaXJjdW1mbGV4IiwiQWFjdXRlIiwiRWRpZXJlc2lzIiwiRWdyYXZlIiwiSWFjdXRlIiwiSWNpcmN1bWZsZXgiLCJJZGllcmVzaXMiLCJJZ3JhdmUiLCJPYWN1dGUiLCJPY2lyY3VtZmxleCIsImFwcGxlIiwiT2dyYXZlIiwiVWFjdXRlIiwiVWNpcmN1bWZsZXgiLCJVZ3JhdmUiLCJkb3RsZXNzaSIsImNpcmN1bWZsZXgiLCJ0aWxkZSIsIm1hY3JvbiIsImJyZXZlIiwiZG90YWNjZW50IiwicmluZyIsImNlZGlsbGEiLCJodW5nYXJ1bWxhdXQiLCJvZ29uZWsiLCJjYXJvbiIsIkxzbGFzaCIsImxzbGFzaCIsIlNjYXJvbiIsInNjYXJvbiIsIlpjYXJvbiIsInpjYXJvbiIsImJyb2tlbmJhciIsIkV0aCIsImV0aCIsIllhY3V0ZSIsInlhY3V0ZSIsIlRob3JuIiwidGhvcm4iLCJtaW51cyIsIm11bHRpcGx5Iiwib25lc3VwZXJpb3IiLCJ0d29zdXBlcmlvciIsInRocmVlc3VwZXJpb3IiLCJvbmVoYWxmIiwib25lcXVhcnRlciIsInRocmVlcXVhcnRlcnMiLCJmcmFuYyIsIkdicmV2ZSIsImdicmV2ZSIsIklkb3RhY2NlbnQiLCJTY2VkaWxsYSIsInNjZWRpbGxhIiwiQ2FjdXRlIiwiY2FjdXRlIiwiQ2Nhcm9uIiwiY2Nhcm9uIiwiZGNyb2F0Il07ZnVuY3Rpb24gcmVjb3ZlckdseXBoTmFtZShlLHQpe2lmKHZvaWQgMCE9PXRbZV0pcmV0dXJuIGU7Y29uc3QgaT1nZXRVbmljb2RlRm9yR2x5cGgoZSx0KTtpZigtMSE9PWkpZm9yKGNvbnN0IGUgaW4gdClpZih0W2VdPT09aSlyZXR1cm4gZTtpbmZvKCJVbmFibGUgdG8gcmVjb3ZlciBhIHN0YW5kYXJkIGdseXBoIG5hbWUgZm9yOiAiK2UpO3JldHVybiBlfWZ1bmN0aW9uIHR5cGUxRm9udEdseXBoTWFwcGluZyhlLHQsaSl7Y29uc3QgYT1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBzLHIsbjtjb25zdCBvPSEhKGUuZmxhZ3MmVGkpO2lmKGUuaXNJbnRlcm5hbEZvbnQpe249dDtmb3Iocj0wO3I8bi5sZW5ndGg7cisrKXtzPWkuaW5kZXhPZihuW3JdKTthW3JdPXM+PTA/czowfX1lbHNlIGlmKGUuYmFzZUVuY29kaW5nTmFtZSl7bj1nZXRFbmNvZGluZyhlLmJhc2VFbmNvZGluZ05hbWUpO2ZvcihyPTA7cjxuLmxlbmd0aDtyKyspe3M9aS5pbmRleE9mKG5bcl0pO2Fbcl09cz49MD9zOjB9fWVsc2UgaWYobylmb3IociBpbiB0KWFbcl09dFtyXTtlbHNle249Zmk7Zm9yKHI9MDtyPG4ubGVuZ3RoO3IrKyl7cz1pLmluZGV4T2YobltyXSk7YVtyXT1zPj0wP3M6MH19Y29uc3QgZz1lLmRpZmZlcmVuY2VzO2xldCBjO2lmKGcpZm9yKHIgaW4gZyl7Y29uc3QgZT1nW3JdO3M9aS5pbmRleE9mKGUpO2lmKC0xPT09cyl7Y3x8KGM9UmkoKSk7Y29uc3QgdD1yZWNvdmVyR2x5cGhOYW1lKGUsYyk7dCE9PWUmJihzPWkuaW5kZXhPZih0KSl9YVtyXT1zPj0wP3M6MH1yZXR1cm4gYX1mdW5jdGlvbiBub3JtYWxpemVGb250TmFtZShlKXtyZXR1cm4gZS5yZXBsYWNlQWxsKC9bLF9dL2csIi0iKS5yZXBsYWNlQWxsKC9ccy9nLCIiKX1jb25zdCBQaT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2VbIlRpbWVzLVJvbWFuIl09IlRpbWVzLVJvbWFuIjtlLkhlbHZldGljYT0iSGVsdmV0aWNhIjtlLkNvdXJpZXI9IkNvdXJpZXIiO2UuU3ltYm9sPSJTeW1ib2wiO2VbIlRpbWVzLUJvbGQiXT0iVGltZXMtQm9sZCI7ZVsiSGVsdmV0aWNhLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkNvdXJpZXItQm9sZCJdPSJDb3VyaWVyLUJvbGQiO2UuWmFwZkRpbmdiYXRzPSJaYXBmRGluZ2JhdHMiO2VbIlRpbWVzLUl0YWxpYyJdPSJUaW1lcy1JdGFsaWMiO2VbIkhlbHZldGljYS1PYmxpcXVlIl09IkhlbHZldGljYS1PYmxpcXVlIjtlWyJDb3VyaWVyLU9ibGlxdWUiXT0iQ291cmllci1PYmxpcXVlIjtlWyJUaW1lcy1Cb2xkSXRhbGljIl09IlRpbWVzLUJvbGRJdGFsaWMiO2VbIkhlbHZldGljYS1Cb2xkT2JsaXF1ZSJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkNvdXJpZXItQm9sZE9ibGlxdWUiXT0iQ291cmllci1Cb2xkT2JsaXF1ZSI7ZS5BcmlhbE5hcnJvdz0iSGVsdmV0aWNhIjtlWyJBcmlhbE5hcnJvdy1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJBcmlhbE5hcnJvdy1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQXJpYWxOYXJyb3ctSXRhbGljIl09IkhlbHZldGljYS1PYmxpcXVlIjtlLkFyaWFsQmxhY2s9IkhlbHZldGljYSI7ZVsiQXJpYWxCbGFjay1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJBcmlhbEJsYWNrLUJvbGRJdGFsaWMiXT0iSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjtlWyJBcmlhbEJsYWNrLUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZVsiQXJpYWwtQmxhY2siXT0iSGVsdmV0aWNhIjtlWyJBcmlhbC1CbGFjay1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJBcmlhbC1CbGFjay1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQXJpYWwtQmxhY2stSXRhbGljIl09IkhlbHZldGljYS1PYmxpcXVlIjtlLkFyaWFsPSJIZWx2ZXRpY2EiO2VbIkFyaWFsLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkFyaWFsLUJvbGRJdGFsaWMiXT0iSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjtlWyJBcmlhbC1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuQXJpYWxNVD0iSGVsdmV0aWNhIjtlWyJBcmlhbC1Cb2xkSXRhbGljTVQiXT0iSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjtlWyJBcmlhbC1Cb2xkTVQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkFyaWFsLUl0YWxpY01UIl09IkhlbHZldGljYS1PYmxpcXVlIjtlWyJBcmlhbC1Cb2xkSXRhbGljTVQtQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkFyaWFsLUJvbGRNVC1Cb2xkIl09IkhlbHZldGljYS1Cb2xkIjtlWyJBcmlhbC1JdGFsaWNNVC1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuQXJpYWxVbmljb2RlTVM9IkhlbHZldGljYSI7ZVsiQXJpYWxVbmljb2RlTVMtQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQXJpYWxVbmljb2RlTVMtQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkFyaWFsVW5pY29kZU1TLUl0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZVsiQ291cmllci1Cb2xkSXRhbGljIl09IkNvdXJpZXItQm9sZE9ibGlxdWUiO2VbIkNvdXJpZXItSXRhbGljIl09IkNvdXJpZXItT2JsaXF1ZSI7ZS5Db3VyaWVyTmV3PSJDb3VyaWVyIjtlWyJDb3VyaWVyTmV3LUJvbGQiXT0iQ291cmllci1Cb2xkIjtlWyJDb3VyaWVyTmV3LUJvbGRJdGFsaWMiXT0iQ291cmllci1Cb2xkT2JsaXF1ZSI7ZVsiQ291cmllck5ldy1JdGFsaWMiXT0iQ291cmllci1PYmxpcXVlIjtlWyJDb3VyaWVyTmV3UFMtQm9sZEl0YWxpY01UIl09IkNvdXJpZXItQm9sZE9ibGlxdWUiO2VbIkNvdXJpZXJOZXdQUy1Cb2xkTVQiXT0iQ291cmllci1Cb2xkIjtlWyJDb3VyaWVyTmV3UFMtSXRhbGljTVQiXT0iQ291cmllci1PYmxpcXVlIjtlLkNvdXJpZXJOZXdQU01UPSJDb3VyaWVyIjtlWyJIZWx2ZXRpY2EtQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkhlbHZldGljYS1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2VbIlN5bWJvbC1Cb2xkIl09IlN5bWJvbCI7ZVsiU3ltYm9sLUJvbGRJdGFsaWMiXT0iU3ltYm9sIjtlWyJTeW1ib2wtSXRhbGljIl09IlN5bWJvbCI7ZS5UaW1lc05ld1JvbWFuPSJUaW1lcy1Sb21hbiI7ZVsiVGltZXNOZXdSb21hbi1Cb2xkIl09IlRpbWVzLUJvbGQiO2VbIlRpbWVzTmV3Um9tYW4tQm9sZEl0YWxpYyJdPSJUaW1lcy1Cb2xkSXRhbGljIjtlWyJUaW1lc05ld1JvbWFuLUl0YWxpYyJdPSJUaW1lcy1JdGFsaWMiO2UuVGltZXNOZXdSb21hblBTPSJUaW1lcy1Sb21hbiI7ZVsiVGltZXNOZXdSb21hblBTLUJvbGQiXT0iVGltZXMtQm9sZCI7ZVsiVGltZXNOZXdSb21hblBTLUJvbGRJdGFsaWMiXT0iVGltZXMtQm9sZEl0YWxpYyI7ZVsiVGltZXNOZXdSb21hblBTLUJvbGRJdGFsaWNNVCJdPSJUaW1lcy1Cb2xkSXRhbGljIjtlWyJUaW1lc05ld1JvbWFuUFMtQm9sZE1UIl09IlRpbWVzLUJvbGQiO2VbIlRpbWVzTmV3Um9tYW5QUy1JdGFsaWMiXT0iVGltZXMtSXRhbGljIjtlWyJUaW1lc05ld1JvbWFuUFMtSXRhbGljTVQiXT0iVGltZXMtSXRhbGljIjtlLlRpbWVzTmV3Um9tYW5QU01UPSJUaW1lcy1Sb21hbiI7ZVsiVGltZXNOZXdSb21hblBTTVQtQm9sZCJdPSJUaW1lcy1Cb2xkIjtlWyJUaW1lc05ld1JvbWFuUFNNVC1Cb2xkSXRhbGljIl09IlRpbWVzLUJvbGRJdGFsaWMiO2VbIlRpbWVzTmV3Um9tYW5QU01ULUl0YWxpYyJdPSJUaW1lcy1JdGFsaWMifSkpLFdpPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZS5Db3VyaWVyPSJGb3hpdEZpeGVkLnBmYiI7ZVsiQ291cmllci1Cb2xkIl09IkZveGl0Rml4ZWRCb2xkLnBmYiI7ZVsiQ291cmllci1Cb2xkT2JsaXF1ZSJdPSJGb3hpdEZpeGVkQm9sZEl0YWxpYy5wZmIiO2VbIkNvdXJpZXItT2JsaXF1ZSJdPSJGb3hpdEZpeGVkSXRhbGljLnBmYiI7ZS5IZWx2ZXRpY2E9IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIudHRmIjtlWyJIZWx2ZXRpY2EtQm9sZCJdPSJMaWJlcmF0aW9uU2Fucy1Cb2xkLnR0ZiI7ZVsiSGVsdmV0aWNhLUJvbGRPYmxpcXVlIl09IkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMudHRmIjtlWyJIZWx2ZXRpY2EtT2JsaXF1ZSJdPSJMaWJlcmF0aW9uU2Fucy1JdGFsaWMudHRmIjtlWyJUaW1lcy1Sb21hbiJdPSJGb3hpdFNlcmlmLnBmYiI7ZVsiVGltZXMtQm9sZCJdPSJGb3hpdFNlcmlmQm9sZC5wZmIiO2VbIlRpbWVzLUJvbGRJdGFsaWMiXT0iRm94aXRTZXJpZkJvbGRJdGFsaWMucGZiIjtlWyJUaW1lcy1JdGFsaWMiXT0iRm94aXRTZXJpZkl0YWxpYy5wZmIiO2UuU3ltYm9sPSJGb3hpdFN5bWJvbC5wZmIiO2UuWmFwZkRpbmdiYXRzPSJGb3hpdERpbmdiYXRzLnBmYiI7ZVsiTGliZXJhdGlvblNhbnMtUmVndWxhciJdPSJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyLnR0ZiI7ZVsiTGliZXJhdGlvblNhbnMtQm9sZCJdPSJMaWJlcmF0aW9uU2Fucy1Cb2xkLnR0ZiI7ZVsiTGliZXJhdGlvblNhbnMtSXRhbGljIl09IkxpYmVyYXRpb25TYW5zLUl0YWxpYy50dGYiO2VbIkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMiXT0iTGliZXJhdGlvblNhbnMtQm9sZEl0YWxpYy50dGYifSkpLGppPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZS5DYWxpYnJpPSJIZWx2ZXRpY2EiO2VbIkNhbGlicmktQm9sZCJdPSJIZWx2ZXRpY2EtQm9sZCI7ZVsiQ2FsaWJyaS1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiQ2FsaWJyaS1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuQ2VudHVyeUdvdGhpYz0iSGVsdmV0aWNhIjtlWyJDZW50dXJ5R290aGljLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkNlbnR1cnlHb3RoaWMtQm9sZEl0YWxpYyJdPSJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiO2VbIkNlbnR1cnlHb3RoaWMtSXRhbGljIl09IkhlbHZldGljYS1PYmxpcXVlIjtlLkNvbWljU2Fuc01TPSJDb21pYyBTYW5zIE1TIjtlWyJDb21pY1NhbnNNUy1Cb2xkIl09IkNvbWljIFNhbnMgTVMtQm9sZCI7ZVsiQ29taWNTYW5zTVMtQm9sZEl0YWxpYyJdPSJDb21pYyBTYW5zIE1TLUJvbGRJdGFsaWMiO2VbIkNvbWljU2Fuc01TLUl0YWxpYyJdPSJDb21pYyBTYW5zIE1TLUl0YWxpYyI7ZS5JbXBhY3Q9IkhlbHZldGljYSI7ZVsiSXRjU3ltYm9sLUJvbGQiXT0iSGVsdmV0aWNhLUJvbGQiO2VbIkl0Y1N5bWJvbC1Cb2xkSXRhbGljIl09IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSI7ZVsiSXRjU3ltYm9sLUJvb2siXT0iSGVsdmV0aWNhIjtlWyJJdGNTeW1ib2wtQm9va0l0YWxpYyJdPSJIZWx2ZXRpY2EtT2JsaXF1ZSI7ZVsiSXRjU3ltYm9sLU1lZGl1bSJdPSJIZWx2ZXRpY2EiO2VbIkl0Y1N5bWJvbC1NZWRpdW1JdGFsaWMiXT0iSGVsdmV0aWNhLU9ibGlxdWUiO2UuTHVjaWRhQ29uc29sZT0iQ291cmllciI7ZVsiTHVjaWRhQ29uc29sZS1Cb2xkIl09IkNvdXJpZXItQm9sZCI7ZVsiTHVjaWRhQ29uc29sZS1Cb2xkSXRhbGljIl09IkNvdXJpZXItQm9sZE9ibGlxdWUiO2VbIkx1Y2lkYUNvbnNvbGUtSXRhbGljIl09IkNvdXJpZXItT2JsaXF1ZSI7ZVsiTHVjaWRhU2Fucy1EZW1pIl09IkhlbHZldGljYS1Cb2xkIjtlWyJNUy1Hb3RoaWMiXT0iTVMgR290aGljIjtlWyJNUy1Hb3RoaWMtQm9sZCJdPSJNUyBHb3RoaWMtQm9sZCI7ZVsiTVMtR290aGljLUJvbGRJdGFsaWMiXT0iTVMgR290aGljLUJvbGRJdGFsaWMiO2VbIk1TLUdvdGhpYy1JdGFsaWMiXT0iTVMgR290aGljLUl0YWxpYyI7ZVsiTVMtTWluY2hvIl09Ik1TIE1pbmNobyI7ZVsiTVMtTWluY2hvLUJvbGQiXT0iTVMgTWluY2hvLUJvbGQiO2VbIk1TLU1pbmNoby1Cb2xkSXRhbGljIl09Ik1TIE1pbmNoby1Cb2xkSXRhbGljIjtlWyJNUy1NaW5jaG8tSXRhbGljIl09Ik1TIE1pbmNoby1JdGFsaWMiO2VbIk1TLVBHb3RoaWMiXT0iTVMgUEdvdGhpYyI7ZVsiTVMtUEdvdGhpYy1Cb2xkIl09Ik1TIFBHb3RoaWMtQm9sZCI7ZVsiTVMtUEdvdGhpYy1Cb2xkSXRhbGljIl09Ik1TIFBHb3RoaWMtQm9sZEl0YWxpYyI7ZVsiTVMtUEdvdGhpYy1JdGFsaWMiXT0iTVMgUEdvdGhpYy1JdGFsaWMiO2VbIk1TLVBNaW5jaG8iXT0iTVMgUE1pbmNobyI7ZVsiTVMtUE1pbmNoby1Cb2xkIl09Ik1TIFBNaW5jaG8tQm9sZCI7ZVsiTVMtUE1pbmNoby1Cb2xkSXRhbGljIl09Ik1TIFBNaW5jaG8tQm9sZEl0YWxpYyI7ZVsiTVMtUE1pbmNoby1JdGFsaWMiXT0iTVMgUE1pbmNoby1JdGFsaWMiO2UuTnVwdGlhbFNjcmlwdD0iVGltZXMtSXRhbGljIjtlLlNlZ29lVUlTeW1ib2w9IkhlbHZldGljYSJ9KSksWGk9Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlWyJBZG9iZSBKZW5zb24iXT0hMDtlWyJBZG9iZSBUZXh0Il09ITA7ZS5BbGJlcnR1cz0hMDtlLkFsZHVzPSEwO2UuQWxleGFuZHJpYT0hMDtlLkFsZ2VyaWFuPSEwO2VbIkFtZXJpY2FuIFR5cGV3cml0ZXIiXT0hMDtlLkFudGlxdWE9ITA7ZS5BcGV4PSEwO2UuQXJubz0hMDtlLkFzdGVyPSEwO2UuQXVyb3JhPSEwO2UuQmFza2VydmlsbGU9ITA7ZS5CZWxsPSEwO2UuQmVtYm89ITA7ZVsiQmVtYm8gU2Nob29sYm9vayJdPSEwO2UuQmVuZ3VpYXQ9ITA7ZVsiQmVya2VsZXkgT2xkIFN0eWxlIl09ITA7ZVsiQmVybmhhcmQgTW9kZXJuIl09ITA7ZVsiQmVydGhvbGQgQ2l0eSJdPSEwO2UuQm9kb25pPSEwO2VbIkJhdWVyIEJvZG9uaSJdPSEwO2VbIkJvb2sgQW50aXF1YSJdPSEwO2UuQm9va21hbj0hMDtlWyJCb3JkZWF1eCBSb21hbiJdPSEwO2VbIkNhbGlmb3JuaWFuIEZCIl09ITA7ZS5DYWxpc3RvPSEwO2UuQ2FsdmVydD0hMDtlLkNhcGl0YWxzPSEwO2UuQ2FtYnJpYT0hMDtlLkNhcnRpZXI9ITA7ZS5DYXNsb249ITA7ZS5DYXR1bGw9ITA7ZS5DZW50YXVyPSEwO2VbIkNlbnR1cnkgT2xkIFN0eWxlIl09ITA7ZVsiQ2VudHVyeSBTY2hvb2xib29rIl09ITA7ZS5DaGFwYXJyYWw9ITA7ZVsiQ2hhcmlzIFNJTCJdPSEwO2UuQ2hlbHRlbmhhbT0hMDtlWyJDaG9sbGEgU2xhYiJdPSEwO2UuQ2xhcmVuZG9uPSEwO2UuQ2xlYXJmYWNlPSEwO2UuQ29jaGluPSEwO2UuQ29sb25uYT0hMDtlWyJDb21wdXRlciBNb2Rlcm4iXT0hMDtlWyJDb25jcmV0ZSBSb21hbiJdPSEwO2UuQ29uc3RhbnRpYT0hMDtlWyJDb29wZXIgQmxhY2siXT0hMDtlLkNvcm9uYT0hMDtlLkVjb3R5cGU9ITA7ZS5FZ3lwdGllbm5lPSEwO2UuRWxlcGhhbnQ9ITA7ZS5FeGNlbHNpb3I9ITA7ZS5GYWlyZmllbGQ9ITA7ZVsiRkYgU2NhbGEiXT0hMDtlLkZvbGthcmQ9ITA7ZS5Gb290bGlnaHQ9ITA7ZS5GcmVlU2VyaWY9ITA7ZVsiRnJpeiBRdWFkcmF0YSJdPSEwO2UuR2FyYW1vbmQ9ITA7ZS5HZW50aXVtPSEwO2UuR2VvcmdpYT0hMDtlLkdsb3VjZXN0ZXI9ITA7ZVsiR291ZHkgT2xkIFN0eWxlIl09ITA7ZVsiR291ZHkgU2Nob29sYm9vayJdPSEwO2VbIkdvdWR5IFBybyBGb250Il09ITA7ZS5HcmFuam9uPSEwO2VbIkd1YXJkaWFuIEVneXB0aWFuIl09ITA7ZS5IZWF0aGVyPSEwO2UuSGVyY3VsZXM9ITA7ZVsiSGlnaCBUb3dlciBUZXh0Il09ITA7ZS5IaXJvc2hpZ2U9ITA7ZVsiSG9lZmxlciBUZXh0Il09ITA7ZVsiSHVtYW5hIFNlcmlmIl09ITA7ZS5JbXByaW50PSEwO2VbIklvbmljIE5vLiA1Il09ITA7ZS5KYW5zb249ITA7ZS5Kb2FubmE9ITA7ZS5Lb3Jpbm5hPSEwO2UuTGV4aWNvbj0hMDtlLkxpYmVyYXRpb25TZXJpZj0hMDtlWyJMaWJlcmF0aW9uIFNlcmlmIl09ITA7ZVsiTGludXggTGliZXJ0aW5lIl09ITA7ZS5MaXRlcmF0dXJuYXlhPSEwO2UuTHVjaWRhPSEwO2VbIkx1Y2lkYSBCcmlnaHQiXT0hMDtlLk1lbGlvcj0hMDtlLk1lbXBoaXM9ITA7ZS5NaWxsZXI9ITA7ZS5NaW5pb249ITA7ZS5Nb2Rlcm49ITA7ZVsiTW9uYSBMaXNhIl09ITA7ZVsiTXJzIEVhdmVzIl09ITA7ZVsiTVMgU2VyaWYiXT0hMDtlWyJNdXNlbyBTbGFiIl09ITA7ZVsiTmV3IFlvcmsiXT0hMDtlWyJOaW1idXMgUm9tYW4iXT0hMDtlWyJOUFMgUmF3bGluc29uIFJvYWR3YXkiXT0hMDtlLk51cHRpYWxTY3JpcHQ9ITA7ZS5QYWxhdGlubz0hMDtlLlBlcnBldHVhPSEwO2UuUGxhbnRpbj0hMDtlWyJQbGFudGluIFNjaG9vbGJvb2siXT0hMDtlLlBsYXliaWxsPSEwO2VbIlBvb3IgUmljaGFyZCJdPSEwO2VbIlJhd2xpbnNvbiBSb2Fkd2F5Il09ITA7ZS5SZW5hdWx0PSEwO2UuUmVxdWllbT0hMDtlLlJvY2t3ZWxsPSEwO2UuUm9tYW49ITA7ZVsiUm90aXMgU2VyaWYiXT0hMDtlLlNhYm9uPSEwO2UuU2NhbGE9ITA7ZS5TZWFndWxsPSEwO2UuU2lzdGluYT0hMDtlLlNvdXZlbmlyPSEwO2UuU1RJWD0hMDtlWyJTdG9uZSBJbmZvcm1hbCJdPSEwO2VbIlN0b25lIFNlcmlmIl09ITA7ZS5TeWxmYWVuPSEwO2UuVGltZXM9ITA7ZS5UcmFqYW49ITA7ZVsiVHJpbml0w6kiXT0hMDtlWyJUcnVtcCBNZWRpYWV2YWwiXT0hMDtlLlV0b3BpYT0hMDtlWyJWYWxlIFR5cGUiXT0hMDtlWyJCaXRzdHJlYW0gVmVyYSJdPSEwO2VbIlZlcmEgU2VyaWYiXT0hMDtlLlZlcnNhaWxsZXM9ITA7ZS5XYW50ZWQ9ITA7ZS5XZWlzcz0hMDtlWyJXaWRlIExhdGluIl09ITA7ZS5XaW5kc29yPSEwO2UuWElUUz0hMH0pKSxaaT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2UuRGluZ2JhdHM9ITA7ZS5TeW1ib2w9ITA7ZS5aYXBmRGluZ2JhdHM9ITA7ZS5XaW5nZGluZ3M9ITA7ZVsiV2luZ2RpbmdzLUJvbGQiXT0hMDtlWyJXaW5nZGluZ3MtUmVndWxhciJdPSEwfSkpLFZpPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZVsyXT0xMDtlWzNdPTMyO2VbNF09MzM7ZVs1XT0zNDtlWzZdPTM1O2VbN109MzY7ZVs4XT0zNztlWzldPTM4O2VbMTBdPTM5O2VbMTFdPTQwO2VbMTJdPTQxO2VbMTNdPTQyO2VbMTRdPTQzO2VbMTVdPTQ0O2VbMTZdPTQ1O2VbMTddPTQ2O2VbMThdPTQ3O2VbMTldPTQ4O2VbMjBdPTQ5O2VbMjFdPTUwO2VbMjJdPTUxO2VbMjNdPTUyO2VbMjRdPTUzO2VbMjVdPTU0O2VbMjZdPTU1O2VbMjddPTU2O2VbMjhdPTU3O2VbMjldPTU4O2VbMzBdPTg5NDtlWzMxXT02MDtlWzMyXT02MTtlWzMzXT02MjtlWzM0XT02MztlWzM1XT02NDtlWzM2XT02NTtlWzM3XT02NjtlWzM4XT02NztlWzM5XT02ODtlWzQwXT02OTtlWzQxXT03MDtlWzQyXT03MTtlWzQzXT03MjtlWzQ0XT03MztlWzQ1XT03NDtlWzQ2XT03NTtlWzQ3XT03NjtlWzQ4XT03NztlWzQ5XT03ODtlWzUwXT03OTtlWzUxXT04MDtlWzUyXT04MTtlWzUzXT04MjtlWzU0XT04MztlWzU1XT04NDtlWzU2XT04NTtlWzU3XT04NjtlWzU4XT04NztlWzU5XT04ODtlWzYwXT04OTtlWzYxXT05MDtlWzYyXT05MTtlWzYzXT05MjtlWzY0XT05MztlWzY1XT05NDtlWzY2XT05NTtlWzY3XT05NjtlWzY4XT05NztlWzY5XT05ODtlWzcwXT05OTtlWzcxXT0xMDA7ZVs3Ml09MTAxO2VbNzNdPTEwMjtlWzc0XT0xMDM7ZVs3NV09MTA0O2VbNzZdPTEwNTtlWzc3XT0xMDY7ZVs3OF09MTA3O2VbNzldPTEwODtlWzgwXT0xMDk7ZVs4MV09MTEwO2VbODJdPTExMTtlWzgzXT0xMTI7ZVs4NF09MTEzO2VbODVdPTExNDtlWzg2XT0xMTU7ZVs4N109MTE2O2VbODhdPTExNztlWzg5XT0xMTg7ZVs5MF09MTE5O2VbOTFdPTEyMDtlWzkyXT0xMjE7ZVs5M109MTIyO2VbOTRdPTEyMztlWzk1XT0xMjQ7ZVs5Nl09MTI1O2VbOTddPTEyNjtlWzk4XT0xOTY7ZVs5OV09MTk3O2VbMTAwXT0xOTk7ZVsxMDFdPTIwMTtlWzEwMl09MjA5O2VbMTAzXT0yMTQ7ZVsxMDRdPTIyMDtlWzEwNV09MjI1O2VbMTA2XT0yMjQ7ZVsxMDddPTIyNjtlWzEwOF09MjI4O2VbMTA5XT0yMjc7ZVsxMTBdPTIyOTtlWzExMV09MjMxO2VbMTEyXT0yMzM7ZVsxMTNdPTIzMjtlWzExNF09MjM0O2VbMTE1XT0yMzU7ZVsxMTZdPTIzNztlWzExN109MjM2O2VbMTE4XT0yMzg7ZVsxMTldPTIzOTtlWzEyMF09MjQxO2VbMTIxXT0yNDM7ZVsxMjJdPTI0MjtlWzEyM109MjQ0O2VbMTI0XT0yNDY7ZVsxMjVdPTI0NTtlWzEyNl09MjUwO2VbMTI3XT0yNDk7ZVsxMjhdPTI1MTtlWzEyOV09MjUyO2VbMTMwXT04MjI0O2VbMTMxXT0xNzY7ZVsxMzJdPTE2MjtlWzEzM109MTYzO2VbMTM0XT0xNjc7ZVsxMzVdPTgyMjY7ZVsxMzZdPTE4MjtlWzEzN109MjIzO2VbMTM4XT0xNzQ7ZVsxMzldPTE2OTtlWzE0MF09ODQ4MjtlWzE0MV09MTgwO2VbMTQyXT0xNjg7ZVsxNDNdPTg4MDA7ZVsxNDRdPTE5ODtlWzE0NV09MjE2O2VbMTQ2XT04NzM0O2VbMTQ3XT0xNzc7ZVsxNDhdPTg4MDQ7ZVsxNDldPTg4MDU7ZVsxNTBdPTE2NTtlWzE1MV09MTgxO2VbMTUyXT04NzA2O2VbMTUzXT04NzIxO2VbMTU0XT04NzE5O2VbMTU2XT04NzQ3O2VbMTU3XT0xNzA7ZVsxNThdPTE4NjtlWzE1OV09ODQ4NjtlWzE2MF09MjMwO2VbMTYxXT0yNDg7ZVsxNjJdPTE5MTtlWzE2M109MTYxO2VbMTY0XT0xNzI7ZVsxNjVdPTg3MzA7ZVsxNjZdPTQwMjtlWzE2N109ODc3NjtlWzE2OF09ODcxMDtlWzE2OV09MTcxO2VbMTcwXT0xODc7ZVsxNzFdPTgyMzA7ZVsxNzldPTgyMjA7ZVsxODBdPTgyMjE7ZVsxODFdPTgyMTY7ZVsxODJdPTgyMTc7ZVsyMDBdPTE5MztlWzIwM109MjA1O2VbMjA3XT0yMTE7ZVsyMTBdPTIxODtlWzIyM109NzExO2VbMjI0XT0zMjE7ZVsyMjVdPTMyMjtlWzIyNl09MzUyO2VbMjI3XT0zNTM7ZVsyMjhdPTM4MTtlWzIyOV09MzgyO2VbMjMzXT0yMjE7ZVsyMzRdPTI1MztlWzI1Ml09MjYzO2VbMjUzXT0yNjg7ZVsyNTRdPTI2OTtlWzI1OF09MjU4O2VbMjYwXT0yNjA7ZVsyNjFdPTI2MTtlWzI2NV09MjgwO2VbMjY2XT0yODE7ZVsyNjddPTI4MjtlWzI2OF09MjgzO2VbMjY5XT0zMTM7ZVsyNzVdPTMyMztlWzI3Nl09MzI0O2VbMjc4XT0zMjg7ZVsyODNdPTM0NDtlWzI4NF09MzQ1O2VbMjg1XT0zNDY7ZVsyODZdPTM0NztlWzI5Ml09MzY3O2VbMjk1XT0zNzc7ZVsyOTZdPTM3ODtlWzI5OF09MzgwO2VbMzA1XT05NjM7ZVszMDZdPTk2NDtlWzMwN109OTY2O2VbMzA4XT04MjE1O2VbMzA5XT04MjUyO2VbMzEwXT04MzE5O2VbMzExXT04MzU5O2VbMzEyXT04NTkyO2VbMzEzXT04NTkzO2VbMzM3XT05NTUyO2VbNDkzXT0xMDM5O2VbNDk0XT0xMDQwO2VbNjcyXT0xNDg4O2VbNjczXT0xNDg5O2VbNjc0XT0xNDkwO2VbNjc1XT0xNDkxO2VbNjc2XT0xNDkyO2VbNjc3XT0xNDkzO2VbNjc4XT0xNDk0O2VbNjc5XT0xNDk1O2VbNjgwXT0xNDk2O2VbNjgxXT0xNDk3O2VbNjgyXT0xNDk4O2VbNjgzXT0xNDk5O2VbNjg0XT0xNTAwO2VbNjg1XT0xNTAxO2VbNjg2XT0xNTAyO2VbNjg3XT0xNTAzO2VbNjg4XT0xNTA0O2VbNjg5XT0xNTA1O2VbNjkwXT0xNTA2O2VbNjkxXT0xNTA3O2VbNjkyXT0xNTA4O2VbNjkzXT0xNTA5O2VbNjk0XT0xNTEwO2VbNjk1XT0xNTExO2VbNjk2XT0xNTEyO2VbNjk3XT0xNTEzO2VbNjk4XT0xNTE0O2VbNzA1XT0xNTI0O2VbNzA2XT04MzYyO2VbNzEwXT02NDI4ODtlWzcxMV09NjQyOTg7ZVs3NTldPTE2MTc7ZVs3NjFdPTE3NzY7ZVs3NjNdPTE3Nzg7ZVs3NzVdPTE2NTI7ZVs3NzddPTE3NjQ7ZVs3NzhdPTE3ODA7ZVs3NzldPTE3ODE7ZVs3ODBdPTE3ODI7ZVs3ODJdPTc3MTtlWzc4M109NjQ3MjY7ZVs3ODZdPTgzNjM7ZVs3ODhdPTg1MzI7ZVs3OTBdPTc2ODtlWzc5MV09NzY5O2VbNzkyXT03Njg7ZVs3OTVdPTgwMztlWzc5N109NjQzMzY7ZVs3OThdPTY0MzM3O2VbNzk5XT02NDM0MjtlWzgwMF09NjQzNDM7ZVs4MDFdPTY0MzQ0O2VbODAyXT02NDM0NTtlWzgwM109NjQzNjI7ZVs4MDRdPTY0MzYzO2VbODA1XT02NDM2NDtlWzI0MjRdPTc4MjE7ZVsyNDI1XT03ODIyO2VbMjQyNl09NzgyMztlWzI0MjddPTc4MjQ7ZVsyNDI4XT03ODI1O2VbMjQyOV09NzgyNjtlWzI0MzBdPTc4Mjc7ZVsyNDMzXT03NjgyO2VbMjY3OF09ODA0NTtlWzI2NzldPTgwNDY7ZVsyODMwXT0xNTUyO2VbMjgzOF09Njg2O2VbMjg0MF09NzUxO2VbMjg0Ml09NzUzO2VbMjg0M109NzU0O2VbMjg0NF09NzU1O2VbMjg0Nl09NzU3O2VbMjg1Nl09NzY3O2VbMjg1N109ODQ4O2VbMjg1OF09ODQ5O2VbMjg2Ml09ODUzO2VbMjg2M109ODU0O2VbMjg2NF09ODU1O2VbMjg2NV09ODYxO2VbMjg2Nl09ODYyO2VbMjkwNl09NzQ2MDtlWzI5MDhdPTc0NjI7ZVsyOTA5XT03NDYzO2VbMjkxMF09NzQ2NDtlWzI5MTJdPTc0NjY7ZVsyOTEzXT03NDY3O2VbMjkxNF09NzQ2ODtlWzI5MTZdPTc0NzA7ZVsyOTE3XT03NDcxO2VbMjkxOF09NzQ3MjtlWzI5MjBdPTc0NzQ7ZVsyOTIxXT03NDc1O2VbMjkyMl09NzQ3NjtlWzI5MjRdPTc0Nzg7ZVsyOTI1XT03NDc5O2VbMjkyNl09NzQ4MDtlWzI5MjhdPTc0ODI7ZVsyOTI5XT03NDgzO2VbMjkzMF09NzQ4NDtlWzI5MzJdPTc0ODY7ZVsyOTMzXT03NDg3O2VbMjkzNF09NzQ4ODtlWzI5MzZdPTc0OTA7ZVsyOTM3XT03NDkxO2VbMjkzOF09NzQ5MjtlWzI5NDBdPTc0OTQ7ZVsyOTQxXT03NDk1O2VbMjk0Ml09NzQ5NjtlWzI5NDRdPTc0OTg7ZVsyOTQ2XT03NTAwO2VbMjk0OF09NzUwMjtlWzI5NTBdPTc1MDQ7ZVsyOTUxXT03NTA1O2VbMjk1Ml09NzUwNjtlWzI5NTRdPTc1MDg7ZVsyOTU1XT03NTA5O2VbMjk1Nl09NzUxMDtlWzI5NThdPTc1MTI7ZVsyOTU5XT03NTEzO2VbMjk2MF09NzUxNDtlWzI5NjJdPTc1MTY7ZVsyOTYzXT03NTE3O2VbMjk2NF09NzUxODtlWzI5NjZdPTc1MjA7ZVsyOTY3XT03NTIxO2VbMjk2OF09NzUyMjtlWzI5NzBdPTc1MjQ7ZVsyOTcxXT03NTI1O2VbMjk3Ml09NzUyNjtlWzI5NzRdPTc1Mjg7ZVsyOTc1XT03NTI5O2VbMjk3Nl09NzUzMDtlWzI5NzhdPTE1Mzc7ZVsyOTc5XT0xNTM4O2VbMjk4MF09MTUzOTtlWzI5ODJdPTE1NDk7ZVsyOTgzXT0xNTUxO2VbMjk4NF09MTU1MjtlWzI5ODZdPTE1NTQ7ZVsyOTg3XT0xNTU1O2VbMjk4OF09MTU1NjtlWzI5OTBdPTE2MjM7ZVsyOTkxXT0xNjI0O2VbMjk5NV09MTc3NTtlWzI5OTldPTE3OTE7ZVszMDAyXT02NDI5MDtlWzMwMDNdPTY0MjkxO2VbMzAwNF09NjQyOTI7ZVszMDA2XT02NDI5NDtlWzMwMDddPTY0Mjk1O2VbMzAwOF09NjQyOTY7ZVszMDExXT0xOTAwO2VbMzAxNF09ODIyMztlWzMwMTVdPTgyNDQ7ZVszMDE3XT03NTMyO2VbMzAxOF09NzUzMztlWzMwMTldPTc1MzQ7ZVszMDc1XT03NTkwO2VbMzA3Nl09NzU5MTtlWzMwNzldPTc1OTQ7ZVszMDgwXT03NTk1O2VbMzA4M109NzU5ODtlWzMwODRdPTc1OTk7ZVszMDg3XT03NjAyO2VbMzA4OF09NzYwMztlWzMwOTFdPTc2MDY7ZVszMDkyXT03NjA3O2VbMzA5NV09NzYxMDtlWzMwOTZdPTc2MTE7ZVszMDk5XT03NjE0O2VbMzEwMF09NzYxNTtlWzMxMDNdPTc2MTg7ZVszMTA0XT03NjE5O2VbMzEwN109ODMzNztlWzMxMDhdPTgzMzg7ZVszMTE2XT0xODg0O2VbMzExOV09MTg4NTtlWzMxMjBdPTE4ODU7ZVszMTIzXT0xODg2O2VbMzEyNF09MTg4NjtlWzMxMjddPTE4ODc7ZVszMTI4XT0xODg3O2VbMzEzMV09MTg4ODtlWzMxMzJdPTE4ODg7ZVszMTM1XT0xODg5O2VbMzEzNl09MTg4OTtlWzMxMzldPTE4OTA7ZVszMTQwXT0xODkwO2VbMzE0M109MTg5MTtlWzMxNDRdPTE4OTE7ZVszMTQ3XT0xODkyO2VbMzE0OF09MTg5MjtlWzMxNTNdPTU4MDtlWzMxNTRdPTU4MTtlWzMxNTddPTU4NDtlWzMxNThdPTU4NTtlWzMxNjFdPTU4ODtlWzMxNjJdPTU4OTtlWzMxNjVdPTg5MTtlWzMxNjZdPTg5MjtlWzMxNjldPTEyNzQ7ZVszMTcwXT0xMjc1O2VbMzE3M109MTI3ODtlWzMxNzRdPTEyNzk7ZVszMTgxXT03NjIyO2VbMzE4Ml09NzYyMztlWzMyODJdPTExNzk5O2VbMzMxNl09NTc4O2VbMzM3OV09NDI3ODU7ZVszMzkzXT0xMTU5O2VbMzQxNl09ODM3N30pKSx6aT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2VbMjI3XT0zMjI7ZVsyNjRdPTI2MTtlWzI5MV09MzQ2fSkpLF9pPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZVsxXT0zMjtlWzRdPTY1O2VbNV09MTkyO2VbNl09MTkzO2VbOV09MTk2O2VbMTddPTY2O2VbMThdPTY3O2VbMjFdPTI2ODtlWzI0XT02ODtlWzI4XT02OTtlWzI5XT0yMDA7ZVszMF09MjAxO2VbMzJdPTI4MjtlWzM4XT03MDtlWzM5XT03MTtlWzQ0XT03MjtlWzQ3XT03MztlWzQ4XT0yMDQ7ZVs0OV09MjA1O2VbNThdPTc0O2VbNjBdPTc1O2VbNjJdPTc2O2VbNjhdPTc3O2VbNjldPTc4O2VbNzVdPTc5O2VbNzZdPTIxMDtlWzgwXT0yMTQ7ZVs4N109ODA7ZVs4OV09ODE7ZVs5MF09ODI7ZVs5Ml09MzQ0O2VbOTRdPTgzO2VbOTddPTM1MjtlWzEwMF09ODQ7ZVsxMDRdPTg1O2VbMTA5XT0yMjA7ZVsxMTVdPTg2O2VbMTE2XT04NztlWzEyMV09ODg7ZVsxMjJdPTg5O2VbMTI0XT0yMjE7ZVsxMjddPTkwO2VbMTI5XT0zODE7ZVsyNThdPTk3O2VbMjU5XT0yMjQ7ZVsyNjBdPTIyNTtlWzI2M109MjI4O2VbMjY4XT0yNjE7ZVsyNzFdPTk4O2VbMjcyXT05OTtlWzI3M109MjYzO2VbMjc1XT0yNjk7ZVsyODJdPTEwMDtlWzI4Nl09MTAxO2VbMjg3XT0yMzI7ZVsyODhdPTIzMztlWzI5MF09MjgzO2VbMjk1XT0yODE7ZVsyOTZdPTEwMjtlWzMzNl09MTAzO2VbMzQ2XT0xMDQ7ZVszNDldPTEwNTtlWzM1MF09MjM2O2VbMzUxXT0yMzc7ZVszNjFdPTEwNjtlWzM2NF09MTA3O2VbMzY3XT0xMDg7ZVszNzFdPTMyMjtlWzM3M109MTA5O2VbMzc0XT0xMTA7ZVszODFdPTExMTtlWzM4Ml09MjQyO2VbMzgzXT0yNDM7ZVszODZdPTI0NjtlWzM5M109MTEyO2VbMzk1XT0xMTM7ZVszOTZdPTExNDtlWzM5OF09MzQ1O2VbNDAwXT0xMTU7ZVs0MDFdPTM0NztlWzQwM109MzUzO2VbNDEwXT0xMTY7ZVs0MzddPTExNztlWzQ0Ml09MjUyO2VbNDQ4XT0xMTg7ZVs0NDldPTExOTtlWzQ1NF09MTIwO2VbNDU1XT0xMjE7ZVs0NTddPTI1MztlWzQ2MF09MTIyO2VbNDYyXT0zODI7ZVs0NjNdPTM4MDtlWzg1M109NDQ7ZVs4NTVdPTU4O2VbODU2XT00NjtlWzg3Nl09NDc7ZVs4NzhdPTQ1O2VbODgyXT00NTtlWzg5NF09NDA7ZVs4OTVdPTQxO2VbODk2XT05MTtlWzg5N109OTM7ZVs5MjNdPTY0O2VbMTAwNF09NDg7ZVsxMDA1XT00OTtlWzEwMDZdPTUwO2VbMTAwN109NTE7ZVsxMDA4XT01MjtlWzEwMDldPTUzO2VbMTAxMF09NTQ7ZVsxMDExXT01NTtlWzEwMTJdPTU2O2VbMTAxM109NTc7ZVsxMDgxXT0zNztlWzEwODVdPTQzO2VbMTA4Nl09NDV9KSk7ZnVuY3Rpb24gZ2V0U3RhbmRhcmRGb250TmFtZShlKXtjb25zdCB0PW5vcm1hbGl6ZUZvbnROYW1lKGUpO3JldHVybiBQaSgpW3RdfWZ1bmN0aW9uIGlzS25vd25Gb250TmFtZShlKXtjb25zdCB0PW5vcm1hbGl6ZUZvbnROYW1lKGUpO3JldHVybiEhKFBpKClbdF18fGppKClbdF18fFhpKClbdF18fFppKClbdF0pfWNsYXNzIFRvVW5pY29kZU1hcHtjb25zdHJ1Y3RvcihlPVtdKXt0aGlzLl9tYXA9ZX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX21hcC5sZW5ndGh9Zm9yRWFjaChlKXtmb3IoY29uc3QgdCBpbiB0aGlzLl9tYXApZSh0LHRoaXMuX21hcFt0XS5jaGFyQ29kZUF0KDApKX1oYXMoZSl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX21hcFtlXX1nZXQoZSl7cmV0dXJuIHRoaXMuX21hcFtlXX1jaGFyQ29kZU9mKGUpe2NvbnN0IHQ9dGhpcy5fbWFwO2lmKHQubGVuZ3RoPD02NTUzNilyZXR1cm4gdC5pbmRleE9mKGUpO2Zvcihjb25zdCBpIGluIHQpaWYodFtpXT09PWUpcmV0dXJuIDB8aTtyZXR1cm4tMX1hbWVuZChlKXtmb3IoY29uc3QgdCBpbiBlKXRoaXMuX21hcFt0XT1lW3RdfX1jbGFzcyBJZGVudGl0eVRvVW5pY29kZU1hcHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuZmlyc3RDaGFyPWU7dGhpcy5sYXN0Q2hhcj10fWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5sYXN0Q2hhcisxLXRoaXMuZmlyc3RDaGFyfWZvckVhY2goZSl7Zm9yKGxldCB0PXRoaXMuZmlyc3RDaGFyLGk9dGhpcy5sYXN0Q2hhcjt0PD1pO3QrKyllKHQsdCl9aGFzKGUpe3JldHVybiB0aGlzLmZpcnN0Q2hhcjw9ZSYmZTw9dGhpcy5sYXN0Q2hhcn1nZXQoZSl7aWYodGhpcy5maXJzdENoYXI8PWUmJmU8PXRoaXMubGFzdENoYXIpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZSl9Y2hhckNvZGVPZihlKXtyZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihlKSYmZT49dGhpcy5maXJzdENoYXImJmU8PXRoaXMubGFzdENoYXI/ZTotMX1hbWVuZChlKXt1bnJlYWNoYWJsZSgiU2hvdWxkIG5vdCBjYWxsIGFtZW5kKCkiKX19Y2xhc3MgQ0ZGRm9udHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMucHJvcGVydGllcz10O2NvbnN0IGk9bmV3IENGRlBhcnNlcihlLHQsWWkpO3RoaXMuY2ZmPWkucGFyc2UoKTt0aGlzLmNmZi5kdXBsaWNhdGVGaXJzdEdseXBoKCk7Y29uc3QgYT1uZXcgQ0ZGQ29tcGlsZXIodGhpcy5jZmYpO3RoaXMuc2VhY3M9dGhpcy5jZmYuc2VhY3M7dHJ5e3RoaXMuZGF0YT1hLmNvbXBpbGUoKX1jYXRjaHt3YXJuKCJGYWlsZWQgdG8gY29tcGlsZSBmb250ICIrdC5sb2FkZWROYW1lKTt0aGlzLmRhdGE9ZX10aGlzLl9jcmVhdGVCdWlsdEluRW5jb2RpbmcoKX1nZXQgbnVtR2x5cGhzKCl7cmV0dXJuIHRoaXMuY2ZmLmNoYXJTdHJpbmdzLmNvdW50fWdldENoYXJzZXQoKXtyZXR1cm4gdGhpcy5jZmYuY2hhcnNldC5jaGFyc2V0fWdldEdseXBoTWFwcGluZygpe2NvbnN0IGU9dGhpcy5jZmYsdD10aGlzLnByb3BlcnRpZXMse2NpZFRvR2lkTWFwOmksY01hcDphfT10LHM9ZS5jaGFyc2V0LmNoYXJzZXQ7bGV0IHIsbjtpZih0LmNvbXBvc2l0ZSl7bGV0IHQsbztpZihpPy5sZW5ndGg+MCl7dD1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihsZXQgZT0wLGE9aS5sZW5ndGg7ZTxhO2UrKyl7Y29uc3QgYT1pW2VdO3ZvaWQgMCE9PWEmJih0W2FdPWUpfX1yPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoZS5pc0NJREZvbnQpZm9yKG49MDtuPHMubGVuZ3RoO24rKyl7Y29uc3QgZT1zW25dO289YS5jaGFyQ29kZU9mKGUpO3ZvaWQgMCE9PXQ/LltvXSYmKG89dFtvXSk7cltvXT1ufWVsc2UgZm9yKG49MDtuPGUuY2hhclN0cmluZ3MuY291bnQ7bisrKXtvPWEuY2hhckNvZGVPZihuKTtyW29dPW59cmV0dXJuIHJ9bGV0IG89ZS5lbmNvZGluZz9lLmVuY29kaW5nLmVuY29kaW5nOm51bGw7dC5pc0ludGVybmFsRm9udCYmKG89dC5kZWZhdWx0RW5jb2RpbmcpO3I9dHlwZTFGb250R2x5cGhNYXBwaW5nKHQsbyxzKTtyZXR1cm4gcn1oYXNHbHlwaElkKGUpe3JldHVybiB0aGlzLmNmZi5oYXNHbHlwaElkKGUpfV9jcmVhdGVCdWlsdEluRW5jb2RpbmcoKXtjb25zdHtjaGFyc2V0OmUsZW5jb2Rpbmc6dH09dGhpcy5jZmY7aWYoIWV8fCF0KXJldHVybjtjb25zdCBpPWUuY2hhcnNldCxhPXQuZW5jb2Rpbmcscz1bXTtmb3IoY29uc3QgZSBpbiBhKXtjb25zdCB0PWFbZV07aWYodD49MCl7Y29uc3QgYT1pW3RdO2EmJihzW2VdPWEpfX1zLmxlbmd0aD4wJiYodGhpcy5wcm9wZXJ0aWVzLmJ1aWx0SW5FbmNvZGluZz1zKX19ZnVuY3Rpb24gZ2V0VWludDMyKGUsdCl7cmV0dXJuKGVbdF08PDI0fGVbdCsxXTw8MTZ8ZVt0KzJdPDw4fGVbdCszXSk+Pj4wfWZ1bmN0aW9uIGdldFVpbnQxNihlLHQpe3JldHVybiBlW3RdPDw4fGVbdCsxXX1mdW5jdGlvbiBnZXRJbnQxNihlLHQpe3JldHVybihlW3RdPDwyNHxlW3QrMV08PDE2KT4+MTZ9ZnVuY3Rpb24gZ2V0SW50OChlLHQpe3JldHVybiBlW3RdPDwyND4+MjR9ZnVuY3Rpb24gZ2V0RmxvYXQyMTQoZSx0KXtyZXR1cm4gZ2V0SW50MTYoZSx0KS8xNjM4NH1mdW5jdGlvbiBnZXRTdWJyb3V0aW5lQmlhcyhlKXtjb25zdCB0PWUubGVuZ3RoO2xldCBpPTMyNzY4O3Q8MTI0MD9pPTEwNzp0PDMzOTAwJiYoaT0xMTMxKTtyZXR1cm4gaX1mdW5jdGlvbiBwYXJzZUNtYXAoZSx0LGkpe2NvbnN0IGE9MT09PWdldFVpbnQxNihlLHQrMik/Z2V0VWludDMyKGUsdCs4KTpnZXRVaW50MzIoZSx0KzE2KSxzPWdldFVpbnQxNihlLHQrYSk7bGV0IHIsbixvO2lmKDQ9PT1zKXtnZXRVaW50MTYoZSx0K2ErMik7Y29uc3QgaT1nZXRVaW50MTYoZSx0K2ErNik+PjE7bj10K2ErMTQ7cj1bXTtmb3Iobz0wO288aTtvKyssbis9MilyW29dPXtlbmQ6Z2V0VWludDE2KGUsbil9O24rPTI7Zm9yKG89MDtvPGk7bysrLG4rPTIpcltvXS5zdGFydD1nZXRVaW50MTYoZSxuKTtmb3Iobz0wO288aTtvKyssbis9MilyW29dLmlkRGVsdGE9Z2V0VWludDE2KGUsbik7Zm9yKG89MDtvPGk7bysrLG4rPTIpe2xldCB0PWdldFVpbnQxNihlLG4pO2lmKDAhPT10KXtyW29dLmlkcz1bXTtmb3IobGV0IGk9MCxhPXJbb10uZW5kLXJbb10uc3RhcnQrMTtpPGE7aSsrKXtyW29dLmlkc1tpXT1nZXRVaW50MTYoZSxuK3QpO3QrPTJ9fX1yZXR1cm4gcn1pZigxMj09PXMpe2NvbnN0IGk9Z2V0VWludDMyKGUsdCthKzEyKTtuPXQrYSsxNjtyPVtdO2ZvcihvPTA7bzxpO28rKyl7dD1nZXRVaW50MzIoZSxuKTtyLnB1c2goe3N0YXJ0OnQsZW5kOmdldFVpbnQzMihlLG4rNCksaWREZWx0YTpnZXRVaW50MzIoZSxuKzgpLXR9KTtuKz0xMn1yZXR1cm4gcn10aHJvdyBuZXcgRm9ybWF0RXJyb3IoYHVuc3VwcG9ydGVkIGNtYXA6ICR7c31gKX1mdW5jdGlvbiBwYXJzZUNmZihlLHQsaSxhKXtjb25zdCBzPW5ldyBDRkZQYXJzZXIobmV3IFN0cmVhbShlLHQsaS10KSx7fSxhKS5wYXJzZSgpO3JldHVybntnbHlwaHM6cy5jaGFyU3RyaW5ncy5vYmplY3RzLHN1YnJzOnMudG9wRGljdC5wcml2YXRlRGljdD8uc3VicnNJbmRleD8ub2JqZWN0cyxnc3VicnM6cy5nbG9iYWxTdWJySW5kZXg/Lm9iamVjdHMsaXNDRkZDSURGb250OnMuaXNDSURGb250LGZkU2VsZWN0OnMuZmRTZWxlY3QsZmRBcnJheTpzLmZkQXJyYXl9fWZ1bmN0aW9uIGxvb2t1cENtYXAoZSx0KXtjb25zdCBpPXQuY29kZVBvaW50QXQoMCk7bGV0IGE9MCxzPTAscj1lLmxlbmd0aC0xO2Zvcig7czxyOyl7Y29uc3QgdD1zK3IrMT4+MTtpPGVbdF0uc3RhcnQ/cj10LTE6cz10fWVbc10uc3RhcnQ8PWkmJmk8PWVbc10uZW5kJiYoYT1lW3NdLmlkRGVsdGErKGVbc10uaWRzP2Vbc10uaWRzW2ktZVtzXS5zdGFydF06aSkmNjU1MzUpO3JldHVybntjaGFyQ29kZTppLGdseXBoSWQ6YX19ZnVuY3Rpb24gY29tcGlsZUdseWYoZSx0LGkpe2Z1bmN0aW9uIG1vdmVUbyhlLGkpe3QuYWRkKEN0LFtlLGldKX1mdW5jdGlvbiBsaW5lVG8oZSxpKXt0LmFkZChodCxbZSxpXSl9ZnVuY3Rpb24gcXVhZHJhdGljQ3VydmVUbyhlLGksYSxzKXt0LmFkZChsdCxbZSxpLGEsc10pfWxldCBhPTA7Y29uc3Qgcz1nZXRJbnQxNihlLGEpO2xldCByLG49MCxvPTA7YSs9MTA7aWYoczwwKWRve3I9Z2V0VWludDE2KGUsYSk7Y29uc3Qgcz1nZXRVaW50MTYoZSxhKzIpO2ErPTQ7bGV0IGcsYztpZigxJnIpe2lmKDImcil7Zz1nZXRJbnQxNihlLGEpO2M9Z2V0SW50MTYoZSxhKzIpfWVsc2V7Zz1nZXRVaW50MTYoZSxhKTtjPWdldFVpbnQxNihlLGErMil9YSs9NH1lbHNlIGlmKDImcil7Zz1nZXRJbnQ4KGUsYSsrKTtjPWdldEludDgoZSxhKyspfWVsc2V7Zz1lW2ErK107Yz1lW2ErK119aWYoMiZyKXtuPWc7bz1jfWVsc2V7bj0wO289MH1sZXQgQz0xLGg9MSxsPTAsUT0wO2lmKDgmcil7Qz1oPWdldEZsb2F0MjE0KGUsYSk7YSs9Mn1lbHNlIGlmKDY0JnIpe0M9Z2V0RmxvYXQyMTQoZSxhKTtoPWdldEZsb2F0MjE0KGUsYSsyKTthKz00fWVsc2UgaWYoMTI4JnIpe0M9Z2V0RmxvYXQyMTQoZSxhKTtsPWdldEZsb2F0MjE0KGUsYSsyKTtRPWdldEZsb2F0MjE0KGUsYSs0KTtoPWdldEZsb2F0MjE0KGUsYSs2KTthKz04fWNvbnN0IEU9aS5nbHlwaHNbc107aWYoRSl7dC5hZGQoUXQpO3QuYWRkKHV0LFtDLGwsUSxoLG4sb10pO2NvbXBpbGVHbHlmKEUsdCxpKTt0LmFkZChCdCl9fXdoaWxlKDMyJnIpO2Vsc2V7Y29uc3QgdD1bXTtsZXQgaSxnO2ZvcihpPTA7aTxzO2krKyl7dC5wdXNoKGdldFVpbnQxNihlLGEpKTthKz0yfWErPTIrZ2V0VWludDE2KGUsYSk7Y29uc3QgYz10LmF0KC0xKSsxLEM9W107Zm9yKDtDLmxlbmd0aDxjOyl7cj1lW2ErK107bGV0IHQ9MTs4JnImJih0Kz1lW2ErK10pO2Zvcig7dC0tID4wOylDLnB1c2goe2ZsYWdzOnJ9KX1mb3IoaT0wO2k8YztpKyspe3N3aXRjaCgxOCZDW2ldLmZsYWdzKXtjYXNlIDA6bis9Z2V0SW50MTYoZSxhKTthKz0yO2JyZWFrO2Nhc2UgMjpuLT1lW2ErK107YnJlYWs7Y2FzZSAxODpuKz1lW2ErK119Q1tpXS54PW59Zm9yKGk9MDtpPGM7aSsrKXtzd2l0Y2goMzYmQ1tpXS5mbGFncyl7Y2FzZSAwOm8rPWdldEludDE2KGUsYSk7YSs9MjticmVhaztjYXNlIDQ6by09ZVthKytdO2JyZWFrO2Nhc2UgMzY6bys9ZVthKytdfUNbaV0ueT1vfWxldCBoPTA7Zm9yKGE9MDthPHM7YSsrKXtjb25zdCBlPXRbYV0scz1DLnNsaWNlKGgsZSsxKTtpZigxJnNbMF0uZmxhZ3Mpcy5wdXNoKHNbMF0pO2Vsc2UgaWYoMSZzLmF0KC0xKS5mbGFncylzLnVuc2hpZnQocy5hdCgtMSkpO2Vsc2V7Y29uc3QgZT17ZmxhZ3M6MSx4OihzWzBdLngrcy5hdCgtMSkueCkvMix5OihzWzBdLnkrcy5hdCgtMSkueSkvMn07cy51bnNoaWZ0KGUpO3MucHVzaChlKX1tb3ZlVG8oc1swXS54LHNbMF0ueSk7Zm9yKGk9MSxnPXMubGVuZ3RoO2k8ZztpKyspaWYoMSZzW2ldLmZsYWdzKWxpbmVUbyhzW2ldLngsc1tpXS55KTtlbHNlIGlmKDEmc1tpKzFdLmZsYWdzKXtxdWFkcmF0aWNDdXJ2ZVRvKHNbaV0ueCxzW2ldLnksc1tpKzFdLngsc1tpKzFdLnkpO2krK31lbHNlIHF1YWRyYXRpY0N1cnZlVG8oc1tpXS54LHNbaV0ueSwoc1tpXS54K3NbaSsxXS54KS8yLChzW2ldLnkrc1tpKzFdLnkpLzIpO2g9ZSsxfX19ZnVuY3Rpb24gY29tcGlsZUNoYXJTdHJpbmcoZSx0LGksYSl7ZnVuY3Rpb24gbW92ZVRvKGUsaSl7dC5hZGQoQ3QsW2UsaV0pfWZ1bmN0aW9uIGxpbmVUbyhlLGkpe3QuYWRkKGh0LFtlLGldKX1mdW5jdGlvbiBiZXppZXJDdXJ2ZVRvKGUsaSxhLHMscixuKXt0LmFkZChjdCxbZSxpLGEscyxyLG5dKX1jb25zdCBzPVtdO2xldCByPTAsbj0wLG89MDshZnVuY3Rpb24gcGFyc2UoZSl7bGV0IGc9MDtmb3IoO2c8ZS5sZW5ndGg7KXtsZXQgYyxDLGgsbCxRLEUsdSxkLGYscD0hMSxtPWVbZysrXTtzd2l0Y2gobSl7Y2FzZSAxOmNhc2UgMzpjYXNlIDE4OmNhc2UgMjM6bys9cy5sZW5ndGg+PjE7cD0hMDticmVhaztjYXNlIDQ6bis9cy5wb3AoKTttb3ZlVG8ocixuKTtwPSEwO2JyZWFrO2Nhc2UgNTpmb3IoO3MubGVuZ3RoPjA7KXtyKz1zLnNoaWZ0KCk7bis9cy5zaGlmdCgpO2xpbmVUbyhyLG4pfWJyZWFrO2Nhc2UgNjpmb3IoO3MubGVuZ3RoPjA7KXtyKz1zLnNoaWZ0KCk7bGluZVRvKHIsbik7aWYoMD09PXMubGVuZ3RoKWJyZWFrO24rPXMuc2hpZnQoKTtsaW5lVG8ocixuKX1icmVhaztjYXNlIDc6Zm9yKDtzLmxlbmd0aD4wOyl7bis9cy5zaGlmdCgpO2xpbmVUbyhyLG4pO2lmKDA9PT1zLmxlbmd0aClicmVhaztyKz1zLnNoaWZ0KCk7bGluZVRvKHIsbil9YnJlYWs7Y2FzZSA4OmZvcig7cy5sZW5ndGg+MDspe2M9citzLnNoaWZ0KCk7aD1uK3Muc2hpZnQoKTtDPWMrcy5zaGlmdCgpO2w9aCtzLnNoaWZ0KCk7cj1DK3Muc2hpZnQoKTtuPWwrcy5zaGlmdCgpO2JlemllckN1cnZlVG8oYyxoLEMsbCxyLG4pfWJyZWFrO2Nhc2UgMTA6ZD1zLnBvcCgpO2Y9bnVsbDtpZihpLmlzQ0ZGQ0lERm9udCl7Y29uc3QgZT1pLmZkU2VsZWN0LmdldEZESW5kZXgoYSk7aWYoZT49MCYmZTxpLmZkQXJyYXkubGVuZ3RoKXtjb25zdCB0PWkuZmRBcnJheVtlXTtsZXQgYTt0LnByaXZhdGVEaWN0Py5zdWJyc0luZGV4JiYoYT10LnByaXZhdGVEaWN0LnN1YnJzSW5kZXgub2JqZWN0cyk7aWYoYSl7ZCs9Z2V0U3Vicm91dGluZUJpYXMoYSk7Zj1hW2RdfX1lbHNlIHdhcm4oIkludmFsaWQgZmQgaW5kZXggZm9yIGdseXBoIGluZGV4LiIpfWVsc2UgZj1pLnN1YnJzW2QraS5zdWJyc0JpYXNdO2YmJnBhcnNlKGYpO2JyZWFrO2Nhc2UgMTE6cmV0dXJuO2Nhc2UgMTI6bT1lW2crK107c3dpdGNoKG0pe2Nhc2UgMzQ6Yz1yK3Muc2hpZnQoKTtDPWMrcy5zaGlmdCgpO1E9bitzLnNoaWZ0KCk7cj1DK3Muc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKGMsbixDLFEscixRKTtjPXIrcy5zaGlmdCgpO0M9YytzLnNoaWZ0KCk7cj1DK3Muc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKGMsUSxDLG4scixuKTticmVhaztjYXNlIDM1OmM9citzLnNoaWZ0KCk7aD1uK3Muc2hpZnQoKTtDPWMrcy5zaGlmdCgpO2w9aCtzLnNoaWZ0KCk7cj1DK3Muc2hpZnQoKTtuPWwrcy5zaGlmdCgpO2JlemllckN1cnZlVG8oYyxoLEMsbCxyLG4pO2M9citzLnNoaWZ0KCk7aD1uK3Muc2hpZnQoKTtDPWMrcy5zaGlmdCgpO2w9aCtzLnNoaWZ0KCk7cj1DK3Muc2hpZnQoKTtuPWwrcy5zaGlmdCgpO2JlemllckN1cnZlVG8oYyxoLEMsbCxyLG4pO3MucG9wKCk7YnJlYWs7Y2FzZSAzNjpjPXIrcy5zaGlmdCgpO1E9bitzLnNoaWZ0KCk7Qz1jK3Muc2hpZnQoKTtFPVErcy5zaGlmdCgpO3I9QytzLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhjLFEsQyxFLHIsRSk7Yz1yK3Muc2hpZnQoKTtDPWMrcy5zaGlmdCgpO3U9RStzLnNoaWZ0KCk7cj1DK3Muc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKGMsRSxDLHUscixuKTticmVhaztjYXNlIDM3OmNvbnN0IGU9cix0PW47Yz1yK3Muc2hpZnQoKTtoPW4rcy5zaGlmdCgpO0M9YytzLnNoaWZ0KCk7bD1oK3Muc2hpZnQoKTtyPUMrcy5zaGlmdCgpO249bCtzLnNoaWZ0KCk7YmV6aWVyQ3VydmVUbyhjLGgsQyxsLHIsbik7Yz1yK3Muc2hpZnQoKTtoPW4rcy5zaGlmdCgpO0M9YytzLnNoaWZ0KCk7bD1oK3Muc2hpZnQoKTtyPUM7bj1sO01hdGguYWJzKHItZSk+TWF0aC5hYnMobi10KT9yKz1zLnNoaWZ0KCk6bis9cy5zaGlmdCgpO2JlemllckN1cnZlVG8oYyxoLEMsbCxyLG4pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEZvcm1hdEVycm9yKGB1bmtub3duIG9wZXJhdG9yOiAxMiAke219YCl9YnJlYWs7Y2FzZSAxNDppZihzLmxlbmd0aD49NCl7Y29uc3QgZT1zLnBvcCgpLGE9cy5wb3AoKTtuPXMucG9wKCk7cj1zLnBvcCgpO3QuYWRkKFF0KTt0LmFkZChkdCxbcixuXSk7bGV0IG89bG9va3VwQ21hcChpLmNtYXAsU3RyaW5nLmZyb21DaGFyQ29kZShpLmdseXBoTmFtZU1hcFtmaVtlXV0pKTtjb21waWxlQ2hhclN0cmluZyhpLmdseXBoc1tvLmdseXBoSWRdLHQsaSxvLmdseXBoSWQpO3QuYWRkKEJ0KTtvPWxvb2t1cENtYXAoaS5jbWFwLFN0cmluZy5mcm9tQ2hhckNvZGUoaS5nbHlwaE5hbWVNYXBbZmlbYV1dKSk7Y29tcGlsZUNoYXJTdHJpbmcoaS5nbHlwaHNbby5nbHlwaElkXSx0LGksby5nbHlwaElkKX1yZXR1cm47Y2FzZSAxOTpjYXNlIDIwOm8rPXMubGVuZ3RoPj4xO2crPW8rNz4+MztwPSEwO2JyZWFrO2Nhc2UgMjE6bis9cy5wb3AoKTtyKz1zLnBvcCgpO21vdmVUbyhyLG4pO3A9ITA7YnJlYWs7Y2FzZSAyMjpyKz1zLnBvcCgpO21vdmVUbyhyLG4pO3A9ITA7YnJlYWs7Y2FzZSAyNDpmb3IoO3MubGVuZ3RoPjI7KXtjPXIrcy5zaGlmdCgpO2g9bitzLnNoaWZ0KCk7Qz1jK3Muc2hpZnQoKTtsPWgrcy5zaGlmdCgpO3I9QytzLnNoaWZ0KCk7bj1sK3Muc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKGMsaCxDLGwscixuKX1yKz1zLnNoaWZ0KCk7bis9cy5zaGlmdCgpO2xpbmVUbyhyLG4pO2JyZWFrO2Nhc2UgMjU6Zm9yKDtzLmxlbmd0aD42Oyl7cis9cy5zaGlmdCgpO24rPXMuc2hpZnQoKTtsaW5lVG8ocixuKX1jPXIrcy5zaGlmdCgpO2g9bitzLnNoaWZ0KCk7Qz1jK3Muc2hpZnQoKTtsPWgrcy5zaGlmdCgpO3I9QytzLnNoaWZ0KCk7bj1sK3Muc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKGMsaCxDLGwscixuKTticmVhaztjYXNlIDI2OnMubGVuZ3RoJTImJihyKz1zLnNoaWZ0KCkpO2Zvcig7cy5sZW5ndGg+MDspe2M9cjtoPW4rcy5zaGlmdCgpO0M9YytzLnNoaWZ0KCk7bD1oK3Muc2hpZnQoKTtyPUM7bj1sK3Muc2hpZnQoKTtiZXppZXJDdXJ2ZVRvKGMsaCxDLGwscixuKX1icmVhaztjYXNlIDI3OnMubGVuZ3RoJTImJihuKz1zLnNoaWZ0KCkpO2Zvcig7cy5sZW5ndGg+MDspe2M9citzLnNoaWZ0KCk7aD1uO0M9YytzLnNoaWZ0KCk7bD1oK3Muc2hpZnQoKTtyPUMrcy5zaGlmdCgpO249bDtiZXppZXJDdXJ2ZVRvKGMsaCxDLGwscixuKX1icmVhaztjYXNlIDI4OnMucHVzaCgoZVtnXTw8MjR8ZVtnKzFdPDwxNik+PjE2KTtnKz0yO2JyZWFrO2Nhc2UgMjk6ZD1zLnBvcCgpK2kuZ3N1YnJzQmlhcztmPWkuZ3N1YnJzW2RdO2YmJnBhcnNlKGYpO2JyZWFrO2Nhc2UgMzA6Zm9yKDtzLmxlbmd0aD4wOyl7Yz1yO2g9bitzLnNoaWZ0KCk7Qz1jK3Muc2hpZnQoKTtsPWgrcy5zaGlmdCgpO3I9QytzLnNoaWZ0KCk7bj1sKygxPT09cy5sZW5ndGg/cy5zaGlmdCgpOjApO2JlemllckN1cnZlVG8oYyxoLEMsbCxyLG4pO2lmKDA9PT1zLmxlbmd0aClicmVhaztjPXIrcy5zaGlmdCgpO2g9bjtDPWMrcy5zaGlmdCgpO2w9aCtzLnNoaWZ0KCk7bj1sK3Muc2hpZnQoKTtyPUMrKDE9PT1zLmxlbmd0aD9zLnNoaWZ0KCk6MCk7YmV6aWVyQ3VydmVUbyhjLGgsQyxsLHIsbil9YnJlYWs7Y2FzZSAzMTpmb3IoO3MubGVuZ3RoPjA7KXtjPXIrcy5zaGlmdCgpO2g9bjtDPWMrcy5zaGlmdCgpO2w9aCtzLnNoaWZ0KCk7bj1sK3Muc2hpZnQoKTtyPUMrKDE9PT1zLmxlbmd0aD9zLnNoaWZ0KCk6MCk7YmV6aWVyQ3VydmVUbyhjLGgsQyxsLHIsbik7aWYoMD09PXMubGVuZ3RoKWJyZWFrO2M9cjtoPW4rcy5zaGlmdCgpO0M9YytzLnNoaWZ0KCk7bD1oK3Muc2hpZnQoKTtyPUMrcy5zaGlmdCgpO249bCsoMT09PXMubGVuZ3RoP3Muc2hpZnQoKTowKTtiZXppZXJDdXJ2ZVRvKGMsaCxDLGwscixuKX1icmVhaztkZWZhdWx0OmlmKG08MzIpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGB1bmtub3duIG9wZXJhdG9yOiAke219YCk7aWYobTwyNDcpcy5wdXNoKG0tMTM5KTtlbHNlIGlmKG08MjUxKXMucHVzaCgyNTYqKG0tMjQ3KStlW2crK10rMTA4KTtlbHNlIGlmKG08MjU1KXMucHVzaCgyNTYqLShtLTI1MSktZVtnKytdLTEwOCk7ZWxzZXtzLnB1c2goKGVbZ108PDI0fGVbZysxXTw8MTZ8ZVtnKzJdPDw4fGVbZyszXSkvNjU1MzYpO2crPTR9fXAmJihzLmxlbmd0aD0wKX19KGUpfWNvbnN0ICRpPVtdO2NsYXNzIENvbW1hbmRze2NtZHM9W107YWRkKGUsdCl7aWYodClpZihpc051bWJlckFycmF5KHQsbnVsbCkpdGhpcy5jbWRzLnB1c2goZSwuLi50KTtlbHNle3dhcm4oYENvbW1hbmRzLmFkZCAtICIke2V9IiBoYXMgYXQgbGVhc3Qgb25lIG5vbi1udW1iZXIgYXJnOiAiJHt0fSIuYCk7Y29uc3QgaT10Lm1hcCgoZT0+Im51bWJlciI9PXR5cGVvZiBlP2U6MCkpO3RoaXMuY21kcy5wdXNoKGUsLi4uaSl9ZWxzZSB0aGlzLmNtZHMucHVzaChlKX19Y2xhc3MgQ29tcGlsZWRGb250e2NvbnN0cnVjdG9yKGUpe3RoaXMuY29uc3RydWN0b3I9PT1Db21waWxlZEZvbnQmJnVucmVhY2hhYmxlKCJDYW5ub3QgaW5pdGlhbGl6ZSBDb21waWxlZEZvbnQuIik7dGhpcy5mb250TWF0cml4PWU7dGhpcy5jb21waWxlZEdseXBocz1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuY29tcGlsZWRDaGFyQ29kZVRvR2x5cGhJZD1PYmplY3QuY3JlYXRlKG51bGwpfWdldFBhdGhKcyhlKXtjb25zdHtjaGFyQ29kZTp0LGdseXBoSWQ6aX09bG9va3VwQ21hcCh0aGlzLmNtYXAsZSk7bGV0IGEscz10aGlzLmNvbXBpbGVkR2x5cGhzW2ldO2lmKCFzKXt0cnl7cz10aGlzLmNvbXBpbGVHbHlwaCh0aGlzLmdseXBoc1tpXSxpKX1jYXRjaChlKXtzPSRpO2E9ZX10aGlzLmNvbXBpbGVkR2x5cGhzW2ldPXN9dGhpcy5jb21waWxlZENoYXJDb2RlVG9HbHlwaElkW3RdPz89aTtpZihhKXRocm93IGE7cmV0dXJuIHN9Y29tcGlsZUdseXBoKGUsdCl7aWYoIWV8fDA9PT1lLmxlbmd0aHx8MTQ9PT1lWzBdKXJldHVybiAkaTtsZXQgaT10aGlzLmZvbnRNYXRyaXg7aWYodGhpcy5pc0NGRkNJREZvbnQpe2NvbnN0IGU9dGhpcy5mZFNlbGVjdC5nZXRGREluZGV4KHQpO2lmKGU+PTAmJmU8dGhpcy5mZEFycmF5Lmxlbmd0aCl7aT10aGlzLmZkQXJyYXlbZV0uZ2V0QnlOYW1lKCJGb250TWF0cml4Iil8fGF9ZWxzZSB3YXJuKCJJbnZhbGlkIGZkIGluZGV4IGZvciBnbHlwaCBpbmRleC4iKX1jb25zdCBzPW5ldyBDb21tYW5kcztzLmFkZChRdCk7cy5hZGQodXQsaS5zbGljZSgpKTtzLmFkZChFdCk7dGhpcy5jb21waWxlR2x5cGhJbXBsKGUscyx0KTtzLmFkZChCdCk7cmV0dXJuIHMuY21kc31jb21waWxlR2x5cGhJbXBsKCl7dW5yZWFjaGFibGUoIkNoaWxkcmVuIGNsYXNzZXMgc2hvdWxkIGltcGxlbWVudCB0aGlzLiIpfWhhc0J1aWx0UGF0aChlKXtjb25zdHtjaGFyQ29kZTp0LGdseXBoSWQ6aX09bG9va3VwQ21hcCh0aGlzLmNtYXAsZSk7cmV0dXJuIHZvaWQgMCE9PXRoaXMuY29tcGlsZWRHbHlwaHNbaV0mJnZvaWQgMCE9PXRoaXMuY29tcGlsZWRDaGFyQ29kZVRvR2x5cGhJZFt0XX19Y2xhc3MgVHJ1ZVR5cGVDb21waWxlZCBleHRlbmRzIENvbXBpbGVkRm9udHtjb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIoaXx8WzQ4OGUtNiwwLDAsNDg4ZS02LDAsMF0pO3RoaXMuZ2x5cGhzPWU7dGhpcy5jbWFwPXR9Y29tcGlsZUdseXBoSW1wbChlLHQpe2NvbXBpbGVHbHlmKGUsdCx0aGlzKX19Y2xhc3MgVHlwZTJDb21waWxlZCBleHRlbmRzIENvbXBpbGVkRm9udHtjb25zdHJ1Y3RvcihlLHQsaSxhKXtzdXBlcihpfHxbLjAwMSwwLDAsLjAwMSwwLDBdKTt0aGlzLmdseXBocz1lLmdseXBoczt0aGlzLmdzdWJycz1lLmdzdWJyc3x8W107dGhpcy5zdWJycz1lLnN1YnJzfHxbXTt0aGlzLmNtYXA9dDt0aGlzLmdseXBoTmFtZU1hcD1hfHxSaSgpO3RoaXMuZ3N1YnJzQmlhcz1nZXRTdWJyb3V0aW5lQmlhcyh0aGlzLmdzdWJycyk7dGhpcy5zdWJyc0JpYXM9Z2V0U3Vicm91dGluZUJpYXModGhpcy5zdWJycyk7dGhpcy5pc0NGRkNJREZvbnQ9ZS5pc0NGRkNJREZvbnQ7dGhpcy5mZFNlbGVjdD1lLmZkU2VsZWN0O3RoaXMuZmRBcnJheT1lLmZkQXJyYXl9Y29tcGlsZUdseXBoSW1wbChlLHQsaSl7Y29tcGlsZUNoYXJTdHJpbmcoZSx0LHRoaXMsaSl9fWNsYXNzIEZvbnRSZW5kZXJlckZhY3Rvcnl7c3RhdGljIGNyZWF0ZShlLHQpe2NvbnN0IGk9bmV3IFVpbnQ4QXJyYXkoZS5kYXRhKTtsZXQgYSxzLHIsbixvLGc7Y29uc3QgYz1nZXRVaW50MTYoaSw0KTtmb3IobGV0IGU9MCxDPTEyO2U8YztlKyssQys9MTYpe2NvbnN0IGU9Ynl0ZXNUb1N0cmluZyhpLnN1YmFycmF5KEMsQys0KSksYz1nZXRVaW50MzIoaSxDKzgpLGg9Z2V0VWludDMyKGksQysxMik7c3dpdGNoKGUpe2Nhc2UiY21hcCI6YT1wYXJzZUNtYXAoaSxjKTticmVhaztjYXNlImdseWYiOnM9aS5zdWJhcnJheShjLGMraCk7YnJlYWs7Y2FzZSJsb2NhIjpyPWkuc3ViYXJyYXkoYyxjK2gpO2JyZWFrO2Nhc2UiaGVhZCI6Zz1nZXRVaW50MTYoaSxjKzE4KTtvPWdldFVpbnQxNihpLGMrNTApO2JyZWFrO2Nhc2UiQ0ZGICI6bj1wYXJzZUNmZihpLGMsYytoLHQpfX1pZihzKXtjb25zdCB0PWc/WzEvZywwLDAsMS9nLDAsMF06ZS5mb250TWF0cml4O3JldHVybiBuZXcgVHJ1ZVR5cGVDb21waWxlZChmdW5jdGlvbiBwYXJzZUdseWZUYWJsZShlLHQsaSl7bGV0IGEscztpZihpKXthPTQ7cz1nZXRVaW50MzJ9ZWxzZXthPTI7cz0oZSx0KT0+MipnZXRVaW50MTYoZSx0KX1jb25zdCByPVtdO2xldCBuPXModCwwKTtmb3IobGV0IGk9YTtpPHQubGVuZ3RoO2krPWEpe2NvbnN0IGE9cyh0LGkpO3IucHVzaChlLnN1YmFycmF5KG4sYSkpO249YX1yZXR1cm4gcn0ocyxyLG8pLGEsdCl9cmV0dXJuIG5ldyBUeXBlMkNvbXBpbGVkKG4sYSxlLmZvbnRNYXRyaXgsZS5nbHlwaE5hbWVNYXApfX1jb25zdCBBYT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2UuQ291cmllcj02MDA7ZVsiQ291cmllci1Cb2xkIl09NjAwO2VbIkNvdXJpZXItQm9sZE9ibGlxdWUiXT02MDA7ZVsiQ291cmllci1PYmxpcXVlIl09NjAwO2UuSGVsdmV0aWNhPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZS5zcGFjZT0yNzg7ZS5leGNsYW09Mjc4O2UucXVvdGVkYmw9MzU1O2UubnVtYmVyc2lnbj01NTY7ZS5kb2xsYXI9NTU2O2UucGVyY2VudD04ODk7ZS5hbXBlcnNhbmQ9NjY3O2UucXVvdGVyaWdodD0yMjI7ZS5wYXJlbmxlZnQ9MzMzO2UucGFyZW5yaWdodD0zMzM7ZS5hc3Rlcmlzaz0zODk7ZS5wbHVzPTU4NDtlLmNvbW1hPTI3ODtlLmh5cGhlbj0zMzM7ZS5wZXJpb2Q9Mjc4O2Uuc2xhc2g9Mjc4O2UuemVybz01NTY7ZS5vbmU9NTU2O2UudHdvPTU1NjtlLnRocmVlPTU1NjtlLmZvdXI9NTU2O2UuZml2ZT01NTY7ZS5zaXg9NTU2O2Uuc2V2ZW49NTU2O2UuZWlnaHQ9NTU2O2UubmluZT01NTY7ZS5jb2xvbj0yNzg7ZS5zZW1pY29sb249Mjc4O2UubGVzcz01ODQ7ZS5lcXVhbD01ODQ7ZS5ncmVhdGVyPTU4NDtlLnF1ZXN0aW9uPTU1NjtlLmF0PTEwMTU7ZS5BPTY2NztlLkI9NjY3O2UuQz03MjI7ZS5EPTcyMjtlLkU9NjY3O2UuRj02MTE7ZS5HPTc3ODtlLkg9NzIyO2UuST0yNzg7ZS5KPTUwMDtlLks9NjY3O2UuTD01NTY7ZS5NPTgzMztlLk49NzIyO2UuTz03Nzg7ZS5QPTY2NztlLlE9Nzc4O2UuUj03MjI7ZS5TPTY2NztlLlQ9NjExO2UuVT03MjI7ZS5WPTY2NztlLlc9OTQ0O2UuWD02Njc7ZS5ZPTY2NztlLlo9NjExO2UuYnJhY2tldGxlZnQ9Mjc4O2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0yNzg7ZS5hc2NpaWNpcmN1bT00Njk7ZS51bmRlcnNjb3JlPTU1NjtlLnF1b3RlbGVmdD0yMjI7ZS5hPTU1NjtlLmI9NTU2O2UuYz01MDA7ZS5kPTU1NjtlLmU9NTU2O2UuZj0yNzg7ZS5nPTU1NjtlLmg9NTU2O2UuaT0yMjI7ZS5qPTIyMjtlLms9NTAwO2UubD0yMjI7ZS5tPTgzMztlLm49NTU2O2Uubz01NTY7ZS5wPTU1NjtlLnE9NTU2O2Uucj0zMzM7ZS5zPTUwMDtlLnQ9Mjc4O2UudT01NTY7ZS52PTUwMDtlLnc9NzIyO2UueD01MDA7ZS55PTUwMDtlLno9NTAwO2UuYnJhY2VsZWZ0PTMzNDtlLmJhcj0yNjA7ZS5icmFjZXJpZ2h0PTMzNDtlLmFzY2lpdGlsZGU9NTg0O2UuZXhjbGFtZG93bj0zMzM7ZS5jZW50PTU1NjtlLnN0ZXJsaW5nPTU1NjtlLmZyYWN0aW9uPTE2NztlLnllbj01NTY7ZS5mbG9yaW49NTU2O2Uuc2VjdGlvbj01NTY7ZS5jdXJyZW5jeT01NTY7ZS5xdW90ZXNpbmdsZT0xOTE7ZS5xdW90ZWRibGxlZnQ9MzMzO2UuZ3VpbGxlbW90bGVmdD01NTY7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTUwMDtlLmZsPTUwMDtlLmVuZGFzaD01NTY7ZS5kYWdnZXI9NTU2O2UuZGFnZ2VyZGJsPTU1NjtlLnBlcmlvZGNlbnRlcmVkPTI3ODtlLnBhcmFncmFwaD01Mzc7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9MjIyO2UucXVvdGVkYmxiYXNlPTMzMztlLnF1b3RlZGJscmlnaHQ9MzMzO2UuZ3VpbGxlbW90cmlnaHQ9NTU2O2UuZWxsaXBzaXM9MWUzO2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTYxMTtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9MWUzO2UuQUU9MWUzO2Uub3JkZmVtaW5pbmU9MzcwO2UuTHNsYXNoPTU1NjtlLk9zbGFzaD03Nzg7ZS5PRT0xZTM7ZS5vcmRtYXNjdWxpbmU9MzY1O2UuYWU9ODg5O2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTIyMjtlLm9zbGFzaD02MTE7ZS5vZT05NDQ7ZS5nZXJtYW5kYmxzPTYxMTtlLklkaWVyZXNpcz0yNzg7ZS5lYWN1dGU9NTU2O2UuYWJyZXZlPTU1NjtlLnVodW5nYXJ1bWxhdXQ9NTU2O2UuZWNhcm9uPTU1NjtlLllkaWVyZXNpcz02Njc7ZS5kaXZpZGU9NTg0O2UuWWFjdXRlPTY2NztlLkFjaXJjdW1mbGV4PTY2NztlLmFhY3V0ZT01NTY7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NTAwO2Uuc2NvbW1hYWNjZW50PTUwMDtlLmVjaXJjdW1mbGV4PTU1NjtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTU1NjtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTU1NjtlLkVkaWVyZXNpcz02Njc7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTczNztlLkVtYWNyb249NjY3O2UuY2Nhcm9uPTUwMDtlLmFyaW5nPTU1NjtlLk5jb21tYWFjY2VudD03MjI7ZS5sYWN1dGU9MjIyO2UuYWdyYXZlPTU1NjtlLlRjb21tYWFjY2VudD02MTE7ZS5DYWN1dGU9NzIyO2UuYXRpbGRlPTU1NjtlLkVkb3RhY2NlbnQ9NjY3O2Uuc2Nhcm9uPTUwMDtlLnNjZWRpbGxhPTUwMDtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ3MTtlLlJjYXJvbj03MjI7ZS5HY29tbWFhY2NlbnQ9Nzc4O2UudWNpcmN1bWZsZXg9NTU2O2UuYWNpcmN1bWZsZXg9NTU2O2UuQW1hY3Jvbj02Njc7ZS5yY2Fyb249MzMzO2UuY2NlZGlsbGE9NTAwO2UuWmRvdGFjY2VudD02MTE7ZS5UaG9ybj02Njc7ZS5PbWFjcm9uPTc3ODtlLlJhY3V0ZT03MjI7ZS5TYWN1dGU9NjY3O2UuZGNhcm9uPTY0MztlLlVtYWNyb249NzIyO2UudXJpbmc9NTU2O2UudGhyZWVzdXBlcmlvcj0zMzM7ZS5PZ3JhdmU9Nzc4O2UuQWdyYXZlPTY2NztlLkFicmV2ZT02Njc7ZS5tdWx0aXBseT01ODQ7ZS51YWN1dGU9NTU2O2UuVGNhcm9uPTYxMTtlLnBhcnRpYWxkaWZmPTQ3NjtlLnlkaWVyZXNpcz01MDA7ZS5OYWN1dGU9NzIyO2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjY3O2UuYWRpZXJlc2lzPTU1NjtlLmVkaWVyZXNpcz01NTY7ZS5jYWN1dGU9NTAwO2UubmFjdXRlPTU1NjtlLnVtYWNyb249NTU2O2UuTmNhcm9uPTcyMjtlLklhY3V0ZT0yNzg7ZS5wbHVzbWludXM9NTg0O2UuYnJva2VuYmFyPTI2MDtlLnJlZ2lzdGVyZWQ9NzM3O2UuR2JyZXZlPTc3ODtlLklkb3RhY2NlbnQ9Mjc4O2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02Njc7ZS5yYWN1dGU9MzMzO2Uub21hY3Jvbj01NTY7ZS5aYWN1dGU9NjExO2UuWmNhcm9uPTYxMTtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NzIyO2UubGNvbW1hYWNjZW50PTIyMjtlLnRjYXJvbj0zMTc7ZS5lb2dvbmVrPTU1NjtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTY2NztlLkFkaWVyZXNpcz02Njc7ZS5lZ3JhdmU9NTU2O2UuemFjdXRlPTUwMDtlLmlvZ29uZWs9MjIyO2UuT2FjdXRlPTc3ODtlLm9hY3V0ZT01NTY7ZS5hbWFjcm9uPTU1NjtlLnNhY3V0ZT01MDA7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9Nzc4O2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTU1NjtlLnR3b3N1cGVyaW9yPTMzMztlLk9kaWVyZXNpcz03Nzg7ZS5tdT01NTY7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD01NTY7ZS5Fb2dvbmVrPTY2NztlLmRjcm9hdD01NTY7ZS50aHJlZXF1YXJ0ZXJzPTgzNDtlLlNjZWRpbGxhPTY2NztlLmxjYXJvbj0yOTk7ZS5LY29tbWFhY2NlbnQ9NjY3O2UuTGFjdXRlPTU1NjtlLnRyYWRlbWFyaz0xZTM7ZS5lZG90YWNjZW50PTU1NjtlLklncmF2ZT0yNzg7ZS5JbWFjcm9uPTI3ODtlLkxjYXJvbj01NTY7ZS5vbmVoYWxmPTgzNDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD01NTY7ZS5udGlsZGU9NTU2O2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjY3O2UuZW1hY3Jvbj01NTY7ZS5nYnJldmU9NTU2O2Uub25lcXVhcnRlcj04MzQ7ZS5TY2Fyb249NjY3O2UuU2NvbW1hYWNjZW50PTY2NztlLk9odW5nYXJ1bWxhdXQ9Nzc4O2UuZGVncmVlPTQwMDtlLm9ncmF2ZT01NTY7ZS5DY2Fyb249NzIyO2UudWdyYXZlPTU1NjtlLnJhZGljYWw9NDUzO2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zMzM7ZS5OdGlsZGU9NzIyO2Uub3RpbGRlPTU1NjtlLlJjb21tYWFjY2VudD03MjI7ZS5MY29tbWFhY2NlbnQ9NTU2O2UuQXRpbGRlPTY2NztlLkFvZ29uZWs9NjY3O2UuQXJpbmc9NjY3O2UuT3RpbGRlPTc3ODtlLnpkb3RhY2NlbnQ9NTAwO2UuRWNhcm9uPTY2NztlLklvZ29uZWs9Mjc4O2Uua2NvbW1hYWNjZW50PTUwMDtlLm1pbnVzPTU4NDtlLkljaXJjdW1mbGV4PTI3ODtlLm5jYXJvbj01NTY7ZS50Y29tbWFhY2NlbnQ9Mjc4O2UubG9naWNhbG5vdD01ODQ7ZS5vZGllcmVzaXM9NTU2O2UudWRpZXJlc2lzPTU1NjtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD01NTY7ZS5ldGg9NTU2O2UuemNhcm9uPTUwMDtlLm5jb21tYWFjY2VudD01NTY7ZS5vbmVzdXBlcmlvcj0zMzM7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTU2fSkpO2VbIkhlbHZldGljYS1Cb2xkIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI3ODtlLmV4Y2xhbT0zMzM7ZS5xdW90ZWRibD00NzQ7ZS5udW1iZXJzaWduPTU1NjtlLmRvbGxhcj01NTY7ZS5wZXJjZW50PTg4OTtlLmFtcGVyc2FuZD03MjI7ZS5xdW90ZXJpZ2h0PTI3ODtlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTM4OTtlLnBsdXM9NTg0O2UuY29tbWE9Mjc4O2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNzg7ZS5zbGFzaD0yNzg7ZS56ZXJvPTU1NjtlLm9uZT01NTY7ZS50d289NTU2O2UudGhyZWU9NTU2O2UuZm91cj01NTY7ZS5maXZlPTU1NjtlLnNpeD01NTY7ZS5zZXZlbj01NTY7ZS5laWdodD01NTY7ZS5uaW5lPTU1NjtlLmNvbG9uPTMzMztlLnNlbWljb2xvbj0zMzM7ZS5sZXNzPTU4NDtlLmVxdWFsPTU4NDtlLmdyZWF0ZXI9NTg0O2UucXVlc3Rpb249NjExO2UuYXQ9OTc1O2UuQT03MjI7ZS5CPTcyMjtlLkM9NzIyO2UuRD03MjI7ZS5FPTY2NztlLkY9NjExO2UuRz03Nzg7ZS5IPTcyMjtlLkk9Mjc4O2UuSj01NTY7ZS5LPTcyMjtlLkw9NjExO2UuTT04MzM7ZS5OPTcyMjtlLk89Nzc4O2UuUD02Njc7ZS5RPTc3ODtlLlI9NzIyO2UuUz02Njc7ZS5UPTYxMTtlLlU9NzIyO2UuVj02Njc7ZS5XPTk0NDtlLlg9NjY3O2UuWT02Njc7ZS5aPTYxMTtlLmJyYWNrZXRsZWZ0PTMzMztlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9MzMzO2UuYXNjaWljaXJjdW09NTg0O2UudW5kZXJzY29yZT01NTY7ZS5xdW90ZWxlZnQ9Mjc4O2UuYT01NTY7ZS5iPTYxMTtlLmM9NTU2O2UuZD02MTE7ZS5lPTU1NjtlLmY9MzMzO2UuZz02MTE7ZS5oPTYxMTtlLmk9Mjc4O2Uuaj0yNzg7ZS5rPTU1NjtlLmw9Mjc4O2UubT04ODk7ZS5uPTYxMTtlLm89NjExO2UucD02MTE7ZS5xPTYxMTtlLnI9Mzg5O2Uucz01NTY7ZS50PTMzMztlLnU9NjExO2Uudj01NTY7ZS53PTc3ODtlLng9NTU2O2UueT01NTY7ZS56PTUwMDtlLmJyYWNlbGVmdD0zODk7ZS5iYXI9MjgwO2UuYnJhY2VyaWdodD0zODk7ZS5hc2NpaXRpbGRlPTU4NDtlLmV4Y2xhbWRvd249MzMzO2UuY2VudD01NTY7ZS5zdGVybGluZz01NTY7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTU2O2UuZmxvcmluPTU1NjtlLnNlY3Rpb249NTU2O2UuY3VycmVuY3k9NTU2O2UucXVvdGVzaW5nbGU9MjM4O2UucXVvdGVkYmxsZWZ0PTUwMDtlLmd1aWxsZW1vdGxlZnQ9NTU2O2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT02MTE7ZS5mbD02MTE7ZS5lbmRhc2g9NTU2O2UuZGFnZ2VyPTU1NjtlLmRhZ2dlcmRibD01NTY7ZS5wZXJpb2RjZW50ZXJlZD0yNzg7ZS5wYXJhZ3JhcGg9NTU2O2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTI3ODtlLnF1b3RlZGJsYmFzZT01MDA7ZS5xdW90ZWRibHJpZ2h0PTUwMDtlLmd1aWxsZW1vdHJpZ2h0PTU1NjtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj02MTE7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTFlMztlLm9yZGZlbWluaW5lPTM3MDtlLkxzbGFzaD02MTE7ZS5Pc2xhc2g9Nzc4O2UuT0U9MWUzO2Uub3JkbWFzY3VsaW5lPTM2NTtlLmFlPTg4OTtlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yNzg7ZS5vc2xhc2g9NjExO2Uub2U9OTQ0O2UuZ2VybWFuZGJscz02MTE7ZS5JZGllcmVzaXM9Mjc4O2UuZWFjdXRlPTU1NjtlLmFicmV2ZT01NTY7ZS51aHVuZ2FydW1sYXV0PTYxMTtlLmVjYXJvbj01NTY7ZS5ZZGllcmVzaXM9NjY3O2UuZGl2aWRlPTU4NDtlLllhY3V0ZT02Njc7ZS5BY2lyY3VtZmxleD03MjI7ZS5hYWN1dGU9NTU2O2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTU1NjtlLnNjb21tYWFjY2VudD01NTY7ZS5lY2lyY3VtZmxleD01NTY7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz01NTY7ZS5VYWN1dGU9NzIyO2UudW9nb25laz02MTE7ZS5FZGllcmVzaXM9NjY3O2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03Mzc7ZS5FbWFjcm9uPTY2NztlLmNjYXJvbj01NTY7ZS5hcmluZz01NTY7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTI3ODtlLmFncmF2ZT01NTY7ZS5UY29tbWFhY2NlbnQ9NjExO2UuQ2FjdXRlPTcyMjtlLmF0aWxkZT01NTY7ZS5FZG90YWNjZW50PTY2NztlLnNjYXJvbj01NTY7ZS5zY2VkaWxsYT01NTY7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00OTQ7ZS5SY2Fyb249NzIyO2UuR2NvbW1hYWNjZW50PTc3ODtlLnVjaXJjdW1mbGV4PTYxMTtlLmFjaXJjdW1mbGV4PTU1NjtlLkFtYWNyb249NzIyO2UucmNhcm9uPTM4OTtlLmNjZWRpbGxhPTU1NjtlLlpkb3RhY2NlbnQ9NjExO2UuVGhvcm49NjY3O2UuT21hY3Jvbj03Nzg7ZS5SYWN1dGU9NzIyO2UuU2FjdXRlPTY2NztlLmRjYXJvbj03NDM7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTYxMTtlLnRocmVlc3VwZXJpb3I9MzMzO2UuT2dyYXZlPTc3ODtlLkFncmF2ZT03MjI7ZS5BYnJldmU9NzIyO2UubXVsdGlwbHk9NTg0O2UudWFjdXRlPTYxMTtlLlRjYXJvbj02MTE7ZS5wYXJ0aWFsZGlmZj00OTQ7ZS55ZGllcmVzaXM9NTU2O2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTY2NztlLmFkaWVyZXNpcz01NTY7ZS5lZGllcmVzaXM9NTU2O2UuY2FjdXRlPTU1NjtlLm5hY3V0ZT02MTE7ZS51bWFjcm9uPTYxMTtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9Mjc4O2UucGx1c21pbnVzPTU4NDtlLmJyb2tlbmJhcj0yODA7ZS5yZWdpc3RlcmVkPTczNztlLkdicmV2ZT03Nzg7ZS5JZG90YWNjZW50PTI3ODtlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjY3O2UucmFjdXRlPTM4OTtlLm9tYWNyb249NjExO2UuWmFjdXRlPTYxMTtlLlpjYXJvbj02MTE7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTcyMjtlLmxjb21tYWFjY2VudD0yNzg7ZS50Y2Fyb249Mzg5O2UuZW9nb25laz01NTY7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT03MjI7ZS5BZGllcmVzaXM9NzIyO2UuZWdyYXZlPTU1NjtlLnphY3V0ZT01MDA7ZS5pb2dvbmVrPTI3ODtlLk9hY3V0ZT03Nzg7ZS5vYWN1dGU9NjExO2UuYW1hY3Jvbj01NTY7ZS5zYWN1dGU9NTU2O2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTc3ODtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj02MTE7ZS50d29zdXBlcmlvcj0zMzM7ZS5PZGllcmVzaXM9Nzc4O2UubXU9NjExO2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NjExO2UuRW9nb25laz02Njc7ZS5kY3JvYXQ9NjExO2UudGhyZWVxdWFydGVycz04MzQ7ZS5TY2VkaWxsYT02Njc7ZS5sY2Fyb249NDAwO2UuS2NvbW1hYWNjZW50PTcyMjtlLkxhY3V0ZT02MTE7ZS50cmFkZW1hcms9MWUzO2UuZWRvdGFjY2VudD01NTY7ZS5JZ3JhdmU9Mjc4O2UuSW1hY3Jvbj0yNzg7ZS5MY2Fyb249NjExO2Uub25laGFsZj04MzQ7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NjExO2UubnRpbGRlPTYxMTtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTY2NztlLmVtYWNyb249NTU2O2UuZ2JyZXZlPTYxMTtlLm9uZXF1YXJ0ZXI9ODM0O2UuU2Nhcm9uPTY2NztlLlNjb21tYWFjY2VudD02Njc7ZS5PaHVuZ2FydW1sYXV0PTc3ODtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NjExO2UuQ2Nhcm9uPTcyMjtlLnVncmF2ZT02MTE7ZS5yYWRpY2FsPTU0OTtlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9Mzg5O2UuTnRpbGRlPTcyMjtlLm90aWxkZT02MTE7ZS5SY29tbWFhY2NlbnQ9NzIyO2UuTGNvbW1hYWNjZW50PTYxMTtlLkF0aWxkZT03MjI7ZS5Bb2dvbmVrPTcyMjtlLkFyaW5nPTcyMjtlLk90aWxkZT03Nzg7ZS56ZG90YWNjZW50PTUwMDtlLkVjYXJvbj02Njc7ZS5Jb2dvbmVrPTI3ODtlLmtjb21tYWFjY2VudD01NTY7ZS5taW51cz01ODQ7ZS5JY2lyY3VtZmxleD0yNzg7ZS5uY2Fyb249NjExO2UudGNvbW1hYWNjZW50PTMzMztlLmxvZ2ljYWxub3Q9NTg0O2Uub2RpZXJlc2lzPTYxMTtlLnVkaWVyZXNpcz02MTE7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NjExO2UuZXRoPTYxMTtlLnpjYXJvbj01MDA7ZS5uY29tbWFhY2NlbnQ9NjExO2Uub25lc3VwZXJpb3I9MzMzO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTU1Nn0pKTtlWyJIZWx2ZXRpY2EtQm9sZE9ibGlxdWUiXT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9Mjc4O2UuZXhjbGFtPTMzMztlLnF1b3RlZGJsPTQ3NDtlLm51bWJlcnNpZ249NTU2O2UuZG9sbGFyPTU1NjtlLnBlcmNlbnQ9ODg5O2UuYW1wZXJzYW5kPTcyMjtlLnF1b3RlcmlnaHQ9Mjc4O2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9Mzg5O2UucGx1cz01ODQ7ZS5jb21tYT0yNzg7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI3ODtlLnNsYXNoPTI3ODtlLnplcm89NTU2O2Uub25lPTU1NjtlLnR3bz01NTY7ZS50aHJlZT01NTY7ZS5mb3VyPTU1NjtlLmZpdmU9NTU2O2Uuc2l4PTU1NjtlLnNldmVuPTU1NjtlLmVpZ2h0PTU1NjtlLm5pbmU9NTU2O2UuY29sb249MzMzO2Uuc2VtaWNvbG9uPTMzMztlLmxlc3M9NTg0O2UuZXF1YWw9NTg0O2UuZ3JlYXRlcj01ODQ7ZS5xdWVzdGlvbj02MTE7ZS5hdD05NzU7ZS5BPTcyMjtlLkI9NzIyO2UuQz03MjI7ZS5EPTcyMjtlLkU9NjY3O2UuRj02MTE7ZS5HPTc3ODtlLkg9NzIyO2UuST0yNzg7ZS5KPTU1NjtlLks9NzIyO2UuTD02MTE7ZS5NPTgzMztlLk49NzIyO2UuTz03Nzg7ZS5QPTY2NztlLlE9Nzc4O2UuUj03MjI7ZS5TPTY2NztlLlQ9NjExO2UuVT03MjI7ZS5WPTY2NztlLlc9OTQ0O2UuWD02Njc7ZS5ZPTY2NztlLlo9NjExO2UuYnJhY2tldGxlZnQ9MzMzO2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0zMzM7ZS5hc2NpaWNpcmN1bT01ODQ7ZS51bmRlcnNjb3JlPTU1NjtlLnF1b3RlbGVmdD0yNzg7ZS5hPTU1NjtlLmI9NjExO2UuYz01NTY7ZS5kPTYxMTtlLmU9NTU2O2UuZj0zMzM7ZS5nPTYxMTtlLmg9NjExO2UuaT0yNzg7ZS5qPTI3ODtlLms9NTU2O2UubD0yNzg7ZS5tPTg4OTtlLm49NjExO2Uubz02MTE7ZS5wPTYxMTtlLnE9NjExO2Uucj0zODk7ZS5zPTU1NjtlLnQ9MzMzO2UudT02MTE7ZS52PTU1NjtlLnc9Nzc4O2UueD01NTY7ZS55PTU1NjtlLno9NTAwO2UuYnJhY2VsZWZ0PTM4OTtlLmJhcj0yODA7ZS5icmFjZXJpZ2h0PTM4OTtlLmFzY2lpdGlsZGU9NTg0O2UuZXhjbGFtZG93bj0zMzM7ZS5jZW50PTU1NjtlLnN0ZXJsaW5nPTU1NjtlLmZyYWN0aW9uPTE2NztlLnllbj01NTY7ZS5mbG9yaW49NTU2O2Uuc2VjdGlvbj01NTY7ZS5jdXJyZW5jeT01NTY7ZS5xdW90ZXNpbmdsZT0yMzg7ZS5xdW90ZWRibGxlZnQ9NTAwO2UuZ3VpbGxlbW90bGVmdD01NTY7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTYxMTtlLmZsPTYxMTtlLmVuZGFzaD01NTY7ZS5kYWdnZXI9NTU2O2UuZGFnZ2VyZGJsPTU1NjtlLnBlcmlvZGNlbnRlcmVkPTI3ODtlLnBhcmFncmFwaD01NTY7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9Mjc4O2UucXVvdGVkYmxiYXNlPTUwMDtlLnF1b3RlZGJscmlnaHQ9NTAwO2UuZ3VpbGxlbW90cmlnaHQ9NTU2O2UuZWxsaXBzaXM9MWUzO2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTYxMTtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9MWUzO2UuQUU9MWUzO2Uub3JkZmVtaW5pbmU9MzcwO2UuTHNsYXNoPTYxMTtlLk9zbGFzaD03Nzg7ZS5PRT0xZTM7ZS5vcmRtYXNjdWxpbmU9MzY1O2UuYWU9ODg5O2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTI3ODtlLm9zbGFzaD02MTE7ZS5vZT05NDQ7ZS5nZXJtYW5kYmxzPTYxMTtlLklkaWVyZXNpcz0yNzg7ZS5lYWN1dGU9NTU2O2UuYWJyZXZlPTU1NjtlLnVodW5nYXJ1bWxhdXQ9NjExO2UuZWNhcm9uPTU1NjtlLllkaWVyZXNpcz02Njc7ZS5kaXZpZGU9NTg0O2UuWWFjdXRlPTY2NztlLkFjaXJjdW1mbGV4PTcyMjtlLmFhY3V0ZT01NTY7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NTU2O2Uuc2NvbW1hYWNjZW50PTU1NjtlLmVjaXJjdW1mbGV4PTU1NjtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTU1NjtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTYxMTtlLkVkaWVyZXNpcz02Njc7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTczNztlLkVtYWNyb249NjY3O2UuY2Nhcm9uPTU1NjtlLmFyaW5nPTU1NjtlLk5jb21tYWFjY2VudD03MjI7ZS5sYWN1dGU9Mjc4O2UuYWdyYXZlPTU1NjtlLlRjb21tYWFjY2VudD02MTE7ZS5DYWN1dGU9NzIyO2UuYXRpbGRlPTU1NjtlLkVkb3RhY2NlbnQ9NjY3O2Uuc2Nhcm9uPTU1NjtlLnNjZWRpbGxhPTU1NjtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ5NDtlLlJjYXJvbj03MjI7ZS5HY29tbWFhY2NlbnQ9Nzc4O2UudWNpcmN1bWZsZXg9NjExO2UuYWNpcmN1bWZsZXg9NTU2O2UuQW1hY3Jvbj03MjI7ZS5yY2Fyb249Mzg5O2UuY2NlZGlsbGE9NTU2O2UuWmRvdGFjY2VudD02MTE7ZS5UaG9ybj02Njc7ZS5PbWFjcm9uPTc3ODtlLlJhY3V0ZT03MjI7ZS5TYWN1dGU9NjY3O2UuZGNhcm9uPTc0MztlLlVtYWNyb249NzIyO2UudXJpbmc9NjExO2UudGhyZWVzdXBlcmlvcj0zMzM7ZS5PZ3JhdmU9Nzc4O2UuQWdyYXZlPTcyMjtlLkFicmV2ZT03MjI7ZS5tdWx0aXBseT01ODQ7ZS51YWN1dGU9NjExO2UuVGNhcm9uPTYxMTtlLnBhcnRpYWxkaWZmPTQ5NDtlLnlkaWVyZXNpcz01NTY7ZS5OYWN1dGU9NzIyO2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjY3O2UuYWRpZXJlc2lzPTU1NjtlLmVkaWVyZXNpcz01NTY7ZS5jYWN1dGU9NTU2O2UubmFjdXRlPTYxMTtlLnVtYWNyb249NjExO2UuTmNhcm9uPTcyMjtlLklhY3V0ZT0yNzg7ZS5wbHVzbWludXM9NTg0O2UuYnJva2VuYmFyPTI4MDtlLnJlZ2lzdGVyZWQ9NzM3O2UuR2JyZXZlPTc3ODtlLklkb3RhY2NlbnQ9Mjc4O2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02Njc7ZS5yYWN1dGU9Mzg5O2Uub21hY3Jvbj02MTE7ZS5aYWN1dGU9NjExO2UuWmNhcm9uPTYxMTtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NzIyO2UubGNvbW1hYWNjZW50PTI3ODtlLnRjYXJvbj0zODk7ZS5lb2dvbmVrPTU1NjtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTcyMjtlLkFkaWVyZXNpcz03MjI7ZS5lZ3JhdmU9NTU2O2UuemFjdXRlPTUwMDtlLmlvZ29uZWs9Mjc4O2UuT2FjdXRlPTc3ODtlLm9hY3V0ZT02MTE7ZS5hbWFjcm9uPTU1NjtlLnNhY3V0ZT01NTY7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9Nzc4O2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTYxMTtlLnR3b3N1cGVyaW9yPTMzMztlLk9kaWVyZXNpcz03Nzg7ZS5tdT02MTE7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD02MTE7ZS5Fb2dvbmVrPTY2NztlLmRjcm9hdD02MTE7ZS50aHJlZXF1YXJ0ZXJzPTgzNDtlLlNjZWRpbGxhPTY2NztlLmxjYXJvbj00MDA7ZS5LY29tbWFhY2NlbnQ9NzIyO2UuTGFjdXRlPTYxMTtlLnRyYWRlbWFyaz0xZTM7ZS5lZG90YWNjZW50PTU1NjtlLklncmF2ZT0yNzg7ZS5JbWFjcm9uPTI3ODtlLkxjYXJvbj02MTE7ZS5vbmVoYWxmPTgzNDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD02MTE7ZS5udGlsZGU9NjExO2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjY3O2UuZW1hY3Jvbj01NTY7ZS5nYnJldmU9NjExO2Uub25lcXVhcnRlcj04MzQ7ZS5TY2Fyb249NjY3O2UuU2NvbW1hYWNjZW50PTY2NztlLk9odW5nYXJ1bWxhdXQ9Nzc4O2UuZGVncmVlPTQwMDtlLm9ncmF2ZT02MTE7ZS5DY2Fyb249NzIyO2UudWdyYXZlPTYxMTtlLnJhZGljYWw9NTQ5O2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zODk7ZS5OdGlsZGU9NzIyO2Uub3RpbGRlPTYxMTtlLlJjb21tYWFjY2VudD03MjI7ZS5MY29tbWFhY2NlbnQ9NjExO2UuQXRpbGRlPTcyMjtlLkFvZ29uZWs9NzIyO2UuQXJpbmc9NzIyO2UuT3RpbGRlPTc3ODtlLnpkb3RhY2NlbnQ9NTAwO2UuRWNhcm9uPTY2NztlLklvZ29uZWs9Mjc4O2Uua2NvbW1hYWNjZW50PTU1NjtlLm1pbnVzPTU4NDtlLkljaXJjdW1mbGV4PTI3ODtlLm5jYXJvbj02MTE7ZS50Y29tbWFhY2NlbnQ9MzMzO2UubG9naWNhbG5vdD01ODQ7ZS5vZGllcmVzaXM9NjExO2UudWRpZXJlc2lzPTYxMTtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD02MTE7ZS5ldGg9NjExO2UuemNhcm9uPTUwMDtlLm5jb21tYWFjY2VudD02MTE7ZS5vbmVzdXBlcmlvcj0zMzM7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTU2fSkpO2VbIkhlbHZldGljYS1PYmxpcXVlIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI3ODtlLmV4Y2xhbT0yNzg7ZS5xdW90ZWRibD0zNTU7ZS5udW1iZXJzaWduPTU1NjtlLmRvbGxhcj01NTY7ZS5wZXJjZW50PTg4OTtlLmFtcGVyc2FuZD02Njc7ZS5xdW90ZXJpZ2h0PTIyMjtlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTM4OTtlLnBsdXM9NTg0O2UuY29tbWE9Mjc4O2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNzg7ZS5zbGFzaD0yNzg7ZS56ZXJvPTU1NjtlLm9uZT01NTY7ZS50d289NTU2O2UudGhyZWU9NTU2O2UuZm91cj01NTY7ZS5maXZlPTU1NjtlLnNpeD01NTY7ZS5zZXZlbj01NTY7ZS5laWdodD01NTY7ZS5uaW5lPTU1NjtlLmNvbG9uPTI3ODtlLnNlbWljb2xvbj0yNzg7ZS5sZXNzPTU4NDtlLmVxdWFsPTU4NDtlLmdyZWF0ZXI9NTg0O2UucXVlc3Rpb249NTU2O2UuYXQ9MTAxNTtlLkE9NjY3O2UuQj02Njc7ZS5DPTcyMjtlLkQ9NzIyO2UuRT02Njc7ZS5GPTYxMTtlLkc9Nzc4O2UuSD03MjI7ZS5JPTI3ODtlLko9NTAwO2UuSz02Njc7ZS5MPTU1NjtlLk09ODMzO2UuTj03MjI7ZS5PPTc3ODtlLlA9NjY3O2UuUT03Nzg7ZS5SPTcyMjtlLlM9NjY3O2UuVD02MTE7ZS5VPTcyMjtlLlY9NjY3O2UuVz05NDQ7ZS5YPTY2NztlLlk9NjY3O2UuWj02MTE7ZS5icmFja2V0bGVmdD0yNzg7ZS5iYWNrc2xhc2g9Mjc4O2UuYnJhY2tldHJpZ2h0PTI3ODtlLmFzY2lpY2lyY3VtPTQ2OTtlLnVuZGVyc2NvcmU9NTU2O2UucXVvdGVsZWZ0PTIyMjtlLmE9NTU2O2UuYj01NTY7ZS5jPTUwMDtlLmQ9NTU2O2UuZT01NTY7ZS5mPTI3ODtlLmc9NTU2O2UuaD01NTY7ZS5pPTIyMjtlLmo9MjIyO2Uuaz01MDA7ZS5sPTIyMjtlLm09ODMzO2Uubj01NTY7ZS5vPTU1NjtlLnA9NTU2O2UucT01NTY7ZS5yPTMzMztlLnM9NTAwO2UudD0yNzg7ZS51PTU1NjtlLnY9NTAwO2Uudz03MjI7ZS54PTUwMDtlLnk9NTAwO2Uuej01MDA7ZS5icmFjZWxlZnQ9MzM0O2UuYmFyPTI2MDtlLmJyYWNlcmlnaHQ9MzM0O2UuYXNjaWl0aWxkZT01ODQ7ZS5leGNsYW1kb3duPTMzMztlLmNlbnQ9NTU2O2Uuc3Rlcmxpbmc9NTU2O2UuZnJhY3Rpb249MTY3O2UueWVuPTU1NjtlLmZsb3Jpbj01NTY7ZS5zZWN0aW9uPTU1NjtlLmN1cnJlbmN5PTU1NjtlLnF1b3Rlc2luZ2xlPTE5MTtlLnF1b3RlZGJsbGVmdD0zMzM7ZS5ndWlsbGVtb3RsZWZ0PTU1NjtlLmd1aWxzaW5nbGxlZnQ9MzMzO2UuZ3VpbHNpbmdscmlnaHQ9MzMzO2UuZmk9NTAwO2UuZmw9NTAwO2UuZW5kYXNoPTU1NjtlLmRhZ2dlcj01NTY7ZS5kYWdnZXJkYmw9NTU2O2UucGVyaW9kY2VudGVyZWQ9Mjc4O2UucGFyYWdyYXBoPTUzNztlLmJ1bGxldD0zNTA7ZS5xdW90ZXNpbmdsYmFzZT0yMjI7ZS5xdW90ZWRibGJhc2U9MzMzO2UucXVvdGVkYmxyaWdodD0zMzM7ZS5ndWlsbGVtb3RyaWdodD01NTY7ZS5lbGxpcHNpcz0xZTM7ZS5wZXJ0aG91c2FuZD0xZTM7ZS5xdWVzdGlvbmRvd249NjExO2UuZ3JhdmU9MzMzO2UuYWN1dGU9MzMzO2UuY2lyY3VtZmxleD0zMzM7ZS50aWxkZT0zMzM7ZS5tYWNyb249MzMzO2UuYnJldmU9MzMzO2UuZG90YWNjZW50PTMzMztlLmRpZXJlc2lzPTMzMztlLnJpbmc9MzMzO2UuY2VkaWxsYT0zMzM7ZS5odW5nYXJ1bWxhdXQ9MzMzO2Uub2dvbmVrPTMzMztlLmNhcm9uPTMzMztlLmVtZGFzaD0xZTM7ZS5BRT0xZTM7ZS5vcmRmZW1pbmluZT0zNzA7ZS5Mc2xhc2g9NTU2O2UuT3NsYXNoPTc3ODtlLk9FPTFlMztlLm9yZG1hc2N1bGluZT0zNjU7ZS5hZT04ODk7ZS5kb3RsZXNzaT0yNzg7ZS5sc2xhc2g9MjIyO2Uub3NsYXNoPTYxMTtlLm9lPTk0NDtlLmdlcm1hbmRibHM9NjExO2UuSWRpZXJlc2lzPTI3ODtlLmVhY3V0ZT01NTY7ZS5hYnJldmU9NTU2O2UudWh1bmdhcnVtbGF1dD01NTY7ZS5lY2Fyb249NTU2O2UuWWRpZXJlc2lzPTY2NztlLmRpdmlkZT01ODQ7ZS5ZYWN1dGU9NjY3O2UuQWNpcmN1bWZsZXg9NjY3O2UuYWFjdXRlPTU1NjtlLlVjaXJjdW1mbGV4PTcyMjtlLnlhY3V0ZT01MDA7ZS5zY29tbWFhY2NlbnQ9NTAwO2UuZWNpcmN1bWZsZXg9NTU2O2UuVXJpbmc9NzIyO2UuVWRpZXJlc2lzPTcyMjtlLmFvZ29uZWs9NTU2O2UuVWFjdXRlPTcyMjtlLnVvZ29uZWs9NTU2O2UuRWRpZXJlc2lzPTY2NztlLkRjcm9hdD03MjI7ZS5jb21tYWFjY2VudD0yNTA7ZS5jb3B5cmlnaHQ9NzM3O2UuRW1hY3Jvbj02Njc7ZS5jY2Fyb249NTAwO2UuYXJpbmc9NTU2O2UuTmNvbW1hYWNjZW50PTcyMjtlLmxhY3V0ZT0yMjI7ZS5hZ3JhdmU9NTU2O2UuVGNvbW1hYWNjZW50PTYxMTtlLkNhY3V0ZT03MjI7ZS5hdGlsZGU9NTU2O2UuRWRvdGFjY2VudD02Njc7ZS5zY2Fyb249NTAwO2Uuc2NlZGlsbGE9NTAwO2UuaWFjdXRlPTI3ODtlLmxvemVuZ2U9NDcxO2UuUmNhcm9uPTcyMjtlLkdjb21tYWFjY2VudD03Nzg7ZS51Y2lyY3VtZmxleD01NTY7ZS5hY2lyY3VtZmxleD01NTY7ZS5BbWFjcm9uPTY2NztlLnJjYXJvbj0zMzM7ZS5jY2VkaWxsYT01MDA7ZS5aZG90YWNjZW50PTYxMTtlLlRob3JuPTY2NztlLk9tYWNyb249Nzc4O2UuUmFjdXRlPTcyMjtlLlNhY3V0ZT02Njc7ZS5kY2Fyb249NjQzO2UuVW1hY3Jvbj03MjI7ZS51cmluZz01NTY7ZS50aHJlZXN1cGVyaW9yPTMzMztlLk9ncmF2ZT03Nzg7ZS5BZ3JhdmU9NjY3O2UuQWJyZXZlPTY2NztlLm11bHRpcGx5PTU4NDtlLnVhY3V0ZT01NTY7ZS5UY2Fyb249NjExO2UucGFydGlhbGRpZmY9NDc2O2UueWRpZXJlc2lzPTUwMDtlLk5hY3V0ZT03MjI7ZS5pY2lyY3VtZmxleD0yNzg7ZS5FY2lyY3VtZmxleD02Njc7ZS5hZGllcmVzaXM9NTU2O2UuZWRpZXJlc2lzPTU1NjtlLmNhY3V0ZT01MDA7ZS5uYWN1dGU9NTU2O2UudW1hY3Jvbj01NTY7ZS5OY2Fyb249NzIyO2UuSWFjdXRlPTI3ODtlLnBsdXNtaW51cz01ODQ7ZS5icm9rZW5iYXI9MjYwO2UucmVnaXN0ZXJlZD03Mzc7ZS5HYnJldmU9Nzc4O2UuSWRvdGFjY2VudD0yNzg7ZS5zdW1tYXRpb249NjAwO2UuRWdyYXZlPTY2NztlLnJhY3V0ZT0zMzM7ZS5vbWFjcm9uPTU1NjtlLlphY3V0ZT02MTE7ZS5aY2Fyb249NjExO2UuZ3JlYXRlcmVxdWFsPTU0OTtlLkV0aD03MjI7ZS5DY2VkaWxsYT03MjI7ZS5sY29tbWFhY2NlbnQ9MjIyO2UudGNhcm9uPTMxNztlLmVvZ29uZWs9NTU2O2UuVW9nb25laz03MjI7ZS5BYWN1dGU9NjY3O2UuQWRpZXJlc2lzPTY2NztlLmVncmF2ZT01NTY7ZS56YWN1dGU9NTAwO2UuaW9nb25laz0yMjI7ZS5PYWN1dGU9Nzc4O2Uub2FjdXRlPTU1NjtlLmFtYWNyb249NTU2O2Uuc2FjdXRlPTUwMDtlLmlkaWVyZXNpcz0yNzg7ZS5PY2lyY3VtZmxleD03Nzg7ZS5VZ3JhdmU9NzIyO2UuRGVsdGE9NjEyO2UudGhvcm49NTU2O2UudHdvc3VwZXJpb3I9MzMzO2UuT2RpZXJlc2lzPTc3ODtlLm11PTU1NjtlLmlncmF2ZT0yNzg7ZS5vaHVuZ2FydW1sYXV0PTU1NjtlLkVvZ29uZWs9NjY3O2UuZGNyb2F0PTU1NjtlLnRocmVlcXVhcnRlcnM9ODM0O2UuU2NlZGlsbGE9NjY3O2UubGNhcm9uPTI5OTtlLktjb21tYWFjY2VudD02Njc7ZS5MYWN1dGU9NTU2O2UudHJhZGVtYXJrPTFlMztlLmVkb3RhY2NlbnQ9NTU2O2UuSWdyYXZlPTI3ODtlLkltYWNyb249Mjc4O2UuTGNhcm9uPTU1NjtlLm9uZWhhbGY9ODM0O2UubGVzc2VxdWFsPTU0OTtlLm9jaXJjdW1mbGV4PTU1NjtlLm50aWxkZT01NTY7ZS5VaHVuZ2FydW1sYXV0PTcyMjtlLkVhY3V0ZT02Njc7ZS5lbWFjcm9uPTU1NjtlLmdicmV2ZT01NTY7ZS5vbmVxdWFydGVyPTgzNDtlLlNjYXJvbj02Njc7ZS5TY29tbWFhY2NlbnQ9NjY3O2UuT2h1bmdhcnVtbGF1dD03Nzg7ZS5kZWdyZWU9NDAwO2Uub2dyYXZlPTU1NjtlLkNjYXJvbj03MjI7ZS51Z3JhdmU9NTU2O2UucmFkaWNhbD00NTM7ZS5EY2Fyb249NzIyO2UucmNvbW1hYWNjZW50PTMzMztlLk50aWxkZT03MjI7ZS5vdGlsZGU9NTU2O2UuUmNvbW1hYWNjZW50PTcyMjtlLkxjb21tYWFjY2VudD01NTY7ZS5BdGlsZGU9NjY3O2UuQW9nb25laz02Njc7ZS5BcmluZz02Njc7ZS5PdGlsZGU9Nzc4O2UuemRvdGFjY2VudD01MDA7ZS5FY2Fyb249NjY3O2UuSW9nb25laz0yNzg7ZS5rY29tbWFhY2NlbnQ9NTAwO2UubWludXM9NTg0O2UuSWNpcmN1bWZsZXg9Mjc4O2UubmNhcm9uPTU1NjtlLnRjb21tYWFjY2VudD0yNzg7ZS5sb2dpY2Fsbm90PTU4NDtlLm9kaWVyZXNpcz01NTY7ZS51ZGllcmVzaXM9NTU2O2Uubm90ZXF1YWw9NTQ5O2UuZ2NvbW1hYWNjZW50PTU1NjtlLmV0aD01NTY7ZS56Y2Fyb249NTAwO2UubmNvbW1hYWNjZW50PTU1NjtlLm9uZXN1cGVyaW9yPTMzMztlLmltYWNyb249Mjc4O2UuRXVybz01NTZ9KSk7ZS5TeW1ib2w9Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI1MDtlLmV4Y2xhbT0zMzM7ZS51bml2ZXJzYWw9NzEzO2UubnVtYmVyc2lnbj01MDA7ZS5leGlzdGVudGlhbD01NDk7ZS5wZXJjZW50PTgzMztlLmFtcGVyc2FuZD03Nzg7ZS5zdWNodGhhdD00Mzk7ZS5wYXJlbmxlZnQ9MzMzO2UucGFyZW5yaWdodD0zMzM7ZS5hc3Rlcmlza21hdGg9NTAwO2UucGx1cz01NDk7ZS5jb21tYT0yNTA7ZS5taW51cz01NDk7ZS5wZXJpb2Q9MjUwO2Uuc2xhc2g9Mjc4O2UuemVybz01MDA7ZS5vbmU9NTAwO2UudHdvPTUwMDtlLnRocmVlPTUwMDtlLmZvdXI9NTAwO2UuZml2ZT01MDA7ZS5zaXg9NTAwO2Uuc2V2ZW49NTAwO2UuZWlnaHQ9NTAwO2UubmluZT01MDA7ZS5jb2xvbj0yNzg7ZS5zZW1pY29sb249Mjc4O2UubGVzcz01NDk7ZS5lcXVhbD01NDk7ZS5ncmVhdGVyPTU0OTtlLnF1ZXN0aW9uPTQ0NDtlLmNvbmdydWVudD01NDk7ZS5BbHBoYT03MjI7ZS5CZXRhPTY2NztlLkNoaT03MjI7ZS5EZWx0YT02MTI7ZS5FcHNpbG9uPTYxMTtlLlBoaT03NjM7ZS5HYW1tYT02MDM7ZS5FdGE9NzIyO2UuSW90YT0zMzM7ZS50aGV0YTE9NjMxO2UuS2FwcGE9NzIyO2UuTGFtYmRhPTY4NjtlLk11PTg4OTtlLk51PTcyMjtlLk9taWNyb249NzIyO2UuUGk9NzY4O2UuVGhldGE9NzQxO2UuUmhvPTU1NjtlLlNpZ21hPTU5MjtlLlRhdT02MTE7ZS5VcHNpbG9uPTY5MDtlLnNpZ21hMT00Mzk7ZS5PbWVnYT03Njg7ZS5YaT02NDU7ZS5Qc2k9Nzk1O2UuWmV0YT02MTE7ZS5icmFja2V0bGVmdD0zMzM7ZS50aGVyZWZvcmU9ODYzO2UuYnJhY2tldHJpZ2h0PTMzMztlLnBlcnBlbmRpY3VsYXI9NjU4O2UudW5kZXJzY29yZT01MDA7ZS5yYWRpY2FsZXg9NTAwO2UuYWxwaGE9NjMxO2UuYmV0YT01NDk7ZS5jaGk9NTQ5O2UuZGVsdGE9NDk0O2UuZXBzaWxvbj00Mzk7ZS5waGk9NTIxO2UuZ2FtbWE9NDExO2UuZXRhPTYwMztlLmlvdGE9MzI5O2UucGhpMT02MDM7ZS5rYXBwYT01NDk7ZS5sYW1iZGE9NTQ5O2UubXU9NTc2O2UubnU9NTIxO2Uub21pY3Jvbj01NDk7ZS5waT01NDk7ZS50aGV0YT01MjE7ZS5yaG89NTQ5O2Uuc2lnbWE9NjAzO2UudGF1PTQzOTtlLnVwc2lsb249NTc2O2Uub21lZ2ExPTcxMztlLm9tZWdhPTY4NjtlLnhpPTQ5MztlLnBzaT02ODY7ZS56ZXRhPTQ5NDtlLmJyYWNlbGVmdD00ODA7ZS5iYXI9MjAwO2UuYnJhY2VyaWdodD00ODA7ZS5zaW1pbGFyPTU0OTtlLkV1cm89NzUwO2UuVXBzaWxvbjE9NjIwO2UubWludXRlPTI0NztlLmxlc3NlcXVhbD01NDk7ZS5mcmFjdGlvbj0xNjc7ZS5pbmZpbml0eT03MTM7ZS5mbG9yaW49NTAwO2UuY2x1Yj03NTM7ZS5kaWFtb25kPTc1MztlLmhlYXJ0PTc1MztlLnNwYWRlPTc1MztlLmFycm93Ym90aD0xMDQyO2UuYXJyb3dsZWZ0PTk4NztlLmFycm93dXA9NjAzO2UuYXJyb3dyaWdodD05ODc7ZS5hcnJvd2Rvd249NjAzO2UuZGVncmVlPTQwMDtlLnBsdXNtaW51cz01NDk7ZS5zZWNvbmQ9NDExO2UuZ3JlYXRlcmVxdWFsPTU0OTtlLm11bHRpcGx5PTU0OTtlLnByb3BvcnRpb25hbD03MTM7ZS5wYXJ0aWFsZGlmZj00OTQ7ZS5idWxsZXQ9NDYwO2UuZGl2aWRlPTU0OTtlLm5vdGVxdWFsPTU0OTtlLmVxdWl2YWxlbmNlPTU0OTtlLmFwcHJveGVxdWFsPTU0OTtlLmVsbGlwc2lzPTFlMztlLmFycm93dmVydGV4PTYwMztlLmFycm93aG9yaXpleD0xZTM7ZS5jYXJyaWFnZXJldHVybj02NTg7ZS5hbGVwaD04MjM7ZS5JZnJha3R1cj02ODY7ZS5SZnJha3R1cj03OTU7ZS53ZWllcnN0cmFzcz05ODc7ZS5jaXJjbGVtdWx0aXBseT03Njg7ZS5jaXJjbGVwbHVzPTc2ODtlLmVtcHR5c2V0PTgyMztlLmludGVyc2VjdGlvbj03Njg7ZS51bmlvbj03Njg7ZS5wcm9wZXJzdXBlcnNldD03MTM7ZS5yZWZsZXhzdXBlcnNldD03MTM7ZS5ub3RzdWJzZXQ9NzEzO2UucHJvcGVyc3Vic2V0PTcxMztlLnJlZmxleHN1YnNldD03MTM7ZS5lbGVtZW50PTcxMztlLm5vdGVsZW1lbnQ9NzEzO2UuYW5nbGU9NzY4O2UuZ3JhZGllbnQ9NzEzO2UucmVnaXN0ZXJzZXJpZj03OTA7ZS5jb3B5cmlnaHRzZXJpZj03OTA7ZS50cmFkZW1hcmtzZXJpZj04OTA7ZS5wcm9kdWN0PTgyMztlLnJhZGljYWw9NTQ5O2UuZG90bWF0aD0yNTA7ZS5sb2dpY2Fsbm90PTcxMztlLmxvZ2ljYWxhbmQ9NjAzO2UubG9naWNhbG9yPTYwMztlLmFycm93ZGJsYm90aD0xMDQyO2UuYXJyb3dkYmxsZWZ0PTk4NztlLmFycm93ZGJsdXA9NjAzO2UuYXJyb3dkYmxyaWdodD05ODc7ZS5hcnJvd2RibGRvd249NjAzO2UubG96ZW5nZT00OTQ7ZS5hbmdsZWxlZnQ9MzI5O2UucmVnaXN0ZXJzYW5zPTc5MDtlLmNvcHlyaWdodHNhbnM9NzkwO2UudHJhZGVtYXJrc2Fucz03ODY7ZS5zdW1tYXRpb249NzEzO2UucGFyZW5sZWZ0dHA9Mzg0O2UucGFyZW5sZWZ0ZXg9Mzg0O2UucGFyZW5sZWZ0YnQ9Mzg0O2UuYnJhY2tldGxlZnR0cD0zODQ7ZS5icmFja2V0bGVmdGV4PTM4NDtlLmJyYWNrZXRsZWZ0YnQ9Mzg0O2UuYnJhY2VsZWZ0dHA9NDk0O2UuYnJhY2VsZWZ0bWlkPTQ5NDtlLmJyYWNlbGVmdGJ0PTQ5NDtlLmJyYWNlZXg9NDk0O2UuYW5nbGVyaWdodD0zMjk7ZS5pbnRlZ3JhbD0yNzQ7ZS5pbnRlZ3JhbHRwPTY4NjtlLmludGVncmFsZXg9Njg2O2UuaW50ZWdyYWxidD02ODY7ZS5wYXJlbnJpZ2h0dHA9Mzg0O2UucGFyZW5yaWdodGV4PTM4NDtlLnBhcmVucmlnaHRidD0zODQ7ZS5icmFja2V0cmlnaHR0cD0zODQ7ZS5icmFja2V0cmlnaHRleD0zODQ7ZS5icmFja2V0cmlnaHRidD0zODQ7ZS5icmFjZXJpZ2h0dHA9NDk0O2UuYnJhY2VyaWdodG1pZD00OTQ7ZS5icmFjZXJpZ2h0YnQ9NDk0O2UuYXBwbGU9NzkwfSkpO2VbIlRpbWVzLVJvbWFuIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI1MDtlLmV4Y2xhbT0zMzM7ZS5xdW90ZWRibD00MDg7ZS5udW1iZXJzaWduPTUwMDtlLmRvbGxhcj01MDA7ZS5wZXJjZW50PTgzMztlLmFtcGVyc2FuZD03Nzg7ZS5xdW90ZXJpZ2h0PTMzMztlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTUwMDtlLnBsdXM9NTY0O2UuY29tbWE9MjUwO2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNTA7ZS5zbGFzaD0yNzg7ZS56ZXJvPTUwMDtlLm9uZT01MDA7ZS50d289NTAwO2UudGhyZWU9NTAwO2UuZm91cj01MDA7ZS5maXZlPTUwMDtlLnNpeD01MDA7ZS5zZXZlbj01MDA7ZS5laWdodD01MDA7ZS5uaW5lPTUwMDtlLmNvbG9uPTI3ODtlLnNlbWljb2xvbj0yNzg7ZS5sZXNzPTU2NDtlLmVxdWFsPTU2NDtlLmdyZWF0ZXI9NTY0O2UucXVlc3Rpb249NDQ0O2UuYXQ9OTIxO2UuQT03MjI7ZS5CPTY2NztlLkM9NjY3O2UuRD03MjI7ZS5FPTYxMTtlLkY9NTU2O2UuRz03MjI7ZS5IPTcyMjtlLkk9MzMzO2UuSj0zODk7ZS5LPTcyMjtlLkw9NjExO2UuTT04ODk7ZS5OPTcyMjtlLk89NzIyO2UuUD01NTY7ZS5RPTcyMjtlLlI9NjY3O2UuUz01NTY7ZS5UPTYxMTtlLlU9NzIyO2UuVj03MjI7ZS5XPTk0NDtlLlg9NzIyO2UuWT03MjI7ZS5aPTYxMTtlLmJyYWNrZXRsZWZ0PTMzMztlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9MzMzO2UuYXNjaWljaXJjdW09NDY5O2UudW5kZXJzY29yZT01MDA7ZS5xdW90ZWxlZnQ9MzMzO2UuYT00NDQ7ZS5iPTUwMDtlLmM9NDQ0O2UuZD01MDA7ZS5lPTQ0NDtlLmY9MzMzO2UuZz01MDA7ZS5oPTUwMDtlLmk9Mjc4O2Uuaj0yNzg7ZS5rPTUwMDtlLmw9Mjc4O2UubT03Nzg7ZS5uPTUwMDtlLm89NTAwO2UucD01MDA7ZS5xPTUwMDtlLnI9MzMzO2Uucz0zODk7ZS50PTI3ODtlLnU9NTAwO2Uudj01MDA7ZS53PTcyMjtlLng9NTAwO2UueT01MDA7ZS56PTQ0NDtlLmJyYWNlbGVmdD00ODA7ZS5iYXI9MjAwO2UuYnJhY2VyaWdodD00ODA7ZS5hc2NpaXRpbGRlPTU0MTtlLmV4Y2xhbWRvd249MzMzO2UuY2VudD01MDA7ZS5zdGVybGluZz01MDA7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTAwO2UuZmxvcmluPTUwMDtlLnNlY3Rpb249NTAwO2UuY3VycmVuY3k9NTAwO2UucXVvdGVzaW5nbGU9MTgwO2UucXVvdGVkYmxsZWZ0PTQ0NDtlLmd1aWxsZW1vdGxlZnQ9NTAwO2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT01NTY7ZS5mbD01NTY7ZS5lbmRhc2g9NTAwO2UuZGFnZ2VyPTUwMDtlLmRhZ2dlcmRibD01MDA7ZS5wZXJpb2RjZW50ZXJlZD0yNTA7ZS5wYXJhZ3JhcGg9NDUzO2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTMzMztlLnF1b3RlZGJsYmFzZT00NDQ7ZS5xdW90ZWRibHJpZ2h0PTQ0NDtlLmd1aWxsZW1vdHJpZ2h0PTUwMDtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj00NDQ7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTg4OTtlLm9yZGZlbWluaW5lPTI3NjtlLkxzbGFzaD02MTE7ZS5Pc2xhc2g9NzIyO2UuT0U9ODg5O2Uub3JkbWFzY3VsaW5lPTMxMDtlLmFlPTY2NztlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yNzg7ZS5vc2xhc2g9NTAwO2Uub2U9NzIyO2UuZ2VybWFuZGJscz01MDA7ZS5JZGllcmVzaXM9MzMzO2UuZWFjdXRlPTQ0NDtlLmFicmV2ZT00NDQ7ZS51aHVuZ2FydW1sYXV0PTUwMDtlLmVjYXJvbj00NDQ7ZS5ZZGllcmVzaXM9NzIyO2UuZGl2aWRlPTU2NDtlLllhY3V0ZT03MjI7ZS5BY2lyY3VtZmxleD03MjI7ZS5hYWN1dGU9NDQ0O2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTUwMDtlLnNjb21tYWFjY2VudD0zODk7ZS5lY2lyY3VtZmxleD00NDQ7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz00NDQ7ZS5VYWN1dGU9NzIyO2UudW9nb25laz01MDA7ZS5FZGllcmVzaXM9NjExO2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03NjA7ZS5FbWFjcm9uPTYxMTtlLmNjYXJvbj00NDQ7ZS5hcmluZz00NDQ7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTI3ODtlLmFncmF2ZT00NDQ7ZS5UY29tbWFhY2NlbnQ9NjExO2UuQ2FjdXRlPTY2NztlLmF0aWxkZT00NDQ7ZS5FZG90YWNjZW50PTYxMTtlLnNjYXJvbj0zODk7ZS5zY2VkaWxsYT0zODk7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00NzE7ZS5SY2Fyb249NjY3O2UuR2NvbW1hYWNjZW50PTcyMjtlLnVjaXJjdW1mbGV4PTUwMDtlLmFjaXJjdW1mbGV4PTQ0NDtlLkFtYWNyb249NzIyO2UucmNhcm9uPTMzMztlLmNjZWRpbGxhPTQ0NDtlLlpkb3RhY2NlbnQ9NjExO2UuVGhvcm49NTU2O2UuT21hY3Jvbj03MjI7ZS5SYWN1dGU9NjY3O2UuU2FjdXRlPTU1NjtlLmRjYXJvbj01ODg7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTUwMDtlLnRocmVlc3VwZXJpb3I9MzAwO2UuT2dyYXZlPTcyMjtlLkFncmF2ZT03MjI7ZS5BYnJldmU9NzIyO2UubXVsdGlwbHk9NTY0O2UudWFjdXRlPTUwMDtlLlRjYXJvbj02MTE7ZS5wYXJ0aWFsZGlmZj00NzY7ZS55ZGllcmVzaXM9NTAwO2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTYxMTtlLmFkaWVyZXNpcz00NDQ7ZS5lZGllcmVzaXM9NDQ0O2UuY2FjdXRlPTQ0NDtlLm5hY3V0ZT01MDA7ZS51bWFjcm9uPTUwMDtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9MzMzO2UucGx1c21pbnVzPTU2NDtlLmJyb2tlbmJhcj0yMDA7ZS5yZWdpc3RlcmVkPTc2MDtlLkdicmV2ZT03MjI7ZS5JZG90YWNjZW50PTMzMztlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjExO2UucmFjdXRlPTMzMztlLm9tYWNyb249NTAwO2UuWmFjdXRlPTYxMTtlLlpjYXJvbj02MTE7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTY2NztlLmxjb21tYWFjY2VudD0yNzg7ZS50Y2Fyb249MzI2O2UuZW9nb25laz00NDQ7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT03MjI7ZS5BZGllcmVzaXM9NzIyO2UuZWdyYXZlPTQ0NDtlLnphY3V0ZT00NDQ7ZS5pb2dvbmVrPTI3ODtlLk9hY3V0ZT03MjI7ZS5vYWN1dGU9NTAwO2UuYW1hY3Jvbj00NDQ7ZS5zYWN1dGU9Mzg5O2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTcyMjtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj01MDA7ZS50d29zdXBlcmlvcj0zMDA7ZS5PZGllcmVzaXM9NzIyO2UubXU9NTAwO2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NTAwO2UuRW9nb25laz02MTE7ZS5kY3JvYXQ9NTAwO2UudGhyZWVxdWFydGVycz03NTA7ZS5TY2VkaWxsYT01NTY7ZS5sY2Fyb249MzQ0O2UuS2NvbW1hYWNjZW50PTcyMjtlLkxhY3V0ZT02MTE7ZS50cmFkZW1hcms9OTgwO2UuZWRvdGFjY2VudD00NDQ7ZS5JZ3JhdmU9MzMzO2UuSW1hY3Jvbj0zMzM7ZS5MY2Fyb249NjExO2Uub25laGFsZj03NTA7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NTAwO2UubnRpbGRlPTUwMDtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTYxMTtlLmVtYWNyb249NDQ0O2UuZ2JyZXZlPTUwMDtlLm9uZXF1YXJ0ZXI9NzUwO2UuU2Nhcm9uPTU1NjtlLlNjb21tYWFjY2VudD01NTY7ZS5PaHVuZ2FydW1sYXV0PTcyMjtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NTAwO2UuQ2Nhcm9uPTY2NztlLnVncmF2ZT01MDA7ZS5yYWRpY2FsPTQ1MztlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9MzMzO2UuTnRpbGRlPTcyMjtlLm90aWxkZT01MDA7ZS5SY29tbWFhY2NlbnQ9NjY3O2UuTGNvbW1hYWNjZW50PTYxMTtlLkF0aWxkZT03MjI7ZS5Bb2dvbmVrPTcyMjtlLkFyaW5nPTcyMjtlLk90aWxkZT03MjI7ZS56ZG90YWNjZW50PTQ0NDtlLkVjYXJvbj02MTE7ZS5Jb2dvbmVrPTMzMztlLmtjb21tYWFjY2VudD01MDA7ZS5taW51cz01NjQ7ZS5JY2lyY3VtZmxleD0zMzM7ZS5uY2Fyb249NTAwO2UudGNvbW1hYWNjZW50PTI3ODtlLmxvZ2ljYWxub3Q9NTY0O2Uub2RpZXJlc2lzPTUwMDtlLnVkaWVyZXNpcz01MDA7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NTAwO2UuZXRoPTUwMDtlLnpjYXJvbj00NDQ7ZS5uY29tbWFhY2NlbnQ9NTAwO2Uub25lc3VwZXJpb3I9MzAwO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTUwMH0pKTtlWyJUaW1lcy1Cb2xkIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI1MDtlLmV4Y2xhbT0zMzM7ZS5xdW90ZWRibD01NTU7ZS5udW1iZXJzaWduPTUwMDtlLmRvbGxhcj01MDA7ZS5wZXJjZW50PTFlMztlLmFtcGVyc2FuZD04MzM7ZS5xdW90ZXJpZ2h0PTMzMztlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTUwMDtlLnBsdXM9NTcwO2UuY29tbWE9MjUwO2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNTA7ZS5zbGFzaD0yNzg7ZS56ZXJvPTUwMDtlLm9uZT01MDA7ZS50d289NTAwO2UudGhyZWU9NTAwO2UuZm91cj01MDA7ZS5maXZlPTUwMDtlLnNpeD01MDA7ZS5zZXZlbj01MDA7ZS5laWdodD01MDA7ZS5uaW5lPTUwMDtlLmNvbG9uPTMzMztlLnNlbWljb2xvbj0zMzM7ZS5sZXNzPTU3MDtlLmVxdWFsPTU3MDtlLmdyZWF0ZXI9NTcwO2UucXVlc3Rpb249NTAwO2UuYXQ9OTMwO2UuQT03MjI7ZS5CPTY2NztlLkM9NzIyO2UuRD03MjI7ZS5FPTY2NztlLkY9NjExO2UuRz03Nzg7ZS5IPTc3ODtlLkk9Mzg5O2UuSj01MDA7ZS5LPTc3ODtlLkw9NjY3O2UuTT05NDQ7ZS5OPTcyMjtlLk89Nzc4O2UuUD02MTE7ZS5RPTc3ODtlLlI9NzIyO2UuUz01NTY7ZS5UPTY2NztlLlU9NzIyO2UuVj03MjI7ZS5XPTFlMztlLlg9NzIyO2UuWT03MjI7ZS5aPTY2NztlLmJyYWNrZXRsZWZ0PTMzMztlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9MzMzO2UuYXNjaWljaXJjdW09NTgxO2UudW5kZXJzY29yZT01MDA7ZS5xdW90ZWxlZnQ9MzMzO2UuYT01MDA7ZS5iPTU1NjtlLmM9NDQ0O2UuZD01NTY7ZS5lPTQ0NDtlLmY9MzMzO2UuZz01MDA7ZS5oPTU1NjtlLmk9Mjc4O2Uuaj0zMzM7ZS5rPTU1NjtlLmw9Mjc4O2UubT04MzM7ZS5uPTU1NjtlLm89NTAwO2UucD01NTY7ZS5xPTU1NjtlLnI9NDQ0O2Uucz0zODk7ZS50PTMzMztlLnU9NTU2O2Uudj01MDA7ZS53PTcyMjtlLng9NTAwO2UueT01MDA7ZS56PTQ0NDtlLmJyYWNlbGVmdD0zOTQ7ZS5iYXI9MjIwO2UuYnJhY2VyaWdodD0zOTQ7ZS5hc2NpaXRpbGRlPTUyMDtlLmV4Y2xhbWRvd249MzMzO2UuY2VudD01MDA7ZS5zdGVybGluZz01MDA7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTAwO2UuZmxvcmluPTUwMDtlLnNlY3Rpb249NTAwO2UuY3VycmVuY3k9NTAwO2UucXVvdGVzaW5nbGU9Mjc4O2UucXVvdGVkYmxsZWZ0PTUwMDtlLmd1aWxsZW1vdGxlZnQ9NTAwO2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT01NTY7ZS5mbD01NTY7ZS5lbmRhc2g9NTAwO2UuZGFnZ2VyPTUwMDtlLmRhZ2dlcmRibD01MDA7ZS5wZXJpb2RjZW50ZXJlZD0yNTA7ZS5wYXJhZ3JhcGg9NTQwO2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTMzMztlLnF1b3RlZGJsYmFzZT01MDA7ZS5xdW90ZWRibHJpZ2h0PTUwMDtlLmd1aWxsZW1vdHJpZ2h0PTUwMDtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj01MDA7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTFlMztlLm9yZGZlbWluaW5lPTMwMDtlLkxzbGFzaD02Njc7ZS5Pc2xhc2g9Nzc4O2UuT0U9MWUzO2Uub3JkbWFzY3VsaW5lPTMzMDtlLmFlPTcyMjtlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yNzg7ZS5vc2xhc2g9NTAwO2Uub2U9NzIyO2UuZ2VybWFuZGJscz01NTY7ZS5JZGllcmVzaXM9Mzg5O2UuZWFjdXRlPTQ0NDtlLmFicmV2ZT01MDA7ZS51aHVuZ2FydW1sYXV0PTU1NjtlLmVjYXJvbj00NDQ7ZS5ZZGllcmVzaXM9NzIyO2UuZGl2aWRlPTU3MDtlLllhY3V0ZT03MjI7ZS5BY2lyY3VtZmxleD03MjI7ZS5hYWN1dGU9NTAwO2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTUwMDtlLnNjb21tYWFjY2VudD0zODk7ZS5lY2lyY3VtZmxleD00NDQ7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz01MDA7ZS5VYWN1dGU9NzIyO2UudW9nb25laz01NTY7ZS5FZGllcmVzaXM9NjY3O2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03NDc7ZS5FbWFjcm9uPTY2NztlLmNjYXJvbj00NDQ7ZS5hcmluZz01MDA7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTI3ODtlLmFncmF2ZT01MDA7ZS5UY29tbWFhY2NlbnQ9NjY3O2UuQ2FjdXRlPTcyMjtlLmF0aWxkZT01MDA7ZS5FZG90YWNjZW50PTY2NztlLnNjYXJvbj0zODk7ZS5zY2VkaWxsYT0zODk7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00OTQ7ZS5SY2Fyb249NzIyO2UuR2NvbW1hYWNjZW50PTc3ODtlLnVjaXJjdW1mbGV4PTU1NjtlLmFjaXJjdW1mbGV4PTUwMDtlLkFtYWNyb249NzIyO2UucmNhcm9uPTQ0NDtlLmNjZWRpbGxhPTQ0NDtlLlpkb3RhY2NlbnQ9NjY3O2UuVGhvcm49NjExO2UuT21hY3Jvbj03Nzg7ZS5SYWN1dGU9NzIyO2UuU2FjdXRlPTU1NjtlLmRjYXJvbj02NzI7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTU1NjtlLnRocmVlc3VwZXJpb3I9MzAwO2UuT2dyYXZlPTc3ODtlLkFncmF2ZT03MjI7ZS5BYnJldmU9NzIyO2UubXVsdGlwbHk9NTcwO2UudWFjdXRlPTU1NjtlLlRjYXJvbj02Njc7ZS5wYXJ0aWFsZGlmZj00OTQ7ZS55ZGllcmVzaXM9NTAwO2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTY2NztlLmFkaWVyZXNpcz01MDA7ZS5lZGllcmVzaXM9NDQ0O2UuY2FjdXRlPTQ0NDtlLm5hY3V0ZT01NTY7ZS51bWFjcm9uPTU1NjtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9Mzg5O2UucGx1c21pbnVzPTU3MDtlLmJyb2tlbmJhcj0yMjA7ZS5yZWdpc3RlcmVkPTc0NztlLkdicmV2ZT03Nzg7ZS5JZG90YWNjZW50PTM4OTtlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjY3O2UucmFjdXRlPTQ0NDtlLm9tYWNyb249NTAwO2UuWmFjdXRlPTY2NztlLlpjYXJvbj02Njc7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTcyMjtlLmxjb21tYWFjY2VudD0yNzg7ZS50Y2Fyb249NDE2O2UuZW9nb25laz00NDQ7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT03MjI7ZS5BZGllcmVzaXM9NzIyO2UuZWdyYXZlPTQ0NDtlLnphY3V0ZT00NDQ7ZS5pb2dvbmVrPTI3ODtlLk9hY3V0ZT03Nzg7ZS5vYWN1dGU9NTAwO2UuYW1hY3Jvbj01MDA7ZS5zYWN1dGU9Mzg5O2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTc3ODtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj01NTY7ZS50d29zdXBlcmlvcj0zMDA7ZS5PZGllcmVzaXM9Nzc4O2UubXU9NTU2O2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NTAwO2UuRW9nb25laz02Njc7ZS5kY3JvYXQ9NTU2O2UudGhyZWVxdWFydGVycz03NTA7ZS5TY2VkaWxsYT01NTY7ZS5sY2Fyb249Mzk0O2UuS2NvbW1hYWNjZW50PTc3ODtlLkxhY3V0ZT02Njc7ZS50cmFkZW1hcms9MWUzO2UuZWRvdGFjY2VudD00NDQ7ZS5JZ3JhdmU9Mzg5O2UuSW1hY3Jvbj0zODk7ZS5MY2Fyb249NjY3O2Uub25laGFsZj03NTA7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NTAwO2UubnRpbGRlPTU1NjtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTY2NztlLmVtYWNyb249NDQ0O2UuZ2JyZXZlPTUwMDtlLm9uZXF1YXJ0ZXI9NzUwO2UuU2Nhcm9uPTU1NjtlLlNjb21tYWFjY2VudD01NTY7ZS5PaHVuZ2FydW1sYXV0PTc3ODtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NTAwO2UuQ2Nhcm9uPTcyMjtlLnVncmF2ZT01NTY7ZS5yYWRpY2FsPTU0OTtlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9NDQ0O2UuTnRpbGRlPTcyMjtlLm90aWxkZT01MDA7ZS5SY29tbWFhY2NlbnQ9NzIyO2UuTGNvbW1hYWNjZW50PTY2NztlLkF0aWxkZT03MjI7ZS5Bb2dvbmVrPTcyMjtlLkFyaW5nPTcyMjtlLk90aWxkZT03Nzg7ZS56ZG90YWNjZW50PTQ0NDtlLkVjYXJvbj02Njc7ZS5Jb2dvbmVrPTM4OTtlLmtjb21tYWFjY2VudD01NTY7ZS5taW51cz01NzA7ZS5JY2lyY3VtZmxleD0zODk7ZS5uY2Fyb249NTU2O2UudGNvbW1hYWNjZW50PTMzMztlLmxvZ2ljYWxub3Q9NTcwO2Uub2RpZXJlc2lzPTUwMDtlLnVkaWVyZXNpcz01NTY7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NTAwO2UuZXRoPTUwMDtlLnpjYXJvbj00NDQ7ZS5uY29tbWFhY2NlbnQ9NTU2O2Uub25lc3VwZXJpb3I9MzAwO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTUwMH0pKTtlWyJUaW1lcy1Cb2xkSXRhbGljIl09Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlLnNwYWNlPTI1MDtlLmV4Y2xhbT0zODk7ZS5xdW90ZWRibD01NTU7ZS5udW1iZXJzaWduPTUwMDtlLmRvbGxhcj01MDA7ZS5wZXJjZW50PTgzMztlLmFtcGVyc2FuZD03Nzg7ZS5xdW90ZXJpZ2h0PTMzMztlLnBhcmVubGVmdD0zMzM7ZS5wYXJlbnJpZ2h0PTMzMztlLmFzdGVyaXNrPTUwMDtlLnBsdXM9NTcwO2UuY29tbWE9MjUwO2UuaHlwaGVuPTMzMztlLnBlcmlvZD0yNTA7ZS5zbGFzaD0yNzg7ZS56ZXJvPTUwMDtlLm9uZT01MDA7ZS50d289NTAwO2UudGhyZWU9NTAwO2UuZm91cj01MDA7ZS5maXZlPTUwMDtlLnNpeD01MDA7ZS5zZXZlbj01MDA7ZS5laWdodD01MDA7ZS5uaW5lPTUwMDtlLmNvbG9uPTMzMztlLnNlbWljb2xvbj0zMzM7ZS5sZXNzPTU3MDtlLmVxdWFsPTU3MDtlLmdyZWF0ZXI9NTcwO2UucXVlc3Rpb249NTAwO2UuYXQ9ODMyO2UuQT02Njc7ZS5CPTY2NztlLkM9NjY3O2UuRD03MjI7ZS5FPTY2NztlLkY9NjY3O2UuRz03MjI7ZS5IPTc3ODtlLkk9Mzg5O2UuSj01MDA7ZS5LPTY2NztlLkw9NjExO2UuTT04ODk7ZS5OPTcyMjtlLk89NzIyO2UuUD02MTE7ZS5RPTcyMjtlLlI9NjY3O2UuUz01NTY7ZS5UPTYxMTtlLlU9NzIyO2UuVj02Njc7ZS5XPTg4OTtlLlg9NjY3O2UuWT02MTE7ZS5aPTYxMTtlLmJyYWNrZXRsZWZ0PTMzMztlLmJhY2tzbGFzaD0yNzg7ZS5icmFja2V0cmlnaHQ9MzMzO2UuYXNjaWljaXJjdW09NTcwO2UudW5kZXJzY29yZT01MDA7ZS5xdW90ZWxlZnQ9MzMzO2UuYT01MDA7ZS5iPTUwMDtlLmM9NDQ0O2UuZD01MDA7ZS5lPTQ0NDtlLmY9MzMzO2UuZz01MDA7ZS5oPTU1NjtlLmk9Mjc4O2Uuaj0yNzg7ZS5rPTUwMDtlLmw9Mjc4O2UubT03Nzg7ZS5uPTU1NjtlLm89NTAwO2UucD01MDA7ZS5xPTUwMDtlLnI9Mzg5O2Uucz0zODk7ZS50PTI3ODtlLnU9NTU2O2Uudj00NDQ7ZS53PTY2NztlLng9NTAwO2UueT00NDQ7ZS56PTM4OTtlLmJyYWNlbGVmdD0zNDg7ZS5iYXI9MjIwO2UuYnJhY2VyaWdodD0zNDg7ZS5hc2NpaXRpbGRlPTU3MDtlLmV4Y2xhbWRvd249Mzg5O2UuY2VudD01MDA7ZS5zdGVybGluZz01MDA7ZS5mcmFjdGlvbj0xNjc7ZS55ZW49NTAwO2UuZmxvcmluPTUwMDtlLnNlY3Rpb249NTAwO2UuY3VycmVuY3k9NTAwO2UucXVvdGVzaW5nbGU9Mjc4O2UucXVvdGVkYmxsZWZ0PTUwMDtlLmd1aWxsZW1vdGxlZnQ9NTAwO2UuZ3VpbHNpbmdsbGVmdD0zMzM7ZS5ndWlsc2luZ2xyaWdodD0zMzM7ZS5maT01NTY7ZS5mbD01NTY7ZS5lbmRhc2g9NTAwO2UuZGFnZ2VyPTUwMDtlLmRhZ2dlcmRibD01MDA7ZS5wZXJpb2RjZW50ZXJlZD0yNTA7ZS5wYXJhZ3JhcGg9NTAwO2UuYnVsbGV0PTM1MDtlLnF1b3Rlc2luZ2xiYXNlPTMzMztlLnF1b3RlZGJsYmFzZT01MDA7ZS5xdW90ZWRibHJpZ2h0PTUwMDtlLmd1aWxsZW1vdHJpZ2h0PTUwMDtlLmVsbGlwc2lzPTFlMztlLnBlcnRob3VzYW5kPTFlMztlLnF1ZXN0aW9uZG93bj01MDA7ZS5ncmF2ZT0zMzM7ZS5hY3V0ZT0zMzM7ZS5jaXJjdW1mbGV4PTMzMztlLnRpbGRlPTMzMztlLm1hY3Jvbj0zMzM7ZS5icmV2ZT0zMzM7ZS5kb3RhY2NlbnQ9MzMzO2UuZGllcmVzaXM9MzMzO2UucmluZz0zMzM7ZS5jZWRpbGxhPTMzMztlLmh1bmdhcnVtbGF1dD0zMzM7ZS5vZ29uZWs9MzMzO2UuY2Fyb249MzMzO2UuZW1kYXNoPTFlMztlLkFFPTk0NDtlLm9yZGZlbWluaW5lPTI2NjtlLkxzbGFzaD02MTE7ZS5Pc2xhc2g9NzIyO2UuT0U9OTQ0O2Uub3JkbWFzY3VsaW5lPTMwMDtlLmFlPTcyMjtlLmRvdGxlc3NpPTI3ODtlLmxzbGFzaD0yNzg7ZS5vc2xhc2g9NTAwO2Uub2U9NzIyO2UuZ2VybWFuZGJscz01MDA7ZS5JZGllcmVzaXM9Mzg5O2UuZWFjdXRlPTQ0NDtlLmFicmV2ZT01MDA7ZS51aHVuZ2FydW1sYXV0PTU1NjtlLmVjYXJvbj00NDQ7ZS5ZZGllcmVzaXM9NjExO2UuZGl2aWRlPTU3MDtlLllhY3V0ZT02MTE7ZS5BY2lyY3VtZmxleD02Njc7ZS5hYWN1dGU9NTAwO2UuVWNpcmN1bWZsZXg9NzIyO2UueWFjdXRlPTQ0NDtlLnNjb21tYWFjY2VudD0zODk7ZS5lY2lyY3VtZmxleD00NDQ7ZS5VcmluZz03MjI7ZS5VZGllcmVzaXM9NzIyO2UuYW9nb25laz01MDA7ZS5VYWN1dGU9NzIyO2UudW9nb25laz01NTY7ZS5FZGllcmVzaXM9NjY3O2UuRGNyb2F0PTcyMjtlLmNvbW1hYWNjZW50PTI1MDtlLmNvcHlyaWdodD03NDc7ZS5FbWFjcm9uPTY2NztlLmNjYXJvbj00NDQ7ZS5hcmluZz01MDA7ZS5OY29tbWFhY2NlbnQ9NzIyO2UubGFjdXRlPTI3ODtlLmFncmF2ZT01MDA7ZS5UY29tbWFhY2NlbnQ9NjExO2UuQ2FjdXRlPTY2NztlLmF0aWxkZT01MDA7ZS5FZG90YWNjZW50PTY2NztlLnNjYXJvbj0zODk7ZS5zY2VkaWxsYT0zODk7ZS5pYWN1dGU9Mjc4O2UubG96ZW5nZT00OTQ7ZS5SY2Fyb249NjY3O2UuR2NvbW1hYWNjZW50PTcyMjtlLnVjaXJjdW1mbGV4PTU1NjtlLmFjaXJjdW1mbGV4PTUwMDtlLkFtYWNyb249NjY3O2UucmNhcm9uPTM4OTtlLmNjZWRpbGxhPTQ0NDtlLlpkb3RhY2NlbnQ9NjExO2UuVGhvcm49NjExO2UuT21hY3Jvbj03MjI7ZS5SYWN1dGU9NjY3O2UuU2FjdXRlPTU1NjtlLmRjYXJvbj02MDg7ZS5VbWFjcm9uPTcyMjtlLnVyaW5nPTU1NjtlLnRocmVlc3VwZXJpb3I9MzAwO2UuT2dyYXZlPTcyMjtlLkFncmF2ZT02Njc7ZS5BYnJldmU9NjY3O2UubXVsdGlwbHk9NTcwO2UudWFjdXRlPTU1NjtlLlRjYXJvbj02MTE7ZS5wYXJ0aWFsZGlmZj00OTQ7ZS55ZGllcmVzaXM9NDQ0O2UuTmFjdXRlPTcyMjtlLmljaXJjdW1mbGV4PTI3ODtlLkVjaXJjdW1mbGV4PTY2NztlLmFkaWVyZXNpcz01MDA7ZS5lZGllcmVzaXM9NDQ0O2UuY2FjdXRlPTQ0NDtlLm5hY3V0ZT01NTY7ZS51bWFjcm9uPTU1NjtlLk5jYXJvbj03MjI7ZS5JYWN1dGU9Mzg5O2UucGx1c21pbnVzPTU3MDtlLmJyb2tlbmJhcj0yMjA7ZS5yZWdpc3RlcmVkPTc0NztlLkdicmV2ZT03MjI7ZS5JZG90YWNjZW50PTM4OTtlLnN1bW1hdGlvbj02MDA7ZS5FZ3JhdmU9NjY3O2UucmFjdXRlPTM4OTtlLm9tYWNyb249NTAwO2UuWmFjdXRlPTYxMTtlLlpjYXJvbj02MTE7ZS5ncmVhdGVyZXF1YWw9NTQ5O2UuRXRoPTcyMjtlLkNjZWRpbGxhPTY2NztlLmxjb21tYWFjY2VudD0yNzg7ZS50Y2Fyb249MzY2O2UuZW9nb25laz00NDQ7ZS5Vb2dvbmVrPTcyMjtlLkFhY3V0ZT02Njc7ZS5BZGllcmVzaXM9NjY3O2UuZWdyYXZlPTQ0NDtlLnphY3V0ZT0zODk7ZS5pb2dvbmVrPTI3ODtlLk9hY3V0ZT03MjI7ZS5vYWN1dGU9NTAwO2UuYW1hY3Jvbj01MDA7ZS5zYWN1dGU9Mzg5O2UuaWRpZXJlc2lzPTI3ODtlLk9jaXJjdW1mbGV4PTcyMjtlLlVncmF2ZT03MjI7ZS5EZWx0YT02MTI7ZS50aG9ybj01MDA7ZS50d29zdXBlcmlvcj0zMDA7ZS5PZGllcmVzaXM9NzIyO2UubXU9NTc2O2UuaWdyYXZlPTI3ODtlLm9odW5nYXJ1bWxhdXQ9NTAwO2UuRW9nb25laz02Njc7ZS5kY3JvYXQ9NTAwO2UudGhyZWVxdWFydGVycz03NTA7ZS5TY2VkaWxsYT01NTY7ZS5sY2Fyb249MzgyO2UuS2NvbW1hYWNjZW50PTY2NztlLkxhY3V0ZT02MTE7ZS50cmFkZW1hcms9MWUzO2UuZWRvdGFjY2VudD00NDQ7ZS5JZ3JhdmU9Mzg5O2UuSW1hY3Jvbj0zODk7ZS5MY2Fyb249NjExO2Uub25laGFsZj03NTA7ZS5sZXNzZXF1YWw9NTQ5O2Uub2NpcmN1bWZsZXg9NTAwO2UubnRpbGRlPTU1NjtlLlVodW5nYXJ1bWxhdXQ9NzIyO2UuRWFjdXRlPTY2NztlLmVtYWNyb249NDQ0O2UuZ2JyZXZlPTUwMDtlLm9uZXF1YXJ0ZXI9NzUwO2UuU2Nhcm9uPTU1NjtlLlNjb21tYWFjY2VudD01NTY7ZS5PaHVuZ2FydW1sYXV0PTcyMjtlLmRlZ3JlZT00MDA7ZS5vZ3JhdmU9NTAwO2UuQ2Nhcm9uPTY2NztlLnVncmF2ZT01NTY7ZS5yYWRpY2FsPTU0OTtlLkRjYXJvbj03MjI7ZS5yY29tbWFhY2NlbnQ9Mzg5O2UuTnRpbGRlPTcyMjtlLm90aWxkZT01MDA7ZS5SY29tbWFhY2NlbnQ9NjY3O2UuTGNvbW1hYWNjZW50PTYxMTtlLkF0aWxkZT02Njc7ZS5Bb2dvbmVrPTY2NztlLkFyaW5nPTY2NztlLk90aWxkZT03MjI7ZS56ZG90YWNjZW50PTM4OTtlLkVjYXJvbj02Njc7ZS5Jb2dvbmVrPTM4OTtlLmtjb21tYWFjY2VudD01MDA7ZS5taW51cz02MDY7ZS5JY2lyY3VtZmxleD0zODk7ZS5uY2Fyb249NTU2O2UudGNvbW1hYWNjZW50PTI3ODtlLmxvZ2ljYWxub3Q9NjA2O2Uub2RpZXJlc2lzPTUwMDtlLnVkaWVyZXNpcz01NTY7ZS5ub3RlcXVhbD01NDk7ZS5nY29tbWFhY2NlbnQ9NTAwO2UuZXRoPTUwMDtlLnpjYXJvbj0zODk7ZS5uY29tbWFhY2NlbnQ9NTU2O2Uub25lc3VwZXJpb3I9MzAwO2UuaW1hY3Jvbj0yNzg7ZS5FdXJvPTUwMH0pKTtlWyJUaW1lcy1JdGFsaWMiXT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2Uuc3BhY2U9MjUwO2UuZXhjbGFtPTMzMztlLnF1b3RlZGJsPTQyMDtlLm51bWJlcnNpZ249NTAwO2UuZG9sbGFyPTUwMDtlLnBlcmNlbnQ9ODMzO2UuYW1wZXJzYW5kPTc3ODtlLnF1b3RlcmlnaHQ9MzMzO2UucGFyZW5sZWZ0PTMzMztlLnBhcmVucmlnaHQ9MzMzO2UuYXN0ZXJpc2s9NTAwO2UucGx1cz02NzU7ZS5jb21tYT0yNTA7ZS5oeXBoZW49MzMzO2UucGVyaW9kPTI1MDtlLnNsYXNoPTI3ODtlLnplcm89NTAwO2Uub25lPTUwMDtlLnR3bz01MDA7ZS50aHJlZT01MDA7ZS5mb3VyPTUwMDtlLmZpdmU9NTAwO2Uuc2l4PTUwMDtlLnNldmVuPTUwMDtlLmVpZ2h0PTUwMDtlLm5pbmU9NTAwO2UuY29sb249MzMzO2Uuc2VtaWNvbG9uPTMzMztlLmxlc3M9Njc1O2UuZXF1YWw9Njc1O2UuZ3JlYXRlcj02NzU7ZS5xdWVzdGlvbj01MDA7ZS5hdD05MjA7ZS5BPTYxMTtlLkI9NjExO2UuQz02Njc7ZS5EPTcyMjtlLkU9NjExO2UuRj02MTE7ZS5HPTcyMjtlLkg9NzIyO2UuST0zMzM7ZS5KPTQ0NDtlLks9NjY3O2UuTD01NTY7ZS5NPTgzMztlLk49NjY3O2UuTz03MjI7ZS5QPTYxMTtlLlE9NzIyO2UuUj02MTE7ZS5TPTUwMDtlLlQ9NTU2O2UuVT03MjI7ZS5WPTYxMTtlLlc9ODMzO2UuWD02MTE7ZS5ZPTU1NjtlLlo9NTU2O2UuYnJhY2tldGxlZnQ9Mzg5O2UuYmFja3NsYXNoPTI3ODtlLmJyYWNrZXRyaWdodD0zODk7ZS5hc2NpaWNpcmN1bT00MjI7ZS51bmRlcnNjb3JlPTUwMDtlLnF1b3RlbGVmdD0zMzM7ZS5hPTUwMDtlLmI9NTAwO2UuYz00NDQ7ZS5kPTUwMDtlLmU9NDQ0O2UuZj0yNzg7ZS5nPTUwMDtlLmg9NTAwO2UuaT0yNzg7ZS5qPTI3ODtlLms9NDQ0O2UubD0yNzg7ZS5tPTcyMjtlLm49NTAwO2Uubz01MDA7ZS5wPTUwMDtlLnE9NTAwO2Uucj0zODk7ZS5zPTM4OTtlLnQ9Mjc4O2UudT01MDA7ZS52PTQ0NDtlLnc9NjY3O2UueD00NDQ7ZS55PTQ0NDtlLno9Mzg5O2UuYnJhY2VsZWZ0PTQwMDtlLmJhcj0yNzU7ZS5icmFjZXJpZ2h0PTQwMDtlLmFzY2lpdGlsZGU9NTQxO2UuZXhjbGFtZG93bj0zODk7ZS5jZW50PTUwMDtlLnN0ZXJsaW5nPTUwMDtlLmZyYWN0aW9uPTE2NztlLnllbj01MDA7ZS5mbG9yaW49NTAwO2Uuc2VjdGlvbj01MDA7ZS5jdXJyZW5jeT01MDA7ZS5xdW90ZXNpbmdsZT0yMTQ7ZS5xdW90ZWRibGxlZnQ9NTU2O2UuZ3VpbGxlbW90bGVmdD01MDA7ZS5ndWlsc2luZ2xsZWZ0PTMzMztlLmd1aWxzaW5nbHJpZ2h0PTMzMztlLmZpPTUwMDtlLmZsPTUwMDtlLmVuZGFzaD01MDA7ZS5kYWdnZXI9NTAwO2UuZGFnZ2VyZGJsPTUwMDtlLnBlcmlvZGNlbnRlcmVkPTI1MDtlLnBhcmFncmFwaD01MjM7ZS5idWxsZXQ9MzUwO2UucXVvdGVzaW5nbGJhc2U9MzMzO2UucXVvdGVkYmxiYXNlPTU1NjtlLnF1b3RlZGJscmlnaHQ9NTU2O2UuZ3VpbGxlbW90cmlnaHQ9NTAwO2UuZWxsaXBzaXM9ODg5O2UucGVydGhvdXNhbmQ9MWUzO2UucXVlc3Rpb25kb3duPTUwMDtlLmdyYXZlPTMzMztlLmFjdXRlPTMzMztlLmNpcmN1bWZsZXg9MzMzO2UudGlsZGU9MzMzO2UubWFjcm9uPTMzMztlLmJyZXZlPTMzMztlLmRvdGFjY2VudD0zMzM7ZS5kaWVyZXNpcz0zMzM7ZS5yaW5nPTMzMztlLmNlZGlsbGE9MzMzO2UuaHVuZ2FydW1sYXV0PTMzMztlLm9nb25laz0zMzM7ZS5jYXJvbj0zMzM7ZS5lbWRhc2g9ODg5O2UuQUU9ODg5O2Uub3JkZmVtaW5pbmU9Mjc2O2UuTHNsYXNoPTU1NjtlLk9zbGFzaD03MjI7ZS5PRT05NDQ7ZS5vcmRtYXNjdWxpbmU9MzEwO2UuYWU9NjY3O2UuZG90bGVzc2k9Mjc4O2UubHNsYXNoPTI3ODtlLm9zbGFzaD01MDA7ZS5vZT02Njc7ZS5nZXJtYW5kYmxzPTUwMDtlLklkaWVyZXNpcz0zMzM7ZS5lYWN1dGU9NDQ0O2UuYWJyZXZlPTUwMDtlLnVodW5nYXJ1bWxhdXQ9NTAwO2UuZWNhcm9uPTQ0NDtlLllkaWVyZXNpcz01NTY7ZS5kaXZpZGU9Njc1O2UuWWFjdXRlPTU1NjtlLkFjaXJjdW1mbGV4PTYxMTtlLmFhY3V0ZT01MDA7ZS5VY2lyY3VtZmxleD03MjI7ZS55YWN1dGU9NDQ0O2Uuc2NvbW1hYWNjZW50PTM4OTtlLmVjaXJjdW1mbGV4PTQ0NDtlLlVyaW5nPTcyMjtlLlVkaWVyZXNpcz03MjI7ZS5hb2dvbmVrPTUwMDtlLlVhY3V0ZT03MjI7ZS51b2dvbmVrPTUwMDtlLkVkaWVyZXNpcz02MTE7ZS5EY3JvYXQ9NzIyO2UuY29tbWFhY2NlbnQ9MjUwO2UuY29weXJpZ2h0PTc2MDtlLkVtYWNyb249NjExO2UuY2Nhcm9uPTQ0NDtlLmFyaW5nPTUwMDtlLk5jb21tYWFjY2VudD02Njc7ZS5sYWN1dGU9Mjc4O2UuYWdyYXZlPTUwMDtlLlRjb21tYWFjY2VudD01NTY7ZS5DYWN1dGU9NjY3O2UuYXRpbGRlPTUwMDtlLkVkb3RhY2NlbnQ9NjExO2Uuc2Nhcm9uPTM4OTtlLnNjZWRpbGxhPTM4OTtlLmlhY3V0ZT0yNzg7ZS5sb3plbmdlPTQ3MTtlLlJjYXJvbj02MTE7ZS5HY29tbWFhY2NlbnQ9NzIyO2UudWNpcmN1bWZsZXg9NTAwO2UuYWNpcmN1bWZsZXg9NTAwO2UuQW1hY3Jvbj02MTE7ZS5yY2Fyb249Mzg5O2UuY2NlZGlsbGE9NDQ0O2UuWmRvdGFjY2VudD01NTY7ZS5UaG9ybj02MTE7ZS5PbWFjcm9uPTcyMjtlLlJhY3V0ZT02MTE7ZS5TYWN1dGU9NTAwO2UuZGNhcm9uPTU0NDtlLlVtYWNyb249NzIyO2UudXJpbmc9NTAwO2UudGhyZWVzdXBlcmlvcj0zMDA7ZS5PZ3JhdmU9NzIyO2UuQWdyYXZlPTYxMTtlLkFicmV2ZT02MTE7ZS5tdWx0aXBseT02NzU7ZS51YWN1dGU9NTAwO2UuVGNhcm9uPTU1NjtlLnBhcnRpYWxkaWZmPTQ3NjtlLnlkaWVyZXNpcz00NDQ7ZS5OYWN1dGU9NjY3O2UuaWNpcmN1bWZsZXg9Mjc4O2UuRWNpcmN1bWZsZXg9NjExO2UuYWRpZXJlc2lzPTUwMDtlLmVkaWVyZXNpcz00NDQ7ZS5jYWN1dGU9NDQ0O2UubmFjdXRlPTUwMDtlLnVtYWNyb249NTAwO2UuTmNhcm9uPTY2NztlLklhY3V0ZT0zMzM7ZS5wbHVzbWludXM9Njc1O2UuYnJva2VuYmFyPTI3NTtlLnJlZ2lzdGVyZWQ9NzYwO2UuR2JyZXZlPTcyMjtlLklkb3RhY2NlbnQ9MzMzO2Uuc3VtbWF0aW9uPTYwMDtlLkVncmF2ZT02MTE7ZS5yYWN1dGU9Mzg5O2Uub21hY3Jvbj01MDA7ZS5aYWN1dGU9NTU2O2UuWmNhcm9uPTU1NjtlLmdyZWF0ZXJlcXVhbD01NDk7ZS5FdGg9NzIyO2UuQ2NlZGlsbGE9NjY3O2UubGNvbW1hYWNjZW50PTI3ODtlLnRjYXJvbj0zMDA7ZS5lb2dvbmVrPTQ0NDtlLlVvZ29uZWs9NzIyO2UuQWFjdXRlPTYxMTtlLkFkaWVyZXNpcz02MTE7ZS5lZ3JhdmU9NDQ0O2UuemFjdXRlPTM4OTtlLmlvZ29uZWs9Mjc4O2UuT2FjdXRlPTcyMjtlLm9hY3V0ZT01MDA7ZS5hbWFjcm9uPTUwMDtlLnNhY3V0ZT0zODk7ZS5pZGllcmVzaXM9Mjc4O2UuT2NpcmN1bWZsZXg9NzIyO2UuVWdyYXZlPTcyMjtlLkRlbHRhPTYxMjtlLnRob3JuPTUwMDtlLnR3b3N1cGVyaW9yPTMwMDtlLk9kaWVyZXNpcz03MjI7ZS5tdT01MDA7ZS5pZ3JhdmU9Mjc4O2Uub2h1bmdhcnVtbGF1dD01MDA7ZS5Fb2dvbmVrPTYxMTtlLmRjcm9hdD01MDA7ZS50aHJlZXF1YXJ0ZXJzPTc1MDtlLlNjZWRpbGxhPTUwMDtlLmxjYXJvbj0zMDA7ZS5LY29tbWFhY2NlbnQ9NjY3O2UuTGFjdXRlPTU1NjtlLnRyYWRlbWFyaz05ODA7ZS5lZG90YWNjZW50PTQ0NDtlLklncmF2ZT0zMzM7ZS5JbWFjcm9uPTMzMztlLkxjYXJvbj02MTE7ZS5vbmVoYWxmPTc1MDtlLmxlc3NlcXVhbD01NDk7ZS5vY2lyY3VtZmxleD01MDA7ZS5udGlsZGU9NTAwO2UuVWh1bmdhcnVtbGF1dD03MjI7ZS5FYWN1dGU9NjExO2UuZW1hY3Jvbj00NDQ7ZS5nYnJldmU9NTAwO2Uub25lcXVhcnRlcj03NTA7ZS5TY2Fyb249NTAwO2UuU2NvbW1hYWNjZW50PTUwMDtlLk9odW5nYXJ1bWxhdXQ9NzIyO2UuZGVncmVlPTQwMDtlLm9ncmF2ZT01MDA7ZS5DY2Fyb249NjY3O2UudWdyYXZlPTUwMDtlLnJhZGljYWw9NDUzO2UuRGNhcm9uPTcyMjtlLnJjb21tYWFjY2VudD0zODk7ZS5OdGlsZGU9NjY3O2Uub3RpbGRlPTUwMDtlLlJjb21tYWFjY2VudD02MTE7ZS5MY29tbWFhY2NlbnQ9NTU2O2UuQXRpbGRlPTYxMTtlLkFvZ29uZWs9NjExO2UuQXJpbmc9NjExO2UuT3RpbGRlPTcyMjtlLnpkb3RhY2NlbnQ9Mzg5O2UuRWNhcm9uPTYxMTtlLklvZ29uZWs9MzMzO2Uua2NvbW1hYWNjZW50PTQ0NDtlLm1pbnVzPTY3NTtlLkljaXJjdW1mbGV4PTMzMztlLm5jYXJvbj01MDA7ZS50Y29tbWFhY2NlbnQ9Mjc4O2UubG9naWNhbG5vdD02NzU7ZS5vZGllcmVzaXM9NTAwO2UudWRpZXJlc2lzPTUwMDtlLm5vdGVxdWFsPTU0OTtlLmdjb21tYWFjY2VudD01MDA7ZS5ldGg9NTAwO2UuemNhcm9uPTM4OTtlLm5jb21tYWFjY2VudD01MDA7ZS5vbmVzdXBlcmlvcj0zMDA7ZS5pbWFjcm9uPTI3ODtlLkV1cm89NTAwfSkpO2UuWmFwZkRpbmdiYXRzPWdldExvb2t1cFRhYmxlRmFjdG9yeSgoZnVuY3Rpb24oZSl7ZS5zcGFjZT0yNzg7ZS5hMT05NzQ7ZS5hMj05NjE7ZS5hMjAyPTk3NDtlLmEzPTk4MDtlLmE0PTcxOTtlLmE1PTc4OTtlLmExMTk9NzkwO2UuYTExOD03OTE7ZS5hMTE3PTY5MDtlLmExMT05NjA7ZS5hMTI9OTM5O2UuYTEzPTU0OTtlLmExND04NTU7ZS5hMTU9OTExO2UuYTE2PTkzMztlLmExMDU9OTExO2UuYTE3PTk0NTtlLmExOD05NzQ7ZS5hMTk9NzU1O2UuYTIwPTg0NjtlLmEyMT03NjI7ZS5hMjI9NzYxO2UuYTIzPTU3MTtlLmEyND02Nzc7ZS5hMjU9NzYzO2UuYTI2PTc2MDtlLmEyNz03NTk7ZS5hMjg9NzU0O2UuYTY9NDk0O2UuYTc9NTUyO2UuYTg9NTM3O2UuYTk9NTc3O2UuYTEwPTY5MjtlLmEyOT03ODY7ZS5hMzA9Nzg4O2UuYTMxPTc4ODtlLmEzMj03OTA7ZS5hMzM9NzkzO2UuYTM0PTc5NDtlLmEzNT04MTY7ZS5hMzY9ODIzO2UuYTM3PTc4OTtlLmEzOD04NDE7ZS5hMzk9ODIzO2UuYTQwPTgzMztlLmE0MT04MTY7ZS5hNDI9ODMxO2UuYTQzPTkyMztlLmE0ND03NDQ7ZS5hNDU9NzIzO2UuYTQ2PTc0OTtlLmE0Nz03OTA7ZS5hNDg9NzkyO2UuYTQ5PTY5NTtlLmE1MD03NzY7ZS5hNTE9NzY4O2UuYTUyPTc5MjtlLmE1Mz03NTk7ZS5hNTQ9NzA3O2UuYTU1PTcwODtlLmE1Nj02ODI7ZS5hNTc9NzAxO2UuYTU4PTgyNjtlLmE1OT04MTU7ZS5hNjA9Nzg5O2UuYTYxPTc4OTtlLmE2Mj03MDc7ZS5hNjM9Njg3O2UuYTY0PTY5NjtlLmE2NT02ODk7ZS5hNjY9Nzg2O2UuYTY3PTc4NztlLmE2OD03MTM7ZS5hNjk9NzkxO2UuYTcwPTc4NTtlLmE3MT03OTE7ZS5hNzI9ODczO2UuYTczPTc2MTtlLmE3ND03NjI7ZS5hMjAzPTc2MjtlLmE3NT03NTk7ZS5hMjA0PTc1OTtlLmE3Nj04OTI7ZS5hNzc9ODkyO2UuYTc4PTc4ODtlLmE3OT03ODQ7ZS5hODE9NDM4O2UuYTgyPTEzODtlLmE4Mz0yNzc7ZS5hODQ9NDE1O2UuYTk3PTM5MjtlLmE5OD0zOTI7ZS5hOTk9NjY4O2UuYTEwMD02Njg7ZS5hODk9MzkwO2UuYTkwPTM5MDtlLmE5Mz0zMTc7ZS5hOTQ9MzE3O2UuYTkxPTI3NjtlLmE5Mj0yNzY7ZS5hMjA1PTUwOTtlLmE4NT01MDk7ZS5hMjA2PTQxMDtlLmE4Nj00MTA7ZS5hODc9MjM0O2UuYTg4PTIzNDtlLmE5NT0zMzQ7ZS5hOTY9MzM0O2UuYTEwMT03MzI7ZS5hMTAyPTU0NDtlLmExMDM9NTQ0O2UuYTEwND05MTA7ZS5hMTA2PTY2NztlLmExMDc9NzYwO2UuYTEwOD03NjA7ZS5hMTEyPTc3NjtlLmExMTE9NTk1O2UuYTExMD02OTQ7ZS5hMTA5PTYyNjtlLmExMjA9Nzg4O2UuYTEyMT03ODg7ZS5hMTIyPTc4ODtlLmExMjM9Nzg4O2UuYTEyND03ODg7ZS5hMTI1PTc4ODtlLmExMjY9Nzg4O2UuYTEyNz03ODg7ZS5hMTI4PTc4ODtlLmExMjk9Nzg4O2UuYTEzMD03ODg7ZS5hMTMxPTc4ODtlLmExMzI9Nzg4O2UuYTEzMz03ODg7ZS5hMTM0PTc4ODtlLmExMzU9Nzg4O2UuYTEzNj03ODg7ZS5hMTM3PTc4ODtlLmExMzg9Nzg4O2UuYTEzOT03ODg7ZS5hMTQwPTc4ODtlLmExNDE9Nzg4O2UuYTE0Mj03ODg7ZS5hMTQzPTc4ODtlLmExNDQ9Nzg4O2UuYTE0NT03ODg7ZS5hMTQ2PTc4ODtlLmExNDc9Nzg4O2UuYTE0OD03ODg7ZS5hMTQ5PTc4ODtlLmExNTA9Nzg4O2UuYTE1MT03ODg7ZS5hMTUyPTc4ODtlLmExNTM9Nzg4O2UuYTE1ND03ODg7ZS5hMTU1PTc4ODtlLmExNTY9Nzg4O2UuYTE1Nz03ODg7ZS5hMTU4PTc4ODtlLmExNTk9Nzg4O2UuYTE2MD04OTQ7ZS5hMTYxPTgzODtlLmExNjM9MTAxNjtlLmExNjQ9NDU4O2UuYTE5Nj03NDg7ZS5hMTY1PTkyNDtlLmExOTI9NzQ4O2UuYTE2Nj05MTg7ZS5hMTY3PTkyNztlLmExNjg9OTI4O2UuYTE2OT05Mjg7ZS5hMTcwPTgzNDtlLmExNzE9ODczO2UuYTE3Mj04Mjg7ZS5hMTczPTkyNDtlLmExNjI9OTI0O2UuYTE3ND05MTc7ZS5hMTc1PTkzMDtlLmExNzY9OTMxO2UuYTE3Nz00NjM7ZS5hMTc4PTg4MztlLmExNzk9ODM2O2UuYTE5Mz04MzY7ZS5hMTgwPTg2NztlLmExOTk9ODY3O2UuYTE4MT02OTY7ZS5hMjAwPTY5NjtlLmExODI9ODc0O2UuYTIwMT04NzQ7ZS5hMTgzPTc2MDtlLmExODQ9OTQ2O2UuYTE5Nz03NzE7ZS5hMTg1PTg2NTtlLmExOTQ9NzcxO2UuYTE5OD04ODg7ZS5hMTg2PTk2NztlLmExOTU9ODg4O2UuYTE4Nz04MzE7ZS5hMTg4PTg3MztlLmExODk9OTI3O2UuYTE5MD05NzA7ZS5hMTkxPTkxOH0pKX0pKSxlYT1nZXRMb29rdXBUYWJsZUZhY3RvcnkoKGZ1bmN0aW9uKGUpe2UuQ291cmllcj17YXNjZW50OjYyOSxkZXNjZW50Oi0xNTcsY2FwSGVpZ2h0OjU2Mix4SGVpZ2h0Oi00MjZ9O2VbIkNvdXJpZXItQm9sZCJdPXthc2NlbnQ6NjI5LGRlc2NlbnQ6LTE1NyxjYXBIZWlnaHQ6NTYyLHhIZWlnaHQ6NDM5fTtlWyJDb3VyaWVyLU9ibGlxdWUiXT17YXNjZW50OjYyOSxkZXNjZW50Oi0xNTcsY2FwSGVpZ2h0OjU2Mix4SGVpZ2h0OjQyNn07ZVsiQ291cmllci1Cb2xkT2JsaXF1ZSJdPXthc2NlbnQ6NjI5LGRlc2NlbnQ6LTE1NyxjYXBIZWlnaHQ6NTYyLHhIZWlnaHQ6NDI2fTtlLkhlbHZldGljYT17YXNjZW50OjcxOCxkZXNjZW50Oi0yMDcsY2FwSGVpZ2h0OjcxOCx4SGVpZ2h0OjUyM307ZVsiSGVsdmV0aWNhLUJvbGQiXT17YXNjZW50OjcxOCxkZXNjZW50Oi0yMDcsY2FwSGVpZ2h0OjcxOCx4SGVpZ2h0OjUzMn07ZVsiSGVsdmV0aWNhLU9ibGlxdWUiXT17YXNjZW50OjcxOCxkZXNjZW50Oi0yMDcsY2FwSGVpZ2h0OjcxOCx4SGVpZ2h0OjUyM307ZVsiSGVsdmV0aWNhLUJvbGRPYmxpcXVlIl09e2FzY2VudDo3MTgsZGVzY2VudDotMjA3LGNhcEhlaWdodDo3MTgseEhlaWdodDo1MzJ9O2VbIlRpbWVzLVJvbWFuIl09e2FzY2VudDo2ODMsZGVzY2VudDotMjE3LGNhcEhlaWdodDo2NjIseEhlaWdodDo0NTB9O2VbIlRpbWVzLUJvbGQiXT17YXNjZW50OjY4MyxkZXNjZW50Oi0yMTcsY2FwSGVpZ2h0OjY3Nix4SGVpZ2h0OjQ2MX07ZVsiVGltZXMtSXRhbGljIl09e2FzY2VudDo2ODMsZGVzY2VudDotMjE3LGNhcEhlaWdodDo2NTMseEhlaWdodDo0NDF9O2VbIlRpbWVzLUJvbGRJdGFsaWMiXT17YXNjZW50OjY4MyxkZXNjZW50Oi0yMTcsY2FwSGVpZ2h0OjY2OSx4SGVpZ2h0OjQ2Mn07ZS5TeW1ib2w9e2FzY2VudDpNYXRoLk5hTixkZXNjZW50Ok1hdGguTmFOLGNhcEhlaWdodDpNYXRoLk5hTix4SGVpZ2h0Ok1hdGguTmFOfTtlLlphcGZEaW5nYmF0cz17YXNjZW50Ok1hdGguTmFOLGRlc2NlbnQ6TWF0aC5OYU4sY2FwSGVpZ2h0Ok1hdGguTmFOLHhIZWlnaHQ6TWF0aC5OYU59fSkpO2NsYXNzIEdseWZUYWJsZXtjb25zdHJ1Y3Rvcih7Z2x5ZlRhYmxlOmUsaXNHbHlwaExvY2F0aW9uc0xvbmc6dCxsb2NhVGFibGU6aSxudW1HbHlwaHM6YX0pe3RoaXMuZ2x5cGhzPVtdO2NvbnN0IHM9bmV3IERhdGFWaWV3KGkuYnVmZmVyLGkuYnl0ZU9mZnNldCxpLmJ5dGVMZW5ndGgpLHI9bmV3IERhdGFWaWV3KGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGgpLG49dD80OjI7bGV0IG89dD9zLmdldFVpbnQzMigwKToyKnMuZ2V0VWludDE2KDApLGc9MDtmb3IobGV0IGU9MDtlPGE7ZSsrKXtnKz1uO2NvbnN0IGU9dD9zLmdldFVpbnQzMihnKToyKnMuZ2V0VWludDE2KGcpO2lmKGU9PT1vKXt0aGlzLmdseXBocy5wdXNoKG5ldyBHbHlwaCh7fSkpO2NvbnRpbnVlfWNvbnN0IGk9R2x5cGgucGFyc2UobyxyKTt0aGlzLmdseXBocy5wdXNoKGkpO289ZX19Z2V0U2l6ZSgpe3JldHVybiB0aGlzLmdseXBocy5yZWR1Y2UoKChlLHQpPT5lKyh0LmdldFNpemUoKSszJi00KSksMCl9d3JpdGUoKXtjb25zdCBlPXRoaXMuZ2V0U2l6ZSgpLHQ9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcihlKSksaT1lPjEzMTA3MCxhPWk/NDoyLHM9bmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigodGhpcy5nbHlwaHMubGVuZ3RoKzEpKmEpKTtpP3Muc2V0VWludDMyKDAsMCk6cy5zZXRVaW50MTYoMCwwKTtsZXQgcj0wLG49MDtmb3IoY29uc3QgZSBvZiB0aGlzLmdseXBocyl7cis9ZS53cml0ZShyLHQpO3I9ciszJi00O24rPWE7aT9zLnNldFVpbnQzMihuLHIpOnMuc2V0VWludDE2KG4scj4+MSl9cmV0dXJue2lzTG9jYXRpb25Mb25nOmksbG9jYTpuZXcgVWludDhBcnJheShzLmJ1ZmZlciksZ2x5ZjpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcil9fXNjYWxlKGUpe2ZvcihsZXQgdD0wLGk9dGhpcy5nbHlwaHMubGVuZ3RoO3Q8aTt0KyspdGhpcy5nbHlwaHNbdF0uc2NhbGUoZVt0XSl9fWNsYXNzIEdseXBoe2NvbnN0cnVjdG9yKHtoZWFkZXI6ZT1udWxsLHNpbXBsZTp0PW51bGwsY29tcG9zaXRlczppPW51bGx9KXt0aGlzLmhlYWRlcj1lO3RoaXMuc2ltcGxlPXQ7dGhpcy5jb21wb3NpdGVzPWl9c3RhdGljIHBhcnNlKGUsdCl7Y29uc3RbaSxhXT1HbHlwaEhlYWRlci5wYXJzZShlLHQpO2UrPWk7aWYoYS5udW1iZXJPZkNvbnRvdXJzPDApe2NvbnN0IGk9W107Zm9yKDs7KXtjb25zdFthLHNdPUNvbXBvc2l0ZUdseXBoLnBhcnNlKGUsdCk7ZSs9YTtpLnB1c2gocyk7aWYoISgzMiZzLmZsYWdzKSlicmVha31yZXR1cm4gbmV3IEdseXBoKHtoZWFkZXI6YSxjb21wb3NpdGVzOml9KX1jb25zdCBzPVNpbXBsZUdseXBoLnBhcnNlKGUsdCxhLm51bWJlck9mQ29udG91cnMpO3JldHVybiBuZXcgR2x5cGgoe2hlYWRlcjphLHNpbXBsZTpzfSl9Z2V0U2l6ZSgpe2lmKCF0aGlzLmhlYWRlcilyZXR1cm4gMDtjb25zdCBlPXRoaXMuc2ltcGxlP3RoaXMuc2ltcGxlLmdldFNpemUoKTp0aGlzLmNvbXBvc2l0ZXMucmVkdWNlKCgoZSx0KT0+ZSt0LmdldFNpemUoKSksMCk7cmV0dXJuIHRoaXMuaGVhZGVyLmdldFNpemUoKStlfXdyaXRlKGUsdCl7aWYoIXRoaXMuaGVhZGVyKXJldHVybiAwO2NvbnN0IGk9ZTtlKz10aGlzLmhlYWRlci53cml0ZShlLHQpO2lmKHRoaXMuc2ltcGxlKWUrPXRoaXMuc2ltcGxlLndyaXRlKGUsdCk7ZWxzZSBmb3IoY29uc3QgaSBvZiB0aGlzLmNvbXBvc2l0ZXMpZSs9aS53cml0ZShlLHQpO3JldHVybiBlLWl9c2NhbGUoZSl7aWYoIXRoaXMuaGVhZGVyKXJldHVybjtjb25zdCB0PSh0aGlzLmhlYWRlci54TWluK3RoaXMuaGVhZGVyLnhNYXgpLzI7dGhpcy5oZWFkZXIuc2NhbGUodCxlKTtpZih0aGlzLnNpbXBsZSl0aGlzLnNpbXBsZS5zY2FsZSh0LGUpO2Vsc2UgZm9yKGNvbnN0IGkgb2YgdGhpcy5jb21wb3NpdGVzKWkuc2NhbGUodCxlKX19Y2xhc3MgR2x5cGhIZWFkZXJ7Y29uc3RydWN0b3Ioe251bWJlck9mQ29udG91cnM6ZSx4TWluOnQseU1pbjppLHhNYXg6YSx5TWF4OnN9KXt0aGlzLm51bWJlck9mQ29udG91cnM9ZTt0aGlzLnhNaW49dDt0aGlzLnlNaW49aTt0aGlzLnhNYXg9YTt0aGlzLnlNYXg9c31zdGF0aWMgcGFyc2UoZSx0KXtyZXR1cm5bMTAsbmV3IEdseXBoSGVhZGVyKHtudW1iZXJPZkNvbnRvdXJzOnQuZ2V0SW50MTYoZSkseE1pbjp0LmdldEludDE2KGUrMikseU1pbjp0LmdldEludDE2KGUrNCkseE1heDp0LmdldEludDE2KGUrNikseU1heDp0LmdldEludDE2KGUrOCl9KV19Z2V0U2l6ZSgpe3JldHVybiAxMH13cml0ZShlLHQpe3Quc2V0SW50MTYoZSx0aGlzLm51bWJlck9mQ29udG91cnMpO3Quc2V0SW50MTYoZSsyLHRoaXMueE1pbik7dC5zZXRJbnQxNihlKzQsdGhpcy55TWluKTt0LnNldEludDE2KGUrNix0aGlzLnhNYXgpO3Quc2V0SW50MTYoZSs4LHRoaXMueU1heCk7cmV0dXJuIDEwfXNjYWxlKGUsdCl7dGhpcy54TWluPU1hdGgucm91bmQoZSsodGhpcy54TWluLWUpKnQpO3RoaXMueE1heD1NYXRoLnJvdW5kKGUrKHRoaXMueE1heC1lKSp0KX19Y2xhc3MgQ29udG91cntjb25zdHJ1Y3Rvcih7ZmxhZ3M6ZSx4Q29vcmRpbmF0ZXM6dCx5Q29vcmRpbmF0ZXM6aX0pe3RoaXMueENvb3JkaW5hdGVzPXQ7dGhpcy55Q29vcmRpbmF0ZXM9aTt0aGlzLmZsYWdzPWV9fWNsYXNzIFNpbXBsZUdseXBoe2NvbnN0cnVjdG9yKHtjb250b3VyczplLGluc3RydWN0aW9uczp0fSl7dGhpcy5jb250b3Vycz1lO3RoaXMuaW5zdHJ1Y3Rpb25zPXR9c3RhdGljIHBhcnNlKGUsdCxpKXtjb25zdCBhPVtdO2ZvcihsZXQgcz0wO3M8aTtzKyspe2NvbnN0IGk9dC5nZXRVaW50MTYoZSk7ZSs9MjthLnB1c2goaSl9Y29uc3Qgcz1hW2ktMV0rMSxyPXQuZ2V0VWludDE2KGUpO2UrPTI7Y29uc3Qgbj1uZXcgVWludDhBcnJheSh0KS5zbGljZShlLGUrcik7ZSs9cjtjb25zdCBvPVtdO2ZvcihsZXQgaT0wO2k8cztlKyssaSsrKXtsZXQgYT10LmdldFVpbnQ4KGUpO28ucHVzaChhKTtpZig4JmEpe2NvbnN0IHM9dC5nZXRVaW50OCgrK2UpO2FePTg7Zm9yKGxldCBlPTA7ZTxzO2UrKylvLnB1c2goYSk7aSs9c319Y29uc3QgZz1bXTtsZXQgYz1bXSxDPVtdLGg9W107Y29uc3QgbD1bXTtsZXQgUT0wLEU9MDtmb3IobGV0IGk9MDtpPHM7aSsrKXtjb25zdCBzPW9baV07aWYoMiZzKXtjb25zdCBpPXQuZ2V0VWludDgoZSsrKTtFKz0xNiZzP2k6LWk7Yy5wdXNoKEUpfWVsc2UgaWYoMTYmcyljLnB1c2goRSk7ZWxzZXtFKz10LmdldEludDE2KGUpO2UrPTI7Yy5wdXNoKEUpfWlmKGFbUV09PT1pKXtRKys7Zy5wdXNoKGMpO2M9W119fUU9MDtRPTA7Zm9yKGxldCBpPTA7aTxzO2krKyl7Y29uc3Qgcz1vW2ldO2lmKDQmcyl7Y29uc3QgaT10LmdldFVpbnQ4KGUrKyk7RSs9MzImcz9pOi1pO0MucHVzaChFKX1lbHNlIGlmKDMyJnMpQy5wdXNoKEUpO2Vsc2V7RSs9dC5nZXRJbnQxNihlKTtlKz0yO0MucHVzaChFKX1oLnB1c2goMSZzfDY0JnMpO2lmKGFbUV09PT1pKXtjPWdbUV07USsrO2wucHVzaChuZXcgQ29udG91cih7ZmxhZ3M6aCx4Q29vcmRpbmF0ZXM6Yyx5Q29vcmRpbmF0ZXM6Q30pKTtDPVtdO2g9W119fXJldHVybiBuZXcgU2ltcGxlR2x5cGgoe2NvbnRvdXJzOmwsaW5zdHJ1Y3Rpb25zOm59KX1nZXRTaXplKCl7bGV0IGU9Mip0aGlzLmNvbnRvdXJzLmxlbmd0aCsyK3RoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCx0PTAsaT0wO2Zvcihjb25zdCBhIG9mIHRoaXMuY29udG91cnMpe2UrPWEuZmxhZ3MubGVuZ3RoO2ZvcihsZXQgcz0wLHI9YS54Q29vcmRpbmF0ZXMubGVuZ3RoO3M8cjtzKyspe2NvbnN0IHI9YS54Q29vcmRpbmF0ZXNbc10sbj1hLnlDb29yZGluYXRlc1tzXTtsZXQgbz1NYXRoLmFicyhyLXQpO28+MjU1P2UrPTI6bz4wJiYoZSs9MSk7dD1yO289TWF0aC5hYnMobi1pKTtvPjI1NT9lKz0yOm8+MCYmKGUrPTEpO2k9bn19cmV0dXJuIGV9d3JpdGUoZSx0KXtjb25zdCBpPWUsYT1bXSxzPVtdLHI9W107bGV0IG49MCxvPTA7Zm9yKGNvbnN0IGkgb2YgdGhpcy5jb250b3Vycyl7Zm9yKGxldCBlPTAsdD1pLnhDb29yZGluYXRlcy5sZW5ndGg7ZTx0O2UrKyl7bGV0IHQ9aS5mbGFnc1tlXTtjb25zdCBnPWkueENvb3JkaW5hdGVzW2VdO2xldCBjPWctbjtpZigwPT09Yyl7dHw9MTY7YS5wdXNoKDApfWVsc2V7Y29uc3QgZT1NYXRoLmFicyhjKTtpZihlPD0yNTUpe3R8PWM+PTA/MTg6MjthLnB1c2goZSl9ZWxzZSBhLnB1c2goYyl9bj1nO2NvbnN0IEM9aS55Q29vcmRpbmF0ZXNbZV07Yz1DLW87aWYoMD09PWMpe3R8PTMyO3MucHVzaCgwKX1lbHNle2NvbnN0IGU9TWF0aC5hYnMoYyk7aWYoZTw9MjU1KXt0fD1jPj0wPzM2OjQ7cy5wdXNoKGUpfWVsc2Ugcy5wdXNoKGMpfW89QztyLnB1c2godCl9dC5zZXRVaW50MTYoZSxhLmxlbmd0aC0xKTtlKz0yfXQuc2V0VWludDE2KGUsdGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoKTtlKz0yO2lmKHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCl7bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsMCx0LmJ1ZmZlci5ieXRlTGVuZ3RoKS5zZXQodGhpcy5pbnN0cnVjdGlvbnMsZSk7ZSs9dGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RofWZvcihjb25zdCBpIG9mIHIpdC5zZXRVaW50OChlKyssaSk7Zm9yKGxldCBpPTAscz1hLmxlbmd0aDtpPHM7aSsrKXtjb25zdCBzPWFbaV0sbj1yW2ldO2lmKDImbil0LnNldFVpbnQ4KGUrKyxzKTtlbHNlIGlmKCEoMTYmbikpe3Quc2V0SW50MTYoZSxzKTtlKz0yfX1mb3IobGV0IGk9MCxhPXMubGVuZ3RoO2k8YTtpKyspe2NvbnN0IGE9c1tpXSxuPXJbaV07aWYoNCZuKXQuc2V0VWludDgoZSsrLGEpO2Vsc2UgaWYoISgzMiZuKSl7dC5zZXRJbnQxNihlLGEpO2UrPTJ9fXJldHVybiBlLWl9c2NhbGUoZSx0KXtmb3IoY29uc3QgaSBvZiB0aGlzLmNvbnRvdXJzKWlmKDAhPT1pLnhDb29yZGluYXRlcy5sZW5ndGgpZm9yKGxldCBhPTAscz1pLnhDb29yZGluYXRlcy5sZW5ndGg7YTxzO2ErKylpLnhDb29yZGluYXRlc1thXT1NYXRoLnJvdW5kKGUrKGkueENvb3JkaW5hdGVzW2FdLWUpKnQpfX1jbGFzcyBDb21wb3NpdGVHbHlwaHtjb25zdHJ1Y3Rvcih7ZmxhZ3M6ZSxnbHlwaEluZGV4OnQsYXJndW1lbnQxOmksYXJndW1lbnQyOmEsdHJhbnNmOnMsaW5zdHJ1Y3Rpb25zOnJ9KXt0aGlzLmZsYWdzPWU7dGhpcy5nbHlwaEluZGV4PXQ7dGhpcy5hcmd1bWVudDE9aTt0aGlzLmFyZ3VtZW50Mj1hO3RoaXMudHJhbnNmPXM7dGhpcy5pbnN0cnVjdGlvbnM9cn1zdGF0aWMgcGFyc2UoZSx0KXtjb25zdCBpPWUsYT1bXTtsZXQgcz10LmdldFVpbnQxNihlKTtjb25zdCByPXQuZ2V0VWludDE2KGUrMik7ZSs9NDtsZXQgbixvO2lmKDEmcyl7aWYoMiZzKXtuPXQuZ2V0SW50MTYoZSk7bz10LmdldEludDE2KGUrMil9ZWxzZXtuPXQuZ2V0VWludDE2KGUpO289dC5nZXRVaW50MTYoZSsyKX1lKz00O3NePTF9ZWxzZXtpZigyJnMpe249dC5nZXRJbnQ4KGUpO289dC5nZXRJbnQ4KGUrMSl9ZWxzZXtuPXQuZ2V0VWludDgoZSk7bz10LmdldFVpbnQ4KGUrMSl9ZSs9Mn1pZig4JnMpe2EucHVzaCh0LmdldFVpbnQxNihlKSk7ZSs9Mn1lbHNlIGlmKDY0JnMpe2EucHVzaCh0LmdldFVpbnQxNihlKSx0LmdldFVpbnQxNihlKzIpKTtlKz00fWVsc2UgaWYoMTI4JnMpe2EucHVzaCh0LmdldFVpbnQxNihlKSx0LmdldFVpbnQxNihlKzIpLHQuZ2V0VWludDE2KGUrNCksdC5nZXRVaW50MTYoZSs2KSk7ZSs9OH1sZXQgZz1udWxsO2lmKDI1NiZzKXtjb25zdCBpPXQuZ2V0VWludDE2KGUpO2UrPTI7Zz1uZXcgVWludDhBcnJheSh0KS5zbGljZShlLGUraSk7ZSs9aX1yZXR1cm5bZS1pLG5ldyBDb21wb3NpdGVHbHlwaCh7ZmxhZ3M6cyxnbHlwaEluZGV4OnIsYXJndW1lbnQxOm4sYXJndW1lbnQyOm8sdHJhbnNmOmEsaW5zdHJ1Y3Rpb25zOmd9KV19Z2V0U2l6ZSgpe2xldCBlPTQrMip0aGlzLnRyYW5zZi5sZW5ndGg7MjU2JnRoaXMuZmxhZ3MmJihlKz0yK3RoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCk7ZSs9MjsyJnRoaXMuZmxhZ3M/dGhpcy5hcmd1bWVudDE+PS0xMjgmJnRoaXMuYXJndW1lbnQxPD0xMjcmJnRoaXMuYXJndW1lbnQyPj0tMTI4JiZ0aGlzLmFyZ3VtZW50Mjw9MTI3fHwoZSs9Mik6dGhpcy5hcmd1bWVudDE+PTAmJnRoaXMuYXJndW1lbnQxPD0yNTUmJnRoaXMuYXJndW1lbnQyPj0wJiZ0aGlzLmFyZ3VtZW50Mjw9MjU1fHwoZSs9Mik7cmV0dXJuIGV9d3JpdGUoZSx0KXtjb25zdCBpPWU7MiZ0aGlzLmZsYWdzP3RoaXMuYXJndW1lbnQxPj0tMTI4JiZ0aGlzLmFyZ3VtZW50MTw9MTI3JiZ0aGlzLmFyZ3VtZW50Mj49LTEyOCYmdGhpcy5hcmd1bWVudDI8PTEyN3x8KHRoaXMuZmxhZ3N8PTEpOnRoaXMuYXJndW1lbnQxPj0wJiZ0aGlzLmFyZ3VtZW50MTw9MjU1JiZ0aGlzLmFyZ3VtZW50Mj49MCYmdGhpcy5hcmd1bWVudDI8PTI1NXx8KHRoaXMuZmxhZ3N8PTEpO3Quc2V0VWludDE2KGUsdGhpcy5mbGFncyk7dC5zZXRVaW50MTYoZSsyLHRoaXMuZ2x5cGhJbmRleCk7ZSs9NDtpZigxJnRoaXMuZmxhZ3Mpe2lmKDImdGhpcy5mbGFncyl7dC5zZXRJbnQxNihlLHRoaXMuYXJndW1lbnQxKTt0LnNldEludDE2KGUrMix0aGlzLmFyZ3VtZW50Mil9ZWxzZXt0LnNldFVpbnQxNihlLHRoaXMuYXJndW1lbnQxKTt0LnNldFVpbnQxNihlKzIsdGhpcy5hcmd1bWVudDIpfWUrPTR9ZWxzZXt0LnNldFVpbnQ4KGUsdGhpcy5hcmd1bWVudDEpO3Quc2V0VWludDgoZSsxLHRoaXMuYXJndW1lbnQyKTtlKz0yfWlmKDI1NiZ0aGlzLmZsYWdzKXt0LnNldFVpbnQxNihlLHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCk7ZSs9MjtpZih0aGlzLmluc3RydWN0aW9ucy5sZW5ndGgpe25ldyBVaW50OEFycmF5KHQuYnVmZmVyLDAsdC5idWZmZXIuYnl0ZUxlbmd0aCkuc2V0KHRoaXMuaW5zdHJ1Y3Rpb25zLGUpO2UrPXRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aH19cmV0dXJuIGUtaX1zY2FsZShlLHQpe319ZnVuY3Rpb24gd3JpdGVJbnQxNihlLHQsaSl7ZVt0XT1pPj44JjI1NTtlW3QrMV09MjU1Jml9ZnVuY3Rpb24gd3JpdGVJbnQzMihlLHQsaSl7ZVt0XT1pPj4yNCYyNTU7ZVt0KzFdPWk+PjE2JjI1NTtlW3QrMl09aT4+OCYyNTU7ZVt0KzNdPTI1NSZpfWZ1bmN0aW9uIHdyaXRlRGF0YShlLHQsaSl7aWYoaSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpZS5zZXQoaSx0KTtlbHNlIGlmKCJzdHJpbmciPT10eXBlb2YgaSlmb3IobGV0IGE9MCxzPWkubGVuZ3RoO2E8czthKyspZVt0KytdPTI1NSZpLmNoYXJDb2RlQXQoYSk7ZWxzZSBmb3IoY29uc3QgYSBvZiBpKWVbdCsrXT0yNTUmYX1jbGFzcyBPcGVuVHlwZUZpbGVCdWlsZGVye2NvbnN0cnVjdG9yKGUpe3RoaXMuc2ZudD1lO3RoaXMudGFibGVzPU9iamVjdC5jcmVhdGUobnVsbCl9c3RhdGljIGdldFNlYXJjaFBhcmFtcyhlLHQpe2xldCBpPTEsYT0wO2Zvcig7KGleZSk+aTspe2k8PD0xO2ErK31jb25zdCBzPWkqdDtyZXR1cm57cmFuZ2U6cyxlbnRyeTphLHJhbmdlU2hpZnQ6dCplLXN9fXRvQXJyYXkoKXtsZXQgZT10aGlzLnNmbnQ7Y29uc3QgdD10aGlzLnRhYmxlcyxpPU9iamVjdC5rZXlzKHQpO2kuc29ydCgpO2NvbnN0IGE9aS5sZW5ndGg7bGV0IHMscixuLG8sZyxjPTEyKzE2KmE7Y29uc3QgQz1bY107Zm9yKHM9MDtzPGE7cysrKXtvPXRbaVtzXV07Yys9KG8ubGVuZ3RoKzMmLTQpPj4+MDtDLnB1c2goYyl9Y29uc3QgaD1uZXcgVWludDhBcnJheShjKTtmb3Iocz0wO3M8YTtzKyspe289dFtpW3NdXTt3cml0ZURhdGEoaCxDW3NdLG8pfSJ0cnVlIj09PWUmJihlPXN0cmluZzMyKDY1NTM2KSk7aFswXT0yNTUmZS5jaGFyQ29kZUF0KDApO2hbMV09MjU1JmUuY2hhckNvZGVBdCgxKTtoWzJdPTI1NSZlLmNoYXJDb2RlQXQoMik7aFszXT0yNTUmZS5jaGFyQ29kZUF0KDMpO3dyaXRlSW50MTYoaCw0LGEpO2NvbnN0IGw9T3BlblR5cGVGaWxlQnVpbGRlci5nZXRTZWFyY2hQYXJhbXMoYSwxNik7d3JpdGVJbnQxNihoLDYsbC5yYW5nZSk7d3JpdGVJbnQxNihoLDgsbC5lbnRyeSk7d3JpdGVJbnQxNihoLDEwLGwucmFuZ2VTaGlmdCk7Yz0xMjtmb3Iocz0wO3M8YTtzKyspe2c9aVtzXTtoW2NdPTI1NSZnLmNoYXJDb2RlQXQoMCk7aFtjKzFdPTI1NSZnLmNoYXJDb2RlQXQoMSk7aFtjKzJdPTI1NSZnLmNoYXJDb2RlQXQoMik7aFtjKzNdPTI1NSZnLmNoYXJDb2RlQXQoMyk7bGV0IGU9MDtmb3Iocj1DW3NdLG49Q1tzKzFdO3I8bjtyKz00KXtlPWUrcmVhZFVpbnQzMihoLHIpPj4+MH13cml0ZUludDMyKGgsYys0LGUpO3dyaXRlSW50MzIoaCxjKzgsQ1tzXSk7d3JpdGVJbnQzMihoLGMrMTIsdFtnXS5sZW5ndGgpO2MrPTE2fXJldHVybiBofWFkZFRhYmxlKGUsdCl7aWYoZSBpbiB0aGlzLnRhYmxlcyl0aHJvdyBuZXcgRXJyb3IoIlRhYmxlICIrZSsiIGFscmVhZHkgZXhpc3RzIik7dGhpcy50YWJsZXNbZV09dH19Y29uc3QgdGE9WzRdLGlhPVs1XSxhYT1bNl0sc2E9WzddLHJhPVs4XSxuYT1bMTIsMzVdLG9hPVsxNF0sZ2E9WzIxXSxJYT1bMjJdLGNhPVszMF0sQ2E9WzMxXTtjbGFzcyBUeXBlMUNoYXJTdHJpbmd7Y29uc3RydWN0b3IoKXt0aGlzLndpZHRoPTA7dGhpcy5sc2I9MDt0aGlzLmZsZXhpbmc9ITE7dGhpcy5vdXRwdXQ9W107dGhpcy5zdGFjaz1bXX1jb252ZXJ0KGUsdCxpKXtjb25zdCBhPWUubGVuZ3RoO2xldCBzLHIsbixvPSExO2ZvcihsZXQgZz0wO2c8YTtnKyspe2xldCBhPWVbZ107aWYoYTwzMil7MTI9PT1hJiYoYT0oYTw8OCkrZVsrK2ddKTtzd2l0Y2goYSl7Y2FzZSAxOmNhc2UgMzpjYXNlIDk6Y2FzZSAzMDcyOmNhc2UgMzA3MzpjYXNlIDMwNzQ6Y2FzZSAzMTA1OnRoaXMuc3RhY2s9W107YnJlYWs7Y2FzZSA0OmlmKHRoaXMuZmxleGluZyl7aWYodGhpcy5zdGFjay5sZW5ndGg8MSl7bz0hMDticmVha31jb25zdCBlPXRoaXMuc3RhY2sucG9wKCk7dGhpcy5zdGFjay5wdXNoKDAsZSk7YnJlYWt9bz10aGlzLmV4ZWN1dGVDb21tYW5kKDEsdGEpO2JyZWFrO2Nhc2UgNTpvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoMixpYSk7YnJlYWs7Y2FzZSA2Om89dGhpcy5leGVjdXRlQ29tbWFuZCgxLGFhKTticmVhaztjYXNlIDc6bz10aGlzLmV4ZWN1dGVDb21tYW5kKDEsc2EpO2JyZWFrO2Nhc2UgODpvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoNixyYSk7YnJlYWs7Y2FzZSAxMDppZih0aGlzLnN0YWNrLmxlbmd0aDwxKXtvPSEwO2JyZWFrfW49dGhpcy5zdGFjay5wb3AoKTtpZighdFtuXSl7bz0hMDticmVha31vPXRoaXMuY29udmVydCh0W25dLHQsaSk7YnJlYWs7Y2FzZSAxMTpyZXR1cm4gbztjYXNlIDEzOmlmKHRoaXMuc3RhY2subGVuZ3RoPDIpe289ITA7YnJlYWt9cz10aGlzLnN0YWNrLnBvcCgpO3I9dGhpcy5zdGFjay5wb3AoKTt0aGlzLmxzYj1yO3RoaXMud2lkdGg9czt0aGlzLnN0YWNrLnB1c2gocyxyKTtvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoMixJYSk7YnJlYWs7Y2FzZSAxNDp0aGlzLm91dHB1dC5wdXNoKG9hWzBdKTticmVhaztjYXNlIDIxOmlmKHRoaXMuZmxleGluZylicmVhaztvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoMixnYSk7YnJlYWs7Y2FzZSAyMjppZih0aGlzLmZsZXhpbmcpe3RoaXMuc3RhY2sucHVzaCgwKTticmVha31vPXRoaXMuZXhlY3V0ZUNvbW1hbmQoMSxJYSk7YnJlYWs7Y2FzZSAzMDpvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoNCxjYSk7YnJlYWs7Y2FzZSAzMTpvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoNCxDYSk7YnJlYWs7Y2FzZSAzMDc4OmlmKGkpe2NvbnN0IGU9dGhpcy5zdGFjay5hdCgtNSk7dGhpcy5zZWFjPXRoaXMuc3RhY2suc3BsaWNlKC00LDQpO3RoaXMuc2VhY1swXSs9dGhpcy5sc2ItZTtvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoMCxvYSl9ZWxzZSBvPXRoaXMuZXhlY3V0ZUNvbW1hbmQoNCxvYSk7YnJlYWs7Y2FzZSAzMDc5OmlmKHRoaXMuc3RhY2subGVuZ3RoPDQpe289ITA7YnJlYWt9dGhpcy5zdGFjay5wb3AoKTtzPXRoaXMuc3RhY2sucG9wKCk7Y29uc3QgZT10aGlzLnN0YWNrLnBvcCgpO3I9dGhpcy5zdGFjay5wb3AoKTt0aGlzLmxzYj1yO3RoaXMud2lkdGg9czt0aGlzLnN0YWNrLnB1c2gocyxyLGUpO289dGhpcy5leGVjdXRlQ29tbWFuZCgzLGdhKTticmVhaztjYXNlIDMwODQ6aWYodGhpcy5zdGFjay5sZW5ndGg8Mil7bz0hMDticmVha31jb25zdCBnPXRoaXMuc3RhY2sucG9wKCksYz10aGlzLnN0YWNrLnBvcCgpO3RoaXMuc3RhY2sucHVzaChjL2cpO2JyZWFrO2Nhc2UgMzA4ODppZih0aGlzLnN0YWNrLmxlbmd0aDwyKXtvPSEwO2JyZWFrfW49dGhpcy5zdGFjay5wb3AoKTtjb25zdCBDPXRoaXMuc3RhY2sucG9wKCk7aWYoMD09PW4mJjM9PT1DKXtjb25zdCBlPXRoaXMuc3RhY2suc3BsaWNlKC0xNywxNyk7dGhpcy5zdGFjay5wdXNoKGVbMl0rZVswXSxlWzNdK2VbMV0sZVs0XSxlWzVdLGVbNl0sZVs3XSxlWzhdLGVbOV0sZVsxMF0sZVsxMV0sZVsxMl0sZVsxM10sZVsxNF0pO289dGhpcy5leGVjdXRlQ29tbWFuZCgxMyxuYSwhMCk7dGhpcy5mbGV4aW5nPSExO3RoaXMuc3RhY2sucHVzaChlWzE1XSxlWzE2XSl9ZWxzZSAxPT09biYmMD09PUMmJih0aGlzLmZsZXhpbmc9ITApO2JyZWFrO2Nhc2UgMzA4OTpicmVhaztkZWZhdWx0Ondhcm4oJ1Vua25vd24gdHlwZSAxIGNoYXJzdHJpbmcgY29tbWFuZCBvZiAiJythKyciJyl9aWYobylicmVha31lbHNle2E8PTI0Nj9hLT0xMzk6YT1hPD0yNTA/MjU2KihhLTI0NykrZVsrK2ddKzEwODphPD0yNTQ/LTI1NiooYS0yNTEpLWVbKytnXS0xMDg6KDI1NSZlWysrZ10pPDwyNHwoMjU1JmVbKytnXSk8PDE2fCgyNTUmZVsrK2ddKTw8OHwoMjU1JmVbKytnXSk8PDA7dGhpcy5zdGFjay5wdXNoKGEpfX1yZXR1cm4gb31leGVjdXRlQ29tbWFuZChlLHQsaSl7Y29uc3QgYT10aGlzLnN0YWNrLmxlbmd0aDtpZihlPmEpcmV0dXJuITA7Y29uc3Qgcz1hLWU7Zm9yKGxldCBlPXM7ZTxhO2UrKyl7bGV0IHQ9dGhpcy5zdGFja1tlXTtpZihOdW1iZXIuaXNJbnRlZ2VyKHQpKXRoaXMub3V0cHV0LnB1c2goMjgsdD4+OCYyNTUsMjU1JnQpO2Vsc2V7dD02NTUzNip0fDA7dGhpcy5vdXRwdXQucHVzaCgyNTUsdD4+MjQmMjU1LHQ+PjE2JjI1NSx0Pj44JjI1NSwyNTUmdCl9fXRoaXMub3V0cHV0LnB1c2goLi4udCk7aT90aGlzLnN0YWNrLnNwbGljZShzLGUpOnRoaXMuc3RhY2subGVuZ3RoPTA7cmV0dXJuITF9fWZ1bmN0aW9uIGlzSGV4RGlnaXQoZSl7cmV0dXJuIGU+PTQ4JiZlPD01N3x8ZT49NjUmJmU8PTcwfHxlPj05NyYmZTw9MTAyfWZ1bmN0aW9uIGRlY3J5cHQoZSx0LGkpe2lmKGk+PWUubGVuZ3RoKXJldHVybiBuZXcgVWludDhBcnJheSgwKTtsZXQgYSxzLHI9MHx0O2ZvcihhPTA7YTxpO2ErKylyPTUyODQ1KihlW2FdK3IpKzIyNzE5JjY1NTM1O2NvbnN0IG49ZS5sZW5ndGgtaSxvPW5ldyBVaW50OEFycmF5KG4pO2ZvcihhPWkscz0wO3M8bjthKysscysrKXtjb25zdCB0PWVbYV07b1tzXT10XnI+Pjg7cj01Mjg0NSoodCtyKSsyMjcxOSY2NTUzNX1yZXR1cm4gb31mdW5jdGlvbiBpc1NwZWNpYWwoZSl7cmV0dXJuIDQ3PT09ZXx8OTE9PT1lfHw5Mz09PWV8fDEyMz09PWV8fDEyNT09PWV8fDQwPT09ZXx8NDE9PT1lfWNsYXNzIFR5cGUxUGFyc2Vye2NvbnN0cnVjdG9yKGUsdCxpKXtpZih0KXtjb25zdCB0PWUuZ2V0Qnl0ZXMoKSxpPSEoKGlzSGV4RGlnaXQodFswXSl8fGlzV2hpdGVTcGFjZSh0WzBdKSkmJmlzSGV4RGlnaXQodFsxXSkmJmlzSGV4RGlnaXQodFsyXSkmJmlzSGV4RGlnaXQodFszXSkmJmlzSGV4RGlnaXQodFs0XSkmJmlzSGV4RGlnaXQodFs1XSkmJmlzSGV4RGlnaXQodFs2XSkmJmlzSGV4RGlnaXQodFs3XSkpO2U9bmV3IFN0cmVhbShpP2RlY3J5cHQodCw1NTY2NSw0KTpmdW5jdGlvbiBkZWNyeXB0QXNjaWkoZSx0LGkpe2xldCBhPTB8dDtjb25zdCBzPWUubGVuZ3RoLHI9bmV3IFVpbnQ4QXJyYXkocz4+PjEpO2xldCBuLG87Zm9yKG49MCxvPTA7bjxzO24rKyl7Y29uc3QgdD1lW25dO2lmKCFpc0hleERpZ2l0KHQpKWNvbnRpbnVlO24rKztsZXQgaTtmb3IoO248cyYmIWlzSGV4RGlnaXQoaT1lW25dKTspbisrO2lmKG48cyl7Y29uc3QgZT1wYXJzZUludChTdHJpbmcuZnJvbUNoYXJDb2RlKHQsaSksMTYpO3JbbysrXT1lXmE+Pjg7YT01Mjg0NSooZSthKSsyMjcxOSY2NTUzNX19cmV0dXJuIHIuc2xpY2UoaSxvKX0odCw1NTY2NSw0KSl9dGhpcy5zZWFjQW5hbHlzaXNFbmFibGVkPSEhaTt0aGlzLnN0cmVhbT1lO3RoaXMubmV4dENoYXIoKX1yZWFkTnVtYmVyQXJyYXkoKXt0aGlzLmdldFRva2VuKCk7Y29uc3QgZT1bXTtmb3IoOzspe2NvbnN0IHQ9dGhpcy5nZXRUb2tlbigpO2lmKG51bGw9PT10fHwiXSI9PT10fHwifSI9PT10KWJyZWFrO2UucHVzaChwYXJzZUZsb2F0KHR8fDApKX1yZXR1cm4gZX1yZWFkTnVtYmVyKCl7Y29uc3QgZT10aGlzLmdldFRva2VuKCk7cmV0dXJuIHBhcnNlRmxvYXQoZXx8MCl9cmVhZEludCgpe2NvbnN0IGU9dGhpcy5nZXRUb2tlbigpO3JldHVybiAwfHBhcnNlSW50KGV8fDAsMTApfXJlYWRCb29sZWFuKCl7cmV0dXJuInRydWUiPT09dGhpcy5nZXRUb2tlbigpPzE6MH1uZXh0Q2hhcigpe3JldHVybiB0aGlzLmN1cnJlbnRDaGFyPXRoaXMuc3RyZWFtLmdldEJ5dGUoKX1wcmV2Q2hhcigpe3RoaXMuc3RyZWFtLnNraXAoLTIpO3JldHVybiB0aGlzLmN1cnJlbnRDaGFyPXRoaXMuc3RyZWFtLmdldEJ5dGUoKX1nZXRUb2tlbigpe2xldCBlPSExLHQ9dGhpcy5jdXJyZW50Q2hhcjtmb3IoOzspe2lmKC0xPT09dClyZXR1cm4gbnVsbDtpZihlKTEwIT09dCYmMTMhPT10fHwoZT0hMSk7ZWxzZSBpZigzNz09PXQpZT0hMDtlbHNlIGlmKCFpc1doaXRlU3BhY2UodCkpYnJlYWs7dD10aGlzLm5leHRDaGFyKCl9aWYoaXNTcGVjaWFsKHQpKXt0aGlzLm5leHRDaGFyKCk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodCl9bGV0IGk9IiI7ZG97aSs9U3RyaW5nLmZyb21DaGFyQ29kZSh0KTt0PXRoaXMubmV4dENoYXIoKX13aGlsZSh0Pj0wJiYhaXNXaGl0ZVNwYWNlKHQpJiYhaXNTcGVjaWFsKHQpKTtyZXR1cm4gaX1yZWFkQ2hhclN0cmluZ3MoZSx0KXtyZXR1cm4tMT09PXQ/ZTpkZWNyeXB0KGUsNDMzMCx0KX1leHRyYWN0Rm9udFByb2dyYW0oZSl7Y29uc3QgdD10aGlzLnN0cmVhbSxpPVtdLGE9W10scz1PYmplY3QuY3JlYXRlKG51bGwpO3MubGVuSVY9NDtjb25zdCByPXtzdWJyczpbXSxjaGFyc3RyaW5nczpbXSxwcm9wZXJ0aWVzOntwcml2YXRlRGF0YTpzfX07bGV0IG4sbyxnLGM7Zm9yKDtudWxsIT09KG49dGhpcy5nZXRUb2tlbigpKTspaWYoIi8iPT09bil7bj10aGlzLmdldFRva2VuKCk7c3dpdGNoKG4pe2Nhc2UiQ2hhclN0cmluZ3MiOnRoaXMuZ2V0VG9rZW4oKTt0aGlzLmdldFRva2VuKCk7dGhpcy5nZXRUb2tlbigpO3RoaXMuZ2V0VG9rZW4oKTtmb3IoOzspe249dGhpcy5nZXRUb2tlbigpO2lmKG51bGw9PT1ufHwiZW5kIj09PW4pYnJlYWs7aWYoIi8iIT09biljb250aW51ZTtjb25zdCBlPXRoaXMuZ2V0VG9rZW4oKTtvPXRoaXMucmVhZEludCgpO3RoaXMuZ2V0VG9rZW4oKTtnPW8+MD90LmdldEJ5dGVzKG8pOm5ldyBVaW50OEFycmF5KDApO2M9ci5wcm9wZXJ0aWVzLnByaXZhdGVEYXRhLmxlbklWO2NvbnN0IGk9dGhpcy5yZWFkQ2hhclN0cmluZ3MoZyxjKTt0aGlzLm5leHRDaGFyKCk7bj10aGlzLmdldFRva2VuKCk7Im5vYWNjZXNzIj09PW4/dGhpcy5nZXRUb2tlbigpOiIvIj09PW4mJnRoaXMucHJldkNoYXIoKTthLnB1c2goe2dseXBoOmUsZW5jb2RlZDppfSl9YnJlYWs7Y2FzZSJTdWJycyI6dGhpcy5yZWFkSW50KCk7dGhpcy5nZXRUb2tlbigpO2Zvcig7ImR1cCI9PT10aGlzLmdldFRva2VuKCk7KXtjb25zdCBlPXRoaXMucmVhZEludCgpO289dGhpcy5yZWFkSW50KCk7dGhpcy5nZXRUb2tlbigpO2c9bz4wP3QuZ2V0Qnl0ZXMobyk6bmV3IFVpbnQ4QXJyYXkoMCk7Yz1yLnByb3BlcnRpZXMucHJpdmF0ZURhdGEubGVuSVY7Y29uc3QgYT10aGlzLnJlYWRDaGFyU3RyaW5ncyhnLGMpO3RoaXMubmV4dENoYXIoKTtuPXRoaXMuZ2V0VG9rZW4oKTsibm9hY2Nlc3MiPT09biYmdGhpcy5nZXRUb2tlbigpO2lbZV09YX1icmVhaztjYXNlIkJsdWVWYWx1ZXMiOmNhc2UiT3RoZXJCbHVlcyI6Y2FzZSJGYW1pbHlCbHVlcyI6Y2FzZSJGYW1pbHlPdGhlckJsdWVzIjpjb25zdCBlPXRoaXMucmVhZE51bWJlckFycmF5KCk7ZS5sZW5ndGg+MCYmZS5sZW5ndGgsMDticmVhaztjYXNlIlN0ZW1TbmFwSCI6Y2FzZSJTdGVtU25hcFYiOnIucHJvcGVydGllcy5wcml2YXRlRGF0YVtuXT10aGlzLnJlYWROdW1iZXJBcnJheSgpO2JyZWFrO2Nhc2UiU3RkSFciOmNhc2UiU3RkVlciOnIucHJvcGVydGllcy5wcml2YXRlRGF0YVtuXT10aGlzLnJlYWROdW1iZXJBcnJheSgpWzBdO2JyZWFrO2Nhc2UiQmx1ZVNoaWZ0IjpjYXNlImxlbklWIjpjYXNlIkJsdWVGdXp6IjpjYXNlIkJsdWVTY2FsZSI6Y2FzZSJMYW5ndWFnZUdyb3VwIjpyLnByb3BlcnRpZXMucHJpdmF0ZURhdGFbbl09dGhpcy5yZWFkTnVtYmVyKCk7YnJlYWs7Y2FzZSJFeHBhbnNpb25GYWN0b3IiOnIucHJvcGVydGllcy5wcml2YXRlRGF0YVtuXT10aGlzLnJlYWROdW1iZXIoKXx8LjA2O2JyZWFrO2Nhc2UiRm9yY2VCb2xkIjpyLnByb3BlcnRpZXMucHJpdmF0ZURhdGFbbl09dGhpcy5yZWFkQm9vbGVhbigpfX1mb3IoY29uc3R7ZW5jb2RlZDp0LGdseXBoOnN9b2YgYSl7Y29uc3QgYT1uZXcgVHlwZTFDaGFyU3RyaW5nLG49YS5jb252ZXJ0KHQsaSx0aGlzLnNlYWNBbmFseXNpc0VuYWJsZWQpO2xldCBvPWEub3V0cHV0O24mJihvPVsxNF0pO2NvbnN0IGc9e2dseXBoTmFtZTpzLGNoYXJzdHJpbmc6byx3aWR0aDphLndpZHRoLGxzYjphLmxzYixzZWFjOmEuc2VhY307Ii5ub3RkZWYiPT09cz9yLmNoYXJzdHJpbmdzLnVuc2hpZnQoZyk6ci5jaGFyc3RyaW5ncy5wdXNoKGcpO2lmKGUuYnVpbHRJbkVuY29kaW5nKXtjb25zdCB0PWUuYnVpbHRJbkVuY29kaW5nLmluZGV4T2Yocyk7dD4tMSYmdm9pZCAwPT09ZS53aWR0aHNbdF0mJnQ+PWUuZmlyc3RDaGFyJiZ0PD1lLmxhc3RDaGFyJiYoZS53aWR0aHNbdF09YS53aWR0aCl9fXJldHVybiByfWV4dHJhY3RGb250SGVhZGVyKGUpe2xldCB0O2Zvcig7bnVsbCE9PSh0PXRoaXMuZ2V0VG9rZW4oKSk7KWlmKCIvIj09PXQpe3Q9dGhpcy5nZXRUb2tlbigpO3N3aXRjaCh0KXtjYXNlIkZvbnRNYXRyaXgiOmNvbnN0IGk9dGhpcy5yZWFkTnVtYmVyQXJyYXkoKTtlLmZvbnRNYXRyaXg9aTticmVhaztjYXNlIkVuY29kaW5nIjpjb25zdCBhPXRoaXMuZ2V0VG9rZW4oKTtsZXQgcztpZigvXlxkKyQvLnRlc3QoYSkpe3M9W107Y29uc3QgZT0wfHBhcnNlSW50KGEsMTApO3RoaXMuZ2V0VG9rZW4oKTtmb3IobGV0IGk9MDtpPGU7aSsrKXt0PXRoaXMuZ2V0VG9rZW4oKTtmb3IoOyJkdXAiIT09dCYmImRlZiIhPT10Oyl7dD10aGlzLmdldFRva2VuKCk7aWYobnVsbD09PXQpcmV0dXJufWlmKCJkZWYiPT09dClicmVhaztjb25zdCBlPXRoaXMucmVhZEludCgpO3RoaXMuZ2V0VG9rZW4oKTtjb25zdCBpPXRoaXMuZ2V0VG9rZW4oKTtzW2VdPWk7dGhpcy5nZXRUb2tlbigpfX1lbHNlIHM9Z2V0RW5jb2RpbmcoYSk7ZS5idWlsdEluRW5jb2Rpbmc9czticmVhaztjYXNlIkZvbnRCQm94Ijpjb25zdCByPXRoaXMucmVhZE51bWJlckFycmF5KCk7ZS5hc2NlbnQ9TWF0aC5tYXgoclszXSxyWzFdKTtlLmRlc2NlbnQ9TWF0aC5taW4oclsxXSxyWzNdKTtlLmFzY2VudFNjYWxlZD0hMH19fX1mdW5jdGlvbiBmaW5kQmxvY2soZSx0LGkpe2NvbnN0IGE9ZS5sZW5ndGgscz10Lmxlbmd0aCxyPWEtcztsZXQgbj1pLG89ITE7Zm9yKDtuPHI7KXtsZXQgaT0wO2Zvcig7aTxzJiZlW24raV09PT10W2ldOylpKys7aWYoaT49cyl7bis9aTtmb3IoO248YSYmaXNXaGl0ZVNwYWNlKGVbbl0pOyluKys7bz0hMDticmVha31uKyt9cmV0dXJue2ZvdW5kOm8sbGVuZ3RoOm59fWNsYXNzIFR5cGUxRm9udHtjb25zdHJ1Y3RvcihlLHQsaSl7bGV0IGE9aS5sZW5ndGgxLHM9aS5sZW5ndGgyLHI9dC5wZWVrQnl0ZXMoNik7Y29uc3Qgbj0xMjg9PT1yWzBdJiYxPT09clsxXTtpZihuKXt0LnNraXAoNik7YT1yWzVdPDwyNHxyWzRdPDwxNnxyWzNdPDw4fHJbMl19Y29uc3Qgbz1mdW5jdGlvbiBnZXRIZWFkZXJCbG9jayhlLHQpe2NvbnN0IGk9WzEwMSwxMDEsMTIwLDEwMSw5OV0sYT1lLnBvcztsZXQgcyxyLG4sbzt0cnl7cz1lLmdldEJ5dGVzKHQpO3I9cy5sZW5ndGh9Y2F0Y2h7fWlmKHI9PT10KXtuPWZpbmRCbG9jayhzLGksdC0yKmkubGVuZ3RoKTtpZihuLmZvdW5kJiZuLmxlbmd0aD09PXQpcmV0dXJue3N0cmVhbTpuZXcgU3RyZWFtKHMpLGxlbmd0aDp0fX13YXJuKCdJbnZhbGlkICJMZW5ndGgxIiBwcm9wZXJ0eSBpbiBUeXBlMSBmb250IC0tIHRyeWluZyB0byByZWNvdmVyLicpO2UucG9zPWE7Zm9yKDs7KXtuPWZpbmRCbG9jayhlLnBlZWtCeXRlcygyMDQ4KSxpLDApO2lmKDA9PT1uLmxlbmd0aClicmVhaztlLnBvcys9bi5sZW5ndGg7aWYobi5mb3VuZCl7bz1lLnBvcy1hO2JyZWFrfX1lLnBvcz1hO2lmKG8pcmV0dXJue3N0cmVhbTpuZXcgU3RyZWFtKGUuZ2V0Qnl0ZXMobykpLGxlbmd0aDpvfTt3YXJuKCdVbmFibGUgdG8gcmVjb3ZlciAiTGVuZ3RoMSIgcHJvcGVydHkgaW4gVHlwZTEgZm9udCAtLSB1c2luZyBhcyBpcy4nKTtyZXR1cm57c3RyZWFtOm5ldyBTdHJlYW0oZS5nZXRCeXRlcyh0KSksbGVuZ3RoOnR9fSh0LGEpO25ldyBUeXBlMVBhcnNlcihvLnN0cmVhbSwhMSxZaSkuZXh0cmFjdEZvbnRIZWFkZXIoaSk7aWYobil7cj10LmdldEJ5dGVzKDYpO3M9cls1XTw8MjR8cls0XTw8MTZ8clszXTw8OHxyWzJdfWNvbnN0IGc9ZnVuY3Rpb24gZ2V0RWV4ZWNCbG9jayhlLHQpe2NvbnN0IGk9ZS5nZXRCeXRlcygpO2lmKDA9PT1pLmxlbmd0aCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoImdldEVleGVjQmxvY2sgLSBubyBmb250IHByb2dyYW0gZm91bmQuIik7cmV0dXJue3N0cmVhbTpuZXcgU3RyZWFtKGkpLGxlbmd0aDppLmxlbmd0aH19KHQpLGM9bmV3IFR5cGUxUGFyc2VyKGcuc3RyZWFtLCEwLFlpKS5leHRyYWN0Rm9udFByb2dyYW0oaSk7Zm9yKGNvbnN0IGUgaW4gYy5wcm9wZXJ0aWVzKWlbZV09Yy5wcm9wZXJ0aWVzW2VdO2NvbnN0IEM9Yy5jaGFyc3RyaW5ncyxoPXRoaXMuZ2V0VHlwZTJDaGFyc3RyaW5ncyhDKSxsPXRoaXMuZ2V0VHlwZTJTdWJycyhjLnN1YnJzKTt0aGlzLmNoYXJzdHJpbmdzPUM7dGhpcy5kYXRhPXRoaXMud3JhcChlLGgsdGhpcy5jaGFyc3RyaW5ncyxsLGkpO3RoaXMuc2VhY3M9dGhpcy5nZXRTZWFjcyhjLmNoYXJzdHJpbmdzKX1nZXQgbnVtR2x5cGhzKCl7cmV0dXJuIHRoaXMuY2hhcnN0cmluZ3MubGVuZ3RoKzF9Z2V0Q2hhcnNldCgpe2NvbnN0IGU9WyIubm90ZGVmIl07Zm9yKGNvbnN0e2dseXBoTmFtZTp0fW9mIHRoaXMuY2hhcnN0cmluZ3MpZS5wdXNoKHQpO3JldHVybiBlfWdldEdseXBoTWFwcGluZyhlKXtjb25zdCB0PXRoaXMuY2hhcnN0cmluZ3M7aWYoZS5jb21wb3NpdGUpe2NvbnN0IGk9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IobGV0IGE9MCxzPXQubGVuZ3RoO2E8czthKyspe2lbZS5jTWFwLmNoYXJDb2RlT2YoYSldPWErMX1yZXR1cm4gaX1jb25zdCBpPVsiLm5vdGRlZiJdO2xldCBhLHM7Zm9yKHM9MDtzPHQubGVuZ3RoO3MrKylpLnB1c2godFtzXS5nbHlwaE5hbWUpO2NvbnN0IHI9ZS5idWlsdEluRW5jb2Rpbmc7aWYocil7YT1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdCBlIGluIHIpe3M9aS5pbmRleE9mKHJbZV0pO3M+PTAmJihhW2VdPXMpfX1yZXR1cm4gdHlwZTFGb250R2x5cGhNYXBwaW5nKGUsYSxpKX1oYXNHbHlwaElkKGUpe2lmKGU8MHx8ZT49dGhpcy5udW1HbHlwaHMpcmV0dXJuITE7aWYoMD09PWUpcmV0dXJuITA7cmV0dXJuIHRoaXMuY2hhcnN0cmluZ3NbZS0xXS5jaGFyc3RyaW5nLmxlbmd0aD4wfWdldFNlYWNzKGUpe2NvbnN0IHQ9W107Zm9yKGxldCBpPTAsYT1lLmxlbmd0aDtpPGE7aSsrKXtjb25zdCBhPWVbaV07YS5zZWFjJiYodFtpKzFdPWEuc2VhYyl9cmV0dXJuIHR9Z2V0VHlwZTJDaGFyc3RyaW5ncyhlKXtjb25zdCB0PVtdO2Zvcihjb25zdCBpIG9mIGUpdC5wdXNoKGkuY2hhcnN0cmluZyk7cmV0dXJuIHR9Z2V0VHlwZTJTdWJycyhlKXtsZXQgdD0wO2NvbnN0IGk9ZS5sZW5ndGg7dD1pPDExMzM/MTA3Omk8MzM3Njk/MTEzMTozMjc2ODtjb25zdCBhPVtdO2xldCBzO2ZvcihzPTA7czx0O3MrKylhLnB1c2goWzExXSk7Zm9yKHM9MDtzPGk7cysrKWEucHVzaChlW3NdKTtyZXR1cm4gYX13cmFwKGUsdCxpLGEscyl7Y29uc3Qgcj1uZXcgQ0ZGO3IuaGVhZGVyPW5ldyBDRkZIZWFkZXIoMSwwLDQsNCk7ci5uYW1lcz1bZV07Y29uc3Qgbj1uZXcgQ0ZGVG9wRGljdDtuLnNldEJ5TmFtZSgidmVyc2lvbiIsMzkxKTtuLnNldEJ5TmFtZSgiTm90aWNlIiwzOTIpO24uc2V0QnlOYW1lKCJGdWxsTmFtZSIsMzkzKTtuLnNldEJ5TmFtZSgiRmFtaWx5TmFtZSIsMzk0KTtuLnNldEJ5TmFtZSgiV2VpZ2h0IiwzOTUpO24uc2V0QnlOYW1lKCJFbmNvZGluZyIsbnVsbCk7bi5zZXRCeU5hbWUoIkZvbnRNYXRyaXgiLHMuZm9udE1hdHJpeCk7bi5zZXRCeU5hbWUoIkZvbnRCQm94IixzLmJib3gpO24uc2V0QnlOYW1lKCJjaGFyc2V0IixudWxsKTtuLnNldEJ5TmFtZSgiQ2hhclN0cmluZ3MiLG51bGwpO24uc2V0QnlOYW1lKCJQcml2YXRlIixudWxsKTtyLnRvcERpY3Q9bjtjb25zdCBvPW5ldyBDRkZTdHJpbmdzO28uYWRkKCJWZXJzaW9uIDAuMTEiKTtvLmFkZCgiU2VlIG9yaWdpbmFsIG5vdGljZSIpO28uYWRkKGUpO28uYWRkKGUpO28uYWRkKCJNZWRpdW0iKTtyLnN0cmluZ3M9bztyLmdsb2JhbFN1YnJJbmRleD1uZXcgQ0ZGSW5kZXg7Y29uc3QgZz10Lmxlbmd0aCxjPVsiLm5vdGRlZiJdO2xldCBDLGg7Zm9yKEM9MDtDPGc7QysrKXtjb25zdCBlPWlbQ10uZ2x5cGhOYW1lOy0xPT09d2kuaW5kZXhPZihlKSYmby5hZGQoZSk7Yy5wdXNoKGUpfXIuY2hhcnNldD1uZXcgQ0ZGQ2hhcnNldCghMSwwLGMpO2NvbnN0IGw9bmV3IENGRkluZGV4O2wuYWRkKFsxMzksMTRdKTtmb3IoQz0wO0M8ZztDKyspbC5hZGQodFtDXSk7ci5jaGFyU3RyaW5ncz1sO2NvbnN0IFE9bmV3IENGRlByaXZhdGVEaWN0O1Euc2V0QnlOYW1lKCJTdWJycyIsbnVsbCk7Y29uc3QgRT1bIkJsdWVWYWx1ZXMiLCJPdGhlckJsdWVzIiwiRmFtaWx5Qmx1ZXMiLCJGYW1pbHlPdGhlckJsdWVzIiwiU3RlbVNuYXBIIiwiU3RlbVNuYXBWIiwiQmx1ZVNoaWZ0IiwiQmx1ZUZ1enoiLCJCbHVlU2NhbGUiLCJMYW5ndWFnZUdyb3VwIiwiRXhwYW5zaW9uRmFjdG9yIiwiRm9yY2VCb2xkIiwiU3RkSFciLCJTdGRWVyJdO2ZvcihDPTAsaD1FLmxlbmd0aDtDPGg7QysrKXtjb25zdCBlPUVbQ107aWYoIShlIGluIHMucHJpdmF0ZURhdGEpKWNvbnRpbnVlO2NvbnN0IHQ9cy5wcml2YXRlRGF0YVtlXTtpZihBcnJheS5pc0FycmF5KHQpKWZvcihsZXQgZT10Lmxlbmd0aC0xO2U+MDtlLS0pdFtlXS09dFtlLTFdO1Euc2V0QnlOYW1lKGUsdCl9ci50b3BEaWN0LnByaXZhdGVEaWN0PVE7Y29uc3QgdT1uZXcgQ0ZGSW5kZXg7Zm9yKEM9MCxoPWEubGVuZ3RoO0M8aDtDKyspdS5hZGQoYVtDXSk7US5zdWJyc0luZGV4PXU7cmV0dXJuIG5ldyBDRkZDb21waWxlcihyKS5jb21waWxlKCl9fWNvbnN0IGhhPVtbNTczNDQsNjM3NDNdLFsxMDQ4NTc2LDExMTQxMDldXSxsYT0xZTMsQmE9WyJhc2NlbnQiLCJiYm94IiwiYmxhY2siLCJib2xkIiwiY2hhclByb2NPcGVyYXRvckxpc3QiLCJjb21wb3NpdGUiLCJjc3NGb250SW5mbyIsImRhdGEiLCJkZWZhdWx0Vk1ldHJpY3MiLCJkZWZhdWx0V2lkdGgiLCJkZXNjZW50IiwiZmFsbGJhY2tOYW1lIiwiZm9udE1hdHJpeCIsImlzSW52YWxpZFBERmpzRm9udCIsImlzVHlwZTNGb250IiwiaXRhbGljIiwibG9hZGVkTmFtZSIsIm1pbWV0eXBlIiwibWlzc2luZ0ZpbGUiLCJuYW1lIiwicmVtZWFzdXJlIiwic3VidHlwZSIsInN5c3RlbUZvbnRJbmZvIiwidHlwZSIsInZlcnRpY2FsIl0sUWE9WyJjTWFwIiwiZGVmYXVsdEVuY29kaW5nIiwiZGlmZmVyZW5jZXMiLCJpc01vbm9zcGFjZSIsImlzU2VyaWZGb250IiwiaXNTeW1ib2xpY0ZvbnQiLCJzZWFjTWFwIiwidG9Gb250Q2hhciIsInRvVW5pY29kZSIsInZtZXRyaWNzIiwid2lkdGhzIl07ZnVuY3Rpb24gYWRqdXN0V2lkdGhzKGUpe2lmKCFlLmZvbnRNYXRyaXgpcmV0dXJuO2lmKGUuZm9udE1hdHJpeFswXT09PWFbMF0pcmV0dXJuO2NvbnN0IHQ9LjAwMS9lLmZvbnRNYXRyaXhbMF0saT1lLndpZHRocztmb3IoY29uc3QgZSBpbiBpKWlbZV0qPXQ7ZS5kZWZhdWx0V2lkdGgqPXR9ZnVuY3Rpb24gYW1lbmRGYWxsYmFja1RvVW5pY29kZShlKXtpZighZS5mYWxsYmFja1RvVW5pY29kZSlyZXR1cm47aWYoZS50b1VuaWNvZGUgaW5zdGFuY2VvZiBJZGVudGl0eVRvVW5pY29kZU1hcClyZXR1cm47Y29uc3QgdD1bXTtmb3IoY29uc3QgaSBpbiBlLmZhbGxiYWNrVG9Vbmljb2RlKWUudG9Vbmljb2RlLmhhcyhpKXx8KHRbaV09ZS5mYWxsYmFja1RvVW5pY29kZVtpXSk7dC5sZW5ndGg+MCYmZS50b1VuaWNvZGUuYW1lbmQodCl9Y2xhc3MgZm9udHNfR2x5cGh7Y29uc3RydWN0b3IoZSx0LGksYSxzLHIsbixvLGcpe3RoaXMub3JpZ2luYWxDaGFyQ29kZT1lO3RoaXMuZm9udENoYXI9dDt0aGlzLnVuaWNvZGU9aTt0aGlzLmFjY2VudD1hO3RoaXMud2lkdGg9czt0aGlzLnZtZXRyaWM9cjt0aGlzLm9wZXJhdG9yTGlzdElkPW47dGhpcy5pc1NwYWNlPW87dGhpcy5pc0luRm9udD1nfWdldCBjYXRlZ29yeSgpe3JldHVybiBzaGFkb3codGhpcywiY2F0ZWdvcnkiLGZ1bmN0aW9uIGdldENoYXJVbmljb2RlQ2F0ZWdvcnkoZSl7Y29uc3QgdD1KaS5nZXQoZSk7aWYodClyZXR1cm4gdDtjb25zdCBpPWUubWF0Y2goSGkpLGE9e2lzV2hpdGVzcGFjZTohIWk/LlsxXSxpc1plcm9XaWR0aERpYWNyaXRpYzohIWk/LlsyXSxpc0ludmlzaWJsZUZvcm1hdE1hcms6ISFpPy5bM119O0ppLnNldChlLGEpO3JldHVybiBhfSh0aGlzLnVuaWNvZGUpLCEwKX19ZnVuY3Rpb24gaW50MTYoZSx0KXtyZXR1cm4oZTw8OCkrdH1mdW5jdGlvbiB3cml0ZVNpZ25lZEludDE2KGUsdCxpKXtlW3QrMV09aTtlW3RdPWk+Pj44fWZ1bmN0aW9uIHNpZ25lZEludDE2KGUsdCl7Y29uc3QgaT0oZTw8OCkrdDtyZXR1cm4gMzI3NjgmaT9pLTY1NTM2Oml9ZnVuY3Rpb24gc3RyaW5nMTYoZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUsMjU1JmUpfWZ1bmN0aW9uIHNhZmVTdHJpbmcxNihlKXtlPjMyNzY3P2U9MzI3Njc6ZTwtMzI3NjgmJihlPS0zMjc2OCk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZT4+OCYyNTUsMjU1JmUpfWZ1bmN0aW9uIGlzVHJ1ZVR5cGVDb2xsZWN0aW9uRmlsZShlKXtyZXR1cm4idHRjZiI9PT1ieXRlc1RvU3RyaW5nKGUucGVla0J5dGVzKDQpKX1mdW5jdGlvbiBnZXRGb250RmlsZVR5cGUoZSx7dHlwZTp0LHN1YnR5cGU6aSxjb21wb3NpdGU6YX0pe2xldCBzLHI7aWYoZnVuY3Rpb24gaXNUcnVlVHlwZUZpbGUoZSl7Y29uc3QgdD1lLnBlZWtCeXRlcyg0KTtyZXR1cm4gNjU1MzY9PT1yZWFkVWludDMyKHQsMCl8fCJ0cnVlIj09PWJ5dGVzVG9TdHJpbmcodCl9KGUpfHxpc1RydWVUeXBlQ29sbGVjdGlvbkZpbGUoZSkpcz1hPyJDSURGb250VHlwZTIiOiJUcnVlVHlwZSI7ZWxzZSBpZihmdW5jdGlvbiBpc09wZW5UeXBlRmlsZShlKXtyZXR1cm4iT1RUTyI9PT1ieXRlc1RvU3RyaW5nKGUucGVla0J5dGVzKDQpKX0oZSkpcz1hPyJDSURGb250VHlwZTIiOiJPcGVuVHlwZSI7ZWxzZSBpZihmdW5jdGlvbiBpc1R5cGUxRmlsZShlKXtjb25zdCB0PWUucGVla0J5dGVzKDIpO3JldHVybiAzNz09PXRbMF0mJjMzPT09dFsxXXx8MTI4PT09dFswXSYmMT09PXRbMV19KGUpKXM9YT8iQ0lERm9udFR5cGUwIjoiTU1UeXBlMSI9PT10PyJNTVR5cGUxIjoiVHlwZTEiO2Vsc2UgaWYoZnVuY3Rpb24gaXNDRkZGaWxlKGUpe2NvbnN0IHQ9ZS5wZWVrQnl0ZXMoNCk7cmV0dXJuIHRbMF0+PTEmJnRbM10+PTEmJnRbM108PTR9KGUpKWlmKGEpe3M9IkNJREZvbnRUeXBlMCI7cj0iQ0lERm9udFR5cGUwQyJ9ZWxzZXtzPSJNTVR5cGUxIj09PXQ/Ik1NVHlwZTEiOiJUeXBlMSI7cj0iVHlwZTFDIn1lbHNle3dhcm4oImdldEZvbnRGaWxlVHlwZTogVW5hYmxlIHRvIGRldGVjdCBjb3JyZWN0IGZvbnQgZmlsZSBUeXBlL1N1YnR5cGUuIik7cz10O3I9aX1yZXR1cm5bcyxyXX1mdW5jdGlvbiBhcHBseVN0YW5kYXJkRm9udEdseXBoTWFwKGUsdCl7Zm9yKGNvbnN0IGkgaW4gdCllWytpXT10W2ldfWZ1bmN0aW9uIGJ1aWxkVG9Gb250Q2hhcihlLHQsaSl7Y29uc3QgYT1bXTtsZXQgcztmb3IobGV0IGk9MCxyPWUubGVuZ3RoO2k8cjtpKyspe3M9Z2V0VW5pY29kZUZvckdseXBoKGVbaV0sdCk7LTEhPT1zJiYoYVtpXT1zKX1mb3IoY29uc3QgZSBpbiBpKXtzPWdldFVuaWNvZGVGb3JHbHlwaChpW2VdLHQpOy0xIT09cyYmKGFbK2VdPXMpfXJldHVybiBhfWZ1bmN0aW9uIGlzTWFjTmFtZVJlY29yZChlKXtyZXR1cm4gMT09PWUucGxhdGZvcm0mJjA9PT1lLmVuY29kaW5nJiYwPT09ZS5sYW5ndWFnZX1mdW5jdGlvbiBpc1dpbk5hbWVSZWNvcmQoZSl7cmV0dXJuIDM9PT1lLnBsYXRmb3JtJiYxPT09ZS5lbmNvZGluZyYmMTAzMz09PWUubGFuZ3VhZ2V9ZnVuY3Rpb24gY29udmVydENpZFN0cmluZyhlLHQsaT0hMSl7c3dpdGNoKHQubGVuZ3RoKXtjYXNlIDE6cmV0dXJuIHQuY2hhckNvZGVBdCgwKTtjYXNlIDI6cmV0dXJuIHQuY2hhckNvZGVBdCgwKTw8OHx0LmNoYXJDb2RlQXQoMSl9Y29uc3QgYT1gVW5zdXBwb3J0ZWQgQ0lEIHN0cmluZyAoY2hhckNvZGUgJHtlfSk6ICIke3R9Ii5gO2lmKGkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGEpO3dhcm4oYSk7cmV0dXJuIHR9ZnVuY3Rpb24gYWRqdXN0TWFwcGluZyhlLHQsaSxhKXtjb25zdCBzPU9iamVjdC5jcmVhdGUobnVsbCkscj1uZXcgTWFwLG49W10sbz1uZXcgU2V0O2xldCBnPTA7bGV0IGM9aGFbZ11bMF0sQz1oYVtnXVsxXTtmb3IobGV0IGwgaW4gZSl7bHw9MDtsZXQgUT1lW2xdO2lmKCF0KFEpKWNvbnRpbnVlO2lmKGM+Qyl7ZysrO2lmKGc+PWhhLmxlbmd0aCl7d2FybigiUmFuIG91dCBvZiBzcGFjZSBpbiBmb250IHByaXZhdGUgdXNlIGFyZWEuIik7YnJlYWt9Yz1oYVtnXVswXTtDPWhhW2ddWzFdfWNvbnN0IEU9YysrOzA9PT1RJiYoUT1pKTtsZXQgdT1hLmdldChsKTsic3RyaW5nIj09dHlwZW9mIHUmJih1PXUuY29kZVBvaW50QXQoMCkpO2lmKHUmJiEoaD11LGhhWzBdWzBdPD1oJiZoPD1oYVswXVsxXXx8aGFbMV1bMF08PWgmJmg8PWhhWzFdWzFdKSYmIW8uaGFzKFEpKXtyLnNldCh1LFEpO28uYWRkKFEpfXNbRV09UTtuW2xdPUV9dmFyIGg7cmV0dXJue3RvRm9udENoYXI6bixjaGFyQ29kZVRvR2x5cGhJZDpzLHRvVW5pY29kZUV4dHJhTWFwOnIsbmV4dEF2YWlsYWJsZUZvbnRDaGFyQ29kZTpjfX1mdW5jdGlvbiBjcmVhdGVDbWFwVGFibGUoZSx0LGkpe2NvbnN0IGE9ZnVuY3Rpb24gZ2V0UmFuZ2VzKGUsdCxpKXtjb25zdCBhPVtdO2Zvcihjb25zdCB0IGluIGUpZVt0XT49aXx8YS5wdXNoKHtmb250Q2hhckNvZGU6MHx0LGdseXBoSWQ6ZVt0XX0pO2lmKHQpZm9yKGNvbnN0W2Usc11vZiB0KXM+PWl8fGEucHVzaCh7Zm9udENoYXJDb2RlOmUsZ2x5cGhJZDpzfSk7MD09PWEubGVuZ3RoJiZhLnB1c2goe2ZvbnRDaGFyQ29kZTowLGdseXBoSWQ6MH0pO2Euc29ydCgoZnVuY3Rpb24gZm9udEdldFJhbmdlc1NvcnQoZSx0KXtyZXR1cm4gZS5mb250Q2hhckNvZGUtdC5mb250Q2hhckNvZGV9KSk7Y29uc3Qgcz1bXSxyPWEubGVuZ3RoO2ZvcihsZXQgZT0wO2U8cjspe2NvbnN0IHQ9YVtlXS5mb250Q2hhckNvZGUsaT1bYVtlXS5nbHlwaElkXTsrK2U7bGV0IG49dDtmb3IoO2U8ciYmbisxPT09YVtlXS5mb250Q2hhckNvZGU7KXtpLnB1c2goYVtlXS5nbHlwaElkKTsrK247KytlO2lmKDY1NTM1PT09bilicmVha31zLnB1c2goW3QsbixpXSl9cmV0dXJuIHN9KGUsdCxpKSxzPWEuYXQoLTEpWzFdPjY1NTM1PzI6MTtsZXQgcixuLG8sZyxjPSJcMFwwIitzdHJpbmcxNihzKSsiXDADXDABIitzdHJpbmczMig0Kzgqcyk7Zm9yKHI9YS5sZW5ndGgtMTtyPj0wJiYhKGFbcl1bMF08PTY1NTM1KTstLXIpO2NvbnN0IEM9cisxO2Fbcl1bMF08NjU1MzUmJjY1NTM1PT09YVtyXVsxXSYmKGFbcl1bMV09NjU1MzQpO2NvbnN0IGg9YVtyXVsxXTw2NTUzNT8xOjAsbD1DK2gsUT1PcGVuVHlwZUZpbGVCdWlsZGVyLmdldFNlYXJjaFBhcmFtcyhsLDIpO2xldCBFLHUsZCxmLHA9IiIsbT0iIix5PSIiLHc9IiIsYj0iIixEPTA7Zm9yKHI9MCxuPUM7cjxuO3IrKyl7RT1hW3JdO3U9RVswXTtkPUVbMV07cCs9c3RyaW5nMTYodSk7bSs9c3RyaW5nMTYoZCk7Zj1FWzJdO2xldCBlPSEwO2ZvcihvPTEsZz1mLmxlbmd0aDtvPGc7KytvKWlmKGZbb10hPT1mW28tMV0rMSl7ZT0hMTticmVha31pZihlKXt5Kz1zdHJpbmcxNihmWzBdLXUmNjU1MzUpO3crPXN0cmluZzE2KDApfWVsc2V7Y29uc3QgZT0yKihsLXIpKzIqRDtEKz1kLXUrMTt5Kz1zdHJpbmcxNigwKTt3Kz1zdHJpbmcxNihlKTtmb3Iobz0wLGc9Zi5sZW5ndGg7bzxnOysrbyliKz1zdHJpbmcxNihmW29dKX19aWYoaD4wKXttKz0iw7/DvyI7cCs9IsO/w78iO3krPSJcMAEiO3crPSJcMFwwIn1jb25zdCBGPSJcMFwwIitzdHJpbmcxNigyKmwpK3N0cmluZzE2KFEucmFuZ2UpK3N0cmluZzE2KFEuZW50cnkpK3N0cmluZzE2KFEucmFuZ2VTaGlmdCkrbSsiXDBcMCIrcCt5K3crYjtsZXQgUz0iIixrPSIiO2lmKHM+MSl7Yys9IlwwA1wwXG4iK3N0cmluZzMyKDQrOCpzKzQrRi5sZW5ndGgpO1M9IiI7Zm9yKHI9MCxuPWEubGVuZ3RoO3I8bjtyKyspe0U9YVtyXTt1PUVbMF07Zj1FWzJdO2xldCBlPWZbMF07Zm9yKG89MSxnPWYubGVuZ3RoO288ZzsrK28paWYoZltvXSE9PWZbby0xXSsxKXtkPUVbMF0rby0xO1MrPXN0cmluZzMyKHUpK3N0cmluZzMyKGQpK3N0cmluZzMyKGUpO3U9ZCsxO2U9ZltvXX1TKz1zdHJpbmczMih1KStzdHJpbmczMihFWzFdKStzdHJpbmczMihlKX1rPSJcMFxmXDBcMCIrc3RyaW5nMzIoUy5sZW5ndGgrMTYpKyJcMFwwXDBcMCIrc3RyaW5nMzIoUy5sZW5ndGgvMTIpfXJldHVybiBjKyJcMAQiK3N0cmluZzE2KEYubGVuZ3RoKzQpK0YraytTfWZ1bmN0aW9uIGNyZWF0ZU9TMlRhYmxlKGUsdCxpKXtpfHw9e3VuaXRzUGVyRW06MCx5TWF4OjAseU1pbjowLGFzY2VudDowLGRlc2NlbnQ6MH07bGV0IHM9MCxyPTAsbj0wLG89MCxnPW51bGwsYz0wLEM9LTE7aWYodCl7Zm9yKGxldCBlIGluIHQpe2V8PTA7KGc+ZXx8IWcpJiYoZz1lKTtjPGUmJihjPWUpO0M9Z2V0VW5pY29kZVJhbmdlRm9yKGUsQyk7aWYoQzwzMilzfD0xPDxDO2Vsc2UgaWYoQzw2NClyfD0xPDxDLTMyO2Vsc2UgaWYoQzw5NilufD0xPDxDLTY0O2Vsc2V7aWYoIShDPDEyMykpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJVbmljb2RlIHJhbmdlcyBCaXRzID4gMTIzIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2UiKTtvfD0xPDxDLTk2fX1jPjY1NTM1JiYoYz02NTUzNSl9ZWxzZXtnPTA7Yz0yNTV9Y29uc3QgaD1lLmJib3h8fFswLDAsMCwwXSxsPWkudW5pdHNQZXJFbXx8MS8oZS5mb250TWF0cml4fHxhKVswXSxRPWUuYXNjZW50U2NhbGVkPzE6bC9sYSxFPWkuYXNjZW50fHxNYXRoLnJvdW5kKFEqKGUuYXNjZW50fHxoWzNdKSk7bGV0IHU9aS5kZXNjZW50fHxNYXRoLnJvdW5kKFEqKGUuZGVzY2VudHx8aFsxXSkpO3U+MCYmZS5kZXNjZW50PjAmJmhbMV08MCYmKHU9LXUpO2NvbnN0IGQ9aS55TWF4fHxFLGY9LWkueU1pbnx8LXU7cmV0dXJuIlwwAwIkAcO0XDAFXDBcMALCigLCu1wwXDBcMMKMAsKKAsK7XDBcMAHDn1x4MDAxAQJcMFwwXDBcMAYiK1N0cmluZy5mcm9tQ2hhckNvZGUoZS5maXhlZFBpdGNoPzk6MCkrIlwwXDBcMFwwXDBcMCIrc3RyaW5nMzIocykrc3RyaW5nMzIocikrc3RyaW5nMzIobikrc3RyaW5nMzIobykrIioyMSoiK3N0cmluZzE2KGUuaXRhbGljQW5nbGU/MTowKStzdHJpbmcxNihnfHxlLmZpcnN0Q2hhcikrc3RyaW5nMTYoY3x8ZS5sYXN0Q2hhcikrc3RyaW5nMTYoRSkrc3RyaW5nMTYodSkrIlwwZCIrc3RyaW5nMTYoZCkrc3RyaW5nMTYoZikrIlwwXDBcMFwwXDBcMFwwXDAiK3N0cmluZzE2KGUueEhlaWdodCkrc3RyaW5nMTYoZS5jYXBIZWlnaHQpK3N0cmluZzE2KDApK3N0cmluZzE2KGd8fGUuZmlyc3RDaGFyKSsiXDADIn1mdW5jdGlvbiBjcmVhdGVQb3N0VGFibGUoZSl7cmV0dXJuIlwwA1wwXDAiK3N0cmluZzMyKE1hdGguZmxvb3IoNjU1MzYqZS5pdGFsaWNBbmdsZSkpKyJcMFwwXDBcMCIrc3RyaW5nMzIoZS5maXhlZFBpdGNoPzE6MCkrIlwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwIn1mdW5jdGlvbiBjcmVhdGVQb3N0c2NyaXB0TmFtZShlKXtyZXR1cm4gZS5yZXBsYWNlQWxsKC9bXlx4MjEtXHg3RV18W1tcXSgpe308Pi8lXS9nLCIiKS5zbGljZSgwLDYzKX1mdW5jdGlvbiBjcmVhdGVOYW1lVGFibGUoZSx0KXt0fHwodD1bW10sW11dKTtjb25zdCBpPVt0WzBdWzBdfHwiT3JpZ2luYWwgbGljZW5jZSIsdFswXVsxXXx8ZSx0WzBdWzJdfHwiVW5rbm93biIsdFswXVszXXx8InVuaXF1ZUlEIix0WzBdWzRdfHxlLHRbMF1bNV18fCJWZXJzaW9uIDAuMTEiLHRbMF1bNl18fGNyZWF0ZVBvc3RzY3JpcHROYW1lKGUpLHRbMF1bN118fCJVbmtub3duIix0WzBdWzhdfHwiVW5rbm93biIsdFswXVs5XXx8IlVua25vd24iXSxhPVtdO2xldCBzLHIsbixvLGc7Zm9yKHM9MCxyPWkubGVuZ3RoO3M8cjtzKyspe2c9dFsxXVtzXXx8aVtzXTtjb25zdCBlPVtdO2ZvcihuPTAsbz1nLmxlbmd0aDtuPG87bisrKWUucHVzaChzdHJpbmcxNihnLmNoYXJDb2RlQXQobikpKTthLnB1c2goZS5qb2luKCIiKSl9Y29uc3QgYz1baSxhXSxDPVsiXDABIiwiXDADIl0saD1bIlwwXDAiLCJcMAEiXSxsPVsiXDBcMCIsIgRcdCJdLFE9aS5sZW5ndGgqQy5sZW5ndGg7bGV0IEU9IlwwXDAiK3N0cmluZzE2KFEpK3N0cmluZzE2KDEyKlErNiksdT0wO2ZvcihzPTAscj1DLmxlbmd0aDtzPHI7cysrKXtjb25zdCBlPWNbc107Zm9yKG49MCxvPWUubGVuZ3RoO248bztuKyspe2c9ZVtuXTtFKz1DW3NdK2hbc10rbFtzXStzdHJpbmcxNihuKStzdHJpbmcxNihnLmxlbmd0aCkrc3RyaW5nMTYodSk7dSs9Zy5sZW5ndGh9fUUrPWkuam9pbigiIikrYS5qb2luKCIiKTtyZXR1cm4gRX1jbGFzcyBGb250e2NvbnN0cnVjdG9yKGUsdCxpKXt0aGlzLm5hbWU9ZTt0aGlzLnBzTmFtZT1udWxsO3RoaXMubWltZXR5cGU9bnVsbDt0aGlzLmRpc2FibGVGb250RmFjZT0hMTt0aGlzLmxvYWRlZE5hbWU9aS5sb2FkZWROYW1lO3RoaXMuaXNUeXBlM0ZvbnQ9aS5pc1R5cGUzRm9udDt0aGlzLm1pc3NpbmdGaWxlPSExO3RoaXMuY3NzRm9udEluZm89aS5jc3NGb250SW5mbzt0aGlzLl9jaGFyc0NhY2hlPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5fZ2x5cGhDYWNoZT1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBhPSEhKGkuZmxhZ3MmS2kpO2lmKCFhJiYhaS5pc1NpbXVsYXRlZEZsYWdzKXtjb25zdCB0PWUucmVwbGFjZUFsbCgvWyxfXS9nLCItIikuc3BsaXQoIi0iLDEpWzBdLGk9WGkoKTtmb3IoY29uc3QgZSBvZiB0LnNwbGl0KCIrIikpaWYoaVtlXSl7YT0hMDticmVha319dGhpcy5pc1NlcmlmRm9udD1hO3RoaXMuaXNTeW1ib2xpY0ZvbnQ9ISEoaS5mbGFncyZUaSk7dGhpcy5pc01vbm9zcGFjZT0hIShpLmZsYWdzJnZpKTtsZXR7dHlwZTpzLHN1YnR5cGU6cn09aTt0aGlzLnR5cGU9czt0aGlzLnN1YnR5cGU9cjt0aGlzLnN5c3RlbUZvbnRJbmZvPWkuc3lzdGVtRm9udEluZm87Y29uc3Qgbj1lLm1hdGNoKC9eSW52YWxpZFBERmpzRm9udF8oLiopX1xkKyQvKTt0aGlzLmlzSW52YWxpZFBERmpzRm9udD0hIW47dGhpcy5pc0ludmFsaWRQREZqc0ZvbnQ/dGhpcy5mYWxsYmFja05hbWU9blsxXTp0aGlzLmlzTW9ub3NwYWNlP3RoaXMuZmFsbGJhY2tOYW1lPSJtb25vc3BhY2UiOnRoaXMuaXNTZXJpZkZvbnQ/dGhpcy5mYWxsYmFja05hbWU9InNlcmlmIjp0aGlzLmZhbGxiYWNrTmFtZT0ic2Fucy1zZXJpZiI7aWYodGhpcy5zeXN0ZW1Gb250SW5mbz8uZ3Vlc3NGYWxsYmFjayl7dGhpcy5zeXN0ZW1Gb250SW5mby5ndWVzc0ZhbGxiYWNrPSExO3RoaXMuc3lzdGVtRm9udEluZm8uY3NzKz1gLCR7dGhpcy5mYWxsYmFja05hbWV9YH10aGlzLmRpZmZlcmVuY2VzPWkuZGlmZmVyZW5jZXM7dGhpcy53aWR0aHM9aS53aWR0aHM7dGhpcy5kZWZhdWx0V2lkdGg9aS5kZWZhdWx0V2lkdGg7dGhpcy5jb21wb3NpdGU9aS5jb21wb3NpdGU7dGhpcy5jTWFwPWkuY01hcDt0aGlzLmNhcEhlaWdodD1pLmNhcEhlaWdodC9sYTt0aGlzLmFzY2VudD1pLmFzY2VudC9sYTt0aGlzLmRlc2NlbnQ9aS5kZXNjZW50L2xhO3RoaXMubGluZUhlaWdodD10aGlzLmFzY2VudC10aGlzLmRlc2NlbnQ7dGhpcy5mb250TWF0cml4PWkuZm9udE1hdHJpeDt0aGlzLmJib3g9aS5iYm94O3RoaXMuZGVmYXVsdEVuY29kaW5nPWkuZGVmYXVsdEVuY29kaW5nO3RoaXMudG9Vbmljb2RlPWkudG9Vbmljb2RlO3RoaXMudG9Gb250Q2hhcj1bXTtpZigiVHlwZTMiPT09aS50eXBlKXtmb3IobGV0IGU9MDtlPDI1NjtlKyspdGhpcy50b0ZvbnRDaGFyW2VdPXRoaXMuZGlmZmVyZW5jZXNbZV18fGkuZGVmYXVsdEVuY29kaW5nW2VdO3JldHVybn10aGlzLmNpZEVuY29kaW5nPWkuY2lkRW5jb2Rpbmd8fCIiO3RoaXMudmVydGljYWw9ISFpLnZlcnRpY2FsO2lmKHRoaXMudmVydGljYWwpe3RoaXMudm1ldHJpY3M9aS52bWV0cmljczt0aGlzLmRlZmF1bHRWTWV0cmljcz1pLmRlZmF1bHRWTWV0cmljc31pZighdHx8dC5pc0VtcHR5KXt0JiZ3YXJuKCdGb250IGZpbGUgaXMgZW1wdHkgaW4gIicrZSsnIiAoJyt0aGlzLmxvYWRlZE5hbWUrIikiKTt0aGlzLmZhbGxiYWNrVG9TeXN0ZW1Gb250KGkpO3JldHVybn1bcyxyXT1nZXRGb250RmlsZVR5cGUodCxpKTtzPT09dGhpcy50eXBlJiZyPT09dGhpcy5zdWJ0eXBlfHxpbmZvKGBJbmNvbnNpc3RlbnQgZm9udCBmaWxlIFR5cGUvU3ViVHlwZSwgZXhwZWN0ZWQ6ICR7dGhpcy50eXBlfS8ke3RoaXMuc3VidHlwZX0gYnV0IGZvdW5kOiAke3N9LyR7cn0uYCk7bGV0IG87dHJ5e3N3aXRjaChzKXtjYXNlIk1NVHlwZTEiOmluZm8oIk1NVHlwZTEgZm9udCAoIitlKyIpLCBmYWxsaW5nIGJhY2sgdG8gVHlwZTEuIik7Y2FzZSJUeXBlMSI6Y2FzZSJDSURGb250VHlwZTAiOnRoaXMubWltZXR5cGU9ImZvbnQvb3BlbnR5cGUiO2NvbnN0IGE9IlR5cGUxQyI9PT1yfHwiQ0lERm9udFR5cGUwQyI9PT1yP25ldyBDRkZGb250KHQsaSk6bmV3IFR5cGUxRm9udChlLHQsaSk7YWRqdXN0V2lkdGhzKGkpO289dGhpcy5jb252ZXJ0KGUsYSxpKTticmVhaztjYXNlIk9wZW5UeXBlIjpjYXNlIlRydWVUeXBlIjpjYXNlIkNJREZvbnRUeXBlMiI6dGhpcy5taW1ldHlwZT0iZm9udC9vcGVudHlwZSI7bz10aGlzLmNoZWNrQW5kUmVwYWlyKGUsdCxpKTtpZih0aGlzLmlzT3BlblR5cGUpe2FkanVzdFdpZHRocyhpKTtzPSJPcGVuVHlwZSJ9YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEZvbnQgJHtzfSBpcyBub3Qgc3VwcG9ydGVkYCl9fWNhdGNoKGUpe3dhcm4oZSk7dGhpcy5mYWxsYmFja1RvU3lzdGVtRm9udChpKTtyZXR1cm59YW1lbmRGYWxsYmFja1RvVW5pY29kZShpKTt0aGlzLmRhdGE9bzt0aGlzLnR5cGU9czt0aGlzLnN1YnR5cGU9cjt0aGlzLmZvbnRNYXRyaXg9aS5mb250TWF0cml4O3RoaXMud2lkdGhzPWkud2lkdGhzO3RoaXMuZGVmYXVsdFdpZHRoPWkuZGVmYXVsdFdpZHRoO3RoaXMudG9Vbmljb2RlPWkudG9Vbmljb2RlO3RoaXMuc2VhY01hcD1pLnNlYWNNYXB9Z2V0IHJlbmRlcmVyKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJyZW5kZXJlciIsRm9udFJlbmRlcmVyRmFjdG9yeS5jcmVhdGUodGhpcyxZaSkpfWV4cG9ydERhdGEoZT0hMSl7Y29uc3QgdD1lP1suLi5CYSwuLi5RYV06QmEsaT1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBhLHM7Zm9yKGEgb2YgdCl7cz10aGlzW2FdO3ZvaWQgMCE9PXMmJihpW2FdPXMpfXJldHVybiBpfWZhbGxiYWNrVG9TeXN0ZW1Gb250KGUpe3RoaXMubWlzc2luZ0ZpbGU9ITA7Y29uc3R7bmFtZTp0LHR5cGU6aX09dGhpcztsZXQgYT1ub3JtYWxpemVGb250TmFtZSh0KTtjb25zdCBzPVBpKCkscj1qaSgpLG49ISFzW2FdLG89ISghclthXXx8IXNbclthXV0pO2E9c1thXXx8clthXXx8YTtjb25zdCBnPWVhKClbYV07aWYoZyl7aXNOYU4odGhpcy5hc2NlbnQpJiYodGhpcy5hc2NlbnQ9Zy5hc2NlbnQvbGEpO2lzTmFOKHRoaXMuZGVzY2VudCkmJih0aGlzLmRlc2NlbnQ9Zy5kZXNjZW50L2xhKTtpc05hTih0aGlzLmNhcEhlaWdodCkmJih0aGlzLmNhcEhlaWdodD1nLmNhcEhlaWdodC9sYSl9dGhpcy5ib2xkPS9ib2xkL2dpLnRlc3QoYSk7dGhpcy5pdGFsaWM9L29ibGlxdWV8aXRhbGljL2dpLnRlc3QoYSk7dGhpcy5ibGFjaz0vQmxhY2svZy50ZXN0KHQpO2NvbnN0IGM9L05hcnJvdy9nLnRlc3QodCk7dGhpcy5yZW1lYXN1cmU9KCFufHxjKSYmT2JqZWN0LmtleXModGhpcy53aWR0aHMpLmxlbmd0aD4wO2lmKChufHxvKSYmIkNJREZvbnRUeXBlMiI9PT1pJiZ0aGlzLmNpZEVuY29kaW5nLnN0YXJ0c1dpdGgoIklkZW50aXR5LSIpKXtjb25zdCBpPWUuY2lkVG9HaWRNYXAsYT1bXTthcHBseVN0YW5kYXJkRm9udEdseXBoTWFwKGEsVmkoKSk7L0FyaWFsLT9CbGFjay9pLnRlc3QodCk/YXBwbHlTdGFuZGFyZEZvbnRHbHlwaE1hcChhLHppKCkpOi9DYWxpYnJpL2kudGVzdCh0KSYmYXBwbHlTdGFuZGFyZEZvbnRHbHlwaE1hcChhLF9pKCkpO2lmKGkpe2Zvcihjb25zdCBlIGluIGEpe2NvbnN0IHQ9YVtlXTt2b2lkIDAhPT1pW3RdJiYoYVsrZV09aVt0XSl9aS5sZW5ndGghPT10aGlzLnRvVW5pY29kZS5sZW5ndGgmJmUuaGFzSW5jbHVkZWRUb1VuaWNvZGVNYXAmJnRoaXMudG9Vbmljb2RlIGluc3RhbmNlb2YgSWRlbnRpdHlUb1VuaWNvZGVNYXAmJnRoaXMudG9Vbmljb2RlLmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7Y29uc3Qgcz1hW2VdO3ZvaWQgMD09PWlbc10mJihhWytlXT10KX0pKX10aGlzLnRvVW5pY29kZSBpbnN0YW5jZW9mIElkZW50aXR5VG9Vbmljb2RlTWFwfHx0aGlzLnRvVW5pY29kZS5mb3JFYWNoKChmdW5jdGlvbihlLHQpe2FbK2VdPXR9KSk7dGhpcy50b0ZvbnRDaGFyPWE7dGhpcy50b1VuaWNvZGU9bmV3IFRvVW5pY29kZU1hcChhKX1lbHNlIGlmKC9TeW1ib2wvaS50ZXN0KGEpKXRoaXMudG9Gb250Q2hhcj1idWlsZFRvRm9udENoYXIobWksUmkoKSx0aGlzLmRpZmZlcmVuY2VzKTtlbHNlIGlmKC9EaW5nYmF0cy9pLnRlc3QoYSkpdGhpcy50b0ZvbnRDaGFyPWJ1aWxkVG9Gb250Q2hhcih5aSxHaSgpLHRoaXMuZGlmZmVyZW5jZXMpO2Vsc2UgaWYobil7Y29uc3QgZT1idWlsZFRvRm9udENoYXIodGhpcy5kZWZhdWx0RW5jb2RpbmcsUmkoKSx0aGlzLmRpZmZlcmVuY2VzKTsiQ0lERm9udFR5cGUyIiE9PWl8fHRoaXMuY2lkRW5jb2Rpbmcuc3RhcnRzV2l0aCgiSWRlbnRpdHktIil8fHRoaXMudG9Vbmljb2RlIGluc3RhbmNlb2YgSWRlbnRpdHlUb1VuaWNvZGVNYXB8fHRoaXMudG9Vbmljb2RlLmZvckVhY2goKGZ1bmN0aW9uKHQsaSl7ZVsrdF09aX0pKTt0aGlzLnRvRm9udENoYXI9ZX1lbHNle2NvbnN0IGU9UmkoKSxpPVtdO3RoaXMudG9Vbmljb2RlLmZvckVhY2goKCh0LGEpPT57aWYoIXRoaXMuY29tcG9zaXRlKXtjb25zdCBpPWdldFVuaWNvZGVGb3JHbHlwaCh0aGlzLmRpZmZlcmVuY2VzW3RdfHx0aGlzLmRlZmF1bHRFbmNvZGluZ1t0XSxlKTstMSE9PWkmJihhPWkpfWlbK3RdPWF9KSk7dGhpcy5jb21wb3NpdGUmJnRoaXMudG9Vbmljb2RlIGluc3RhbmNlb2YgSWRlbnRpdHlUb1VuaWNvZGVNYXAmJi9UYWhvbWF8VmVyZGFuYS9pLnRlc3QodCkmJmFwcGx5U3RhbmRhcmRGb250R2x5cGhNYXAoaSxWaSgpKTt0aGlzLnRvRm9udENoYXI9aX1hbWVuZEZhbGxiYWNrVG9Vbmljb2RlKGUpO3RoaXMubG9hZGVkTmFtZT1hLnNwbGl0KCItIiwxKVswXX1jaGVja0FuZFJlcGFpcihlLHQsaSl7Y29uc3QgYT1bIk9TLzIiLCJjbWFwIiwiaGVhZCIsImhoZWEiLCJobXR4IiwibWF4cCIsIm5hbWUiLCJwb3N0IiwibG9jYSIsImdseWYiLCJmcGdtIiwicHJlcCIsImN2dCAiLCJDRkYgIl07ZnVuY3Rpb24gcmVhZFRhYmxlcyhlLHQpe2NvbnN0IGk9T2JqZWN0LmNyZWF0ZShudWxsKTtpWyJPUy8yIl09bnVsbDtpLmNtYXA9bnVsbDtpLmhlYWQ9bnVsbDtpLmhoZWE9bnVsbDtpLmhtdHg9bnVsbDtpLm1heHA9bnVsbDtpLm5hbWU9bnVsbDtpLnBvc3Q9bnVsbDtmb3IobGV0IHM9MDtzPHQ7cysrKXtjb25zdCB0PXJlYWRUYWJsZUVudHJ5KGUpO2EuaW5jbHVkZXModC50YWcpJiYoMCE9PXQubGVuZ3RoJiYoaVt0LnRhZ109dCkpfXJldHVybiBpfWZ1bmN0aW9uIHJlYWRUYWJsZUVudHJ5KGUpe2NvbnN0IHQ9ZS5nZXRTdHJpbmcoNCksaT1lLmdldEludDMyKCk+Pj4wLGE9ZS5nZXRJbnQzMigpPj4+MCxzPWUuZ2V0SW50MzIoKT4+PjAscj1lLnBvcztlLnBvcz1lLnN0YXJ0fHwwO2Uuc2tpcChhKTtjb25zdCBuPWUuZ2V0Qnl0ZXMocyk7ZS5wb3M9cjtpZigiaGVhZCI9PT10KXtuWzhdPW5bOV09blsxMF09blsxMV09MDtuWzE3XXw9MzJ9cmV0dXJue3RhZzp0LGNoZWNrc3VtOmksbGVuZ3RoOnMsb2Zmc2V0OmEsZGF0YTpufX1mdW5jdGlvbiByZWFkT3BlblR5cGVIZWFkZXIoZSl7cmV0dXJue3ZlcnNpb246ZS5nZXRTdHJpbmcoNCksbnVtVGFibGVzOmUuZ2V0VWludDE2KCksc2VhcmNoUmFuZ2U6ZS5nZXRVaW50MTYoKSxlbnRyeVNlbGVjdG9yOmUuZ2V0VWludDE2KCkscmFuZ2VTaGlmdDplLmdldFVpbnQxNigpfX1mdW5jdGlvbiBzYW5pdGl6ZUdseXBoKGUsdCxpLGEscyxyKXtjb25zdCBuPXtsZW5ndGg6MCxzaXplT2ZJbnN0cnVjdGlvbnM6MH07aWYodDwwfHx0Pj1lLmxlbmd0aHx8aT5lLmxlbmd0aHx8aS10PD0xMilyZXR1cm4gbjtjb25zdCBvPWUuc3ViYXJyYXkodCxpKSxnPXNpZ25lZEludDE2KG9bMl0sb1szXSksYz1zaWduZWRJbnQxNihvWzRdLG9bNV0pLEM9c2lnbmVkSW50MTYob1s2XSxvWzddKSxoPXNpZ25lZEludDE2KG9bOF0sb1s5XSk7aWYoZz5DKXt3cml0ZVNpZ25lZEludDE2KG8sMixDKTt3cml0ZVNpZ25lZEludDE2KG8sNixnKX1pZihjPmgpe3dyaXRlU2lnbmVkSW50MTYobyw0LGgpO3dyaXRlU2lnbmVkSW50MTYobyw4LGMpfWNvbnN0IGw9c2lnbmVkSW50MTYob1swXSxvWzFdKTtpZihsPDApe2lmKGw8LTEpcmV0dXJuIG47YS5zZXQobyxzKTtuLmxlbmd0aD1vLmxlbmd0aDtyZXR1cm4gbn1sZXQgUSxFPTEwLHU9MDtmb3IoUT0wO1E8bDtRKyspe3U9KG9bRV08PDh8b1tFKzFdKSsxO0UrPTJ9Y29uc3QgZD1FLGY9b1tFXTw8OHxvW0UrMV07bi5zaXplT2ZJbnN0cnVjdGlvbnM9ZjtFKz0yK2Y7Y29uc3QgcD1FO2xldCBtPTA7Zm9yKFE9MDtRPHU7USsrKXtjb25zdCBlPW9bRSsrXTsxOTImZSYmKG9bRS0xXT02MyZlKTtsZXQgdD0yOzImZT90PTE6MTYmZSYmKHQ9MCk7bGV0IGk9Mjs0JmU/aT0xOjMyJmUmJihpPTApO2NvbnN0IGE9dCtpO20rPWE7aWYoOCZlKXtjb25zdCBlPW9bRSsrXTswPT09ZSYmKG9bRS0xXV49OCk7USs9ZTttKz1lKmF9fWlmKDA9PT1tKXJldHVybiBuO2xldCB5PUUrbTtpZih5Pm8ubGVuZ3RoKXJldHVybiBuO2lmKCFyJiZmPjApe2Euc2V0KG8uc3ViYXJyYXkoMCxkKSxzKTthLnNldChbMCwwXSxzK2QpO2Euc2V0KG8uc3ViYXJyYXkocCx5KSxzK2QrMik7eS09ZjtvLmxlbmd0aC15PjMmJih5PXkrMyYtNCk7bi5sZW5ndGg9eTtyZXR1cm4gbn1pZihvLmxlbmd0aC15PjMpe3k9eSszJi00O2Euc2V0KG8uc3ViYXJyYXkoMCx5KSxzKTtuLmxlbmd0aD15O3JldHVybiBufWEuc2V0KG8scyk7bi5sZW5ndGg9by5sZW5ndGg7cmV0dXJuIG59ZnVuY3Rpb24gcmVhZE5hbWVUYWJsZShlKXtjb25zdCBpPSh0LnN0YXJ0fHwwKStlLm9mZnNldDt0LnBvcz1pO2NvbnN0IGE9W1tdLFtdXSxzPVtdLHI9ZS5sZW5ndGgsbj1pK3I7aWYoMCE9PXQuZ2V0VWludDE2KCl8fHI8NilyZXR1cm5bYSxzXTtjb25zdCBvPXQuZ2V0VWludDE2KCksZz10LmdldFVpbnQxNigpO2xldCBjLEM7Zm9yKGM9MDtjPG8mJnQucG9zKzEyPD1uO2MrKyl7Y29uc3QgZT17cGxhdGZvcm06dC5nZXRVaW50MTYoKSxlbmNvZGluZzp0LmdldFVpbnQxNigpLGxhbmd1YWdlOnQuZ2V0VWludDE2KCksbmFtZTp0LmdldFVpbnQxNigpLGxlbmd0aDp0LmdldFVpbnQxNigpLG9mZnNldDp0LmdldFVpbnQxNigpfTsoaXNNYWNOYW1lUmVjb3JkKGUpfHxpc1dpbk5hbWVSZWNvcmQoZSkpJiZzLnB1c2goZSl9Zm9yKGM9MCxDPXMubGVuZ3RoO2M8QztjKyspe2NvbnN0IGU9c1tjXTtpZihlLmxlbmd0aDw9MCljb250aW51ZTtjb25zdCByPWkrZytlLm9mZnNldDtpZihyK2UubGVuZ3RoPm4pY29udGludWU7dC5wb3M9cjtjb25zdCBvPWUubmFtZTtpZihlLmVuY29kaW5nKXtsZXQgaT0iIjtmb3IobGV0IGE9MCxzPWUubGVuZ3RoO2E8czthKz0yKWkrPVN0cmluZy5mcm9tQ2hhckNvZGUodC5nZXRVaW50MTYoKSk7YVsxXVtvXT1pfWVsc2UgYVswXVtvXT10LmdldFN0cmluZyhlLmxlbmd0aCl9cmV0dXJuW2Esc119Y29uc3Qgcz1bMCwwLDAsMCwwLDAsMCwwLC0yLC0yLC0yLC0yLDAsMCwtMiwtNSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwwLDAsLTEsMCwtMSwtMSwtMSwtMSwxLC0xLC05OTksMCwxLDAsLTEsLTIsMCwtMSwtMiwtMSwtMSwwLC0xLC0xLDAsMCwtOTk5LC05OTksLTEsLTEsLTEsLTEsLTIsLTk5OSwtMiwtMiwtOTk5LDAsLTIsLTIsMCwwLC0yLDAsLTIsMCwwLDAsLTIsLTEsLTEsMSwxLDAsMCwtMSwtMSwtMSwtMSwtMSwtMSwtMSwwLDAsLTEsMCwtMSwtMSwwLC05OTksLTEsLTEsLTEsLTEsLTEsLTEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsLTIsLTk5OSwtOTk5LC05OTksLTk5OSwtOTk5LC0xLC0xLC0yLC0yLDAsMCwwLDAsLTEsLTEsLTk5OSwtMiwtMiwwLDAsLTEsLTIsLTIsMCwwLDAsLTEsLTEsLTEsLTJdO2Z1bmN0aW9uIHNhbml0aXplVFRQcm9ncmFtKGUsdCl7bGV0IGksYSxyLG4sbyxnPWUuZGF0YSxjPTAsQz0wLGg9MDtjb25zdCBsPVtdLFE9W10sRT1bXTtsZXQgdT10LnRvb0NvbXBsZXhUb0ZvbGxvd0Z1bmN0aW9ucyxkPSExLGY9MCxwPTA7Zm9yKGxldCBlPWcubGVuZ3RoO2M8ZTspe2NvbnN0IGU9Z1tjKytdO2lmKDY0PT09ZSl7YT1nW2MrK107aWYoZHx8cCljKz1hO2Vsc2UgZm9yKGk9MDtpPGE7aSsrKWwucHVzaChnW2MrK10pfWVsc2UgaWYoNjU9PT1lKXthPWdbYysrXTtpZihkfHxwKWMrPTIqYTtlbHNlIGZvcihpPTA7aTxhO2krKyl7cj1nW2MrK107bC5wdXNoKHI8PDh8Z1tjKytdKX19ZWxzZSBpZigxNzY9PSgyNDgmZSkpe2E9ZS0xNzYrMTtpZihkfHxwKWMrPWE7ZWxzZSBmb3IoaT0wO2k8YTtpKyspbC5wdXNoKGdbYysrXSl9ZWxzZSBpZigxODQ9PSgyNDgmZSkpe2E9ZS0xODQrMTtpZihkfHxwKWMrPTIqYTtlbHNlIGZvcihpPTA7aTxhO2krKyl7cj1nW2MrK107bC5wdXNoKHI8PDh8Z1tjKytdKX19ZWxzZSBpZig0MyE9PWV8fHUpaWYoNDQhPT1lfHx1KXtpZig0NT09PWUpaWYoZCl7ZD0hMTtDPWN9ZWxzZXtvPVEucG9wKCk7aWYoIW8pe3dhcm4oIlRUOiBFTkRGIGJhZCBzdGFjayIpO3QuaGludHNWYWxpZD0hMTtyZXR1cm59bj1FLnBvcCgpO2c9by5kYXRhO2M9by5pO3QuZnVuY3Rpb25zU3RhY2tEZWx0YXNbbl09bC5sZW5ndGgtby5zdGFja1RvcH1lbHNlIGlmKDEzNz09PWUpe2lmKGR8fHApe3dhcm4oIlRUOiBuZXN0ZWQgSURFRnMgbm90IGFsbG93ZWQiKTt1PSEwfWQ9ITA7aD1jfWVsc2UgaWYoODg9PT1lKSsrZjtlbHNlIGlmKDI3PT09ZSlwPWY7ZWxzZSBpZig4OT09PWUpe3A9PT1mJiYocD0wKTstLWZ9ZWxzZSBpZigyOD09PWUmJiFkJiYhcCl7Y29uc3QgZT1sLmF0KC0xKTtlPjAmJihjKz1lLTEpfX1lbHNle2lmKGR8fHApe3dhcm4oIlRUOiBuZXN0ZWQgRkRFRnMgbm90IGFsbG93ZWQiKTt1PSEwfWQ9ITA7aD1jO249bC5wb3AoKTt0LmZ1bmN0aW9uc0RlZmluZWRbbl09e2RhdGE6ZyxpOmN9fWVsc2UgaWYoIWQmJiFwKXtuPWwuYXQoLTEpO2lmKGlzTmFOKG4pKWluZm8oIlRUOiBDQUxMIGVtcHR5IHN0YWNrIChvciBpbnZhbGlkIGVudHJ5KS4iKTtlbHNle3QuZnVuY3Rpb25zVXNlZFtuXT0hMDtpZihuIGluIHQuZnVuY3Rpb25zU3RhY2tEZWx0YXMpe2NvbnN0IGU9bC5sZW5ndGgrdC5mdW5jdGlvbnNTdGFja0RlbHRhc1tuXTtpZihlPDApe3dhcm4oIlRUOiBDQUxMIGludmFsaWQgZnVuY3Rpb25zIHN0YWNrIGRlbHRhLiIpO3QuaGludHNWYWxpZD0hMTtyZXR1cm59bC5sZW5ndGg9ZX1lbHNlIGlmKG4gaW4gdC5mdW5jdGlvbnNEZWZpbmVkJiYhRS5pbmNsdWRlcyhuKSl7US5wdXNoKHtkYXRhOmcsaTpjLHN0YWNrVG9wOmwubGVuZ3RoLTF9KTtFLnB1c2gobik7bz10LmZ1bmN0aW9uc0RlZmluZWRbbl07aWYoIW8pe3dhcm4oIlRUOiBDQUxMIG5vbi1leGlzdGVudCBmdW5jdGlvbiIpO3QuaGludHNWYWxpZD0hMTtyZXR1cm59Zz1vLmRhdGE7Yz1vLml9fX1pZighZCYmIXApe2xldCB0PTA7ZTw9MTQyP3Q9c1tlXTplPj0xOTImJmU8PTIyMz90PS0xOmU+PTIyNCYmKHQ9LTIpO2lmKGU+PTExMyYmZTw9MTE3KXthPWwucG9wKCk7aXNOYU4oYSl8fCh0PTIqLWEpfWZvcig7dDwwJiZsLmxlbmd0aD4wOyl7bC5wb3AoKTt0Kyt9Zm9yKDt0PjA7KXtsLnB1c2goTmFOKTt0LS19fX10LnRvb0NvbXBsZXhUb0ZvbGxvd0Z1bmN0aW9ucz11O2NvbnN0IG09W2ddO2M+Zy5sZW5ndGgmJm0ucHVzaChuZXcgVWludDhBcnJheShjLWcubGVuZ3RoKSk7aWYoaD5DKXt3YXJuKCJUVDogY29tcGxlbWVudGluZyBhIG1pc3NpbmcgZnVuY3Rpb24gdGFpbCIpO20ucHVzaChuZXcgVWludDhBcnJheShbMzQsNDVdKSl9IWZ1bmN0aW9uIGZvbGRUVFRhYmxlKGUsdCl7aWYodC5sZW5ndGg+MSl7bGV0IGksYSxzPTA7Zm9yKGk9MCxhPXQubGVuZ3RoO2k8YTtpKyspcys9dFtpXS5sZW5ndGg7cz1zKzMmLTQ7Y29uc3Qgcj1uZXcgVWludDhBcnJheShzKTtsZXQgbj0wO2ZvcihpPTAsYT10Lmxlbmd0aDtpPGE7aSsrKXtyLnNldCh0W2ldLG4pO24rPXRbaV0ubGVuZ3RofWUuZGF0YT1yO2UubGVuZ3RoPXN9fShlLG0pfWxldCByLG4sbyxnO2lmKGlzVHJ1ZVR5cGVDb2xsZWN0aW9uRmlsZSh0PW5ldyBTdHJlYW0obmV3IFVpbnQ4QXJyYXkodC5nZXRCeXRlcygpKSkpKXtjb25zdCBlPWZ1bmN0aW9uIHJlYWRUcnVlVHlwZUNvbGxlY3Rpb25EYXRhKGUsdCl7Y29uc3R7bnVtRm9udHM6aSxvZmZzZXRUYWJsZTphfT1mdW5jdGlvbiByZWFkVHJ1ZVR5cGVDb2xsZWN0aW9uSGVhZGVyKGUpe2NvbnN0IHQ9ZS5nZXRTdHJpbmcoNCk7YXNzZXJ0KCJ0dGNmIj09PXQsIk11c3QgYmUgYSBUcnVlVHlwZSBDb2xsZWN0aW9uIGZvbnQuIik7Y29uc3QgaT1lLmdldFVpbnQxNigpLGE9ZS5nZXRVaW50MTYoKSxzPWUuZ2V0SW50MzIoKT4+PjAscj1bXTtmb3IobGV0IHQ9MDt0PHM7dCsrKXIucHVzaChlLmdldEludDMyKCk+Pj4wKTtjb25zdCBuPXt0dGNUYWc6dCxtYWpvclZlcnNpb246aSxtaW5vclZlcnNpb246YSxudW1Gb250czpzLG9mZnNldFRhYmxlOnJ9O3N3aXRjaChpKXtjYXNlIDE6cmV0dXJuIG47Y2FzZSAyOm4uZHNpZ1RhZz1lLmdldEludDMyKCk+Pj4wO24uZHNpZ0xlbmd0aD1lLmdldEludDMyKCk+Pj4wO24uZHNpZ09mZnNldD1lLmdldEludDMyKCk+Pj4wO3JldHVybiBufXRocm93IG5ldyBGb3JtYXRFcnJvcihgSW52YWxpZCBUcnVlVHlwZSBDb2xsZWN0aW9uIG1ham9yVmVyc2lvbjogJHtpfS5gKX0oZSkscz10LnNwbGl0KCIrIik7bGV0IHI7Zm9yKGxldCBuPTA7bjxpO24rKyl7ZS5wb3M9KGUuc3RhcnR8fDApK2Fbbl07Y29uc3QgaT1yZWFkT3BlblR5cGVIZWFkZXIoZSksbz1yZWFkVGFibGVzKGUsaS5udW1UYWJsZXMpO2lmKCFvLm5hbWUpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCdUcnVlVHlwZSBDb2xsZWN0aW9uIGZvbnQgbXVzdCBjb250YWluIGEgIm5hbWUiIHRhYmxlLicpO2NvbnN0W2ddPXJlYWROYW1lVGFibGUoby5uYW1lKTtmb3IobGV0IGU9MCxhPWcubGVuZ3RoO2U8YTtlKyspZm9yKGxldCBhPTAsbj1nW2VdLmxlbmd0aDthPG47YSsrKXtjb25zdCBuPWdbZV1bYV0/LnJlcGxhY2VBbGwoL1xzL2csIiIpO2lmKG4pe2lmKG49PT10KXJldHVybntoZWFkZXI6aSx0YWJsZXM6b307aWYoIShzLmxlbmd0aDwyKSlmb3IoY29uc3QgZSBvZiBzKW49PT1lJiYocj17bmFtZTplLGhlYWRlcjppLHRhYmxlczpvfSl9fX1pZihyKXt3YXJuKGBUcnVlVHlwZSBDb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gIiR7dH0iIGZvbnQsIGZhbGxpbmcgYmFjayB0byAiJHtyLm5hbWV9IiBmb250IGluc3RlYWQuYCk7cmV0dXJue2hlYWRlcjpyLmhlYWRlcix0YWJsZXM6ci50YWJsZXN9fXRocm93IG5ldyBGb3JtYXRFcnJvcihgVHJ1ZVR5cGUgQ29sbGVjdGlvbiBkb2VzIG5vdCBjb250YWluICIke3R9IiBmb250LmApfSh0LHRoaXMubmFtZSk7cj1lLmhlYWRlcjtuPWUudGFibGVzfWVsc2V7cj1yZWFkT3BlblR5cGVIZWFkZXIodCk7bj1yZWFkVGFibGVzKHQsci5udW1UYWJsZXMpfWNvbnN0IGM9IW5bIkNGRiAiXTtpZihjKXtpZighbi5sb2NhKXRocm93IG5ldyBGb3JtYXRFcnJvcignUmVxdWlyZWQgImxvY2EiIHRhYmxlIGlzIG5vdCBmb3VuZCcpO2lmKCFuLmdseWYpe3dhcm4oJ1JlcXVpcmVkICJnbHlmIiB0YWJsZSBpcyBub3QgZm91bmQgLS0gdHJ5aW5nIHRvIHJlY292ZXIuJyk7bi5nbHlmPXt0YWc6ImdseWYiLGRhdGE6bmV3IFVpbnQ4QXJyYXkoMCl9fXRoaXMuaXNPcGVuVHlwZT0hMX1lbHNle2NvbnN0IHQ9aS5jb21wb3NpdGUmJihpLmNpZFRvR2lkTWFwPy5sZW5ndGg+MHx8IShpLmNNYXAgaW5zdGFuY2VvZiBJZGVudGl0eUNNYXApKTtpZigiT1RUTyI9PT1yLnZlcnNpb24mJiF0fHwhbi5oZWFkfHwhbi5oaGVhfHwhbi5tYXhwfHwhbi5wb3N0KXtnPW5ldyBTdHJlYW0oblsiQ0ZGICJdLmRhdGEpO289bmV3IENGRkZvbnQoZyxpKTthZGp1c3RXaWR0aHMoaSk7cmV0dXJuIHRoaXMuY29udmVydChlLG8saSl9ZGVsZXRlIG4uZ2x5ZjtkZWxldGUgbi5sb2NhO2RlbGV0ZSBuLmZwZ207ZGVsZXRlIG4ucHJlcDtkZWxldGUgblsiY3Z0ICJdO3RoaXMuaXNPcGVuVHlwZT0hMH1pZighbi5tYXhwKXRocm93IG5ldyBGb3JtYXRFcnJvcignUmVxdWlyZWQgIm1heHAiIHRhYmxlIGlzIG5vdCBmb3VuZCcpO3QucG9zPSh0LnN0YXJ0fHwwKStuLm1heHAub2Zmc2V0O2xldCBDPXQuZ2V0SW50MzIoKTtjb25zdCBoPXQuZ2V0VWludDE2KCk7aWYoNjU1MzYhPT1DJiYyMDQ4MCE9PUMpe2lmKDY9PT1uLm1heHAubGVuZ3RoKUM9MjA0ODA7ZWxzZXtpZighKG4ubWF4cC5sZW5ndGg+PTMyKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoJyJtYXhwIiB0YWJsZSBoYXMgYSB3cm9uZyB2ZXJzaW9uIG51bWJlcicpO0M9NjU1MzZ9IWZ1bmN0aW9uIHdyaXRlVWludDMyKGUsdCxpKXtlW3QrM109MjU1Jmk7ZVt0KzJdPWk+Pj44O2VbdCsxXT1pPj4+MTY7ZVt0XT1pPj4+MjR9KG4ubWF4cC5kYXRhLDAsQyl9aWYoaS5zY2FsZUZhY3RvcnM/Lmxlbmd0aD09PWgmJmMpe2NvbnN0e3NjYWxlRmFjdG9yczplfT1pLHQ9aW50MTYobi5oZWFkLmRhdGFbNTBdLG4uaGVhZC5kYXRhWzUxXSksYT1uZXcgR2x5ZlRhYmxlKHtnbHlmVGFibGU6bi5nbHlmLmRhdGEsaXNHbHlwaExvY2F0aW9uc0xvbmc6dCxsb2NhVGFibGU6bi5sb2NhLmRhdGEsbnVtR2x5cGhzOmh9KTthLnNjYWxlKGUpO2NvbnN0e2dseWY6cyxsb2NhOnIsaXNMb2NhdGlvbkxvbmc6b309YS53cml0ZSgpO24uZ2x5Zi5kYXRhPXM7bi5sb2NhLmRhdGE9cjtpZihvIT09ISF0KXtuLmhlYWQuZGF0YVs1MF09MDtuLmhlYWQuZGF0YVs1MV09bz8xOjB9Y29uc3QgZz1uLmhtdHguZGF0YTtmb3IobGV0IHQ9MDt0PGg7dCsrKXtjb25zdCBpPTQqdCxhPU1hdGgucm91bmQoZVt0XSppbnQxNihnW2ldLGdbaSsxXSkpO2dbaV09YT4+OCYyNTU7Z1tpKzFdPTI1NSZhO3dyaXRlU2lnbmVkSW50MTYoZyxpKzIsTWF0aC5yb3VuZChlW3RdKnNpZ25lZEludDE2KGdbaSsyXSxnW2krM10pKSl9fWxldCBsPWgrMSxRPSEwO2lmKGw+NjU1MzUpe1E9ITE7bD1oO3dhcm4oIk5vdCBlbm91Z2ggc3BhY2UgaW4gZ2x5ZnMgdG8gZHVwbGljYXRlIGZpcnN0IGdseXBoLiIpfWxldCBFPTAsdT0wO2lmKEM+PTY1NTM2JiZuLm1heHAubGVuZ3RoPj0zMil7dC5wb3MrPTg7aWYodC5nZXRVaW50MTYoKT4yKXtuLm1heHAuZGF0YVsxNF09MDtuLm1heHAuZGF0YVsxNV09Mn10LnBvcys9NDtFPXQuZ2V0VWludDE2KCk7dC5wb3MrPTQ7dT10LmdldFVpbnQxNigpfW4ubWF4cC5kYXRhWzRdPWw+Pjg7bi5tYXhwLmRhdGFbNV09MjU1Jmw7Y29uc3QgZD1mdW5jdGlvbiBzYW5pdGl6ZVRUUHJvZ3JhbXMoZSx0LGksYSl7Y29uc3Qgcz17ZnVuY3Rpb25zRGVmaW5lZDpbXSxmdW5jdGlvbnNVc2VkOltdLGZ1bmN0aW9uc1N0YWNrRGVsdGFzOltdLHRvb0NvbXBsZXhUb0ZvbGxvd0Z1bmN0aW9uczohMSxoaW50c1ZhbGlkOiEwfTtlJiZzYW5pdGl6ZVRUUHJvZ3JhbShlLHMpO3QmJnNhbml0aXplVFRQcm9ncmFtKHQscyk7ZSYmZnVuY3Rpb24gY2hlY2tJbnZhbGlkRnVuY3Rpb25zKGUsdCl7aWYoIWUudG9vQ29tcGxleFRvRm9sbG93RnVuY3Rpb25zKWlmKGUuZnVuY3Rpb25zRGVmaW5lZC5sZW5ndGg+dCl7d2FybigiVFQ6IG1vcmUgZnVuY3Rpb25zIGRlZmluZWQgdGhhbiBleHBlY3RlZCIpO2UuaGludHNWYWxpZD0hMX1lbHNlIGZvcihsZXQgaT0wLGE9ZS5mdW5jdGlvbnNVc2VkLmxlbmd0aDtpPGE7aSsrKXtpZihpPnQpe3dhcm4oIlRUOiBpbnZhbGlkIGZ1bmN0aW9uIGlkOiAiK2kpO2UuaGludHNWYWxpZD0hMTtyZXR1cm59aWYoZS5mdW5jdGlvbnNVc2VkW2ldJiYhZS5mdW5jdGlvbnNEZWZpbmVkW2ldKXt3YXJuKCJUVDogdW5kZWZpbmVkIGZ1bmN0aW9uOiAiK2kpO2UuaGludHNWYWxpZD0hMTtyZXR1cm59fX0ocyxhKTtpZihpJiYxJmkubGVuZ3RoKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KGkubGVuZ3RoKzEpO2Uuc2V0KGkuZGF0YSk7aS5kYXRhPWV9cmV0dXJuIHMuaGludHNWYWxpZH0obi5mcGdtLG4ucHJlcCxuWyJjdnQgIl0sRSk7aWYoIWQpe2RlbGV0ZSBuLmZwZ207ZGVsZXRlIG4ucHJlcDtkZWxldGUgblsiY3Z0ICJdfSFmdW5jdGlvbiBzYW5pdGl6ZU1ldHJpY3MoZSx0LGksYSxzLHIpe2lmKCF0KXtpJiYoaS5kYXRhPW51bGwpO3JldHVybn1lLnBvcz0oZS5zdGFydHx8MCkrdC5vZmZzZXQ7ZS5wb3MrPTQ7ZS5wb3MrPTI7ZS5wb3MrPTI7ZS5wb3MrPTI7ZS5wb3MrPTI7ZS5wb3MrPTI7ZS5wb3MrPTI7ZS5wb3MrPTI7ZS5wb3MrPTI7ZS5wb3MrPTI7Y29uc3Qgbj1lLmdldFVpbnQxNigpO2UucG9zKz04O2UucG9zKz0yO2xldCBvPWUuZ2V0VWludDE2KCk7aWYoMCE9PW4pe2lmKCEoMiZpbnQxNihhLmRhdGFbNDRdLGEuZGF0YVs0NV0pKSl7dC5kYXRhWzIyXT0wO3QuZGF0YVsyM109MH19aWYobz5zKXtpbmZvKGBUaGUgbnVtT2ZNZXRyaWNzICgke299KSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtR2x5cGhzICgke3N9KS5gKTtvPXM7dC5kYXRhWzM0XT0oNjUyODAmbyk+Pjg7dC5kYXRhWzM1XT0yNTUmb31jb25zdCBnPXMtby0oaS5sZW5ndGgtNCpvPj4xKTtpZihnPjApe2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkoaS5sZW5ndGgrMipnKTtlLnNldChpLmRhdGEpO2lmKHIpe2VbaS5sZW5ndGhdPWkuZGF0YVsyXTtlW2kubGVuZ3RoKzFdPWkuZGF0YVszXX1pLmRhdGE9ZX19KHQsbi5oaGVhLG4uaG10eCxuLmhlYWQsbCxRKTtpZighbi5oZWFkKXRocm93IG5ldyBGb3JtYXRFcnJvcignUmVxdWlyZWQgImhlYWQiIHRhYmxlIGlzIG5vdCBmb3VuZCcpOyFmdW5jdGlvbiBzYW5pdGl6ZUhlYWQoZSx0LGkpe2NvbnN0IGE9ZS5kYXRhLHM9ZnVuY3Rpb24gaW50MzIoZSx0LGksYSl7cmV0dXJuKGU8PDI0KSsodDw8MTYpKyhpPDw4KSthfShhWzBdLGFbMV0sYVsyXSxhWzNdKTtpZihzPj4xNiE9MSl7aW5mbygiQXR0ZW1wdGluZyB0byBmaXggaW52YWxpZCB2ZXJzaW9uIGluIGhlYWQgdGFibGU6ICIrcyk7YVswXT0wO2FbMV09MTthWzJdPTA7YVszXT0wfWNvbnN0IHI9aW50MTYoYVs1MF0sYVs1MV0pO2lmKHI8MHx8cj4xKXtpbmZvKCJBdHRlbXB0aW5nIHRvIGZpeCBpbnZhbGlkIGluZGV4VG9Mb2NGb3JtYXQgaW4gaGVhZCB0YWJsZTogIityKTtjb25zdCBlPXQrMTtpZihpPT09ZTw8MSl7YVs1MF09MDthWzUxXT0wfWVsc2V7aWYoaSE9PWU8PDIpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJDb3VsZCBub3QgZml4IGluZGV4VG9Mb2NGb3JtYXQ6ICIrcik7YVs1MF09MDthWzUxXT0xfX19KG4uaGVhZCxoLGM/bi5sb2NhLmxlbmd0aDowKTtsZXQgZj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKGMpe2NvbnN0IGU9aW50MTYobi5oZWFkLmRhdGFbNTBdLG4uaGVhZC5kYXRhWzUxXSksdD1mdW5jdGlvbiBzYW5pdGl6ZUdseXBoTG9jYXRpb25zKGUsdCxpLGEscyxyLG4pe2xldCBvLGcsYztpZihhKXtvPTQ7Zz1mdW5jdGlvbiBmb250SXRlbURlY29kZUxvbmcoZSx0KXtyZXR1cm4gZVt0XTw8MjR8ZVt0KzFdPDwxNnxlW3QrMl08PDh8ZVt0KzNdfTtjPWZ1bmN0aW9uIGZvbnRJdGVtRW5jb2RlTG9uZyhlLHQsaSl7ZVt0XT1pPj4+MjQmMjU1O2VbdCsxXT1pPj4xNiYyNTU7ZVt0KzJdPWk+PjgmMjU1O2VbdCszXT0yNTUmaX19ZWxzZXtvPTI7Zz1mdW5jdGlvbiBmb250SXRlbURlY29kZShlLHQpe3JldHVybiBlW3RdPDw5fGVbdCsxXTw8MX07Yz1mdW5jdGlvbiBmb250SXRlbUVuY29kZShlLHQsaSl7ZVt0XT1pPj45JjI1NTtlW3QrMV09aT4+MSYyNTV9fWNvbnN0IEM9cj9pKzE6aSxoPW8qKDErQyksbD1uZXcgVWludDhBcnJheShoKTtsLnNldChlLmRhdGEuc3ViYXJyYXkoMCxoKSk7ZS5kYXRhPWw7Y29uc3QgUT10LmRhdGEsRT1RLmxlbmd0aCx1PW5ldyBVaW50OEFycmF5KEUpO2xldCBkLGY7Y29uc3QgcD1bXTtmb3IoZD0wLGY9MDtkPGkrMTtkKyssZis9byl7bGV0IGU9ZyhsLGYpO2U+RSYmKGU9RSk7cC5wdXNoKHtpbmRleDpkLG9mZnNldDplLGVuZE9mZnNldDowfSl9cC5zb3J0KCgoZSx0KT0+ZS5vZmZzZXQtdC5vZmZzZXQpKTtmb3IoZD0wO2Q8aTtkKyspcFtkXS5lbmRPZmZzZXQ9cFtkKzFdLm9mZnNldDtwLnNvcnQoKChlLHQpPT5lLmluZGV4LXQuaW5kZXgpKTtmb3IoZD0wO2Q8aTtkKyspe2NvbnN0e29mZnNldDplLGVuZE9mZnNldDp0fT1wW2RdO2lmKDAhPT1lfHwwIT09dClicmVhaztjb25zdCBpPXBbZCsxXS5vZmZzZXQ7aWYoMCE9PWkpe3BbZF0uZW5kT2Zmc2V0PWk7YnJlYWt9fWNvbnN0IG09cC5hdCgtMik7MCE9PW0ub2Zmc2V0JiYwPT09bS5lbmRPZmZzZXQmJihtLmVuZE9mZnNldD1FKTtjb25zdCB5PU9iamVjdC5jcmVhdGUobnVsbCk7bGV0IHc9MDtjKGwsMCx3KTtmb3IoZD0wLGY9bztkPGk7ZCsrLGYrPW8pe2NvbnN0IGU9c2FuaXRpemVHbHlwaChRLHBbZF0ub2Zmc2V0LHBbZF0uZW5kT2Zmc2V0LHUsdyxzKSx0PWUubGVuZ3RoOzA9PT10JiYoeVtkXT0hMCk7ZS5zaXplT2ZJbnN0cnVjdGlvbnM+biYmKG49ZS5zaXplT2ZJbnN0cnVjdGlvbnMpO3crPXQ7YyhsLGYsdyl9aWYoMD09PXcpe2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkoWzAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw0OSwwXSk7Zm9yKGQ9MCxmPW87ZDxDO2QrKyxmKz1vKWMobCxmLGUubGVuZ3RoKTt0LmRhdGE9ZX1lbHNlIGlmKHIpe2NvbnN0IGk9ZyhsLG8pO2lmKHUubGVuZ3RoPmkrdyl0LmRhdGE9dS5zdWJhcnJheSgwLGkrdyk7ZWxzZXt0LmRhdGE9bmV3IFVpbnQ4QXJyYXkoaSt3KTt0LmRhdGEuc2V0KHUuc3ViYXJyYXkoMCx3KSl9dC5kYXRhLnNldCh1LnN1YmFycmF5KDAsaSksdyk7YyhlLmRhdGEsbC5sZW5ndGgtbyx3K2kpfWVsc2UgdC5kYXRhPXUuc3ViYXJyYXkoMCx3KTtyZXR1cm57bWlzc2luZ0dseXBoczp5LG1heFNpemVPZkluc3RydWN0aW9uczpufX0obi5sb2NhLG4uZ2x5ZixoLGUsZCxRLHUpO2Y9dC5taXNzaW5nR2x5cGhzO2lmKEM+PTY1NTM2JiZuLm1heHAubGVuZ3RoPj0zMil7bi5tYXhwLmRhdGFbMjZdPXQubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zPj44O24ubWF4cC5kYXRhWzI3XT0yNTUmdC5tYXhTaXplT2ZJbnN0cnVjdGlvbnN9fWlmKCFuLmhoZWEpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCdSZXF1aXJlZCAiaGhlYSIgdGFibGUgaXMgbm90IGZvdW5kJyk7aWYoMD09PW4uaGhlYS5kYXRhWzEwXSYmMD09PW4uaGhlYS5kYXRhWzExXSl7bi5oaGVhLmRhdGFbMTBdPTI1NTtuLmhoZWEuZGF0YVsxMV09MjU1fWNvbnN0IHA9e3VuaXRzUGVyRW06aW50MTYobi5oZWFkLmRhdGFbMThdLG4uaGVhZC5kYXRhWzE5XSkseU1heDpzaWduZWRJbnQxNihuLmhlYWQuZGF0YVs0Ml0sbi5oZWFkLmRhdGFbNDNdKSx5TWluOnNpZ25lZEludDE2KG4uaGVhZC5kYXRhWzM4XSxuLmhlYWQuZGF0YVszOV0pLGFzY2VudDpzaWduZWRJbnQxNihuLmhoZWEuZGF0YVs0XSxuLmhoZWEuZGF0YVs1XSksZGVzY2VudDpzaWduZWRJbnQxNihuLmhoZWEuZGF0YVs2XSxuLmhoZWEuZGF0YVs3XSksbGluZUdhcDpzaWduZWRJbnQxNihuLmhoZWEuZGF0YVs4XSxuLmhoZWEuZGF0YVs5XSl9O3RoaXMuYXNjZW50PXAuYXNjZW50L3AudW5pdHNQZXJFbTt0aGlzLmRlc2NlbnQ9cC5kZXNjZW50L3AudW5pdHNQZXJFbTt0aGlzLmxpbmVHYXA9cC5saW5lR2FwL3AudW5pdHNQZXJFbTtpZih0aGlzLmNzc0ZvbnRJbmZvPy5saW5lSGVpZ2h0KXt0aGlzLmxpbmVIZWlnaHQ9dGhpcy5jc3NGb250SW5mby5tZXRyaWNzLmxpbmVIZWlnaHQ7dGhpcy5saW5lR2FwPXRoaXMuY3NzRm9udEluZm8ubWV0cmljcy5saW5lR2FwfWVsc2UgdGhpcy5saW5lSGVpZ2h0PXRoaXMuYXNjZW50LXRoaXMuZGVzY2VudCt0aGlzLmxpbmVHYXA7bi5wb3N0JiZmdW5jdGlvbiByZWFkUG9zdFNjcmlwdFRhYmxlKGUsaSxhKXtjb25zdCBzPSh0LnN0YXJ0fHwwKStlLm9mZnNldDt0LnBvcz1zO2NvbnN0IHI9cytlLmxlbmd0aCxuPXQuZ2V0SW50MzIoKTt0LnNraXAoMjgpO2xldCBvLGcsYz0hMDtzd2l0Y2gobil7Y2FzZSA2NTUzNjpvPU9pO2JyZWFrO2Nhc2UgMTMxMDcyOmNvbnN0IGU9dC5nZXRVaW50MTYoKTtpZihlIT09YSl7Yz0hMTticmVha31jb25zdCBzPVtdO2ZvcihnPTA7ZzxlOysrZyl7Y29uc3QgZT10LmdldFVpbnQxNigpO2lmKGU+PTMyNzY4KXtjPSExO2JyZWFrfXMucHVzaChlKX1pZighYylicmVhaztjb25zdCBDPVtdLGg9W107Zm9yKDt0LnBvczxyOyl7Y29uc3QgZT10LmdldEJ5dGUoKTtoLmxlbmd0aD1lO2ZvcihnPTA7ZzxlOysrZyloW2ddPVN0cmluZy5mcm9tQ2hhckNvZGUodC5nZXRCeXRlKCkpO0MucHVzaChoLmpvaW4oIiIpKX1vPVtdO2ZvcihnPTA7ZzxlOysrZyl7Y29uc3QgZT1zW2ddO2U8MjU4P28ucHVzaChPaVtlXSk6by5wdXNoKENbZS0yNThdKX1icmVhaztjYXNlIDE5NjYwODpicmVhaztkZWZhdWx0Ondhcm4oIlVua25vd24vdW5zdXBwb3J0ZWQgcG9zdCB0YWJsZSB2ZXJzaW9uICIrbik7Yz0hMTtpLmRlZmF1bHRFbmNvZGluZyYmKG89aS5kZWZhdWx0RW5jb2RpbmcpfWkuZ2x5cGhOYW1lcz1vO3JldHVybiBjfShuLnBvc3QsaSxoKTtuLnBvc3Q9e3RhZzoicG9zdCIsZGF0YTpjcmVhdGVQb3N0VGFibGUoaSl9O2NvbnN0IG09W107ZnVuY3Rpb24gaGFzR2x5cGgoZSl7cmV0dXJuIWZbZV19aWYoaS5jb21wb3NpdGUpe2NvbnN0IGU9aS5jaWRUb0dpZE1hcHx8W10sdD0wPT09ZS5sZW5ndGg7aS5jTWFwLmZvckVhY2goKGZ1bmN0aW9uKGksYSl7InN0cmluZyI9PXR5cGVvZiBhJiYoYT1jb252ZXJ0Q2lkU3RyaW5nKGksYSwhMCkpO2lmKGE+NjU1MzUpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJNYXggc2l6ZSBvZiBDSUQgaXMgNjUsNTM1Iik7bGV0IHM9LTE7dD9zPWE6dm9pZCAwIT09ZVthXSYmKHM9ZVthXSk7cz49MCYmczxoJiZoYXNHbHlwaChzKSYmKG1baV09cyl9KSl9ZWxzZXtjb25zdCBlPWZ1bmN0aW9uIHJlYWRDbWFwVGFibGUoZSx0LGksYSl7aWYoIWUpe3dhcm4oIk5vIGNtYXAgdGFibGUgYXZhaWxhYmxlLiIpO3JldHVybntwbGF0Zm9ybUlkOi0xLGVuY29kaW5nSWQ6LTEsbWFwcGluZ3M6W10saGFzU2hvcnRDbWFwOiExfX1sZXQgcyxyPSh0LnN0YXJ0fHwwKStlLm9mZnNldDt0LnBvcz1yO3Quc2tpcCgyKTtjb25zdCBuPXQuZ2V0VWludDE2KCk7bGV0IG8sZz0hMTtmb3IobGV0IGU9MDtlPG47ZSsrKXtjb25zdCBzPXQuZ2V0VWludDE2KCkscj10LmdldFVpbnQxNigpLGM9dC5nZXRJbnQzMigpPj4+MDtsZXQgQz0hMTtpZihvPy5wbGF0Zm9ybUlkIT09c3x8bz8uZW5jb2RpbmdJZCE9PXIpe2lmKDAhPT1zfHwwIT09ciYmMSE9PXImJjMhPT1yKWlmKDE9PT1zJiYwPT09cilDPSEwO2Vsc2UgaWYoMyE9PXN8fDEhPT1yfHwhYSYmbyl7aWYoaSYmMz09PXMmJjA9PT1yKXtDPSEwO2xldCBpPSEwO2lmKGU8bi0xKXtjb25zdCBlPXQucGVla0J5dGVzKDIpO2ludDE2KGVbMF0sZVsxXSk8cyYmKGk9ITEpfWkmJihnPSEwKX19ZWxzZXtDPSEwO2l8fChnPSEwKX1lbHNlIEM9ITA7QyYmKG89e3BsYXRmb3JtSWQ6cyxlbmNvZGluZ0lkOnIsb2Zmc2V0OmN9KTtpZihnKWJyZWFrfX1vJiYodC5wb3M9citvLm9mZnNldCk7aWYoIW98fC0xPT09dC5wZWVrQnl0ZSgpKXt3YXJuKCJDb3VsZCBub3QgZmluZCBhIHByZWZlcnJlZCBjbWFwIHRhYmxlLiIpO3JldHVybntwbGF0Zm9ybUlkOi0xLGVuY29kaW5nSWQ6LTEsbWFwcGluZ3M6W10saGFzU2hvcnRDbWFwOiExfX1jb25zdCBjPXQuZ2V0VWludDE2KCk7bGV0IEM9ITE7Y29uc3QgaD1bXTtsZXQgbCxRO2lmKDA9PT1jKXt0LnNraXAoNCk7Zm9yKGw9MDtsPDI1NjtsKyspe2NvbnN0IGU9dC5nZXRCeXRlKCk7ZSYmaC5wdXNoKHtjaGFyQ29kZTpsLGdseXBoSWQ6ZX0pfUM9ITB9ZWxzZSBpZigyPT09Yyl7dC5za2lwKDQpO2NvbnN0IGU9W107bGV0IGk9MDtmb3IobGV0IGE9MDthPDI1NjthKyspe2NvbnN0IGE9dC5nZXRVaW50MTYoKT4+MztlLnB1c2goYSk7aT1NYXRoLm1heChhLGkpfWNvbnN0IGE9W107Zm9yKGxldCBlPTA7ZTw9aTtlKyspYS5wdXNoKHtmaXJzdENvZGU6dC5nZXRVaW50MTYoKSxlbnRyeUNvdW50OnQuZ2V0VWludDE2KCksaWREZWx0YTpzaWduZWRJbnQxNih0LmdldEJ5dGUoKSx0LmdldEJ5dGUoKSksaWRSYW5nZVBvczp0LnBvcyt0LmdldFVpbnQxNigpfSk7Zm9yKGxldCBpPTA7aTwyNTY7aSsrKWlmKDA9PT1lW2ldKXt0LnBvcz1hWzBdLmlkUmFuZ2VQb3MrMippO1E9dC5nZXRVaW50MTYoKTtoLnB1c2goe2NoYXJDb2RlOmksZ2x5cGhJZDpRfSl9ZWxzZXtjb25zdCBzPWFbZVtpXV07Zm9yKGw9MDtsPHMuZW50cnlDb3VudDtsKyspe2NvbnN0IGU9KGk8PDgpK2wrcy5maXJzdENvZGU7dC5wb3M9cy5pZFJhbmdlUG9zKzIqbDtRPXQuZ2V0VWludDE2KCk7MCE9PVEmJihRPShRK3MuaWREZWx0YSklNjU1MzYpO2gucHVzaCh7Y2hhckNvZGU6ZSxnbHlwaElkOlF9KX19fWVsc2UgaWYoND09PWMpe3Quc2tpcCg0KTtjb25zdCBlPXQuZ2V0VWludDE2KCk+PjE7dC5za2lwKDYpO2NvbnN0IGk9W107bGV0IGE7Zm9yKGE9MDthPGU7YSsrKWkucHVzaCh7ZW5kOnQuZ2V0VWludDE2KCl9KTt0LnNraXAoMik7Zm9yKGE9MDthPGU7YSsrKWlbYV0uc3RhcnQ9dC5nZXRVaW50MTYoKTtmb3IoYT0wO2E8ZTthKyspaVthXS5kZWx0YT10LmdldFVpbnQxNigpO2xldCBuLG89MDtmb3IoYT0wO2E8ZTthKyspe3M9aVthXTtjb25zdCByPXQuZ2V0VWludDE2KCk7aWYocil7bj0ocj4+MSktKGUtYSk7cy5vZmZzZXRJbmRleD1uO289TWF0aC5tYXgobyxuK3MuZW5kLXMuc3RhcnQrMSl9ZWxzZSBzLm9mZnNldEluZGV4PS0xfWNvbnN0IGc9W107Zm9yKGw9MDtsPG87bCsrKWcucHVzaCh0LmdldFVpbnQxNigpKTtmb3IoYT0wO2E8ZTthKyspe3M9aVthXTtyPXMuc3RhcnQ7Y29uc3QgZT1zLmVuZCx0PXMuZGVsdGE7bj1zLm9mZnNldEluZGV4O2ZvcihsPXI7bDw9ZTtsKyspaWYoNjU1MzUhPT1sKXtRPW48MD9sOmdbbitsLXJdO1E9USt0JjY1NTM1O2gucHVzaCh7Y2hhckNvZGU6bCxnbHlwaElkOlF9KX19fWVsc2UgaWYoNj09PWMpe3Quc2tpcCg0KTtjb25zdCBlPXQuZ2V0VWludDE2KCksaT10LmdldFVpbnQxNigpO2ZvcihsPTA7bDxpO2wrKyl7UT10LmdldFVpbnQxNigpO2NvbnN0IGk9ZStsO2gucHVzaCh7Y2hhckNvZGU6aSxnbHlwaElkOlF9KX19ZWxzZXtpZigxMiE9PWMpe3dhcm4oImNtYXAgdGFibGUgaGFzIHVuc3VwcG9ydGVkIGZvcm1hdDogIitjKTtyZXR1cm57cGxhdGZvcm1JZDotMSxlbmNvZGluZ0lkOi0xLG1hcHBpbmdzOltdLGhhc1Nob3J0Q21hcDohMX19e3Quc2tpcCgxMCk7Y29uc3QgZT10LmdldEludDMyKCk+Pj4wO2ZvcihsPTA7bDxlO2wrKyl7Y29uc3QgZT10LmdldEludDMyKCk+Pj4wLGk9dC5nZXRJbnQzMigpPj4+MDtsZXQgYT10LmdldEludDMyKCk+Pj4wO2ZvcihsZXQgdD1lO3Q8PWk7dCsrKWgucHVzaCh7Y2hhckNvZGU6dCxnbHlwaElkOmErK30pfX19aC5zb3J0KChmdW5jdGlvbihlLHQpe3JldHVybiBlLmNoYXJDb2RlLXQuY2hhckNvZGV9KSk7Zm9yKGxldCBlPTE7ZTxoLmxlbmd0aDtlKyspaWYoaFtlLTFdLmNoYXJDb2RlPT09aFtlXS5jaGFyQ29kZSl7aC5zcGxpY2UoZSwxKTtlLS19cmV0dXJue3BsYXRmb3JtSWQ6by5wbGF0Zm9ybUlkLGVuY29kaW5nSWQ6by5lbmNvZGluZ0lkLG1hcHBpbmdzOmgsaGFzU2hvcnRDbWFwOkN9fShuLmNtYXAsdCx0aGlzLmlzU3ltYm9saWNGb250LGkuaGFzRW5jb2RpbmcpLGE9ZS5wbGF0Zm9ybUlkLHM9ZS5lbmNvZGluZ0lkLHI9ZS5tYXBwaW5ncztsZXQgbz1bXSxnPSExOyFpLmhhc0VuY29kaW5nfHwiTWFjUm9tYW5FbmNvZGluZyIhPT1pLmJhc2VFbmNvZGluZ05hbWUmJiJXaW5BbnNpRW5jb2RpbmciIT09aS5iYXNlRW5jb2RpbmdOYW1lfHwobz1nZXRFbmNvZGluZyhpLmJhc2VFbmNvZGluZ05hbWUpKTtpZihpLmhhc0VuY29kaW5nJiYhdGhpcy5pc1N5bWJvbGljRm9udCYmKDM9PT1hJiYxPT09c3x8MT09PWEmJjA9PT1zKSl7Y29uc3QgZT1SaSgpO2ZvcihsZXQgdD0wO3Q8MjU2O3QrKyl7bGV0IG47bj12b2lkIDAhPT10aGlzLmRpZmZlcmVuY2VzW3RdP3RoaXMuZGlmZmVyZW5jZXNbdF06by5sZW5ndGgmJiIiIT09b1t0XT9vW3RdOmZpW3RdO2lmKCFuKWNvbnRpbnVlO2NvbnN0IGc9cmVjb3ZlckdseXBoTmFtZShuLGUpO2xldCBjOzM9PT1hJiYxPT09cz9jPWVbZ106MT09PWEmJjA9PT1zJiYoYz1kaS5pbmRleE9mKGcpKTtpZih2b2lkIDA9PT1jKXtpZighaS5nbHlwaE5hbWVzJiZpLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwJiYhKHRoaXMudG9Vbmljb2RlIGluc3RhbmNlb2YgSWRlbnRpdHlUb1VuaWNvZGVNYXApKXtjb25zdCBlPXRoaXMudG9Vbmljb2RlLmdldCh0KTtlJiYoYz1lLmNvZGVQb2ludEF0KDApKX1pZih2b2lkIDA9PT1jKWNvbnRpbnVlfWZvcihjb25zdCBlIG9mIHIpaWYoZS5jaGFyQ29kZT09PWMpe21bdF09ZS5nbHlwaElkO2JyZWFrfX19ZWxzZSBpZigwPT09YSl7Zm9yKGNvbnN0IGUgb2YgciltW2UuY2hhckNvZGVdPWUuZ2x5cGhJZDtnPSEwfWVsc2UgaWYoMz09PWEmJjA9PT1zKWZvcihjb25zdCBlIG9mIHIpe2xldCB0PWUuY2hhckNvZGU7dD49NjE0NDAmJnQ8PTYxNjk1JiYodCY9MjU1KTttW3RdPWUuZ2x5cGhJZH1lbHNlIGZvcihjb25zdCBlIG9mIHIpbVtlLmNoYXJDb2RlXT1lLmdseXBoSWQ7aWYoaS5nbHlwaE5hbWVzJiYoby5sZW5ndGh8fHRoaXMuZGlmZmVyZW5jZXMubGVuZ3RoKSlmb3IobGV0IGU9MDtlPDI1NjsrK2Upe2lmKCFnJiZ2b2lkIDAhPT1tW2VdKWNvbnRpbnVlO2NvbnN0IHQ9dGhpcy5kaWZmZXJlbmNlc1tlXXx8b1tlXTtpZighdCljb250aW51ZTtjb25zdCBhPWkuZ2x5cGhOYW1lcy5pbmRleE9mKHQpO2E+MCYmaGFzR2x5cGgoYSkmJihtW2VdPWEpfX0wPT09bS5sZW5ndGgmJihtWzBdPTApO2xldCB5PWwtMTtRfHwoeT0wKTtpZighaS5jc3NGb250SW5mbyl7Y29uc3QgZT1hZGp1c3RNYXBwaW5nKG0saGFzR2x5cGgseSx0aGlzLnRvVW5pY29kZSk7dGhpcy50b0ZvbnRDaGFyPWUudG9Gb250Q2hhcjtuLmNtYXA9e3RhZzoiY21hcCIsZGF0YTpjcmVhdGVDbWFwVGFibGUoZS5jaGFyQ29kZVRvR2x5cGhJZCxlLnRvVW5pY29kZUV4dHJhTWFwLGwpfTtuWyJPUy8yIl0mJmZ1bmN0aW9uIHZhbGlkYXRlT1MyVGFibGUoZSx0KXt0LnBvcz0odC5zdGFydHx8MCkrZS5vZmZzZXQ7Y29uc3QgaT10LmdldFVpbnQxNigpO3Quc2tpcCg2MCk7Y29uc3QgYT10LmdldFVpbnQxNigpO2lmKGk8NCYmNzY4JmEpcmV0dXJuITE7aWYodC5nZXRVaW50MTYoKT50LmdldFVpbnQxNigpKXJldHVybiExO3Quc2tpcCg2KTtpZigwPT09dC5nZXRVaW50MTYoKSlyZXR1cm4hMTtlLmRhdGFbOF09ZS5kYXRhWzldPTA7cmV0dXJuITB9KG5bIk9TLzIiXSx0KXx8KG5bIk9TLzIiXT17dGFnOiJPUy8yIixkYXRhOmNyZWF0ZU9TMlRhYmxlKGksZS5jaGFyQ29kZVRvR2x5cGhJZCxwKX0pfWlmKCFjKXRyeXtnPW5ldyBTdHJlYW0oblsiQ0ZGICJdLmRhdGEpO289bmV3IENGRlBhcnNlcihnLGksWWkpLnBhcnNlKCk7by5kdXBsaWNhdGVGaXJzdEdseXBoKCk7Y29uc3QgZT1uZXcgQ0ZGQ29tcGlsZXIobyk7blsiQ0ZGICJdLmRhdGE9ZS5jb21waWxlKCl9Y2F0Y2h7d2FybigiRmFpbGVkIHRvIGNvbXBpbGUgZm9udCAiK2kubG9hZGVkTmFtZSl9aWYobi5uYW1lKXtjb25zdFt0LGFdPXJlYWROYW1lVGFibGUobi5uYW1lKTtuLm5hbWUuZGF0YT1jcmVhdGVOYW1lVGFibGUoZSx0KTt0aGlzLnBzTmFtZT10WzBdWzZdfHxudWxsO2kuY29tcG9zaXRlfHxmdW5jdGlvbiBhZGp1c3RUcnVlVHlwZVRvVW5pY29kZShlLHQsaSl7aWYoZS5pc0ludGVybmFsRm9udClyZXR1cm47aWYoZS5oYXNJbmNsdWRlZFRvVW5pY29kZU1hcClyZXR1cm47aWYoZS5oYXNFbmNvZGluZylyZXR1cm47aWYoZS50b1VuaWNvZGUgaW5zdGFuY2VvZiBJZGVudGl0eVRvVW5pY29kZU1hcClyZXR1cm47aWYoIXQpcmV0dXJuO2lmKDA9PT1pLmxlbmd0aClyZXR1cm47aWYoZS5kZWZhdWx0RW5jb2Rpbmc9PT1waSlyZXR1cm47Zm9yKGNvbnN0IGUgb2YgaSlpZighaXNXaW5OYW1lUmVjb3JkKGUpKXJldHVybjtjb25zdCBhPXBpLHM9W10scj1SaSgpO2Zvcihjb25zdCBlIGluIGEpe2NvbnN0IHQ9YVtlXTtpZigiIj09PXQpY29udGludWU7Y29uc3QgaT1yW3RdO3ZvaWQgMCE9PWkmJihzW2VdPVN0cmluZy5mcm9tQ2hhckNvZGUoaSkpfXMubGVuZ3RoPjAmJmUudG9Vbmljb2RlLmFtZW5kKHMpfShpLHRoaXMuaXNTeW1ib2xpY0ZvbnQsYSl9ZWxzZSBuLm5hbWU9e3RhZzoibmFtZSIsZGF0YTpjcmVhdGVOYW1lVGFibGUodGhpcy5uYW1lKX07Y29uc3Qgdz1uZXcgT3BlblR5cGVGaWxlQnVpbGRlcihyLnZlcnNpb24pO2Zvcihjb25zdCBlIGluIG4pdy5hZGRUYWJsZShlLG5bZV0uZGF0YSk7cmV0dXJuIHcudG9BcnJheSgpfWNvbnZlcnQoZSx0LGkpe2kuZml4ZWRQaXRjaD0hMTtpLmJ1aWx0SW5FbmNvZGluZyYmZnVuY3Rpb24gYWRqdXN0VHlwZTFUb1VuaWNvZGUoZSx0KXtpZihlLmlzSW50ZXJuYWxGb250KXJldHVybjtpZihlLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwKXJldHVybjtpZih0PT09ZS5kZWZhdWx0RW5jb2RpbmcpcmV0dXJuO2lmKGUudG9Vbmljb2RlIGluc3RhbmNlb2YgSWRlbnRpdHlUb1VuaWNvZGVNYXApcmV0dXJuO2NvbnN0IGk9W10sYT1SaSgpO2Zvcihjb25zdCBzIGluIHQpe2lmKGUuaGFzRW5jb2RpbmcmJihlLmJhc2VFbmNvZGluZ05hbWV8fHZvaWQgMCE9PWUuZGlmZmVyZW5jZXNbc10pKWNvbnRpbnVlO2NvbnN0IHI9Z2V0VW5pY29kZUZvckdseXBoKHRbc10sYSk7LTEhPT1yJiYoaVtzXT1TdHJpbmcuZnJvbUNoYXJDb2RlKHIpKX1pLmxlbmd0aD4wJiZlLnRvVW5pY29kZS5hbWVuZChpKX0oaSxpLmJ1aWx0SW5FbmNvZGluZyk7bGV0IHM9MTt0IGluc3RhbmNlb2YgQ0ZGRm9udCYmKHM9dC5udW1HbHlwaHMtMSk7Y29uc3Qgcj10LmdldEdseXBoTWFwcGluZyhpKTtsZXQgbj1udWxsLG89cixnPW51bGw7aWYoIWkuY3NzRm9udEluZm8pe249YWRqdXN0TWFwcGluZyhyLHQuaGFzR2x5cGhJZC5iaW5kKHQpLHMsdGhpcy50b1VuaWNvZGUpO3RoaXMudG9Gb250Q2hhcj1uLnRvRm9udENoYXI7bz1uLmNoYXJDb2RlVG9HbHlwaElkO2c9bi50b1VuaWNvZGVFeHRyYU1hcH1jb25zdCBjPXQubnVtR2x5cGhzO2Z1bmN0aW9uIGdldENoYXJDb2RlcyhlLHQpe2xldCBpPW51bGw7Zm9yKGNvbnN0IGEgaW4gZSl0PT09ZVthXSYmKGl8fD1bXSkucHVzaCgwfGEpO3JldHVybiBpfWZ1bmN0aW9uIGNyZWF0ZUNoYXJDb2RlKGUsdCl7Zm9yKGNvbnN0IGkgaW4gZSlpZih0PT09ZVtpXSlyZXR1cm4gMHxpO24uY2hhckNvZGVUb0dseXBoSWRbbi5uZXh0QXZhaWxhYmxlRm9udENoYXJDb2RlXT10O3JldHVybiBuLm5leHRBdmFpbGFibGVGb250Q2hhckNvZGUrK31jb25zdCBDPXQuc2VhY3M7aWYobiYmQz8ubGVuZ3RoKXtjb25zdCBlPWkuZm9udE1hdHJpeHx8YSxzPXQuZ2V0Q2hhcnNldCgpLG89T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IobGV0IHQgaW4gQyl7dHw9MDtjb25zdCBpPUNbdF0sYT1maVtpWzJdXSxnPWZpW2lbM11dLGM9cy5pbmRleE9mKGEpLGg9cy5pbmRleE9mKGcpO2lmKGM8MHx8aDwwKWNvbnRpbnVlO2NvbnN0IGw9e3g6aVswXSplWzBdK2lbMV0qZVsyXStlWzRdLHk6aVswXSplWzFdK2lbMV0qZVszXStlWzVdfSxRPWdldENoYXJDb2RlcyhyLHQpO2lmKFEpZm9yKGNvbnN0IGUgb2YgUSl7Y29uc3QgdD1uLmNoYXJDb2RlVG9HbHlwaElkLGk9Y3JlYXRlQ2hhckNvZGUodCxjKSxhPWNyZWF0ZUNoYXJDb2RlKHQsaCk7b1tlXT17YmFzZUZvbnRDaGFyQ29kZTppLGFjY2VudEZvbnRDaGFyQ29kZTphLGFjY2VudE9mZnNldDpsfX19aS5zZWFjTWFwPW99Y29uc3QgaD0xLyhpLmZvbnRNYXRyaXh8fGEpWzBdLGw9bmV3IE9wZW5UeXBlRmlsZUJ1aWxkZXIoIk9UVE8iKTtsLmFkZFRhYmxlKCJDRkYgIix0LmRhdGEpO2wuYWRkVGFibGUoIk9TLzIiLGNyZWF0ZU9TMlRhYmxlKGksbykpO2wuYWRkVGFibGUoImNtYXAiLGNyZWF0ZUNtYXBUYWJsZShvLGcsYykpO2wuYWRkVGFibGUoImhlYWQiLCJcMAFcMFwwXDBcMBBcMFwwXDBcMFwwXw88w7VcMFwwIitzYWZlU3RyaW5nMTYoaCkrIlwwXDBcMFwwwp5cdn4nXDBcMFwwXDDCnlx2fidcMFwwIitzYWZlU3RyaW5nMTYoaS5kZXNjZW50KSsiD8O/IitzYWZlU3RyaW5nMTYoaS5hc2NlbnQpK3N0cmluZzE2KGkuaXRhbGljQW5nbGU/MjowKSsiXDARXDBcMFwwXDBcMFwwIik7bC5hZGRUYWJsZSgiaGhlYSIsIlwwAVwwXDAiK3NhZmVTdHJpbmcxNihpLmFzY2VudCkrc2FmZVN0cmluZzE2KGkuZGVzY2VudCkrIlwwXDDDv8O/XDBcMFwwXDBcMFwwIitzYWZlU3RyaW5nMTYoaS5jYXBIZWlnaHQpK3NhZmVTdHJpbmcxNihNYXRoLnRhbihpLml0YWxpY0FuZ2xlKSppLnhIZWlnaHQpKyJcMFwwXDBcMFwwXDBcMFwwXDBcMFwwXDAiK3N0cmluZzE2KGMpKTtsLmFkZFRhYmxlKCJobXR4IixmdW5jdGlvbiBmb250RmllbGRzSG10eCgpe2NvbnN0IGU9dC5jaGFyc3RyaW5ncyxpPXQuY2ZmP3QuY2ZmLndpZHRoczpudWxsO2xldCBhPSJcMFwwXDBcMCI7Zm9yKGxldCB0PTEscz1jO3Q8czt0Kyspe2xldCBzPTA7aWYoZSl7Y29uc3QgaT1lW3QtMV07cz0id2lkdGgiaW4gaT9pLndpZHRoOjB9ZWxzZSBpJiYocz1NYXRoLmNlaWwoaVt0XXx8MCkpO2ErPXN0cmluZzE2KHMpK3N0cmluZzE2KDApfXJldHVybiBhfSgpKTtsLmFkZFRhYmxlKCJtYXhwIiwiXDBcMFBcMCIrc3RyaW5nMTYoYykpO2wuYWRkVGFibGUoIm5hbWUiLGNyZWF0ZU5hbWVUYWJsZShlKSk7bC5hZGRUYWJsZSgicG9zdCIsY3JlYXRlUG9zdFRhYmxlKGkpKTtyZXR1cm4gbC50b0FycmF5KCl9Z2V0IHNwYWNlV2lkdGgoKXtjb25zdCBlPVsic3BhY2UiLCJtaW51cyIsIm9uZSIsImkiLCJJIl07bGV0IHQ7Zm9yKGNvbnN0IGkgb2YgZSl7aWYoaSBpbiB0aGlzLndpZHRocyl7dD10aGlzLndpZHRoc1tpXTticmVha31jb25zdCBlPVJpKClbaV07bGV0IGE9MDtpZih0aGlzLmNvbXBvc2l0ZSYmdGhpcy5jTWFwLmNvbnRhaW5zKGUpKXthPXRoaXMuY01hcC5sb29rdXAoZSk7InN0cmluZyI9PXR5cGVvZiBhJiYoYT1jb252ZXJ0Q2lkU3RyaW5nKGUsYSkpfSFhJiZ0aGlzLnRvVW5pY29kZSYmKGE9dGhpcy50b1VuaWNvZGUuY2hhckNvZGVPZihlKSk7YTw9MCYmKGE9ZSk7dD10aGlzLndpZHRoc1thXTtpZih0KWJyZWFrfXJldHVybiBzaGFkb3codGhpcywic3BhY2VXaWR0aCIsdHx8dGhpcy5kZWZhdWx0V2lkdGgpfV9jaGFyVG9HbHlwaChlLHQ9ITEpe2xldCBpLGEscyxyPXRoaXMuX2dseXBoQ2FjaGVbZV07aWYocj8uaXNTcGFjZT09PXQpcmV0dXJuIHI7bGV0IG49ZTtpZih0aGlzLmNNYXA/LmNvbnRhaW5zKGUpKXtuPXRoaXMuY01hcC5sb29rdXAoZSk7InN0cmluZyI9PXR5cGVvZiBuJiYobj1jb252ZXJ0Q2lkU3RyaW5nKGUsbikpfWE9dGhpcy53aWR0aHNbbl07Im51bWJlciIhPXR5cGVvZiBhJiYoYT10aGlzLmRlZmF1bHRXaWR0aCk7Y29uc3Qgbz10aGlzLnZtZXRyaWNzPy5bbl07bGV0IGc9dGhpcy50b1VuaWNvZGUuZ2V0KGUpfHxlOyJudW1iZXIiPT10eXBlb2YgZyYmKGc9U3RyaW5nLmZyb21DaGFyQ29kZShnKSk7bGV0IGM9dm9pZCAwIT09dGhpcy50b0ZvbnRDaGFyW2VdO2k9dGhpcy50b0ZvbnRDaGFyW2VdfHxlO2lmKHRoaXMubWlzc2luZ0ZpbGUpe2NvbnN0IHQ9dGhpcy5kaWZmZXJlbmNlc1tlXXx8dGhpcy5kZWZhdWx0RW5jb2RpbmdbZV07Ii5ub3RkZWYiIT09dCYmIiIhPT10fHwiVHlwZTEiIT09dGhpcy50eXBlfHwoaT0zMik7aT1mdW5jdGlvbiBtYXBTcGVjaWFsVW5pY29kZVZhbHVlcyhlKXtyZXR1cm4gZT49NjU1MjAmJmU8PTY1NTM1PzA6ZT49NjI5NzYmJmU8PTYzNzQzP3hpKClbZV18fGU6MTczPT09ZT80NTplfShpKX10aGlzLmlzVHlwZTNGb250JiYocz1pKTtsZXQgQz1udWxsO2lmKHRoaXMuc2VhY01hcD8uW2VdKXtjPSEwO2NvbnN0IHQ9dGhpcy5zZWFjTWFwW2VdO2k9dC5iYXNlRm9udENoYXJDb2RlO0M9e2ZvbnRDaGFyOlN0cmluZy5mcm9tQ29kZVBvaW50KHQuYWNjZW50Rm9udENoYXJDb2RlKSxvZmZzZXQ6dC5hY2NlbnRPZmZzZXR9fWxldCBoPSIiOyJudW1iZXIiPT10eXBlb2YgaSYmKGk8PTExMTQxMTE/aD1TdHJpbmcuZnJvbUNvZGVQb2ludChpKTp3YXJuKGBjaGFyVG9HbHlwaCAtIGludmFsaWQgZm9udENoYXJDb2RlOiAke2l9YCkpO3I9bmV3IGZvbnRzX0dseXBoKGUsaCxnLEMsYSxvLHMsdCxjKTtyZXR1cm4gdGhpcy5fZ2x5cGhDYWNoZVtlXT1yfWNoYXJzVG9HbHlwaHMoZSl7bGV0IHQ9dGhpcy5fY2hhcnNDYWNoZVtlXTtpZih0KXJldHVybiB0O3Q9W107aWYodGhpcy5jTWFwKXtjb25zdCBpPU9iamVjdC5jcmVhdGUobnVsbCksYT1lLmxlbmd0aDtsZXQgcz0wO2Zvcig7czxhOyl7dGhpcy5jTWFwLnJlYWRDaGFyQ29kZShlLHMsaSk7Y29uc3R7Y2hhcmNvZGU6YSxsZW5ndGg6cn09aTtzKz1yO2NvbnN0IG49dGhpcy5fY2hhclRvR2x5cGgoYSwxPT09ciYmMzI9PT1lLmNoYXJDb2RlQXQocy0xKSk7dC5wdXNoKG4pfX1lbHNlIGZvcihsZXQgaT0wLGE9ZS5sZW5ndGg7aTxhOysraSl7Y29uc3QgYT1lLmNoYXJDb2RlQXQoaSkscz10aGlzLl9jaGFyVG9HbHlwaChhLDMyPT09YSk7dC5wdXNoKHMpfXJldHVybiB0aGlzLl9jaGFyc0NhY2hlW2VdPXR9Z2V0Q2hhclBvc2l0aW9ucyhlKXtjb25zdCB0PVtdO2lmKHRoaXMuY01hcCl7Y29uc3QgaT1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBhPTA7Zm9yKDthPGUubGVuZ3RoOyl7dGhpcy5jTWFwLnJlYWRDaGFyQ29kZShlLGEsaSk7Y29uc3Qgcz1pLmxlbmd0aDt0LnB1c2goW2EsYStzXSk7YSs9c319ZWxzZSBmb3IobGV0IGk9MCxhPWUubGVuZ3RoO2k8YTsrK2kpdC5wdXNoKFtpLGkrMV0pO3JldHVybiB0fWdldCBnbHlwaENhY2hlVmFsdWVzKCl7cmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fZ2x5cGhDYWNoZSl9ZW5jb2RlU3RyaW5nKGUpe2NvbnN0IHQ9W10saT1bXSxoYXNDdXJyZW50QnVmRXJyb3JzPSgpPT50Lmxlbmd0aCUyPT0xLGE9dGhpcy50b1VuaWNvZGUgaW5zdGFuY2VvZiBJZGVudGl0eVRvVW5pY29kZU1hcD9lPT50aGlzLnRvVW5pY29kZS5jaGFyQ29kZU9mKGUpOmU9PnRoaXMudG9Vbmljb2RlLmNoYXJDb2RlT2YoU3RyaW5nLmZyb21Db2RlUG9pbnQoZSkpO2ZvcihsZXQgcz0wLHI9ZS5sZW5ndGg7czxyO3MrKyl7Y29uc3Qgcj1lLmNvZGVQb2ludEF0KHMpO3I+NTUyOTUmJihyPDU3MzQ0fHxyPjY1NTMzKSYmcysrO2lmKHRoaXMudG9Vbmljb2RlKXtjb25zdCBlPWEocik7aWYoLTEhPT1lKXtpZihoYXNDdXJyZW50QnVmRXJyb3JzKCkpe3QucHVzaChpLmpvaW4oIiIpKTtpLmxlbmd0aD0wfWZvcihsZXQgdD0odGhpcy5jTWFwP3RoaXMuY01hcC5nZXRDaGFyQ29kZUxlbmd0aChlKToxKS0xO3Q+PTA7dC0tKWkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGU+PjgqdCYyNTUpKTtjb250aW51ZX19aWYoIWhhc0N1cnJlbnRCdWZFcnJvcnMoKSl7dC5wdXNoKGkuam9pbigiIikpO2kubGVuZ3RoPTB9aS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KHIpKX10LnB1c2goaS5qb2luKCIiKSk7cmV0dXJuIHR9fWNsYXNzIEVycm9yRm9udHtjb25zdHJ1Y3RvcihlKXt0aGlzLmVycm9yPWU7dGhpcy5sb2FkZWROYW1lPSJnX2ZvbnRfZXJyb3IiO3RoaXMubWlzc2luZ0ZpbGU9ITB9Y2hhcnNUb0dseXBocygpe3JldHVybltdfWVuY29kZVN0cmluZyhlKXtyZXR1cm5bZV19ZXhwb3J0RGF0YShlPSExKXtyZXR1cm57ZXJyb3I6dGhpcy5lcnJvcn19fWNvbnN0IEVhPTIsdWE9MyxkYT00LGZhPTUscGE9NixtYT03O2NsYXNzIFBhdHRlcm57Y29uc3RydWN0b3IoKXt1bnJlYWNoYWJsZSgiQ2Fubm90IGluaXRpYWxpemUgUGF0dGVybi4iKX1zdGF0aWMgcGFyc2VTaGFkaW5nKGUsdCxpLGEscyl7Y29uc3Qgcj1lIGluc3RhbmNlb2YgQmFzZVN0cmVhbT9lLmRpY3Q6ZSxuPXIuZ2V0KCJTaGFkaW5nVHlwZSIpO3RyeXtzd2l0Y2gobil7Y2FzZSBFYTpjYXNlIHVhOnJldHVybiBuZXcgUmFkaWFsQXhpYWxTaGFkaW5nKHIsdCxpLGEscyk7Y2FzZSBkYTpjYXNlIGZhOmNhc2UgcGE6Y2FzZSBtYTpyZXR1cm4gbmV3IE1lc2hTaGFkaW5nKGUsdCxpLGEscyk7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlVuc3VwcG9ydGVkIFNoYWRpbmdUeXBlOiAiK24pfX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTt3YXJuKGUpO3JldHVybiBuZXcgRHVtbXlTaGFkaW5nfX19Y2xhc3MgQmFzZVNoYWRpbmd7c3RhdGljIFNNQUxMX05VTUJFUj0xZS02O2NvbnN0cnVjdG9yKCl7dGhpcy5jb25zdHJ1Y3Rvcj09PUJhc2VTaGFkaW5nJiZ1bnJlYWNoYWJsZSgiQ2Fubm90IGluaXRpYWxpemUgQmFzZVNoYWRpbmcuIil9Z2V0SVIoKXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGBnZXRJUmAgY2FsbGVkLiIpfX1jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmcgZXh0ZW5kcyBCYXNlU2hhZGluZ3tjb25zdHJ1Y3RvcihlLHQsaSxhLHMpe3N1cGVyKCk7dGhpcy5jb29yZHNBcnI9ZS5nZXRBcnJheSgiQ29vcmRzIik7dGhpcy5zaGFkaW5nVHlwZT1lLmdldCgiU2hhZGluZ1R5cGUiKTtjb25zdCByPUNvbG9yU3BhY2UucGFyc2Uoe2NzOmUuZ2V0UmF3KCJDUyIpfHxlLmdldFJhdygiQ29sb3JTcGFjZSIpLHhyZWY6dCxyZXNvdXJjZXM6aSxwZGZGdW5jdGlvbkZhY3Rvcnk6YSxsb2NhbENvbG9yU3BhY2VDYWNoZTpzfSksbj1lLmdldEFycmF5KCJCQm94Iik7dGhpcy5iYm94PUFycmF5LmlzQXJyYXkobikmJjQ9PT1uLmxlbmd0aD9VdGlsLm5vcm1hbGl6ZVJlY3Qobik6bnVsbDtsZXQgbz0wLGc9MTtpZihlLmhhcygiRG9tYWluIikpe2NvbnN0IHQ9ZS5nZXRBcnJheSgiRG9tYWluIik7bz10WzBdO2c9dFsxXX1sZXQgYz0hMSxDPSExO2lmKGUuaGFzKCJFeHRlbmQiKSl7Y29uc3QgdD1lLmdldEFycmF5KCJFeHRlbmQiKTtjPXRbMF07Qz10WzFdfWlmKCEodGhpcy5zaGFkaW5nVHlwZSE9PXVhfHxjJiZDKSl7Y29uc3RbZSx0LGksYSxzLHJdPXRoaXMuY29vcmRzQXJyLG49TWF0aC5oeXBvdChlLWEsdC1zKTtpPD1yK24mJnI8PWkrbiYmd2FybigiVW5zdXBwb3J0ZWQgcmFkaWFsIGdyYWRpZW50LiIpfXRoaXMuZXh0ZW5kU3RhcnQ9Yzt0aGlzLmV4dGVuZEVuZD1DO2NvbnN0IGg9ZS5nZXRSYXcoIkZ1bmN0aW9uIiksbD1hLmNyZWF0ZUZyb21BcnJheShoKSxRPShnLW8pLzg0MCxFPXRoaXMuY29sb3JTdG9wcz1bXTtpZihvPj1nfHxRPD0wKXtpbmZvKCJCYWQgc2hhZGluZyBkb21haW4uIik7cmV0dXJufWNvbnN0IHU9bmV3IEZsb2F0MzJBcnJheShyLm51bUNvbXBzKSxkPW5ldyBGbG9hdDMyQXJyYXkoMSk7bGV0IGYscD0wO2RbMF09bztsKGQsMCx1LDApO2xldCBtPXIuZ2V0UmdiKHUsMCk7Y29uc3QgeT1VdGlsLm1ha2VIZXhDb2xvcihtWzBdLG1bMV0sbVsyXSk7RS5wdXNoKFswLHldKTtsZXQgdz0xO2RbMF09bytRO2woZCwwLHUsMCk7bGV0IGI9ci5nZXRSZ2IodSwwKSxEPWJbMF0tbVswXSsxLEY9YlsxXS1tWzFdKzEsUz1iWzJdLW1bMl0rMSxrPWJbMF0tbVswXS0xLE49YlsxXS1tWzFdLTEsUj1iWzJdLW1bMl0tMTtmb3IobGV0IGU9MjtlPDg0MDtlKyspe2RbMF09bytlKlE7bChkLDAsdSwwKTtmPXIuZ2V0UmdiKHUsMCk7Y29uc3QgdD1lLXA7RD1NYXRoLm1pbihELChmWzBdLW1bMF0rMSkvdCk7Rj1NYXRoLm1pbihGLChmWzFdLW1bMV0rMSkvdCk7Uz1NYXRoLm1pbihTLChmWzJdLW1bMl0rMSkvdCk7az1NYXRoLm1heChrLChmWzBdLW1bMF0tMSkvdCk7Tj1NYXRoLm1heChOLChmWzFdLW1bMV0tMSkvdCk7Uj1NYXRoLm1heChSLChmWzJdLW1bMl0tMSkvdCk7aWYoIShrPD1EJiZOPD1GJiZSPD1TKSl7Y29uc3QgZT1VdGlsLm1ha2VIZXhDb2xvcihiWzBdLGJbMV0sYlsyXSk7RS5wdXNoKFt3Lzg0MCxlXSk7RD1mWzBdLWJbMF0rMTtGPWZbMV0tYlsxXSsxO1M9ZlsyXS1iWzJdKzE7az1mWzBdLWJbMF0tMTtOPWZbMV0tYlsxXS0xO1I9ZlsyXS1iWzJdLTE7cD13O209Yn13PWU7Yj1mfWNvbnN0IEc9VXRpbC5tYWtlSGV4Q29sb3IoYlswXSxiWzFdLGJbMl0pO0UucHVzaChbMSxHXSk7bGV0IHg9InRyYW5zcGFyZW50IjtpZihlLmhhcygiQmFja2dyb3VuZCIpKXtmPXIuZ2V0UmdiKGUuZ2V0KCJCYWNrZ3JvdW5kIiksMCk7eD1VdGlsLm1ha2VIZXhDb2xvcihmWzBdLGZbMV0sZlsyXSl9aWYoIWMpe0UudW5zaGlmdChbMCx4XSk7RVsxXVswXSs9QmFzZVNoYWRpbmcuU01BTExfTlVNQkVSfWlmKCFDKXtFLmF0KC0xKVswXS09QmFzZVNoYWRpbmcuU01BTExfTlVNQkVSO0UucHVzaChbMSx4XSl9dGhpcy5jb2xvclN0b3BzPUV9Z2V0SVIoKXtjb25zdCBlPXRoaXMuY29vcmRzQXJyLHQ9dGhpcy5zaGFkaW5nVHlwZTtsZXQgaSxhLHMscixuO2lmKHQ9PT1FYSl7YT1bZVswXSxlWzFdXTtzPVtlWzJdLGVbM11dO3I9bnVsbDtuPW51bGw7aT0iYXhpYWwifWVsc2UgaWYodD09PXVhKXthPVtlWzBdLGVbMV1dO3M9W2VbM10sZVs0XV07cj1lWzJdO249ZVs1XTtpPSJyYWRpYWwifWVsc2UgdW5yZWFjaGFibGUoYGdldFBhdHRlcm4gdHlwZSB1bmtub3duOiAke3R9YCk7cmV0dXJuWyJSYWRpYWxBeGlhbCIsaSx0aGlzLmJib3gsdGhpcy5jb2xvclN0b3BzLGEscyxyLG5dfX1jbGFzcyBNZXNoU3RyZWFtUmVhZGVye2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5zdHJlYW09ZTt0aGlzLmNvbnRleHQ9dDt0aGlzLmJ1ZmZlcj0wO3RoaXMuYnVmZmVyTGVuZ3RoPTA7Y29uc3QgaT10Lm51bUNvbXBzO3RoaXMudG1wQ29tcHNCdWY9bmV3IEZsb2F0MzJBcnJheShpKTtjb25zdCBhPXQuY29sb3JTcGFjZS5udW1Db21wczt0aGlzLnRtcENzQ29tcHNCdWY9dC5jb2xvckZuP25ldyBGbG9hdDMyQXJyYXkoYSk6dGhpcy50bXBDb21wc0J1Zn1nZXQgaGFzRGF0YSgpe2lmKHRoaXMuc3RyZWFtLmVuZClyZXR1cm4gdGhpcy5zdHJlYW0ucG9zPHRoaXMuc3RyZWFtLmVuZDtpZih0aGlzLmJ1ZmZlckxlbmd0aD4wKXJldHVybiEwO2NvbnN0IGU9dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpO2lmKGU8MClyZXR1cm4hMTt0aGlzLmJ1ZmZlcj1lO3RoaXMuYnVmZmVyTGVuZ3RoPTg7cmV0dXJuITB9cmVhZEJpdHMoZSl7bGV0IHQ9dGhpcy5idWZmZXIsaT10aGlzLmJ1ZmZlckxlbmd0aDtpZigzMj09PWUpe2lmKDA9PT1pKXJldHVybih0aGlzLnN0cmVhbS5nZXRCeXRlKCk8PDI0fHRoaXMuc3RyZWFtLmdldEJ5dGUoKTw8MTZ8dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpPDw4fHRoaXMuc3RyZWFtLmdldEJ5dGUoKSk+Pj4wO3Q9dDw8MjR8dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpPDwxNnx0aGlzLnN0cmVhbS5nZXRCeXRlKCk8PDh8dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpO2NvbnN0IGU9dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpO3RoaXMuYnVmZmVyPWUmKDE8PGkpLTE7cmV0dXJuKHQ8PDgtaXwoMjU1JmUpPj5pKT4+PjB9aWYoOD09PWUmJjA9PT1pKXJldHVybiB0aGlzLnN0cmVhbS5nZXRCeXRlKCk7Zm9yKDtpPGU7KXt0PXQ8PDh8dGhpcy5zdHJlYW0uZ2V0Qnl0ZSgpO2krPTh9aS09ZTt0aGlzLmJ1ZmZlckxlbmd0aD1pO3RoaXMuYnVmZmVyPXQmKDE8PGkpLTE7cmV0dXJuIHQ+Pml9YWxpZ24oKXt0aGlzLmJ1ZmZlcj0wO3RoaXMuYnVmZmVyTGVuZ3RoPTB9cmVhZEZsYWcoKXtyZXR1cm4gdGhpcy5yZWFkQml0cyh0aGlzLmNvbnRleHQuYml0c1BlckZsYWcpfXJlYWRDb29yZGluYXRlKCl7Y29uc3QgZT10aGlzLmNvbnRleHQuYml0c1BlckNvb3JkaW5hdGUsdD10aGlzLnJlYWRCaXRzKGUpLGk9dGhpcy5yZWFkQml0cyhlKSxhPXRoaXMuY29udGV4dC5kZWNvZGUscz1lPDMyPzEvKCgxPDxlKS0xKToyLjMyODMwNjQzNjUzODY5NjNlLTEwO3JldHVyblt0KnMqKGFbMV0tYVswXSkrYVswXSxpKnMqKGFbM10tYVsyXSkrYVsyXV19cmVhZENvbXBvbmVudHMoKXtjb25zdCBlPXRoaXMuY29udGV4dC5udW1Db21wcyx0PXRoaXMuY29udGV4dC5iaXRzUGVyQ29tcG9uZW50LGk9dDwzMj8xLygoMTw8dCktMSk6Mi4zMjgzMDY0MzY1Mzg2OTYzZS0xMCxhPXRoaXMuY29udGV4dC5kZWNvZGUscz10aGlzLnRtcENvbXBzQnVmO2ZvcihsZXQgcj0wLG49NDtyPGU7cisrLG4rPTIpe2NvbnN0IGU9dGhpcy5yZWFkQml0cyh0KTtzW3JdPWUqaSooYVtuKzFdLWFbbl0pK2Fbbl19Y29uc3Qgcj10aGlzLnRtcENzQ29tcHNCdWY7dGhpcy5jb250ZXh0LmNvbG9yRm4mJnRoaXMuY29udGV4dC5jb2xvckZuKHMsMCxyLDApO3JldHVybiB0aGlzLmNvbnRleHQuY29sb3JTcGFjZS5nZXRSZ2IociwwKX19bGV0IHlhPU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gZ2V0QihlKXtyZXR1cm4geWFbZV18fD1mdW5jdGlvbiBidWlsZEIoZSl7Y29uc3QgdD1bXTtmb3IobGV0IGk9MDtpPD1lO2krKyl7Y29uc3QgYT1pL2Uscz0xLWE7dC5wdXNoKG5ldyBGbG9hdDMyQXJyYXkoW3MqKjMsMyphKnMqKjIsMyphKioyKnMsYSoqM10pKX1yZXR1cm4gdH0oZSl9Y2xhc3MgTWVzaFNoYWRpbmcgZXh0ZW5kcyBCYXNlU2hhZGluZ3tzdGF0aWMgTUlOX1NQTElUX1BBVENIX0NIVU5LU19BTU9VTlQ9MztzdGF0aWMgTUFYX1NQTElUX1BBVENIX0NIVU5LU19BTU9VTlQ9MjA7c3RhdGljIFRSSUFOR0xFX0RFTlNJVFk9MjA7Y29uc3RydWN0b3IoZSx0LGksYSxzKXtzdXBlcigpO2lmKCEoZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pKXRocm93IG5ldyBGb3JtYXRFcnJvcigiTWVzaCBkYXRhIGlzIG5vdCBhIHN0cmVhbSIpO2NvbnN0IHI9ZS5kaWN0O3RoaXMuc2hhZGluZ1R5cGU9ci5nZXQoIlNoYWRpbmdUeXBlIik7Y29uc3Qgbj1yLmdldEFycmF5KCJCQm94Iik7dGhpcy5iYm94PUFycmF5LmlzQXJyYXkobikmJjQ9PT1uLmxlbmd0aD9VdGlsLm5vcm1hbGl6ZVJlY3Qobik6bnVsbDtjb25zdCBvPUNvbG9yU3BhY2UucGFyc2Uoe2NzOnIuZ2V0UmF3KCJDUyIpfHxyLmdldFJhdygiQ29sb3JTcGFjZSIpLHhyZWY6dCxyZXNvdXJjZXM6aSxwZGZGdW5jdGlvbkZhY3Rvcnk6YSxsb2NhbENvbG9yU3BhY2VDYWNoZTpzfSk7dGhpcy5iYWNrZ3JvdW5kPXIuaGFzKCJCYWNrZ3JvdW5kIik/by5nZXRSZ2Ioci5nZXQoIkJhY2tncm91bmQiKSwwKTpudWxsO2NvbnN0IGc9ci5nZXRSYXcoIkZ1bmN0aW9uIiksYz1nP2EuY3JlYXRlRnJvbUFycmF5KGcpOm51bGw7dGhpcy5jb29yZHM9W107dGhpcy5jb2xvcnM9W107dGhpcy5maWd1cmVzPVtdO2NvbnN0IEM9e2JpdHNQZXJDb29yZGluYXRlOnIuZ2V0KCJCaXRzUGVyQ29vcmRpbmF0ZSIpLGJpdHNQZXJDb21wb25lbnQ6ci5nZXQoIkJpdHNQZXJDb21wb25lbnQiKSxiaXRzUGVyRmxhZzpyLmdldCgiQml0c1BlckZsYWciKSxkZWNvZGU6ci5nZXRBcnJheSgiRGVjb2RlIiksY29sb3JGbjpjLGNvbG9yU3BhY2U6byxudW1Db21wczpjPzE6by5udW1Db21wc30saD1uZXcgTWVzaFN0cmVhbVJlYWRlcihlLEMpO2xldCBsPSExO3N3aXRjaCh0aGlzLnNoYWRpbmdUeXBlKXtjYXNlIGRhOnRoaXMuX2RlY29kZVR5cGU0U2hhZGluZyhoKTticmVhaztjYXNlIGZhOmNvbnN0IGU9MHxyLmdldCgiVmVydGljZXNQZXJSb3ciKTtpZihlPDIpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFZlcnRpY2VzUGVyUm93Iik7dGhpcy5fZGVjb2RlVHlwZTVTaGFkaW5nKGgsZSk7YnJlYWs7Y2FzZSBwYTp0aGlzLl9kZWNvZGVUeXBlNlNoYWRpbmcoaCk7bD0hMDticmVhaztjYXNlIG1hOnRoaXMuX2RlY29kZVR5cGU3U2hhZGluZyhoKTtsPSEwO2JyZWFrO2RlZmF1bHQ6dW5yZWFjaGFibGUoIlVuc3VwcG9ydGVkIG1lc2ggdHlwZS4iKX1pZihsKXt0aGlzLl91cGRhdGVCb3VuZHMoKTtmb3IobGV0IGU9MCx0PXRoaXMuZmlndXJlcy5sZW5ndGg7ZTx0O2UrKyl0aGlzLl9idWlsZEZpZ3VyZUZyb21QYXRjaChlKX10aGlzLl91cGRhdGVCb3VuZHMoKTt0aGlzLl9wYWNrRGF0YSgpfV9kZWNvZGVUeXBlNFNoYWRpbmcoZSl7Y29uc3QgdD10aGlzLmNvb3JkcyxpPXRoaXMuY29sb3JzLGE9W10scz1bXTtsZXQgcj0wO2Zvcig7ZS5oYXNEYXRhOyl7Y29uc3Qgbj1lLnJlYWRGbGFnKCksbz1lLnJlYWRDb29yZGluYXRlKCksZz1lLnJlYWRDb21wb25lbnRzKCk7aWYoMD09PXIpe2lmKCEoMDw9biYmbjw9MikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJVbmtub3duIHR5cGU0IGZsYWciKTtzd2l0Y2gobil7Y2FzZSAwOnI9MzticmVhaztjYXNlIDE6cy5wdXNoKHMuYXQoLTIpLHMuYXQoLTEpKTtyPTE7YnJlYWs7Y2FzZSAyOnMucHVzaChzLmF0KC0zKSxzLmF0KC0xKSk7cj0xfWEucHVzaChuKX1zLnB1c2godC5sZW5ndGgpO3QucHVzaChvKTtpLnB1c2goZyk7ci0tO2UuYWxpZ24oKX10aGlzLmZpZ3VyZXMucHVzaCh7dHlwZToidHJpYW5nbGVzIixjb29yZHM6bmV3IEludDMyQXJyYXkocyksY29sb3JzOm5ldyBJbnQzMkFycmF5KHMpfSl9X2RlY29kZVR5cGU1U2hhZGluZyhlLHQpe2NvbnN0IGk9dGhpcy5jb29yZHMsYT10aGlzLmNvbG9ycyxzPVtdO2Zvcig7ZS5oYXNEYXRhOyl7Y29uc3QgdD1lLnJlYWRDb29yZGluYXRlKCkscj1lLnJlYWRDb21wb25lbnRzKCk7cy5wdXNoKGkubGVuZ3RoKTtpLnB1c2godCk7YS5wdXNoKHIpfXRoaXMuZmlndXJlcy5wdXNoKHt0eXBlOiJsYXR0aWNlIixjb29yZHM6bmV3IEludDMyQXJyYXkocyksY29sb3JzOm5ldyBJbnQzMkFycmF5KHMpLHZlcnRpY2VzUGVyUm93OnR9KX1fZGVjb2RlVHlwZTZTaGFkaW5nKGUpe2NvbnN0IHQ9dGhpcy5jb29yZHMsaT10aGlzLmNvbG9ycyxhPW5ldyBJbnQzMkFycmF5KDE2KSxzPW5ldyBJbnQzMkFycmF5KDQpO2Zvcig7ZS5oYXNEYXRhOyl7Y29uc3Qgcj1lLnJlYWRGbGFnKCk7aWYoISgwPD1yJiZyPD0zKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlVua25vd24gdHlwZTYgZmxhZyIpO2NvbnN0IG49dC5sZW5ndGg7Zm9yKGxldCBpPTAsYT0wIT09cj84OjEyO2k8YTtpKyspdC5wdXNoKGUucmVhZENvb3JkaW5hdGUoKSk7Y29uc3Qgbz1pLmxlbmd0aDtmb3IobGV0IHQ9MCxhPTAhPT1yPzI6NDt0PGE7dCsrKWkucHVzaChlLnJlYWRDb21wb25lbnRzKCkpO2xldCBnLGMsQyxoO3N3aXRjaChyKXtjYXNlIDA6YVsxMl09biszO2FbMTNdPW4rNDthWzE0XT1uKzU7YVsxNV09bis2O2FbOF09bisyO2FbMTFdPW4rNzthWzRdPW4rMTthWzddPW4rODthWzBdPW47YVsxXT1uKzExO2FbMl09bisxMDthWzNdPW4rOTtzWzJdPW8rMTtzWzNdPW8rMjtzWzBdPW87c1sxXT1vKzM7YnJlYWs7Y2FzZSAxOmc9YVsxMl07Yz1hWzEzXTtDPWFbMTRdO2g9YVsxNV07YVsxMl09aDthWzEzXT1uKzA7YVsxNF09bisxO2FbMTVdPW4rMjthWzhdPUM7YVsxMV09biszO2FbNF09YzthWzddPW4rNDthWzBdPWc7YVsxXT1uKzc7YVsyXT1uKzY7YVszXT1uKzU7Zz1zWzJdO2M9c1szXTtzWzJdPWM7c1szXT1vO3NbMF09ZztzWzFdPW8rMTticmVhaztjYXNlIDI6Zz1hWzE1XTtjPWFbMTFdO2FbMTJdPWFbM107YVsxM109biswO2FbMTRdPW4rMTthWzE1XT1uKzI7YVs4XT1hWzddO2FbMTFdPW4rMzthWzRdPWM7YVs3XT1uKzQ7YVswXT1nO2FbMV09bis3O2FbMl09bis2O2FbM109bis1O2c9c1szXTtzWzJdPXNbMV07c1szXT1vO3NbMF09ZztzWzFdPW8rMTticmVhaztjYXNlIDM6YVsxMl09YVswXTthWzEzXT1uKzA7YVsxNF09bisxO2FbMTVdPW4rMjthWzhdPWFbMV07YVsxMV09biszO2FbNF09YVsyXTthWzddPW4rNDthWzBdPWFbM107YVsxXT1uKzc7YVsyXT1uKzY7YVszXT1uKzU7c1syXT1zWzBdO3NbM109bztzWzBdPXNbMV07c1sxXT1vKzF9YVs1XT10Lmxlbmd0aDt0LnB1c2goWygtNCp0W2FbMF1dWzBdLXRbYVsxNV1dWzBdKzYqKHRbYVs0XV1bMF0rdFthWzFdXVswXSktMioodFthWzEyXV1bMF0rdFthWzNdXVswXSkrMyoodFthWzEzXV1bMF0rdFthWzddXVswXSkpLzksKC00KnRbYVswXV1bMV0tdFthWzE1XV1bMV0rNioodFthWzRdXVsxXSt0W2FbMV1dWzFdKS0yKih0W2FbMTJdXVsxXSt0W2FbM11dWzFdKSszKih0W2FbMTNdXVsxXSt0W2FbN11dWzFdKSkvOV0pO2FbNl09dC5sZW5ndGg7dC5wdXNoKFsoLTQqdFthWzNdXVswXS10W2FbMTJdXVswXSs2Kih0W2FbMl1dWzBdK3RbYVs3XV1bMF0pLTIqKHRbYVswXV1bMF0rdFthWzE1XV1bMF0pKzMqKHRbYVs0XV1bMF0rdFthWzE0XV1bMF0pKS85LCgtNCp0W2FbM11dWzFdLXRbYVsxMl1dWzFdKzYqKHRbYVsyXV1bMV0rdFthWzddXVsxXSktMioodFthWzBdXVsxXSt0W2FbMTVdXVsxXSkrMyoodFthWzRdXVsxXSt0W2FbMTRdXVsxXSkpLzldKTthWzldPXQubGVuZ3RoO3QucHVzaChbKC00KnRbYVsxMl1dWzBdLXRbYVszXV1bMF0rNioodFthWzhdXVswXSt0W2FbMTNdXVswXSktMioodFthWzBdXVswXSt0W2FbMTVdXVswXSkrMyoodFthWzExXV1bMF0rdFthWzFdXVswXSkpLzksKC00KnRbYVsxMl1dWzFdLXRbYVszXV1bMV0rNioodFthWzhdXVsxXSt0W2FbMTNdXVsxXSktMioodFthWzBdXVsxXSt0W2FbMTVdXVsxXSkrMyoodFthWzExXV1bMV0rdFthWzFdXVsxXSkpLzldKTthWzEwXT10Lmxlbmd0aDt0LnB1c2goWygtNCp0W2FbMTVdXVswXS10W2FbMF1dWzBdKzYqKHRbYVsxMV1dWzBdK3RbYVsxNF1dWzBdKS0yKih0W2FbMTJdXVswXSt0W2FbM11dWzBdKSszKih0W2FbMl1dWzBdK3RbYVs4XV1bMF0pKS85LCgtNCp0W2FbMTVdXVsxXS10W2FbMF1dWzFdKzYqKHRbYVsxMV1dWzFdK3RbYVsxNF1dWzFdKS0yKih0W2FbMTJdXVsxXSt0W2FbM11dWzFdKSszKih0W2FbMl1dWzFdK3RbYVs4XV1bMV0pKS85XSk7dGhpcy5maWd1cmVzLnB1c2goe3R5cGU6InBhdGNoIixjb29yZHM6bmV3IEludDMyQXJyYXkoYSksY29sb3JzOm5ldyBJbnQzMkFycmF5KHMpfSl9fV9kZWNvZGVUeXBlN1NoYWRpbmcoZSl7Y29uc3QgdD10aGlzLmNvb3JkcyxpPXRoaXMuY29sb3JzLGE9bmV3IEludDMyQXJyYXkoMTYpLHM9bmV3IEludDMyQXJyYXkoNCk7Zm9yKDtlLmhhc0RhdGE7KXtjb25zdCByPWUucmVhZEZsYWcoKTtpZighKDA8PXImJnI8PTMpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiVW5rbm93biB0eXBlNyBmbGFnIik7Y29uc3Qgbj10Lmxlbmd0aDtmb3IobGV0IGk9MCxhPTAhPT1yPzEyOjE2O2k8YTtpKyspdC5wdXNoKGUucmVhZENvb3JkaW5hdGUoKSk7Y29uc3Qgbz1pLmxlbmd0aDtmb3IobGV0IHQ9MCxhPTAhPT1yPzI6NDt0PGE7dCsrKWkucHVzaChlLnJlYWRDb21wb25lbnRzKCkpO2xldCBnLGMsQyxoO3N3aXRjaChyKXtjYXNlIDA6YVsxMl09biszO2FbMTNdPW4rNDthWzE0XT1uKzU7YVsxNV09bis2O2FbOF09bisyO2FbOV09bisxMzthWzEwXT1uKzE0O2FbMTFdPW4rNzthWzRdPW4rMTthWzVdPW4rMTI7YVs2XT1uKzE1O2FbN109bis4O2FbMF09bjthWzFdPW4rMTE7YVsyXT1uKzEwO2FbM109bis5O3NbMl09bysxO3NbM109bysyO3NbMF09bztzWzFdPW8rMzticmVhaztjYXNlIDE6Zz1hWzEyXTtjPWFbMTNdO0M9YVsxNF07aD1hWzE1XTthWzEyXT1oO2FbMTNdPW4rMDthWzE0XT1uKzE7YVsxNV09bisyO2FbOF09QzthWzldPW4rOTthWzEwXT1uKzEwO2FbMTFdPW4rMzthWzRdPWM7YVs1XT1uKzg7YVs2XT1uKzExO2FbN109bis0O2FbMF09ZzthWzFdPW4rNzthWzJdPW4rNjthWzNdPW4rNTtnPXNbMl07Yz1zWzNdO3NbMl09YztzWzNdPW87c1swXT1nO3NbMV09bysxO2JyZWFrO2Nhc2UgMjpnPWFbMTVdO2M9YVsxMV07YVsxMl09YVszXTthWzEzXT1uKzA7YVsxNF09bisxO2FbMTVdPW4rMjthWzhdPWFbN107YVs5XT1uKzk7YVsxMF09bisxMDthWzExXT1uKzM7YVs0XT1jO2FbNV09bis4O2FbNl09bisxMTthWzddPW4rNDthWzBdPWc7YVsxXT1uKzc7YVsyXT1uKzY7YVszXT1uKzU7Zz1zWzNdO3NbMl09c1sxXTtzWzNdPW87c1swXT1nO3NbMV09bysxO2JyZWFrO2Nhc2UgMzphWzEyXT1hWzBdO2FbMTNdPW4rMDthWzE0XT1uKzE7YVsxNV09bisyO2FbOF09YVsxXTthWzldPW4rOTthWzEwXT1uKzEwO2FbMTFdPW4rMzthWzRdPWFbMl07YVs1XT1uKzg7YVs2XT1uKzExO2FbN109bis0O2FbMF09YVszXTthWzFdPW4rNzthWzJdPW4rNjthWzNdPW4rNTtzWzJdPXNbMF07c1szXT1vO3NbMF09c1sxXTtzWzFdPW8rMX10aGlzLmZpZ3VyZXMucHVzaCh7dHlwZToicGF0Y2giLGNvb3JkczpuZXcgSW50MzJBcnJheShhKSxjb2xvcnM6bmV3IEludDMyQXJyYXkocyl9KX19X2J1aWxkRmlndXJlRnJvbVBhdGNoKGUpe2NvbnN0IHQ9dGhpcy5maWd1cmVzW2VdO2Fzc2VydCgicGF0Y2giPT09dC50eXBlLCJVbmV4cGVjdGVkIHBhdGNoIG1lc2ggZmlndXJlIik7Y29uc3QgaT10aGlzLmNvb3JkcyxhPXRoaXMuY29sb3JzLHM9dC5jb29yZHMscj10LmNvbG9ycyxuPU1hdGgubWluKGlbc1swXV1bMF0saVtzWzNdXVswXSxpW3NbMTJdXVswXSxpW3NbMTVdXVswXSksbz1NYXRoLm1pbihpW3NbMF1dWzFdLGlbc1szXV1bMV0saVtzWzEyXV1bMV0saVtzWzE1XV1bMV0pLGc9TWF0aC5tYXgoaVtzWzBdXVswXSxpW3NbM11dWzBdLGlbc1sxMl1dWzBdLGlbc1sxNV1dWzBdKSxjPU1hdGgubWF4KGlbc1swXV1bMV0saVtzWzNdXVsxXSxpW3NbMTJdXVsxXSxpW3NbMTVdXVsxXSk7bGV0IEM9TWF0aC5jZWlsKChnLW4pKk1lc2hTaGFkaW5nLlRSSUFOR0xFX0RFTlNJVFkvKHRoaXMuYm91bmRzWzJdLXRoaXMuYm91bmRzWzBdKSk7Qz1NYXRoLm1heChNZXNoU2hhZGluZy5NSU5fU1BMSVRfUEFUQ0hfQ0hVTktTX0FNT1VOVCxNYXRoLm1pbihNZXNoU2hhZGluZy5NQVhfU1BMSVRfUEFUQ0hfQ0hVTktTX0FNT1VOVCxDKSk7bGV0IGg9TWF0aC5jZWlsKChjLW8pKk1lc2hTaGFkaW5nLlRSSUFOR0xFX0RFTlNJVFkvKHRoaXMuYm91bmRzWzNdLXRoaXMuYm91bmRzWzFdKSk7aD1NYXRoLm1heChNZXNoU2hhZGluZy5NSU5fU1BMSVRfUEFUQ0hfQ0hVTktTX0FNT1VOVCxNYXRoLm1pbihNZXNoU2hhZGluZy5NQVhfU1BMSVRfUEFUQ0hfQ0hVTktTX0FNT1VOVCxoKSk7Y29uc3QgbD1DKzEsUT1uZXcgSW50MzJBcnJheSgoaCsxKSpsKSxFPW5ldyBJbnQzMkFycmF5KChoKzEpKmwpO2xldCB1PTA7Y29uc3QgZD1uZXcgVWludDhBcnJheSgzKSxmPW5ldyBVaW50OEFycmF5KDMpLHA9YVtyWzBdXSxtPWFbclsxXV0seT1hW3JbMl1dLHc9YVtyWzNdXSxiPWdldEIoaCksRD1nZXRCKEMpO2ZvcihsZXQgZT0wO2U8PWg7ZSsrKXtkWzBdPShwWzBdKihoLWUpK3lbMF0qZSkvaHwwO2RbMV09KHBbMV0qKGgtZSkreVsxXSplKS9ofDA7ZFsyXT0ocFsyXSooaC1lKSt5WzJdKmUpL2h8MDtmWzBdPShtWzBdKihoLWUpK3dbMF0qZSkvaHwwO2ZbMV09KG1bMV0qKGgtZSkrd1sxXSplKS9ofDA7ZlsyXT0obVsyXSooaC1lKSt3WzJdKmUpL2h8MDtmb3IobGV0IHQ9MDt0PD1DO3QrKyx1Kyspe2lmKCEoMCE9PWUmJmUhPT1ofHwwIT09dCYmdCE9PUMpKWNvbnRpbnVlO2xldCByPTAsbj0wLG89MDtmb3IobGV0IGE9MDthPD0zO2ErKylmb3IobGV0IGc9MDtnPD0zO2crKyxvKyspe2NvbnN0IGM9YltlXVthXSpEW3RdW2ddO3IrPWlbc1tvXV1bMF0qYztuKz1pW3Nbb11dWzFdKmN9UVt1XT1pLmxlbmd0aDtpLnB1c2goW3Isbl0pO0VbdV09YS5sZW5ndGg7Y29uc3QgZz1uZXcgVWludDhBcnJheSgzKTtnWzBdPShkWzBdKihDLXQpK2ZbMF0qdCkvQ3wwO2dbMV09KGRbMV0qKEMtdCkrZlsxXSp0KS9DfDA7Z1syXT0oZFsyXSooQy10KStmWzJdKnQpL0N8MDthLnB1c2goZyl9fVFbMF09c1swXTtFWzBdPXJbMF07UVtDXT1zWzNdO0VbQ109clsxXTtRW2wqaF09c1sxMl07RVtsKmhdPXJbMl07UVtsKmgrQ109c1sxNV07RVtsKmgrQ109clszXTt0aGlzLmZpZ3VyZXNbZV09e3R5cGU6ImxhdHRpY2UiLGNvb3JkczpRLGNvbG9yczpFLHZlcnRpY2VzUGVyUm93Omx9fV91cGRhdGVCb3VuZHMoKXtsZXQgZT10aGlzLmNvb3Jkc1swXVswXSx0PXRoaXMuY29vcmRzWzBdWzFdLGk9ZSxhPXQ7Zm9yKGxldCBzPTEscj10aGlzLmNvb3Jkcy5sZW5ndGg7czxyO3MrKyl7Y29uc3Qgcj10aGlzLmNvb3Jkc1tzXVswXSxuPXRoaXMuY29vcmRzW3NdWzFdO2U9ZT5yP3I6ZTt0PXQ+bj9uOnQ7aT1pPHI/cjppO2E9YTxuP246YX10aGlzLmJvdW5kcz1bZSx0LGksYV19X3BhY2tEYXRhKCl7bGV0IGUsdCxpLGE7Y29uc3Qgcz10aGlzLmNvb3JkcyxyPW5ldyBGbG9hdDMyQXJyYXkoMipzLmxlbmd0aCk7Zm9yKGU9MCxpPTAsdD1zLmxlbmd0aDtlPHQ7ZSsrKXtjb25zdCB0PXNbZV07cltpKytdPXRbMF07cltpKytdPXRbMV19dGhpcy5jb29yZHM9cjtjb25zdCBuPXRoaXMuY29sb3JzLG89bmV3IFVpbnQ4QXJyYXkoMypuLmxlbmd0aCk7Zm9yKGU9MCxpPTAsdD1uLmxlbmd0aDtlPHQ7ZSsrKXtjb25zdCB0PW5bZV07b1tpKytdPXRbMF07b1tpKytdPXRbMV07b1tpKytdPXRbMl19dGhpcy5jb2xvcnM9bztjb25zdCBnPXRoaXMuZmlndXJlcztmb3IoZT0wLHQ9Zy5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1nW2VdLHM9dC5jb29yZHMscj10LmNvbG9ycztmb3IoaT0wLGE9cy5sZW5ndGg7aTxhO2krKyl7c1tpXSo9MjtyW2ldKj0zfX19Z2V0SVIoKXtjb25zdHtib3VuZHM6ZX09dGhpcztpZihlWzJdLWVbMF09PTB8fGVbM10tZVsxXT09MCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgTWVzaFNoYWRpbmcgYm91bmRzOiBbJHtlfV0uYCk7cmV0dXJuWyJNZXNoIix0aGlzLnNoYWRpbmdUeXBlLHRoaXMuY29vcmRzLHRoaXMuY29sb3JzLHRoaXMuZmlndXJlcyxlLHRoaXMuYmJveCx0aGlzLmJhY2tncm91bmRdfX1jbGFzcyBEdW1teVNoYWRpbmcgZXh0ZW5kcyBCYXNlU2hhZGluZ3tnZXRJUigpe3JldHVyblsiRHVtbXkiXX19ZnVuY3Rpb24gZ2V0VGlsaW5nUGF0dGVybklSKGUsdCxpKXtjb25zdCBhPXQuZ2V0QXJyYXkoIk1hdHJpeCIpLHM9VXRpbC5ub3JtYWxpemVSZWN0KHQuZ2V0QXJyYXkoIkJCb3giKSkscj10LmdldCgiWFN0ZXAiKSxuPXQuZ2V0KCJZU3RlcCIpLG89dC5nZXQoIlBhaW50VHlwZSIpLGc9dC5nZXQoIlRpbGluZ1R5cGUiKTtpZihzWzJdLXNbMF09PTB8fHNbM10tc1sxXT09MCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgZ2V0VGlsaW5nUGF0dGVybklSIC9CQm94IGFycmF5OiBbJHtzfV0uYCk7cmV0dXJuWyJUaWxpbmdQYXR0ZXJuIixpLGUsYSxzLHIsbixvLGddfWNvbnN0IHdhPVsxLjM4NzcsMSwxLDEsLjk3ODAxLC45MjQ4MiwuODk1NTIsLjkxMTMzLC44MTk4OCwuOTc1NjYsLjk4MTUyLC45MzU0OCwuOTM1NDgsMS4yNzk4LC44NTI4NCwuOTI3OTQsMSwuOTYxMzQsMS41NDY1NywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjgyODQ1LC44Mjg0NSwuODUyODQsLjg1Mjg0LC44NTI4NCwuNzU4NTksLjkyMTM4LC44MzkwOCwuNzc2MiwuNzMyOTMsLjg3Mjg5LC43MzEzMywuNzUxNCwuODE5MjEsLjg3MzU2LC45NTk1OCwuNTk1MjYsLjc1NzI3LC42OTIyNSwxLjA0OTI0LC45MTIxLC44Njk0MywuNzk3OTUsLjg4MTk4LC43Nzk1OCwuNzA4NjQsLjgxMDU1LC45MDM5OSwuODg2NTMsLjk2MDE3LC44MjU3NywuNzc4OTIsLjc4MjU3LC45NzUwNywxLjU0NjU3LC45NzUwNywuODUyODQsLjg5NTUyLC45MDE3NiwuODg3NjIsLjg3ODUsLjc1MjQxLC44Nzg1LC45MDUxOCwuOTUwMTUsLjc3NjE4LC44Nzg1LC44ODQwMSwuOTE5MTYsLjg2MzA0LC44ODQwMSwuOTE0ODgsLjg3ODUsLjg4MDEsLjg3ODUsLjg3ODUsLjkxMzQzLC43MTczLDEuMDQxMDYsLjg3ODUsLjg1MDc1LC45NTc5NCwuODI2MTYsLjg1MTYyLC43OTQ5MiwuODgzMzEsMS42OTgwOCwuODgzMzEsLjg1Mjg0LC45NzgwMSwuODk1NTIsLjkxMTMzLC44OTU1MiwuOTExMzMsMS43ODAxLC44OTU1MiwxLjI0NDg3LDEuMTMyNTQsMS4xMjQwMSwuOTY4MzksLjg1Mjg0LC42ODc4NywuNzA2NDUsLjg1NTkyLC45MDc0NywxLjAxNDY2LDEuMDA4OCwuOTAzMjMsMSwxLjA3NDYzLDEsLjkxMDU2LC43NTgwNiwxLjE5MTE4LC45NjgzOSwuNzg4NjQsLjgyODQ1LC44NDEzMywuNzU4NTksLjgzOTA4LC44MzkwOCwuODM5MDgsLjgzOTA4LC44MzkwOCwuODM5MDgsLjc3NTM5LC43MzI5MywuNzMxMzMsLjczMTMzLC43MzEzMywuNzMxMzMsLjk1OTU4LC45NTk1OCwuOTU5NTgsLjk1OTU4LC44ODUwNiwuOTEyMSwuODY5NDMsLjg2OTQzLC44Njk0MywuODY5NDMsLjg2OTQzLC44NTI4NCwuODc1MDgsLjkwMzk5LC45MDM5OSwuOTAzOTksLjkwMzk5LC43Nzg5MiwuNzk3OTUsLjkwODA3LC44ODc2MiwuODg3NjIsLjg4NzYyLC44ODc2MiwuODg3NjIsLjg4NzYyLC44NzE1LC43NTI0MSwuOTA1MTgsLjkwNTE4LC45MDUxOCwuOTA1MTgsLjg4NDAxLC44ODQwMSwuODg0MDEsLjg4NDAxLC44Nzg1LC44Nzg1LC44ODAxLC44ODAxLC44ODAxLC44ODAxLC44ODAxLC45MDc0NywuODkwNDksLjg3ODUsLjg3ODUsLjg3ODUsLjg3ODUsLjg1MTYyLC44Nzg1LC44NTE2MiwuODM5MDgsLjg4NzYyLC44MzkwOCwuODg3NjIsLjgzOTA4LC44ODc2MiwuNzMyOTMsLjc1MjQxLC43MzI5MywuNzUyNDEsLjczMjkzLC43NTI0MSwuNzMyOTMsLjc1MjQxLC44NzI4OSwuODMwMTYsLjg4NTA2LC45MzEyNSwuNzMxMzMsLjkwNTE4LC43MzEzMywuOTA1MTgsLjczMTMzLC45MDUxOCwuNzMxMzMsLjkwNTE4LC43MzEzMywuOTA1MTgsLjgxOTIxLC43NzYxOCwuODE5MjEsLjc3NjE4LC44MTkyMSwuNzc2MTgsMSwxLC44NzM1NiwuODc4NSwuOTEwNzUsLjg5NjA4LC45NTk1OCwuODg0MDEsLjk1OTU4LC44ODQwMSwuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjk1OTU4LC44ODQwMSwuNzYyMjksLjkwMTY3LC41OTUyNiwuOTE5MTYsMSwxLC44NjMwNCwuNjkyMjUsLjg4NDAxLDEsMSwuNzA0MjQsLjc5NDY4LC45MTkyNiwuODgxNzUsLjcwODIzLC45NDkwMywuOTEyMSwuODc4NSwxLDEsLjkxMjEsLjg3ODUsLjg3ODAyLC44ODY1NiwuODc4NSwuODY5NDMsLjg4MDEsLjg2OTQzLC44ODAxLC44Njk0MywuODgwMSwuODc0MDIsLjg5MjkxLC43Nzk1OCwuOTEzNDMsMSwxLC43Nzk1OCwuOTEzNDMsLjcwODY0LC43MTczLC43MDg2NCwuNzE3MywuNzA4NjQsLjcxNzMsLjcwODY0LC43MTczLDEsMSwuODEwNTUsLjc1ODQxLC44MTA1NSwxLjA2NDUyLC45MDM5OSwuODc4NSwuOTAzOTksLjg3ODUsLjkwMzk5LC44Nzg1LC45MDM5OSwuODc4NSwuOTAzOTksLjg3ODUsLjkwMzk5LC44Nzg1LC45NjAxNywuOTU3OTQsLjc3ODkyLC44NTE2MiwuNzc4OTIsLjc4MjU3LC43OTQ5MiwuNzgyNTcsLjc5NDkyLC43ODI1NywuNzk0OTIsLjkyOTcsLjU2ODkyLC44MzkwOCwuODg3NjIsLjc3NTM5LC44NzE1LC44NzUwOCwuODkwNDksMSwxLC44MTA1NSwxLjA0MTA2LDEuMjA1MjgsMS4yMDUyOCwxLDEuMTU1NDMsLjcwNjc0LC45ODM4NywuOTQ3MjEsMS4zMzQzMSwxLjQ1ODk0LC45NTE2MSwxLjA2MzAzLC44MzkwOCwuODAzNTIsLjU3MTg0LC42OTY1LC41NjI4OSwuODIwMDEsLjU2MDI5LC44MTIzNSwxLjAyOTg4LC44MzkwOCwuNzc2MiwuNjgxNTYsLjgwMzY3LC43MzEzMywuNzgyNTcsLjg3MzU2LC44Njk0MywuOTU5NTgsLjc1NzI3LC44OTAxOSwxLjA0OTI0LC45MTIxLC43NjQ4LC44Njk0MywuODczNTYsLjc5Nzk1LC43ODI3NSwuODEwNTUsLjc3ODkyLC45NzYyLC44MjU3NywuOTk4MTksLjg0ODk2LC45NTk1OCwuNzc4OTIsLjk2MTA4LDEuMDE0MDcsLjg5MDQ5LDEuMDI5ODgsLjk0MjExLC45NjEwOCwuODkzNiwuODQwMjEsLjg3ODQyLC45NjM5OSwuNzkxMDksLjg5MDQ5LDEuMDA4MTMsMS4wMjk4OCwuODYwNzcsLjg3NDQ1LC45MjA5OSwuODQ3MjMsLjg2NTEzLC44ODAxLC43NTYzOCwuODU3MTQsLjc4MjE2LC43OTU4NiwuODc5NjUsLjk0MjExLC45Nzc0NywuNzgyODcsLjk3OTI2LC44NDk3MSwxLjAyOTg4LC45NDIxMSwuODgwMSwuOTQyMTEsLjg0OTcxLC43MzEzMywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTAyNjQsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjkwNTE4LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45MDU0OCwxLDEsMSwxLDEsMSwuOTYwMTcsLjk1Nzk0LC45NjAxNywuOTU3OTQsLjk2MDE3LC45NTc5NCwuNzc4OTIsLjg1MTYyLDEsMSwuODk1NTIsLjkwNTI3LDEsLjkwMzYzLC45Mjc5NCwuOTI3OTQsLjkyNzk0LC45Mjc5NCwuODcwMTIsLjg3MDEyLC44NzAxMiwuODk1NTIsLjg5NTUyLDEuNDIyNTksLjcxMTQzLDEuMDYxNTIsMSwxLDEuMDMzNzIsMS4wMzM3MiwuOTcxNzEsMS40OTU2LDIuMjgwNywuOTM4MzUsLjgzNDA2LC45MTEzMywuODQxMDcsLjkxMTMzLDEsMSwxLC43MjAyMSwxLDEuMjMxMDgsLjgzNDg5LC44ODUyNSwuODg1MjUsLjgxNDk5LC45MDUyNywxLjgxMDU1LC45MDUyNywxLjgxMDU1LDEuMzEwMDYsMS41MzcxMSwuOTQ0MzQsMS4wODY5NiwxLC45NTAxOCwuNzcxOTIsLjg1Mjg0LC45MDc0NywxLjE3NTM0LC42OTgyNSwuOTcxNiwxLjM3MDc3LC45MDc0NywuOTA3NDcsLjg1MzU2LC45MDc0NywuOTA3NDcsMS40NDk0NywuODUyODQsLjg5NDEsLjg5NDEsLjcwNTcyLC44LC43MDU3MiwuNzA1NzIsLjcwNTcyLC43MDU3MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk5ODYyLC45OTg2MiwxLDEsMSwxLDEsMS4wODAwNCwuOTEwMjcsMSwxLDEsLjk5ODYyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45MDcyNywuOTA3MjcsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLGJhPXtsaW5lSGVpZ2h0OjEuMjIwNyxsaW5lR2FwOi4yMjA3fSxEYT1bMS4zODc3LDEsMSwxLC45NzgwMSwuOTI0ODIsLjg5NTUyLC45MTEzMywuODE5ODgsLjk3NTY2LC45ODE1MiwuOTM1NDgsLjkzNTQ4LDEuMjc5OCwuODUyODQsLjkyNzk0LDEsLjk2MTM0LDEuNTYyMzksLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC44Mjg0NSwuODI4NDUsLjg1Mjg0LC44NTI4NCwuODUyODQsLjc1ODU5LC45MjEzOCwuODM5MDgsLjc3NjIsLjcxODA1LC44NzI4OSwuNzMxMzMsLjc1MTQsLjgxOTIxLC44NzM1NiwuOTU5NTgsLjU5NTI2LC43NTcyNywuNjkyMjUsMS4wNDkyNCwuOTA4NzIsLjg1OTM4LC43OTc5NSwuODcwNjgsLjc3OTU4LC42OTc2NiwuODEwNTUsLjkwMzk5LC44ODY1MywuOTYwNjgsLjgyNTc3LC43Nzg5MiwuNzgyNTcsLjk3NTA3LDEuNTI5LC45NzUwNywuODUyODQsLjg5NTUyLC45MDE3NiwuOTQ5MDgsLjg2NDExLC43NDAxMiwuODY0MTEsLjg4MzIzLC45NTAxNSwuODY0MTEsLjg2MzMxLC44ODQwMSwuOTE5MTYsLjg2MzA0LC44ODQwMSwuOTAzOSwuODYzMzEsLjg2MzMxLC44NjQxMSwuODY0MTEsLjkwNDY0LC43MDg1MiwxLjA0MTA2LC44NjMzMSwuODQzNzIsLjk1Nzk0LC44MjYxNiwuODQ1NDgsLjc5NDkyLC44ODMzMSwxLjY5ODA4LC44ODMzMSwuODUyODQsLjk3ODAxLC44OTU1MiwuOTExMzMsLjg5NTUyLC45MTEzMywxLjc4MDEsLjg5NTUyLDEuMjQ0ODcsMS4xMzI1NCwxLjE5MTI5LC45NjgzOSwuODUyODQsLjY4Nzg3LC43MDY0NSwuODU1OTIsLjkwNzQ3LDEuMDE0NjYsMS4wMDg4LC45MDMyMywxLDEuMDc0NjMsMSwuOTEwNTYsLjc1ODA2LDEuMTkxMTgsLjk2ODM5LC43ODg2NCwuODI4NDUsLjg0MTMzLC43NTg1OSwuODM5MDgsLjgzOTA4LC44MzkwOCwuODM5MDgsLjgzOTA4LC44MzkwOCwuNzc1MzksLjcxODA1LC43MzEzMywuNzMxMzMsLjczMTMzLC43MzEzMywuOTU5NTgsLjk1OTU4LC45NTk1OCwuOTU5NTgsLjg4NTA2LC45MDg3MiwuODU5MzgsLjg1OTM4LC44NTkzOCwuODU5MzgsLjg1OTM4LC44NTI4NCwuODcwNjgsLjkwMzk5LC45MDM5OSwuOTAzOTksLjkwMzk5LC43Nzg5MiwuNzk3OTUsLjkwODA3LC45NDkwOCwuOTQ5MDgsLjk0OTA4LC45NDkwOCwuOTQ5MDgsLjk0OTA4LC44NTg4NywuNzQwMTIsLjg4MzIzLC44ODMyMywuODgzMjMsLjg4MzIzLC44ODQwMSwuODg0MDEsLjg4NDAxLC44ODQwMSwuODc4NSwuODYzMzEsLjg2MzMxLC44NjMzMSwuODYzMzEsLjg2MzMxLC44NjMzMSwuOTA3NDcsLjg5MDQ5LC44NjMzMSwuODYzMzEsLjg2MzMxLC44NjMzMSwuODQ1NDgsLjg2NDExLC44NDU0OCwuODM5MDgsLjk0OTA4LC44MzkwOCwuOTQ5MDgsLjgzOTA4LC45NDkwOCwuNzE4MDUsLjc0MDEyLC43MTgwNSwuNzQwMTIsLjcxODA1LC43NDAxMiwuNzE4MDUsLjc0MDEyLC44NzI4OSwuNzk1MzgsLjg4NTA2LC45MjcyNiwuNzMxMzMsLjg4MzIzLC43MzEzMywuODgzMjMsLjczMTMzLC44ODMyMywuNzMxMzMsLjg4MzIzLC43MzEzMywuODgzMjMsLjgxOTIxLC44NjQxMSwuODE5MjEsLjg2NDExLC44MTkyMSwuODY0MTEsMSwxLC44NzM1NiwuODYzMzEsLjkxMDc1LC44Nzc3LC45NTk1OCwuODg0MDEsLjk1OTU4LC44ODQwMSwuOTU5NTgsLjg4NDAxLC45NTk1OCwuODg0MDEsLjk1OTU4LC44ODQwMSwuNzY0NjcsLjkwMTY3LC41OTUyNiwuOTE5MTYsMSwxLC44NjMwNCwuNjkyMjUsLjg4NDAxLDEsMSwuNzA0MjQsLjc3MzEyLC45MTkyNiwuODgxNzUsLjcwODIzLC45NDkwMywuOTA4NzIsLjg2MzMxLDEsMSwuOTA4NzIsLjg2MzMxLC44NjkwNiwuODgxMTYsLjg2MzMxLC44NTkzOCwuODYzMzEsLjg1OTM4LC44NjMzMSwuODU5MzgsLjg2MzMxLC44NzQwMiwuODY1NDksLjc3OTU4LC45MDQ2NCwxLDEsLjc3OTU4LC45MDQ2NCwuNjk3NjYsLjcwODUyLC42OTc2NiwuNzA4NTIsLjY5NzY2LC43MDg1MiwuNjk3NjYsLjcwODUyLDEsMSwuODEwNTUsLjc1ODQxLC44MTA1NSwxLjA2NDUyLC45MDM5OSwuODYzMzEsLjkwMzk5LC44NjMzMSwuOTAzOTksLjg2MzMxLC45MDM5OSwuODYzMzEsLjkwMzk5LC44NjMzMSwuOTAzOTksLjg2MzMxLC45NjA2OCwuOTU3OTQsLjc3ODkyLC44NDU0OCwuNzc4OTIsLjc4MjU3LC43OTQ5MiwuNzgyNTcsLjc5NDkyLC43ODI1NywuNzk0OTIsLjkyOTcsLjU2ODkyLC44MzkwOCwuOTQ5MDgsLjc3NTM5LC44NTg4NywuODcwNjgsLjg5MDQ5LDEsMSwuODEwNTUsMS4wNDEwNiwxLjIwNTI4LDEuMjA1MjgsMSwxLjE1NTQzLC43MDA4OCwuOTgzODcsLjk0NzIxLDEuMzM0MzEsMS40NTg5NCwuOTUxNjEsMS40ODM4NywuODM5MDgsLjgwMzUyLC41NzExOCwuNjk2NSwuNTYzNDcsLjc5MTc5LC41NTg1MywuODAzNDYsMS4wMjk4OCwuODM5MDgsLjc3NjIsLjY3MTc0LC44NjAzNiwuNzMxMzMsLjc4MjU3LC44NzM1NiwuODY0NDEsLjk1OTU4LC43NTcyNywuODkwMTksMS4wNDkyNCwuOTA4NzIsLjc0ODg5LC44NTkzOCwuODc4OTEsLjc5Nzk1LC43OTU3LC44MTA1NSwuNzc4OTIsLjk3NDQ3LC44MjU3NywuOTc0NjYsLjg3MTc5LC45NTk1OCwuNzc4OTIsLjk0MjUyLC45NTYxMiwuODc1MywxLjAyOTg4LC45MjczMywuOTQyNTIsLjg3NDExLC44NDAyMSwuODcyOCwuOTU2MTIsLjc0MDgxLC44NzUzLDEuMDIxODksMS4wMjk4OCwuODQ4MTQsLjg3NDQ1LC45MTgyMiwuODQ3MjMsLjg1NjY4LC44NjMzMSwuODEzNDQsLjg3NTgxLC43NjQyMiwuODIwNDYsLjk2MDU3LC45MjczMywuOTkzNzUsLjc4MDIyLC45NTQ1MiwuODYwMTUsMS4wMjk4OCwuOTI3MzMsLjg2MzMxLC45MjczMywuODYwMTUsLjczMTMzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45MDYzMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuODgzMjMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg1MTc0LDEsMSwxLDEsMSwxLC45NjA2OCwuOTU3OTQsLjk2MDY4LC45NTc5NCwuOTYwNjgsLjk1Nzk0LC43Nzg5MiwuODQ1NDgsMSwxLC44OTU1MiwuOTA1MjcsMSwuOTAzNjMsLjkyNzk0LC45Mjc5NCwuOTI3OTQsLjg5ODA3LC44NzAxMiwuODcwMTIsLjg3MDEyLC44OTU1MiwuODk1NTIsMS40MjI1OSwuNzEwOTQsMS4wNjE1MiwxLDEsMS4wMzM3MiwxLjAzMzcyLC45NzE3MSwxLjQ5NTYsMi4yODA3LC45Mjk3MiwuODM0MDYsLjkxMTMzLC44MzMyNiwuOTExMzMsMSwxLDEsLjcyMDIxLDEsMS4yMzEwOCwuODM0ODksLjg4NTI1LC44ODUyNSwuODE0OTksLjkwNjE2LDEuODEwNTUsLjkwNTI3LDEuODEwNTUsMS4zMTA3LDEuNTM3MTEsLjk0NDM0LDEuMDg2OTYsMSwuOTUwMTgsLjc3MTkyLC44NTI4NCwuOTA3NDcsMS4xNzUzNCwuNjk4MjUsLjk3MTYsMS4zNzA3NywuOTA3NDcsLjkwNzQ3LC44NTM1NiwuOTA3NDcsLjkwNzQ3LDEuNDQ5NDcsLjg1Mjg0LC44OTQxLC44OTQxLC43MDU3MiwuOCwuNzA1NzIsLjcwNTcyLC43MDU3MiwuNzA1NzIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45OTg2MiwuOTk4NjIsMSwxLDEsMSwxLDEuMDgwMDQsLjkxMDI3LDEsMSwxLC45OTg2MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA3MjcsLjkwNzI3LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSxGYT17bGluZUhlaWdodDoxLjIyMDcsbGluZUdhcDouMjIwN30sU2E9WzEuMzg3NywxLDEsMSwxLjE3MjIzLDEuMTI5MywuODk1NTIsLjkxMTMzLC44MDM5NSwxLjAyMjY5LDEuMTU2MDEsLjkxMDU2LC45MTA1NiwxLjI3OTgsLjg1Mjg0LC44OTgwNywxLC45MDg2MSwxLjM5NTQzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTYzMDksLjk2MzA5LC44NTI4NCwuODUyODQsLjg1Mjg0LC44MzMxOSwuODgwNzEsLjg2NzUsLjgxNTUyLC43MjM0NiwuODUxOTMsLjczMjA2LC43NTIyLC44MTEwNSwuODYyNzUsLjkwNjg1LC42Mzc3LC43Nzg5MiwuNzU1OTMsMS4wMjYzOCwuODkyNDksLjg0MTE4LC43NzQ1MiwuODUzNzQsLjc1MTg2LC42Nzc4OSwuNzk3NzYsLjg4ODQ0LC44NTA2NiwuOTQzMDksLjc3ODE4LC43MzA2LC43NjY1OSwxLjEwMzY5LDEuMzgzMTMsMS4xMDM2OSwxLjA2MTM5LC44OTU1MiwuODczOSwuOTI0NSwuOTI0NSwuODMyMDMsLjkyNDUsLjg1ODY1LDEuMDk4NDIsLjkyNDUsLjkyNDUsMS4wMzI5NywxLjA3NjkyLC45MDkxOCwxLjAzMjk3LC45NDk1OSwuOTI0NSwuOTIyNzQsLjkyNDUsLjkyNDUsMS4wMjkzMywuNzc4MzIsMS4yMDU2MiwuOTI0NSwuODkxNiwuOTg5ODYsLjg2NjIxLC44OTQ1MywuNzkwMDQsLjk0MTUyLDEuNzcyNTYsLjk0MTUyLC44NTI4NCwuOTc4MDEsLjg5NTUyLC45MTEzMywuODk1NTIsLjkxMTMzLDEuOTE3MjksLjg5NTUyLDEuMTc4ODksMS4xMzI1NCwxLjE2MzU5LC45MjA5OCwuODUyODQsLjY4Nzg3LC43MTM1MywuODQ3MzcsLjkwNzQ3LDEuMDA4OCwxLjAwNDQsLjg3NjgzLDEsMS4wOTA5MSwxLC45MjIyOSwuNzM5LDEuMTU2NDIsLjkyMDk4LC43NjI4OCwuODA1MDQsLjgwOTcyLC43NTg1OSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuODY3NSwuNzYzMTgsLjcyMzQ2LC43MzIwNiwuNzMyMDYsLjczMjA2LC43MzIwNiwuOTA2ODUsLjkwNjg1LC45MDY4NSwuOTA2ODUsLjg2NDc3LC44OTI0OSwuODQxMTgsLjg0MTE4LC44NDExOCwuODQxMTgsLjg0MTE4LC44NTI4NCwuODQ1NTcsLjg4ODQ0LC44ODg0NCwuODg4NDQsLjg4ODQ0LC43MzA2LC43NzQ1MiwuODYzMzEsLjkyNDUsLjkyNDUsLjkyNDUsLjkyNDUsLjkyNDUsLjkyNDUsLjg0ODQzLC44MzIwMywuODU4NjUsLjg1ODY1LC44NTg2NSwuODU4NjUsLjgyNjAxLC44MjYwMSwuODI2MDEsLjgyNjAxLC45NDQ2OSwuOTI0NSwuOTIyNzQsLjkyMjc0LC45MjI3NCwuOTIyNzQsLjkyMjc0LC45MDc0NywuODY2NTEsLjkyNDUsLjkyNDUsLjkyNDUsLjkyNDUsLjg5NDUzLC45MjQ1LC44OTQ1MywuODY3NSwuOTI0NSwuODY3NSwuOTI0NSwuODY3NSwuOTI0NSwuNzIzNDYsLjgzMjAzLC43MjM0NiwuODMyMDMsLjcyMzQ2LC44MzIwMywuNzIzNDYsLjgzMjAzLC44NTE5MywuODg3NSwuODY0NzcsLjk5MDM0LC43MzIwNiwuODU4NjUsLjczMjA2LC44NTg2NSwuNzMyMDYsLjg1ODY1LC43MzIwNiwuODU4NjUsLjczMjA2LC44NTg2NSwuODExMDUsLjkyNDUsLjgxMTA1LC45MjQ1LC44MTEwNSwuOTI0NSwxLDEsLjg2Mjc1LC45MjQ1LC45MDg3MiwuOTM1OTEsLjkwNjg1LC44MjYwMSwuOTA2ODUsLjgyNjAxLC45MDY4NSwuODI2MDEsLjkwNjg1LDEuMDMyOTcsLjkwNjg1LC44MjYwMSwuNzc4OTYsMS4wNTYxMSwuNjM3NywxLjA3NjkyLDEsMSwuOTA5MTgsLjc1NTkzLDEuMDMyOTcsMSwxLC43NjAzMiwuOTM3NSwuOTgxNTYsLjkzNDA3LC43NzI2MSwxLjExNDI5LC44OTI0OSwuOTI0NSwxLDEsLjg5MjQ5LC45MjQ1LC45MjUzNCwuODY2OTgsLjkyNDUsLjg0MTE4LC45MjI3NCwuODQxMTgsLjkyMjc0LC44NDExOCwuOTIyNzQsLjg2NjcsLjg2MjkxLC43NTE4NiwxLjAyOTMzLDEsMSwuNzUxODYsMS4wMjkzMywuNjc3ODksLjc3ODMyLC42Nzc4OSwuNzc4MzIsLjY3Nzg5LC43NzgzMiwuNjc3ODksLjc3ODMyLDEsMSwuNzk3NzYsLjk3NjU1LC43OTc3NiwxLjIzMDIzLC44ODg0NCwuOTI0NSwuODg4NDQsLjkyNDUsLjg4ODQ0LC45MjQ1LC44ODg0NCwuOTI0NSwuODg4NDQsLjkyNDUsLjg4ODQ0LC45MjQ1LC45NDMwOSwuOTg5ODYsLjczMDYsLjg5NDUzLC43MzA2LC43NjY1OSwuNzkwMDQsLjc2NjU5LC43OTAwNCwuNzY2NTksLjc5MDA0LDEuMDkyMzEsLjU0ODczLC44Njc1LC45MjQ1LC43NjMxOCwuODQ4NDMsLjg0NTU3LC44NjY1MSwxLDEsLjc5Nzc2LDEuMjA1NjIsMS4xODYyMiwxLjE4NjIyLDEsMS4xNDM3LC42NzAwOSwuOTYzMzQsLjkzNjk1LDEuMzUxOTEsMS40MDkwOSwuOTUxNjEsMS40ODM4NywuODY3NSwuOTA4NjEsLjYxOTIsLjczNjMsLjY0ODI0LC44MjQxMSwuNTYzMjEsLjg1Njk2LDEuMjM1MTYsLjg2NzUsLjgxNTUyLC43Mjg2LC44NDEzNCwuNzMyMDYsLjc2NjU5LC44NjI3NSwuODQzNjksLjkwNjg1LC43Nzg5MiwuODU4NzEsMS4wMjYzOCwuODkyNDksLjc1ODI4LC44NDExOCwuODU5ODQsLjc3NDUyLC43NjQ2NiwuNzk3NzYsLjczMDYsLjkwNzgyLC43NzgxOCwuOTAzLC44NzI5MSwuOTA2ODUsLjczMDYsLjk5MDU4LDEuMDM2NjcsLjk0NjM1LDEuMjM1MTYsLjk4NDksLjk5MDU4LC45MjM5MywuODkxNiwuOTQyLDEuMDM2NjcsLjc1MDI2LC45NDYzNSwxLjAyOTcsMS4yMzUxNiwuOTA5MTgsLjk0MDQ4LC45ODIxNywuODk3NDYsLjg0MTUzLC45MjI3NCwuODI1MDcsLjg4ODMyLC44NDQzOCwuODgxNzgsMS4wMzUyNSwuOTg0OSwxLjAwMjI1LC43ODA4NiwuOTcyNDgsLjg5NDA0LDEuMjM1MTYsLjk4NDksLjkyMjc0LC45ODQ5LC44OTQwNCwuNzMyMDYsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg5NjkzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44NTg2NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTA5MzMsMSwxLDEsMSwxLDEsLjk0MzA5LC45ODk4NiwuOTQzMDksLjk4OTg2LC45NDMwOSwuOTg5ODYsLjczMDYsLjg5NDUzLDEsMSwuODk1NTIsLjkwNTI3LDEsLjkwMTg2LDEuMTIzMDgsMS4xMjMwOCwxLjEyMzA4LDEuMTIzMDgsMS4yNTY2LDEuMjU2NiwxLjI1NjYsLjg5NTUyLC44OTU1MiwxLjQyMjU5LC42ODk5NCwxLjAzODA5LDEsMSwxLjAxNzYsMS4wMTc2LDEuMTE1MjMsMS40OTU2LDIuMDE0NjIsLjk3ODU4LC44MjYxNiwuOTExMzMsLjgzNDM3LC45MTEzMywxLDEsMSwuNzA1MDgsMSwxLjIzMTA4LC43OTgwMSwuODQ0MjYsLjg0NDI2LC43NzQsLjkwNTcyLDEuODEwNTUsLjkwNzQ5LDEuODEwNTUsMS4yODgwOSwxLjU1NDY5LC45NDQzNCwxLjA3ODA2LDEsLjk3MDk0LC43NTg5LC44NTI4NCwuOTA3NDcsMS4xOTY1OCwuNjk4MjUsLjk3NjIyLDEuMzM1MTIsLjkwNzQ3LC45MDc0NywuODUyODQsLjkwNzQ3LC45MDc0NywxLjQ0OTQ3LC44NTI4NCwuODk0MSwuODk0MSwuNzA1NzIsLjgsLjcwNTcyLC43MDU3MiwuNzA1NzIsLjcwNTcyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTk4NjIsLjk5ODYyLDEsMSwxLDEsMSwxLjAzMzYsLjkxMDI3LDEsMSwxLC45OTg2MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA1ODU5LDEuMDU4NTksMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLGthPXtsaW5lSGVpZ2h0OjEuMjIwNyxsaW5lR2FwOi4yMjA3fSxOYT1bMS4zODc3LDEsMSwxLDEuMTcyMjMsMS4xMjkzLC44OTU1MiwuOTExMzMsLjgwMzk1LDEuMDIyNjksMS4xNTYwMSwuOTEwNTYsLjkxMDU2LDEuMjc5OCwuODUyODQsLjg5ODA3LDEsLjkwODYxLDEuMzkwMTYsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45MTEzMywuOTExMzMsLjkxMTMzLC45NjMwOSwuOTYzMDksLjg1Mjg0LC44NTI4NCwuODUyODQsLjgzMzE5LC44ODA3MSwuODY3NSwuODE1NTIsLjczODM0LC44NTE5MywuNzMyMDYsLjc1MjIsLjgxMTA1LC44NjI3NSwuOTA2ODUsLjYzNzcsLjc3ODkyLC43NTU5MywxLjAyNjM4LC44OTM4NSwuODUxMjIsLjc3NDUyLC44NjUwMywuNzUxODYsLjY4ODg3LC43OTc3NiwuODg4NDQsLjg1MDY2LC45NDI1OCwuNzc4MTgsLjczMDYsLjc2NjU5LDEuMTAzNjksMS4zOTAxNiwxLjEwMzY5LDEuMDYxMzksLjg5NTUyLC44NzM5LC44NjEyOCwuOTQ0NjksLjg0NTcsLjk0NDY5LC44OTQ2NCwxLjA5ODQyLC44NDYzNiwuOTQ0NjksMS4wMzI5NywxLjA3NjkyLC45MDkxOCwxLjAzMjk3LC45NTg5NywuOTQ0NjksLjk0ODIsLjk0NDY5LC45NDQ2OSwxLjA0NjkyLC43ODIyMywxLjIwNTYyLC45NDQ2OSwuOTAzMzIsLjk4OTg2LC44NjYyMSwuOTA1MjcsLjc5MDA0LC45NDE1MiwxLjc3MjU2LC45NDE1MiwuODUyODQsLjk3ODAxLC44OTU1MiwuOTExMzMsLjg5NTUyLC45MTEzMywxLjkxNzI5LC44OTU1MiwxLjE3ODg5LDEuMTMyNTQsMS4wODcwNywuOTIwOTgsLjg1Mjg0LC42ODc4NywuNzEzNTMsLjg0NzM3LC45MDc0NywxLjAwODgsMS4wMDQ0LC44NzY4MywxLDEuMDkwOTEsMSwuOTIyMjksLjczOSwxLjE1NjQyLC45MjA5OCwuNzYyODgsLjgwNTA0LC44MDk3MiwuNzU4NTksLjg2NzUsLjg2NzUsLjg2NzUsLjg2NzUsLjg2NzUsLjg2NzUsLjc2MzE4LC43MzgzNCwuNzMyMDYsLjczMjA2LC43MzIwNiwuNzMyMDYsLjkwNjg1LC45MDY4NSwuOTA2ODUsLjkwNjg1LC44NjQ3NywuODkzODUsLjg1MTIyLC44NTEyMiwuODUxMjIsLjg1MTIyLC44NTEyMiwuODUyODQsLjg1MzExLC44ODg0NCwuODg4NDQsLjg4ODQ0LC44ODg0NCwuNzMwNiwuNzc0NTIsLjg2MzMxLC44NjEyOCwuODYxMjgsLjg2MTI4LC44NjEyOCwuODYxMjgsLjg2MTI4LC44NjkzLC44NDU3LC44OTQ2NCwuODk0NjQsLjg5NDY0LC44OTQ2NCwuODI2MDEsLjgyNjAxLC44MjYwMSwuODI2MDEsLjk0NDY5LC45NDQ2OSwuOTQ4MiwuOTQ4MiwuOTQ4MiwuOTQ4MiwuOTQ4MiwuOTA3NDcsLjg2NjUxLC45NDQ2OSwuOTQ0NjksLjk0NDY5LC45NDQ2OSwuOTA1MjcsLjk0NDY5LC45MDUyNywuODY3NSwuODYxMjgsLjg2NzUsLjg2MTI4LC44Njc1LC44NjEyOCwuNzM4MzQsLjg0NTcsLjczODM0LC44NDU3LC43MzgzNCwuODQ1NywuNzM4MzQsLjg0NTcsLjg1MTkzLC45MjQ1NCwuODY0NzcsLjk5MjEsLjczMjA2LC44OTQ2NCwuNzMyMDYsLjg5NDY0LC43MzIwNiwuODk0NjQsLjczMjA2LC44OTQ2NCwuNzMyMDYsLjg5NDY0LC44MTEwNSwuODQ2MzYsLjgxMTA1LC44NDYzNiwuODExMDUsLjg0NjM2LDEsMSwuODYyNzUsLjk0NDY5LC45MDg3MiwuOTU3ODYsLjkwNjg1LC44MjYwMSwuOTA2ODUsLjgyNjAxLC45MDY4NSwuODI2MDEsLjkwNjg1LDEuMDMyOTcsLjkwNjg1LC44MjYwMSwuNzc3NDEsMS4wNTYxMSwuNjM3NywxLjA3NjkyLDEsMSwuOTA5MTgsLjc1NTkzLDEuMDMyOTcsMSwxLC43NjAzMiwuOTA0NTIsLjk4MTU2LDEuMTE4NDIsLjc3MjYxLDEuMTE0MjksLjg5Mzg1LC45NDQ2OSwxLDEsLjg5Mzg1LC45NDQ2OSwuOTU4NzcsLjg2OTAxLC45NDQ2OSwuODUxMjIsLjk0ODIsLjg1MTIyLC45NDgyLC44NTEyMiwuOTQ4MiwuODY2NywuOTAwMTYsLjc1MTg2LDEuMDQ2OTIsMSwxLC43NTE4NiwxLjA0NjkyLC42ODg4NywuNzgyMjMsLjY4ODg3LC43ODIyMywuNjg4ODcsLjc4MjIzLC42ODg4NywuNzgyMjMsMSwxLC43OTc3NiwuOTIxODgsLjc5Nzc2LDEuMjMwMjMsLjg4ODQ0LC45NDQ2OSwuODg4NDQsLjk0NDY5LC44ODg0NCwuOTQ0NjksLjg4ODQ0LC45NDQ2OSwuODg4NDQsLjk0NDY5LC44ODg0NCwuOTQ0NjksLjk0MjU4LC45ODk4NiwuNzMwNiwuOTA1MjcsLjczMDYsLjc2NjU5LC43OTAwNCwuNzY2NTksLjc5MDA0LC43NjY1OSwuNzkwMDQsMS4wOTIzMSwuNTQ4NzMsLjg2NzUsLjg2MTI4LC43NjMxOCwuODY5MywuODUzMTEsLjg2NjUxLDEsMSwuNzk3NzYsMS4yMDU2MiwxLjE4NjIyLDEuMTg2MjIsMSwxLjE0MzcsLjY3NzQyLC45NjMzNCwuOTM2OTUsMS4zNTE5MSwxLjQwOTA5LC45NTE2MSwxLjQ4Mzg3LC44NjY4NiwuOTA4NjEsLjYyMjY3LC43NDM1OSwuNjU2NDksLjg1NDk4LC41Njk2MywuODgyNTQsMS4yMzUxNiwuODY3NSwuODE1NTIsLjc1NDQzLC44NDUwMywuNzMyMDYsLjc2NjU5LC44NjI3NSwuODUxMjIsLjkwNjg1LC43Nzg5MiwuODU3NDYsMS4wMjYzOCwuODkzODUsLjc1NjU3LC44NTEyMiwuODYyNzUsLjc3NDUyLC43NDE3MSwuNzk3NzYsLjczMDYsLjk1MTY1LC43NzgxOCwuODk3NzIsLjg4ODMxLC45MDY4NSwuNzMwNiwuOTgxNDIsMS4wMjE5MSwuOTY1NzYsMS4yMzUxNiwuOTkwMTgsLjk4MTQyLC45MjM2LC44OTI1OCwuOTQwMzUsMS4wMjE5MSwuNzg4NDgsLjk2NTc2LC45NTYxLDEuMjM1MTYsLjkwOTE4LC45MjU3OCwuOTU0MjQsLjg5NzQ2LC44Mzk2OSwuOTQ4MiwuODAxMTMsLjg5NDQyLC44NTIwOCwuODYxNTUsLjk4MDIyLC45OTAxOCwxLjAwNDUyLC44MTIwOSwuOTkyNDcsLjg5MTgxLDEuMjM1MTYsLjk5MDE4LC45NDgyLC45OTAxOCwuODkxODEsLjczMjA2LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44ODg0NCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuODk0NjQsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk2NzY2LDEsMSwxLDEsMSwxLC45NDI1OCwuOTg5ODYsLjk0MjU4LC45ODk4NiwuOTQyNTgsLjk4OTg2LC43MzA2LC45MDUyNywxLDEsLjg5NTUyLC45MDUyNywxLC45MDE4NiwxLjEyMzA4LDEuMTIzMDgsMS4xMjMwOCwxLjEyMzA4LDEuMjU2NiwxLjI1NjYsMS4yNTY2LC44OTU1MiwuODk1NTIsMS40MjI1OSwuNjkwNDMsMS4wMzgwOSwxLDEsMS4wMTc2LDEuMDE3NiwxLjExNTIzLDEuNDk1NiwyLjAxNDYyLC45OTMzMSwuODI2MTYsLjkxMTMzLC44NDI4NiwuOTExMzMsMSwxLDEsLjcwNTA4LDEsMS4yMzEwOCwuNzk4MDEsLjg0NDI2LC44NDQyNiwuNzc0LC45MDUyNywxLjgxMDU1LC45MDUyNywxLjgxMDU1LDEuMjg4MDksMS41NTQ2OSwuOTQ0MzQsMS4wNzgwNiwxLC45NzA5NCwuNzU4OSwuODUyODQsLjkwNzQ3LDEuMTk2NTgsLjY5ODI1LC45NzYyMiwxLjMzNTEyLC45MDc0NywuOTA3NDcsLjg1MzU2LC45MDc0NywuOTA3NDcsMS40NDk0NywuODUyODQsLjg5NDEsLjg5NDEsLjcwNTcyLC44LC43MDU3MiwuNzA1NzIsLjcwNTcyLC43MDU3MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk5ODYyLC45OTg2MiwxLDEsMSwxLDEsMS4wMzM2LC45MTAyNywxLDEsMSwuOTk4NjIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wNTg1OSwxLjA1ODU5LDEsMSwxLDEuMDcxODUsLjk5NDEzLC45NjMzNCwxLjA4MDY1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sUmE9e2xpbmVIZWlnaHQ6MS4yMjA3LGxpbmVHYXA6LjIyMDd9LEdhPVsuNzYxMTYsMSwxLDEuMDAwNiwuOTk5OTgsLjk5OTc0LC45OTk3MywuOTk5NzMsLjk5OTgyLC45OTk3NywxLjAwMDg3LC45OTk5OCwuOTk5OTgsLjk5OTU5LDEuMDAwMDMsMS4wMDA2LC45OTk5OCwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5OTgsMSwxLjAwMDAzLDEuMDAwMDMsMS4wMDAwMywxLjAwMDI2LC45OTk5LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMjYsMS4wMDAyMiwuOTk5NzcsMS4wMDA2LC45OTk3MywuOTk5NzcsMS4wMDAyNiwuOTk5OTksLjk5OTc3LDEuMDAwMjIsMS4wMDAwMSwxLjAwMDIyLC45OTk3NywxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMDEsMS4wMDAxNiwxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5OTgsMS4wMDA2LC45OTk5OCwxLjAwMDAzLC45OTk3MywuOTk5OTgsLjk5OTczLDEuMDAwMjYsLjk5OTczLDEuMDAwMjYsLjk5OTczLC45OTk5OCwxLjAwMDI2LDEuMDAwMjYsMS4wMDA2LDEuMDAwNiwuOTk5NzMsMS4wMDA2LC45OTk4MiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45OTk1OSwuOTk5NzMsLjk5OTk4LDEuMDAwMjYsLjk5OTczLDEuMDAwMjIsLjk5OTczLC45OTk3MywxLC45OTk1OSwxLjAwMDc3LC45OTk1OSwxLjAwMDAzLC45OTk5OCwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA3NywuOTk5NzMsLjk5OTk4LDEuMDAwMjUsLjk5OTY4LC45OTk3MywxLjAwMDAzLDEuMDAwMjUsLjYwMjk5LDEuMDAwMjQsMS4wNjQwOSwxLDEsLjk5OTk4LDEsLjk5OTczLDEuMDAwNiwuOTk5OTgsMSwuOTk5MzYsLjk5OTczLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMjYsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsMSwuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTc3LC45OTk3NywxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAwMywxLjAwMDIyLC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5ODIsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjA2NDA5LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTk5NzMsMS4wMDAyNiwuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsMS4wMzM3NCwuOTk5NzcsMS4wMDAyNiwxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNDIsLjk5OTczLC45OTk3MywxLjAwMDYsLjk5OTc3LC45OTk3MywuOTk5NzMsMS4wMDAyNiwxLjAwMDYsMS4wMDAyNiwxLjAwMDYsMS4wMDAyNiwxLjAzODI4LDEuMDAwMjYsLjk5OTk5LDEuMDAwMjYsMS4wMDA2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTkzLC45OTk4LDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMSwxLjAwMDE2LC45OTk3NywuOTk5NTksLjk5OTc3LC45OTk1OSwuOTk5NzcsLjk5OTU5LDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMjYsLjk5OTk4LDEuMDAwMjYsLjgxMjEsMS4wMDAyNiwuOTk5OTgsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsLjk5OTc3LDEuMDAwMjYsMS4wMDAxNiwxLjAwMDIyLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwxLjAwMDI2LDEsMS4wMDA2LC45OTk3MywuOTk5NzcsLjk5OTczLDEsLjk5OTgyLDEuMDAwMjIsMS4wMDAyNiwxLjAwMDAxLC45OTk3MywxLjAwMDI2LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsMS4wMDAzNCwuOTk5NzcsMSwuOTk5OTcsMS4wMDAyNiwxLjAwMDc4LDEuMDAwMzYsLjk5OTczLDEuMDAwMTMsMS4wMDA2LC45OTk3NywuOTk5NzcsLjk5OTg4LC44NTE0OCwxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMjIsMS4wMDA2LC45OTk3NywxLjAwMDAxLC45OTk5OSwuOTk5NzcsMS4wMDA2OSwxLjAwMDIyLC45OTk3NywxLjAwMDAxLC45OTk4NCwxLjAwMDI2LDEuMDAwMDEsMS4wMDAyNCwxLjAwMDAxLC45OTk5LDEsMS4wMDA2LDEuMDAwMDEsMS4wMDA0MSwuOTk5NjIsMS4wMDAyNiwxLjAwMDYsLjk5OTk1LDEuMDAwNDEsLjk5OTQyLC45OTk3MywuOTk5MjcsMS4wMDA4MiwuOTk5MDIsMS4wMDAyNiwxLjAwMDg3LDEuMDAwNiwxLjAwMDY5LC45OTk3MywuOTk4NjcsLjk5OTczLC45OTkzLDEuMDAwMjYsMS4wMDA0OSwxLjAwMDU2LDEsLjk5OTg4LC45OTkzNSwuOTk5OTUsLjk5OTU0LDEuMDAwNTUsLjk5OTQ1LDEuMDAwMzIsMS4wMDA2LC45OTk5NSwxLjAwMDI2LC45OTk5NSwxLjAwMDMyLDEuMDAwMDEsMS4wMDAwOCwuOTk5NzEsMS4wMDAxOSwuOTk5NCwxLjAwMDAxLDEuMDAwNiwxLjAwMDQ0LC45OTk3MywxLjAwMDIzLDEuMDAwNDcsMSwuOTk5NDIsLjk5NTYxLC45OTk4OSwxLjAwMDM1LC45OTk3NywxLjAwMDM1LC45OTk3NywxLjAwMDE5LC45OTk0NCwxLjAwMDAxLDEuMDAwMjEsLjk5OTI2LDEuMDAwMzUsMS4wMDAzNSwuOTk5NDIsMS4wMDA0OCwuOTk5OTksLjk5OTc3LDEuMDAwMjIsMS4wMDAzNSwxLjAwMDAxLC45OTk3NywxLjAwMDI2LC45OTk4OSwxLjAwMDU3LDEuMDAwMDEsLjk5OTM2LDEuMDAwNTIsMS4wMDAxMiwuOTk5OTYsMS4wMDA0MywxLDEuMDAwMzUsLjk5OTQsLjk5OTc2LDEuMDAwMzUsLjk5OTczLDEuMDAwNTIsMS4wMDA0MSwxLjAwMTE5LDEuMDAwMzcsLjk5OTczLDEuMDAwMDIsLjk5OTg2LDEuMDAwNDEsMS4wMDA0MSwuOTk5MDIsLjk5OTYsMS4wMDAzNCwuOTk5OTksMS4wMDAyNiwuOTk5OTksMS4wMDAyNiwuOTk5NzMsMS4wMDA1MiwuOTk5NzMsMSwuOTk5NzMsMS4wMDA0MSwxLjAwMDc1LC45OTk0LDEuMDAwMywuOTk5OTksMSwxLjAwMDQxLC45OTk1NSwxLC45OTkxNSwuOTk5NzMsLjk5OTczLDEuMDAwMjYsMS4wMDExOSwuOTk5NTUsLjk5OTczLDEuMDAwNiwuOTk5MTEsMS4wMDA2LDEuMDAwMjYsLjk5OTcyLDEuMDAwMjYsLjk5OTAyLDEuMDAwNDEsLjk5OTczLC45OTk5OSwxLDEsMS4wMDAzOCwxLjAwMDUsMS4wMDAxNiwxLjAwMDIyLDEuMDAwMTYsMS4wMDAyMiwxLjAwMDE2LDEuMDAwMjIsMS4wMDAwMSwuOTk5NzMsMSwxLC45OTk3MywxLDEsLjk5OTU1LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLDEsMSwuOTk5NzMsLjk5OTczLC45OTk3MiwxLDEsMS4wMDEwNiwuOTk5OTksLjk5OTk4LC45OTk5OCwuOTk5OTksLjk5OTk4LDEuNjY0NzUsMSwuOTk5NzMsLjk5OTczLDEuMDAwMjMsLjk5OTczLC45OTk3MSwxLjAwMDQ3LDEuMDAwMjMsMSwuOTk5OTEsLjk5OTg0LDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMSwxLDEsMSwxLDEsMSwuOTk5NzIsMSwxLjIwOTg1LDEuMzk3MTMsMS4wMDAwMywxLjAwMDMxLDEuMDAwMTUsMSwuOTk1NjEsMS4wMDAyNywxLjAwMDMxLDEuMDAwMzEsLjk5OTE1LDEuMDAwMzEsMS4wMDAzMSwuOTk5OTksMS4wMDAwMywuOTk5OTksLjk5OTk5LDEuNDExNDQsMS42LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MDU3OSwxLjQwNTc5LDEuMzY2MjUsLjk5OTk5LDEsLjk5ODYxLC45OTg2MSwxLDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk5OTcyLC45OTk5OSwuOTk5OTksLjk5OTk5LC45OTk5OSwxLjQwNDgzLDEsLjk5OTc3LDEuMDAwNTQsMSwxLC45OTk1MywuOTk5NjIsMS4wMDA0MiwuOTk5NSwxLDEsMSwxLDEsMSwxLDEsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0seGE9e2xpbmVIZWlnaHQ6MS4yLGxpbmVHYXA6LjJ9LFVhPVsuNzYxMTYsMSwxLDEuMDAwNiwuOTk5OTgsLjk5OTc0LC45OTk3MywuOTk5NzMsLjk5OTgyLC45OTk3NywxLjAwMDg3LC45OTk5OCwuOTk5OTgsLjk5OTU5LDEuMDAwMDMsMS4wMDA2LC45OTk5OCwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5OTgsMSwxLjAwMDAzLDEuMDAwMDMsMS4wMDAwMywxLjAwMDI2LC45OTk5LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMjYsMS4wMDAyMiwuOTk5NzcsMS4wMDA2LC45OTk3MywuOTk5NzcsMS4wMDAyNiwuOTk5OTksLjk5OTc3LDEuMDAwMjIsMS4wMDAwMSwxLjAwMDIyLC45OTk3NywxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMDEsMS4wMDAxNiwxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5OTgsMS4wMDA2LC45OTk5OCwxLjAwMDAzLC45OTk3MywuOTk5OTgsLjk5OTczLDEuMDAwMjYsLjk5OTczLDEuMDAwMjYsLjk5OTczLC45OTk5OCwxLjAwMDI2LDEuMDAwMjYsMS4wMDA2LDEuMDAwNiwuOTk5NzMsMS4wMDA2LC45OTk4MiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45OTk1OSwuOTk5NzMsLjk5OTk4LDEuMDAwMjYsLjk5OTczLDEuMDAwMjIsLjk5OTczLC45OTk3MywxLC45OTk1OSwxLjAwMDc3LC45OTk1OSwxLjAwMDAzLC45OTk5OCwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA3NywuOTk5NzMsLjk5OTk4LDEuMDAwMjUsLjk5OTY4LC45OTk3MywxLjAwMDAzLDEuMDAwMjUsLjYwMjk5LDEuMDAwMjQsMS4wNjQwOSwxLDEsLjk5OTk4LDEsLjk5OTczLDEuMDAwNiwuOTk5OTgsMSwuOTk5MzYsLjk5OTczLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMjYsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywuOTk5NzcsMSwuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTc3LC45OTk3NywxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAwMywxLjAwMDIyLC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5ODIsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwxLjA2NDA5LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTk5NzMsMS4wMDAyNiwuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsMS4wMDQ0LC45OTk3NywxLjAwMDI2LDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTcxLC45OTk3MywuOTk5NzMsMS4wMDA2LC45OTk3NywuOTk5NzMsLjk5OTczLDEuMDAwMjYsMS4wMDA2LDEuMDAwMjYsMS4wMDA2LDEuMDAwMjYsMS4wMTAxMSwxLjAwMDI2LC45OTk5OSwxLjAwMDI2LDEuMDAwNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5NzcsMS4wMDAyNiwuOTk5MywuOTk5OCwxLjAwMDI2LDEuMDAwMjIsMS4wMDAyNiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAyMiwxLjAwMDI2LDEsMS4wMDAxNiwuOTk5NzcsLjk5OTU5LC45OTk3NywuOTk5NTksLjk5OTc3LC45OTk1OSwxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDI2LC45OTk5OCwxLjAwMDI2LC44MTIxLDEuMDAwMjYsLjk5OTk4LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LC45OTk3NywxLjAwMDI2LDEuMDAwMTYsMS4wMDAyMiwxLjAwMDAxLC45OTk3MywxLjAwMDAxLDEuMDAwMjYsMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwNiwuOTk5NzMsLjk5OTc3LC45OTk3MywxLC45OTk4MiwxLjAwMDIyLDEuMDAwMjYsMS4wMDAwMSwuOTk5NzMsMS4wMDAyNiwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5NzcsMSwxLDEuMDAwMjYsLjk5OTY5LC45OTk3MiwuOTk5ODEsLjk5OTgsMS4wMDA2LC45OTk3NywuOTk5NzcsMS4wMDAyMiwuOTExNTUsMS4wMDAwMSwxLjAwMDI2LC45OTk3NywxLjAwMDIyLDEuMDAwNiwuOTk5NzcsMS4wMDAwMSwuOTk5OTksLjk5OTc3LC45OTk2NiwxLjAwMDIyLDEuMDAwMzIsMS4wMDAwMSwuOTk5NDQsMS4wMDAyNiwxLjAwMDAxLC45OTk2OCwxLjAwMDAxLDEuMDAwNDcsMSwxLjAwMDYsMS4wMDAwMSwuOTk5ODEsMS4wMDEwMSwxLjAwMDI2LDEuMDAwNiwuOTk5NDgsLjk5OTgxLDEuMDAwNjQsLjk5OTczLC45OTk0MiwxLjAwMTAxLDEuMDAwNjEsMS4wMDAyNiwxLjAwMDY5LDEuMDAwNiwxLjAwMDE0LC45OTk3MywxLjAxMzIyLC45OTk3MywxLjAwMDY1LDEuMDAwMjYsMS4wMDAxMiwuOTk5MjMsMSwxLjAwMDY0LDEuMDAwNzYsLjk5OTQ4LDEuMDAwNTUsMS4wMDA2MywxLjAwMDA3LC45OTk0MywxLjAwMDYsLjk5OTQ4LDEuMDAwMjYsLjk5OTQ4LC45OTk0MywxLjAwMDAxLDEuMDAwMDEsMS4wMDAyOSwxLjAwMDM4LDEuMDAwMzUsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzgsMS4wMDAwMSwxLjAwMDU3LC45OTk4OSwuOTk5NjcsLjk5OTY0LC45OTk2NywuOTk5NzcsLjk5OTk5LC45OTk3NywxLjAwMDM4LC45OTk3NywxLjAwMDAxLC45OTk3MywxLjAwMDY2LC45OTk2NywuOTk5NjcsMS4wMDA0MSwuOTk5OTgsLjk5OTk5LC45OTk3NywxLjAwMDIyLC45OTk2NywxLjAwMDAxLC45OTk3NywxLjAwMDI2LC45OTk2NCwxLjAwMDMxLDEuMDAwMDEsLjk5OTk5LC45OTk5OSwxLDEuMDAwMjMsMSwxLC45OTk5OSwxLjAwMDM1LDEuMDAwMDEsLjk5OTk5LC45OTk3MywuOTk5NzcsLjk5OTk5LDEuMDAwNTgsLjk5OTczLC45OTk3MywuOTk5NTUsLjk5OTUsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMzIsLjk5OTg5LDEuMDAwMzQsLjk5OTk5LDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LC45OTk3MywuNDU5OTgsLjk5OTczLDEuMDAwMjYsLjk5OTczLDEuMDAwMDEsLjk5OTk5LC45OTk4MiwuOTk5OTQsLjk5OTk2LDEsMS4wMDA0MiwxLjAwMDQ0LDEuMDAwMjksMS4wMDAyMywuOTk5NzMsLjk5OTczLDEuMDAwMjYsLjk5OTQ5LDEuMDAwMDIsLjk5OTczLDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3NSwxLjAwMDI2LDEuMDAwMjYsMS4wMDAzMiwuOTg2ODUsLjk5OTczLDEuMDAwMjYsMSwxLC45OTk2NiwxLjAwMDQ0LDEuMDAwMTYsMS4wMDAyMiwxLjAwMDE2LDEuMDAwMjIsMS4wMDAxNiwxLjAwMDIyLDEuMDAwMDEsLjk5OTczLDEsMSwuOTk5NzMsMSwxLC45OTk1NSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMSwxLDEsLjk5OTczLC45OTk3MywuOTk5NzIsMSwxLDEuMDAxMDYsLjk5OTk5LC45OTk5OCwuOTk5OTgsLjk5OTk5LC45OTk5OCwxLjY2NDc1LDEsLjk5OTczLC45OTk3MywxLC45OTk3MywuOTk5NzEsLjk5OTc4LDEsMSwuOTk5OTEsLjk5OTg0LDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDA5OCwxLDEsMSwxLjAwMDQ5LDEsMSwuOTk5NzIsMSwxLjIwOTg1LDEuMzk3MTMsMS4wMDAwMywxLjAwMDMxLDEuMDAwMTUsMSwuOTk1NjEsMS4wMDAyNywxLjAwMDMxLDEuMDAwMzEsLjk5OTE1LDEuMDAwMzEsMS4wMDAzMSwuOTk5OTksMS4wMDAwMywuOTk5OTksLjk5OTk5LDEuNDExNDQsMS42LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MDU3OSwxLjQwNTc5LDEuMzY2MjUsLjk5OTk5LDEsLjk5ODYxLC45OTg2MSwxLDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk5OTcyLC45OTk5OSwuOTk5OTksLjk5OTk5LC45OTk5OSwxLjQwNDgzLDEsLjk5OTc3LDEuMDAwNTQsMSwxLC45OTk1MywuOTk5NjIsMS4wMDA0MiwuOTk5NSwxLDEsMSwxLDEsMSwxLDEsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sTWE9e2xpbmVIZWlnaHQ6MS4zNSxsaW5lR2FwOi4yfSxMYT1bLjc2MTE2LDEsMSwxLjAwMDYsMS4wMDA2LDEuMDAwMDYsLjk5OTczLC45OTk3MywuOTk5ODIsMS4wMDAwMSwxLjAwMDQzLC45OTk5OCwuOTk5OTgsLjk5OTU5LDEuMDAwMDMsMS4wMDA2LC45OTk5OCwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDYsMSwxLjAwMDAzLDEuMDAwMDMsMS4wMDAwMywuOTk5NzMsLjk5OTg3LDEuMDAwMDEsMS4wMDAwMSwuOTk5NzcsLjk5OTc3LDEuMDAwMDEsMS4wMDAyNiwxLjAwMDIyLC45OTk3NywxLjAwMDYsMSwxLjAwMDAxLC45OTk3MywuOTk5OTksLjk5OTc3LDEuMDAwMjIsMS4wMDAwMSwxLjAwMDIyLC45OTk3NywxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMDEsMS4wMDAxNiwxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwuOTk5NDksLjk5OTczLC45OTk5OCwuOTk5NzMsLjk5OTczLDEsLjk5OTczLC45OTk3MywxLjAwMDYsLjk5OTczLC45OTk3MywuOTk5MjQsLjk5OTI0LDEsLjk5OTI0LC45OTk5OSwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTk4LDEsMS4wMDA2LC45OTk3MywxLC45OTk3NywxLDEsMSwxLjAwMDA1LDEuMDAwOSwxLjAwMDA1LDEuMDAwMDMsLjk5OTk4LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDksLjk5OTczLC45OTk5OCwxLjAwMDI1LC45OTk2OCwuOTk5NzMsMS4wMDAwMywxLjAwMDI1LC42MDI5OSwxLjAwMDI0LDEuMDY0MDksMSwxLC45OTk5OCwxLC45OTk4LDEuMDAwNiwuOTk5OTgsMSwuOTk5MzYsLjk5OTczLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMjYsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMSwuOTk5NzcsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTc3LC45OTk3NywxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAwMywxLjAwMDIyLC45OTk3NywuOTk5NzcsLjk5OTc3LC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5ODIsMSwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjA2NDA5LDEuMDAwMjYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEsLjk5OTczLDEsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsMS4wMDAwMSwuOTk5NzMsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEsLjk5OTc3LDEuMDI4OCwuOTk5NzcsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTI0LDEuMDAwNiwxLjAwMDYsLjk5OTQ2LDEuMDAwMzQsMSwuOTk5MjQsMS4wMDAwMSwxLDEsLjk5OTczLC45OTkyNCwuOTk5NzMsLjk5OTI0LC45OTk3MywxLjA2MzExLC45OTk3MywxLjAwMDI0LC45OTk3MywuOTk5MjQsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsMS4wMDA0MSwuOTk5OCwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMSwxLjAwMDE2LC45OTk3NywuOTk5OTgsLjk5OTc3LC45OTk5OCwuOTk5NzcsLjk5OTk4LDEuMDAwMDEsMSwxLjAwMDAxLDEsMS4wMDAwMSwxLDEuMDAwMDEsMSwxLjAwMDI2LDEuMDAwNiwxLjAwMDI2LC44OTU0NywxLjAwMDI2LDEuMDAwNiwuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywxLjAwMDE2LC45OTk3NywxLjAwMDAxLDEsMS4wMDAwMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwuOTk5MjQsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEsLjk5OTgyLDEuMDAwMjIsMS4wMDAyNiwxLjAwMDAxLDEsMS4wMDAyNiwxLjAwMDYsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwxLjAwMDAxLDEsMS4wMDA1NCwuOTk5NzcsMS4wMDA4NCwxLjAwMDA3LC45OTk3MywxLjAwMDEzLC45OTkyNCwxLjAwMDAxLDEuMDAwMDEsLjk5OTQ1LC45MTIyMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMjIsMS4wMDA2LDEuMDAwMDEsMS4wMDAwMSwuOTk5OTksLjk5OTc3LC45OTkzMywxLjAwMDIyLDEuMDAwNTQsMS4wMDAwMSwxLjAwMDY1LDEuMDAwMjYsMS4wMDAwMSwxLjAwMDEsMS4wMDAwMSwxLjAwMDUyLDEsMS4wMDA2LDEuMDAwMDEsLjk5OTQ1LC45OTg5NywuOTk5NjgsLjk5OTI0LDEuMDAwMzYsLjk5OTQ1LC45OTk0OSwxLDEuMDAwNiwuOTk4OTcsLjk5OTE4LC45OTk2OCwuOTk5MTEsLjk5OTI0LDEsLjk5OTYyLDEuMDE0ODcsMSwxLjAwMDUsLjk5OTczLDEuMDAwMTIsMS4wMDA0MywxLC45OTk5NSwuOTk5OTQsMS4wMDAzNiwuOTk5NDcsMS4wMDAxOSwxLjAwMDYzLDEuMDAwMjUsLjk5OTI0LDEuMDAwMzYsLjk5OTczLDEuMDAwMzYsMS4wMDAyNSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAyNywxLjAwMDEsMS4wMDA2OCwxLjAwMDAxLDEuMDAwNiwxLjAwMDYsMSwxLjAwMDA4LC45OTk1NywuOTk5NzIsLjk5OTQsLjk5OTU0LC45OTk3NSwxLjAwMDUxLDEuMDAwMDEsMS4wMDAxOSwxLjAwMDAxLDEuMDAwMSwuOTk5ODYsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMzgsLjk5OTU0LC45OTk1NCwuOTk5NCwxLjAwMDY2LC45OTk5OSwuOTk5NzcsMS4wMDAyMiwxLjAwMDU0LDEuMDAwMDEsLjk5OTc3LDEuMDAwMjYsLjk5OTc1LDEuMDAwMSwxLjAwMDAxLC45OTk5MywuOTk5NSwuOTk5NTUsMS4wMDAxNiwuOTk5NzgsLjk5OTc0LDEuMDAwMTksMS4wMDAyMiwuOTk5NTUsMS4wMDA1MywuOTk5NzMsMS4wMDA4OSwxLjAwMDA1LC45OTk2NywxLjAwMDQ4LC45OTk3MywxLjAwMDAyLDEuMDAwMzQsLjk5OTczLC45OTk3MywuOTk5NjQsMS4wMDAwNiwxLjAwMDY2LC45OTk0NywuOTk5NzMsLjk4ODk0LC45OTk3MywxLC40NDg5OCwxLC45OTk0NiwxLDEuMDAwMzksMS4wMDA4MiwuOTk5OTEsLjk5OTkxLC45OTk4NSwxLjAwMDIyLDEuMDAwMjMsMS4wMDA2MSwxLjAwMDA2LC45OTk2NiwuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDE5LDEuMDAwOCwxLC45OTkyNCwuOTk5MjQsLjk5OTI0LC45OTk4MywxLjAwMDQ0LC45OTk3MywuOTk5NjQsLjk4MzMyLDEsLjk5OTczLDEsMSwuOTk5NjIsLjk5ODk1LDEuMDAwMTYsLjk5OTc3LDEuMDAwMTYsLjk5OTc3LDEuMDAwMTYsLjk5OTc3LDEuMDAwMDEsMSwxLDEsLjk5OTczLDEsMSwuOTk5NTUsLjk5OTI0LC45OTkyNCwuOTk5MjQsLjk5OTI0LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk3MywuOTk5NzMsLjk5OTcyLDEsMSwxLjAwMjY3LC45OTk5OSwuOTk5OTgsLjk5OTk4LDEsLjk5OTk4LDEuNjY0NzUsMSwuOTk5NzMsLjk5OTczLDEuMDAwMjMsLjk5OTczLDEuMDA0MjMsLjk5OTI1LC45OTk5OSwxLC45OTk5MSwuOTk5ODQsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDQ5LDEsMS4wMDI0NSwxLDEsMSwxLC45NjMyOSwxLDEuMjA5ODUsMS4zOTcxMywxLjAwMDAzLC44MjU0LDEuMDAwMTUsMSwxLjAwMDM1LDEuMDAwMjcsMS4wMDAzMSwxLjAwMDMxLDEuMDAwMDMsMS4wMDAzMSwxLjAwMDMxLC45OTk5OSwxLjAwMDAzLC45OTk5OSwuOTk5OTksMS40MTE0NCwxLjYsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQwNTc5LDEuNDA1NzksMS4zNjYyNSwuOTk5OTksMSwuOTk4NjEsLjk5ODYxLDEsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsMS4wMDAyNiwuOTUzMTcsLjk5OTk5LC45OTk5OSwuOTk5OTksLjk5OTk5LDEuNDA0ODMsMSwuOTk5NzcsMS4wMDA1NCwxLDEsLjk5OTUzLC45OTk2MiwxLjAwMDQyLC45OTk1LDEsMSwxLDEsMSwxLDEsMSwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSxIYT17bGluZUhlaWdodDoxLjM1LGxpbmVHYXA6LjJ9LEphPVsuNzYxMTYsMSwxLDEuMDAwNiwxLjAwMDYsMS4wMDAwNiwuOTk5NzMsLjk5OTczLC45OTk4MiwxLjAwMDAxLDEuMDAwNDMsLjk5OTk4LC45OTk5OCwuOTk5NTksMS4wMDAwMywxLjAwMDYsLjk5OTk4LDEuMDAwNiwxLjAwMDYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwNiwxLDEuMDAwMDMsMS4wMDAwMywxLjAwMDAzLC45OTk3MywuOTk5ODcsMS4wMDAwMSwxLjAwMDAxLC45OTk3NywuOTk5NzcsMS4wMDAwMSwxLjAwMDI2LDEuMDAwMjIsLjk5OTc3LDEuMDAwNiwxLDEuMDAwMDEsLjk5OTczLC45OTk5OSwuOTk5NzcsMS4wMDAyMiwxLjAwMDAxLDEuMDAwMjIsLjk5OTc3LDEuMDAwMDEsMS4wMDAyNiwuOTk5NzcsMS4wMDAwMSwxLjAwMDE2LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDI2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LC45OTk0OSwuOTk5NzMsLjk5OTk4LC45OTk3MywuOTk5NzMsMSwuOTk5NzMsLjk5OTczLDEuMDAwNiwuOTk5NzMsLjk5OTczLC45OTkyNCwuOTk5MjQsMSwuOTk5MjQsLjk5OTk5LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5OTgsMSwxLjAwMDYsLjk5OTczLDEsLjk5OTc3LDEsMSwxLDEuMDAwMDUsMS4wMDA5LDEuMDAwMDUsMS4wMDAwMywuOTk5OTgsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDAwOSwuOTk5NzMsLjk5OTk4LDEuMDAwMjUsLjk5OTY4LC45OTk3MywxLjAwMDAzLDEuMDAwMjUsLjYwMjk5LDEuMDAwMjQsMS4wNjQwOSwxLDEsLjk5OTk4LDEsLjk5OTgsMS4wMDA2LC45OTk5OCwxLC45OTkzNiwuOTk5NzMsMS4wMDAwMiwxLjAwMDAyLDEuMDAwMDIsMS4wMDAyNiwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLC45OTk3NywxLjAwMDAxLDEuMDAwMDEsMS4wMDAwMSwxLjAwMDAxLDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwuOTk5NzcsLjk5OTc3LDEuMDAwMjIsMS4wMDAyMiwxLjAwMDIyLDEuMDAwMjIsMS4wMDAyMiwxLjAwMDAzLDEuMDAwMjIsLjk5OTc3LC45OTk3NywuOTk5NzcsLjk5OTc3LDEuMDAwMDEsMS4wMDAwMSwxLjAwMDI2LC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk4MiwxLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsLjk5OTczLDEuMDY0MDksMS4wMDAyNiwuOTk5NzMsLjk5OTczLC45OTk3MywuOTk5NzMsMSwuOTk5NzMsMSwxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywxLjAwMDAxLC45OTk3MywuOTk5NzcsMSwuOTk5NzcsMSwuOTk5NzcsMSwuOTk5NzcsMSwuOTk5NzcsMS4wNDU5NiwuOTk5NzcsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLDEuMDAwMjIsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsMS4wMDA2LDEuMDAwNiwxLjAwMDYsLjk5OTI0LDEuMDAwNiwxLjAwMDYsMS4wMDAxOSwxLjAwMDM0LDEsLjk5OTI0LDEuMDAwMDEsMSwxLC45OTk3MywuOTk5MjQsLjk5OTczLC45OTkyNCwuOTk5NzMsMS4wMjU3MiwuOTk5NzMsMS4wMDAwNSwuOTk5NzMsLjk5OTI0LC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk5OSwuOTk5OCwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMS4wMDAyMiwuOTk5NzMsMSwxLjAwMDE2LC45OTk3NywuOTk5OTgsLjk5OTc3LC45OTk5OCwuOTk5NzcsLjk5OTk4LDEuMDAwMDEsMSwxLjAwMDAxLDEsMS4wMDAwMSwxLDEuMDAwMDEsMSwxLjAwMDI2LDEuMDAwNiwxLjAwMDI2LC44NDUzMywxLjAwMDI2LDEuMDAwNiwuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywuOTk5NzcsLjk5OTczLC45OTk3NywuOTk5NzMsLjk5OTc3LC45OTk3MywxLjAwMDE2LC45OTk3NywxLjAwMDAxLDEsMS4wMDAwMSwxLjAwMDI2LDEsMS4wMDAyNiwxLDEuMDAwMjYsMSwuOTk5MjQsLjk5OTczLDEuMDAwMDEsLjk5OTczLDEsLjk5OTgyLDEuMDAwMjIsMS4wMDAyNiwxLjAwMDAxLDEsMS4wMDAyNiwxLjAwMDYsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTk4LC45OTk5OCwuOTk5MjgsMSwuOTk5NzcsMS4wMDAxMywxLjAwMDU1LC45OTk0NywuOTk5NDUsLjk5OTQxLC45OTkyNCwxLjAwMDAxLDEuMDAwMDEsMS4wMDA0LC45MTYyMSwxLjAwMDAxLDEuMDAwMjYsLjk5OTc3LDEuMDAwMjIsMS4wMDA2LDEuMDAwMDEsMS4wMDAwNSwuOTk5OTksLjk5OTc3LDEuMDAwMTUsMS4wMDAyMiwuOTk5NzcsMS4wMDAwMSwuOTk5NzMsMS4wMDAyNiwxLjAwMDAxLDEuMDAwMTksMS4wMDAwMSwuOTk5NDYsMSwxLjAwMDYsMS4wMDAwMSwuOTk5NzgsMS4wMDA0NSwuOTk5NzMsLjk5OTI0LDEuMDAwMjMsLjk5OTc4LC45OTk2NiwxLDEuMDAwNjUsMS4wMDA0NSwxLjAwMDE5LC45OTk3MywuOTk5NzMsLjk5OTI0LDEsMSwuOTY0OTksMSwxLjAwMDU1LC45OTk3MywxLjAwMDA4LDEuMDAwMjcsMSwuOTk5NywuOTk5OTUsMS4wMDAyMywuOTk5MzMsMS4wMDAxOSwxLjAwMDE1LDEuMDAwMzEsLjk5OTI0LDEuMDAwMjMsLjk5OTczLDEuMDAwMjMsMS4wMDAzMSwxLjAwMDAxLC45OTkyOCwxLjAwMDI5LDEuMDAwOTIsMS4wMDAzNSwxLjAwMDAxLDEuMDAwNiwxLjAwMDYsMSwuOTk5ODgsLjk5OTc1LDEsMS4wMDA4MiwuOTk1NjEsLjk5OTYsMS4wMDAzNSwxLjAwMDAxLC45OTk2MiwxLjAwMDAxLDEuMDAwOTIsLjk5OTY0LDEuMDAwMDEsLjk5OTYzLC45OTk5OSwxLjAwMDM1LDEuMDAwMzUsMS4wMDA4MiwuOTk5NjIsLjk5OTk5LC45OTk3NywxLjAwMDIyLDEuMDAwMzUsMS4wMDAwMSwuOTk5NzcsMS4wMDAyNiwuOTk5NiwuOTk5NjcsMS4wMDAwMSwxLjAwMDM0LDEuMDAwNzQsMS4wMDA1NCwxLjAwMDUzLDEuMDAwNjMsLjk5OTcxLC45OTk2MiwxLjAwMDM1LC45OTk3NSwuOTk5NzcsLjk5OTczLDEuMDAwNDMsLjk5OTUzLDEuMDAwNywuOTk5MTUsLjk5OTczLDEuMDAwMDgsLjk5ODkyLDEuMDAwNzMsMS4wMDA3MywxLjAwMTE0LC45OTkxNSwxLjAwMDczLC45OTk1NSwuOTk5NzMsMS4wMDA5MiwuOTk5NzMsMSwuOTk5OTgsMSwxLjAwMDMsMSwxLjAwMDQzLDEuMDAwMDEsLjk5OTY5LDEuMDAwMywxLDEuMDAwMzUsMS4wMDAwMSwuOTk5NSwxLDEuMDAwOTIsLjk5OTczLC45OTk3MywuOTk5NzMsMS4wMDA3LC45OTk1LDEsLjk5OTI0LDEuMDAwNiwuOTk5MjQsLjk5OTcyLDEuMDAwNjIsLjk5OTczLDEuMDAxMTQsMS4wMDA3MywxLC45OTk1NSwxLDEsMS4wMDA0NywuOTk5NjgsMS4wMDAxNiwuOTk5NzcsMS4wMDAxNiwuOTk5NzcsMS4wMDAxNiwuOTk5NzcsMS4wMDAwMSwxLDEsMSwuOTk5NzMsMSwxLC45OTk1NSwuOTk5MjQsLjk5OTI0LC45OTkyNCwuOTk5MjQsLjk5OTk4LC45OTk5OCwuOTk5OTgsLjk5OTczLC45OTk3MywuOTk5NzIsMSwxLDEuMDAyNjcsLjk5OTk5LC45OTk5OCwuOTk5OTgsMSwuOTk5OTgsMS42NjQ3NSwxLC45OTk3MywuOTk5NzMsMS4wMDAyMywuOTk5NzMsLjk5OTcxLC45OTkyNSwxLjAwMDIzLDEsLjk5OTkxLC45OTk4NCwxLjAwMDAyLDEuMDAwMDIsMS4wMDAwMiwxLjAwMDAyLDEsMSwxLDEsMSwxLDEsLjk2MzI5LDEsMS4yMDk4NSwxLjM5NzEzLDEuMDAwMDMsLjgyNTQsMS4wMDAxNSwxLDEuMDAwMzUsMS4wMDAyNywxLjAwMDMxLDEuMDAwMzEsLjk5OTE1LDEuMDAwMzEsMS4wMDAzMSwuOTk5OTksMS4wMDAwMywuOTk5OTksLjk5OTk5LDEuNDExNDQsMS42LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MTE0NCwxLjQxMTQ0LDEuNDExNDQsMS40MDU3OSwxLjQwNTc5LDEuMzY2MjUsLjk5OTk5LDEsLjk5ODYxLC45OTg2MSwxLDEuMDAwMjYsMS4wMDAyNiwxLjAwMDI2LDEuMDAwMjYsLjk1MzE3LC45OTk5OSwuOTk5OTksLjk5OTk5LC45OTk5OSwxLjQwNDgzLDEsLjk5OTc3LDEuMDAwNTQsMSwxLC45OTk1MywuOTk5NjIsMS4wMDA0MiwuOTk5NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLFlhPXtsaW5lSGVpZ2h0OjEuMixsaW5lR2FwOi4yfSx2YT1bMzY1LDAsMzMzLDI3OCwzMzMsNDc0LDU1Niw1NTYsODg5LDcyMiwyMzgsMzMzLDMzMywzODksNTg0LDI3OCwzMzMsMjc4LDI3OCw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsMzMzLDMzMyw1ODQsNTg0LDU4NCw2MTEsOTc1LDcyMiw3MjIsNzIyLDcyMiw2NjcsNjExLDc3OCw3MjIsMjc4LDU1Niw3MjIsNjExLDgzMyw3MjIsNzc4LDY2Nyw3NzgsNzIyLDY2Nyw2MTEsNzIyLDY2Nyw5NDQsNjY3LDY2Nyw2MTEsMzMzLDI3OCwzMzMsNTg0LDU1NiwzMzMsNTU2LDYxMSw1NTYsNjExLDU1NiwzMzMsNjExLDYxMSwyNzgsMjc4LDU1NiwyNzgsODg5LDYxMSw2MTEsNjExLDYxMSwzODksNTU2LDMzMyw2MTEsNTU2LDc3OCw1NTYsNTU2LDUwMCwzODksMjgwLDM4OSw1ODQsMzMzLDU1Niw1NTYsNTU2LDU1NiwyODAsNTU2LDMzMyw3MzcsMzcwLDU1Niw1ODQsNzM3LDU1Miw0MDAsNTQ5LDMzMywzMzMsMzMzLDU3Niw1NTYsMjc4LDMzMywzMzMsMzY1LDU1Niw4MzQsODM0LDgzNCw2MTEsNzIyLDcyMiw3MjIsNzIyLDcyMiw3MjIsMWUzLDcyMiw2NjcsNjY3LDY2Nyw2NjcsMjc4LDI3OCwyNzgsMjc4LDcyMiw3MjIsNzc4LDc3OCw3NzgsNzc4LDc3OCw1ODQsNzc4LDcyMiw3MjIsNzIyLDcyMiw2NjcsNjY3LDYxMSw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw4ODksNTU2LDU1Niw1NTYsNTU2LDU1NiwyNzgsMjc4LDI3OCwyNzgsNjExLDYxMSw2MTEsNjExLDYxMSw2MTEsNjExLDU0OSw2MTEsNjExLDYxMSw2MTEsNjExLDU1Niw2MTEsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDcxOSw3MjIsNjExLDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw3NzgsNjExLDc3OCw2MTEsNzc4LDYxMSw3NzgsNjExLDcyMiw2MTEsNzIyLDYxMSwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsNzg1LDU1Niw1NTYsMjc4LDcyMiw1NTYsNTU2LDYxMSwyNzgsNjExLDI3OCw2MTEsMzg1LDYxMSw0NzksNjExLDI3OCw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw3MDgsNzIzLDYxMSw3NzgsNjExLDc3OCw2MTEsNzc4LDYxMSwxZTMsOTQ0LDcyMiwzODksNzIyLDM4OSw3MjIsMzg5LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjExLDMzMyw2MTEsNDc5LDYxMSwzMzMsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsOTQ0LDc3OCw2NjcsNTU2LDY2Nyw2MTEsNTAwLDYxMSw1MDAsNjExLDUwMCwyNzgsNTU2LDcyMiw1NTYsMWUzLDg4OSw3NzgsNjExLDY2Nyw1NTYsNjExLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsNDY1LDcyMiwzMzMsODUzLDkwNiw0NzQsODI1LDkyNyw4MzgsMjc4LDcyMiw3MjIsNjAxLDcxOSw2NjcsNjExLDcyMiw3NzgsMjc4LDcyMiw2NjcsODMzLDcyMiw2NDQsNzc4LDcyMiw2NjcsNjAwLDYxMSw2NjcsODIxLDY2Nyw4MDksODAyLDI3OCw2NjcsNjE1LDQ1MSw2MTEsMjc4LDU4Miw2MTUsNjEwLDU1Niw2MDYsNDc1LDQ2MCw2MTEsNTQxLDI3OCw1NTgsNTU2LDYxMiw1NTYsNDQ1LDYxMSw3NjYsNjE5LDUyMCw2ODQsNDQ2LDU4Miw3MTUsNTc2LDc1Myw4NDUsMjc4LDU4Miw2MTEsNTgyLDg0NSw2NjcsNjY5LDg4NSw1NjcsNzExLDY2NywyNzgsMjc2LDU1NiwxMDk0LDEwNjIsODc1LDYxMCw3MjIsNjIyLDcxOSw3MjIsNzE5LDcyMiw1NjcsNzEyLDY2Nyw5MDQsNjI2LDcxOSw3MTksNjEwLDcwMiw4MzMsNzIyLDc3OCw3MTksNjY3LDcyMiw2MTEsNjIyLDg1NCw2NjcsNzMwLDcwMywxMDA1LDEwMTksODcwLDk3OSw3MTksNzExLDEwMzEsNzE5LDU1Niw2MTgsNjE1LDQxNyw2MzUsNTU2LDcwOSw0OTcsNjE1LDYxNSw1MDAsNjM1LDc0MCw2MDQsNjExLDYwNCw2MTEsNTU2LDQ5MCw1NTYsODc1LDU1Niw2MTUsNTgxLDgzMyw4NDQsNzI5LDg1NCw2MTUsNTUyLDg1NCw1ODMsNTU2LDU1Niw2MTEsNDE3LDU1Miw1NTYsMjc4LDI4MSwyNzgsOTY5LDkwNiw2MTEsNTAwLDYxNSw1NTYsNjA0LDc3OCw2MTEsNDg3LDQ0Nyw5NDQsNzc4LDk0NCw3NzgsOTQ0LDc3OCw2NjcsNTU2LDMzMywzMzMsNTU2LDFlMywxZTMsNTUyLDI3OCwyNzgsMjc4LDI3OCw1MDAsNTAwLDUwMCw1NTYsNTU2LDM1MCwxZTMsMWUzLDI0MCw0NzksMzMzLDMzMyw2MDQsMzMzLDE2NywzOTYsNTU2LDU1NiwxMDk0LDU1Niw4ODUsNDg5LDExMTUsMWUzLDc2OCw2MDAsODM0LDgzNCw4MzQsODM0LDFlMyw1MDAsMWUzLDUwMCwxZTMsNTAwLDUwMCw0OTQsNjEyLDgyMyw3MTMsNTg0LDU0OSw3MTMsOTc5LDcyMiwyNzQsNTQ5LDU0OSw1ODMsNTQ5LDU0OSw2MDQsNTg0LDYwNCw2MDQsNzA4LDYyNSw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MjksNjA0LDYwNCwzNTQsMzU0LDFlMyw5OTAsOTkwLDk5MCw5OTAsNDk0LDYwNCw2MDQsNjA0LDYwNCwzNTQsMTAyMSwxMDUyLDkxNyw3NTAsNzUwLDUzMSw2NTYsNTk0LDUxMCw1MDAsNzUwLDc1MCw2MTEsNjExLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMjIyLDIyMiwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzXSxLYT1bLTEsLTEsLTEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsOTYsOTcsOTgsOTksMTAwLDEwMSwxMDIsMTAzLDEwNCwxMDUsMTA2LDEwNywxMDgsMTA5LDExMCwxMTEsMTEyLDExMywxMTQsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMjMsMTI0LDEyNSwxMjYsMTYxLDE2MiwxNjMsMTY0LDE2NSwxNjYsMTY3LDE2OCwxNjksMTcwLDE3MSwxNzIsMTc0LDE3NSwxNzYsMTc3LDE3OCwxNzksMTgwLDE4MSwxODIsMTgzLDE4NCwxODUsMTg2LDE4NywxODgsMTg5LDE5MCwxOTEsMTkyLDE5MywxOTQsMTk1LDE5NiwxOTcsMTk4LDE5OSwyMDAsMjAxLDIwMiwyMDMsMjA0LDIwNSwyMDYsMjA3LDIwOCwyMDksMjEwLDIxMSwyMTIsMjEzLDIxNCwyMTUsMjE2LDIxNywyMTgsMjE5LDIyMCwyMjEsMjIyLDIyMywyMjQsMjI1LDIyNiwyMjcsMjI4LDIyOSwyMzAsMjMxLDIzMiwyMzMsMjM0LDIzNSwyMzYsMjM3LDIzOCwyMzksMjQwLDI0MSwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5LDI1MCwyNTEsMjUyLDI1MywyNTQsMjU1LDI1NiwyNTcsMjU4LDI1OSwyNjAsMjYxLDI2MiwyNjMsMjY0LDI2NSwyNjYsMjY3LDI2OCwyNjksMjcwLDI3MSwyNzIsMjczLDI3NCwyNzUsMjc2LDI3NywyNzgsMjc5LDI4MCwyODEsMjgyLDI4MywyODQsMjg1LDI4NiwyODcsMjg4LDI4OSwyOTAsMjkxLDI5MiwyOTMsMjk0LDI5NSwyOTYsMjk3LDI5OCwyOTksMzAwLDMwMSwzMDIsMzAzLDMwNCwzMDUsMzA2LDMwNywzMDgsMzA5LDMxMCwzMTEsMzEyLDMxMywzMTQsMzE1LDMxNiwzMTcsMzE4LDMxOSwzMjAsMzIxLDMyMiwzMjMsMzI0LDMyNSwzMjYsMzI3LDMyOCwzMjksMzMwLDMzMSwzMzIsMzMzLDMzNCwzMzUsMzM2LDMzNywzMzgsMzM5LDM0MCwzNDEsMzQyLDM0MywzNDQsMzQ1LDM0NiwzNDcsMzQ4LDM0OSwzNTAsMzUxLDM1MiwzNTMsMzU0LDM1NSwzNTYsMzU3LDM1OCwzNTksMzYwLDM2MSwzNjIsMzYzLDM2NCwzNjUsMzY2LDM2NywzNjgsMzY5LDM3MCwzNzEsMzcyLDM3MywzNzQsMzc1LDM3NiwzNzcsMzc4LDM3OSwzODAsMzgxLDM4MiwzODMsNDAyLDUwNiw1MDcsNTA4LDUwOSw1MTAsNTExLDUzNiw1MzcsNTM4LDUzOSw3MTAsNzExLDcxMyw3MjgsNzI5LDczMCw3MzEsNzMyLDczMyw5MDAsOTAxLDkwMiw5MDMsOTA0LDkwNSw5MDYsOTA4LDkxMCw5MTEsOTEyLDkxMyw5MTQsOTE1LDkxNiw5MTcsOTE4LDkxOSw5MjAsOTIxLDkyMiw5MjMsOTI0LDkyNSw5MjYsOTI3LDkyOCw5MjksOTMxLDkzMiw5MzMsOTM0LDkzNSw5MzYsOTM3LDkzOCw5MzksOTQwLDk0MSw5NDIsOTQzLDk0NCw5NDUsOTQ2LDk0Nyw5NDgsOTQ5LDk1MCw5NTEsOTUyLDk1Myw5NTQsOTU1LDk1Niw5NTcsOTU4LDk1OSw5NjAsOTYxLDk2Miw5NjMsOTY0LDk2NSw5NjYsOTY3LDk2OCw5NjksOTcwLDk3MSw5NzIsOTczLDk3NCwxMDI0LDEwMjUsMTAyNiwxMDI3LDEwMjgsMTAyOSwxMDMwLDEwMzEsMTAzMiwxMDMzLDEwMzQsMTAzNSwxMDM2LDEwMzcsMTAzOCwxMDM5LDEwNDAsMTA0MSwxMDQyLDEwNDMsMTA0NCwxMDQ1LDEwNDYsMTA0NywxMDQ4LDEwNDksMTA1MCwxMDUxLDEwNTIsMTA1MywxMDU0LDEwNTUsMTA1NiwxMDU3LDEwNTgsMTA1OSwxMDYwLDEwNjEsMTA2MiwxMDYzLDEwNjQsMTA2NSwxMDY2LDEwNjcsMTA2OCwxMDY5LDEwNzAsMTA3MSwxMDcyLDEwNzMsMTA3NCwxMDc1LDEwNzYsMTA3NywxMDc4LDEwNzksMTA4MCwxMDgxLDEwODIsMTA4MywxMDg0LDEwODUsMTA4NiwxMDg3LDEwODgsMTA4OSwxMDkwLDEwOTEsMTA5MiwxMDkzLDEwOTQsMTA5NSwxMDk2LDEwOTcsMTA5OCwxMDk5LDExMDAsMTEwMSwxMTAyLDExMDMsMTEwNCwxMTA1LDExMDYsMTEwNywxMTA4LDExMDksMTExMCwxMTExLDExMTIsMTExMywxMTE0LDExMTUsMTExNiwxMTE3LDExMTgsMTExOSwxMTM4LDExMzksMTE2OCwxMTY5LDc4MDgsNzgwOSw3ODEwLDc4MTEsNzgxMiw3ODEzLDc5MjIsNzkyMyw4MjA4LDgyMDksODIxMSw4MjEyLDgyMTMsODIxNSw4MjE2LDgyMTcsODIxOCw4MjE5LDgyMjAsODIyMSw4MjIyLDgyMjQsODIyNSw4MjI2LDgyMzAsODI0MCw4MjQyLDgyNDMsODI0OSw4MjUwLDgyNTIsODI1NCw4MjYwLDgzMTksODM1NSw4MzU2LDgzNTksODM2NCw4NDUzLDg0NjcsODQ3MCw4NDgyLDg0ODYsODQ5NCw4NTM5LDg1NDAsODU0MSw4NTQyLDg1OTIsODU5Myw4NTk0LDg1OTUsODU5Niw4NTk3LDg2MTYsODcwNiw4NzEwLDg3MTksODcyMSw4NzIyLDg3MzAsODczNCw4NzM1LDg3NDUsODc0Nyw4Nzc2LDg4MDAsODgwMSw4ODA0LDg4MDUsODk2Miw4OTc2LDg5OTIsODk5Myw5NDcyLDk0NzQsOTQ4NCw5NDg4LDk0OTIsOTQ5Niw5NTAwLDk1MDgsOTUxNiw5NTI0LDk1MzIsOTU1Miw5NTUzLDk1NTQsOTU1NSw5NTU2LDk1NTcsOTU1OCw5NTU5LDk1NjAsOTU2MSw5NTYyLDk1NjMsOTU2NCw5NTY1LDk1NjYsOTU2Nyw5NTY4LDk1NjksOTU3MCw5NTcxLDk1NzIsOTU3Myw5NTc0LDk1NzUsOTU3Niw5NTc3LDk1NzgsOTU3OSw5NTgwLDk2MDAsOTYwNCw5NjA4LDk2MTIsOTYxNiw5NjE3LDk2MTgsOTYxOSw5NjMyLDk2MzMsOTY0Miw5NjQzLDk2NDQsOTY1MCw5NjU4LDk2NjAsOTY2OCw5Njc0LDk2NzUsOTY3OSw5Njg4LDk2ODksOTcwMiw5Nzg2LDk3ODcsOTc4OCw5NzkyLDk3OTQsOTgyNCw5ODI3LDk4MjksOTgzMCw5ODM0LDk4MzUsOTgzNiw2MTQ0MSw2MTQ0Miw2MTQ0NSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMSwtMV0sVGE9WzM2NSwwLDMzMywyNzgsMzMzLDQ3NCw1NTYsNTU2LDg4OSw3MjIsMjM4LDMzMywzMzMsMzg5LDU4NCwyNzgsMzMzLDI3OCwyNzgsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDMzMywzMzMsNTg0LDU4NCw1ODQsNjExLDk3NSw3MjIsNzIyLDcyMiw3MjIsNjY3LDYxMSw3NzgsNzIyLDI3OCw1NTYsNzIyLDYxMSw4MzMsNzIyLDc3OCw2NjcsNzc4LDcyMiw2NjcsNjExLDcyMiw2NjcsOTQ0LDY2Nyw2NjcsNjExLDMzMywyNzgsMzMzLDU4NCw1NTYsMzMzLDU1Niw2MTEsNTU2LDYxMSw1NTYsMzMzLDYxMSw2MTEsMjc4LDI3OCw1NTYsMjc4LDg4OSw2MTEsNjExLDYxMSw2MTEsMzg5LDU1NiwzMzMsNjExLDU1Niw3NzgsNTU2LDU1Niw1MDAsMzg5LDI4MCwzODksNTg0LDMzMyw1NTYsNTU2LDU1Niw1NTYsMjgwLDU1NiwzMzMsNzM3LDM3MCw1NTYsNTg0LDczNyw1NTIsNDAwLDU0OSwzMzMsMzMzLDMzMyw1NzYsNTU2LDI3OCwzMzMsMzMzLDM2NSw1NTYsODM0LDgzNCw4MzQsNjExLDcyMiw3MjIsNzIyLDcyMiw3MjIsNzIyLDFlMyw3MjIsNjY3LDY2Nyw2NjcsNjY3LDI3OCwyNzgsMjc4LDI3OCw3MjIsNzIyLDc3OCw3NzgsNzc4LDc3OCw3NzgsNTg0LDc3OCw3MjIsNzIyLDcyMiw3MjIsNjY3LDY2Nyw2MTEsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsODg5LDU1Niw1NTYsNTU2LDU1Niw1NTYsMjc4LDI3OCwyNzgsMjc4LDYxMSw2MTEsNjExLDYxMSw2MTEsNjExLDYxMSw1NDksNjExLDYxMSw2MTEsNjExLDYxMSw1NTYsNjExLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw3NDAsNzIyLDYxMSw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNzc4LDYxMSw3NzgsNjExLDc3OCw2MTEsNzc4LDYxMSw3MjIsNjExLDcyMiw2MTEsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDc4Miw1NTYsNTU2LDI3OCw3MjIsNTU2LDU1Niw2MTEsMjc4LDYxMSwyNzgsNjExLDM5Niw2MTEsNDc5LDYxMSwyNzgsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsNzA4LDcyMyw2MTEsNzc4LDYxMSw3NzgsNjExLDc3OCw2MTEsMWUzLDk0NCw3MjIsMzg5LDcyMiwzODksNzIyLDM4OSw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDYxMSwzMzMsNjExLDQ3OSw2MTEsMzMzLDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDcyMiw2MTEsNzIyLDYxMSw3MjIsNjExLDk0NCw3NzgsNjY3LDU1Niw2NjcsNjExLDUwMCw2MTEsNTAwLDYxMSw1MDAsMjc4LDU1Niw3MjIsNTU2LDFlMyw4ODksNzc4LDYxMSw2NjcsNTU2LDYxMSwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMyw3MjIsMzMzLDg1NCw5MDYsNDczLDg0NCw5MzAsODQ3LDI3OCw3MjIsNzIyLDYxMCw2NzEsNjY3LDYxMSw3MjIsNzc4LDI3OCw3MjIsNjY3LDgzMyw3MjIsNjU3LDc3OCw3MTgsNjY3LDU5MCw2MTEsNjY3LDgyMiw2NjcsODI5LDc4MSwyNzgsNjY3LDYyMCw0NzksNjExLDI3OCw1OTEsNjIwLDYyMSw1NTYsNjEwLDQ3OSw0OTIsNjExLDU1OCwyNzgsNTY2LDU1Niw2MDMsNTU2LDQ1MCw2MTEsNzEyLDYwNSw1MzIsNjY0LDQwOSw1OTEsNzA0LDU3OCw3NzMsODM0LDI3OCw1OTEsNjExLDU5MSw4MzQsNjY3LDY2Nyw4ODYsNjE0LDcxOSw2NjcsMjc4LDI3OCw1NTYsMTA5NCwxMDQyLDg1NCw2MjIsNzE5LDY3Nyw3MTksNzIyLDcwOCw3MjIsNjE0LDcyMiw2NjcsOTI3LDY0Myw3MTksNzE5LDYxNSw2ODcsODMzLDcyMiw3NzgsNzE5LDY2Nyw3MjIsNjExLDY3Nyw3ODEsNjY3LDcyOSw3MDgsOTc5LDk4OSw4NTQsMWUzLDcwOCw3MTksMTA0Miw3MjksNTU2LDYxOSw2MDQsNTM0LDYxOCw1NTYsNzM2LDUxMCw2MTEsNjExLDUwNyw2MjIsNzQwLDYwNCw2MTEsNjExLDYxMSw1NTYsODg5LDU1Niw4ODUsNTU2LDY0Niw1ODMsODg5LDkzNSw3MDcsODU0LDU5NCw1NTIsODY1LDU4OSw1NTYsNTU2LDYxMSw0NjksNTYzLDU1NiwyNzgsMjc4LDI3OCw5NjksOTA2LDYxMSw1MDcsNjE5LDU1Niw2MTEsNzc4LDYxMSw1NzUsNDY3LDk0NCw3NzgsOTQ0LDc3OCw5NDQsNzc4LDY2Nyw1NTYsMzMzLDMzMyw1NTYsMWUzLDFlMyw1NTIsMjc4LDI3OCwyNzgsMjc4LDUwMCw1MDAsNTAwLDU1Niw1NTYsMzUwLDFlMywxZTMsMjQwLDQ3OSwzMzMsMzMzLDYwNCwzMzMsMTY3LDM5Niw1NTYsNTU2LDExMDQsNTU2LDg4NSw1MTYsMTE0NiwxZTMsNzY4LDYwMCw4MzQsODM0LDgzNCw4MzQsOTk5LDUwMCwxZTMsNTAwLDFlMyw1MDAsNTAwLDQ5NCw2MTIsODIzLDcxMyw1ODQsNTQ5LDcxMyw5NzksNzIyLDI3NCw1NDksNTQ5LDU4Myw1NDksNTQ5LDYwNCw1ODQsNjA0LDYwNCw3MDgsNjI1LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcyOSw2MDQsNjA0LDM1NCwzNTQsMWUzLDk5MCw5OTAsOTkwLDk5MCw0OTQsNjA0LDYwNCw2MDQsNjA0LDM1NCwxMDIxLDEwNTIsOTE3LDc1MCw3NTAsNTMxLDY1Niw1OTQsNTEwLDUwMCw3NTAsNzUwLDYxMSw2MTEsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywyMjIsMjIyLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzNdLHFhPVstMSwtMSwtMSwzMiwzMywzNCwzNSwzNiwzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5MSw5Miw5Myw5NCw5NSw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDExMSwxMTIsMTEzLDExNCwxMTUsMTE2LDExNywxMTgsMTE5LDEyMCwxMjEsMTIyLDEyMywxMjQsMTI1LDEyNiwxNjEsMTYyLDE2MywxNjQsMTY1LDE2NiwxNjcsMTY4LDE2OSwxNzAsMTcxLDE3MiwxNzQsMTc1LDE3NiwxNzcsMTc4LDE3OSwxODAsMTgxLDE4MiwxODMsMTg0LDE4NSwxODYsMTg3LDE4OCwxODksMTkwLDE5MSwxOTIsMTkzLDE5NCwxOTUsMTk2LDE5NywxOTgsMTk5LDIwMCwyMDEsMjAyLDIwMywyMDQsMjA1LDIwNiwyMDcsMjA4LDIwOSwyMTAsMjExLDIxMiwyMTMsMjE0LDIxNSwyMTYsMjE3LDIxOCwyMTksMjIwLDIyMSwyMjIsMjIzLDIyNCwyMjUsMjI2LDIyNywyMjgsMjI5LDIzMCwyMzEsMjMyLDIzMywyMzQsMjM1LDIzNiwyMzcsMjM4LDIzOSwyNDAsMjQxLDI0MiwyNDMsMjQ0LDI0NSwyNDYsMjQ3LDI0OCwyNDksMjUwLDI1MSwyNTIsMjUzLDI1NCwyNTUsMjU2LDI1NywyNTgsMjU5LDI2MCwyNjEsMjYyLDI2MywyNjQsMjY1LDI2NiwyNjcsMjY4LDI2OSwyNzAsMjcxLDI3MiwyNzMsMjc0LDI3NSwyNzYsMjc3LDI3OCwyNzksMjgwLDI4MSwyODIsMjgzLDI4NCwyODUsMjg2LDI4NywyODgsMjg5LDI5MCwyOTEsMjkyLDI5MywyOTQsMjk1LDI5NiwyOTcsMjk4LDI5OSwzMDAsMzAxLDMwMiwzMDMsMzA0LDMwNSwzMDYsMzA3LDMwOCwzMDksMzEwLDMxMSwzMTIsMzEzLDMxNCwzMTUsMzE2LDMxNywzMTgsMzE5LDMyMCwzMjEsMzIyLDMyMywzMjQsMzI1LDMyNiwzMjcsMzI4LDMyOSwzMzAsMzMxLDMzMiwzMzMsMzM0LDMzNSwzMzYsMzM3LDMzOCwzMzksMzQwLDM0MSwzNDIsMzQzLDM0NCwzNDUsMzQ2LDM0NywzNDgsMzQ5LDM1MCwzNTEsMzUyLDM1MywzNTQsMzU1LDM1NiwzNTcsMzU4LDM1OSwzNjAsMzYxLDM2MiwzNjMsMzY0LDM2NSwzNjYsMzY3LDM2OCwzNjksMzcwLDM3MSwzNzIsMzczLDM3NCwzNzUsMzc2LDM3NywzNzgsMzc5LDM4MCwzODEsMzgyLDM4Myw0MDIsNTA2LDUwNyw1MDgsNTA5LDUxMCw1MTEsNTM2LDUzNyw1MzgsNTM5LDcxMCw3MTEsNzEzLDcyOCw3MjksNzMwLDczMSw3MzIsNzMzLDkwMCw5MDEsOTAyLDkwMyw5MDQsOTA1LDkwNiw5MDgsOTEwLDkxMSw5MTIsOTEzLDkxNCw5MTUsOTE2LDkxNyw5MTgsOTE5LDkyMCw5MjEsOTIyLDkyMyw5MjQsOTI1LDkyNiw5MjcsOTI4LDkyOSw5MzEsOTMyLDkzMyw5MzQsOTM1LDkzNiw5MzcsOTM4LDkzOSw5NDAsOTQxLDk0Miw5NDMsOTQ0LDk0NSw5NDYsOTQ3LDk0OCw5NDksOTUwLDk1MSw5NTIsOTUzLDk1NCw5NTUsOTU2LDk1Nyw5NTgsOTU5LDk2MCw5NjEsOTYyLDk2Myw5NjQsOTY1LDk2Niw5NjcsOTY4LDk2OSw5NzAsOTcxLDk3Miw5NzMsOTc0LDEwMjQsMTAyNSwxMDI2LDEwMjcsMTAyOCwxMDI5LDEwMzAsMTAzMSwxMDMyLDEwMzMsMTAzNCwxMDM1LDEwMzYsMTAzNywxMDM4LDEwMzksMTA0MCwxMDQxLDEwNDIsMTA0MywxMDQ0LDEwNDUsMTA0NiwxMDQ3LDEwNDgsMTA0OSwxMDUwLDEwNTEsMTA1MiwxMDUzLDEwNTQsMTA1NSwxMDU2LDEwNTcsMTA1OCwxMDU5LDEwNjAsMTA2MSwxMDYyLDEwNjMsMTA2NCwxMDY1LDEwNjYsMTA2NywxMDY4LDEwNjksMTA3MCwxMDcxLDEwNzIsMTA3MywxMDc0LDEwNzUsMTA3NiwxMDc3LDEwNzgsMTA3OSwxMDgwLDEwODEsMTA4MiwxMDgzLDEwODQsMTA4NSwxMDg2LDEwODcsMTA4OCwxMDg5LDEwOTAsMTA5MSwxMDkyLDEwOTMsMTA5NCwxMDk1LDEwOTYsMTA5NywxMDk4LDEwOTksMTEwMCwxMTAxLDExMDIsMTEwMywxMTA0LDExMDUsMTEwNiwxMTA3LDExMDgsMTEwOSwxMTEwLDExMTEsMTExMiwxMTEzLDExMTQsMTExNSwxMTE2LDExMTcsMTExOCwxMTE5LDExMzgsMTEzOSwxMTY4LDExNjksNzgwOCw3ODA5LDc4MTAsNzgxMSw3ODEyLDc4MTMsNzkyMiw3OTIzLDgyMDgsODIwOSw4MjExLDgyMTIsODIxMyw4MjE1LDgyMTYsODIxNyw4MjE4LDgyMTksODIyMCw4MjIxLDgyMjIsODIyNCw4MjI1LDgyMjYsODIzMCw4MjQwLDgyNDIsODI0Myw4MjQ5LDgyNTAsODI1Miw4MjU0LDgyNjAsODMxOSw4MzU1LDgzNTYsODM1OSw4MzY0LDg0NTMsODQ2Nyw4NDcwLDg0ODIsODQ4Niw4NDk0LDg1MzksODU0MCw4NTQxLDg1NDIsODU5Miw4NTkzLDg1OTQsODU5NSw4NTk2LDg1OTcsODYxNiw4NzA2LDg3MTAsODcxOSw4NzIxLDg3MjIsODczMCw4NzM0LDg3MzUsODc0NSw4NzQ3LDg3NzYsODgwMCw4ODAxLDg4MDQsODgwNSw4OTYyLDg5NzYsODk5Miw4OTkzLDk0NzIsOTQ3NCw5NDg0LDk0ODgsOTQ5Miw5NDk2LDk1MDAsOTUwOCw5NTE2LDk1MjQsOTUzMiw5NTUyLDk1NTMsOTU1NCw5NTU1LDk1NTYsOTU1Nyw5NTU4LDk1NTksOTU2MCw5NTYxLDk1NjIsOTU2Myw5NTY0LDk1NjUsOTU2Niw5NTY3LDk1NjgsOTU2OSw5NTcwLDk1NzEsOTU3Miw5NTczLDk1NzQsOTU3NSw5NTc2LDk1NzcsOTU3OCw5NTc5LDk1ODAsOTYwMCw5NjA0LDk2MDgsOTYxMiw5NjE2LDk2MTcsOTYxOCw5NjE5LDk2MzIsOTYzMyw5NjQyLDk2NDMsOTY0NCw5NjUwLDk2NTgsOTY2MCw5NjY4LDk2NzQsOTY3NSw5Njc5LDk2ODgsOTY4OSw5NzAyLDk3ODYsOTc4Nyw5Nzg4LDk3OTIsOTc5NCw5ODI0LDk4MjcsOTgyOSw5ODMwLDk4MzQsOTgzNSw5ODM2LDYxNDQxLDYxNDQyLDYxNDQ1LC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xLC0xXSxPYT1bMzY1LDAsMzMzLDI3OCwyNzgsMzU1LDU1Niw1NTYsODg5LDY2NywxOTEsMzMzLDMzMywzODksNTg0LDI3OCwzMzMsMjc4LDI3OCw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsMjc4LDI3OCw1ODQsNTg0LDU4NCw1NTYsMTAxNSw2NjcsNjY3LDcyMiw3MjIsNjY3LDYxMSw3NzgsNzIyLDI3OCw1MDAsNjY3LDU1Niw4MzMsNzIyLDc3OCw2NjcsNzc4LDcyMiw2NjcsNjExLDcyMiw2NjcsOTQ0LDY2Nyw2NjcsNjExLDI3OCwyNzgsMjc4LDQ2OSw1NTYsMzMzLDU1Niw1NTYsNTAwLDU1Niw1NTYsMjc4LDU1Niw1NTYsMjIyLDIyMiw1MDAsMjIyLDgzMyw1NTYsNTU2LDU1Niw1NTYsMzMzLDUwMCwyNzgsNTU2LDUwMCw3MjIsNTAwLDUwMCw1MDAsMzM0LDI2MCwzMzQsNTg0LDMzMyw1NTYsNTU2LDU1Niw1NTYsMjYwLDU1NiwzMzMsNzM3LDM3MCw1NTYsNTg0LDczNyw1NTIsNDAwLDU0OSwzMzMsMzMzLDMzMyw1NzYsNTM3LDI3OCwzMzMsMzMzLDM2NSw1NTYsODM0LDgzNCw4MzQsNjExLDY2Nyw2NjcsNjY3LDY2Nyw2NjcsNjY3LDFlMyw3MjIsNjY3LDY2Nyw2NjcsNjY3LDI3OCwyNzgsMjc4LDI3OCw3MjIsNzIyLDc3OCw3NzgsNzc4LDc3OCw3NzgsNTg0LDc3OCw3MjIsNzIyLDcyMiw3MjIsNjY3LDY2Nyw2MTEsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsODg5LDUwMCw1NTYsNTU2LDU1Niw1NTYsMjc4LDI3OCwyNzgsMjc4LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NDksNjExLDU1Niw1NTYsNTU2LDU1Niw1MDAsNTU2LDUwMCw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw3MjIsNTAwLDcyMiw1MDAsNzIyLDUwMCw3MjIsNTAwLDcyMiw2MjUsNzIyLDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNzc4LDU1Niw3NzgsNTU2LDc3OCw1NTYsNzc4LDU1Niw3MjIsNTU2LDcyMiw1NTYsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjc4LDIyMiwyNzgsMjc4LDczMyw0NDQsNTAwLDIyMiw2NjcsNTAwLDUwMCw1NTYsMjIyLDU1NiwyMjIsNTU2LDI4MSw1NTYsNDAwLDU1NiwyMjIsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNjE1LDcyMyw1NTYsNzc4LDU1Niw3NzgsNTU2LDc3OCw1NTYsMWUzLDk0NCw3MjIsMzMzLDcyMiwzMzMsNzIyLDMzMyw2NjcsNTAwLDY2Nyw1MDAsNjY3LDUwMCw2NjcsNTAwLDYxMSwyNzgsNjExLDM1NCw2MTEsMjc4LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDk0NCw3MjIsNjY3LDUwMCw2NjcsNjExLDUwMCw2MTEsNTAwLDYxMSw1MDAsMjIyLDU1Niw2NjcsNTU2LDFlMyw4ODksNzc4LDYxMSw2NjcsNTAwLDYxMSwyNzgsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMyw2NjcsMjc4LDc4OSw4NDYsMzg5LDc5NCw4NjUsNzc1LDIyMiw2NjcsNjY3LDU3MCw2NzEsNjY3LDYxMSw3MjIsNzc4LDI3OCw2NjcsNjY3LDgzMyw3MjIsNjQ4LDc3OCw3MjUsNjY3LDYwMCw2MTEsNjY3LDgzNyw2NjcsODMxLDc2MSwyNzgsNjY3LDU3MCw0MzksNTU1LDIyMiw1NTAsNTcwLDU3MSw1MDAsNTU2LDQzOSw0NjMsNTU1LDU0MiwyMjIsNTAwLDQ5Miw1NDgsNTAwLDQ0Nyw1NTYsNjcwLDU3Myw0ODYsNjAzLDM3NCw1NTAsNjUyLDU0Niw3MjgsNzc5LDIyMiw1NTAsNTU2LDU1MCw3NzksNjY3LDY2Nyw4NDMsNTQ0LDcwOCw2NjcsMjc4LDI3OCw1MDAsMTA2Niw5ODIsODQ0LDU4OSw3MTUsNjM5LDcyNCw2NjcsNjUxLDY2Nyw1NDQsNzA0LDY2Nyw5MTcsNjE0LDcxNSw3MTUsNTg5LDY4Niw4MzMsNzIyLDc3OCw3MjUsNjY3LDcyMiw2MTEsNjM5LDc5NSw2NjcsNzI3LDY3Myw5MjAsOTIzLDgwNSw4ODYsNjUxLDY5NCwxMDIyLDY4Miw1NTYsNTYyLDUyMiw0OTMsNTUzLDU1Niw2ODgsNDY1LDU1Niw1NTYsNDcyLDU2NCw2ODYsNTUwLDU1Niw1NTYsNTU2LDUwMCw4MzMsNTAwLDgzNSw1MDAsNTcyLDUxOCw4MzAsODUxLDYyMSw3MzYsNTI2LDQ5Miw3NTIsNTM0LDU1Niw1NTYsNTU2LDM3OCw0OTYsNTAwLDIyMiwyMjIsMjIyLDkxMCw4MjgsNTU2LDQ3Miw1NjUsNTAwLDU1Niw3NzgsNTU2LDQ5MiwzMzksOTQ0LDcyMiw5NDQsNzIyLDk0NCw3MjIsNjY3LDUwMCwzMzMsMzMzLDU1NiwxZTMsMWUzLDU1MiwyMjIsMjIyLDIyMiwyMjIsMzMzLDMzMywzMzMsNTU2LDU1NiwzNTAsMWUzLDFlMywxODgsMzU0LDMzMywzMzMsNTAwLDMzMywxNjcsMzY1LDU1Niw1NTYsMTA5NCw1NTYsODg1LDMyMywxMDgzLDFlMyw3NjgsNjAwLDgzNCw4MzQsODM0LDgzNCwxZTMsNTAwLDk5OCw1MDAsMWUzLDUwMCw1MDAsNDk0LDYxMiw4MjMsNzEzLDU4NCw1NDksNzEzLDk3OSw3MTksMjc0LDU0OSw1NDksNTg0LDU0OSw1NDksNjA0LDU4NCw2MDQsNjA0LDcwOCw2MjUsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzI5LDYwNCw2MDQsMzU0LDM1NCwxZTMsOTkwLDk5MCw5OTAsOTkwLDQ5NCw2MDQsNjA0LDYwNCw2MDQsMzU0LDEwMjEsMTA1Miw5MTcsNzUwLDc1MCw1MzEsNjU2LDU5NCw1MTAsNTAwLDc1MCw3NTAsNTAwLDUwMCwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDIyMiwyMjIsMjk0LDI5NCwzMjQsMzI0LDMxNiwzMjgsMzk4LDI4NV0sUGE9Wy0xLC0xLC0xLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMTIzLDEyNCwxMjUsMTI2LDE2MSwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzEsMTcyLDE3NCwxNzUsMTc2LDE3NywxNzgsMTc5LDE4MCwxODEsMTgyLDE4MywxODQsMTg1LDE4NiwxODcsMTg4LDE4OSwxOTAsMTkxLDE5MiwxOTMsMTk0LDE5NSwxOTYsMTk3LDE5OCwxOTksMjAwLDIwMSwyMDIsMjAzLDIwNCwyMDUsMjA2LDIwNywyMDgsMjA5LDIxMCwyMTEsMjEyLDIxMywyMTQsMjE1LDIxNiwyMTcsMjE4LDIxOSwyMjAsMjIxLDIyMiwyMjMsMjI0LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyMzUsMjM2LDIzNywyMzgsMjM5LDI0MCwyNDEsMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OSwyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OCwyNTksMjYwLDI2MSwyNjIsMjYzLDI2NCwyNjUsMjY2LDI2NywyNjgsMjY5LDI3MCwyNzEsMjcyLDI3MywyNzQsMjc1LDI3NiwyNzcsMjc4LDI3OSwyODAsMjgxLDI4MiwyODMsMjg0LDI4NSwyODYsMjg3LDI4OCwyODksMjkwLDI5MSwyOTIsMjkzLDI5NCwyOTUsMjk2LDI5NywyOTgsMjk5LDMwMCwzMDEsMzAyLDMwMywzMDQsMzA1LDMwNiwzMDcsMzA4LDMwOSwzMTAsMzExLDMxMiwzMTMsMzE0LDMxNSwzMTYsMzE3LDMxOCwzMTksMzIwLDMyMSwzMjIsMzIzLDMyNCwzMjUsMzI2LDMyNywzMjgsMzI5LDMzMCwzMzEsMzMyLDMzMywzMzQsMzM1LDMzNiwzMzcsMzM4LDMzOSwzNDAsMzQxLDM0MiwzNDMsMzQ0LDM0NSwzNDYsMzQ3LDM0OCwzNDksMzUwLDM1MSwzNTIsMzUzLDM1NCwzNTUsMzU2LDM1NywzNTgsMzU5LDM2MCwzNjEsMzYyLDM2MywzNjQsMzY1LDM2NiwzNjcsMzY4LDM2OSwzNzAsMzcxLDM3MiwzNzMsMzc0LDM3NSwzNzYsMzc3LDM3OCwzNzksMzgwLDM4MSwzODIsMzgzLDQwMiw1MDYsNTA3LDUwOCw1MDksNTEwLDUxMSw1MzYsNTM3LDUzOCw1MzksNzEwLDcxMSw3MTMsNzI4LDcyOSw3MzAsNzMxLDczMiw3MzMsOTAwLDkwMSw5MDIsOTAzLDkwNCw5MDUsOTA2LDkwOCw5MTAsOTExLDkxMiw5MTMsOTE0LDkxNSw5MTYsOTE3LDkxOCw5MTksOTIwLDkyMSw5MjIsOTIzLDkyNCw5MjUsOTI2LDkyNyw5MjgsOTI5LDkzMSw5MzIsOTMzLDkzNCw5MzUsOTM2LDkzNyw5MzgsOTM5LDk0MCw5NDEsOTQyLDk0Myw5NDQsOTQ1LDk0Niw5NDcsOTQ4LDk0OSw5NTAsOTUxLDk1Miw5NTMsOTU0LDk1NSw5NTYsOTU3LDk1OCw5NTksOTYwLDk2MSw5NjIsOTYzLDk2NCw5NjUsOTY2LDk2Nyw5NjgsOTY5LDk3MCw5NzEsOTcyLDk3Myw5NzQsMTAyNCwxMDI1LDEwMjYsMTAyNywxMDI4LDEwMjksMTAzMCwxMDMxLDEwMzIsMTAzMywxMDM0LDEwMzUsMTAzNiwxMDM3LDEwMzgsMTAzOSwxMDQwLDEwNDEsMTA0MiwxMDQzLDEwNDQsMTA0NSwxMDQ2LDEwNDcsMTA0OCwxMDQ5LDEwNTAsMTA1MSwxMDUyLDEwNTMsMTA1NCwxMDU1LDEwNTYsMTA1NywxMDU4LDEwNTksMTA2MCwxMDYxLDEwNjIsMTA2MywxMDY0LDEwNjUsMTA2NiwxMDY3LDEwNjgsMTA2OSwxMDcwLDEwNzEsMTA3MiwxMDczLDEwNzQsMTA3NSwxMDc2LDEwNzcsMTA3OCwxMDc5LDEwODAsMTA4MSwxMDgyLDEwODMsMTA4NCwxMDg1LDEwODYsMTA4NywxMDg4LDEwODksMTA5MCwxMDkxLDEwOTIsMTA5MywxMDk0LDEwOTUsMTA5NiwxMDk3LDEwOTgsMTA5OSwxMTAwLDExMDEsMTEwMiwxMTAzLDExMDQsMTEwNSwxMTA2LDExMDcsMTEwOCwxMTA5LDExMTAsMTExMSwxMTEyLDExMTMsMTExNCwxMTE1LDExMTYsMTExNywxMTE4LDExMTksMTEzOCwxMTM5LDExNjgsMTE2OSw3ODA4LDc4MDksNzgxMCw3ODExLDc4MTIsNzgxMyw3OTIyLDc5MjMsODIwOCw4MjA5LDgyMTEsODIxMiw4MjEzLDgyMTUsODIxNiw4MjE3LDgyMTgsODIxOSw4MjIwLDgyMjEsODIyMiw4MjI0LDgyMjUsODIyNiw4MjMwLDgyNDAsODI0Miw4MjQzLDgyNDksODI1MCw4MjUyLDgyNTQsODI2MCw4MzE5LDgzNTUsODM1Niw4MzU5LDgzNjQsODQ1Myw4NDY3LDg0NzAsODQ4Miw4NDg2LDg0OTQsODUzOSw4NTQwLDg1NDEsODU0Miw4NTkyLDg1OTMsODU5NCw4NTk1LDg1OTYsODU5Nyw4NjE2LDg3MDYsODcxMCw4NzE5LDg3MjEsODcyMiw4NzMwLDg3MzQsODczNSw4NzQ1LDg3NDcsODc3Niw4ODAwLDg4MDEsODgwNCw4ODA1LDg5NjIsODk3Niw4OTkyLDg5OTMsOTQ3Miw5NDc0LDk0ODQsOTQ4OCw5NDkyLDk0OTYsOTUwMCw5NTA4LDk1MTYsOTUyNCw5NTMyLDk1NTIsOTU1Myw5NTU0LDk1NTUsOTU1Niw5NTU3LDk1NTgsOTU1OSw5NTYwLDk1NjEsOTU2Miw5NTYzLDk1NjQsOTU2NSw5NTY2LDk1NjcsOTU2OCw5NTY5LDk1NzAsOTU3MSw5NTcyLDk1NzMsOTU3NCw5NTc1LDk1NzYsOTU3Nyw5NTc4LDk1NzksOTU4MCw5NjAwLDk2MDQsOTYwOCw5NjEyLDk2MTYsOTYxNyw5NjE4LDk2MTksOTYzMiw5NjMzLDk2NDIsOTY0Myw5NjQ0LDk2NTAsOTY1OCw5NjYwLDk2NjgsOTY3NCw5Njc1LDk2NzksOTY4OCw5Njg5LDk3MDIsOTc4Niw5Nzg3LDk3ODgsOTc5Miw5Nzk0LDk4MjQsOTgyNyw5ODI5LDk4MzAsOTgzNCw5ODM1LDk4MzYsNjE0NDEsNjE0NDIsNjE0NDUsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTFdLFdhPVszNjUsMCwzMzMsMjc4LDI3OCwzNTUsNTU2LDU1Niw4ODksNjY3LDE5MSwzMzMsMzMzLDM4OSw1ODQsMjc4LDMzMywyNzgsMjc4LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1NiwyNzgsMjc4LDU4NCw1ODQsNTg0LDU1NiwxMDE1LDY2Nyw2NjcsNzIyLDcyMiw2NjcsNjExLDc3OCw3MjIsMjc4LDUwMCw2NjcsNTU2LDgzMyw3MjIsNzc4LDY2Nyw3NzgsNzIyLDY2Nyw2MTEsNzIyLDY2Nyw5NDQsNjY3LDY2Nyw2MTEsMjc4LDI3OCwyNzgsNDY5LDU1NiwzMzMsNTU2LDU1Niw1MDAsNTU2LDU1NiwyNzgsNTU2LDU1NiwyMjIsMjIyLDUwMCwyMjIsODMzLDU1Niw1NTYsNTU2LDU1NiwzMzMsNTAwLDI3OCw1NTYsNTAwLDcyMiw1MDAsNTAwLDUwMCwzMzQsMjYwLDMzNCw1ODQsMzMzLDU1Niw1NTYsNTU2LDU1NiwyNjAsNTU2LDMzMyw3MzcsMzcwLDU1Niw1ODQsNzM3LDU1Miw0MDAsNTQ5LDMzMywzMzMsMzMzLDU3Niw1MzcsMjc4LDMzMywzMzMsMzY1LDU1Niw4MzQsODM0LDgzNCw2MTEsNjY3LDY2Nyw2NjcsNjY3LDY2Nyw2NjcsMWUzLDcyMiw2NjcsNjY3LDY2Nyw2NjcsMjc4LDI3OCwyNzgsMjc4LDcyMiw3MjIsNzc4LDc3OCw3NzgsNzc4LDc3OCw1ODQsNzc4LDcyMiw3MjIsNzIyLDcyMiw2NjcsNjY3LDYxMSw1NTYsNTU2LDU1Niw1NTYsNTU2LDU1Niw4ODksNTAwLDU1Niw1NTYsNTU2LDU1NiwyNzgsMjc4LDI3OCwyNzgsNTU2LDU1Niw1NTYsNTU2LDU1Niw1NTYsNTU2LDU0OSw2MTEsNTU2LDU1Niw1NTYsNTU2LDUwMCw1NTYsNTAwLDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDcyMiw1MDAsNzIyLDUwMCw3MjIsNTAwLDcyMiw1MDAsNzIyLDYxNSw3MjIsNTU2LDY2Nyw1NTYsNjY3LDU1Niw2NjcsNTU2LDY2Nyw1NTYsNjY3LDU1Niw3NzgsNTU2LDc3OCw1NTYsNzc4LDU1Niw3NzgsNTU2LDcyMiw1NTYsNzIyLDU1NiwyNzgsMjc4LDI3OCwyNzgsMjc4LDI3OCwyNzgsMjIyLDI3OCwyNzgsNzM1LDQ0NCw1MDAsMjIyLDY2Nyw1MDAsNTAwLDU1NiwyMjIsNTU2LDIyMiw1NTYsMjkyLDU1NiwzMzQsNTU2LDIyMiw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw2MDQsNzIzLDU1Niw3NzgsNTU2LDc3OCw1NTYsNzc4LDU1NiwxZTMsOTQ0LDcyMiwzMzMsNzIyLDMzMyw3MjIsMzMzLDY2Nyw1MDAsNjY3LDUwMCw2NjcsNTAwLDY2Nyw1MDAsNjExLDI3OCw2MTEsMzc1LDYxMSwyNzgsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsNzIyLDU1Niw3MjIsNTU2LDcyMiw1NTYsOTQ0LDcyMiw2NjcsNTAwLDY2Nyw2MTEsNTAwLDYxMSw1MDAsNjExLDUwMCwyMjIsNTU2LDY2Nyw1NTYsMWUzLDg4OSw3NzgsNjExLDY2Nyw1MDAsNjExLDI3OCwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDY2NywyNzgsNzg0LDgzOCwzODQsNzc0LDg1NSw3NTIsMjIyLDY2Nyw2NjcsNTUxLDY2OCw2NjcsNjExLDcyMiw3NzgsMjc4LDY2Nyw2NjgsODMzLDcyMiw2NTAsNzc4LDcyMiw2NjcsNjE4LDYxMSw2NjcsNzk4LDY2Nyw4MzUsNzQ4LDI3OCw2NjcsNTc4LDQ0Niw1NTYsMjIyLDU0Nyw1NzgsNTc1LDUwMCw1NTcsNDQ2LDQ0MSw1NTYsNTU2LDIyMiw1MDAsNTAwLDU3Niw1MDAsNDQ4LDU1Niw2OTAsNTY5LDQ4Miw2MTcsMzk1LDU0Nyw2NDgsNTI1LDcxMyw3ODEsMjIyLDU0Nyw1NTYsNTQ3LDc4MSw2NjcsNjY3LDg2NSw1NDIsNzE5LDY2NywyNzgsMjc4LDUwMCwxMDU3LDEwMTAsODU0LDU4Myw3MjIsNjM1LDcxOSw2NjcsNjU2LDY2Nyw1NDIsNjc3LDY2Nyw5MjMsNjA0LDcxOSw3MTksNTgzLDY1Niw4MzMsNzIyLDc3OCw3MTksNjY3LDcyMiw2MTEsNjM1LDc2MCw2NjcsNzQwLDY2Nyw5MTcsOTM4LDc5Miw4ODUsNjU2LDcxOSwxMDEwLDcyMiw1NTYsNTczLDUzMSwzNjUsNTgzLDU1Niw2NjksNDU4LDU1OSw1NTksNDM4LDU4Myw2ODgsNTUyLDU1Niw1NDIsNTU2LDUwMCw0NTgsNTAwLDgyMyw1MDAsNTczLDUyMSw4MDIsODIzLDYyNSw3MTksNTIxLDUxMCw3NTAsNTQyLDU1Niw1NTYsNTU2LDM2NSw1MTAsNTAwLDIyMiwyNzgsMjIyLDkwNiw4MTIsNTU2LDQzOCw1NTksNTAwLDU1Miw3NzgsNTU2LDQ4OSw0MTEsOTQ0LDcyMiw5NDQsNzIyLDk0NCw3MjIsNjY3LDUwMCwzMzMsMzMzLDU1NiwxZTMsMWUzLDU1MiwyMjIsMjIyLDIyMiwyMjIsMzMzLDMzMywzMzMsNTU2LDU1NiwzNTAsMWUzLDFlMywxODgsMzU0LDMzMywzMzMsNTAwLDMzMywxNjcsMzY1LDU1Niw1NTYsMTA5NCw1NTYsODg1LDMyMywxMDczLDFlMyw3NjgsNjAwLDgzNCw4MzQsODM0LDgzNCwxZTMsNTAwLDFlMyw1MDAsMWUzLDUwMCw1MDAsNDk0LDYxMiw4MjMsNzEzLDU4NCw1NDksNzEzLDk3OSw3MTksMjc0LDU0OSw1NDksNTgzLDU0OSw1NDksNjA0LDU4NCw2MDQsNjA0LDcwOCw2MjUsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzA4LDcwOCw3MDgsNzI5LDYwNCw2MDQsMzU0LDM1NCwxZTMsOTkwLDk5MCw5OTAsOTkwLDQ5NCw2MDQsNjA0LDYwNCw2MDQsMzU0LDEwMjEsMTA1Miw5MTcsNzUwLDc1MCw1MzEsNjU2LDU5NCw1MTAsNTAwLDc1MCw3NTAsNTAwLDUwMCwzMzMsMzMzLDMzMywzMzMsMzMzLDMzMywzMzMsMzMzLDIyMiwyMjIsMjk0LDI5NCwzMjQsMzI0LDMxNiwzMjgsMzk4LDI4NV0samE9Wy0xLC0xLC0xLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyLDczLDc0LDc1LDc2LDc3LDc4LDc5LDgwLDgxLDgyLDgzLDg0LDg1LDg2LDg3LDg4LDg5LDkwLDkxLDkyLDkzLDk0LDk1LDk2LDk3LDk4LDk5LDEwMCwxMDEsMTAyLDEwMywxMDQsMTA1LDEwNiwxMDcsMTA4LDEwOSwxMTAsMTExLDExMiwxMTMsMTE0LDExNSwxMTYsMTE3LDExOCwxMTksMTIwLDEyMSwxMjIsMTIzLDEyNCwxMjUsMTI2LDE2MSwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzEsMTcyLDE3NCwxNzUsMTc2LDE3NywxNzgsMTc5LDE4MCwxODEsMTgyLDE4MywxODQsMTg1LDE4NiwxODcsMTg4LDE4OSwxOTAsMTkxLDE5MiwxOTMsMTk0LDE5NSwxOTYsMTk3LDE5OCwxOTksMjAwLDIwMSwyMDIsMjAzLDIwNCwyMDUsMjA2LDIwNywyMDgsMjA5LDIxMCwyMTEsMjEyLDIxMywyMTQsMjE1LDIxNiwyMTcsMjE4LDIxOSwyMjAsMjIxLDIyMiwyMjMsMjI0LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyMzUsMjM2LDIzNywyMzgsMjM5LDI0MCwyNDEsMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OSwyNTAsMjUxLDI1MiwyNTMsMjU0LDI1NSwyNTYsMjU3LDI1OCwyNTksMjYwLDI2MSwyNjIsMjYzLDI2NCwyNjUsMjY2LDI2NywyNjgsMjY5LDI3MCwyNzEsMjcyLDI3MywyNzQsMjc1LDI3NiwyNzcsMjc4LDI3OSwyODAsMjgxLDI4MiwyODMsMjg0LDI4NSwyODYsMjg3LDI4OCwyODksMjkwLDI5MSwyOTIsMjkzLDI5NCwyOTUsMjk2LDI5NywyOTgsMjk5LDMwMCwzMDEsMzAyLDMwMywzMDQsMzA1LDMwNiwzMDcsMzA4LDMwOSwzMTAsMzExLDMxMiwzMTMsMzE0LDMxNSwzMTYsMzE3LDMxOCwzMTksMzIwLDMyMSwzMjIsMzIzLDMyNCwzMjUsMzI2LDMyNywzMjgsMzI5LDMzMCwzMzEsMzMyLDMzMywzMzQsMzM1LDMzNiwzMzcsMzM4LDMzOSwzNDAsMzQxLDM0MiwzNDMsMzQ0LDM0NSwzNDYsMzQ3LDM0OCwzNDksMzUwLDM1MSwzNTIsMzUzLDM1NCwzNTUsMzU2LDM1NywzNTgsMzU5LDM2MCwzNjEsMzYyLDM2MywzNjQsMzY1LDM2NiwzNjcsMzY4LDM2OSwzNzAsMzcxLDM3MiwzNzMsMzc0LDM3NSwzNzYsMzc3LDM3OCwzNzksMzgwLDM4MSwzODIsMzgzLDQwMiw1MDYsNTA3LDUwOCw1MDksNTEwLDUxMSw1MzYsNTM3LDUzOCw1MzksNzEwLDcxMSw3MTMsNzI4LDcyOSw3MzAsNzMxLDczMiw3MzMsOTAwLDkwMSw5MDIsOTAzLDkwNCw5MDUsOTA2LDkwOCw5MTAsOTExLDkxMiw5MTMsOTE0LDkxNSw5MTYsOTE3LDkxOCw5MTksOTIwLDkyMSw5MjIsOTIzLDkyNCw5MjUsOTI2LDkyNyw5MjgsOTI5LDkzMSw5MzIsOTMzLDkzNCw5MzUsOTM2LDkzNyw5MzgsOTM5LDk0MCw5NDEsOTQyLDk0Myw5NDQsOTQ1LDk0Niw5NDcsOTQ4LDk0OSw5NTAsOTUxLDk1Miw5NTMsOTU0LDk1NSw5NTYsOTU3LDk1OCw5NTksOTYwLDk2MSw5NjIsOTYzLDk2NCw5NjUsOTY2LDk2Nyw5NjgsOTY5LDk3MCw5NzEsOTcyLDk3Myw5NzQsMTAyNCwxMDI1LDEwMjYsMTAyNywxMDI4LDEwMjksMTAzMCwxMDMxLDEwMzIsMTAzMywxMDM0LDEwMzUsMTAzNiwxMDM3LDEwMzgsMTAzOSwxMDQwLDEwNDEsMTA0MiwxMDQzLDEwNDQsMTA0NSwxMDQ2LDEwNDcsMTA0OCwxMDQ5LDEwNTAsMTA1MSwxMDUyLDEwNTMsMTA1NCwxMDU1LDEwNTYsMTA1NywxMDU4LDEwNTksMTA2MCwxMDYxLDEwNjIsMTA2MywxMDY0LDEwNjUsMTA2NiwxMDY3LDEwNjgsMTA2OSwxMDcwLDEwNzEsMTA3MiwxMDczLDEwNzQsMTA3NSwxMDc2LDEwNzcsMTA3OCwxMDc5LDEwODAsMTA4MSwxMDgyLDEwODMsMTA4NCwxMDg1LDEwODYsMTA4NywxMDg4LDEwODksMTA5MCwxMDkxLDEwOTIsMTA5MywxMDk0LDEwOTUsMTA5NiwxMDk3LDEwOTgsMTA5OSwxMTAwLDExMDEsMTEwMiwxMTAzLDExMDQsMTEwNSwxMTA2LDExMDcsMTEwOCwxMTA5LDExMTAsMTExMSwxMTEyLDExMTMsMTExNCwxMTE1LDExMTYsMTExNywxMTE4LDExMTksMTEzOCwxMTM5LDExNjgsMTE2OSw3ODA4LDc4MDksNzgxMCw3ODExLDc4MTIsNzgxMyw3OTIyLDc5MjMsODIwOCw4MjA5LDgyMTEsODIxMiw4MjEzLDgyMTUsODIxNiw4MjE3LDgyMTgsODIxOSw4MjIwLDgyMjEsODIyMiw4MjI0LDgyMjUsODIyNiw4MjMwLDgyNDAsODI0Miw4MjQzLDgyNDksODI1MCw4MjUyLDgyNTQsODI2MCw4MzE5LDgzNTUsODM1Niw4MzU5LDgzNjQsODQ1Myw4NDY3LDg0NzAsODQ4Miw4NDg2LDg0OTQsODUzOSw4NTQwLDg1NDEsODU0Miw4NTkyLDg1OTMsODU5NCw4NTk1LDg1OTYsODU5Nyw4NjE2LDg3MDYsODcxMCw4NzE5LDg3MjEsODcyMiw4NzMwLDg3MzQsODczNSw4NzQ1LDg3NDcsODc3Niw4ODAwLDg4MDEsODgwNCw4ODA1LDg5NjIsODk3Niw4OTkyLDg5OTMsOTQ3Miw5NDc0LDk0ODQsOTQ4OCw5NDkyLDk0OTYsOTUwMCw5NTA4LDk1MTYsOTUyNCw5NTMyLDk1NTIsOTU1Myw5NTU0LDk1NTUsOTU1Niw5NTU3LDk1NTgsOTU1OSw5NTYwLDk1NjEsOTU2Miw5NTYzLDk1NjQsOTU2NSw5NTY2LDk1NjcsOTU2OCw5NTY5LDk1NzAsOTU3MSw5NTcyLDk1NzMsOTU3NCw5NTc1LDk1NzYsOTU3Nyw5NTc4LDk1NzksOTU4MCw5NjAwLDk2MDQsOTYwOCw5NjEyLDk2MTYsOTYxNyw5NjE4LDk2MTksOTYzMiw5NjMzLDk2NDIsOTY0Myw5NjQ0LDk2NTAsOTY1OCw5NjYwLDk2NjgsOTY3NCw5Njc1LDk2NzksOTY4OCw5Njg5LDk3MDIsOTc4Niw5Nzg3LDk3ODgsOTc5Miw5Nzk0LDk4MjQsOTgyNyw5ODI5LDk4MzAsOTgzNCw5ODM1LDk4MzYsNjE0NDEsNjE0NDIsNjE0NDUsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLTFdLFhhPVsxLjM2ODk4LDEsMSwuNzI3MDYsLjgwNDc5LC44MzczNCwuOTg4OTQsLjk5NzkzLC45ODk3LC45Mzg4NCwuODYyMDksLjk0MjkyLC45NDI5MiwxLjE2NjYxLDEuMDIwNTgsLjkzNTgyLC45NjY5NCwuOTM1ODIsMS4xOTEzNywuOTk3OTMsLjk5NzkzLC45OTc5MywuOTk3OTMsLjk5NzkzLC45OTc5MywuOTk3OTMsLjk5NzkzLC45OTc5MywuOTk3OTMsLjc4MDc2LC43ODA3NiwxLjAyMDU4LDEuMDIwNTgsMS4wMjA1OCwuNzI4NTEsLjc4OTY2LC45MDgzOCwuODM2MzcsLjgyMzkxLC45NjM3NiwuODAwNjEsLjg2Mjc1LC44NzY4LC45NTQwNywxLjAyNTgsLjczOTAxLC44NTAyMiwuODM2NTUsMS4wMTU2LC45NTU0NiwuOTIxNzksLjg3MTA3LC45MjE3OSwuODIxMTQsLjgwOTYsLjg5NzEzLC45NDQzOCwuOTUzNTMsLjk0MDgzLC45MTkwNSwuOTA0MDYsLjk0NDYsLjk0MjkyLDEuMTg3NzcsLjk0MjkyLDEuMDIwNTgsLjg5OTAzLC45MDA4OCwuOTQ5MzgsLjk3ODk4LC44MTA5MywuOTc1NzEsLjk0OTM4LDEuMDI0LC45NTc3LC45NTkzMywuOTg2MjEsMS4wNDc0LC45NzQ1NSwuOTg5ODEsLjk2NzIsLjk1OTMzLC45NDQ2LC45Nzg5OCwuOTc0MDcsLjk3NjQ2LC43ODAzNiwxLjEwMjA4LC45NTQ0MiwuOTUyOTgsLjk3NTc5LC45MzMyLC45NDAzOSwuOTM4LC44MDY4NywxLjAxMTQ5LC44MDY4NywxLjAyMDU4LC44MDQ3OSwuOTk3OTMsLjk5NzkzLC45OTc5MywuOTk3OTMsMS4wMTE0OSwxLjAwODcyLC45MDA4OCwuOTE4ODIsMS4wMjEzLC44MzYxLDEuMDIwNTgsLjYyMjk1LC41NDMyNCwuODkwMjIsMS4wODU5NSwxLDEsLjkwMDg4LDEsLjk3NDU1LC45MzU4MiwuOTAwODgsMSwxLjA1Njg2LC44MzYxLC45OTY0MiwuOTk2NDIsLjk5NjQyLC43Mjg1MSwuOTA4MzgsLjkwODM4LC45MDgzOCwuOTA4MzgsLjkwODM4LC45MDgzOCwuODY4LC44MjM5MSwuODAwNjEsLjgwMDYxLC44MDA2MSwuODAwNjEsMS4wMjU4LDEuMDI1OCwxLjAyNTgsMS4wMjU4LC45NzQ4NCwuOTU1NDYsLjkyMTc5LC45MjE3OSwuOTIxNzksLjkyMTc5LC45MjE3OSwxLjAyMDU4LC45MjE3OSwuOTQ0MzgsLjk0NDM4LC45NDQzOCwuOTQ0MzgsLjkwNDA2LC44Njk1OCwuOTgyMjUsLjk0OTM4LC45NDkzOCwuOTQ5MzgsLjk0OTM4LC45NDkzOCwuOTQ5MzgsLjkwMzEsLjgxMDkzLC45NDkzOCwuOTQ5MzgsLjk0OTM4LC45NDkzOCwuOTg2MjEsLjk4NjIxLC45ODYyMSwuOTg2MjEsLjkzOTY5LC45NTkzMywuOTQ0NiwuOTQ0NiwuOTQ0NiwuOTQ0NiwuOTQ0NiwxLjA4NTk1LC45NDQ2LC45NTQ0MiwuOTU0NDIsLjk1NDQyLC45NTQ0MiwuOTQwMzksLjk3ODk4LC45NDAzOSwuOTA4MzgsLjk0OTM4LC45MDgzOCwuOTQ5MzgsLjkwODM4LC45NDkzOCwuODIzOTEsLjgxMDkzLC44MjM5MSwuODEwOTMsLjgyMzkxLC44MTA5MywuODIzOTEsLjgxMDkzLC45NjM3NiwuODQzMTMsLjk3NDg0LC45NzU3MSwuODAwNjEsLjk0OTM4LC44MDA2MSwuOTQ5MzgsLjgwMDYxLC45NDkzOCwuODAwNjEsLjk0OTM4LC44MDA2MSwuOTQ5MzgsLjg3NjgsLjk1NzcsLjg3NjgsLjk1NzcsLjg3NjgsLjk1NzcsMSwxLC45NTQwNywuOTU5MzMsLjk3MDY5LC45NTkzMywxLjAyNTgsLjk4NjIxLDEuMDI1OCwuOTg2MjEsMS4wMjU4LC45ODYyMSwxLjAyNTgsLjk4NjIxLDEuMDI1OCwuOTg2MjEsLjg4NywxLjAxNTkxLC43MzkwMSwxLjA0NzQsMSwxLC45NzQ1NSwuODM2NTUsLjk4OTgxLDEsMSwuODM2NTUsLjczOTc3LC44MzY1NSwuNzM5MDMsLjg0NjM4LDEuMDMzLC45NTU0NiwuOTU5MzMsMSwxLC45NTU0NiwuOTU5MzMsLjgyNzEsLjk1NDE3LC45NTkzMywuOTIxNzksLjk0NDYsLjkyMTc5LC45NDQ2LC45MjE3OSwuOTQ0NiwuOTM2LC45MTk2NCwuODIxMTQsLjk3NjQ2LDEsMSwuODIxMTQsLjk3NjQ2LC44MDk2LC43ODAzNiwuODA5NiwuNzgwMzYsMSwxLC44MDk2LC43ODAzNiwxLDEsLjg5NzEzLC43NzQ1MiwuODk3MTMsMS4xMDIwOCwuOTQ0MzgsLjk1NDQyLC45NDQzOCwuOTU0NDIsLjk0NDM4LC45NTQ0MiwuOTQ0MzgsLjk1NDQyLC45NDQzOCwuOTU0NDIsLjk0NDM4LC45NTQ0MiwuOTQwODMsLjk3NTc5LC45MDQwNiwuOTQwMzksLjkwNDA2LC45NDQ2LC45MzgsLjk0NDYsLjkzOCwuOTQ0NiwuOTM4LDEsLjk5NzkzLC45MDgzOCwuOTQ5MzgsLjg2OCwuOTAzMSwuOTIxNzksLjk0NDYsMSwxLC44OTcxMywxLjEwMjA4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDk4OSwuOTM1OCwuOTE5NDUsLjgzMTgxLC43NTI2MSwuODc5OTIsLjgyOTc2LC45NjAzNCwuODM2ODksLjk3MjY4LDEuMDA3OCwuOTA4MzgsLjgzNjM3LC44MDE5LC45MDE1NywuODAwNjEsLjk0NDYsLjk1NDA3LC45MjQzNiwxLjAyNTgsLjg1MDIyLC45NzE1MywxLjAxNTYsLjk1NTQ2LC44OTE5MiwuOTIxNzksLjkyMzYxLC44NzEwNywuOTYzMTgsLjg5NzEzLC45MzcwNCwuOTU2MzgsLjkxOTA1LC45MTcwOSwuOTI3OTYsMS4wMjU4LC45MzcwNCwuOTQ4MzYsMS4wMzczLC45NTkzMywxLjAwNzgsLjk1ODcxLC45NDgzNiwuOTYxNzQsLjkyNjAxLC45NDk4LC45ODYwNywuOTU3NzYsLjk1OTMzLDEuMDU0NTMsMS4wMDc4LC45ODI3NSwuOTMxNCwuOTU2MTcsLjkxNzAxLDEuMDU5OTMsLjk0NDYsLjc4MzY3LC45NTUzLDEsLjg2ODMyLDEuMDEyOCwuOTU4NzEsLjk5Mzk0LC44NzU0OCwuOTYzNjEsLjg2Nzc0LDEuMDA3OCwuOTU4NzEsLjk0NDYsLjk1ODcxLC44Njc3NCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45NDA4MywuOTc1NzksLjk0MDgzLC45NzU3OSwuOTQwODMsLjk3NTc5LC45MDQwNiwuOTQwMzksLjk2Njk0LDEsLjg5OTAzLDEsMSwxLC45MzU4MiwuOTM1ODIsLjkzNTgyLDEsLjkwOCwuOTA4LC45MTgsLjk0MjE5LC45NDIxOSwuOTY1NDQsMSwxLjI4NSwxLDEsLjgxMDc5LC44MTA3OSwxLDEsLjc0ODU0LDEsMSwxLDEsLjk5NzkzLDEsMSwxLC42NSwxLDEuMzYxNDUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMTcxNzMsMSwuODA1MzUsLjc2MTY5LDEuMDIwNTgsMS4wNzMyLDEuMDU0ODYsMSwxLDEuMzA2OTIsMS4wODU5NSwxLjA4NTk1LDEsMS4wODU5NSwxLjA4NTk1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4xNjE2MSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSxaYT17bGluZUhlaWdodDoxLjIsbGluZUdhcDouMn0sVmE9WzEuMzY4OTgsMSwxLC42NjIyNywuODA3NzksLjgxNjI1LC45NzI3NiwuOTcyNzYsLjk3NzMzLC45MjIyMiwuODMyNjYsLjk0MjkyLC45NDI5MiwxLjE2MTQ4LDEuMDIwNTgsLjkzNTgyLC45NjY5NCwuOTM1ODIsMS4xNzMzNywuOTcyNzYsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjc4MDc2LC43ODA3NiwxLjAyMDU4LDEuMDIwNTgsMS4wMjA1OCwuNzE1NDEsLjc2ODEzLC44NTU3NiwuODA1OTEsLjgwNzI5LC45NDI5OSwuNzc1MTIsLjgzNjU1LC44NjUyMywuOTIyMjIsLjk4NjIxLC43MTc0MywuODE2OTgsLjc5NzI2LC45ODU1OCwuOTIyMjIsLjkwNjM3LC44MzgwOSwuOTA2MzcsLjgwNzI5LC43NjQ2MywuODYyNzUsLjkwNjk5LC45MTYwNSwuOTE1NCwuODUzMDgsLjg1NDU4LC45MDUzMSwuOTQyOTIsMS4yMTI5NiwuOTQyOTIsMS4wMjA1OCwuODk5MDMsMS4xODYxNiwuOTk2MTMsLjkxNjc3LC43ODIxNiwuOTE2NzcsLjkwMDgzLC45ODc5NiwuOTEzNSwuOTIxNjgsLjk1MzgxLC45ODk4MSwuOTUyOTgsLjk1MzgxLC45MzQ1OSwuOTIxNjgsLjkxNTEzLC45MjAwNCwuOTE2NzcsLjk1MDc3LC43NDgsMS4wNDUwMiwuOTE2NzcsLjkyMDYxLC45NDIzNiwuODk1NDQsLjg5MzY0LC45LC44MDY4NywuODU3OCwuODA2ODcsMS4wMjA1OCwuODA3NzksLjk3Mjc2LC45NzI3NiwuOTcyNzYsLjk3Mjc2LC44NTc4LC45OTk3MywxLjE4NjE2LC45MTMzOSwxLjA4MDc0LC44Mjg5MSwxLjAyMDU4LC41NTUwOSwuNzE1MjYsLjg5MDIyLDEuMDg1OTUsMSwxLDEuMTg2MTYsMSwuOTY3MzYsLjkzNTgyLDEuMTg2MTYsMSwxLjA0ODY0LC44MjcxMSwuOTkwNDMsLjk5MDQzLC45OTA0MywuNzE1NDEsLjg1NTc2LC44NTU3NiwuODU1NzYsLjg1NTc2LC44NTU3NiwuODU1NzYsLjg0NSwuODA3MjksLjc3NTEyLC43NzUxMiwuNzc1MTIsLjc3NTEyLC45ODYyMSwuOTg2MjEsLjk4NjIxLC45ODYyMSwuOTU5NjEsLjkyMjIyLC45MDYzNywuOTA2MzcsLjkwNjM3LC45MDYzNywuOTA2MzcsMS4wMjA1OCwuOTAyNTEsLjkwNjk5LC45MDY5OSwuOTA2OTksLjkwNjk5LC44NTQ1OCwuODM2NTksLjk0OTUxLC45OTYxMywuOTk2MTMsLjk5NjEzLC45OTYxMywuOTk2MTMsLjk5NjEzLC44NTgxMSwuNzgyMTYsLjkwMDgzLC45MDA4MywuOTAwODMsLjkwMDgzLC45NTM4MSwuOTUzODEsLjk1MzgxLC45NTM4MSwuOTEzNSwuOTIxNjgsLjkxNTEzLC45MTUxMywuOTE1MTMsLjkxNTEzLC45MTUxMywxLjA4NTk1LC45MTY3NywuOTE2NzcsLjkxNjc3LC45MTY3NywuOTE2NzcsLjg5MzY0LC45MjMzMiwuODkzNjQsLjg1NTc2LC45OTYxMywuODU1NzYsLjk5NjEzLC44NTU3NiwuOTk2MTMsLjgwNzI5LC43ODIxNiwuODA3MjksLjc4MjE2LC44MDcyOSwuNzgyMTYsLjgwNzI5LC43ODIxNiwuOTQyOTksLjc2NzgzLC45NTk2MSwuOTE2NzcsLjc3NTEyLC45MDA4MywuNzc1MTIsLjkwMDgzLC43NzUxMiwuOTAwODMsLjc3NTEyLC45MDA4MywuNzc1MTIsLjkwMDgzLC44NjUyMywuOTEzNSwuODY1MjMsLjkxMzUsLjg2NTIzLC45MTM1LDEsMSwuOTIyMjIsLjkyMTY4LC45MjIyMiwuOTIxNjgsLjk4NjIxLC45NTM4MSwuOTg2MjEsLjk1MzgxLC45ODYyMSwuOTUzODEsLjk4NjIxLC45NTM4MSwuOTg2MjEsLjk1MzgxLC44NjAzNiwuOTcwOTYsLjcxNzQzLC45ODk4MSwxLDEsLjk1Mjk4LC43OTcyNiwuOTUzODEsMSwxLC43OTcyNiwuNjg5NCwuNzk3MjYsLjc0MzIxLC44MTY5MSwxLjAwMDYsLjkyMjIyLC45MjE2OCwxLDEsLjkyMjIyLC45MjE2OCwuNzk0NjQsLjkyMDk4LC45MjE2OCwuOTA2MzcsLjkxNTEzLC45MDYzNywuOTE1MTMsLjkwNjM3LC45MTUxMywuOTA5LC44NzUxNCwuODA3MjksLjk1MDc3LDEsMSwuODA3MjksLjk1MDc3LC43NjQ2MywuNzQ4LC43NjQ2MywuNzQ4LDEsMSwuNzY0NjMsLjc0OCwxLDEsLjg2Mjc1LC43MjY1MSwuODYyNzUsMS4wNDUwMiwuOTA2OTksLjkxNjc3LC45MDY5OSwuOTE2NzcsLjkwNjk5LC45MTY3NywuOTA2OTksLjkxNjc3LC45MDY5OSwuOTE2NzcsLjkwNjk5LC45MTY3NywuOTE1NCwuOTQyMzYsLjg1NDU4LC44OTM2NCwuODU0NTgsLjkwNTMxLC45LC45MDUzMSwuOSwuOTA1MzEsLjksMSwuOTcyNzYsLjg1NTc2LC45OTYxMywuODQ1LC44NTgxMSwuOTAyNTEsLjkxNjc3LDEsMSwuODYyNzUsMS4wNDUwMiwxLjE4NjE2LDEuMTg2MTYsMS4xODYxNiwxLjE4NjE2LDEuMTg2MTYsMS4xODYxNiwxLjE4NjE2LDEuMTg2MTYsMS4xODYxNiwxLjAwODk5LDEuMzA2MjgsLjg1NTc2LC44MDE3OCwuNjY4NjIsLjc5MjcsLjY5MzIzLC44ODEyNywuNzI0NTksLjg5NzExLC45NTM4MSwuODU1NzYsLjgwNTkxLC43ODA1LC45NDcyOSwuNzc1MTIsLjkwNTMxLC45MjIyMiwuOTA2MzcsLjk4NjIxLC44MTY5OCwuOTI2NTUsLjk4NTU4LC45MjIyMiwuODUzNTksLjkwNjM3LC45MDk3NiwuODM4MDksLjk0NTIzLC44NjI3NSwuODM1MDksLjkzMTU3LC44NTMwOCwuODMzOTIsLjkyMzQ2LC45ODYyMSwuODM1MDksLjkyODg2LC45MTMyNCwuOTIxNjgsLjk1MzgxLC45MDY0NiwuOTI4ODYsLjkwNTU3LC44Njg0NywuOTAyNzYsLjkxMzI0LC44Njg0MiwuOTIxNjgsLjk5NTMxLC45NTM4MSwuOTIyNCwuODU0MDgsLjkyNjk5LC44Njg0NywxLjAwNTEsLjkxNTEzLC44MDQ4NywuOTM0ODEsMSwuODgxNTksMS4wNTIxNCwuOTA2NDYsLjk3MzU1LC44MTUzOSwuODkzOTgsLjg1OTIzLC45NTM4MSwuOTA2NDYsLjkxNTEzLC45MDY0NiwuODU5MjMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTE1NCwuOTQyMzYsLjkxNTQsLjk0MjM2LC45MTU0LC45NDIzNiwuODU0NTgsLjg5MzY0LC45NjY5NCwxLC44OTkwMywxLDEsMSwuOTE3ODIsLjkxNzgyLC45MTc4MiwxLC44OTYsLjg5NiwuODk2LC45MzMyLC45MzMyLC45NTk3MywxLDEuMjYsMSwxLC44MDQ3OSwuODAxNzgsMSwxLC44NTYzMywxLDEsMSwxLC45NzI3NiwxLDEsMSwuNjk4LDEsMS4zNjE0NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4xNDU0MiwxLC43OTE5OSwuNzg2OTQsMS4wMjA1OCwxLjAzNDkzLDEuMDU0ODYsMSwxLDEuMjMwMjYsMS4wODU5NSwxLjA4NTk1LDEsMS4wODU5NSwxLjA4NTk1LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4yMDAwNiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSx6YT17bGluZUhlaWdodDoxLjIsbGluZUdhcDouMn0sX2E9WzEuMzY4OTgsMSwxLC42NTUwNywuODQ5NDMsLjg1NjM5LC44ODQ2NSwuODg0NjUsLjg2OTM2LC44ODMwNywuODY5NDgsLjg1MjgzLC44NTI4MywxLjA2MzgzLDEuMDIwNTgsLjc1OTQ1LC45MjE5LC43NTk0NSwxLjE3MzM3LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44ODQ2NSwuNzU5NDUsLjc1OTQ1LDEuMDIwNTgsMS4wMjA1OCwxLjAyMDU4LC42OTA0NiwuNzA5MjYsLjg1MTU4LC43NzgxMiwuNzY4NTIsLjg5NTkxLC43MDQ2NiwuNzYxMjUsLjgwMDk0LC44NjgyMiwuODM4NjQsLjcyOCwuNzcyMTIsLjc5NDc1LC45MzYzNywuODc1MTQsLjg1ODgsLjc2MDEzLC44NTg4LC43MjQyMSwuNjk4NjYsLjc3NTk4LC44NTk5MSwuODA4MTEsLjg3ODMyLC43ODExMiwuNzc1MTIsLjg1NjIsMS4wMjIyLDEuMTg0MTcsMS4wMjIyLDEuMjcwMTQsLjg5OTAzLDEuMTUwMTIsLjkzODU5LC45NDM5OSwuODQ2LC45NDM5OSwuODE0NTMsMS4wMTg2LC45NDIxOSwuOTYwMTcsMS4wMzA3NSwxLjAyMTc1LC45MTIsMS4wMzA3NSwuOTY5OTgsLjk2MDE3LC45Mzg1OSwuOTQzOTksLjk0Mzk5LC45NTQ5MywuNzQ2LDEuMTI2NTgsLjk0NTc4LC45MSwuOTc5LC44ODIsLjg4MiwuODMsLjg1MDM0LC44MzUzNywuODUwMzQsMS4wMjA1OCwuNzA4NjksLjg4NDY1LC44ODQ2NSwuODg0NjUsLjg4NDY1LC44MzUzNywuOTAwODMsMS4xNTAxMiwuOTE2MSwuOTQ1NjUsLjczNTQxLDEuMDIwNTgsLjUzNjA5LC42OTM1MywuNzk1MTksMS4wODU5NSwxLDEsMS4xNTAxMiwxLC45MTk3NCwuNzU5NDUsMS4xNTAxMiwxLC45NDQ2LC43MzM2MSwuOTAwNSwuOTAwNSwuOTAwNSwuNjI4NjQsLjg1MTU4LC44NTE1OCwuODUxNTgsLjg1MTU4LC44NTE1OCwuODUxNTgsLjc3MywuNzY4NTIsLjcwNDY2LC43MDQ2NiwuNzA0NjYsLjcwNDY2LC44Mzg2NCwuODM4NjQsLjgzODY0LC44Mzg2NCwuOTA1NjEsLjg3NTE0LC44NTg4LC44NTg4LC44NTg4LC44NTg4LC44NTg4LDEuMDIwNTgsLjg1NzUxLC44NTk5MSwuODU5OTEsLjg1OTkxLC44NTk5MSwuNzc1MTIsLjc2MDEzLC44ODA3NSwuOTM4NTksLjkzODU5LC45Mzg1OSwuOTM4NTksLjkzODU5LC45Mzg1OSwuODA3NSwuODQ2LC44MTQ1MywuODE0NTMsLjgxNDUzLC44MTQ1MywuODI0MjQsLjgyNDI0LC44MjQyNCwuODI0MjQsLjkyNzgsLjk2MDE3LC45Mzg1OSwuOTM4NTksLjkzODU5LC45Mzg1OSwuOTM4NTksMS4wODU5NSwuODU2MiwuOTQ1NzgsLjk0NTc4LC45NDU3OCwuOTQ1NzgsLjg4MiwuOTQ1NzgsLjg4MiwuODUxNTgsLjkzODU5LC44NTE1OCwuOTM4NTksLjg1MTU4LC45Mzg1OSwuNzY4NTIsLjg0NiwuNzY4NTIsLjg0NiwuNzY4NTIsLjg0NiwuNzY4NTIsLjg0NiwuODk1OTEsLjg1NDQsLjkwNTYxLC45NDM5OSwuNzA0NjYsLjgxNDUzLC43MDQ2NiwuODE0NTMsLjcwNDY2LC44MTQ1MywuNzA0NjYsLjgxNDUzLC43MDQ2NiwuODE0NTMsLjgwMDk0LC45NDIxOSwuODAwOTQsLjk0MjE5LC44MDA5NCwuOTQyMTksMSwxLC44NjgyMiwuOTYwMTcsLjg2ODIyLC45NjAxNywuODM4NjQsLjgyNDI0LC44Mzg2NCwuODI0MjQsLjgzODY0LC44MjQyNCwuODM4NjQsMS4wMzA3NSwuODM4NjQsLjgyNDI0LC44MTQwMiwxLjAyNzM4LC43MjgsMS4wMjE3NSwxLDEsLjkxMiwuNzk0NzUsMS4wMzA3NSwxLDEsLjc5NDc1LC44MzkxMSwuNzk0NzUsLjY2MjY2LC44MDU1MywxLjA2Njc2LC44NzUxNCwuOTYwMTcsMSwxLC44NzUxNCwuOTYwMTcsLjg2ODY1LC44NzM5NiwuOTYwMTcsLjg1ODgsLjkzODU5LC44NTg4LC45Mzg1OSwuODU4OCwuOTM4NTksLjg2NywuODQ3NTksLjcyNDIxLC45NTQ5MywxLDEsLjcyNDIxLC45NTQ5MywuNjk4NjYsLjc0NiwuNjk4NjYsLjc0NiwxLDEsLjY5ODY2LC43NDYsMSwxLC43NzU5OCwuODg0MTcsLjc3NTk4LDEuMTI2NTgsLjg1OTkxLC45NDU3OCwuODU5OTEsLjk0NTc4LC44NTk5MSwuOTQ1NzgsLjg1OTkxLC45NDU3OCwuODU5OTEsLjk0NTc4LC44NTk5MSwuOTQ1NzgsLjg3ODMyLC45NzksLjc3NTEyLC44ODIsLjc3NTEyLC44NTYyLC44MywuODU2MiwuODMsLjg1NjIsLjgzLDEsLjg4NDY1LC44NTE1OCwuOTM4NTksLjc3MywuODA3NSwuODU3NTEsLjg1NjIsMSwxLC43NzU5OCwxLjEyNjU4LDEuMTUwMTIsMS4xNTAxMiwxLjE1MDEyLDEuMTUwMTIsMS4xNTAxMiwxLjE1MzEzLDEuMTUwMTIsMS4xNTAxMiwxLjE1MDEyLDEuMDgxMDYsMS4wMzkwMSwuODUxNTgsLjc3MDI1LC42MjI2NCwuNzY0NiwuNjUzNTEsLjg2MDI2LC42OTQ2MSwuODk5NDcsMS4wMzA3NSwuODUxNTgsLjc3ODEyLC43NjQ0OSwuODg4MzYsLjcwNDY2LC44NTYyLC44NjgyMiwuODU4OCwuODM4NjQsLjc3MjEyLC44NTMwOCwuOTM2MzcsLjg3NTE0LC44MjM1MiwuODU4OCwuODU3MDEsLjc2MDEzLC44OTA1OCwuNzc1OTgsLjgxNTYsLjgyNTY1LC43ODExMiwuNzc4OTksLjg5Mzg2LC44Mzg2NCwuODE1NiwuOTQ4NiwuOTIzODgsLjk2MTg2LDEuMDMwNzUsLjkxMTIzLC45NDg2LC45MzI5OCwuODc4LC45Mzk0MiwuOTIzODgsLjg0NTk2LC45NjE4NiwuOTUxMTksMS4wMzA3NSwuOTIyLC44ODc4NywuOTU4MjksLjg4LC45MzU1OSwuOTM4NTksLjc4ODE1LC45Mzc1OCwxLC44OTIxNywxLjAzNzM3LC45MTEyMywuOTM5NjksLjc3NDg3LC44NTc2OSwuODY3OTksMS4wMzA3NSwuOTExMjMsLjkzODU5LC45MTEyMywuODY3OTksMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuODc4MzIsLjk3OSwuODc4MzIsLjk3OSwuODc4MzIsLjk3OSwuNzc1MTIsLjg4MiwuOTIxOSwxLC44OTkwMywxLDEsMSwuODczMjEsLjg3MzIxLC44NzMyMSwxLDEuMDI3LDEuMDI3LDEuMDI3LC44Njg0NywuODY4NDcsLjc5MTIxLDEsMS4xMjQsMSwxLC43MzU3MiwuNzM1NzIsMSwxLC44NTAzNCwxLDEsMSwxLC44ODQ2NSwxLDEsMSwuNjY5LDEsMS4zNjE0NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wNDgyOCwxLC43NDk0OCwuNzUxODcsMS4wMjA1OCwuOTgzOTEsMS4wMjExOSwxLDEsMS4wNjIzMywxLjA4NTk1LDEuMDg1OTUsMSwxLjA4NTk1LDEuMDg1OTUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA1MjMzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLCRhPXtsaW5lSGVpZ2h0OjEuMixsaW5lR2FwOi4yfSxBcz1bMS4zNjg5OCwxLDEsLjc2MzA1LC44Mjc4NCwuOTQ5MzUsLjg5MzY0LC45MjI0MSwuODkwNzMsLjkwNzA2LC45ODQ3MiwuODUyODMsLjg1MjgzLDEuMDY2NCwxLjAyMDU4LC43NDUwNSwuOTIxOSwuNzQ1MDUsMS4yMzQ1NiwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIyNDEsLjc0NTA1LC43NDUwNSwxLjAyMDU4LDEuMDIwNTgsMS4wMjA1OCwuNzMwMDIsLjcyNjAxLC45MTc1NSwuODEyNiwuODAzMTQsLjkyMjIyLC43Mzc2NCwuNzk3MjYsLjgzMDUxLC45MDI4NCwuODYwMjMsLjc0LC44MTI2LC44NDg2OSwuOTY1MTgsLjkxMTE1LC44ODU4LC43OTc2MSwuODg1OCwuNzQ0OTgsLjczOTE0LC44MTM2MywuODk1OTEsLjgzNjU5LC44OTYzMywuODU2MDgsLjgxMTEsLjkwNTMxLDEuMDIyMiwxLjIyNzM2LDEuMDIyMiwxLjI3MDE0LC44OTkwMywuOTAwODgsLjg2NjY3LDEuMDIzMSwuODk2LDEuMDE0MTEsLjkwMDgzLDEuMDUwOTksMS4wMDUxMiwuOTk3OTMsMS4wNTMyNiwxLjA5Mzc3LC45MzgsMS4wNjIyNiwxLjAwMTE5LC45OTc5MywuOTg3MTQsMS4wMjMxLDEuMDEyMzEsLjk4MTk2LC43OTIsMS4xOTEzNywuOTkwNzQsLjk2MiwxLjAxOTE1LC45MjYsLjk0MiwuODU2LC44NTAzNCwuOTIwMDYsLjg1MDM0LDEuMDIwNTgsLjY5MDY3LC45MjI0MSwuOTIyNDEsLjkyMjQxLC45MjI0MSwuOTIwMDYsLjkzMzIsLjkwMDg4LC45MTg4MiwuOTM0ODQsLjc1MzM5LDEuMDIwNTgsLjU2ODY2LC41NDMyNCwuNzk1MTksMS4wODU5NSwxLDEsLjkwMDg4LDEsLjk1MzI1LC43NDUwNSwuOTAwODgsMSwuOTcxOTgsLjc1MzM5LC45MTAwOSwuOTEwMDksLjkxMDA5LC42NjQ2NiwuOTE3NTUsLjkxNzU1LC45MTc1NSwuOTE3NTUsLjkxNzU1LC45MTc1NSwuNzg4LC44MDMxNCwuNzM3NjQsLjczNzY0LC43Mzc2NCwuNzM3NjQsLjg2MDIzLC44NjAyMywuODYwMjMsLjg2MDIzLC45MjkxNSwuOTExMTUsLjg4NTgsLjg4NTgsLjg4NTgsLjg4NTgsLjg4NTgsMS4wMjA1OCwuODg1OCwuODk1OTEsLjg5NTkxLC44OTU5MSwuODk1OTEsLjgxMTEsLjc5NjExLC44OTcxMywuODY2NjcsLjg2NjY3LC44NjY2NywuODY2NjcsLjg2NjY3LC44NjY2NywuODY5MzYsLjg5NiwuOTAwODMsLjkwMDgzLC45MDA4MywuOTAwODMsLjg0MjI0LC44NDIyNCwuODQyMjQsLjg0MjI0LC45NzI3NiwuOTk3OTMsLjk4NzE0LC45ODcxNCwuOTg3MTQsLjk4NzE0LC45ODcxNCwxLjA4NTk1LC44OTg3NiwuOTkwNzQsLjk5MDc0LC45OTA3NCwuOTkwNzQsLjk0MiwxLjAyMzEsLjk0MiwuOTE3NTUsLjg2NjY3LC45MTc1NSwuODY2NjcsLjkxNzU1LC44NjY2NywuODAzMTQsLjg5NiwuODAzMTQsLjg5NiwuODAzMTQsLjg5NiwuODAzMTQsLjg5NiwuOTIyMjIsLjkzMzcyLC45MjkxNSwxLjAxNDExLC43Mzc2NCwuOTAwODMsLjczNzY0LC45MDA4MywuNzM3NjQsLjkwMDgzLC43Mzc2NCwuOTAwODMsLjczNzY0LC45MDA4MywuODMwNTEsMS4wMDUxMiwuODMwNTEsMS4wMDUxMiwuODMwNTEsMS4wMDUxMiwxLDEsLjkwMjg0LC45OTc5MywuOTA5NzYsLjk5NzkzLC44NjAyMywuODQyMjQsLjg2MDIzLC44NDIyNCwuODYwMjMsLjg0MjI0LC44NjAyMywxLjA1MzI2LC44NjAyMywuODQyMjQsLjgyODczLDEuMDc0NjksLjc0LDEuMDkzNzcsMSwxLC45MzgsLjg0ODY5LDEuMDYyMjYsMSwxLC44NDg2OSwuODM3MDQsLjg0ODY5LC44MTQ0MSwuODU1ODgsMS4wODkyNywuOTExMTUsLjk5NzkzLDEsMSwuOTExMTUsLjk5NzkzLC45MTg4NywuOTA5OTEsLjk5NzkzLC44ODU4LC45ODcxNCwuODg1OCwuOTg3MTQsLjg4NTgsLjk4NzE0LC44OTQsLjkxNDM0LC43NDQ5OCwuOTgxOTYsMSwxLC43NDQ5OCwuOTgxOTYsLjczOTE0LC43OTIsLjczOTE0LC43OTIsMSwxLC43MzkxNCwuNzkyLDEsMSwuODEzNjMsLjkwNCwuODEzNjMsMS4xOTEzNywuODk1OTEsLjk5MDc0LC44OTU5MSwuOTkwNzQsLjg5NTkxLC45OTA3NCwuODk1OTEsLjk5MDc0LC44OTU5MSwuOTkwNzQsLjg5NTkxLC45OTA3NCwuODk2MzMsMS4wMTkxNSwuODExMSwuOTQyLC44MTExLC45MDUzMSwuODU2LC45MDUzMSwuODU2LC45MDUzMSwuODU2LDEsLjkyMjQxLC45MTc1NSwuODY2NjcsLjc4OCwuODY5MzYsLjg4NTgsLjg5ODc2LDEsMSwuODEzNjMsMS4xOTEzNywuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAwODgsLjkwMDg4LC45MDA4OCwuOTAzODgsMS4wMzkwMSwuOTIxMzgsLjc4MTA1LC43MTU0LC44NjE2OSwuODA1MTMsLjk0MDA3LC44MjUyOCwuOTg2MTIsMS4wNjIyNiwuOTE3NTUsLjgxMjYsLjgxODg0LC45MjgxOSwuNzM3NjQsLjkwNTMxLC45MDI4NCwuODg1OCwuODYwMjMsLjgxMjYsLjkxMTcyLC45NjUxOCwuOTExMTUsLjgzMDg5LC44ODU4LC44Nzc5MSwuNzk3NjEsLjg5Mjk3LC44MTM2MywuODgxNTcsLjg5OTkyLC44NTYwOCwuODE5OTIsLjk0MzA3LC44NjAyMywuODgxNTcsLjk1MzA4LC45ODY5OSwuOTk3OTMsMS4wNjIyNiwuOTU4MTcsLjk1MzA4LC45NzM1OCwuOTI4LC45ODA4OCwuOTg2OTksLjkyNzYxLC45OTc5MywuOTYwMTcsMS4wNjIyNiwuOTg2LC45NDQsLjk1OTc4LC45MzgsLjk2NzA1LC45ODcxNCwuODA0NDIsLjk4OTcyLDEsLjg5NzYyLDEuMDQ1NTIsLjk1ODE3LC45OTAwNywuODcwNjQsLjkxODc5LC44ODg4OCwxLjA2MjI2LC45NTgxNywuOTg3MTQsLjk1ODE3LC44ODg4OCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC44OTYzMywxLjAxOTE1LC44OTYzMywxLjAxOTE1LC44OTYzMywxLjAxOTE1LC44MTExLC45NDIsLjkyMTksMSwuODk5MDMsMSwxLDEsLjkzMTczLC45MzE3MywuOTMxNzMsMSwxLjA2MzA0LDEuMDYzMDQsMS4wNjkwNCwuODk5MDMsLjg5OTAzLC44MDU0OSwxLDEuMTU2LDEsMSwuNzY1NzUsLjc2NTc1LDEsMSwuNzI0NTgsMSwxLDEsMSwuOTIyNDEsMSwxLDEsLjYxOSwxLDEuMzYxNDUsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDcyNTcsMSwuNzQ3MDUsLjcxMTE5LDEuMDIwNTgsMS4wMjQsMS4wMjExOSwxLDEsMS4xNTM2LDEuMDg1OTUsMS4wODU5NSwxLDEuMDg1OTUsMS4wODU5NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDU2MzgsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sZXM9e2xpbmVIZWlnaHQ6MS4yLGxpbmVHYXA6LjJ9LHRzPVsxLjc2NzM4LDEsMSwuOTkyOTcsLjk4MjQsMS4wNDAxNiwxLjA2NDk3LDEuMDM0MjQsLjk3NTI5LDEuMTc2NDcsMS4yMzIwMywxLjEwODUsMS4xMDg1LDEuMTY5MzksMS4yMTA3LC45NzU0LDEuMjE0MDgsLjk3NTQsMS41OTU3OCwxLjAzNDI0LDEuMDM0MjQsMS4wMzQyNCwxLjAzNDI0LDEuMDM0MjQsMS4wMzQyNCwxLjAzNDI0LDEuMDM0MjQsMS4wMzQyNCwxLjAzNDI0LC44MTM3OCwuODEzNzgsMS4yMTA3LDEuMjEwNywxLjIxMDcsLjcxNzAzLC45Nzg0NywuOTczNjMsLjg4Nzc2LC44NjQxLDEuMDIwOTYsLjc5Nzk1LC44NTEzMiwuOTE0LDEuMDYwODUsMS4xNDA2LC44MDA3LC44OTg1OCwuODM2OTMsMS4xNDg4OSwxLjA5Mzk4LC45NzQ4OSwuOTIwOTQsLjk3NDg5LC45MDM5OSwuODQwNDEsLjk1OTIzLDEuMDAxMzUsMSwxLjA2NDY3LC45ODI0MywuOTA5OTYsLjk5MzYxLDEuMTA4NSwxLjU2OTQyLDEuMTA4NSwxLjIxMDcsLjc0NjI3LC45NDI4MiwuOTY3NTIsMS4wMTUxOSwuODYzMDQsMS4wMTM1OSwuOTcyNzgsMS4xNTEwMywxLjAxMzU5LC45ODU2MSwxLjAyMjg1LDEuMDIyODUsMS4wMDUyNywxLjAyMjg1LDEuMDMwMiwuOTkwNDEsMS4wMDA4LDEuMDE1MTksMS4wMTM1OSwxLjAyMjU4LC43OTEwNCwxLjE2ODYyLC45OTA0MSwuOTc0NTQsMS4wMjUxMSwuOTkyOTgsLjk2NzUyLC45NTgwMSwuOTQ4NTYsMS4xNjU3OSwuOTQ4NTYsMS4yMTA3LC45ODI0LDEuMDM0MjQsMS4wMzQyNCwxLDEuMDM0MjQsMS4xNjU3OSwuODcyNywxLjM4NzEsMS4xODYyMiwxLjEwODE4LDEuMDQ0NzgsMS4yMTA3LDEuMTg2MjIsLjc1MTU1LC45NDk5NCwxLjI4ODI2LDEuMjE0MDgsMS4yMTQwOCwuOTEwNTYsMSwuOTE1NzIsLjk3NTQsLjY0NjYzLDEuMTgzMjgsMS4yNDg2NiwxLjA0NDc4LDEuMTQxNjksMS4xNTc0OSwxLjE3Mzg5LC43MTcwMywuOTczNjMsLjk3MzYzLC45NzM2MywuOTczNjMsLjk3MzYzLC45NzM2MywuOTM1MDYsLjg2NDEsLjc5Nzk1LC43OTc5NSwuNzk3OTUsLjc5Nzk1LDEuMTQwNiwxLjE0MDYsMS4xNDA2LDEuMTQwNiwxLjAyMDk2LDEuMDkzOTgsLjk3NDI2LC45NzQyNiwuOTc0MjYsLjk3NDI2LC45NzQyNiwxLjIxMDcsLjk3NDg5LDEuMDAxMzUsMS4wMDEzNSwxLjAwMTM1LDEuMDAxMzUsLjkwOTk2LC45MjA5NCwxLjAyNzk4LC45Njc1MiwuOTY3NTIsLjk2NzUyLC45Njc1MiwuOTY3NTIsLjk2NzUyLC45MzEzNiwuODYzMDQsLjk3Mjc4LC45NzI3OCwuOTcyNzgsLjk3Mjc4LDEuMDIyODUsMS4wMjI4NSwxLjAyMjg1LDEuMDIyODUsLjk3MTIyLC45OTA0MSwxLDEsMSwxLDEsMS4yODgyNiwxLjAwMDgsLjk5MDQxLC45OTA0MSwuOTkwNDEsLjk5MDQxLC45Njc1MiwxLjAxNTE5LC45Njc1MiwuOTczNjMsLjk2NzUyLC45NzM2MywuOTY3NTIsLjk3MzYzLC45Njc1MiwuODY0MSwuODYzMDQsLjg2NDEsLjg2MzA0LC44NjQxLC44NjMwNCwuODY0MSwuODYzMDQsMS4wMjA5NiwxLjAzMDU3LDEuMDIwOTYsMS4wMzUxNywuNzk3OTUsLjk3Mjc4LC43OTc5NSwuOTcyNzgsLjc5Nzk1LC45NzI3OCwuNzk3OTUsLjk3Mjc4LC43OTc5NSwuOTcyNzgsLjkxNCwxLjAxMzU5LC45MTQsMS4wMTM1OSwuOTE0LDEuMDEzNTksMSwxLDEuMDYwODUsLjk4NTYxLDEuMDYwODUsMS4wMDg3OSwxLjE0MDYsMS4wMjI4NSwxLjE0MDYsMS4wMjI4NSwxLjE0MDYsMS4wMjI4NSwxLjE0MDYsMS4wMjI4NSwxLjE0MDYsMS4wMjI4NSwuOTcxMzgsMS4wODY5MiwuODAwNywxLjAyMjg1LDEsMSwxLjAwNTI3LC44MzY5MywxLjAyMjg1LDEsMSwuODM2OTMsLjk0NTUsLjgzNjkzLC45MDQxOCwuODM2OTMsMS4xMzAwNSwxLjA5Mzk4LC45OTA0MSwxLDEsMS4wOTM5OCwuOTkwNDEsLjk2NjkyLDEuMDkyNTEsLjk5MDQxLC45NzQ4OSwxLjAwMDgsLjk3NDg5LDEuMDAwOCwuOTc0ODksMS4wMDA4LC45Mzk5NCwuOTc5MzEsLjkwMzk5LDEuMDIyNTgsMSwxLC45MDM5OSwxLjAyMjU4LC44NDA0MSwuNzkxMDQsLjg0MDQxLC43OTEwNCwuODQwNDEsLjc5MTA0LC44NDA0MSwuNzkxMDQsMSwxLC45NTkyMywxLjA3MDM0LC45NTkyMywxLjE2ODYyLDEuMDAxMzUsLjk5MDQxLDEuMDAxMzUsLjk5MDQxLDEuMDAxMzUsLjk5MDQxLDEuMDAxMzUsLjk5MDQxLDEuMDAxMzUsLjk5MDQxLDEuMDAxMzUsLjk5MDQxLDEuMDY0NjcsMS4wMjUxMSwuOTA5OTYsLjk2NzUyLC45MDk5NiwuOTkzNjEsLjk1ODAxLC45OTM2MSwuOTU4MDEsLjk5MzYxLC45NTgwMSwxLjA3NzMzLDEuMDM0MjQsLjk3MzYzLC45Njc1MiwuOTM1MDYsLjkzMTM2LC45NzQ4OSwxLjAwMDgsMSwxLC45NTkyMywxLjE2ODYyLDEuMTUxMDMsMS4xNTEwMywxLjAxMTczLDEuMDM5NTksLjc1OTUzLC44MTM3OCwuNzk5MTIsMS4xNTEwMywxLjIxOTk0LC45NTE2MSwuODc4MTUsMS4wMTE0OSwuODE1MjUsLjc2NzYsLjk4MTY3LDEuMDExMzQsMS4wMjU0NiwuODQwOTcsMS4wMzA4OSwxLjE4MTAyLC45NzM2MywuODg3NzYsLjg1MTM0LC45NzgyNiwuNzk3OTUsLjk5MzYxLDEuMDYwODUsLjk3NDg5LDEuMTQwNiwuODk4NTgsMS4wMzg4LDEuMTQ4ODksMS4wOTM5OCwuODYwMzksLjk3NDg5LDEuMDU5NSwuOTIwOTQsLjk0NzkzLC45NTkyMywuOTA5OTYsLjk5MzQ2LC45ODI0MywxLjAyMTEyLC45NTQ5MywxLjE0MDYsLjkwOTk2LDEuMDM1NzQsMS4wMjU5NywxLjAwMDgsMS4xODEwMiwxLjA2NjI4LDEuMDM1NzQsMS4wMTkyLDEuMDE5MzIsMS4wMDg4NiwuOTc1MzEsMS4wMTA2LDEuMDAwOCwxLjEzMTg5LDEuMTgxMDIsMS4wMjI3NywuOTg2ODMsMS4wMDE2LC45OTU2MSwxLjA3MjM3LDEuMDAwOCwuOTA0MzQsLjk5OTIxLC45MzgwMywuODk2NSwxLjIzMDg1LDEuMDY2MjgsMS4wNDk4MywuOTYyNjgsMS4wNDk5LC45ODQzOSwxLjE4MTAyLDEuMDY2MjgsMS4wMDA4LDEuMDY2MjgsLjk4NDM5LC43OTc5NSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjA5NDY2LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45NzI3OCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjAyMDY1LDEsMSwxLDEsMSwxLDEuMDY0NjcsMS4wMjUxMSwxLjA2NDY3LDEuMDI1MTEsMS4wNjQ2NywxLjAyNTExLC45MDk5NiwuOTY3NTIsMSwxLjIxNDA4LC44OTkwMywxLDEsLjc1MTU1LDEuMDQzOTQsMS4wNDM5NCwxLjA0Mzk0LDEuMDQzOTQsLjk4NjMzLC45ODYzMywuOTg2MzMsLjczMDQ3LC43MzA0NywxLjIwNjQyLC45MTIxMSwxLjI1NjM1LDEuMjIyLDEuMDI5NTYsMS4wMzM3MiwxLjAzMzcyLC45NjAzOSwxLjI0NjMzLDEsMS4xMjQ1NCwuOTM1MDMsMS4wMzQyNCwxLjE5Njg3LDEuMDM0MjQsMSwxLDEsLjc3MSwxLDEsMS4xNTc0OSwxLjE1NzQ5LDEuMTU3NDksMS4xMDk0OCwuODYyNzksLjk0NDM0LC44NjI3OSwuOTQ0MzQsLjg2MTgyLDEsMSwxLjE2ODk3LDEsLjk2MDg1LC45MDEzNywxLjIxMDcsMS4xODQxNiwxLjEzOTczLC42OTgyNSwuOTcxNiwyLjEwMzM5LDEuMjkwMDQsMS4yOTAwNCwxLjIxMTcyLDEuMjkwMDQsMS4yOTAwNCwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuNDI2MDMsMSwuOTk4NjIsLjk5ODYyLDEsLjg3MDI1LC44NzAyNSwuODcwMjUsLjg3MDI1LDEuMTg4NzQsMS40MjYwMywxLDEuNDI2MDMsMS40MjYwMywuOTk4NjIsMSwxLDEsMSwxLDEuMjg4NiwxLjA0MzE1LDEuMTUyOTYsMS4zNDE2MywxLDEsMSwxLjA5MTkzLDEuMDkxOTMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDFdLGlzPXtsaW5lSGVpZ2h0OjEuMzMwMDgsbGluZUdhcDowfSxhcz1bMS43NjczOCwxLDEsLjk4OTQ2LDEuMDM5NTksMS4wNDAxNiwxLjAyODA5LDEuMDM2LC45NzYzOSwxLjEwOTUzLDEuMjMyMDMsMS4xMTE0NCwxLjExMTQ0LDEuMTY5MzksMS4yMTIzNywuOTc1NCwxLjIxMjYxLC45NzU0LDEuNTk3NTQsMS4wMzYsMS4wMzYsMS4wMzYsMS4wMzYsMS4wMzYsMS4wMzYsMS4wMzYsMS4wMzYsMS4wMzYsMS4wMzYsLjgxMzc4LC44MTM3OCwxLjIxMjM3LDEuMjEyMzcsMS4yMTIzNywuNzM1NDEsLjk3ODQ3LC45NzM2MywuODk3MjMsLjg3ODk3LDEuMDQyNiwuNzk0MjksLjg1MjkyLC45MTE0OSwxLjA1ODE1LDEuMTQwNiwuNzk2MzEsLjkwMTI4LC44Mzg1MywxLjA0Mzk2LDEuMTA2MTUsLjk3NTUyLC45NDQzNiwuOTc1NTIsLjg4NjQxLC44MDUyNywuOTYwODMsMS4wMDEzNSwxLDEuMDY3NzcsLjk4MTcsLjkxMTQyLC45OTM2MSwxLjExMTQ0LDEuNTcyOTMsMS4xMTE0NCwxLjIxMjM3LC43NDYyNywxLjMxODE4LDEuMDY1ODUsLjk3MDQyLC44MzA1NSwuOTcwNDIsLjkzNTAzLDEuMTI2MSwuOTcwNDIsLjk3OTIyLDEuMTQyMzYsLjk0NTUyLDEuMDEwNTQsMS4xNDIzNiwxLjAyNDcxLC45NzkyMiwuOTQxNjUsLjk3MDQyLC45NzA0MiwxLjAyNzYsLjc4OTI5LDEuMTI2MSwuOTc5MjIsLjk1ODc0LDEuMDIxOTcsLjk4NTA3LC45Njc1MiwuOTcxNjgsLjk1MTA3LDEuMTY1NzksLjk1MTA3LDEuMjEyMzcsMS4wMzk1OSwxLjAzNiwxLjAzNiwxLDEuMDM2LDEuMTY1NzksLjg3MzU3LDEuMzE4MTgsMS4xODc1NCwxLjI2NzgxLDEuMDUzNTYsMS4yMTIzNywxLjE4NjIyLC43OTQ4NywuOTQ5OTQsMS4yOTAwNCwxLjI0MDQ3LDEuMjQwNDcsMS4zMTgxOCwxLC45MTQ4NCwuOTc1NCwxLjMxODE4LDEuMTM0OSwxLjI0ODY2LDEuMDUzNTYsMS4xMzkzNCwxLjE1NTc0LDEuMTczODksLjczNTQxLC45NzM2MywuOTczNjMsLjk3MzYzLC45NzM2MywuOTczNjMsLjk3MzYzLC45NDM4NSwuODc4OTcsLjc5NDI5LC43OTQyOSwuNzk0MjksLjc5NDI5LDEuMTQwNiwxLjE0MDYsMS4xNDA2LDEuMTQwNiwxLjA0MjYsMS4xMDYxNSwuOTc1NTIsLjk3NTUyLC45NzU1MiwuOTc1NTIsLjk3NTUyLDEuMjEyMzcsLjk3NTUyLDEuMDAxMzUsMS4wMDEzNSwxLjAwMTM1LDEuMDAxMzUsLjkxMTQyLC45NDQzNiwuOTg3MjEsMS4wNjU4NSwxLjA2NTg1LDEuMDY1ODUsMS4wNjU4NSwxLjA2NTg1LDEuMDY1ODUsLjk2NzA1LC44MzA1NSwuOTM1MDMsLjkzNTAzLC45MzUwMywuOTM1MDMsMS4xNDIzNiwxLjE0MjM2LDEuMTQyMzYsMS4xNDIzNiwuOTMxMjUsLjk3OTIyLC45NDE2NSwuOTQxNjUsLjk0MTY1LC45NDE2NSwuOTQxNjUsMS4yOTAwNCwuOTQxNjUsLjk3OTIyLC45NzkyMiwuOTc5MjIsLjk3OTIyLC45Njc1MiwuOTcwNDIsLjk2NzUyLC45NzM2MywxLjA2NTg1LC45NzM2MywxLjA2NTg1LC45NzM2MywxLjA2NTg1LC44Nzg5NywuODMwNTUsLjg3ODk3LC44MzA1NSwuODc4OTcsLjgzMDU1LC44Nzg5NywuODMwNTUsMS4wNDI2LDEuMDAzMywxLjA0MjYsLjk3MDQyLC43OTQyOSwuOTM1MDMsLjc5NDI5LC45MzUwMywuNzk0MjksLjkzNTAzLC43OTQyOSwuOTM1MDMsLjc5NDI5LC45MzUwMywuOTExNDksLjk3MDQyLC45MTE0OSwuOTcwNDIsLjkxMTQ5LC45NzA0MiwxLDEsMS4wNTgxNSwuOTc5MjIsMS4wNTgxNSwuOTc5MjIsMS4xNDA2LDEuMTQyMzYsMS4xNDA2LDEuMTQyMzYsMS4xNDA2LDEuMTQyMzYsMS4xNDA2LDEuMTQyMzYsMS4xNDA2LDEuMTQyMzYsLjk3NDQxLDEuMDQzMDIsLjc5NjMxLDEuMDE1ODIsMSwxLDEuMDEwNTQsLjgzODUzLDEuMTQyMzYsMSwxLC44Mzg1MywxLjA5MTI1LC44Mzg1MywuOTA0MTgsLjgzODUzLDEuMTk1MDgsMS4xMDYxNSwuOTc5MjIsMSwxLDEuMTA2MTUsLjk3OTIyLDEuMDEwMzQsMS4xMDQ2NiwuOTc5MjIsLjk3NTUyLC45NDE2NSwuOTc1NTIsLjk0MTY1LC45NzU1MiwuOTQxNjUsLjkxNjAyLC45MTk4MSwuODg2NDEsMS4wMjc2LDEsMSwuODg2NDEsMS4wMjc2LC44MDUyNywuNzg5MjksLjgwNTI3LC43ODkyOSwuODA1MjcsLjc4OTI5LC44MDUyNywuNzg5MjksMSwxLC45NjA4MywxLjA1NDAzLC45NTkyMywxLjE2ODYyLDEuMDAxMzUsLjk3OTIyLDEuMDAxMzUsLjk3OTIyLDEuMDAxMzUsLjk3OTIyLDEuMDAxMzUsLjk3OTIyLDEuMDAxMzUsLjk3OTIyLDEuMDAxMzUsLjk3OTIyLDEuMDY3NzcsMS4wMjE5NywuOTExNDIsLjk2NzUyLC45MTE0MiwuOTkzNjEsLjk3MTY4LC45OTM2MSwuOTcxNjgsLjk5MzYxLC45NzE2OCwxLjIzMTk5LDEuMDM2LC45NzM2MywxLjA2NTg1LC45NDM4NSwuOTY3MDUsLjk3NTUyLC45NDE2NSwxLDEsLjk2MDgzLDEuMTI2MSwxLjMxODE4LDEuMzE4MTgsMS4zMTgxOCwxLjMxODE4LDEuMzE4MTgsMS4zMTgxOCwxLjMxODE4LDEuMzE4MTgsMS4zMTgxOCwuOTUxNjEsMS4yNzEyNiwxLjAwODExLC44MzI4NCwuNzc3MDIsLjk5MTM3LC45NTI1MywxLjAzNDcsLjg2MTQyLDEuMDcyMDUsMS4xNDIzNiwuOTczNjMsLjg5NzIzLC44Njg2OSwxLjA5ODE4LC43OTQyOSwuOTkzNjEsMS4wNTgxNSwuOTc1NTIsMS4xNDA2LC45MDEyOCwxLjA2NjYyLDEuMDQzOTYsMS4xMDYxNSwuODQ5MTgsLjk3NTUyLDEuMDQ2OTQsLjk0NDM2LC45ODAxNSwuOTYwODMsLjkxMTQyLDEuMDAzNTYsLjk4MTcsMS4wMTk0NSwuOTg5OTksMS4xNDA2LC45MTE0MiwxLjA0OTYxLC45ODk4LDEuMDA2MzksMS4xNDIzNiwxLjA3NTE0LDEuMDQ5NjEsLjk5NjA3LDEuMDI4OTcsMS4wMDgsLjk4OTgsLjk1MTM0LDEuMDA2MzksMS4xMTEyMSwxLjE0MjM2LDEuMDA1MTgsLjk3OTgxLDEuMDIxODYsMSwxLjA4NTc4LC45NDE2NSwuOTkzMTQsLjk4Mzg3LC45MzAyOCwuOTMzNzcsMS4zNTEyNSwxLjA3NTE0LDEuMTA2ODcsLjkzNDkxLDEuMDQyMzIsMS4wMDM1MSwxLjE0MjM2LDEuMDc1MTQsLjk0MTY1LDEuMDc1MTQsMS4wMDM1MSwuNzk0MjksMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wOTA5NywxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwuOTM1MDMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk2NjA5LDEsMSwxLDEsMSwxLDEuMDY3NzcsMS4wMjE5NywxLjA2Nzc3LDEuMDIxOTcsMS4wNjc3NywxLjAyMTk3LC45MTE0MiwuOTY3NTIsMSwxLjIxMjYxLC44OTkwMywxLDEsLjc1MTU1LDEuMDQ3NDUsMS4wNDc0NSwxLjA0NzQ1LDEuMDQzOTQsLjk4NjMzLC45ODYzMywuOTg2MzMsLjcyOTU5LC43Mjk1OSwxLjIwNTAyLC45MTQwNiwxLjI2NTE0LDEuMjIyLDEuMDI5NTYsMS4wMzM3MiwxLjAzMzcyLC45NjAzOSwxLjI0NjMzLDEsMS4wOTEyNSwuOTMzMjcsMS4wMzMzNiwxLjE2NTQxLDEuMDM2LDEsMSwxLC43NzEsMSwxLDEuMTU1NzQsMS4xNTU3NCwxLjE1NTc0LDEuMTU1NzQsLjg2MzY0LC45NDQzNCwuODYyNzksLjk0NDM0LC44NjIyNCwxLDEsMS4xNjc5OCwxLC45NjA4NSwuOTAwNjgsMS4yMTIzNywxLjE4NDE2LDEuMTM5MDQsLjY5ODI1LC45NzE2LDIuMTAzMzksMS4yOTAwNCwxLjI5MDA0LDEuMjEzMzksMS4yOTAwNCwxLjI5MDA0LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS40MjYwMywxLC45OTg2MiwuOTk4NjIsMSwuODcwMjUsLjg3MDI1LC44NzAyNSwuODcwMjUsMS4xODc3NSwxLjQyNjAzLDEsMS40MjYwMywxLjQyNjAzLC45OTg2MiwxLDEsMSwxLDEsMS4yODg2LDEuMDQzMTUsMS4xNTI5NiwxLjM0MTYzLDEsMSwxLDEuMTMyNjksMS4xMzI2OSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sc3M9e2xpbmVIZWlnaHQ6MS4zMzAwOCxsaW5lR2FwOjB9LHJzPVsxLjc2NzM4LDEsMSwuOTg5NDYsMS4xNDc2MywxLjA1MzY1LDEuMDYyMzQsLjk2OTI3LC45MjU4NiwxLjE1MzczLDEuMTg0MTQsLjkxMzQ5LC45MTM0OSwxLjA3NDAzLDEuMTczMDgsLjc4MzgzLDEuMjAwODgsLjc4MzgzLDEuNDI1MzEsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC43ODM4MywuNzgzODMsMS4xNzMwOCwxLjE3MzA4LDEuMTczMDgsLjc3MzQ5LC45NDU2NSwuOTQ3MjksLjg1OTQ0LC44ODUwNiwuOTg1OCwuNzQ4MTcsLjgwMDE2LC44ODQ0OSwuOTgwMzksLjk1NzgyLC42OTIzOCwuODk4OTgsLjgzMjMxLC45ODE4MywxLjAzOTg5LC45NjkyNCwuODYyMzcsLjk2OTI0LC44MDU5NSwuNzQ1MjQsLjg2MDkxLC45NTQwMiwuOTQxNDMsLjk4NDQ4LC44ODU4LC44MzA4OSwuOTMyODUsMS4wOTQ5LDEuMzkwMTYsMS4wOTQ5LDEuNDU5OTQsLjc0NjI3LDEuMDQ4MzksLjk3NDU0LC45NzQ1NCwuODcyMDcsLjk3NDU0LC44NzUzMywxLjA2MTUxLC45NzQ1NCwxLjAwMTc2LDEuMTY0ODQsMS4wODEzMiwuOTgwNDcsMS4xNjQ4NCwxLjAyOTg5LDEuMDEwNTQsLjk2MjI1LC45NzQ1NCwuOTc0NTQsMS4wNjU5OCwuNzkwMDQsMS4xNjM0NCwxLjAwMzUxLC45NDYyOSwuOTk3MywuOTEwMTYsLjk2Nzc3LC45MDQzLC45MTA4MiwuOTI0ODEsLjkxMDgyLDEuMTczMDgsLjk1NzQ4LC45NjkyNywuOTY5MjcsMSwuOTY5MjcsLjkyNDgxLC44MDU5NywxLjA0ODM5LDEuMjMzOTMsMS4xNzgxLC45MjQ1LDEuMTczMDgsMS4yMDgwOCwuNjMyMTgsLjk0MjYxLDEuMjQ4MjIsMS4wOTk3MSwxLjA5OTcxLDEuMDQ4MzksMSwuODUyNzMsLjc4MDMyLDEuMDQ4MzksMS4wOTk3MSwxLjIyMzI2LC45MjQ1LDEuMDk4MzYsMS4xMzUyNSwxLjE1MjIyLC43MDQyNCwuOTQ3MjksLjk0NzI5LC45NDcyOSwuOTQ3MjksLjk0NzI5LC45NDcyOSwuODU0OTgsLjg4NTA2LC43NDgxNywuNzQ4MTcsLjc0ODE3LC43NDgxNywuOTU3ODIsLjk1NzgyLC45NTc4MiwuOTU3ODIsLjk4NTgsMS4wMzk4OSwuOTY5MjQsLjk2OTI0LC45NjkyNCwuOTY5MjQsLjk2OTI0LDEuMTczMDgsLjk2OTI0LC45NTQwMiwuOTU0MDIsLjk1NDAyLC45NTQwMiwuODMwODksLjg2MjM3LC44ODQwOSwuOTc0NTQsLjk3NDU0LC45NzQ1NCwuOTc0NTQsLjk3NDU0LC45NzQ1NCwuOTI5MTYsLjg3MjA3LC44NzUzMywuODc1MzMsLjg3NTMzLC44NzUzMywuOTMxNDYsLjkzMTQ2LC45MzE0NiwuOTMxNDYsLjkzODU0LDEuMDEwNTQsLjk2MjI1LC45NjIyNSwuOTYyMjUsLjk2MjI1LC45NjIyNSwxLjI0ODIyLC44NzYxLDEuMDAzNTEsMS4wMDM1MSwxLjAwMzUxLDEuMDAzNTEsLjk2Nzc3LC45NzQ1NCwuOTY3NzcsLjk0NzI5LC45NzQ1NCwuOTQ3MjksLjk3NDU0LC45NDcyOSwuOTc0NTQsLjg4NTA2LC44NzIwNywuODg1MDYsLjg3MjA3LC44ODUwNiwuODcyMDcsLjg4NTA2LC44NzIwNywuOTg1OCwuOTUzOTEsLjk4NTgsLjk3NDU0LC43NDgxNywuODc1MzMsLjc0ODE3LC44NzUzMywuNzQ4MTcsLjg3NTMzLC43NDgxNywuODc1MzMsLjc0ODE3LC44NzUzMywuODg0NDksLjk3NDU0LC44ODQ0OSwuOTc0NTQsLjg4NDQ5LC45NzQ1NCwxLDEsLjk4MDM5LDEuMDAxNzYsLjk4MDM5LDEuMDAxNzYsLjk1NzgyLC45MzE0NiwuOTU3ODIsLjkzMTQ2LC45NTc4MiwuOTMxNDYsLjk1NzgyLDEuMTY0ODQsLjk1NzgyLC45MzE0NiwuODQ0MjEsMS4xMjc2MSwuNjkyMzgsMS4wODEzMiwxLDEsLjk4MDQ3LC44MzIzMSwxLjE2NDg0LDEsMSwuODQ3MjMsMS4wNDg2MSwuODQ3MjMsLjc4NzU1LC44MzIzMSwxLjIzNzM2LDEuMDM5ODksMS4wMTA1NCwxLDEsMS4wMzk4OSwxLjAxMDU0LC45ODU3LDEuMDM4NDksMS4wMTA1NCwuOTY5MjQsLjk2MjI1LC45NjkyNCwuOTYyMjUsLjk2OTI0LC45NjIyNSwuOTIzODMsLjkwMTcxLC44MDU5NSwxLjA2NTk4LDEsMSwuODA1OTUsMS4wNjU5OCwuNzQ1MjQsLjc5MDA0LC43NDUyNCwuNzkwMDQsLjc0NTI0LC43OTAwNCwuNzQ1MjQsLjc5MDA0LDEsMSwuODYwOTEsMS4wMjc1OSwuODU3NzEsMS4xNjM0NCwuOTU0MDIsMS4wMDM1MSwuOTU0MDIsMS4wMDM1MSwuOTU0MDIsMS4wMDM1MSwuOTU0MDIsMS4wMDM1MSwuOTU0MDIsMS4wMDM1MSwuOTU0MDIsMS4wMDM1MSwuOTg0NDgsLjk5NzMsLjgzMDg5LC45Njc3NywuODMwODksLjkzMjg1LC45MDQzLC45MzI4NSwuOTA0MywuOTMyODUsLjkwNDMsMS4zMTg2OCwuOTY5MjcsLjk0NzI5LC45NzQ1NCwuODU0OTgsLjkyOTE2LC45NjkyNCwuODc2MSwxLDEsLjg2MDkxLDEuMTYzNDQsMS4wNDgzOSwxLjA0ODM5LDEuMDQ4MzksMS4wNDgzOSwxLjA0ODM5LDEuMDQ4MzksMS4wNDgzOSwxLjA0ODM5LDEuMDQ4MzksLjgxOTY1LC44MTk2NSwuOTQ3MjksLjc4MDMyLC43MTAyMiwuOTA4ODMsLjg0MTcxLC45OTg3NywuNzc1OTYsMS4wNTczNCwxLjIsLjk0NzI5LC44NTk0NCwuODI3OTEsLjk2MDcsLjc0ODE3LC45MzI4NSwuOTgwMzksLjk2OTI0LC45NTc4MiwuODk4OTgsLjk4MzE2LC45ODE4MywxLjAzOTg5LC43ODYxNCwuOTY5MjQsLjk3NjQyLC44NjIzNywuODYwNzUsLjg2MDkxLC44MzA4OSwuOTAwODIsLjg4NTgsLjk3Mjk2LDEuMDEyODQsLjk1NzgyLC44MzA4OSwxLjA5NzYsMS4wNCwxLjAzMzQyLDEuMiwxLjA2NzUsMS4wOTc2LC45ODIwNSwxLjAzODA5LDEuMDUwOTcsMS4wNCwuOTUzNjQsMS4wMzM0MiwxLjA1NDAxLDEuMiwxLjAyMTQ4LDEuMDExOSwxLjA0NzI0LDEuMDEyNywxLjAyNzMyLC45NjIyNSwuODk2NSwuOTc3ODMsLjkzNTc0LC45NDgxOCwxLjMwNjc5LDEuMDY3NSwxLjExODI2LC45OTgyMSwxLjA1NTcsMS4wMzI2LDEuMiwxLjA2NzUsLjk2MjI1LDEuMDY3NSwxLjAzMjYsLjc0ODE3LDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDM3NTQsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjg3NTMzLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLC45ODcwNSwxLDEsMSwxLDEsMSwuOTg0NDgsLjk5NzMsLjk4NDQ4LC45OTczLC45ODQ0OCwuOTk3MywuODMwODksLjk2Nzc3LDEsMS4yMDA4OCwuODk5MDMsMSwxLC43NTE1NSwuOTQ5NDUsLjk0OTQ1LC45NDk0NSwuOTQ5NDUsMS4xMjMxNywxLjEyMzE3LDEuMTIzMTcsLjY3NjAzLC42NzYwMywxLjE1NjIxLC43MzU4NCwxLjIxMTkxLDEuMjIxMzUsMS4wNjQ4MywuOTQ4NjgsLjk0ODY4LC45NTk5NiwxLjI0NjMzLDEsMS4wNzQ5NywuODc3MDksLjk2OTI3LDEuMDE0NzMsLjk2OTI3LDEsMSwxLC43NzI5NSwxLDEsMS4wOTgzNiwxLjA5ODM2LDEuMDk4MzYsMS4wMTUyMiwuODYzMjEsLjk0NDM0LC44NjQ5LC45NDQzNCwuODYxODIsMSwxLDEuMDgzLDEsLjkxNTc4LC44NjQzOCwxLjE3MzA4LDEuMTg0MTYsMS4xNDU4OSwuNjk4MjUsLjk3NjIyLDEuOTY3OTEsMS4yNDgyMiwxLjI0ODIyLDEuMTczMDgsMS4yNDgyMiwxLjI0ODIyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS40MjYwMywxLC45OTg2MiwuOTk4NjIsMSwuODcwMjUsLjg3MDI1LC44NzAyNSwuODcwMjUsMS4xNzk4NCwxLjQyNjAzLDEsMS40MjYwMywxLjQyNjAzLC45OTg2MiwxLDEsMSwxLDEsMS4yODg2LDEuMDQzMTUsMS4xNTI5NiwxLjM0MTYzLDEsMSwxLDEuMTA3NDIsMS4xMDc0MiwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMV0sbnM9e2xpbmVIZWlnaHQ6MS4zMzAwOCxsaW5lR2FwOjB9LG9zPVsxLjc2NzM4LDEsMSwuOTg1OTQsMS4wMjI4NSwxLjEwNDU0LDEuMDYyMzQsLjk2OTI3LC45MjAzNywxLjE5OTg1LDEuMjA0NiwuOTA2MTYsLjkwNjE2LDEuMDcxNTIsMS4xNzE0LC43ODAzMiwxLjIwMDg4LC43ODAzMiwxLjQwMjQ2LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuOTY5MjcsLjk2OTI3LC45NjkyNywuNzgwMzIsLjc4MDMyLDEuMTcxNCwxLjE3MTQsMS4xNzE0LC44MDU5NywuOTQwODQsLjk2NzA2LC44NTk0NCwuODU3MzQsLjk3MDkzLC43NTg0MiwuNzk5MzYsLjg4MTk4LC45ODMxLC45NTc4MiwuNzEzODcsLjg2OTY5LC44NDYzNiwxLjA3Nzk2LDEuMDM1ODQsLjk2OTI0LC44Mzk2OCwuOTY5MjQsLjgyODI2LC43OTY0OSwuODU3NzEsLjk1MTMyLC45MzExOSwuOTg5NjUsLjg4NDMzLC44Mjg3LC45MzM2NSwxLjA4NjEyLDEuMzYzOCwxLjA4NjEyLDEuNDU3ODYsLjc0NjI3LC44MDQ5OSwuOTE0ODQsMS4wNTcwNywuOTIzODMsMS4wNTg4MiwuOTQwMywxLjEyNjU0LDEuMDU4ODIsMS4wMTc1NiwxLjA5MDExLDEuMDkwMTEsLjk5NDE0LDEuMDkwMTEsMS4wMzQsMS4wMTc1NiwxLjA1MzU2LDEuMDU3MDcsMS4wNTg4MiwxLjA0Mzk5LC44NDg2MywxLjIxOTY4LDEuMDE3NTYsLjk1ODAxLDEuMDAwNjgsLjkxNzk3LC45Njc3NywuOTA0MywuOTAzNTEsLjkyMTA1LC45MDM1MSwxLjE3MTQsLjg1MzM3LC45NjkyNywuOTY5MjcsLjk5OTEyLC45NjkyNywuOTIxMDUsLjgwNTk3LDEuMjQzNCwxLjIwODA4LDEuMDU5MzcsLjkwOTU3LDEuMTcxNCwxLjIwODA4LC43NTE1NSwuOTQyNjEsMS4yNDY0NCwxLjA5OTcxLDEuMDk5NzEsLjg0NzUxLDEsLjg1MjczLC43ODAzMiwuNjE1ODQsMS4wNTQyNSwxLjE3OTE0LC45MDk1NywxLjA4NjY1LDEuMTE1OTMsMS4xNDE2OSwuNzMzODEsLjk2NzA2LC45NjcwNiwuOTY3MDYsLjk2NzA2LC45NjcwNiwuOTY3MDYsLjg2MDM1LC44NTczNCwuNzU4NDIsLjc1ODQyLC43NTg0MiwuNzU4NDIsLjk1NzgyLC45NTc4MiwuOTU3ODIsLjk1NzgyLC45NzA5MywxLjAzNTg0LC45NjkyNCwuOTY5MjQsLjk2OTI0LC45NjkyNCwuOTY5MjQsMS4xNzE0LC45NjkyNCwuOTUxMzIsLjk1MTMyLC45NTEzMiwuOTUxMzIsLjgyODcsLjgzOTY4LC44OTA0OSwuOTE0ODQsLjkxNDg0LC45MTQ4NCwuOTE0ODQsLjkxNDg0LC45MTQ4NCwuOTM1NzUsLjkyMzgzLC45NDAzLC45NDAzLC45NDAzLC45NDAzLC44NzE3LC44NzE3LC44NzE3LC44NzE3LDEuMDA1MjcsMS4wMTc1NiwxLjA1MzU2LDEuMDUzNTYsMS4wNTM1NiwxLjA1MzU2LDEuMDUzNTYsMS4yNDY0NCwuOTU5MjMsMS4wMTc1NiwxLjAxNzU2LDEuMDE3NTYsMS4wMTc1NiwuOTY3NzcsMS4wNTcwNywuOTY3NzcsLjk2NzA2LC45MTQ4NCwuOTY3MDYsLjkxNDg0LC45NjcwNiwuOTE0ODQsLjg1NzM0LC45MjM4MywuODU3MzQsLjkyMzgzLC44NTczNCwuOTIzODMsLjg1NzM0LC45MjM4MywuOTcwOTMsMS4wOTY5LC45NzA5MywxLjA1ODgyLC43NTg0MiwuOTQwMywuNzU4NDIsLjk0MDMsLjc1ODQyLC45NDAzLC43NTg0MiwuOTQwMywuNzU4NDIsLjk0MDMsLjg4MTk4LDEuMDU4ODIsLjg4MTk4LDEuMDU4ODIsLjg4MTk4LDEuMDU4ODIsMSwxLC45ODMxLDEuMDE3NTYsLjk4MzEsMS4wMTc1NiwuOTU3ODIsLjg3MTcsLjk1NzgyLC44NzE3LC45NTc4MiwuODcxNywuOTU3ODIsMS4wOTAxMSwuOTU3ODIsLjg3MTcsLjg0Nzg0LDEuMTE1NTEsLjcxMzg3LDEuMDkwMTEsMSwxLC45OTQxNCwuODQ2MzYsMS4wOTAxMSwxLDEsLjg0NjM2LDEuMDUzNiwuODQ2MzYsLjk0Mjk4LC44NDYzNiwxLjIzMjk3LDEuMDM1ODQsMS4wMTc1NiwxLDEsMS4wMzU4NCwxLjAxNzU2LDEuMDAzMjMsMS4wMzQ0NCwxLjAxNzU2LC45NjkyNCwxLjA1MzU2LC45NjkyNCwxLjA1MzU2LC45NjkyNCwxLjA1MzU2LC45MzA2NiwuOTgyOTMsLjgyODI2LDEuMDQzOTksMSwxLC44MjgyNiwxLjA0Mzk5LC43OTY0OSwuODQ4NjMsLjc5NjQ5LC44NDg2MywuNzk2NDksLjg0ODYzLC43OTY0OSwuODQ4NjMsMSwxLC44NTc3MSwxLjE3MzE4LC44NTc3MSwxLjIxOTY4LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45NTEzMiwxLjAxNzU2LC45ODk2NSwxLjAwMDY4LC44Mjg3LC45Njc3NywuODI4NywuOTMzNjUsLjkwNDMsLjkzMzY1LC45MDQzLC45MzM2NSwuOTA0MywxLjA4NTcxLC45NjkyNywuOTY3MDYsLjkxNDg0LC44NjAzNSwuOTM1NzUsLjk2OTI0LC45NTkyMywxLDEsLjg1NzcxLDEuMjE5NjgsMS4xMTQzNywxLjExNDM3LC45MzEwOSwuOTEyMDIsLjYwNDExLC44NDE2NCwuNTU1NzIsMS4wMTE3MywuOTczNjEsLjgxODE4LC44MTgxOCwuOTY2MzUsLjc4MDMyLC43MjcyNywuOTIzNjYsLjk4NjAxLDEuMDM0MDUsLjc3OTY4LDEuMDk3OTksMS4yLC45NjcwNiwuODU5NDQsLjg1NjM4LC45NjQ5MSwuNzU4NDIsLjkzMzY1LC45ODMxLC45NjkyNCwuOTU3ODIsLjg2OTY5LC45NDE1MiwxLjA3Nzk2LDEuMDM1ODQsLjc4NDM3LC45NjkyNCwuOTg3MTUsLjgzOTY4LC44MzQ5MSwuODU3NzEsLjgyODcsLjk0NDkyLC44ODQzMywuOTI4NywxLjAwOTgsLjk1NzgyLC44Mjg3LDEuMDYyNSwuOTgyNDgsMS4wMzQyNCwxLjIsMS4wMTA3MSwxLjA2MjUsLjk1MjQ2LDEuMDM4MDksMS4wNDkxMiwuOTgyNDgsMS4wMDIyMSwxLjAzNDI0LDEuMDU0NDMsMS4yLDEuMDQ3ODUsLjk5NjA5LDEuMDAxNjksMS4wNTE3NiwuOTkzNDYsMS4wNTM1NiwuOTA4NywxLjAzMDA0LC45NTU0MiwuOTMxMTcsMS4yMzM2MiwxLjAxMDcxLDEuMDc4MzEsMS4wMjUxMiwxLjA1MjA1LDEuMDM1MDIsMS4yLDEuMDEwNzEsMS4wNTM1NiwxLjAxMDcxLDEuMDM1MDIsLjc1ODQyLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEuMDM3MTksMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsLjk0MDMsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMS4wNDAyMSwxLDEsMSwxLDEsMSwuOTg5NjUsMS4wMDA2OCwuOTg5NjUsMS4wMDA2OCwuOTg5NjUsMS4wMDA2OCwuODI4NywuOTY3NzcsMSwxLjIwMDg4LC44OTkwMywxLDEsLjc1MTU1LDEuMDMwNzcsMS4wMzA3NywxLjAzMDc3LDEuMDMwNzcsMS4xMzE5NiwxLjEzMTk2LDEuMTMxOTYsLjY3NDI4LC42NzQyOCwxLjE2MDM5LC43MzI5MSwxLjIwOTk2LDEuMjIxMzUsMS4wNjQ4MywuOTQ4NjgsLjk0ODY4LC45NTk5NiwxLjI0NjMzLDEsMS4wNzQ5NywuODc3OTYsLjk2OTI3LDEuMDE1MTgsLjk2OTI3LDEsMSwxLC43NzI5NSwxLDEsMS4xMDUzOSwxLjEwNTM5LDEuMTEzNTgsMS4wNjk2NywuODYyNzksLjk0NDM0LC44NjI3OSwuOTQ0MzQsLjg2MTgyLDEsMSwxLjA4MywxLC45MTU3OCwuODY1MDcsMS4xNzE0LDEuMTg0MTYsMS4xNDU4OSwuNjk4MjUsLjk3NjIyLDEuOTY5NywxLjI0ODIyLDEuMjQ4MjIsMS4xNzIzOCwxLjI0ODIyLDEuMjQ4MjIsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxLjQyNjAzLDEsLjk5ODYyLC45OTg2MiwxLC44NzAyNSwuODcwMjUsLjg3MDI1LC44NzAyNSwxLjE4MDgzLDEuNDI2MDMsMSwxLjQyNjAzLDEuNDI2MDMsLjk5ODYyLDEsMSwxLDEsMSwxLjI4ODYsMS4wNDMxNSwxLjE1Mjk2LDEuMzQxNjMsMSwxLDEsMS4xMDkzOCwxLjEwOTM4LDEsMSwxLDEuMDU0MjUsMS4wOTk3MSwxLjA5OTcxLDEuMDk5NzEsMSwxLDEsMSwxLDEsMSwxLDEsMSwxXSxncz17bGluZUhlaWdodDoxLjMzMDA4LGxpbmVHYXA6MH0sSXM9Z2V0TG9va3VwVGFibGVGYWN0b3J5KChmdW5jdGlvbihlKXtlWyJNeXJpYWRQcm8tUmVndWxhciJdPWVbIlBkZkpTLUZhbGxiYWNrLVJlZ3VsYXIiXT17bmFtZToiTGliZXJhdGlvblNhbnMtUmVndWxhciIsZmFjdG9yczpBcyxiYXNlV2lkdGhzOldhLGJhc2VNYXBwaW5nOmphLG1ldHJpY3M6ZXN9O2VbIk15cmlhZFByby1Cb2xkIl09ZVsiUGRmSlMtRmFsbGJhY2stQm9sZCJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkIixmYWN0b3JzOlhhLGJhc2VXaWR0aHM6dmEsYmFzZU1hcHBpbmc6S2EsbWV0cmljczpaYX07ZVsiTXlyaWFkUHJvLUl0Il09ZVsiTXlyaWFkUHJvLUl0YWxpYyJdPWVbIlBkZkpTLUZhbGxiYWNrLUl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1JdGFsaWMiLGZhY3RvcnM6X2EsYmFzZVdpZHRoczpPYSxiYXNlTWFwcGluZzpQYSxtZXRyaWNzOiRhfTtlWyJNeXJpYWRQcm8tQm9sZEl0Il09ZVsiTXlyaWFkUHJvLUJvbGRJdGFsaWMiXT1lWyJQZGZKUy1GYWxsYmFjay1Cb2xkSXRhbGljIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMiLGZhY3RvcnM6VmEsYmFzZVdpZHRoczpUYSxiYXNlTWFwcGluZzpxYSxtZXRyaWNzOnphfTtlLkFyaWFsTVQ9ZS5BcmlhbD1lWyJBcmlhbC1SZWd1bGFyIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIiLGJhc2VXaWR0aHM6V2EsYmFzZU1hcHBpbmc6amF9O2VbIkFyaWFsLUJvbGRNVCJdPWVbIkFyaWFsLUJvbGQiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZCIsYmFzZVdpZHRoczp2YSxiYXNlTWFwcGluZzpLYX07ZVsiQXJpYWwtSXRhbGljTVQiXT1lWyJBcmlhbC1JdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtSXRhbGljIixiYXNlV2lkdGhzOk9hLGJhc2VNYXBwaW5nOlBhfTtlWyJBcmlhbC1Cb2xkSXRhbGljTVQiXT1lWyJBcmlhbC1Cb2xkSXRhbGljIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMiLGJhc2VXaWR0aHM6VGEsYmFzZU1hcHBpbmc6cWF9O2VbIkNhbGlicmktUmVndWxhciJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyIixmYWN0b3JzOk5hLGJhc2VXaWR0aHM6V2EsYmFzZU1hcHBpbmc6amEsbWV0cmljczpSYX07ZVsiQ2FsaWJyaS1Cb2xkIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGQiLGZhY3RvcnM6d2EsYmFzZVdpZHRoczp2YSxiYXNlTWFwcGluZzpLYSxtZXRyaWNzOmJhfTtlWyJDYWxpYnJpLUl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1JdGFsaWMiLGZhY3RvcnM6U2EsYmFzZVdpZHRoczpPYSxiYXNlTWFwcGluZzpQYSxtZXRyaWNzOmthfTtlWyJDYWxpYnJpLUJvbGRJdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZEl0YWxpYyIsZmFjdG9yczpEYSxiYXNlV2lkdGhzOlRhLGJhc2VNYXBwaW5nOnFhLG1ldHJpY3M6RmF9O2VbIlNlZ29ldWktUmVndWxhciJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1SZWd1bGFyIixmYWN0b3JzOm9zLGJhc2VXaWR0aHM6V2EsYmFzZU1hcHBpbmc6amEsbWV0cmljczpnc307ZVsiU2Vnb2V1aS1Cb2xkIl09e25hbWU6IkxpYmVyYXRpb25TYW5zLUJvbGQiLGZhY3RvcnM6dHMsYmFzZVdpZHRoczp2YSxiYXNlTWFwcGluZzpLYSxtZXRyaWNzOmlzfTtlWyJTZWdvZXVpLUl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1JdGFsaWMiLGZhY3RvcnM6cnMsYmFzZVdpZHRoczpPYSxiYXNlTWFwcGluZzpQYSxtZXRyaWNzOm5zfTtlWyJTZWdvZXVpLUJvbGRJdGFsaWMiXT17bmFtZToiTGliZXJhdGlvblNhbnMtQm9sZEl0YWxpYyIsZmFjdG9yczphcyxiYXNlV2lkdGhzOlRhLGJhc2VNYXBwaW5nOnFhLG1ldHJpY3M6c3N9O2VbIkhlbHZldGljYS1SZWd1bGFyIl09ZS5IZWx2ZXRpY2E9e25hbWU6IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIiLGZhY3RvcnM6SmEsYmFzZVdpZHRoczpXYSxiYXNlTWFwcGluZzpqYSxtZXRyaWNzOllhfTtlWyJIZWx2ZXRpY2EtQm9sZCJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkIixmYWN0b3JzOkdhLGJhc2VXaWR0aHM6dmEsYmFzZU1hcHBpbmc6S2EsbWV0cmljczp4YX07ZVsiSGVsdmV0aWNhLUl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1JdGFsaWMiLGZhY3RvcnM6TGEsYmFzZVdpZHRoczpPYSxiYXNlTWFwcGluZzpQYSxtZXRyaWNzOkhhfTtlWyJIZWx2ZXRpY2EtQm9sZEl0YWxpYyJdPXtuYW1lOiJMaWJlcmF0aW9uU2Fucy1Cb2xkSXRhbGljIixmYWN0b3JzOlVhLGJhc2VXaWR0aHM6VGEsYmFzZU1hcHBpbmc6cWEsbWV0cmljczpNYX19KSk7ZnVuY3Rpb24gZ2V0WGZhRm9udE5hbWUoZSl7Y29uc3QgdD1ub3JtYWxpemVGb250TmFtZShlKTtyZXR1cm4gSXMoKVt0XX1mdW5jdGlvbiBnZXRYZmFGb250RGljdChlKXtjb25zdCB0PWZ1bmN0aW9uIGdldFhmYUZvbnRXaWR0aHMoZSl7Y29uc3QgdD1nZXRYZmFGb250TmFtZShlKTtpZighdClyZXR1cm4gbnVsbDtjb25zdHtiYXNlV2lkdGhzOmksYmFzZU1hcHBpbmc6YSxmYWN0b3JzOnN9PXQscj1zP2kubWFwKCgoZSx0KT0+ZSpzW3RdKSk6aTtsZXQgbixvPS0yO2NvbnN0IGc9W107Zm9yKGNvbnN0W2UsdF1vZiBhLm1hcCgoKGUsdCk9PltlLHRdKSkuc29ydCgoKFtlXSxbdF0pPT5lLXQpKSlpZigtMSE9PWUpaWYoZT09PW8rMSl7bi5wdXNoKHJbdF0pO28rPTF9ZWxzZXtvPWU7bj1bclt0XV07Zy5wdXNoKGUsbil9cmV0dXJuIGd9KGUpLGk9bmV3IERpY3QobnVsbCk7aS5zZXQoIkJhc2VGb250IixOYW1lLmdldChlKSk7aS5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJGb250IikpO2kuc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiQ0lERm9udFR5cGUyIikpO2kuc2V0KCJFbmNvZGluZyIsTmFtZS5nZXQoIklkZW50aXR5LUgiKSk7aS5zZXQoIkNJRFRvR0lETWFwIixOYW1lLmdldCgiSWRlbnRpdHkiKSk7aS5zZXQoIlciLHQpO2kuc2V0KCJGaXJzdENoYXIiLHRbMF0pO2kuc2V0KCJMYXN0Q2hhciIsdC5hdCgtMikrdC5hdCgtMSkubGVuZ3RoLTEpO2NvbnN0IGE9bmV3IERpY3QobnVsbCk7aS5zZXQoIkZvbnREZXNjcmlwdG9yIixhKTtjb25zdCBzPW5ldyBEaWN0KG51bGwpO3Muc2V0KCJPcmRlcmluZyIsIklkZW50aXR5Iik7cy5zZXQoIlJlZ2lzdHJ5IiwiQWRvYmUiKTtzLnNldCgiU3VwcGxlbWVudCIsMCk7aS5zZXQoIkNJRFN5c3RlbUluZm8iLHMpO3JldHVybiBpfWNsYXNzIFBvc3RTY3JpcHRQYXJzZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5sZXhlcj1lO3RoaXMub3BlcmF0b3JzPVtdO3RoaXMudG9rZW49bnVsbDt0aGlzLnByZXY9bnVsbH1uZXh0VG9rZW4oKXt0aGlzLnByZXY9dGhpcy50b2tlbjt0aGlzLnRva2VuPXRoaXMubGV4ZXIuZ2V0VG9rZW4oKX1hY2NlcHQoZSl7aWYodGhpcy50b2tlbi50eXBlPT09ZSl7dGhpcy5uZXh0VG9rZW4oKTtyZXR1cm4hMH1yZXR1cm4hMX1leHBlY3QoZSl7aWYodGhpcy5hY2NlcHQoZSkpcmV0dXJuITA7dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbmV4cGVjdGVkIHN5bWJvbDogZm91bmQgJHt0aGlzLnRva2VuLnR5cGV9IGV4cGVjdGVkICR7ZX0uYCl9cGFyc2UoKXt0aGlzLm5leHRUb2tlbigpO3RoaXMuZXhwZWN0KGNzLkxCUkFDRSk7dGhpcy5wYXJzZUJsb2NrKCk7dGhpcy5leHBlY3QoY3MuUkJSQUNFKTtyZXR1cm4gdGhpcy5vcGVyYXRvcnN9cGFyc2VCbG9jaygpe2Zvcig7OylpZih0aGlzLmFjY2VwdChjcy5OVU1CRVIpKXRoaXMub3BlcmF0b3JzLnB1c2godGhpcy5wcmV2LnZhbHVlKTtlbHNlIGlmKHRoaXMuYWNjZXB0KGNzLk9QRVJBVE9SKSl0aGlzLm9wZXJhdG9ycy5wdXNoKHRoaXMucHJldi52YWx1ZSk7ZWxzZXtpZighdGhpcy5hY2NlcHQoY3MuTEJSQUNFKSlyZXR1cm47dGhpcy5wYXJzZUNvbmRpdGlvbigpfX1wYXJzZUNvbmRpdGlvbigpe2NvbnN0IGU9dGhpcy5vcGVyYXRvcnMubGVuZ3RoO3RoaXMub3BlcmF0b3JzLnB1c2gobnVsbCxudWxsKTt0aGlzLnBhcnNlQmxvY2soKTt0aGlzLmV4cGVjdChjcy5SQlJBQ0UpO2lmKHRoaXMuYWNjZXB0KGNzLklGKSl7dGhpcy5vcGVyYXRvcnNbZV09dGhpcy5vcGVyYXRvcnMubGVuZ3RoO3RoaXMub3BlcmF0b3JzW2UrMV09Imp6In1lbHNle2lmKCF0aGlzLmFjY2VwdChjcy5MQlJBQ0UpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiUFMgRnVuY3Rpb246IGVycm9yIHBhcnNpbmcgY29uZGl0aW9uYWwuIik7e2NvbnN0IHQ9dGhpcy5vcGVyYXRvcnMubGVuZ3RoO3RoaXMub3BlcmF0b3JzLnB1c2gobnVsbCxudWxsKTtjb25zdCBpPXRoaXMub3BlcmF0b3JzLmxlbmd0aDt0aGlzLnBhcnNlQmxvY2soKTt0aGlzLmV4cGVjdChjcy5SQlJBQ0UpO3RoaXMuZXhwZWN0KGNzLklGRUxTRSk7dGhpcy5vcGVyYXRvcnNbdF09dGhpcy5vcGVyYXRvcnMubGVuZ3RoO3RoaXMub3BlcmF0b3JzW3QrMV09ImoiO3RoaXMub3BlcmF0b3JzW2VdPWk7dGhpcy5vcGVyYXRvcnNbZSsxXT0ianoifX19fWNvbnN0IGNzPXtMQlJBQ0U6MCxSQlJBQ0U6MSxOVU1CRVI6MixPUEVSQVRPUjozLElGOjQsSUZFTFNFOjV9O2NsYXNzIFBvc3RTY3JpcHRUb2tlbntzdGF0aWMgZ2V0IG9wQ2FjaGUoKXtyZXR1cm4gc2hhZG93KHRoaXMsIm9wQ2FjaGUiLE9iamVjdC5jcmVhdGUobnVsbCkpfWNvbnN0cnVjdG9yKGUsdCl7dGhpcy50eXBlPWU7dGhpcy52YWx1ZT10fXN0YXRpYyBnZXRPcGVyYXRvcihlKXtyZXR1cm4gUG9zdFNjcmlwdFRva2VuLm9wQ2FjaGVbZV18fD1uZXcgUG9zdFNjcmlwdFRva2VuKGNzLk9QRVJBVE9SLGUpfXN0YXRpYyBnZXQgTEJSQUNFKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJMQlJBQ0UiLG5ldyBQb3N0U2NyaXB0VG9rZW4oY3MuTEJSQUNFLCJ7IikpfXN0YXRpYyBnZXQgUkJSQUNFKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJSQlJBQ0UiLG5ldyBQb3N0U2NyaXB0VG9rZW4oY3MuUkJSQUNFLCJ9IikpfXN0YXRpYyBnZXQgSUYoKXtyZXR1cm4gc2hhZG93KHRoaXMsIklGIixuZXcgUG9zdFNjcmlwdFRva2VuKGNzLklGLCJJRiIpKX1zdGF0aWMgZ2V0IElGRUxTRSgpe3JldHVybiBzaGFkb3codGhpcywiSUZFTFNFIixuZXcgUG9zdFNjcmlwdFRva2VuKGNzLklGRUxTRSwiSUZFTFNFIikpfX1jbGFzcyBQb3N0U2NyaXB0TGV4ZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5zdHJlYW09ZTt0aGlzLm5leHRDaGFyKCk7dGhpcy5zdHJCdWY9W119bmV4dENoYXIoKXtyZXR1cm4gdGhpcy5jdXJyZW50Q2hhcj10aGlzLnN0cmVhbS5nZXRCeXRlKCl9Z2V0VG9rZW4oKXtsZXQgZT0hMSx0PXRoaXMuY3VycmVudENoYXI7Zm9yKDs7KXtpZih0PDApcmV0dXJuIHB0O2lmKGUpMTAhPT10JiYxMyE9PXR8fChlPSExKTtlbHNlIGlmKDM3PT09dCllPSEwO2Vsc2UgaWYoIWlzV2hpdGVTcGFjZSh0KSlicmVhazt0PXRoaXMubmV4dENoYXIoKX1zd2l0Y2goMHx0KXtjYXNlIDQ4OmNhc2UgNDk6Y2FzZSA1MDpjYXNlIDUxOmNhc2UgNTI6Y2FzZSA1MzpjYXNlIDU0OmNhc2UgNTU6Y2FzZSA1NjpjYXNlIDU3OmNhc2UgNDM6Y2FzZSA0NTpjYXNlIDQ2OnJldHVybiBuZXcgUG9zdFNjcmlwdFRva2VuKGNzLk5VTUJFUix0aGlzLmdldE51bWJlcigpKTtjYXNlIDEyMzp0aGlzLm5leHRDaGFyKCk7cmV0dXJuIFBvc3RTY3JpcHRUb2tlbi5MQlJBQ0U7Y2FzZSAxMjU6dGhpcy5uZXh0Q2hhcigpO3JldHVybiBQb3N0U2NyaXB0VG9rZW4uUkJSQUNFfWNvbnN0IGk9dGhpcy5zdHJCdWY7aS5sZW5ndGg9MDtpWzBdPVN0cmluZy5mcm9tQ2hhckNvZGUodCk7Zm9yKDsodD10aGlzLm5leHRDaGFyKCkpPj0wJiYodD49NjUmJnQ8PTkwfHx0Pj05NyYmdDw9MTIyKTspaS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodCkpO2NvbnN0IGE9aS5qb2luKCIiKTtzd2l0Y2goYS50b0xvd2VyQ2FzZSgpKXtjYXNlImlmIjpyZXR1cm4gUG9zdFNjcmlwdFRva2VuLklGO2Nhc2UiaWZlbHNlIjpyZXR1cm4gUG9zdFNjcmlwdFRva2VuLklGRUxTRTtkZWZhdWx0OnJldHVybiBQb3N0U2NyaXB0VG9rZW4uZ2V0T3BlcmF0b3IoYSl9fWdldE51bWJlcigpe2xldCBlPXRoaXMuY3VycmVudENoYXI7Y29uc3QgdD10aGlzLnN0ckJ1Zjt0Lmxlbmd0aD0wO3RbMF09U3RyaW5nLmZyb21DaGFyQ29kZShlKTtmb3IoOyhlPXRoaXMubmV4dENoYXIoKSk+PTAmJihlPj00OCYmZTw9NTd8fDQ1PT09ZXx8NDY9PT1lKTspdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpO2NvbnN0IGk9cGFyc2VGbG9hdCh0LmpvaW4oIiIpKTtpZihpc05hTihpKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyOiAke2l9YCk7cmV0dXJuIGl9fWNsYXNzIEJhc2VMb2NhbENhY2hle2NvbnN0cnVjdG9yKGUpe3RoaXMuY29uc3RydWN0b3I9PT1CYXNlTG9jYWxDYWNoZSYmdW5yZWFjaGFibGUoIkNhbm5vdCBpbml0aWFsaXplIEJhc2VMb2NhbENhY2hlLiIpO3RoaXMuX29ubHlSZWZzPSEwPT09ZT8ub25seVJlZnM7aWYoIXRoaXMuX29ubHlSZWZzKXt0aGlzLl9uYW1lUmVmTWFwPW5ldyBNYXA7dGhpcy5faW1hZ2VNYXA9bmV3IE1hcH10aGlzLl9pbWFnZUNhY2hlPW5ldyBSZWZTZXRDYWNoZX1nZXRCeU5hbWUoZSl7dGhpcy5fb25seVJlZnMmJnVucmVhY2hhYmxlKCJTaG91bGQgbm90IGNhbGwgYGdldEJ5TmFtZWAgbWV0aG9kLiIpO2NvbnN0IHQ9dGhpcy5fbmFtZVJlZk1hcC5nZXQoZSk7cmV0dXJuIHQ/dGhpcy5nZXRCeVJlZih0KTp0aGlzLl9pbWFnZU1hcC5nZXQoZSl8fG51bGx9Z2V0QnlSZWYoZSl7cmV0dXJuIHRoaXMuX2ltYWdlQ2FjaGUuZ2V0KGUpfHxudWxsfXNldChlLHQsaSl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgc2V0YCBjYWxsZWQuIil9fWNsYXNzIExvY2FsSW1hZ2VDYWNoZSBleHRlbmRzIEJhc2VMb2NhbENhY2hle3NldChlLHQ9bnVsbCxpKXtpZigic3RyaW5nIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKCdMb2NhbEltYWdlQ2FjaGUuc2V0IC0gZXhwZWN0ZWQgIm5hbWUiIGFyZ3VtZW50LicpO2lmKHQpe2lmKHRoaXMuX2ltYWdlQ2FjaGUuaGFzKHQpKXJldHVybjt0aGlzLl9uYW1lUmVmTWFwLnNldChlLHQpO3RoaXMuX2ltYWdlQ2FjaGUucHV0KHQsaSl9ZWxzZSB0aGlzLl9pbWFnZU1hcC5oYXMoZSl8fHRoaXMuX2ltYWdlTWFwLnNldChlLGkpfX1jbGFzcyBMb2NhbENvbG9yU3BhY2VDYWNoZSBleHRlbmRzIEJhc2VMb2NhbENhY2hle3NldChlPW51bGwsdD1udWxsLGkpe2lmKCJzdHJpbmciIT10eXBlb2YgZSYmIXQpdGhyb3cgbmV3IEVycm9yKCdMb2NhbENvbG9yU3BhY2VDYWNoZS5zZXQgLSBleHBlY3RlZCAibmFtZSIgYW5kL29yICJyZWYiIGFyZ3VtZW50LicpO2lmKHQpe2lmKHRoaXMuX2ltYWdlQ2FjaGUuaGFzKHQpKXJldHVybjtudWxsIT09ZSYmdGhpcy5fbmFtZVJlZk1hcC5zZXQoZSx0KTt0aGlzLl9pbWFnZUNhY2hlLnB1dCh0LGkpfWVsc2UgdGhpcy5faW1hZ2VNYXAuaGFzKGUpfHx0aGlzLl9pbWFnZU1hcC5zZXQoZSxpKX19Y2xhc3MgTG9jYWxGdW5jdGlvbkNhY2hlIGV4dGVuZHMgQmFzZUxvY2FsQ2FjaGV7Y29uc3RydWN0b3IoZSl7c3VwZXIoe29ubHlSZWZzOiEwfSl9c2V0KGU9bnVsbCx0LGkpe2lmKCF0KXRocm93IG5ldyBFcnJvcignTG9jYWxGdW5jdGlvbkNhY2hlLnNldCAtIGV4cGVjdGVkICJyZWYiIGFyZ3VtZW50LicpO3RoaXMuX2ltYWdlQ2FjaGUuaGFzKHQpfHx0aGlzLl9pbWFnZUNhY2hlLnB1dCh0LGkpfX1jbGFzcyBMb2NhbEdTdGF0ZUNhY2hlIGV4dGVuZHMgQmFzZUxvY2FsQ2FjaGV7c2V0KGUsdD1udWxsLGkpe2lmKCJzdHJpbmciIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsR1N0YXRlQ2FjaGUuc2V0IC0gZXhwZWN0ZWQgIm5hbWUiIGFyZ3VtZW50LicpO2lmKHQpe2lmKHRoaXMuX2ltYWdlQ2FjaGUuaGFzKHQpKXJldHVybjt0aGlzLl9uYW1lUmVmTWFwLnNldChlLHQpO3RoaXMuX2ltYWdlQ2FjaGUucHV0KHQsaSl9ZWxzZSB0aGlzLl9pbWFnZU1hcC5oYXMoZSl8fHRoaXMuX2ltYWdlTWFwLnNldChlLGkpfX1jbGFzcyBMb2NhbFRpbGluZ1BhdHRlcm5DYWNoZSBleHRlbmRzIEJhc2VMb2NhbENhY2hle2NvbnN0cnVjdG9yKGUpe3N1cGVyKHtvbmx5UmVmczohMH0pfXNldChlPW51bGwsdCxpKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsVGlsaW5nUGF0dGVybkNhY2hlLnNldCAtIGV4cGVjdGVkICJyZWYiIGFyZ3VtZW50LicpO3RoaXMuX2ltYWdlQ2FjaGUuaGFzKHQpfHx0aGlzLl9pbWFnZUNhY2hlLnB1dCh0LGkpfX1jbGFzcyBSZWdpb25hbEltYWdlQ2FjaGUgZXh0ZW5kcyBCYXNlTG9jYWxDYWNoZXtjb25zdHJ1Y3RvcihlKXtzdXBlcih7b25seVJlZnM6ITB9KX1zZXQoZT1udWxsLHQsaSl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCdSZWdpb25hbEltYWdlQ2FjaGUuc2V0IC0gZXhwZWN0ZWQgInJlZiIgYXJndW1lbnQuJyk7dGhpcy5faW1hZ2VDYWNoZS5oYXModCl8fHRoaXMuX2ltYWdlQ2FjaGUucHV0KHQsaSl9fWNsYXNzIEdsb2JhbEltYWdlQ2FjaGV7c3RhdGljIE5VTV9QQUdFU19USFJFU0hPTEQ9MjtzdGF0aWMgTUlOX0lNQUdFU19UT19DQUNIRT0xMDtzdGF0aWMgTUFYX0JZVEVfU0laRT01ZTc7Y29uc3RydWN0b3IoKXt0aGlzLl9yZWZDYWNoZT1uZXcgUmVmU2V0Q2FjaGU7dGhpcy5faW1hZ2VDYWNoZT1uZXcgUmVmU2V0Q2FjaGV9Z2V0IF9ieXRlU2l6ZSgpe2xldCBlPTA7Zm9yKGNvbnN0IHQgb2YgdGhpcy5faW1hZ2VDYWNoZSllKz10LmJ5dGVTaXplO3JldHVybiBlfWdldCBfY2FjaGVMaW1pdFJlYWNoZWQoKXtyZXR1cm4hKHRoaXMuX2ltYWdlQ2FjaGUuc2l6ZTxHbG9iYWxJbWFnZUNhY2hlLk1JTl9JTUFHRVNfVE9fQ0FDSEUpJiYhKHRoaXMuX2J5dGVTaXplPEdsb2JhbEltYWdlQ2FjaGUuTUFYX0JZVEVfU0laRSl9c2hvdWxkQ2FjaGUoZSx0KXtsZXQgaT10aGlzLl9yZWZDYWNoZS5nZXQoZSk7aWYoIWkpe2k9bmV3IFNldDt0aGlzLl9yZWZDYWNoZS5wdXQoZSxpKX1pLmFkZCh0KTtyZXR1cm4hKGkuc2l6ZTxHbG9iYWxJbWFnZUNhY2hlLk5VTV9QQUdFU19USFJFU0hPTEQpJiYhKCF0aGlzLl9pbWFnZUNhY2hlLmhhcyhlKSYmdGhpcy5fY2FjaGVMaW1pdFJlYWNoZWQpfWFkZEJ5dGVTaXplKGUsdCl7Y29uc3QgaT10aGlzLl9pbWFnZUNhY2hlLmdldChlKTtpJiYoaS5ieXRlU2l6ZXx8KGkuYnl0ZVNpemU9dCkpfWdldERhdGEoZSx0KXtjb25zdCBpPXRoaXMuX3JlZkNhY2hlLmdldChlKTtpZighaSlyZXR1cm4gbnVsbDtpZihpLnNpemU8R2xvYmFsSW1hZ2VDYWNoZS5OVU1fUEFHRVNfVEhSRVNIT0xEKXJldHVybiBudWxsO2NvbnN0IGE9dGhpcy5faW1hZ2VDYWNoZS5nZXQoZSk7aWYoIWEpcmV0dXJuIG51bGw7aS5hZGQodCk7cmV0dXJuIGF9c2V0RGF0YShlLHQpe2lmKCF0aGlzLl9yZWZDYWNoZS5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKCdHbG9iYWxJbWFnZUNhY2hlLnNldERhdGEgLSBleHBlY3RlZCAic2hvdWxkQ2FjaGUiIHRvIGhhdmUgYmVlbiBjYWxsZWQuJyk7dGhpcy5faW1hZ2VDYWNoZS5oYXMoZSl8fCh0aGlzLl9jYWNoZUxpbWl0UmVhY2hlZD93YXJuKCJHbG9iYWxJbWFnZUNhY2hlLnNldERhdGEgLSBjYWNoZSBsaW1pdCByZWFjaGVkLiIpOnRoaXMuX2ltYWdlQ2FjaGUucHV0KGUsdCkpfWNsZWFyKGU9ITEpe2V8fHRoaXMuX3JlZkNhY2hlLmNsZWFyKCk7dGhpcy5faW1hZ2VDYWNoZS5jbGVhcigpfX1jbGFzcyBQREZGdW5jdGlvbkZhY3Rvcnl7Y29uc3RydWN0b3Ioe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dD0hMH0pe3RoaXMueHJlZj1lO3RoaXMuaXNFdmFsU3VwcG9ydGVkPSExIT09dH1jcmVhdGUoZSl7Y29uc3QgdD10aGlzLmdldENhY2hlZChlKTtpZih0KXJldHVybiB0O2NvbnN0IGk9UERGRnVuY3Rpb24ucGFyc2Uoe3hyZWY6dGhpcy54cmVmLGlzRXZhbFN1cHBvcnRlZDp0aGlzLmlzRXZhbFN1cHBvcnRlZCxmbjplIGluc3RhbmNlb2YgUmVmP3RoaXMueHJlZi5mZXRjaChlKTplfSk7dGhpcy5fY2FjaGUoZSxpKTtyZXR1cm4gaX1jcmVhdGVGcm9tQXJyYXkoZSl7Y29uc3QgdD10aGlzLmdldENhY2hlZChlKTtpZih0KXJldHVybiB0O2NvbnN0IGk9UERGRnVuY3Rpb24ucGFyc2VBcnJheSh7eHJlZjp0aGlzLnhyZWYsaXNFdmFsU3VwcG9ydGVkOnRoaXMuaXNFdmFsU3VwcG9ydGVkLGZuT2JqOmUgaW5zdGFuY2VvZiBSZWY/dGhpcy54cmVmLmZldGNoKGUpOmV9KTt0aGlzLl9jYWNoZShlLGkpO3JldHVybiBpfWdldENhY2hlZChlKXtsZXQgdDtlIGluc3RhbmNlb2YgUmVmP3Q9ZTplIGluc3RhbmNlb2YgRGljdD90PWUub2JqSWQ6ZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJih0PWUuZGljdD8ub2JqSWQpO2lmKHQpe2NvbnN0IGU9dGhpcy5fbG9jYWxGdW5jdGlvbkNhY2hlLmdldEJ5UmVmKHQpO2lmKGUpcmV0dXJuIGV9cmV0dXJuIG51bGx9X2NhY2hlKGUsdCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKCdQREZGdW5jdGlvbkZhY3RvcnkuX2NhY2hlIC0gZXhwZWN0ZWQgInBhcnNlZEZ1bmN0aW9uIiBhcmd1bWVudC4nKTtsZXQgaTtlIGluc3RhbmNlb2YgUmVmP2k9ZTplIGluc3RhbmNlb2YgRGljdD9pPWUub2JqSWQ6ZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJihpPWUuZGljdD8ub2JqSWQpO2kmJnRoaXMuX2xvY2FsRnVuY3Rpb25DYWNoZS5zZXQobnVsbCxpLHQpfWdldCBfbG9jYWxGdW5jdGlvbkNhY2hlKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJfbG9jYWxGdW5jdGlvbkNhY2hlIixuZXcgTG9jYWxGdW5jdGlvbkNhY2hlKX19ZnVuY3Rpb24gdG9OdW1iZXJBcnJheShlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKT9pc051bWJlckFycmF5KGUsbnVsbCk/ZTplLm1hcCgoZT0+K2UpKTpudWxsfWNsYXNzIFBERkZ1bmN0aW9ue3N0YXRpYyBnZXRTYW1wbGVBcnJheShlLHQsaSxhKXtsZXQgcyxyLG49MTtmb3Iocz0wLHI9ZS5sZW5ndGg7czxyO3MrKyluKj1lW3NdO24qPXQ7Y29uc3Qgbz1uZXcgQXJyYXkobik7bGV0IGc9MCxjPTA7Y29uc3QgQz0xLygyKippLTEpLGg9YS5nZXRCeXRlcygobippKzcpLzgpO2xldCBsPTA7Zm9yKHM9MDtzPG47cysrKXtmb3IoO2c8aTspe2M8PD04O2N8PWhbbCsrXTtnKz04fWctPWk7b1tzXT0oYz4+ZykqQztjJj0oMTw8ZyktMX1yZXR1cm4gb31zdGF0aWMgcGFyc2Uoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxmbjppfSl7Y29uc3QgYT1pLmRpY3R8fGk7c3dpdGNoKGEuZ2V0KCJGdW5jdGlvblR5cGUiKSl7Y2FzZSAwOnJldHVybiB0aGlzLmNvbnN0cnVjdFNhbXBsZWQoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxmbjppLGRpY3Q6YX0pO2Nhc2UgMTpicmVhaztjYXNlIDI6cmV0dXJuIHRoaXMuY29uc3RydWN0SW50ZXJwb2xhdGVkKHt4cmVmOmUsaXNFdmFsU3VwcG9ydGVkOnQsZGljdDphfSk7Y2FzZSAzOnJldHVybiB0aGlzLmNvbnN0cnVjdFN0aWNoZWQoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxkaWN0OmF9KTtjYXNlIDQ6cmV0dXJuIHRoaXMuY29uc3RydWN0UG9zdFNjcmlwdCh7eHJlZjplLGlzRXZhbFN1cHBvcnRlZDp0LGZuOmksZGljdDphfSl9dGhyb3cgbmV3IEZvcm1hdEVycm9yKCJVbmtub3duIHR5cGUgb2YgZnVuY3Rpb24iKX1zdGF0aWMgcGFyc2VBcnJheSh7eHJlZjplLGlzRXZhbFN1cHBvcnRlZDp0LGZuT2JqOml9KXtpZighQXJyYXkuaXNBcnJheShpKSlyZXR1cm4gdGhpcy5wYXJzZSh7eHJlZjplLGlzRXZhbFN1cHBvcnRlZDp0LGZuOml9KTtjb25zdCBhPVtdO2Zvcihjb25zdCBzIG9mIGkpYS5wdXNoKHRoaXMucGFyc2Uoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxmbjplLmZldGNoSWZSZWYocyl9KSk7cmV0dXJuIGZ1bmN0aW9uKGUsdCxpLHMpe2ZvcihsZXQgcj0wLG49YS5sZW5ndGg7cjxuO3IrKylhW3JdKGUsdCxpLHMrcil9fXN0YXRpYyBjb25zdHJ1Y3RTYW1wbGVkKHt4cmVmOmUsaXNFdmFsU3VwcG9ydGVkOnQsZm46aSxkaWN0OmF9KXtmdW5jdGlvbiB0b011bHRpQXJyYXkoZSl7Y29uc3QgdD1lLmxlbmd0aCxpPVtdO2xldCBhPTA7Zm9yKGxldCBzPTA7czx0O3MrPTIpaVthKytdPVtlW3NdLGVbcysxXV07cmV0dXJuIGl9ZnVuY3Rpb24gaW50ZXJwb2xhdGUoZSx0LGksYSxzKXtyZXR1cm4gYSsocy1hKS8oaS10KSooZS10KX1sZXQgcz10b051bWJlckFycmF5KGEuZ2V0QXJyYXkoIkRvbWFpbiIpKSxyPXRvTnVtYmVyQXJyYXkoYS5nZXRBcnJheSgiUmFuZ2UiKSk7aWYoIXN8fCFyKXRocm93IG5ldyBGb3JtYXRFcnJvcigiTm8gZG9tYWluIG9yIHJhbmdlIik7Y29uc3Qgbj1zLmxlbmd0aC8yLG89ci5sZW5ndGgvMjtzPXRvTXVsdGlBcnJheShzKTtyPXRvTXVsdGlBcnJheShyKTtjb25zdCBnPXRvTnVtYmVyQXJyYXkoYS5nZXRBcnJheSgiU2l6ZSIpKSxjPWEuZ2V0KCJCaXRzUGVyU2FtcGxlIiksQz1hLmdldCgiT3JkZXIiKXx8MTsxIT09QyYmaW5mbygiTm8gc3VwcG9ydCBmb3IgY3ViaWMgc3BsaW5lIGludGVycG9sYXRpb246ICIrQyk7bGV0IGg9dG9OdW1iZXJBcnJheShhLmdldEFycmF5KCJFbmNvZGUiKSk7aWYoaCloPXRvTXVsdGlBcnJheShoKTtlbHNle2g9W107Zm9yKGxldCBlPTA7ZTxuOysrZSloLnB1c2goWzAsZ1tlXS0xXSl9bGV0IGw9dG9OdW1iZXJBcnJheShhLmdldEFycmF5KCJEZWNvZGUiKSk7bD1sP3RvTXVsdGlBcnJheShsKTpyO2NvbnN0IFE9dGhpcy5nZXRTYW1wbGVBcnJheShnLG8sYyxpKTtyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0U2FtcGxlZEZuKGUsdCxpLGEpe2NvbnN0IGM9MTw8bixDPW5ldyBGbG9hdDY0QXJyYXkoYyksRT1uZXcgVWludDMyQXJyYXkoYyk7bGV0IHUsZDtmb3IoZD0wO2Q8YztkKyspQ1tkXT0xO2xldCBmPW8scD0xO2Zvcih1PTA7dTxuOysrdSl7Y29uc3QgaT1zW3VdWzBdLGE9c1t1XVsxXTtsZXQgcj1pbnRlcnBvbGF0ZShNYXRoLm1pbihNYXRoLm1heChlW3QrdV0saSksYSksaSxhLGhbdV1bMF0saFt1XVsxXSk7Y29uc3Qgbj1nW3VdO3I9TWF0aC5taW4oTWF0aC5tYXgociwwKSxuLTEpO2NvbnN0IG89cjxuLTE/TWF0aC5mbG9vcihyKTpyLTEsbD1vKzEtcixRPXItbyxtPW8qZix5PW0rZjtmb3IoZD0wO2Q8YztkKyspaWYoZCZwKXtDW2RdKj1RO0VbZF0rPXl9ZWxzZXtDW2RdKj1sO0VbZF0rPW19Zio9bjtwPDw9MX1mb3IoZD0wO2Q8bzsrK2Qpe2xldCBlPTA7Zm9yKHU9MDt1PGM7dSsrKWUrPVFbRVt1XStkXSpDW3VdO2U9aW50ZXJwb2xhdGUoZSwwLDEsbFtkXVswXSxsW2RdWzFdKTtpW2ErZF09TWF0aC5taW4oTWF0aC5tYXgoZSxyW2RdWzBdKSxyW2RdWzFdKX19fXN0YXRpYyBjb25zdHJ1Y3RJbnRlcnBvbGF0ZWQoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxkaWN0Oml9KXtjb25zdCBhPXRvTnVtYmVyQXJyYXkoaS5nZXRBcnJheSgiQzAiKSl8fFswXSxzPXRvTnVtYmVyQXJyYXkoaS5nZXRBcnJheSgiQzEiKSl8fFsxXSxyPWkuZ2V0KCJOIiksbj1bXTtmb3IobGV0IGU9MCx0PWEubGVuZ3RoO2U8dDsrK2Upbi5wdXNoKHNbZV0tYVtlXSk7Y29uc3Qgbz1uLmxlbmd0aDtyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0SW50ZXJwb2xhdGVkRm4oZSx0LGkscyl7Y29uc3QgZz0xPT09cj9lW3RdOmVbdF0qKnI7Zm9yKGxldCBlPTA7ZTxvOysrZSlpW3MrZV09YVtlXStnKm5bZV19fXN0YXRpYyBjb25zdHJ1Y3RTdGljaGVkKHt4cmVmOmUsaXNFdmFsU3VwcG9ydGVkOnQsZGljdDppfSl7Y29uc3QgYT10b051bWJlckFycmF5KGkuZ2V0QXJyYXkoIkRvbWFpbiIpKTtpZighYSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk5vIGRvbWFpbiIpO2lmKDEhPT1hLmxlbmd0aC8yKXRocm93IG5ldyBGb3JtYXRFcnJvcigiQmFkIGRvbWFpbiBmb3Igc3RpY2hlZCBmdW5jdGlvbiIpO2NvbnN0IHM9W107Zm9yKGNvbnN0IGEgb2YgaS5nZXQoIkZ1bmN0aW9ucyIpKXMucHVzaCh0aGlzLnBhcnNlKHt4cmVmOmUsaXNFdmFsU3VwcG9ydGVkOnQsZm46ZS5mZXRjaElmUmVmKGEpfSkpO2NvbnN0IHI9dG9OdW1iZXJBcnJheShpLmdldEFycmF5KCJCb3VuZHMiKSksbj10b051bWJlckFycmF5KGkuZ2V0QXJyYXkoIkVuY29kZSIpKSxvPW5ldyBGbG9hdDMyQXJyYXkoMSk7cmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdFN0aWNoZWRGbihlLHQsaSxnKXtjb25zdCBjPWZ1bmN0aW9uIGNvbnN0cnVjdFN0aWNoZWRGcm9tSVJDbGlwKGUsdCxpKXtlPmk/ZT1pOmU8dCYmKGU9dCk7cmV0dXJuIGV9KGVbdF0sYVswXSxhWzFdKSxDPXIubGVuZ3RoO2xldCBoO2ZvcihoPTA7aDxDJiYhKGM8cltoXSk7KytoKTtsZXQgbD1hWzBdO2g+MCYmKGw9cltoLTFdKTtsZXQgUT1hWzFdO2g8ci5sZW5ndGgmJihRPXJbaF0pO2NvbnN0IEU9blsyKmhdLHU9blsyKmgrMV07b1swXT1sPT09UT9FOkUrKGMtbCkqKHUtRSkvKFEtbCk7c1toXShvLDAsaSxnKX19c3RhdGljIGNvbnN0cnVjdFBvc3RTY3JpcHQoe3hyZWY6ZSxpc0V2YWxTdXBwb3J0ZWQ6dCxmbjppLGRpY3Q6YX0pe2NvbnN0IHM9dG9OdW1iZXJBcnJheShhLmdldEFycmF5KCJEb21haW4iKSkscj10b051bWJlckFycmF5KGEuZ2V0QXJyYXkoIlJhbmdlIikpO2lmKCFzKXRocm93IG5ldyBGb3JtYXRFcnJvcigiTm8gZG9tYWluLiIpO2lmKCFyKXRocm93IG5ldyBGb3JtYXRFcnJvcigiTm8gcmFuZ2UuIik7Y29uc3Qgbj1uZXcgUG9zdFNjcmlwdExleGVyKGkpLG89bmV3IFBvc3RTY3JpcHRQYXJzZXIobikucGFyc2UoKTtpZih0JiZGZWF0dXJlVGVzdC5pc0V2YWxTdXBwb3J0ZWQpe2NvbnN0IGU9KG5ldyBQb3N0U2NyaXB0Q29tcGlsZXIpLmNvbXBpbGUobyxzLHIpO2lmKGUpcmV0dXJuIG5ldyBGdW5jdGlvbigic3JjIiwic3JjT2Zmc2V0IiwiZGVzdCIsImRlc3RPZmZzZXQiLGUpfWluZm8oIlVuYWJsZSB0byBjb21waWxlIFBTIGZ1bmN0aW9uIik7Y29uc3QgZz1yLmxlbmd0aD4+MSxjPXMubGVuZ3RoPj4xLEM9bmV3IFBvc3RTY3JpcHRFdmFsdWF0b3IobyksaD1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBsPTgxOTI7Y29uc3QgUT1uZXcgRmxvYXQzMkFycmF5KGMpO3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RQb3N0U2NyaXB0Rm4oZSx0LGksYSl7bGV0IHMsbixvPSIiO2NvbnN0IEU9UTtmb3Iocz0wO3M8YztzKyspe249ZVt0K3NdO0Vbc109bjtvKz1uKyJfIn1jb25zdCB1PWhbb107aWYodm9pZCAwIT09dSl7aS5zZXQodSxhKTtyZXR1cm59Y29uc3QgZD1uZXcgRmxvYXQzMkFycmF5KGcpLGY9Qy5leGVjdXRlKEUpLHA9Zi5sZW5ndGgtZztmb3Iocz0wO3M8ZztzKyspe249ZltwK3NdO2xldCBlPXJbMipzXTtpZihuPGUpbj1lO2Vsc2V7ZT1yWzIqcysxXTtuPmUmJihuPWUpfWRbc109bn1pZihsPjApe2wtLTtoW29dPWR9aS5zZXQoZCxhKX19fWZ1bmN0aW9uIGlzUERGRnVuY3Rpb24oZSl7bGV0IHQ7aWYoZSBpbnN0YW5jZW9mIERpY3QpdD1lO2Vsc2V7aWYoIShlIGluc3RhbmNlb2YgQmFzZVN0cmVhbSkpcmV0dXJuITE7dD1lLmRpY3R9cmV0dXJuIHQuaGFzKCJGdW5jdGlvblR5cGUiKX1jbGFzcyBQb3N0U2NyaXB0U3RhY2t7c3RhdGljIE1BWF9TVEFDS19TSVpFPTEwMDtjb25zdHJ1Y3RvcihlKXt0aGlzLnN0YWNrPWU/QXJyYXkuZnJvbShlKTpbXX1wdXNoKGUpe2lmKHRoaXMuc3RhY2subGVuZ3RoPj1Qb3N0U2NyaXB0U3RhY2suTUFYX1NUQUNLX1NJWkUpdGhyb3cgbmV3IEVycm9yKCJQb3N0U2NyaXB0IGZ1bmN0aW9uIHN0YWNrIG92ZXJmbG93LiIpO3RoaXMuc3RhY2sucHVzaChlKX1wb3AoKXtpZih0aGlzLnN0YWNrLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoIlBvc3RTY3JpcHQgZnVuY3Rpb24gc3RhY2sgdW5kZXJmbG93LiIpO3JldHVybiB0aGlzLnN0YWNrLnBvcCgpfWNvcHkoZSl7aWYodGhpcy5zdGFjay5sZW5ndGgrZT49UG9zdFNjcmlwdFN0YWNrLk1BWF9TVEFDS19TSVpFKXRocm93IG5ldyBFcnJvcigiUG9zdFNjcmlwdCBmdW5jdGlvbiBzdGFjayBvdmVyZmxvdy4iKTtjb25zdCB0PXRoaXMuc3RhY2s7Zm9yKGxldCBpPXQubGVuZ3RoLWUsYT1lLTE7YT49MDthLS0saSsrKXQucHVzaCh0W2ldKX1pbmRleChlKXt0aGlzLnB1c2godGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC1lLTFdKX1yb2xsKGUsdCl7Y29uc3QgaT10aGlzLnN0YWNrLGE9aS5sZW5ndGgtZSxzPWkubGVuZ3RoLTEscj1hKyh0LU1hdGguZmxvb3IodC9lKSplKTtmb3IobGV0IGU9YSx0PXM7ZTx0O2UrKyx0LS0pe2NvbnN0IGE9aVtlXTtpW2VdPWlbdF07aVt0XT1hfWZvcihsZXQgZT1hLHQ9ci0xO2U8dDtlKyssdC0tKXtjb25zdCBhPWlbZV07aVtlXT1pW3RdO2lbdF09YX1mb3IobGV0IGU9cix0PXM7ZTx0O2UrKyx0LS0pe2NvbnN0IGE9aVtlXTtpW2VdPWlbdF07aVt0XT1hfX19Y2xhc3MgUG9zdFNjcmlwdEV2YWx1YXRvcntjb25zdHJ1Y3RvcihlKXt0aGlzLm9wZXJhdG9ycz1lfWV4ZWN1dGUoZSl7Y29uc3QgdD1uZXcgUG9zdFNjcmlwdFN0YWNrKGUpO2xldCBpPTA7Y29uc3QgYT10aGlzLm9wZXJhdG9ycyxzPWEubGVuZ3RoO2xldCByLG4sbztmb3IoO2k8czspe3I9YVtpKytdO2lmKCJudW1iZXIiIT10eXBlb2Ygcilzd2l0Y2gocil7Y2FzZSJqeiI6bz10LnBvcCgpO249dC5wb3AoKTtufHwoaT1vKTticmVhaztjYXNlImoiOm49dC5wb3AoKTtpPW47YnJlYWs7Y2FzZSJhYnMiOm49dC5wb3AoKTt0LnB1c2goTWF0aC5hYnMobikpO2JyZWFrO2Nhc2UiYWRkIjpvPXQucG9wKCk7bj10LnBvcCgpO3QucHVzaChuK28pO2JyZWFrO2Nhc2UiYW5kIjpvPXQucG9wKCk7bj10LnBvcCgpOyJib29sZWFuIj09dHlwZW9mIG4mJiJib29sZWFuIj09dHlwZW9mIG8/dC5wdXNoKG4mJm8pOnQucHVzaChuJm8pO2JyZWFrO2Nhc2UiYXRhbiI6bz10LnBvcCgpO249dC5wb3AoKTtuPU1hdGguYXRhbjIobixvKS9NYXRoLlBJKjE4MDtuPDAmJihuKz0zNjApO3QucHVzaChuKTticmVhaztjYXNlImJpdHNoaWZ0IjpvPXQucG9wKCk7bj10LnBvcCgpO24+MD90LnB1c2gobjw8byk6dC5wdXNoKG4+Pm8pO2JyZWFrO2Nhc2UiY2VpbGluZyI6bj10LnBvcCgpO3QucHVzaChNYXRoLmNlaWwobikpO2JyZWFrO2Nhc2UiY29weSI6bj10LnBvcCgpO3QuY29weShuKTticmVhaztjYXNlImNvcyI6bj10LnBvcCgpO3QucHVzaChNYXRoLmNvcyhuJTM2MC8xODAqTWF0aC5QSSkpO2JyZWFrO2Nhc2UiY3ZpIjpuPTB8dC5wb3AoKTt0LnB1c2gobik7YnJlYWs7Y2FzZSJjdnIiOmJyZWFrO2Nhc2UiZGl2IjpvPXQucG9wKCk7bj10LnBvcCgpO3QucHVzaChuL28pO2JyZWFrO2Nhc2UiZHVwIjp0LmNvcHkoMSk7YnJlYWs7Y2FzZSJlcSI6bz10LnBvcCgpO249dC5wb3AoKTt0LnB1c2gobj09PW8pO2JyZWFrO2Nhc2UiZXhjaCI6dC5yb2xsKDIsMSk7YnJlYWs7Y2FzZSJleHAiOm89dC5wb3AoKTtuPXQucG9wKCk7dC5wdXNoKG4qKm8pO2JyZWFrO2Nhc2UiZmFsc2UiOnQucHVzaCghMSk7YnJlYWs7Y2FzZSJmbG9vciI6bj10LnBvcCgpO3QucHVzaChNYXRoLmZsb29yKG4pKTticmVhaztjYXNlImdlIjpvPXQucG9wKCk7bj10LnBvcCgpO3QucHVzaChuPj1vKTticmVhaztjYXNlImd0IjpvPXQucG9wKCk7bj10LnBvcCgpO3QucHVzaChuPm8pO2JyZWFrO2Nhc2UiaWRpdiI6bz10LnBvcCgpO249dC5wb3AoKTt0LnB1c2gobi9vfDApO2JyZWFrO2Nhc2UiaW5kZXgiOm49dC5wb3AoKTt0LmluZGV4KG4pO2JyZWFrO2Nhc2UibGUiOm89dC5wb3AoKTtuPXQucG9wKCk7dC5wdXNoKG48PW8pO2JyZWFrO2Nhc2UibG4iOm49dC5wb3AoKTt0LnB1c2goTWF0aC5sb2cobikpO2JyZWFrO2Nhc2UibG9nIjpuPXQucG9wKCk7dC5wdXNoKE1hdGgubG9nMTAobikpO2JyZWFrO2Nhc2UibHQiOm89dC5wb3AoKTtuPXQucG9wKCk7dC5wdXNoKG48byk7YnJlYWs7Y2FzZSJtb2QiOm89dC5wb3AoKTtuPXQucG9wKCk7dC5wdXNoKG4lbyk7YnJlYWs7Y2FzZSJtdWwiOm89dC5wb3AoKTtuPXQucG9wKCk7dC5wdXNoKG4qbyk7YnJlYWs7Y2FzZSJuZSI6bz10LnBvcCgpO249dC5wb3AoKTt0LnB1c2gobiE9PW8pO2JyZWFrO2Nhc2UibmVnIjpuPXQucG9wKCk7dC5wdXNoKC1uKTticmVhaztjYXNlIm5vdCI6bj10LnBvcCgpOyJib29sZWFuIj09dHlwZW9mIG4/dC5wdXNoKCFuKTp0LnB1c2gofm4pO2JyZWFrO2Nhc2Uib3IiOm89dC5wb3AoKTtuPXQucG9wKCk7ImJvb2xlYW4iPT10eXBlb2YgbiYmImJvb2xlYW4iPT10eXBlb2Ygbz90LnB1c2gobnx8byk6dC5wdXNoKG58byk7YnJlYWs7Y2FzZSJwb3AiOnQucG9wKCk7YnJlYWs7Y2FzZSJyb2xsIjpvPXQucG9wKCk7bj10LnBvcCgpO3Qucm9sbChuLG8pO2JyZWFrO2Nhc2Uicm91bmQiOm49dC5wb3AoKTt0LnB1c2goTWF0aC5yb3VuZChuKSk7YnJlYWs7Y2FzZSJzaW4iOm49dC5wb3AoKTt0LnB1c2goTWF0aC5zaW4obiUzNjAvMTgwKk1hdGguUEkpKTticmVhaztjYXNlInNxcnQiOm49dC5wb3AoKTt0LnB1c2goTWF0aC5zcXJ0KG4pKTticmVhaztjYXNlInN1YiI6bz10LnBvcCgpO249dC5wb3AoKTt0LnB1c2gobi1vKTticmVhaztjYXNlInRydWUiOnQucHVzaCghMCk7YnJlYWs7Y2FzZSJ0cnVuY2F0ZSI6bj10LnBvcCgpO249bjwwP01hdGguY2VpbChuKTpNYXRoLmZsb29yKG4pO3QucHVzaChuKTticmVhaztjYXNlInhvciI6bz10LnBvcCgpO249dC5wb3AoKTsiYm9vbGVhbiI9PXR5cGVvZiBuJiYiYm9vbGVhbiI9PXR5cGVvZiBvP3QucHVzaChuIT09byk6dC5wdXNoKG5ebyk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYFVua25vd24gb3BlcmF0b3IgJHtyfWApfWVsc2UgdC5wdXNoKHIpfXJldHVybiB0LnN0YWNrfX1jbGFzcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUpe3RoaXMudHlwZT1lfXZpc2l0KGUpe3VucmVhY2hhYmxlKCJhYnN0cmFjdCBtZXRob2QiKX19Y2xhc3MgQXN0QXJndW1lbnQgZXh0ZW5kcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcigiYXJncyIpO3RoaXMuaW5kZXg9ZTt0aGlzLm1pbj10O3RoaXMubWF4PWl9dmlzaXQoZSl7ZS52aXNpdEFyZ3VtZW50KHRoaXMpfX1jbGFzcyBBc3RMaXRlcmFsIGV4dGVuZHMgQXN0Tm9kZXtjb25zdHJ1Y3RvcihlKXtzdXBlcigibGl0ZXJhbCIpO3RoaXMubnVtYmVyPWU7dGhpcy5taW49ZTt0aGlzLm1heD1lfXZpc2l0KGUpe2UudmlzaXRMaXRlcmFsKHRoaXMpfX1jbGFzcyBBc3RCaW5hcnlPcGVyYXRpb24gZXh0ZW5kcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUsdCxpLGEscyl7c3VwZXIoImJpbmFyeSIpO3RoaXMub3A9ZTt0aGlzLmFyZzE9dDt0aGlzLmFyZzI9aTt0aGlzLm1pbj1hO3RoaXMubWF4PXN9dmlzaXQoZSl7ZS52aXNpdEJpbmFyeU9wZXJhdGlvbih0aGlzKX19Y2xhc3MgQXN0TWluIGV4dGVuZHMgQXN0Tm9kZXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKCJtYXgiKTt0aGlzLmFyZz1lO3RoaXMubWluPWUubWluO3RoaXMubWF4PXR9dmlzaXQoZSl7ZS52aXNpdE1pbih0aGlzKX19Y2xhc3MgQXN0VmFyaWFibGUgZXh0ZW5kcyBBc3ROb2Rle2NvbnN0cnVjdG9yKGUsdCxpKXtzdXBlcigidmFyIik7dGhpcy5pbmRleD1lO3RoaXMubWluPXQ7dGhpcy5tYXg9aX12aXNpdChlKXtlLnZpc2l0VmFyaWFibGUodGhpcyl9fWNsYXNzIEFzdFZhcmlhYmxlRGVmaW5pdGlvbiBleHRlbmRzIEFzdE5vZGV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcigiZGVmaW5pdGlvbiIpO3RoaXMudmFyaWFibGU9ZTt0aGlzLmFyZz10fXZpc2l0KGUpe2UudmlzaXRWYXJpYWJsZURlZmluaXRpb24odGhpcyl9fWNsYXNzIEV4cHJlc3Npb25CdWlsZGVyVmlzaXRvcntjb25zdHJ1Y3Rvcigpe3RoaXMucGFydHM9W119dmlzaXRBcmd1bWVudChlKXt0aGlzLnBhcnRzLnB1c2goIk1hdGgubWF4KCIsZS5taW4sIiwgTWF0aC5taW4oIixlLm1heCwiLCBzcmNbc3JjT2Zmc2V0ICsgIixlLmluZGV4LCJdKSkiKX12aXNpdFZhcmlhYmxlKGUpe3RoaXMucGFydHMucHVzaCgidiIsZS5pbmRleCl9dmlzaXRMaXRlcmFsKGUpe3RoaXMucGFydHMucHVzaChlLm51bWJlcil9dmlzaXRCaW5hcnlPcGVyYXRpb24oZSl7dGhpcy5wYXJ0cy5wdXNoKCIoIik7ZS5hcmcxLnZpc2l0KHRoaXMpO3RoaXMucGFydHMucHVzaCgiICIsZS5vcCwiICIpO2UuYXJnMi52aXNpdCh0aGlzKTt0aGlzLnBhcnRzLnB1c2goIikiKX12aXNpdFZhcmlhYmxlRGVmaW5pdGlvbihlKXt0aGlzLnBhcnRzLnB1c2goInZhciAiKTtlLnZhcmlhYmxlLnZpc2l0KHRoaXMpO3RoaXMucGFydHMucHVzaCgiID0gIik7ZS5hcmcudmlzaXQodGhpcyk7dGhpcy5wYXJ0cy5wdXNoKCI7Iil9dmlzaXRNaW4oZSl7dGhpcy5wYXJ0cy5wdXNoKCJNYXRoLm1pbigiKTtlLmFyZy52aXNpdCh0aGlzKTt0aGlzLnBhcnRzLnB1c2goIiwgIixlLm1heCwiKSIpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMucGFydHMuam9pbigiIil9fWZ1bmN0aW9uIGJ1aWxkQWRkT3BlcmF0aW9uKGUsdCl7cmV0dXJuImxpdGVyYWwiPT09dC50eXBlJiYwPT09dC5udW1iZXI/ZToibGl0ZXJhbCI9PT1lLnR5cGUmJjA9PT1lLm51bWJlcj90OiJsaXRlcmFsIj09PXQudHlwZSYmImxpdGVyYWwiPT09ZS50eXBlP25ldyBBc3RMaXRlcmFsKGUubnVtYmVyK3QubnVtYmVyKTpuZXcgQXN0QmluYXJ5T3BlcmF0aW9uKCIrIixlLHQsZS5taW4rdC5taW4sZS5tYXgrdC5tYXgpfWZ1bmN0aW9uIGJ1aWxkTXVsT3BlcmF0aW9uKGUsdCl7aWYoImxpdGVyYWwiPT09dC50eXBlKXtpZigwPT09dC5udW1iZXIpcmV0dXJuIG5ldyBBc3RMaXRlcmFsKDApO2lmKDE9PT10Lm51bWJlcilyZXR1cm4gZTtpZigibGl0ZXJhbCI9PT1lLnR5cGUpcmV0dXJuIG5ldyBBc3RMaXRlcmFsKGUubnVtYmVyKnQubnVtYmVyKX1pZigibGl0ZXJhbCI9PT1lLnR5cGUpe2lmKDA9PT1lLm51bWJlcilyZXR1cm4gbmV3IEFzdExpdGVyYWwoMCk7aWYoMT09PWUubnVtYmVyKXJldHVybiB0fWNvbnN0IGk9TWF0aC5taW4oZS5taW4qdC5taW4sZS5taW4qdC5tYXgsZS5tYXgqdC5taW4sZS5tYXgqdC5tYXgpLGE9TWF0aC5tYXgoZS5taW4qdC5taW4sZS5taW4qdC5tYXgsZS5tYXgqdC5taW4sZS5tYXgqdC5tYXgpO3JldHVybiBuZXcgQXN0QmluYXJ5T3BlcmF0aW9uKCIqIixlLHQsaSxhKX1mdW5jdGlvbiBidWlsZFN1Yk9wZXJhdGlvbihlLHQpe2lmKCJsaXRlcmFsIj09PXQudHlwZSl7aWYoMD09PXQubnVtYmVyKXJldHVybiBlO2lmKCJsaXRlcmFsIj09PWUudHlwZSlyZXR1cm4gbmV3IEFzdExpdGVyYWwoZS5udW1iZXItdC5udW1iZXIpfXJldHVybiJiaW5hcnkiPT09dC50eXBlJiYiLSI9PT10Lm9wJiYibGl0ZXJhbCI9PT1lLnR5cGUmJjE9PT1lLm51bWJlciYmImxpdGVyYWwiPT09dC5hcmcxLnR5cGUmJjE9PT10LmFyZzEubnVtYmVyP3QuYXJnMjpuZXcgQXN0QmluYXJ5T3BlcmF0aW9uKCItIixlLHQsZS5taW4tdC5tYXgsZS5tYXgtdC5taW4pfWZ1bmN0aW9uIGJ1aWxkTWluT3BlcmF0aW9uKGUsdCl7cmV0dXJuIGUubWluPj10P25ldyBBc3RMaXRlcmFsKHQpOmUubWF4PD10P2U6bmV3IEFzdE1pbihlLHQpfWNsYXNzIFBvc3RTY3JpcHRDb21waWxlcntjb21waWxlKGUsdCxpKXtjb25zdCBhPVtdLHM9W10scj10Lmxlbmd0aD4+MSxuPWkubGVuZ3RoPj4xO2xldCBvLGcsYyxDLGgsbCxRLEUsdT0wO2ZvcihsZXQgZT0wO2U8cjtlKyspYS5wdXNoKG5ldyBBc3RBcmd1bWVudChlLHRbMiplXSx0WzIqZSsxXSkpO2ZvcihsZXQgdD0wLGk9ZS5sZW5ndGg7dDxpO3QrKyl7RT1lW3RdO2lmKCJudW1iZXIiIT10eXBlb2YgRSlzd2l0Y2goRSl7Y2FzZSJhZGQiOmlmKGEubGVuZ3RoPDIpcmV0dXJuIG51bGw7Qz1hLnBvcCgpO2M9YS5wb3AoKTthLnB1c2goYnVpbGRBZGRPcGVyYXRpb24oYyxDKSk7YnJlYWs7Y2FzZSJjdnIiOmlmKGEubGVuZ3RoPDEpcmV0dXJuIG51bGw7YnJlYWs7Y2FzZSJtdWwiOmlmKGEubGVuZ3RoPDIpcmV0dXJuIG51bGw7Qz1hLnBvcCgpO2M9YS5wb3AoKTthLnB1c2goYnVpbGRNdWxPcGVyYXRpb24oYyxDKSk7YnJlYWs7Y2FzZSJzdWIiOmlmKGEubGVuZ3RoPDIpcmV0dXJuIG51bGw7Qz1hLnBvcCgpO2M9YS5wb3AoKTthLnB1c2goYnVpbGRTdWJPcGVyYXRpb24oYyxDKSk7YnJlYWs7Y2FzZSJleGNoIjppZihhLmxlbmd0aDwyKXJldHVybiBudWxsO2g9YS5wb3AoKTtsPWEucG9wKCk7YS5wdXNoKGgsbCk7YnJlYWs7Y2FzZSJwb3AiOmlmKGEubGVuZ3RoPDEpcmV0dXJuIG51bGw7YS5wb3AoKTticmVhaztjYXNlImluZGV4IjppZihhLmxlbmd0aDwxKXJldHVybiBudWxsO2M9YS5wb3AoKTtpZigibGl0ZXJhbCIhPT1jLnR5cGUpcmV0dXJuIG51bGw7bz1jLm51bWJlcjtpZihvPDB8fCFOdW1iZXIuaXNJbnRlZ2VyKG8pfHxhLmxlbmd0aDxvKXJldHVybiBudWxsO2g9YVthLmxlbmd0aC1vLTFdO2lmKCJsaXRlcmFsIj09PWgudHlwZXx8InZhciI9PT1oLnR5cGUpe2EucHVzaChoKTticmVha31RPW5ldyBBc3RWYXJpYWJsZSh1KyssaC5taW4saC5tYXgpO2FbYS5sZW5ndGgtby0xXT1RO2EucHVzaChRKTtzLnB1c2gobmV3IEFzdFZhcmlhYmxlRGVmaW5pdGlvbihRLGgpKTticmVhaztjYXNlImR1cCI6aWYoYS5sZW5ndGg8MSlyZXR1cm4gbnVsbDtpZigibnVtYmVyIj09dHlwZW9mIGVbdCsxXSYmImd0Ij09PWVbdCsyXSYmZVt0KzNdPT09dCs3JiYianoiPT09ZVt0KzRdJiYicG9wIj09PWVbdCs1XSYmZVt0KzZdPT09ZVt0KzFdKXtjPWEucG9wKCk7YS5wdXNoKGJ1aWxkTWluT3BlcmF0aW9uKGMsZVt0KzFdKSk7dCs9NjticmVha31oPWEuYXQoLTEpO2lmKCJsaXRlcmFsIj09PWgudHlwZXx8InZhciI9PT1oLnR5cGUpe2EucHVzaChoKTticmVha31RPW5ldyBBc3RWYXJpYWJsZSh1KyssaC5taW4saC5tYXgpO2FbYS5sZW5ndGgtMV09UTthLnB1c2goUSk7cy5wdXNoKG5ldyBBc3RWYXJpYWJsZURlZmluaXRpb24oUSxoKSk7YnJlYWs7Y2FzZSJyb2xsIjppZihhLmxlbmd0aDwyKXJldHVybiBudWxsO0M9YS5wb3AoKTtjPWEucG9wKCk7aWYoImxpdGVyYWwiIT09Qy50eXBlfHwibGl0ZXJhbCIhPT1jLnR5cGUpcmV0dXJuIG51bGw7Zz1DLm51bWJlcjtvPWMubnVtYmVyO2lmKG88PTB8fCFOdW1iZXIuaXNJbnRlZ2VyKG8pfHwhTnVtYmVyLmlzSW50ZWdlcihnKXx8YS5sZW5ndGg8bylyZXR1cm4gbnVsbDtnPShnJW8rbyklbztpZigwPT09ZylicmVhazthLnB1c2goLi4uYS5zcGxpY2UoYS5sZW5ndGgtbyxvLWcpKTticmVhaztkZWZhdWx0OnJldHVybiBudWxsfWVsc2UgYS5wdXNoKG5ldyBBc3RMaXRlcmFsKEUpKX1pZihhLmxlbmd0aCE9PW4pcmV0dXJuIG51bGw7Y29uc3QgZD1bXTtmb3IoY29uc3QgZSBvZiBzKXtjb25zdCB0PW5ldyBFeHByZXNzaW9uQnVpbGRlclZpc2l0b3I7ZS52aXNpdCh0KTtkLnB1c2godC50b1N0cmluZygpKX1mb3IobGV0IGU9MCx0PWEubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9YVtlXSxzPW5ldyBFeHByZXNzaW9uQnVpbGRlclZpc2l0b3I7dC52aXNpdChzKTtjb25zdCByPWlbMiplXSxuPWlbMiplKzFdLG89W3MudG9TdHJpbmcoKV07aWYocj50Lm1pbil7by51bnNoaWZ0KCJNYXRoLm1heCgiLHIsIiwgIik7by5wdXNoKCIpIil9aWYobjx0Lm1heCl7by51bnNoaWZ0KCJNYXRoLm1pbigiLG4sIiwgIik7by5wdXNoKCIpIil9by51bnNoaWZ0KCJkZXN0W2Rlc3RPZmZzZXQgKyAiLGUsIl0gPSAiKTtvLnB1c2goIjsiKTtkLnB1c2goby5qb2luKCIiKSl9cmV0dXJuIGQuam9pbigiXG4iKX19Y29uc3QgQ3M9WyJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJTIiwiQiIsIlMiLCJXUyIsIkIiLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQiIsIkIiLCJCIiwiUyIsIldTIiwiT04iLCJPTiIsIkVUIiwiRVQiLCJFVCIsIk9OIiwiT04iLCJPTiIsIk9OIiwiT04iLCJFUyIsIkNTIiwiRVMiLCJDUyIsIkNTIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJDUyIsIk9OIiwiT04iLCJPTiIsIk9OIiwiT04iLCJPTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiT04iLCJPTiIsIk9OIiwiT04iLCJPTiIsIk9OIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJPTiIsIk9OIiwiT04iLCJPTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkIiLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQ1MiLCJPTiIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiT04iLCJPTiIsIk9OIiwiT04iLCJMIiwiT04iLCJPTiIsIkJOIiwiT04iLCJPTiIsIkVUIiwiRVQiLCJFTiIsIkVOIiwiT04iLCJMIiwiT04iLCJPTiIsIk9OIiwiRU4iLCJMIiwiT04iLCJPTiIsIk9OIiwiT04iLCJPTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiT04iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiT04iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCJdLGhzPVsiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiT04iLCJPTiIsIkFMIiwiRVQiLCJFVCIsIkFMIiwiQ1MiLCJBTCIsIk9OIiwiT04iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJBTCIsIkFMIiwiIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJFVCIsIkFOIiwiQU4iLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJPTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJPTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIkFMIiwiQUwiLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCJdO2Z1bmN0aW9uIGlzT2RkKGUpe3JldHVybiAwIT0oMSZlKX1mdW5jdGlvbiBpc0V2ZW4oZSl7cmV0dXJuIDA9PSgxJmUpfWZ1bmN0aW9uIGZpbmRVbmVxdWFsKGUsdCxpKXtsZXQgYSxzO2ZvcihhPXQscz1lLmxlbmd0aDthPHM7KythKWlmKGVbYV0hPT1pKXJldHVybiBhO3JldHVybiBhfWZ1bmN0aW9uIHNldFZhbHVlcyhlLHQsaSxhKXtmb3IobGV0IHM9dDtzPGk7KytzKWVbc109YX1mdW5jdGlvbiByZXZlcnNlVmFsdWVzKGUsdCxpKXtmb3IobGV0IGE9dCxzPWktMTthPHM7KythLC0tcyl7Y29uc3QgdD1lW2FdO2VbYV09ZVtzXTtlW3NdPXR9fWZ1bmN0aW9uIGNyZWF0ZUJpZGlUZXh0KGUsdCxpPSExKXtsZXQgYT0ibHRyIjtpP2E9InR0YiI6dHx8KGE9InJ0bCIpO3JldHVybntzdHI6ZSxkaXI6YX19Y29uc3QgbHM9W10sQnM9W107ZnVuY3Rpb24gYmlkaShlLHQ9LTEsaT0hMSl7bGV0IGE9ITA7Y29uc3Qgcz1lLmxlbmd0aDtpZigwPT09c3x8aSlyZXR1cm4gY3JlYXRlQmlkaVRleHQoZSxhLGkpO2xzLmxlbmd0aD1zO0JzLmxlbmd0aD1zO2xldCByLG4sbz0wO2ZvcihyPTA7cjxzOysrcil7bHNbcl09ZS5jaGFyQXQocik7Y29uc3QgdD1lLmNoYXJDb2RlQXQocik7bGV0IGk9IkwiO2lmKHQ8PTI1NSlpPUNzW3RdO2Vsc2UgaWYoMTQyNDw9dCYmdDw9MTUyNClpPSJSIjtlbHNlIGlmKDE1MzY8PXQmJnQ8PTE3OTEpe2k9aHNbMjU1JnRdO2l8fHdhcm4oIkJpZGk6IGludmFsaWQgVW5pY29kZSBjaGFyYWN0ZXIgIit0LnRvU3RyaW5nKDE2KSl9ZWxzZSgxNzkyPD10JiZ0PD0yMjIwfHw2NDMzNjw9dCYmdDw9NjUwMjN8fDY1MTM2PD10JiZ0PD02NTI3OSkmJihpPSJBTCIpOyJSIiE9PWkmJiJBTCIhPT1pJiYiQU4iIT09aXx8bysrO0JzW3JdPWl9aWYoMD09PW8pe2E9ITA7cmV0dXJuIGNyZWF0ZUJpZGlUZXh0KGUsYSl9aWYoLTE9PT10KWlmKG8vczwuMyYmcz40KXthPSEwO3Q9MH1lbHNle2E9ITE7dD0xfWNvbnN0IGc9W107Zm9yKHI9MDtyPHM7KytyKWdbcl09dDtjb25zdCBjPWlzT2RkKHQpPyJSIjoiTCIsQz1jLGg9QztsZXQgbCxRPUM7Zm9yKHI9MDtyPHM7KytyKSJOU00iPT09QnNbcl0/QnNbcl09UTpRPUJzW3JdO1E9Qztmb3Iocj0wO3I8czsrK3Ipe2w9QnNbcl07IkVOIj09PWw/QnNbcl09IkFMIj09PVE/IkFOIjoiRU4iOiJSIiE9PWwmJiJMIiE9PWwmJiJBTCIhPT1sfHwoUT1sKX1mb3Iocj0wO3I8czsrK3Ipe2w9QnNbcl07IkFMIj09PWwmJihCc1tyXT0iUiIpfWZvcihyPTE7cjxzLTE7KytyKXsiRVMiPT09QnNbcl0mJiJFTiI9PT1Cc1tyLTFdJiYiRU4iPT09QnNbcisxXSYmKEJzW3JdPSJFTiIpOyJDUyIhPT1Cc1tyXXx8IkVOIiE9PUJzW3ItMV0mJiJBTiIhPT1Cc1tyLTFdfHxCc1tyKzFdIT09QnNbci0xXXx8KEJzW3JdPUJzW3ItMV0pfWZvcihyPTA7cjxzOysrcilpZigiRU4iPT09QnNbcl0pe2ZvcihsZXQgZT1yLTE7ZT49MCYmIkVUIj09PUJzW2VdOy0tZSlCc1tlXT0iRU4iO2ZvcihsZXQgZT1yKzE7ZTxzJiYiRVQiPT09QnNbZV07KytlKUJzW2VdPSJFTiJ9Zm9yKHI9MDtyPHM7KytyKXtsPUJzW3JdOyJXUyIhPT1sJiYiRVMiIT09bCYmIkVUIiE9PWwmJiJDUyIhPT1sfHwoQnNbcl09Ik9OIil9UT1DO2ZvcihyPTA7cjxzOysrcil7bD1Cc1tyXTsiRU4iPT09bD9Cc1tyXT0iTCI9PT1RPyJMIjoiRU4iOiJSIiE9PWwmJiJMIiE9PWx8fChRPWwpfWZvcihyPTA7cjxzOysrcilpZigiT04iPT09QnNbcl0pe2NvbnN0IGU9ZmluZFVuZXF1YWwoQnMscisxLCJPTiIpO2xldCB0PUM7cj4wJiYodD1Cc1tyLTFdKTtsZXQgaT1oO2UrMTxzJiYoaT1Cc1tlKzFdKTsiTCIhPT10JiYodD0iUiIpOyJMIiE9PWkmJihpPSJSIik7dD09PWkmJnNldFZhbHVlcyhCcyxyLGUsdCk7cj1lLTF9Zm9yKHI9MDtyPHM7KytyKSJPTiI9PT1Cc1tyXSYmKEJzW3JdPWMpO2ZvcihyPTA7cjxzOysrcil7bD1Cc1tyXTtpc0V2ZW4oZ1tyXSk/IlIiPT09bD9nW3JdKz0xOiJBTiIhPT1sJiYiRU4iIT09bHx8KGdbcl0rPTIpOiJMIiE9PWwmJiJBTiIhPT1sJiYiRU4iIT09bHx8KGdbcl0rPTEpfWxldCBFLHU9LTEsZD05OTtmb3Iocj0wLG49Zy5sZW5ndGg7cjxuOysrcil7RT1nW3JdO3U8RSYmKHU9RSk7ZD5FJiZpc09kZChFKSYmKGQ9RSl9Zm9yKEU9dTtFPj1kOy0tRSl7bGV0IGU9LTE7Zm9yKHI9MCxuPWcubGVuZ3RoO3I8bjsrK3IpaWYoZ1tyXTxFKXtpZihlPj0wKXtyZXZlcnNlVmFsdWVzKGxzLGUscik7ZT0tMX19ZWxzZSBlPDAmJihlPXIpO2U+PTAmJnJldmVyc2VWYWx1ZXMobHMsZSxnLmxlbmd0aCl9Zm9yKHI9MCxuPWxzLmxlbmd0aDtyPG47KytyKXtjb25zdCBlPWxzW3JdOyI8IiE9PWUmJiI+IiE9PWV8fChsc1tyXT0iIil9cmV0dXJuIGNyZWF0ZUJpZGlUZXh0KGxzLmpvaW4oIiIpLGEpfWNvbnN0IFFzPXtzdHlsZToibm9ybWFsIix3ZWlnaHQ6Im5vcm1hbCJ9LEVzPXtzdHlsZToibm9ybWFsIix3ZWlnaHQ6ImJvbGQifSx1cz17c3R5bGU6Iml0YWxpYyIsd2VpZ2h0OiJub3JtYWwifSxkcz17c3R5bGU6Iml0YWxpYyIsd2VpZ2h0OiJib2xkIn0sZnM9bmV3IE1hcChbWyJUaW1lcy1Sb21hbiIse2xvY2FsOlsiVGltZXMgTmV3IFJvbWFuIiwiVGltZXMtUm9tYW4iLCJUaW1lcyIsIkxpYmVyYXRpb24gU2VyaWYiLCJOaW1idXMgUm9tYW4iLCJOaW1idXMgUm9tYW4gTCIsIlRpbm9zIiwiVGhvcm5kYWxlIiwiVGVYIEd5cmUgVGVybWVzIiwiRnJlZVNlcmlmIiwiTGludXggTGliZXJ0aW5lIE8iLCJMaWJlcnRpbnVzIFNlcmlmIiwiRGVqYVZ1IFNlcmlmIiwiQml0c3RyZWFtIFZlcmEgU2VyaWYiLCJVYnVudHUiXSxzdHlsZTpRcyx1bHRpbWF0ZToic2VyaWYifV0sWyJUaW1lcy1Cb2xkIix7YWxpYXM6IlRpbWVzLVJvbWFuIixzdHlsZTpFcyx1bHRpbWF0ZToic2VyaWYifV0sWyJUaW1lcy1JdGFsaWMiLHthbGlhczoiVGltZXMtUm9tYW4iLHN0eWxlOnVzLHVsdGltYXRlOiJzZXJpZiJ9XSxbIlRpbWVzLUJvbGRJdGFsaWMiLHthbGlhczoiVGltZXMtUm9tYW4iLHN0eWxlOmRzLHVsdGltYXRlOiJzZXJpZiJ9XSxbIkhlbHZldGljYSIse2xvY2FsOlsiSGVsdmV0aWNhIiwiSGVsdmV0aWNhIE5ldWUiLCJBcmlhbCIsIkFyaWFsIE5vdmEiLCJMaWJlcmF0aW9uIFNhbnMiLCJBcmltbyIsIk5pbWJ1cyBTYW5zIiwiTmltYnVzIFNhbnMgTCIsIkEwMzAiLCJUZVggR3lyZSBIZXJvcyIsIkZyZWVTYW5zIiwiRGVqYVZ1IFNhbnMiLCJBbGJhbnkiLCJCaXRzdHJlYW0gVmVyYSBTYW5zIiwiQXJpYWwgVW5pY29kZSBNUyIsIk1pY3Jvc29mdCBTYW5zIFNlcmlmIiwiQXBwbGUgU3ltYm9scyIsIkNhbnRhcmVsbCJdLHBhdGg6IkxpYmVyYXRpb25TYW5zLVJlZ3VsYXIudHRmIixzdHlsZTpRcyx1bHRpbWF0ZToic2Fucy1zZXJpZiJ9XSxbIkhlbHZldGljYS1Cb2xkIix7YWxpYXM6IkhlbHZldGljYSIscGF0aDoiTGliZXJhdGlvblNhbnMtQm9sZC50dGYiLHN0eWxlOkVzLHVsdGltYXRlOiJzYW5zLXNlcmlmIn1dLFsiSGVsdmV0aWNhLU9ibGlxdWUiLHthbGlhczoiSGVsdmV0aWNhIixwYXRoOiJMaWJlcmF0aW9uU2Fucy1JdGFsaWMudHRmIixzdHlsZTp1cyx1bHRpbWF0ZToic2Fucy1zZXJpZiJ9XSxbIkhlbHZldGljYS1Cb2xkT2JsaXF1ZSIse2FsaWFzOiJIZWx2ZXRpY2EiLHBhdGg6IkxpYmVyYXRpb25TYW5zLUJvbGRJdGFsaWMudHRmIixzdHlsZTpkcyx1bHRpbWF0ZToic2Fucy1zZXJpZiJ9XSxbIkNvdXJpZXIiLHtsb2NhbDpbIkNvdXJpZXIiLCJDb3VyaWVyIE5ldyIsIkxpYmVyYXRpb24gTW9ubyIsIk5pbWJ1cyBNb25vIiwiTmltYnVzIE1vbm8gTCIsIkNvdXNpbmUiLCJDdW1iZXJsYW5kIiwiVGVYIEd5cmUgQ3Vyc29yIiwiRnJlZU1vbm8iLCJMaW51eCBMaWJlcnRpbmUgTW9ubyBPIiwiTGliZXJ0aW51cyBNb25vIl0sc3R5bGU6UXMsdWx0aW1hdGU6Im1vbm9zcGFjZSJ9XSxbIkNvdXJpZXItQm9sZCIse2FsaWFzOiJDb3VyaWVyIixzdHlsZTpFcyx1bHRpbWF0ZToibW9ub3NwYWNlIn1dLFsiQ291cmllci1PYmxpcXVlIix7YWxpYXM6IkNvdXJpZXIiLHN0eWxlOnVzLHVsdGltYXRlOiJtb25vc3BhY2UifV0sWyJDb3VyaWVyLUJvbGRPYmxpcXVlIix7YWxpYXM6IkNvdXJpZXIiLHN0eWxlOmRzLHVsdGltYXRlOiJtb25vc3BhY2UifV0sWyJBcmlhbEJsYWNrIix7bG9jYWw6WyJBcmlhbCBCbGFjayJdLHN0eWxlOntzdHlsZToibm9ybWFsIix3ZWlnaHQ6IjkwMCJ9LGZhbGxiYWNrOiJIZWx2ZXRpY2EtQm9sZCJ9XSxbIkFyaWFsQmxhY2stQm9sZCIse2FsaWFzOiJBcmlhbEJsYWNrIn1dLFsiQXJpYWxCbGFjay1JdGFsaWMiLHthbGlhczoiQXJpYWxCbGFjayIsc3R5bGU6e3N0eWxlOiJpdGFsaWMiLHdlaWdodDoiOTAwIn0sZmFsbGJhY2s6IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSJ9XSxbIkFyaWFsQmxhY2stQm9sZEl0YWxpYyIse2FsaWFzOiJBcmlhbEJsYWNrLUl0YWxpYyJ9XSxbIkFyaWFsTmFycm93Iix7bG9jYWw6WyJBcmlhbCBOYXJyb3ciLCJMaWJlcmF0aW9uIFNhbnMgTmFycm93IiwiSGVsdmV0aWNhIENvbmRlbnNlZCIsIk5pbWJ1cyBTYW5zIE5hcnJvdyIsIlRlWCBHeXJlIEhlcm9zIENuIl0sc3R5bGU6UXMsZmFsbGJhY2s6IkhlbHZldGljYSJ9XSxbIkFyaWFsTmFycm93LUJvbGQiLHthbGlhczoiQXJpYWxOYXJyb3ciLHN0eWxlOkVzLGZhbGxiYWNrOiJIZWx2ZXRpY2EtQm9sZCJ9XSxbIkFyaWFsTmFycm93LUl0YWxpYyIse2FsaWFzOiJBcmlhbE5hcnJvdyIsc3R5bGU6dXMsZmFsbGJhY2s6IkhlbHZldGljYS1PYmxpcXVlIn1dLFsiQXJpYWxOYXJyb3ctQm9sZEl0YWxpYyIse2FsaWFzOiJBcmlhbE5hcnJvdyIsc3R5bGU6ZHMsZmFsbGJhY2s6IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSJ9XSxbIkNhbGlicmkiLHtsb2NhbDpbIkNhbGlicmkiLCJDYXJsaXRvIl0sc3R5bGU6UXMsZmFsbGJhY2s6IkhlbHZldGljYSJ9XSxbIkNhbGlicmktQm9sZCIse2FsaWFzOiJDYWxpYnJpIixzdHlsZTpFcyxmYWxsYmFjazoiSGVsdmV0aWNhLUJvbGQifV0sWyJDYWxpYnJpLUl0YWxpYyIse2FsaWFzOiJDYWxpYnJpIixzdHlsZTp1cyxmYWxsYmFjazoiSGVsdmV0aWNhLU9ibGlxdWUifV0sWyJDYWxpYnJpLUJvbGRJdGFsaWMiLHthbGlhczoiQ2FsaWJyaSIsc3R5bGU6ZHMsZmFsbGJhY2s6IkhlbHZldGljYS1Cb2xkT2JsaXF1ZSJ9XSxbIldpbmdkaW5ncyIse2xvY2FsOlsiV2luZ2RpbmdzIiwiVVJXIERpbmdiYXRzIl0sc3R5bGU6UXN9XSxbIldpbmdkaW5ncy1SZWd1bGFyIix7YWxpYXM6IldpbmdkaW5ncyJ9XSxbIldpbmdkaW5ncy1Cb2xkIix7YWxpYXM6IldpbmdkaW5ncyJ9XV0pLHBzPW5ldyBNYXAoW1siQXJpYWwtQmxhY2siLCJBcmlhbEJsYWNrIl1dKTtmdW5jdGlvbiBnZXRGYW1pbHlOYW1lKGUpe2NvbnN0IHQ9bmV3IFNldChbInRoaW4iLCJleHRyYWxpZ2h0IiwidWx0cmFsaWdodCIsImRlbWlsaWdodCIsInNlbWlsaWdodCIsImxpZ2h0IiwiYm9vayIsInJlZ3VsYXIiLCJub3JtYWwiLCJtZWRpdW0iLCJkZW1pYm9sZCIsInNlbWlib2xkIiwiYm9sZCIsImV4dHJhYm9sZCIsInVsdHJhYm9sZCIsImJsYWNrIiwiaGVhdnkiLCJleHRyYWJsYWNrIiwidWx0cmFibGFjayIsInJvbWFuIiwiaXRhbGljIiwib2JsaXF1ZSIsInVsdHJhY29uZGVuc2VkIiwiZXh0cmFjb25kZW5zZWQiLCJjb25kZW5zZWQiLCJzZW1pY29uZGVuc2VkIiwibm9ybWFsIiwic2VtaWV4cGFuZGVkIiwiZXhwYW5kZWQiLCJleHRyYWV4cGFuZGVkIiwidWx0cmFleHBhbmRlZCIsImJvbGRpdGFsaWMiXSk7cmV0dXJuIGUuc3BsaXQoL1stICwrXSsvZykuZmlsdGVyKChlPT4hdC5oYXMoZS50b0xvd2VyQ2FzZSgpKSkpLmpvaW4oIiAiKX1mdW5jdGlvbiBnZW5lcmF0ZUZvbnQoe2FsaWFzOmUsbG9jYWw6dCxwYXRoOmksZmFsbGJhY2s6YSxzdHlsZTpzLHVsdGltYXRlOnJ9LG4sbyxnPSEwLGM9ITAsQz0iIil7Y29uc3QgaD17c3R5bGU6bnVsbCx1bHRpbWF0ZTpudWxsfTtpZih0KXtjb25zdCBlPUM/YCAke0N9YDoiIjtmb3IoY29uc3QgaSBvZiB0KW4ucHVzaChgbG9jYWwoJHtpfSR7ZX0pYCl9aWYoZSl7Y29uc3QgdD1mcy5nZXQoZSkscj1DfHxmdW5jdGlvbiBnZXRTdHlsZVRvQXBwZW5kKGUpe3N3aXRjaChlKXtjYXNlIEVzOnJldHVybiJCb2xkIjtjYXNlIHVzOnJldHVybiJJdGFsaWMiO2Nhc2UgZHM6cmV0dXJuIkJvbGQgSXRhbGljIjtkZWZhdWx0OmlmKCJib2xkIj09PWU/LndlaWdodClyZXR1cm4iQm9sZCI7aWYoIml0YWxpYyI9PT1lPy5zdHlsZSlyZXR1cm4iSXRhbGljIn1yZXR1cm4iIn0ocyk7T2JqZWN0LmFzc2lnbihoLGdlbmVyYXRlRm9udCh0LG4sbyxnJiYhYSxjJiYhaSxyKSl9cyYmKGguc3R5bGU9cyk7ciYmKGgudWx0aW1hdGU9cik7aWYoZyYmYSl7Y29uc3QgZT1mcy5nZXQoYSkse3VsdGltYXRlOnR9PWdlbmVyYXRlRm9udChlLG4sbyxnLGMmJiFpLEMpO2gudWx0aW1hdGV8fD10fWMmJmkmJm8mJm4ucHVzaChgdXJsKCR7b30ke2l9KWApO3JldHVybiBofWZ1bmN0aW9uIGdldEZvbnRTdWJzdGl0dXRpb24oZSx0LGksYSxzLHIpe2lmKGEuc3RhcnRzV2l0aCgiSW52YWxpZFBERmpzRm9udF8iKSlyZXR1cm4gbnVsbDsiVHJ1ZVR5cGUiIT09ciYmIlR5cGUxIiE9PXJ8fCEvXltBLVpdezZ9XCsvLnRlc3QoYSl8fChhPWEuc2xpY2UoNykpO2NvbnN0IG49YT1ub3JtYWxpemVGb250TmFtZShhKTtsZXQgbz1lLmdldChuKTtpZihvKXJldHVybiBvO2xldCBnPWZzLmdldChhKTtpZighZylmb3IoY29uc3RbZSx0XW9mIHBzKWlmKGEuc3RhcnRzV2l0aChlKSl7YT1gJHt0fSR7YS5zdWJzdHJpbmcoZS5sZW5ndGgpfWA7Zz1mcy5nZXQoYSk7YnJlYWt9bGV0IGM9ITE7aWYoIWcpe2c9ZnMuZ2V0KHMpO2M9ITB9Y29uc3QgQz1gJHt0LmdldERvY0lkKCl9X3Mke3QuY3JlYXRlRm9udElkKCl9YDtpZighZyl7aWYoIXZhbGlkYXRlRm9udE5hbWUoYSkpe3dhcm4oYENhbm5vdCBzdWJzdGl0dXRlIHRoZSBmb250IGJlY2F1c2Ugb2YgaXRzIG5hbWU6ICR7YX1gKTtlLnNldChuLG51bGwpO3JldHVybiBudWxsfWNvbnN0IHQ9L2JvbGQvZ2kudGVzdChhKSxpPS9vYmxpcXVlfGl0YWxpYy9naS50ZXN0KGEpLHM9dCYmaSYmZHN8fHQmJkVzfHxpJiZ1c3x8UXM7bz17Y3NzOmAiJHtnZXRGYW1pbHlOYW1lKGEpfSIsJHtDfWAsZ3Vlc3NGYWxsYmFjazohMCxsb2FkZWROYW1lOkMsYmFzZUZvbnROYW1lOmEsc3JjOmBsb2NhbCgke2F9KWAsc3R5bGU6c307ZS5zZXQobixvKTtyZXR1cm4gb31jb25zdCBoPVtdO2MmJnZhbGlkYXRlRm9udE5hbWUoYSkmJmgucHVzaChgbG9jYWwoJHthfSlgKTtjb25zdHtzdHlsZTpsLHVsdGltYXRlOlF9PWdlbmVyYXRlRm9udChnLGgsaSksRT1udWxsPT09USx1PUU/IiI6YCwke1F9YDtvPXtjc3M6YCIke2dldEZhbWlseU5hbWUoYSl9Iiwke0N9JHt1fWAsZ3Vlc3NGYWxsYmFjazpFLGxvYWRlZE5hbWU6QyxiYXNlRm9udE5hbWU6YSxzcmM6aC5qb2luKCIsIiksc3R5bGU6bH07ZS5zZXQobixvKTtyZXR1cm4gb31jbGFzcyBJbWFnZVJlc2l6ZXJ7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9pbWdEYXRhPWU7dGhpcy5faXNNYXNrPXR9c3RhdGljIG5lZWRzVG9CZVJlc2l6ZWQoZSx0KXtpZihlPD10aGlzLl9nb29kU3F1YXJlTGVuZ3RoJiZ0PD10aGlzLl9nb29kU3F1YXJlTGVuZ3RoKXJldHVybiExO2NvbnN0e01BWF9ESU06aX09dGhpcztpZihlPml8fHQ+aSlyZXR1cm4hMDtjb25zdCBhPWUqdDtpZih0aGlzLl9oYXNNYXhBcmVhKXJldHVybiBhPnRoaXMuTUFYX0FSRUE7aWYoYTx0aGlzLl9nb29kU3F1YXJlTGVuZ3RoKioyKXJldHVybiExO2lmKHRoaXMuX2FyZUdvb2REaW1zKGUsdCkpe3RoaXMuX2dvb2RTcXVhcmVMZW5ndGg9TWF0aC5tYXgodGhpcy5fZ29vZFNxdWFyZUxlbmd0aCxNYXRoLmZsb29yKE1hdGguc3FydChlKnQpKSk7cmV0dXJuITF9dGhpcy5fZ29vZFNxdWFyZUxlbmd0aD10aGlzLl9ndWVzc01heCh0aGlzLl9nb29kU3F1YXJlTGVuZ3RoLGksMTI4LDApO3JldHVybiBhPih0aGlzLk1BWF9BUkVBPXRoaXMuX2dvb2RTcXVhcmVMZW5ndGgqKjIpfXN0YXRpYyBnZXQgTUFYX0RJTSgpe3JldHVybiBzaGFkb3codGhpcywiTUFYX0RJTSIsdGhpcy5fZ3Vlc3NNYXgoMjA0OCw2NTUzNywwLDEpKX1zdGF0aWMgZ2V0IE1BWF9BUkVBKCl7dGhpcy5faGFzTWF4QXJlYT0hMDtyZXR1cm4gc2hhZG93KHRoaXMsIk1BWF9BUkVBIix0aGlzLl9ndWVzc01heChJbWFnZVJlc2l6ZXIuX2dvb2RTcXVhcmVMZW5ndGgsdGhpcy5NQVhfRElNLDEyOCwwKSoqMil9c3RhdGljIHNldCBNQVhfQVJFQShlKXtpZihlPj0wKXt0aGlzLl9oYXNNYXhBcmVhPSEwO3NoYWRvdyh0aGlzLCJNQVhfQVJFQSIsZSl9fXN0YXRpYyBzZXRNYXhBcmVhKGUpe3RoaXMuX2hhc01heEFyZWF8fCh0aGlzLk1BWF9BUkVBPWU+PjIpfXN0YXRpYyBfYXJlR29vZERpbXMoZSx0KXt0cnl7Y29uc3QgaT1uZXcgT2Zmc2NyZWVuQ2FudmFzKGUsdCksYT1pLmdldENvbnRleHQoIjJkIik7YS5maWxsUmVjdCgwLDAsMSwxKTtjb25zdCBzPWEuZ2V0SW1hZ2VEYXRhKDAsMCwxLDEpLmRhdGFbM107aS53aWR0aD1pLmhlaWdodD0xO3JldHVybiAwIT09c31jYXRjaHtyZXR1cm4hMX19c3RhdGljIF9ndWVzc01heChlLHQsaSxhKXtmb3IoO2UraSsxPHQ7KXtjb25zdCBpPU1hdGguZmxvb3IoKGUrdCkvMikscz1hfHxpO3RoaXMuX2FyZUdvb2REaW1zKGkscyk/ZT1pOnQ9aX1yZXR1cm4gZX1zdGF0aWMgYXN5bmMgY3JlYXRlSW1hZ2UoZSx0PSExKXtyZXR1cm4gbmV3IEltYWdlUmVzaXplcihlLHQpLl9jcmVhdGVJbWFnZSgpfWFzeW5jIF9jcmVhdGVJbWFnZSgpe2NvbnN0IGU9dGhpcy5fZW5jb2RlQk1QKCksdD1uZXcgQmxvYihbZS5idWZmZXJdLHt0eXBlOiJpbWFnZS9ibXAifSksaT1jcmVhdGVJbWFnZUJpdG1hcCh0KSx7TUFYX0FSRUE6YSxNQVhfRElNOnN9PUltYWdlUmVzaXplcix7X2ltZ0RhdGE6cn09dGhpcyx7d2lkdGg6bixoZWlnaHQ6b309cixnPU1hdGgubWF4KG4vcyxvL3MsTWF0aC5zcXJ0KG4qby9hKSksYz1NYXRoLm1heChnLDIpLEM9TWF0aC5yb3VuZCgxMCooZysxLjI1KSkvMTAvYyxoPU1hdGguZmxvb3IoTWF0aC5sb2cyKEMpKSxsPW5ldyBBcnJheShoKzIpLmZpbGwoMik7bFswXT1jO2wuc3BsaWNlKC0xLDEsQy8oMTw8aCkpO2xldCBRPW4sRT1vLHU9YXdhaXQgaTtmb3IoY29uc3QgZSBvZiBsKXtjb25zdCB0PVEsaT1FO1E9TWF0aC5mbG9vcihRL2UpLTE7RT1NYXRoLmZsb29yKEUvZSktMTtjb25zdCBhPW5ldyBPZmZzY3JlZW5DYW52YXMoUSxFKTthLmdldENvbnRleHQoIjJkIikuZHJhd0ltYWdlKHUsMCwwLHQsaSwwLDAsUSxFKTt1PWEudHJhbnNmZXJUb0ltYWdlQml0bWFwKCl9ci5kYXRhPW51bGw7ci5iaXRtYXA9dTtyLndpZHRoPVE7ci5oZWlnaHQ9RTtyZXR1cm4gcn1fZW5jb2RlQk1QKCl7Y29uc3R7d2lkdGg6ZSxoZWlnaHQ6dCxraW5kOml9PXRoaXMuX2ltZ0RhdGE7bGV0IGEscz10aGlzLl9pbWdEYXRhLmRhdGEscj1uZXcgVWludDhBcnJheSgwKSxuPXIsbz0wO3N3aXRjaChpKXtjYXNlIGI6e2E9MTtyPW5ldyBVaW50OEFycmF5KHRoaXMuX2lzTWFzaz9bMjU1LDI1NSwyNTUsMjU1LDAsMCwwLDBdOlswLDAsMCwwLDI1NSwyNTUsMjU1LDI1NV0pO2NvbnN0IGk9ZSs3Pj4zLG49aSszJi00O2lmKGkhPT1uKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KG4qdCk7bGV0IGE9MDtmb3IobGV0IHI9MCxvPXQqaTtyPG87cis9aSxhKz1uKWUuc2V0KHMuc3ViYXJyYXkocixyK2kpLGEpO3M9ZX1icmVha31jYXNlIEQ6YT0yNDtpZigzJmUpe2NvbnN0IGk9MyplLGE9aSszJi00LHI9YS1pLG49bmV3IFVpbnQ4QXJyYXkoYSp0KTtsZXQgbz0wO2ZvcihsZXQgZT0wLGE9dCppO2U8YTtlKz1pKXtjb25zdCB0PXMuc3ViYXJyYXkoZSxlK2kpO2ZvcihsZXQgZT0wO2U8aTtlKz0zKXtuW28rK109dFtlKzJdO25bbysrXT10W2UrMV07bltvKytdPXRbZV19bys9cn1zPW59ZWxzZSBmb3IobGV0IGU9MCx0PXMubGVuZ3RoO2U8dDtlKz0zKXtjb25zdCB0PXNbZV07c1tlXT1zW2UrMl07c1tlKzJdPXR9YnJlYWs7Y2FzZSBGOmE9MzI7bz0zO249bmV3IFVpbnQ4QXJyYXkoNjgpO2NvbnN0IGk9bmV3IERhdGFWaWV3KG4uYnVmZmVyKTtpZihGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbil7aS5zZXRVaW50MzIoMCwyNTUsITApO2kuc2V0VWludDMyKDQsNjUyODAsITApO2kuc2V0VWludDMyKDgsMTY3MTE2ODAsITApO2kuc2V0VWludDMyKDEyLDQyNzgxOTAwODAsITApfWVsc2V7aS5zZXRVaW50MzIoMCw0Mjc4MTkwMDgwLCEwKTtpLnNldFVpbnQzMig0LDE2NzExNjgwLCEwKTtpLnNldFVpbnQzMig4LDY1MjgwLCEwKTtpLnNldFVpbnQzMigxMiwyNTUsITApfWJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJpbnZhbGlkIGZvcm1hdCIpfWxldCBnPTA7Y29uc3QgYz00MCtuLmxlbmd0aCxDPTE0K2Mrci5sZW5ndGgrcy5sZW5ndGgsaD1uZXcgVWludDhBcnJheShDKSxsPW5ldyBEYXRhVmlldyhoLmJ1ZmZlcik7bC5zZXRVaW50MTYoZywxOTc3OCwhMCk7Zys9MjtsLnNldFVpbnQzMihnLEMsITApO2crPTQ7bC5zZXRVaW50MzIoZywwLCEwKTtnKz00O2wuc2V0VWludDMyKGcsMTQrYytyLmxlbmd0aCwhMCk7Zys9NDtsLnNldFVpbnQzMihnLGMsITApO2crPTQ7bC5zZXRJbnQzMihnLGUsITApO2crPTQ7bC5zZXRJbnQzMihnLC10LCEwKTtnKz00O2wuc2V0VWludDE2KGcsMSwhMCk7Zys9MjtsLnNldFVpbnQxNihnLGEsITApO2crPTI7bC5zZXRVaW50MzIoZyxvLCEwKTtnKz00O2wuc2V0VWludDMyKGcsMCwhMCk7Zys9NDtsLnNldEludDMyKGcsMCwhMCk7Zys9NDtsLnNldEludDMyKGcsMCwhMCk7Zys9NDtsLnNldFVpbnQzMihnLHIubGVuZ3RoLzQsITApO2crPTQ7bC5zZXRVaW50MzIoZywwLCEwKTtnKz00O2guc2V0KG4sZyk7Zys9bi5sZW5ndGg7aC5zZXQocixnKTtnKz1yLmxlbmd0aDtoLnNldChzLGcpO3JldHVybiBofX1JbWFnZVJlc2l6ZXIuX2dvb2RTcXVhcmVMZW5ndGg9MjA0ODtjb25zdCBtcz0zMjg1Mzc3NTIwLHlzPTQyOTQ5MDE3NjAsd3M9NjU1MzU7Y2xhc3MgTXVybXVySGFzaDNfNjR7Y29uc3RydWN0b3IoZSl7dGhpcy5oMT1lPzQyOTQ5NjcyOTUmZTptczt0aGlzLmgyPWU/NDI5NDk2NzI5NSZlOm1zfXVwZGF0ZShlKXtsZXQgdCxpO2lmKCJzdHJpbmciPT10eXBlb2YgZSl7dD1uZXcgVWludDhBcnJheSgyKmUubGVuZ3RoKTtpPTA7Zm9yKGxldCBhPTAscz1lLmxlbmd0aDthPHM7YSsrKXtjb25zdCBzPWUuY2hhckNvZGVBdChhKTtpZihzPD0yNTUpdFtpKytdPXM7ZWxzZXt0W2krK109cz4+Pjg7dFtpKytdPTI1NSZzfX19ZWxzZXtpZighQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBkYXRhIGZvcm1hdCwgbXVzdCBiZSBhIHN0cmluZyBvciBUeXBlZEFycmF5LiIpO3Q9ZS5zbGljZSgpO2k9dC5ieXRlTGVuZ3RofWNvbnN0IGE9aT4+MixzPWktNCphLHI9bmV3IFVpbnQzMkFycmF5KHQuYnVmZmVyLDAsYSk7bGV0IG49MCxvPTAsZz10aGlzLmgxLGM9dGhpcy5oMjtjb25zdCBDPTM0MzI5MTgzNTMsaD00NjE4NDU5MDcsbD0xMTYwMSxRPTEzNzE1O2ZvcihsZXQgZT0wO2U8YTtlKyspaWYoMSZlKXtuPXJbZV07bj1uKkMmeXN8bipsJndzO249bjw8MTV8bj4+PjE3O249bipoJnlzfG4qUSZ3cztnXj1uO2c9Zzw8MTN8Zz4+PjE5O2c9NSpnKzM4NjQyOTIxOTZ9ZWxzZXtvPXJbZV07bz1vKkMmeXN8bypsJndzO289bzw8MTV8bz4+PjE3O289bypoJnlzfG8qUSZ3cztjXj1vO2M9Yzw8MTN8Yz4+PjE5O2M9NSpjKzM4NjQyOTIxOTZ9bj0wO3N3aXRjaChzKXtjYXNlIDM6bl49dFs0KmErMl08PDE2O2Nhc2UgMjpuXj10WzQqYSsxXTw8ODtjYXNlIDE6bl49dFs0KmFdO249bipDJnlzfG4qbCZ3cztuPW48PDE1fG4+Pj4xNztuPW4qaCZ5c3xuKlEmd3M7MSZhP2dePW46Y149bn10aGlzLmgxPWc7dGhpcy5oMj1jfWhleGRpZ2VzdCgpe2xldCBlPXRoaXMuaDEsdD10aGlzLmgyO2VePXQ+Pj4xO2U9Mzk4MTgwNjc5NyplJnlzfDM2MDQ1KmUmd3M7dD00MjgzNTQzNTExKnQmeXN8KDI5NTAxNjM3OTcqKHQ8PDE2fGU+Pj4xNikmeXMpPj4+MTY7ZV49dD4+PjE7ZT00NDQ5ODQ0MDMqZSZ5c3w2MDQ5OSplJndzO3Q9MzMwMTg4MjM2Nip0JnlzfCgzMTIwNDM3ODkzKih0PDwxNnxlPj4+MTYpJnlzKT4+PjE2O2VePXQ+Pj4xO3JldHVybihlPj4+MCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIjAiKSsodD4+PjApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCIwIil9fWZ1bmN0aW9uIGFkZFN0YXRlKGUsdCxpLGEscyl7bGV0IHI9ZTtmb3IobGV0IGU9MCxpPXQubGVuZ3RoLTE7ZTxpO2UrKyl7Y29uc3QgaT10W2VdO3I9cltpXXx8PVtdfXJbdC5hdCgtMSldPXtjaGVja0ZuOmksaXRlcmF0ZUZuOmEscHJvY2Vzc0ZuOnN9fWNvbnN0IGJzPVtdO2FkZFN0YXRlKGJzLFtHQSxVQSx6ZSx4QV0sbnVsbCwoZnVuY3Rpb24gaXRlcmF0ZUlubGluZUltYWdlR3JvdXAoZSx0KXtjb25zdCBpPWUuZm5BcnJheSxhPSh0LShlLmlDdXJyLTMpKSU0O3N3aXRjaChhKXtjYXNlIDA6cmV0dXJuIGlbdF09PT1HQTtjYXNlIDE6cmV0dXJuIGlbdF09PT1VQTtjYXNlIDI6cmV0dXJuIGlbdF09PT16ZTtjYXNlIDM6cmV0dXJuIGlbdF09PT14QX10aHJvdyBuZXcgRXJyb3IoYGl0ZXJhdGVJbmxpbmVJbWFnZUdyb3VwIC0gaW52YWxpZCBwb3M6ICR7YX1gKX0pLChmdW5jdGlvbiBmb3VuZElubGluZUltYWdlR3JvdXAoZSx0KXtjb25zdCBpPWUuZm5BcnJheSxhPWUuYXJnc0FycmF5LHM9ZS5pQ3VycixyPXMtMyxuPXMtMixvPXMtMSxnPU1hdGgubWluKE1hdGguZmxvb3IoKHQtcikvNCksMjAwKTtpZihnPDEwKXJldHVybiB0LSh0LXIpJTQ7bGV0IGM9MDtjb25zdCBDPVtdO2xldCBoPTAsbD0xLFE9MTtmb3IobGV0IGU9MDtlPGc7ZSsrKXtjb25zdCB0PWFbbisoZTw8MildLGk9YVtvKyhlPDwyKV1bMF07aWYobCtpLndpZHRoPjFlMyl7Yz1NYXRoLm1heChjLGwpO1ErPWgrMjtsPTA7aD0wfUMucHVzaCh7dHJhbnNmb3JtOnQseDpsLHk6USx3Omkud2lkdGgsaDppLmhlaWdodH0pO2wrPWkud2lkdGgrMjtoPU1hdGgubWF4KGgsaS5oZWlnaHQpfWNvbnN0IEU9TWF0aC5tYXgoYyxsKSsxLHU9UStoKzEsZD1uZXcgVWludDhBcnJheShFKnUqNCksZj1FPDwyO2ZvcihsZXQgZT0wO2U8ZztlKyspe2NvbnN0IHQ9YVtvKyhlPDwyKV1bMF0uZGF0YSxpPUNbZV0udzw8MjtsZXQgcz0wLHI9Q1tlXS54K0NbZV0ueSpFPDwyO2Quc2V0KHQuc3ViYXJyYXkoMCxpKSxyLWYpO2ZvcihsZXQgYT0wLG49Q1tlXS5oO2E8bjthKyspe2Quc2V0KHQuc3ViYXJyYXkocyxzK2kpLHIpO3MrPWk7cis9Zn1kLnNldCh0LnN1YmFycmF5KHMtaSxzKSxyKTtmb3IoO3I+PTA7KXt0W3ItNF09dFtyXTt0W3ItM109dFtyKzFdO3Rbci0yXT10W3IrMl07dFtyLTFdPXRbciszXTt0W3IraV09dFtyK2ktNF07dFtyK2krMV09dFtyK2ktM107dFtyK2krMl09dFtyK2ktMl07dFtyK2krM109dFtyK2ktMV07ci09Zn19Y29uc3QgcD17d2lkdGg6RSxoZWlnaHQ6dX07aWYoZS5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCl7Y29uc3QgZT1uZXcgT2Zmc2NyZWVuQ2FudmFzKEUsdSk7ZS5nZXRDb250ZXh0KCIyZCIpLnB1dEltYWdlRGF0YShuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShkLmJ1ZmZlciksRSx1KSwwLDApO3AuYml0bWFwPWUudHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7cC5kYXRhPW51bGx9ZWxzZXtwLmtpbmQ9RjtwLmRhdGE9ZH1pLnNwbGljZShyLDQqZyxfZSk7YS5zcGxpY2Uociw0KmcsW3AsQ10pO3JldHVybiByKzF9KSk7YWRkU3RhdGUoYnMsW0dBLFVBLFhlLHhBXSxudWxsLChmdW5jdGlvbiBpdGVyYXRlSW1hZ2VNYXNrR3JvdXAoZSx0KXtjb25zdCBpPWUuZm5BcnJheSxhPSh0LShlLmlDdXJyLTMpKSU0O3N3aXRjaChhKXtjYXNlIDA6cmV0dXJuIGlbdF09PT1HQTtjYXNlIDE6cmV0dXJuIGlbdF09PT1VQTtjYXNlIDI6cmV0dXJuIGlbdF09PT1YZTtjYXNlIDM6cmV0dXJuIGlbdF09PT14QX10aHJvdyBuZXcgRXJyb3IoYGl0ZXJhdGVJbWFnZU1hc2tHcm91cCAtIGludmFsaWQgcG9zOiAke2F9YCl9KSwoZnVuY3Rpb24gZm91bmRJbWFnZU1hc2tHcm91cChlLHQpe2NvbnN0IGk9ZS5mbkFycmF5LGE9ZS5hcmdzQXJyYXkscz1lLmlDdXJyLHI9cy0zLG49cy0yLG89cy0xO2xldCBnPU1hdGguZmxvb3IoKHQtcikvNCk7aWYoZzwxMClyZXR1cm4gdC0odC1yKSU0O2xldCBjLEMsaD0hMTtjb25zdCBsPWFbb11bMF0sUT1hW25dWzBdLEU9YVtuXVsxXSx1PWFbbl1bMl0sZD1hW25dWzNdO2lmKEU9PT11KXtoPSEwO2M9bis0O2xldCBlPW8rNDtmb3IobGV0IHQ9MTt0PGc7dCsrLGMrPTQsZSs9NCl7Qz1hW2NdO2lmKGFbZV1bMF0hPT1sfHxDWzBdIT09UXx8Q1sxXSE9PUV8fENbMl0hPT11fHxDWzNdIT09ZCl7dDwxMD9oPSExOmc9dDticmVha319fWlmKGgpe2c9TWF0aC5taW4oZywxZTMpO2NvbnN0IGU9bmV3IEZsb2F0MzJBcnJheSgyKmcpO2M9bjtmb3IobGV0IHQ9MDt0PGc7dCsrLGMrPTQpe0M9YVtjXTtlW3Q8PDFdPUNbNF07ZVsxKyh0PDwxKV09Q1s1XX1pLnNwbGljZShyLDQqZyxBdCk7YS5zcGxpY2Uociw0KmcsW2wsUSxFLHUsZCxlXSl9ZWxzZXtnPU1hdGgubWluKGcsMTAwKTtjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8Zzt0Kyspe0M9YVtuKyh0PDwyKV07Y29uc3QgaT1hW28rKHQ8PDIpXVswXTtlLnB1c2goe2RhdGE6aS5kYXRhLHdpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0LGludGVycG9sYXRlOmkuaW50ZXJwb2xhdGUsY291bnQ6aS5jb3VudCx0cmFuc2Zvcm06Q30pfWkuc3BsaWNlKHIsNCpnLFplKTthLnNwbGljZShyLDQqZyxbZV0pfXJldHVybiByKzF9KSk7YWRkU3RhdGUoYnMsW0dBLFVBLFZlLHhBXSwoZnVuY3Rpb24oZSl7Y29uc3QgdD1lLmFyZ3NBcnJheSxpPWUuaUN1cnItMjtyZXR1cm4gMD09PXRbaV1bMV0mJjA9PT10W2ldWzJdfSksKGZ1bmN0aW9uIGl0ZXJhdGVJbWFnZUdyb3VwKGUsdCl7Y29uc3QgaT1lLmZuQXJyYXksYT1lLmFyZ3NBcnJheSxzPSh0LShlLmlDdXJyLTMpKSU0O3N3aXRjaChzKXtjYXNlIDA6cmV0dXJuIGlbdF09PT1HQTtjYXNlIDE6aWYoaVt0XSE9PVVBKXJldHVybiExO2NvbnN0IHM9ZS5pQ3Vyci0yLHI9YVtzXVswXSxuPWFbc11bM107cmV0dXJuIGFbdF1bMF09PT1yJiYwPT09YVt0XVsxXSYmMD09PWFbdF1bMl0mJmFbdF1bM109PT1uO2Nhc2UgMjppZihpW3RdIT09VmUpcmV0dXJuITE7Y29uc3Qgbz1hW2UuaUN1cnItMV1bMF07cmV0dXJuIGFbdF1bMF09PT1vO2Nhc2UgMzpyZXR1cm4gaVt0XT09PXhBfXRocm93IG5ldyBFcnJvcihgaXRlcmF0ZUltYWdlR3JvdXAgLSBpbnZhbGlkIHBvczogJHtzfWApfSksKGZ1bmN0aW9uKGUsdCl7Y29uc3QgaT1lLmZuQXJyYXksYT1lLmFyZ3NBcnJheSxzPWUuaUN1cnIscj1zLTMsbj1zLTIsbz1hW3MtMV1bMF0sZz1hW25dWzBdLGM9YVtuXVszXSxDPU1hdGgubWluKE1hdGguZmxvb3IoKHQtcikvNCksMWUzKTtpZihDPDMpcmV0dXJuIHQtKHQtciklNDtjb25zdCBoPW5ldyBGbG9hdDMyQXJyYXkoMipDKTtsZXQgbD1uO2ZvcihsZXQgZT0wO2U8QztlKyssbCs9NCl7Y29uc3QgdD1hW2xdO2hbZTw8MV09dFs0XTtoWzErKGU8PDEpXT10WzVdfWNvbnN0IFE9W28sZyxjLGhdO2kuc3BsaWNlKHIsNCpDLCRlKTthLnNwbGljZShyLDQqQyxRKTtyZXR1cm4gcisxfSkpO2FkZFN0YXRlKGJzLFskQSxzZSxJZSxDZSxBZV0sbnVsbCwoZnVuY3Rpb24gaXRlcmF0ZVNob3dUZXh0R3JvdXAoZSx0KXtjb25zdCBpPWUuZm5BcnJheSxhPWUuYXJnc0FycmF5LHM9KHQtKGUuaUN1cnItNCkpJTU7c3dpdGNoKHMpe2Nhc2UgMDpyZXR1cm4gaVt0XT09PSRBO2Nhc2UgMTpyZXR1cm4gaVt0XT09PXNlO2Nhc2UgMjpyZXR1cm4gaVt0XT09PUllO2Nhc2UgMzppZihpW3RdIT09Q2UpcmV0dXJuITE7Y29uc3Qgcz1lLmlDdXJyLTMscj1hW3NdWzBdLG49YVtzXVsxXTtyZXR1cm4gYVt0XVswXT09PXImJmFbdF1bMV09PT1uO2Nhc2UgNDpyZXR1cm4gaVt0XT09PUFlfXRocm93IG5ldyBFcnJvcihgaXRlcmF0ZVNob3dUZXh0R3JvdXAgLSBpbnZhbGlkIHBvczogJHtzfWApfSksKGZ1bmN0aW9uKGUsdCl7Y29uc3QgaT1lLmZuQXJyYXksYT1lLmFyZ3NBcnJheSxzPWUuaUN1cnIscj1zLTQsbj1zLTMsbz1zLTIsZz1zLTEsYz1zLEM9YVtuXVswXSxoPWFbbl1bMV07bGV0IGw9TWF0aC5taW4oTWF0aC5mbG9vcigodC1yKS81KSwxZTMpO2lmKGw8MylyZXR1cm4gdC0odC1yKSU1O2xldCBRPXI7aWYocj49NCYmaVtyLTRdPT09aVtuXSYmaVtyLTNdPT09aVtvXSYmaVtyLTJdPT09aVtnXSYmaVtyLTFdPT09aVtjXSYmYVtyLTRdWzBdPT09QyYmYVtyLTRdWzFdPT09aCl7bCsrO1EtPTV9bGV0IEU9USs0O2ZvcihsZXQgZT0xO2U8bDtlKyspe2kuc3BsaWNlKEUsMyk7YS5zcGxpY2UoRSwzKTtFKz0yfXJldHVybiBFKzF9KSk7Y2xhc3MgTnVsbE9wdGltaXplcntjb25zdHJ1Y3RvcihlKXt0aGlzLnF1ZXVlPWV9X29wdGltaXplKCl7fXB1c2goZSx0KXt0aGlzLnF1ZXVlLmZuQXJyYXkucHVzaChlKTt0aGlzLnF1ZXVlLmFyZ3NBcnJheS5wdXNoKHQpO3RoaXMuX29wdGltaXplKCl9Zmx1c2goKXt9cmVzZXQoKXt9fWNsYXNzIFF1ZXVlT3B0aW1pemVyIGV4dGVuZHMgTnVsbE9wdGltaXplcntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLnN0YXRlPW51bGw7dGhpcy5jb250ZXh0PXtpQ3VycjowLGZuQXJyYXk6ZS5mbkFycmF5LGFyZ3NBcnJheTplLmFyZ3NBcnJheSxpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDohMX07dGhpcy5tYXRjaD1udWxsO3RoaXMubGFzdFByb2Nlc3NlZD0wfXNldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZChlKXt0aGlzLmNvbnRleHQuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ9ZX1fb3B0aW1pemUoKXtjb25zdCBlPXRoaXMucXVldWUuZm5BcnJheTtsZXQgdD10aGlzLmxhc3RQcm9jZXNzZWQsaT1lLmxlbmd0aCxhPXRoaXMuc3RhdGUscz10aGlzLm1hdGNoO2lmKCFhJiYhcyYmdCsxPT09aSYmIWJzW2VbdF1dKXt0aGlzLmxhc3RQcm9jZXNzZWQ9aTtyZXR1cm59Y29uc3Qgcj10aGlzLmNvbnRleHQ7Zm9yKDt0PGk7KXtpZihzKXtpZigoMCxzLml0ZXJhdGVGbikocix0KSl7dCsrO2NvbnRpbnVlfXQ9KDAscy5wcm9jZXNzRm4pKHIsdCsxKTtpPWUubGVuZ3RoO3M9bnVsbDthPW51bGw7aWYodD49aSlicmVha31hPShhfHxicylbZVt0XV07aWYoYSYmIUFycmF5LmlzQXJyYXkoYSkpe3IuaUN1cnI9dDt0Kys7aWYoIWEuY2hlY2tGbnx8KDAsYS5jaGVja0ZuKShyKSl7cz1hO2E9bnVsbH1lbHNlIGE9bnVsbH1lbHNlIHQrK310aGlzLnN0YXRlPWE7dGhpcy5tYXRjaD1zO3RoaXMubGFzdFByb2Nlc3NlZD10fWZsdXNoKCl7Zm9yKDt0aGlzLm1hdGNoOyl7Y29uc3QgZT10aGlzLnF1ZXVlLmZuQXJyYXkubGVuZ3RoO3RoaXMubGFzdFByb2Nlc3NlZD0oMCx0aGlzLm1hdGNoLnByb2Nlc3NGbikodGhpcy5jb250ZXh0LGUpO3RoaXMubWF0Y2g9bnVsbDt0aGlzLnN0YXRlPW51bGw7dGhpcy5fb3B0aW1pemUoKX19cmVzZXQoKXt0aGlzLnN0YXRlPW51bGw7dGhpcy5tYXRjaD1udWxsO3RoaXMubGFzdFByb2Nlc3NlZD0wfX1jbGFzcyBPcGVyYXRvckxpc3R7c3RhdGljIENIVU5LX1NJWkU9MWUzO3N0YXRpYyBDSFVOS19TSVpFX0FCT1VUPXRoaXMuQ0hVTktfU0laRS01O2NvbnN0cnVjdG9yKGU9MCx0KXt0aGlzLl9zdHJlYW1TaW5rPXQ7dGhpcy5mbkFycmF5PVtdO3RoaXMuYXJnc0FycmF5PVtdO3RoaXMub3B0aW1pemVyPSF0fHxlJlE/bmV3IE51bGxPcHRpbWl6ZXIodGhpcyk6bmV3IFF1ZXVlT3B0aW1pemVyKHRoaXMpO3RoaXMuZGVwZW5kZW5jaWVzPW5ldyBTZXQ7dGhpcy5fdG90YWxMZW5ndGg9MDt0aGlzLndlaWdodD0wO3RoaXMuX3Jlc29sdmVkPXQ/bnVsbDpQcm9taXNlLnJlc29sdmUoKX1zZXQgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQoZSl7dGhpcy5vcHRpbWl6ZXIuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ9ZX1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuYXJnc0FycmF5Lmxlbmd0aH1nZXQgcmVhZHkoKXtyZXR1cm4gdGhpcy5fcmVzb2x2ZWR8fHRoaXMuX3N0cmVhbVNpbmsucmVhZHl9Z2V0IHRvdGFsTGVuZ3RoKCl7cmV0dXJuIHRoaXMuX3RvdGFsTGVuZ3RoK3RoaXMubGVuZ3RofWFkZE9wKGUsdCl7dGhpcy5vcHRpbWl6ZXIucHVzaChlLHQpO3RoaXMud2VpZ2h0Kys7dGhpcy5fc3RyZWFtU2luayYmKHRoaXMud2VpZ2h0Pj1PcGVyYXRvckxpc3QuQ0hVTktfU0laRXx8dGhpcy53ZWlnaHQ+PU9wZXJhdG9yTGlzdC5DSFVOS19TSVpFX0FCT1VUJiYoZT09PXhBfHxlPT09QWUpKSYmdGhpcy5mbHVzaCgpfWFkZEltYWdlT3BzKGUsdCxpKXt2b2lkIDAhPT1pJiZ0aGlzLmFkZE9wKEplLFsiT0MiLGldKTt0aGlzLmFkZE9wKGUsdCk7dm9pZCAwIT09aSYmdGhpcy5hZGRPcChZZSxbXSl9YWRkRGVwZW5kZW5jeShlKXtpZighdGhpcy5kZXBlbmRlbmNpZXMuaGFzKGUpKXt0aGlzLmRlcGVuZGVuY2llcy5hZGQoZSk7dGhpcy5hZGRPcCh5QSxbZV0pfX1hZGREZXBlbmRlbmNpZXMoZSl7Zm9yKGNvbnN0IHQgb2YgZSl0aGlzLmFkZERlcGVuZGVuY3kodCl9YWRkT3BMaXN0KGUpe2lmKGUgaW5zdGFuY2VvZiBPcGVyYXRvckxpc3Qpe2Zvcihjb25zdCB0IG9mIGUuZGVwZW5kZW5jaWVzKXRoaXMuZGVwZW5kZW5jaWVzLmFkZCh0KTtmb3IobGV0IHQ9MCxpPWUubGVuZ3RoO3Q8aTt0KyspdGhpcy5hZGRPcChlLmZuQXJyYXlbdF0sZS5hcmdzQXJyYXlbdF0pfWVsc2Ugd2FybignYWRkT3BMaXN0IC0gaWdub3JpbmcgaW52YWxpZCAib3BMaXN0IiBwYXJhbWV0ZXIuJyl9Z2V0SVIoKXtyZXR1cm57Zm5BcnJheTp0aGlzLmZuQXJyYXksYXJnc0FycmF5OnRoaXMuYXJnc0FycmF5LGxlbmd0aDp0aGlzLmxlbmd0aH19Z2V0IF90cmFuc2ZlcnMoKXtjb25zdCBlPVtdLHtmbkFycmF5OnQsYXJnc0FycmF5OmksbGVuZ3RoOmF9PXRoaXM7Zm9yKGxldCBzPTA7czxhO3MrKylzd2l0Y2godFtzXSl7Y2FzZSB6ZTpjYXNlIF9lOmNhc2UgWGU6Y29uc3QgdD1pW3NdWzBdOyF0LmNhY2hlZCYmdC5kYXRhPy5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmZS5wdXNoKHQuZGF0YS5idWZmZXIpfXJldHVybiBlfWZsdXNoKGU9ITEsdD1udWxsKXt0aGlzLm9wdGltaXplci5mbHVzaCgpO2NvbnN0IGk9dGhpcy5sZW5ndGg7dGhpcy5fdG90YWxMZW5ndGgrPWk7dGhpcy5fc3RyZWFtU2luay5lbnF1ZXVlKHtmbkFycmF5OnRoaXMuZm5BcnJheSxhcmdzQXJyYXk6dGhpcy5hcmdzQXJyYXksbGFzdENodW5rOmUsc2VwYXJhdGVBbm5vdHM6dCxsZW5ndGg6aX0sMSx0aGlzLl90cmFuc2ZlcnMpO3RoaXMuZGVwZW5kZW5jaWVzLmNsZWFyKCk7dGhpcy5mbkFycmF5Lmxlbmd0aD0wO3RoaXMuYXJnc0FycmF5Lmxlbmd0aD0wO3RoaXMud2VpZ2h0PTA7dGhpcy5vcHRpbWl6ZXIucmVzZXQoKX19ZnVuY3Rpb24gZGVjb2RlQW5kQ2xhbXAoZSx0LGksYSl7KGU9dCtlKmkpPDA/ZT0wOmU+YSYmKGU9YSk7cmV0dXJuIGV9ZnVuY3Rpb24gcmVzaXplSW1hZ2VNYXNrKGUsdCxpLGEscyxyKXtjb25zdCBuPXMqcjtsZXQgbztvPXQ8PTg/bmV3IFVpbnQ4QXJyYXkobik6dDw9MTY/bmV3IFVpbnQxNkFycmF5KG4pOm5ldyBVaW50MzJBcnJheShuKTtjb25zdCBnPWkvcyxjPWEvcjtsZXQgQyxoLGwsUSxFPTA7Y29uc3QgdT1uZXcgVWludDE2QXJyYXkocyksZD1pO2ZvcihDPTA7QzxzO0MrKyl1W0NdPU1hdGguZmxvb3IoQypnKTtmb3IoQz0wO0M8cjtDKyspe2w9TWF0aC5mbG9vcihDKmMpKmQ7Zm9yKGg9MDtoPHM7aCsrKXtRPWwrdVtoXTtvW0UrK109ZVtRXX19cmV0dXJuIG99Y2xhc3MgUERGSW1hZ2V7Y29uc3RydWN0b3Ioe3hyZWY6ZSxyZXM6dCxpbWFnZTppLGlzSW5saW5lOmE9ITEsc21hc2s6cz1udWxsLG1hc2s6cj1udWxsLGlzTWFzazpuPSExLHBkZkZ1bmN0aW9uRmFjdG9yeTpvLGxvY2FsQ29sb3JTcGFjZUNhY2hlOmd9KXt0aGlzLmltYWdlPWk7bGV0IGM9ITE7Y29uc3QgQz1pLmRpY3QsaD1DLmdldCgiRiIsIkZpbHRlciIpO2xldCBsO2lmKGggaW5zdGFuY2VvZiBOYW1lKWw9aC5uYW1lO2Vsc2UgaWYoQXJyYXkuaXNBcnJheShoKSl7Y29uc3QgdD1lLmZldGNoSWZSZWYoaFswXSk7dCBpbnN0YW5jZW9mIE5hbWUmJihsPXQubmFtZSl9c3dpdGNoKGwpe2Nhc2UiSlBYRGVjb2RlIjooe3dpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0LGNvbXBvbmVudHNDb3VudDppLm51bUNvbXBzLGJpdHNQZXJDb21wb25lbnQ6aS5iaXRzUGVyQ29tcG9uZW50fT1KcHhJbWFnZS5wYXJzZUltYWdlUHJvcGVydGllcyhpLnN0cmVhbSkpO2kuc3RyZWFtLnJlc2V0KCk7Yz0hMDticmVhaztjYXNlIkpCSUcyRGVjb2RlIjppLmJpdHNQZXJDb21wb25lbnQ9MTtpLm51bUNvbXBzPTF9bGV0IFE9Qy5nZXQoIlciLCJXaWR0aCIpLEU9Qy5nZXQoIkgiLCJIZWlnaHQiKTtpZihOdW1iZXIuaXNJbnRlZ2VyKGkud2lkdGgpJiZpLndpZHRoPjAmJk51bWJlci5pc0ludGVnZXIoaS5oZWlnaHQpJiZpLmhlaWdodD4wJiYoaS53aWR0aCE9PVF8fGkuaGVpZ2h0IT09RSkpe3dhcm4oIlBERkltYWdlIC0gdXNpbmcgdGhlIFdpZHRoL0hlaWdodCBvZiB0aGUgaW1hZ2UgZGF0YSwgcmF0aGVyIHRoYW4gdGhlIGltYWdlIGRpY3Rpb25hcnkuIik7UT1pLndpZHRoO0U9aS5oZWlnaHR9aWYoUTwxfHxFPDEpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIGltYWdlIHdpZHRoOiAke1F9IG9yIGhlaWdodDogJHtFfWApO3RoaXMud2lkdGg9UTt0aGlzLmhlaWdodD1FO3RoaXMuaW50ZXJwb2xhdGU9Qy5nZXQoIkkiLCJJbnRlcnBvbGF0ZSIpO3RoaXMuaW1hZ2VNYXNrPUMuZ2V0KCJJTSIsIkltYWdlTWFzayIpfHwhMTt0aGlzLm1hdHRlPUMuZ2V0KCJNYXR0ZSIpfHwhMTtsZXQgdT1pLmJpdHNQZXJDb21wb25lbnQ7aWYoIXUpe3U9Qy5nZXQoIkJQQyIsIkJpdHNQZXJDb21wb25lbnQiKTtpZighdSl7aWYoIXRoaXMuaW1hZ2VNYXNrKXRocm93IG5ldyBGb3JtYXRFcnJvcihgQml0cyBwZXIgY29tcG9uZW50IG1pc3NpbmcgaW4gaW1hZ2U6ICR7dGhpcy5pbWFnZU1hc2t9YCk7dT0xfX10aGlzLmJwYz11O2lmKCF0aGlzLmltYWdlTWFzayl7bGV0IHM9Qy5nZXRSYXcoIkNTIil8fEMuZ2V0UmF3KCJDb2xvclNwYWNlIik7aWYoIXMpe2luZm8oIkpQWCBpbWFnZXMgKHdoaWNoIGRvIG5vdCByZXF1aXJlIGNvbG9yIHNwYWNlcykiKTtzd2l0Y2goaS5udW1Db21wcyl7Y2FzZSAxOnM9TmFtZS5nZXQoIkRldmljZUdyYXkiKTticmVhaztjYXNlIDM6cz1OYW1lLmdldCgiRGV2aWNlUkdCIik7YnJlYWs7Y2FzZSA0OnM9TmFtZS5nZXQoIkRldmljZUNNWUsiKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgSlBYIGltYWdlcyB3aXRoICR7aS5udW1Db21wc30gY29sb3IgY29tcG9uZW50cyBub3Qgc3VwcG9ydGVkLmApfX10aGlzLmNvbG9yU3BhY2U9Q29sb3JTcGFjZS5wYXJzZSh7Y3M6cyx4cmVmOmUscmVzb3VyY2VzOmE/dDpudWxsLHBkZkZ1bmN0aW9uRmFjdG9yeTpvLGxvY2FsQ29sb3JTcGFjZUNhY2hlOmd9KTt0aGlzLm51bUNvbXBzPXRoaXMuY29sb3JTcGFjZS5udW1Db21wczt0aGlzLmlnbm9yZUNvbG9yU3BhY2U9YyYmIkluZGV4ZWQiPT09dGhpcy5jb2xvclNwYWNlLm5hbWV9dGhpcy5kZWNvZGU9Qy5nZXRBcnJheSgiRCIsIkRlY29kZSIpO3RoaXMubmVlZHNEZWNvZGU9ITE7aWYodGhpcy5kZWNvZGUmJih0aGlzLmNvbG9yU3BhY2UmJiF0aGlzLmNvbG9yU3BhY2UuaXNEZWZhdWx0RGVjb2RlKHRoaXMuZGVjb2RlLHUpfHxuJiYhQ29sb3JTcGFjZS5pc0RlZmF1bHREZWNvZGUodGhpcy5kZWNvZGUsMSkpKXt0aGlzLm5lZWRzRGVjb2RlPSEwO2NvbnN0IGU9KDE8PHUpLTE7dGhpcy5kZWNvZGVDb2VmZmljaWVudHM9W107dGhpcy5kZWNvZGVBZGRlbmRzPVtdO2NvbnN0IHQ9IkluZGV4ZWQiPT09dGhpcy5jb2xvclNwYWNlPy5uYW1lO2ZvcihsZXQgaT0wLGE9MDtpPHRoaXMuZGVjb2RlLmxlbmd0aDtpKz0yLCsrYSl7Y29uc3Qgcz10aGlzLmRlY29kZVtpXSxyPXRoaXMuZGVjb2RlW2krMV07dGhpcy5kZWNvZGVDb2VmZmljaWVudHNbYV09dD8oci1zKS9lOnItczt0aGlzLmRlY29kZUFkZGVuZHNbYV09dD9zOmUqc319aWYocyl0aGlzLnNtYXNrPW5ldyBQREZJbWFnZSh7eHJlZjplLHJlczp0LGltYWdlOnMsaXNJbmxpbmU6YSxwZGZGdW5jdGlvbkZhY3Rvcnk6byxsb2NhbENvbG9yU3BhY2VDYWNoZTpnfSk7ZWxzZSBpZihyKWlmKHIgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKXtyLmRpY3QuZ2V0KCJJTSIsIkltYWdlTWFzayIpP3RoaXMubWFzaz1uZXcgUERGSW1hZ2Uoe3hyZWY6ZSxyZXM6dCxpbWFnZTpyLGlzSW5saW5lOmEsaXNNYXNrOiEwLHBkZkZ1bmN0aW9uRmFjdG9yeTpvLGxvY2FsQ29sb3JTcGFjZUNhY2hlOmd9KTp3YXJuKCJJZ25vcmluZyAvTWFzayBpbiBpbWFnZSB3aXRob3V0IC9JbWFnZU1hc2suIil9ZWxzZSB0aGlzLm1hc2s9cn1zdGF0aWMgYXN5bmMgYnVpbGRJbWFnZSh7eHJlZjplLHJlczp0LGltYWdlOmksaXNJbmxpbmU6YT0hMSxwZGZGdW5jdGlvbkZhY3Rvcnk6cyxsb2NhbENvbG9yU3BhY2VDYWNoZTpyfSl7Y29uc3Qgbj1pO2xldCBvPW51bGwsZz1udWxsO2NvbnN0IGM9aS5kaWN0LmdldCgiU01hc2siKSxDPWkuZGljdC5nZXQoIk1hc2siKTtjP2MgaW5zdGFuY2VvZiBCYXNlU3RyZWFtP289Yzp3YXJuKCJVbnN1cHBvcnRlZCAvU01hc2sgZm9ybWF0LiIpOkMmJihDIGluc3RhbmNlb2YgQmFzZVN0cmVhbXx8QXJyYXkuaXNBcnJheShDKT9nPUM6d2FybigiVW5zdXBwb3J0ZWQgL01hc2sgZm9ybWF0LiIpKTtyZXR1cm4gbmV3IFBERkltYWdlKHt4cmVmOmUscmVzOnQsaW1hZ2U6bixpc0lubGluZTphLHNtYXNrOm8sbWFzazpnLHBkZkZ1bmN0aW9uRmFjdG9yeTpzLGxvY2FsQ29sb3JTcGFjZUNhY2hlOnJ9KX1zdGF0aWMgY3JlYXRlUmF3TWFzayh7aW1nQXJyYXk6ZSx3aWR0aDp0LGhlaWdodDppLGltYWdlSXNGcm9tRGVjb2RlU3RyZWFtOmEsaW52ZXJzZURlY29kZTpzLGludGVycG9sYXRlOnJ9KXtjb25zdCBuPSh0Kzc+PjMpKmksbz1lLmJ5dGVMZW5ndGg7bGV0IGcsYztpZighYXx8cyYmIShuPT09bykpaWYocyl7Zz1uZXcgVWludDhBcnJheShuKTtnLnNldChlKTtnLmZpbGwoMjU1LG8pfWVsc2UgZz1uZXcgVWludDhBcnJheShlKTtlbHNlIGc9ZTtpZihzKWZvcihjPTA7YzxvO2MrKylnW2NdXj0yNTU7cmV0dXJue2RhdGE6Zyx3aWR0aDp0LGhlaWdodDppLGludGVycG9sYXRlOnJ9fXN0YXRpYyBhc3luYyBjcmVhdGVNYXNrKHtpbWdBcnJheTplLHdpZHRoOnQsaGVpZ2h0OmksaW1hZ2VJc0Zyb21EZWNvZGVTdHJlYW06YSxpbnZlcnNlRGVjb2RlOnMsaW50ZXJwb2xhdGU6cixpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDpuPSExfSl7Y29uc3Qgbz0xPT09dCYmMT09PWkmJnM9PT0oMD09PWUubGVuZ3RofHwhISgxMjgmZVswXSkpO2lmKG8pcmV0dXJue2lzU2luZ2xlT3BhcXVlUGl4ZWw6b307aWYobil7aWYoSW1hZ2VSZXNpemVyLm5lZWRzVG9CZVJlc2l6ZWQodCxpKSl7Y29uc3QgYT1uZXcgVWludDhDbGFtcGVkQXJyYXkodCppKjQpO2NvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtzcmM6ZSxkZXN0OmEsd2lkdGg6dCxoZWlnaHQ6aSxub25CbGFja0NvbG9yOjAsaW52ZXJzZURlY29kZTpzfSk7cmV0dXJuIEltYWdlUmVzaXplci5jcmVhdGVJbWFnZSh7a2luZDpGLGRhdGE6YSx3aWR0aDp0LGhlaWdodDppLGludGVycG9sYXRlOnJ9KX1jb25zdCBhPW5ldyBPZmZzY3JlZW5DYW52YXModCxpKSxuPWEuZ2V0Q29udGV4dCgiMmQiKSxvPW4uY3JlYXRlSW1hZ2VEYXRhKHQsaSk7Y29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe3NyYzplLGRlc3Q6by5kYXRhLHdpZHRoOnQsaGVpZ2h0Omksbm9uQmxhY2tDb2xvcjowLGludmVyc2VEZWNvZGU6c30pO24ucHV0SW1hZ2VEYXRhKG8sMCwwKTtyZXR1cm57ZGF0YTpudWxsLHdpZHRoOnQsaGVpZ2h0OmksaW50ZXJwb2xhdGU6cixiaXRtYXA6YS50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKX19cmV0dXJuIHRoaXMuY3JlYXRlUmF3TWFzayh7aW1nQXJyYXk6ZSx3aWR0aDp0LGhlaWdodDppLGludmVyc2VEZWNvZGU6cyxpbWFnZUlzRnJvbURlY29kZVN0cmVhbTphLGludGVycG9sYXRlOnJ9KX1nZXQgZHJhd1dpZHRoKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMud2lkdGgsdGhpcy5zbWFzaz8ud2lkdGh8fDAsdGhpcy5tYXNrPy53aWR0aHx8MCl9Z2V0IGRyYXdIZWlnaHQoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5oZWlnaHQsdGhpcy5zbWFzaz8uaGVpZ2h0fHwwLHRoaXMubWFzaz8uaGVpZ2h0fHwwKX1kZWNvZGVCdWZmZXIoZSl7Y29uc3QgdD10aGlzLmJwYyxpPXRoaXMubnVtQ29tcHMsYT10aGlzLmRlY29kZUFkZGVuZHMscz10aGlzLmRlY29kZUNvZWZmaWNpZW50cyxyPSgxPDx0KS0xO2xldCBuLG87aWYoMT09PXQpe2ZvcihuPTAsbz1lLmxlbmd0aDtuPG87bisrKWVbbl09KyFlW25dO3JldHVybn1sZXQgZz0wO2ZvcihuPTAsbz10aGlzLndpZHRoKnRoaXMuaGVpZ2h0O248bztuKyspZm9yKGxldCB0PTA7dDxpO3QrKyl7ZVtnXT1kZWNvZGVBbmRDbGFtcChlW2ddLGFbdF0sc1t0XSxyKTtnKyt9fWdldENvbXBvbmVudHMoZSl7Y29uc3QgdD10aGlzLmJwYztpZig4PT09dClyZXR1cm4gZTtjb25zdCBpPXRoaXMud2lkdGgsYT10aGlzLmhlaWdodCxzPXRoaXMubnVtQ29tcHMscj1pKmEqcztsZXQgbixvPTA7bj10PD04P25ldyBVaW50OEFycmF5KHIpOnQ8PTE2P25ldyBVaW50MTZBcnJheShyKTpuZXcgVWludDMyQXJyYXkocik7Y29uc3QgZz1pKnMsYz0oMTw8dCktMTtsZXQgQyxoLGw9MDtpZigxPT09dCl7bGV0IHQsaSxzO2ZvcihsZXQgcj0wO3I8YTtyKyspe2k9bCsoLTgmZyk7cz1sK2c7Zm9yKDtsPGk7KXtoPWVbbysrXTtuW2xdPWg+PjcmMTtuW2wrMV09aD4+NiYxO25bbCsyXT1oPj41JjE7bltsKzNdPWg+PjQmMTtuW2wrNF09aD4+MyYxO25bbCs1XT1oPj4yJjE7bltsKzZdPWg+PjEmMTtuW2wrN109MSZoO2wrPTh9aWYobDxzKXtoPWVbbysrXTt0PTEyODtmb3IoO2w8czspe25bbCsrXT0rISEoaCZ0KTt0Pj49MX19fX1lbHNle2xldCBpPTA7aD0wO2ZvcihsPTAsQz1yO2w8QzsrK2wpe2lmKGwlZz09MCl7aD0wO2k9MH1mb3IoO2k8dDspe2g9aDw8OHxlW28rK107aSs9OH1jb25zdCBhPWktdDtsZXQgcz1oPj5hO3M8MD9zPTA6cz5jJiYocz1jKTtuW2xdPXM7aCY9KDE8PGEpLTE7aT1hfX1yZXR1cm4gbn1maWxsT3BhY2l0eShlLHQsaSxhLHMpe2NvbnN0IHI9dGhpcy5zbWFzayxuPXRoaXMubWFzaztsZXQgbyxnLGMsQyxoLGw7aWYocil7Zz1yLndpZHRoO2M9ci5oZWlnaHQ7bz1uZXcgVWludDhDbGFtcGVkQXJyYXkoZypjKTtyLmZpbGxHcmF5QnVmZmVyKG8pO2c9PT10JiZjPT09aXx8KG89cmVzaXplSW1hZ2VNYXNrKG8sci5icGMsZyxjLHQsaSkpfWVsc2UgaWYobilpZihuIGluc3RhbmNlb2YgUERGSW1hZ2Upe2c9bi53aWR0aDtjPW4uaGVpZ2h0O289bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGcqYyk7bi5udW1Db21wcz0xO24uZmlsbEdyYXlCdWZmZXIobyk7Zm9yKEM9MCxoPWcqYztDPGg7KytDKW9bQ109MjU1LW9bQ107Zz09PXQmJmM9PT1pfHwobz1yZXNpemVJbWFnZU1hc2sobyxuLmJwYyxnLGMsdCxpKSl9ZWxzZXtpZighQXJyYXkuaXNBcnJheShuKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlVua25vd24gbWFzayBmb3JtYXQuIik7e289bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHQqaSk7Y29uc3QgZT10aGlzLm51bUNvbXBzO2ZvcihDPTAsaD10Kmk7QzxoOysrQyl7bGV0IHQ9MDtjb25zdCBpPUMqZTtmb3IobD0wO2w8ZTsrK2wpe2NvbnN0IGU9c1tpK2xdLGE9MipsO2lmKGU8blthXXx8ZT5uW2ErMV0pe3Q9MjU1O2JyZWFrfX1vW0NdPXR9fX1pZihvKWZvcihDPTAsbD0zLGg9dCphO0M8aDsrK0MsbCs9NCllW2xdPW9bQ107ZWxzZSBmb3IoQz0wLGw9MyxoPXQqYTtDPGg7KytDLGwrPTQpZVtsXT0yNTV9dW5kb1ByZWJsZW5kKGUsdCxpKXtjb25zdCBhPXRoaXMuc21hc2s/Lm1hdHRlO2lmKCFhKXJldHVybjtjb25zdCBzPXRoaXMuY29sb3JTcGFjZS5nZXRSZ2IoYSwwKSxyPXNbMF0sbj1zWzFdLG89c1syXSxnPXQqaSo0O2ZvcihsZXQgdD0wO3Q8Zzt0Kz00KXtjb25zdCBpPWVbdCszXTtpZigwPT09aSl7ZVt0XT0yNTU7ZVt0KzFdPTI1NTtlW3QrMl09MjU1O2NvbnRpbnVlfWNvbnN0IGE9MjU1L2k7ZVt0XT0oZVt0XS1yKSphK3I7ZVt0KzFdPShlW3QrMV0tbikqYStuO2VbdCsyXT0oZVt0KzJdLW8pKmErb319YXN5bmMgY3JlYXRlSW1hZ2VEYXRhKGU9ITEsdD0hMSl7Y29uc3QgaT10aGlzLmRyYXdXaWR0aCxhPXRoaXMuZHJhd0hlaWdodCxzPXt3aWR0aDppLGhlaWdodDphLGludGVycG9sYXRlOnRoaXMuaW50ZXJwb2xhdGUsa2luZDowLGRhdGE6bnVsbH0scj10aGlzLm51bUNvbXBzLG49dGhpcy53aWR0aCxvPXRoaXMuaGVpZ2h0LGc9dGhpcy5icGMsYz1uKnIqZys3Pj4zLEM9dCYmSW1hZ2VSZXNpemVyLm5lZWRzVG9CZVJlc2l6ZWQoaSxhKTtpZighZSl7bGV0IGU7IkRldmljZUdyYXkiPT09dGhpcy5jb2xvclNwYWNlLm5hbWUmJjE9PT1nP2U9YjoiRGV2aWNlUkdCIiE9PXRoaXMuY29sb3JTcGFjZS5uYW1lfHw4IT09Z3x8dGhpcy5uZWVkc0RlY29kZXx8KGU9RCk7aWYoZSYmIXRoaXMuc21hc2smJiF0aGlzLm1hc2smJmk9PT1uJiZhPT09byl7Y29uc3Qgcj10aGlzLmdldEltYWdlQnl0ZXMobypjLHt9KTtpZih0KXJldHVybiBDP0ltYWdlUmVzaXplci5jcmVhdGVJbWFnZSh7ZGF0YTpyLGtpbmQ6ZSx3aWR0aDppLGhlaWdodDphLGludGVycG9sYXRlOnRoaXMuaW50ZXJwb2xhdGV9LHRoaXMubmVlZHNEZWNvZGUpOnRoaXMuY3JlYXRlQml0bWFwKGUsbixvLHIpO3Mua2luZD1lO3MuZGF0YT1yO2lmKHRoaXMubmVlZHNEZWNvZGUpe2Fzc2VydChlPT09YiwiUERGSW1hZ2UuY3JlYXRlSW1hZ2VEYXRhOiBUaGUgaW1hZ2UgbXVzdCBiZSBncmF5c2NhbGUuIik7Y29uc3QgdD1zLmRhdGE7Zm9yKGxldCBlPTAsaT10Lmxlbmd0aDtlPGk7ZSsrKXRbZV1ePTI1NX1yZXR1cm4gc31pZih0aGlzLmltYWdlIGluc3RhbmNlb2YgSnBlZ1N0cmVhbSYmIXRoaXMuc21hc2smJiF0aGlzLm1hc2smJiF0aGlzLm5lZWRzRGVjb2RlKXtsZXQgZT1vKmM7aWYodCYmIUMpe2xldCB0PSExO3N3aXRjaCh0aGlzLmNvbG9yU3BhY2UubmFtZSl7Y2FzZSJEZXZpY2VHcmF5IjplKj00O3Q9ITA7YnJlYWs7Y2FzZSJEZXZpY2VSR0IiOmU9ZS8zKjQ7dD0hMDticmVhaztjYXNlIkRldmljZUNNWUsiOnQ9ITB9aWYodCl7Y29uc3QgdD10aGlzLmdldEltYWdlQnl0ZXMoZSx7ZHJhd1dpZHRoOmksZHJhd0hlaWdodDphLGZvcmNlUkdCQTohMH0pO3JldHVybiB0aGlzLmNyZWF0ZUJpdG1hcChGLGksYSx0KX19ZWxzZSBzd2l0Y2godGhpcy5jb2xvclNwYWNlLm5hbWUpe2Nhc2UiRGV2aWNlR3JheSI6ZSo9MztjYXNlIkRldmljZVJHQiI6Y2FzZSJEZXZpY2VDTVlLIjpzLmtpbmQ9RDtzLmRhdGE9dGhpcy5nZXRJbWFnZUJ5dGVzKGUse2RyYXdXaWR0aDppLGRyYXdIZWlnaHQ6YSxmb3JjZVJHQjohMH0pO3JldHVybiBDP0ltYWdlUmVzaXplci5jcmVhdGVJbWFnZShzKTpzfX19Y29uc3QgaD10aGlzLmdldEltYWdlQnl0ZXMobypjLHtpbnRlcm5hbDohMH0pLGw9MHxoLmxlbmd0aC9jKmEvbyxRPXRoaXMuZ2V0Q29tcG9uZW50cyhoKTtsZXQgRSx1LGQsZixwLG07aWYodCYmIUMpe2Q9bmV3IE9mZnNjcmVlbkNhbnZhcyhpLGEpO2Y9ZC5nZXRDb250ZXh0KCIyZCIpO3A9Zi5jcmVhdGVJbWFnZURhdGEoaSxhKTttPXAuZGF0YX1zLmtpbmQ9RjtpZihlfHx0aGlzLnNtYXNrfHx0aGlzLm1hc2spe3QmJiFDfHwobT1uZXcgVWludDhDbGFtcGVkQXJyYXkoaSphKjQpKTtFPTE7dT0hMDt0aGlzLmZpbGxPcGFjaXR5KG0saSxhLGwsUSl9ZWxzZXtpZighdHx8Qyl7cy5raW5kPUQ7bT1uZXcgVWludDhDbGFtcGVkQXJyYXkoaSphKjMpO0U9MH1lbHNle25ldyBVaW50MzJBcnJheShtLmJ1ZmZlcikuZmlsbChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbj80Mjc4MTkwMDgwOjI1NSk7RT0xfXU9ITF9dGhpcy5uZWVkc0RlY29kZSYmdGhpcy5kZWNvZGVCdWZmZXIoUSk7dGhpcy5jb2xvclNwYWNlLmZpbGxSZ2IobSxuLG8saSxhLGwsZyxRLEUpO3UmJnRoaXMudW5kb1ByZWJsZW5kKG0saSxsKTtpZih0JiYhQyl7Zi5wdXRJbWFnZURhdGEocCwwLDApO3JldHVybntkYXRhOm51bGwsd2lkdGg6aSxoZWlnaHQ6YSxiaXRtYXA6ZC50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxpbnRlcnBvbGF0ZTp0aGlzLmludGVycG9sYXRlfX1zLmRhdGE9bTtyZXR1cm4gQz9JbWFnZVJlc2l6ZXIuY3JlYXRlSW1hZ2Uocyk6c31maWxsR3JheUJ1ZmZlcihlKXtjb25zdCB0PXRoaXMubnVtQ29tcHM7aWYoMSE9PXQpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBSZWFkaW5nIGdyYXkgc2NhbGUgZnJvbSBhIGNvbG9yIGltYWdlOiAke3R9YCk7Y29uc3QgaT10aGlzLndpZHRoLGE9dGhpcy5oZWlnaHQscz10aGlzLmJwYyxyPWkqdCpzKzc+PjMsbj10aGlzLmdldEltYWdlQnl0ZXMoYSpyLHtpbnRlcm5hbDohMH0pLG89dGhpcy5nZXRDb21wb25lbnRzKG4pO2xldCBnLGM7aWYoMT09PXMpe2M9aSphO2lmKHRoaXMubmVlZHNEZWNvZGUpZm9yKGc9MDtnPGM7KytnKWVbZ109b1tnXS0xJjI1NTtlbHNlIGZvcihnPTA7ZzxjOysrZyllW2ddPTI1NSYtb1tnXTtyZXR1cm59dGhpcy5uZWVkc0RlY29kZSYmdGhpcy5kZWNvZGVCdWZmZXIobyk7Yz1pKmE7Y29uc3QgQz0yNTUvKCgxPDxzKS0xKTtmb3IoZz0wO2c8YzsrK2cpZVtnXT1DKm9bZ119Y3JlYXRlQml0bWFwKGUsdCxpLGEpe2NvbnN0IHM9bmV3IE9mZnNjcmVlbkNhbnZhcyh0LGkpLHI9cy5nZXRDb250ZXh0KCIyZCIpO2xldCBuO2lmKGU9PT1GKW49bmV3IEltYWdlRGF0YShhLHQsaSk7ZWxzZXtuPXIuY3JlYXRlSW1hZ2VEYXRhKHQsaSk7Y29udmVydFRvUkdCQSh7a2luZDplLHNyYzphLGRlc3Q6bmV3IFVpbnQzMkFycmF5KG4uZGF0YS5idWZmZXIpLHdpZHRoOnQsaGVpZ2h0OmksaW52ZXJzZURlY29kZTp0aGlzLm5lZWRzRGVjb2RlfSl9ci5wdXRJbWFnZURhdGEobiwwLDApO3JldHVybntkYXRhOm51bGwsd2lkdGg6dCxoZWlnaHQ6aSxiaXRtYXA6cy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxpbnRlcnBvbGF0ZTp0aGlzLmludGVycG9sYXRlfX1nZXRJbWFnZUJ5dGVzKGUse2RyYXdXaWR0aDp0LGRyYXdIZWlnaHQ6aSxmb3JjZVJHQkE6YT0hMSxmb3JjZVJHQjpzPSExLGludGVybmFsOnI9ITF9KXt0aGlzLmltYWdlLnJlc2V0KCk7dGhpcy5pbWFnZS5kcmF3V2lkdGg9dHx8dGhpcy53aWR0aDt0aGlzLmltYWdlLmRyYXdIZWlnaHQ9aXx8dGhpcy5oZWlnaHQ7dGhpcy5pbWFnZS5mb3JjZVJHQkE9ISFhO3RoaXMuaW1hZ2UuZm9yY2VSR0I9ISFzO2NvbnN0IG49dGhpcy5pbWFnZS5nZXRCeXRlcyhlLHRoaXMuaWdub3JlQ29sb3JTcGFjZSk7aWYocnx8dGhpcy5pbWFnZSBpbnN0YW5jZW9mIERlY29kZVN0cmVhbSlyZXR1cm4gbjthc3NlcnQobiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksJ1BERkltYWdlLmdldEltYWdlQnl0ZXM6IFVuc3VwcG9ydGVkICJpbWFnZUJ5dGVzIiB0eXBlLicpO3JldHVybiBuZXcgVWludDhBcnJheShuKX19Y29uc3QgRHM9T2JqZWN0LmZyZWV6ZSh7bWF4SW1hZ2VTaXplOi0xLGRpc2FibGVGb250RmFjZTohMSxpZ25vcmVFcnJvcnM6ITEsaXNFdmFsU3VwcG9ydGVkOiEwLGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkOiExLGNhbnZhc01heEFyZWFJbkJ5dGVzOi0xLGZvbnRFeHRyYVByb3BlcnRpZXM6ITEsdXNlU3lzdGVtRm9udHM6ITAsY01hcFVybDpudWxsLHN0YW5kYXJkRm9udERhdGFVcmw6bnVsbH0pLEZzPTEsU3M9Mixrcz1Qcm9taXNlLnJlc29sdmUoKTtmdW5jdGlvbiBub3JtYWxpemVCbGVuZE1vZGUoZSx0PSExKXtpZihBcnJheS5pc0FycmF5KGUpKXtmb3IoY29uc3QgdCBvZiBlKXtjb25zdCBlPW5vcm1hbGl6ZUJsZW5kTW9kZSh0LCEwKTtpZihlKXJldHVybiBlfXdhcm4oYFVuc3VwcG9ydGVkIGJsZW5kIG1vZGUgQXJyYXk6ICR7ZX1gKTtyZXR1cm4ic291cmNlLW92ZXIifWlmKCEoZSBpbnN0YW5jZW9mIE5hbWUpKXJldHVybiB0P251bGw6InNvdXJjZS1vdmVyIjtzd2l0Y2goZS5uYW1lKXtjYXNlIk5vcm1hbCI6Y2FzZSJDb21wYXRpYmxlIjpyZXR1cm4ic291cmNlLW92ZXIiO2Nhc2UiTXVsdGlwbHkiOnJldHVybiJtdWx0aXBseSI7Y2FzZSJTY3JlZW4iOnJldHVybiJzY3JlZW4iO2Nhc2UiT3ZlcmxheSI6cmV0dXJuIm92ZXJsYXkiO2Nhc2UiRGFya2VuIjpyZXR1cm4iZGFya2VuIjtjYXNlIkxpZ2h0ZW4iOnJldHVybiJsaWdodGVuIjtjYXNlIkNvbG9yRG9kZ2UiOnJldHVybiJjb2xvci1kb2RnZSI7Y2FzZSJDb2xvckJ1cm4iOnJldHVybiJjb2xvci1idXJuIjtjYXNlIkhhcmRMaWdodCI6cmV0dXJuImhhcmQtbGlnaHQiO2Nhc2UiU29mdExpZ2h0IjpyZXR1cm4ic29mdC1saWdodCI7Y2FzZSJEaWZmZXJlbmNlIjpyZXR1cm4iZGlmZmVyZW5jZSI7Y2FzZSJFeGNsdXNpb24iOnJldHVybiJleGNsdXNpb24iO2Nhc2UiSHVlIjpyZXR1cm4iaHVlIjtjYXNlIlNhdHVyYXRpb24iOnJldHVybiJzYXR1cmF0aW9uIjtjYXNlIkNvbG9yIjpyZXR1cm4iY29sb3IiO2Nhc2UiTHVtaW5vc2l0eSI6cmV0dXJuImx1bWlub3NpdHkifWlmKHQpcmV0dXJuIG51bGw7d2FybihgVW5zdXBwb3J0ZWQgYmxlbmQgbW9kZTogJHtlLm5hbWV9YCk7cmV0dXJuInNvdXJjZS1vdmVyIn1mdW5jdGlvbiBpbmNyZW1lbnRDYWNoZWRJbWFnZU1hc2tDb3VudChlKXtlLmZuPT09WGUmJmUuYXJnc1swXT8uY291bnQ+MCYmZS5hcmdzWzBdLmNvdW50Kyt9Y2xhc3MgVGltZVNsb3RNYW5hZ2Vye3N0YXRpYyBUSU1FX1NMT1RfRFVSQVRJT05fTVM9MjA7c3RhdGljIENIRUNLX1RJTUVfRVZFUlk9MTAwO2NvbnN0cnVjdG9yKCl7dGhpcy5yZXNldCgpfWNoZWNrKCl7aWYoKyt0aGlzLmNoZWNrZWQ8VGltZVNsb3RNYW5hZ2VyLkNIRUNLX1RJTUVfRVZFUlkpcmV0dXJuITE7dGhpcy5jaGVja2VkPTA7cmV0dXJuIHRoaXMuZW5kVGltZTw9RGF0ZS5ub3coKX1yZXNldCgpe3RoaXMuZW5kVGltZT1EYXRlLm5vdygpK1RpbWVTbG90TWFuYWdlci5USU1FX1NMT1RfRFVSQVRJT05fTVM7dGhpcy5jaGVja2VkPTB9fWNsYXNzIFBhcnRpYWxFdmFsdWF0b3J7Y29uc3RydWN0b3Ioe3hyZWY6ZSxoYW5kbGVyOnQscGFnZUluZGV4OmksaWRGYWN0b3J5OmEsZm9udENhY2hlOnMsYnVpbHRJbkNNYXBDYWNoZTpyLHN0YW5kYXJkRm9udERhdGFDYWNoZTpuLGdsb2JhbEltYWdlQ2FjaGU6byxzeXN0ZW1Gb250Q2FjaGU6ZyxvcHRpb25zOmM9bnVsbH0pe3RoaXMueHJlZj1lO3RoaXMuaGFuZGxlcj10O3RoaXMucGFnZUluZGV4PWk7dGhpcy5pZEZhY3Rvcnk9YTt0aGlzLmZvbnRDYWNoZT1zO3RoaXMuYnVpbHRJbkNNYXBDYWNoZT1yO3RoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlPW47dGhpcy5nbG9iYWxJbWFnZUNhY2hlPW87dGhpcy5zeXN0ZW1Gb250Q2FjaGU9Zzt0aGlzLm9wdGlvbnM9Y3x8RHM7dGhpcy5wYXJzaW5nVHlwZTNGb250PSExO3RoaXMuX3JlZ2lvbmFsSW1hZ2VDYWNoZT1uZXcgUmVnaW9uYWxJbWFnZUNhY2hlO3RoaXMuX2ZldGNoQnVpbHRJbkNNYXBCb3VuZD10aGlzLmZldGNoQnVpbHRJbkNNYXAuYmluZCh0aGlzKTtJbWFnZVJlc2l6ZXIuc2V0TWF4QXJlYSh0aGlzLm9wdGlvbnMuY2FudmFzTWF4QXJlYUluQnl0ZXMpfWdldCBfcGRmRnVuY3Rpb25GYWN0b3J5KCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJfcGRmRnVuY3Rpb25GYWN0b3J5IixuZXcgUERGRnVuY3Rpb25GYWN0b3J5KHt4cmVmOnRoaXMueHJlZixpc0V2YWxTdXBwb3J0ZWQ6dGhpcy5vcHRpb25zLmlzRXZhbFN1cHBvcnRlZH0pKX1jbG9uZShlPW51bGwpe2NvbnN0IHQ9T2JqZWN0LmNyZWF0ZSh0aGlzKTt0Lm9wdGlvbnM9T2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHRoaXMub3B0aW9ucyxlKTtyZXR1cm4gdH1oYXNCbGVuZE1vZGVzKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuITE7aWYoZS5vYmpJZCYmdC5oYXMoZS5vYmpJZCkpcmV0dXJuITE7Y29uc3QgaT1uZXcgUmVmU2V0KHQpO2Uub2JqSWQmJmkucHV0KGUub2JqSWQpO2NvbnN0IGE9W2VdLHM9dGhpcy54cmVmO2Zvcig7YS5sZW5ndGg7KXtjb25zdCBlPWEuc2hpZnQoKSx0PWUuZ2V0KCJFeHRHU3RhdGUiKTtpZih0IGluc3RhbmNlb2YgRGljdClmb3IobGV0IGUgb2YgdC5nZXRSYXdWYWx1ZXMoKSl7aWYoZSBpbnN0YW5jZW9mIFJlZil7aWYoaS5oYXMoZSkpY29udGludWU7dHJ5e2U9cy5mZXRjaChlKX1jYXRjaCh0KXtpLnB1dChlKTtpbmZvKGBoYXNCbGVuZE1vZGVzIC0gaWdub3JpbmcgRXh0R1N0YXRlOiAiJHt0fSIuYCk7Y29udGludWV9fWlmKCEoZSBpbnN0YW5jZW9mIERpY3QpKWNvbnRpbnVlO2Uub2JqSWQmJmkucHV0KGUub2JqSWQpO2NvbnN0IHQ9ZS5nZXQoIkJNIik7aWYodCBpbnN0YW5jZW9mIE5hbWUpe2lmKCJOb3JtYWwiIT09dC5uYW1lKXJldHVybiEwfWVsc2UgaWYodm9pZCAwIT09dCYmQXJyYXkuaXNBcnJheSh0KSlmb3IoY29uc3QgZSBvZiB0KWlmKGUgaW5zdGFuY2VvZiBOYW1lJiYiTm9ybWFsIiE9PWUubmFtZSlyZXR1cm4hMH1jb25zdCByPWUuZ2V0KCJYT2JqZWN0Iik7aWYociBpbnN0YW5jZW9mIERpY3QpZm9yKGxldCBlIG9mIHIuZ2V0UmF3VmFsdWVzKCkpe2lmKGUgaW5zdGFuY2VvZiBSZWYpe2lmKGkuaGFzKGUpKWNvbnRpbnVlO3RyeXtlPXMuZmV0Y2goZSl9Y2F0Y2godCl7aS5wdXQoZSk7aW5mbyhgaGFzQmxlbmRNb2RlcyAtIGlnbm9yaW5nIFhPYmplY3Q6ICIke3R9Ii5gKTtjb250aW51ZX19aWYoIShlIGluc3RhbmNlb2YgQmFzZVN0cmVhbSkpY29udGludWU7ZS5kaWN0Lm9iaklkJiZpLnB1dChlLmRpY3Qub2JqSWQpO2NvbnN0IHQ9ZS5kaWN0LmdldCgiUmVzb3VyY2VzIik7aWYodCBpbnN0YW5jZW9mIERpY3QmJighdC5vYmpJZHx8IWkuaGFzKHQub2JqSWQpKSl7YS5wdXNoKHQpO3Qub2JqSWQmJmkucHV0KHQub2JqSWQpfX19Zm9yKGNvbnN0IGUgb2YgaSl0LnB1dChlKTtyZXR1cm4hMX1hc3luYyBmZXRjaEJ1aWx0SW5DTWFwKGUpe2NvbnN0IHQ9dGhpcy5idWlsdEluQ01hcENhY2hlLmdldChlKTtpZih0KXJldHVybiB0O2xldCBpO2lmKG51bGwhPT10aGlzLm9wdGlvbnMuY01hcFVybCl7Y29uc3QgdD1gJHt0aGlzLm9wdGlvbnMuY01hcFVybH0ke2V9LmJjbWFwYCxhPWF3YWl0IGZldGNoKHQpO2lmKCFhLm9rKXRocm93IG5ldyBFcnJvcihgZmV0Y2hCdWlsdEluQ01hcDogZmFpbGVkIHRvIGZldGNoIGZpbGUgIiR7dH0iIHdpdGggIiR7YS5zdGF0dXNUZXh0fSIuYCk7aT17Y01hcERhdGE6bmV3IFVpbnQ4QXJyYXkoYXdhaXQgYS5hcnJheUJ1ZmZlcigpKSxjb21wcmVzc2lvblR5cGU6bUEuQklOQVJZfX1lbHNlIGk9YXdhaXQgdGhpcy5oYW5kbGVyLnNlbmRXaXRoUHJvbWlzZSgiRmV0Y2hCdWlsdEluQ01hcCIse25hbWU6ZX0pO2kuY29tcHJlc3Npb25UeXBlIT09bUEuTk9ORSYmdGhpcy5idWlsdEluQ01hcENhY2hlLnNldChlLGkpO3JldHVybiBpfWFzeW5jIGZldGNoU3RhbmRhcmRGb250RGF0YShlKXtjb25zdCB0PXRoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlLmdldChlKTtpZih0KXJldHVybiBuZXcgU3RyZWFtKHQpO2lmKHRoaXMub3B0aW9ucy51c2VTeXN0ZW1Gb250cyYmIlN5bWJvbCIhPT1lJiYiWmFwZkRpbmdiYXRzIiE9PWUpcmV0dXJuIG51bGw7Y29uc3QgaT1XaSgpW2VdO2xldCBhO2lmKG51bGwhPT10aGlzLm9wdGlvbnMuc3RhbmRhcmRGb250RGF0YVVybCl7Y29uc3QgZT1gJHt0aGlzLm9wdGlvbnMuc3RhbmRhcmRGb250RGF0YVVybH0ke2l9YCx0PWF3YWl0IGZldGNoKGUpO3Qub2s/YT1uZXcgVWludDhBcnJheShhd2FpdCB0LmFycmF5QnVmZmVyKCkpOndhcm4oYGZldGNoU3RhbmRhcmRGb250RGF0YTogZmFpbGVkIHRvIGZldGNoIGZpbGUgIiR7ZX0iIHdpdGggIiR7dC5zdGF0dXNUZXh0fSIuYCl9ZWxzZSB0cnl7YT1hd2FpdCB0aGlzLmhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKCJGZXRjaFN0YW5kYXJkRm9udERhdGEiLHtmaWxlbmFtZTppfSl9Y2F0Y2goZSl7d2FybihgZmV0Y2hTdGFuZGFyZEZvbnREYXRhOiBmYWlsZWQgdG8gZmV0Y2ggZmlsZSAiJHtpfSIgd2l0aCAiJHtlfSIuYCl9aWYoIWEpcmV0dXJuIG51bGw7dGhpcy5zdGFuZGFyZEZvbnREYXRhQ2FjaGUuc2V0KGUsYSk7cmV0dXJuIG5ldyBTdHJlYW0oYSl9YXN5bmMgYnVpbGRGb3JtWE9iamVjdChlLHQsaSxhLHMscixuKXtjb25zdCBvPXQuZGljdCxnPW8uZ2V0QXJyYXkoIk1hdHJpeCIpO2xldCBjLEMsaD1vLmdldEFycmF5KCJCQm94Iik7aD1BcnJheS5pc0FycmF5KGgpJiY0PT09aC5sZW5ndGg/VXRpbC5ub3JtYWxpemVSZWN0KGgpOm51bGw7by5oYXMoIk9DIikmJihjPWF3YWl0IHRoaXMucGFyc2VNYXJrZWRDb250ZW50UHJvcHMoby5nZXQoIk9DIiksZSkpO3ZvaWQgMCE9PWMmJmEuYWRkT3AoSmUsWyJPQyIsY10pO2NvbnN0IGw9by5nZXQoIkdyb3VwIik7aWYobCl7Qz17bWF0cml4OmcsYmJveDpoLHNtYXNrOmksaXNvbGF0ZWQ6ITEsa25vY2tvdXQ6ITF9O2xldCB0PW51bGw7aWYoaXNOYW1lKGwuZ2V0KCJTIiksIlRyYW5zcGFyZW5jeSIpKXtDLmlzb2xhdGVkPWwuZ2V0KCJJIil8fCExO0Mua25vY2tvdXQ9bC5nZXQoIksiKXx8ITE7aWYobC5oYXMoIkNTIikpe2NvbnN0IGk9bC5nZXRSYXcoIkNTIiksYT1Db2xvclNwYWNlLmdldENhY2hlZChpLHRoaXMueHJlZixuKTt0PWF8fGF3YWl0IHRoaXMucGFyc2VDb2xvclNwYWNlKHtjczppLHJlc291cmNlczplLGxvY2FsQ29sb3JTcGFjZUNhY2hlOm59KX19aWYoaT8uYmFja2Ryb3Ape3R8fD1Db2xvclNwYWNlLnNpbmdsZXRvbnMucmdiO2kuYmFja2Ryb3A9dC5nZXRSZ2IoaS5iYWNrZHJvcCwwKX1hLmFkZE9wKE9lLFtDXSl9Y29uc3QgUT1sP1tnLG51bGxdOltnLGhdO2EuYWRkT3AoVGUsUSk7YXdhaXQgdGhpcy5nZXRPcGVyYXRvckxpc3Qoe3N0cmVhbTp0LHRhc2s6cyxyZXNvdXJjZXM6by5nZXQoIlJlc291cmNlcyIpfHxlLG9wZXJhdG9yTGlzdDphLGluaXRpYWxTdGF0ZTpyfSk7YS5hZGRPcChxZSxbXSk7bCYmYS5hZGRPcChQZSxbQ10pO3ZvaWQgMCE9PWMmJmEuYWRkT3AoWWUsW10pfV9zZW5kSW1nRGF0YShlLHQsaT0hMSl7Y29uc3QgYT10P1t0LmJpdG1hcHx8dC5kYXRhLmJ1ZmZlcl06bnVsbDtyZXR1cm4gdGhpcy5wYXJzaW5nVHlwZTNGb250fHxpP3RoaXMuaGFuZGxlci5zZW5kKCJjb21tb25vYmoiLFtlLCJJbWFnZSIsdF0sYSk6dGhpcy5oYW5kbGVyLnNlbmQoIm9iaiIsW2UsdGhpcy5wYWdlSW5kZXgsIkltYWdlIix0XSxhKX1hc3luYyBidWlsZFBhaW50SW1hZ2VYT2JqZWN0KHtyZXNvdXJjZXM6ZSxpbWFnZTp0LGlzSW5saW5lOmk9ITEsb3BlcmF0b3JMaXN0OmEsY2FjaGVLZXk6cyxsb2NhbEltYWdlQ2FjaGU6cixsb2NhbENvbG9yU3BhY2VDYWNoZTpufSl7Y29uc3Qgbz10LmRpY3QsZz1vLm9iaklkLGM9by5nZXQoIlciLCJXaWR0aCIpLEM9by5nZXQoIkgiLCJIZWlnaHQiKTtpZighY3x8Im51bWJlciIhPXR5cGVvZiBjfHwhQ3x8Im51bWJlciIhPXR5cGVvZiBDKXt3YXJuKCJJbWFnZSBkaW1lbnNpb25zIGFyZSBtaXNzaW5nLCBvciBub3QgbnVtYmVycy4iKTtyZXR1cm59Y29uc3QgaD10aGlzLm9wdGlvbnMubWF4SW1hZ2VTaXplO2lmKC0xIT09aCYmYypDPmgpe2NvbnN0IGU9IkltYWdlIGV4Y2VlZGVkIG1heGltdW0gYWxsb3dlZCBzaXplIGFuZCB3YXMgcmVtb3ZlZC4iO2lmKHRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpe3dhcm4oZSk7cmV0dXJufXRocm93IG5ldyBFcnJvcihlKX1sZXQgbDtvLmhhcygiT0MiKSYmKGw9YXdhaXQgdGhpcy5wYXJzZU1hcmtlZENvbnRlbnRQcm9wcyhvLmdldCgiT0MiKSxlKSk7bGV0IFEsRTtpZihvLmdldCgiSU0iLCJJbWFnZU1hc2siKXx8ITEpe2NvbnN0IGU9by5nZXQoIkkiLCJJbnRlcnBvbGF0ZSIpLGk9Yys3Pj4zLG49dC5nZXRCeXRlcyhpKkMpLGg9by5nZXRBcnJheSgiRCIsIkRlY29kZSIpO2lmKHRoaXMucGFyc2luZ1R5cGUzRm9udCl7UT1QREZJbWFnZS5jcmVhdGVSYXdNYXNrKHtpbWdBcnJheTpuLHdpZHRoOmMsaGVpZ2h0OkMsaW1hZ2VJc0Zyb21EZWNvZGVTdHJlYW06dCBpbnN0YW5jZW9mIERlY29kZVN0cmVhbSxpbnZlcnNlRGVjb2RlOmg/LlswXT4wLGludGVycG9sYXRlOmV9KTtRLmNhY2hlZD0hIXM7RT1bUV07YS5hZGRJbWFnZU9wcyhYZSxFLGwpO2lmKHMpe2NvbnN0IGU9e2ZuOlhlLGFyZ3M6RSxvcHRpb25hbENvbnRlbnQ6bH07ci5zZXQocyxnLGUpO2cmJnRoaXMuX3JlZ2lvbmFsSW1hZ2VDYWNoZS5zZXQobnVsbCxnLGUpfXJldHVybn1RPWF3YWl0IFBERkltYWdlLmNyZWF0ZU1hc2soe2ltZ0FycmF5Om4sd2lkdGg6YyxoZWlnaHQ6QyxpbWFnZUlzRnJvbURlY29kZVN0cmVhbTp0IGluc3RhbmNlb2YgRGVjb2RlU3RyZWFtLGludmVyc2VEZWNvZGU6aD8uWzBdPjAsaW50ZXJwb2xhdGU6ZSxpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDp0aGlzLm9wdGlvbnMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWR9KTtpZihRLmlzU2luZ2xlT3BhcXVlUGl4ZWwpe2EuYWRkSW1hZ2VPcHMoZXQsW10sbCk7aWYocyl7Y29uc3QgZT17Zm46ZXQsYXJnczpbXSxvcHRpb25hbENvbnRlbnQ6bH07ci5zZXQocyxnLGUpO2cmJnRoaXMuX3JlZ2lvbmFsSW1hZ2VDYWNoZS5zZXQobnVsbCxnLGUpfXJldHVybn1jb25zdCB1PWBtYXNrXyR7dGhpcy5pZEZhY3RvcnkuY3JlYXRlT2JqSWQoKX1gO2EuYWRkRGVwZW5kZW5jeSh1KTtRLmRhdGFMZW49US5iaXRtYXA/US53aWR0aCpRLmhlaWdodCo0OlEuZGF0YS5sZW5ndGg7dGhpcy5fc2VuZEltZ0RhdGEodSxRKTtFPVt7ZGF0YTp1LHdpZHRoOlEud2lkdGgsaGVpZ2h0OlEuaGVpZ2h0LGludGVycG9sYXRlOlEuaW50ZXJwb2xhdGUsY291bnQ6MX1dO2EuYWRkSW1hZ2VPcHMoWGUsRSxsKTtpZihzKXtjb25zdCBlPXtmbjpYZSxhcmdzOkUsb3B0aW9uYWxDb250ZW50Omx9O3Iuc2V0KHMsZyxlKTtnJiZ0aGlzLl9yZWdpb25hbEltYWdlQ2FjaGUuc2V0KG51bGwsZyxlKX1yZXR1cm59aWYoaSYmYytDPDIwMCYmIW8uaGFzKCJTTWFzayIpJiYhby5oYXMoIk1hc2siKSl7dHJ5e2NvbnN0IHM9bmV3IFBERkltYWdlKHt4cmVmOnRoaXMueHJlZixyZXM6ZSxpbWFnZTp0LGlzSW5saW5lOmkscGRmRnVuY3Rpb25GYWN0b3J5OnRoaXMuX3BkZkZ1bmN0aW9uRmFjdG9yeSxsb2NhbENvbG9yU3BhY2VDYWNoZTpufSk7UT1hd2FpdCBzLmNyZWF0ZUltYWdlRGF0YSghMCwhMSk7YS5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZD10aGlzLm9wdGlvbnMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ7YS5hZGRJbWFnZU9wcyh6ZSxbUV0sbCl9Y2F0Y2goZSl7Y29uc3QgdD1gVW5hYmxlIHRvIGRlY29kZSBpbmxpbmUgaW1hZ2U6ICIke2V9Ii5gO2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IG5ldyBFcnJvcih0KTt3YXJuKHQpfXJldHVybn1sZXQgdT1gaW1nXyR7dGhpcy5pZEZhY3RvcnkuY3JlYXRlT2JqSWQoKX1gLGQ9ITE7aWYodGhpcy5wYXJzaW5nVHlwZTNGb250KXU9YCR7dGhpcy5pZEZhY3RvcnkuZ2V0RG9jSWQoKX1fdHlwZTNfJHt1fWA7ZWxzZSBpZihzJiZnKXtkPXRoaXMuZ2xvYmFsSW1hZ2VDYWNoZS5zaG91bGRDYWNoZShnLHRoaXMucGFnZUluZGV4KTtpZihkKXthc3NlcnQoIWksIkNhbm5vdCBjYWNoZSBhbiBpbmxpbmUgaW1hZ2UgZ2xvYmFsbHkuIik7dT1gJHt0aGlzLmlkRmFjdG9yeS5nZXREb2NJZCgpfV8ke3V9YH19YS5hZGREZXBlbmRlbmN5KHUpO0U9W3UsYyxDXTthLmFkZEltYWdlT3BzKFZlLEUsbCk7aWYoZCYmKGMqQz4yNWU0fHxvLmhhcygiU01hc2siKXx8by5oYXMoIk1hc2siKSkpe2NvbnN0IGU9YXdhaXQgdGhpcy5oYW5kbGVyLnNlbmRXaXRoUHJvbWlzZSgiY29tbW9ub2JqIixbdSwiQ29weUxvY2FsSW1hZ2UiLHtpbWFnZVJlZjpnfV0pO2lmKGUpe3RoaXMuZ2xvYmFsSW1hZ2VDYWNoZS5zZXREYXRhKGcse29iaklkOnUsZm46VmUsYXJnczpFLG9wdGlvbmFsQ29udGVudDpsLGJ5dGVTaXplOjB9KTt0aGlzLmdsb2JhbEltYWdlQ2FjaGUuYWRkQnl0ZVNpemUoZyxlKTtyZXR1cm59fVBERkltYWdlLmJ1aWxkSW1hZ2Uoe3hyZWY6dGhpcy54cmVmLHJlczplLGltYWdlOnQsaXNJbmxpbmU6aSxwZGZGdW5jdGlvbkZhY3Rvcnk6dGhpcy5fcGRmRnVuY3Rpb25GYWN0b3J5LGxvY2FsQ29sb3JTcGFjZUNhY2hlOm59KS50aGVuKChhc3luYyBlPT57UT1hd2FpdCBlLmNyZWF0ZUltYWdlRGF0YSghMSx0aGlzLm9wdGlvbnMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpO1EuZGF0YUxlbj1RLmJpdG1hcD9RLndpZHRoKlEuaGVpZ2h0KjQ6US5kYXRhLmxlbmd0aDtRLnJlZj1nO2QmJnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZS5hZGRCeXRlU2l6ZShnLFEuZGF0YUxlbik7cmV0dXJuIHRoaXMuX3NlbmRJbWdEYXRhKHUsUSxkKX0pKS5jYXRjaCgoZT0+e3dhcm4oYFVuYWJsZSB0byBkZWNvZGUgaW1hZ2UgIiR7dX0iOiAiJHtlfSIuYCk7cmV0dXJuIHRoaXMuX3NlbmRJbWdEYXRhKHUsbnVsbCxkKX0pKTtpZihzKXtjb25zdCBlPXtmbjpWZSxhcmdzOkUsb3B0aW9uYWxDb250ZW50Omx9O3Iuc2V0KHMsZyxlKTtpZihnKXt0aGlzLl9yZWdpb25hbEltYWdlQ2FjaGUuc2V0KG51bGwsZyxlKTtkJiZ0aGlzLmdsb2JhbEltYWdlQ2FjaGUuc2V0RGF0YShnLHtvYmpJZDp1LGZuOlZlLGFyZ3M6RSxvcHRpb25hbENvbnRlbnQ6bCxieXRlU2l6ZTowfSl9fX1oYW5kbGVTTWFzayhlLHQsaSxhLHMscil7Y29uc3Qgbj1lLmdldCgiRyIpLG89e3N1YnR5cGU6ZS5nZXQoIlMiKS5uYW1lLGJhY2tkcm9wOmUuZ2V0KCJCQyIpfSxnPWUuZ2V0KCJUUiIpO2lmKGlzUERGRnVuY3Rpb24oZykpe2NvbnN0IGU9dGhpcy5fcGRmRnVuY3Rpb25GYWN0b3J5LmNyZWF0ZShnKSx0PW5ldyBVaW50OEFycmF5KDI1NiksaT1uZXcgRmxvYXQzMkFycmF5KDEpO2ZvcihsZXQgYT0wO2E8MjU2O2ErKyl7aVswXT1hLzI1NTtlKGksMCxpLDApO3RbYV09MjU1KmlbMF18MH1vLnRyYW5zZmVyTWFwPXR9cmV0dXJuIHRoaXMuYnVpbGRGb3JtWE9iamVjdCh0LG4sbyxpLGEscy5zdGF0ZS5jbG9uZSgpLHIpfWhhbmRsZVRyYW5zZmVyRnVuY3Rpb24oZSl7bGV0IHQ7aWYoQXJyYXkuaXNBcnJheShlKSl0PWU7ZWxzZXtpZighaXNQREZGdW5jdGlvbihlKSlyZXR1cm4gbnVsbDt0PVtlXX1jb25zdCBpPVtdO2xldCBhPTAscz0wO2Zvcihjb25zdCBlIG9mIHQpe2NvbnN0IHQ9dGhpcy54cmVmLmZldGNoSWZSZWYoZSk7YSsrO2lmKGlzTmFtZSh0LCJJZGVudGl0eSIpKXtpLnB1c2gobnVsbCk7Y29udGludWV9aWYoIWlzUERGRnVuY3Rpb24odCkpcmV0dXJuIG51bGw7Y29uc3Qgcj10aGlzLl9wZGZGdW5jdGlvbkZhY3RvcnkuY3JlYXRlKHQpLG49bmV3IFVpbnQ4QXJyYXkoMjU2KSxvPW5ldyBGbG9hdDMyQXJyYXkoMSk7Zm9yKGxldCBlPTA7ZTwyNTY7ZSsrKXtvWzBdPWUvMjU1O3IobywwLG8sMCk7bltlXT0yNTUqb1swXXwwfWkucHVzaChuKTtzKyt9cmV0dXJuIDEhPT1hJiY0IT09YXx8MD09PXM/bnVsbDppfWhhbmRsZVRpbGluZ1R5cGUoZSx0LGksYSxzLHIsbixvKXtjb25zdCBnPW5ldyBPcGVyYXRvckxpc3QsYz1EaWN0Lm1lcmdlKHt4cmVmOnRoaXMueHJlZixkaWN0QXJyYXk6W3MuZ2V0KCJSZXNvdXJjZXMiKSxpXX0pO3JldHVybiB0aGlzLmdldE9wZXJhdG9yTGlzdCh7c3RyZWFtOmEsdGFzazpuLHJlc291cmNlczpjLG9wZXJhdG9yTGlzdDpnfSkudGhlbigoZnVuY3Rpb24oKXtjb25zdCBpPWcuZ2V0SVIoKSxhPWdldFRpbGluZ1BhdHRlcm5JUihpLHMsdCk7ci5hZGREZXBlbmRlbmNpZXMoZy5kZXBlbmRlbmNpZXMpO3IuYWRkT3AoZSxhKTtzLm9iaklkJiZvLnNldChudWxsLHMub2JqSWQse29wZXJhdG9yTGlzdElSOmksZGljdDpzfSl9KSkuY2F0Y2goKGU9PntpZighKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbikpe2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IGU7d2FybihgaGFuZGxlVGlsaW5nVHlwZSAtIGlnbm9yaW5nIHBhdHRlcm46ICIke2V9Ii5gKX19KSl9YXN5bmMgaGFuZGxlU2V0Rm9udChlLHQsaSxhLHMscixuPW51bGwsbz1udWxsKXtjb25zdCBnPXQ/LlswXWluc3RhbmNlb2YgTmFtZT90WzBdLm5hbWU6bnVsbDtsZXQgYz1hd2FpdCB0aGlzLmxvYWRGb250KGcsaSxlLG4sbyk7aWYoYy5mb250LmlzVHlwZTNGb250KXRyeXthd2FpdCBjLmxvYWRUeXBlM0RhdGEodGhpcyxlLHMpO2EuYWRkRGVwZW5kZW5jaWVzKGMudHlwZTNEZXBlbmRlbmNpZXMpfWNhdGNoKGUpe2M9bmV3IFRyYW5zbGF0ZWRGb250KHtsb2FkZWROYW1lOiJnX2ZvbnRfZXJyb3IiLGZvbnQ6bmV3IEVycm9yRm9udChgVHlwZTMgZm9udCBsb2FkIGVycm9yOiAke2V9YCksZGljdDpjLmZvbnQsZXZhbHVhdG9yT3B0aW9uczp0aGlzLm9wdGlvbnN9KX1yLmZvbnQ9Yy5mb250O2Muc2VuZCh0aGlzLmhhbmRsZXIpO3JldHVybiBjLmxvYWRlZE5hbWV9aGFuZGxlVGV4dChlLHQpe2NvbnN0IGk9dC5mb250LGE9aS5jaGFyc1RvR2x5cGhzKGUpO2lmKGkuZGF0YSl7KCEhKHQudGV4dFJlbmRlcmluZ01vZGUmdyl8fCJQYXR0ZXJuIj09PXQuZmlsbENvbG9yU3BhY2UubmFtZXx8aS5kaXNhYmxlRm9udEZhY2V8fHRoaXMub3B0aW9ucy5kaXNhYmxlRm9udEZhY2UpJiZQYXJ0aWFsRXZhbHVhdG9yLmJ1aWxkRm9udFBhdGhzKGksYSx0aGlzLmhhbmRsZXIsdGhpcy5vcHRpb25zKX1yZXR1cm4gYX1lbnN1cmVTdGF0ZUZvbnQoZSl7aWYoZS5mb250KXJldHVybjtjb25zdCB0PW5ldyBGb3JtYXRFcnJvcigiTWlzc2luZyBzZXRGb250IChUZikgb3BlcmF0b3IgYmVmb3JlIHRleHQgcmVuZGVyaW5nIG9wZXJhdG9yLiIpO2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IHQ7d2FybihgZW5zdXJlU3RhdGVGb250OiAiJHt0fSIuYCl9YXN5bmMgc2V0R1N0YXRlKHtyZXNvdXJjZXM6ZSxnU3RhdGU6dCxvcGVyYXRvckxpc3Q6aSxjYWNoZUtleTphLHRhc2s6cyxzdGF0ZU1hbmFnZXI6cixsb2NhbEdTdGF0ZUNhY2hlOm4sbG9jYWxDb2xvclNwYWNlQ2FjaGU6b30pe2NvbnN0IGc9dC5vYmpJZDtsZXQgYz0hMDtjb25zdCBDPVtdO2xldCBoPVByb21pc2UucmVzb2x2ZSgpO2Zvcihjb25zdCBhIG9mIHQuZ2V0S2V5cygpKXtjb25zdCBuPXQuZ2V0KGEpO3N3aXRjaChhKXtjYXNlIlR5cGUiOmJyZWFrO2Nhc2UiTFciOmNhc2UiTEMiOmNhc2UiTEoiOmNhc2UiTUwiOmNhc2UiRCI6Y2FzZSJSSSI6Y2FzZSJGTCI6Y2FzZSJDQSI6Y2FzZSJjYSI6Qy5wdXNoKFthLG5dKTticmVhaztjYXNlIkZvbnQiOmM9ITE7aD1oLnRoZW4oKCgpPT50aGlzLmhhbmRsZVNldEZvbnQoZSxudWxsLG5bMF0saSxzLHIuc3RhdGUpLnRoZW4oKGZ1bmN0aW9uKGUpe2kuYWRkRGVwZW5kZW5jeShlKTtDLnB1c2goW2EsW2UsblsxXV1dKX0pKSkpO2JyZWFrO2Nhc2UiQk0iOkMucHVzaChbYSxub3JtYWxpemVCbGVuZE1vZGUobildKTticmVhaztjYXNlIlNNYXNrIjppZihpc05hbWUobiwiTm9uZSIpKXtDLnB1c2goW2EsITFdKTticmVha31pZihuIGluc3RhbmNlb2YgRGljdCl7Yz0hMTtoPWgudGhlbigoKCk9PnRoaXMuaGFuZGxlU01hc2sobixlLGkscyxyLG8pKSk7Qy5wdXNoKFthLCEwXSl9ZWxzZSB3YXJuKCJVbnN1cHBvcnRlZCBTTWFzayB0eXBlIik7YnJlYWs7Y2FzZSJUUiI6Y29uc3QgdD10aGlzLmhhbmRsZVRyYW5zZmVyRnVuY3Rpb24obik7Qy5wdXNoKFthLHRdKTticmVhaztjYXNlIk9QIjpjYXNlIm9wIjpjYXNlIk9QTSI6Y2FzZSJCRyI6Y2FzZSJCRzIiOmNhc2UiVUNSIjpjYXNlIlVDUjIiOmNhc2UiVFIyIjpjYXNlIkhUIjpjYXNlIlNNIjpjYXNlIlNBIjpjYXNlIkFJUyI6Y2FzZSJUSyI6aW5mbygiZ3JhcGhpYyBzdGF0ZSBvcGVyYXRvciAiK2EpO2JyZWFrO2RlZmF1bHQ6aW5mbygiVW5rbm93biBncmFwaGljIHN0YXRlIG9wZXJhdG9yICIrYSl9fWF3YWl0IGg7Qy5sZW5ndGg+MCYmaS5hZGRPcChSQSxbQ10pO2MmJm4uc2V0KGEsZyxDKX1sb2FkRm9udChlLHQsaSxhPW51bGwscz1udWxsKXtjb25zdCBlcnJvckZvbnQ9YXN5bmMoKT0+bmV3IFRyYW5zbGF0ZWRGb250KHtsb2FkZWROYW1lOiJnX2ZvbnRfZXJyb3IiLGZvbnQ6bmV3IEVycm9yRm9udChgRm9udCAiJHtlfSIgaXMgbm90IGF2YWlsYWJsZS5gKSxkaWN0OnQsZXZhbHVhdG9yT3B0aW9uczp0aGlzLm9wdGlvbnN9KTtsZXQgcjtpZih0KXQgaW5zdGFuY2VvZiBSZWYmJihyPXQpO2Vsc2V7Y29uc3QgdD1pLmdldCgiRm9udCIpO3QmJihyPXQuZ2V0UmF3KGUpKX1pZihyKXtpZih0aGlzLnBhcnNpbmdUeXBlM0ZvbnQmJnRoaXMudHlwZTNGb250UmVmcy5oYXMocikpcmV0dXJuIGVycm9yRm9udCgpO2lmKHRoaXMuZm9udENhY2hlLmhhcyhyKSlyZXR1cm4gdGhpcy5mb250Q2FjaGUuZ2V0KHIpO3Q9dGhpcy54cmVmLmZldGNoSWZSZWYocil9aWYoISh0IGluc3RhbmNlb2YgRGljdCkpe2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzJiYhdGhpcy5wYXJzaW5nVHlwZTNGb250KXt3YXJuKGBGb250ICIke2V9IiBpcyBub3QgYXZhaWxhYmxlLmApO3JldHVybiBlcnJvckZvbnQoKX13YXJuKGBGb250ICIke2V9IiBpcyBub3QgYXZhaWxhYmxlIC0tIGF0dGVtcHRpbmcgdG8gZmFsbGJhY2sgdG8gYSBkZWZhdWx0IGZvbnQuYCk7dD1hfHxQYXJ0aWFsRXZhbHVhdG9yLmZhbGxiYWNrRm9udERpY3R9aWYodC5jYWNoZUtleSYmdGhpcy5mb250Q2FjaGUuaGFzKHQuY2FjaGVLZXkpKXJldHVybiB0aGlzLmZvbnRDYWNoZS5nZXQodC5jYWNoZUtleSk7Y29uc3R7cHJvbWlzZTpuLHJlc29sdmU6b309UHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7bGV0IGc7dHJ5e2c9dGhpcy5wcmVFdmFsdWF0ZUZvbnQodCk7Zy5jc3NGb250SW5mbz1zfWNhdGNoKGUpe3dhcm4oYGxvYWRGb250IC0gcHJlRXZhbHVhdGVGb250IGZhaWxlZDogIiR7ZX0iLmApO3JldHVybiBlcnJvckZvbnQoKX1jb25zdHtkZXNjcmlwdG9yOmMsaGFzaDpDfT1nLGg9ciBpbnN0YW5jZW9mIFJlZjtsZXQgbDtpZihDJiZjIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgZT1jLmZvbnRBbGlhc2VzfHw9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihlW0NdKXtjb25zdCB0PWVbQ10uYWxpYXNSZWY7aWYoaCYmdCYmdGhpcy5mb250Q2FjaGUuaGFzKHQpKXt0aGlzLmZvbnRDYWNoZS5wdXRBbGlhcyhyLHQpO3JldHVybiB0aGlzLmZvbnRDYWNoZS5nZXQocil9fWVsc2UgZVtDXT17Zm9udElEOnRoaXMuaWRGYWN0b3J5LmNyZWF0ZUZvbnRJZCgpfTtoJiYoZVtDXS5hbGlhc1JlZj1yKTtsPWVbQ10uZm9udElEfWVsc2UgbD10aGlzLmlkRmFjdG9yeS5jcmVhdGVGb250SWQoKTthc3NlcnQobD8uc3RhcnRzV2l0aCgiZiIpLCdUaGUgImZvbnRJRCIgbXVzdCBiZSAoY29ycmVjdGx5KSBkZWZpbmVkLicpO2lmKGgpdGhpcy5mb250Q2FjaGUucHV0KHIsbik7ZWxzZXt0LmNhY2hlS2V5PWBjYWNoZUtleV8ke2x9YDt0aGlzLmZvbnRDYWNoZS5wdXQodC5jYWNoZUtleSxuKX10LmxvYWRlZE5hbWU9YCR7dGhpcy5pZEZhY3RvcnkuZ2V0RG9jSWQoKX1fJHtsfWA7dGhpcy50cmFuc2xhdGVGb250KGcpLnRoZW4oKGU9PntvKG5ldyBUcmFuc2xhdGVkRm9udCh7bG9hZGVkTmFtZTp0LmxvYWRlZE5hbWUsZm9udDplLGRpY3Q6dCxldmFsdWF0b3JPcHRpb25zOnRoaXMub3B0aW9uc30pKX0pKS5jYXRjaCgoZT0+e3dhcm4oYGxvYWRGb250IC0gdHJhbnNsYXRlRm9udCBmYWlsZWQ6ICIke2V9Ii5gKTtvKG5ldyBUcmFuc2xhdGVkRm9udCh7bG9hZGVkTmFtZTp0LmxvYWRlZE5hbWUsZm9udDpuZXcgRXJyb3JGb250KGUgaW5zdGFuY2VvZiBFcnJvcj9lLm1lc3NhZ2U6ZSksZGljdDp0LGV2YWx1YXRvck9wdGlvbnM6dGhpcy5vcHRpb25zfSkpfSkpO3JldHVybiBufWJ1aWxkUGF0aChlLHQsaSxhPSExKXtjb25zdCBzPWUubGVuZ3RoLTE7aXx8KGk9W10pO2lmKHM8MHx8ZS5mbkFycmF5W3NdIT09dHQpe2lmKGEpe3dhcm4oYEVuY291bnRlcmVkIHBhdGggb3BlcmF0b3IgIiR7dH0iIGluc2lkZSBvZiBhIHRleHQgb2JqZWN0LmApO2UuYWRkT3AoR0EsbnVsbCl9bGV0IHM7c3dpdGNoKHQpe2Nhc2UgS0E6Y29uc3QgZT1pWzBdK2lbMl0sdD1pWzFdK2lbM107cz1bTWF0aC5taW4oaVswXSxlKSxNYXRoLm1pbihpWzFdLHQpLE1hdGgubWF4KGlbMF0sZSksTWF0aC5tYXgoaVsxXSx0KV07YnJlYWs7Y2FzZSBNQTpjYXNlIExBOnM9W2lbMF0saVsxXSxpWzBdLGlbMV1dO2JyZWFrO2RlZmF1bHQ6cz1bMS8wLDEvMCwtMS8wLC0xLzBdfWUuYWRkT3AodHQsW1t0XSxpLHNdKTthJiZlLmFkZE9wKHhBLG51bGwpfWVsc2V7Y29uc3QgYT1lLmFyZ3NBcnJheVtzXTthWzBdLnB1c2godCk7YVsxXS5wdXNoKC4uLmkpO2NvbnN0IHI9YVsyXTtzd2l0Y2godCl7Y2FzZSBLQTpjb25zdCBlPWlbMF0raVsyXSx0PWlbMV0raVszXTtyWzBdPU1hdGgubWluKHJbMF0saVswXSxlKTtyWzFdPU1hdGgubWluKHJbMV0saVsxXSx0KTtyWzJdPU1hdGgubWF4KHJbMl0saVswXSxlKTtyWzNdPU1hdGgubWF4KHJbM10saVsxXSx0KTticmVhaztjYXNlIE1BOmNhc2UgTEE6clswXT1NYXRoLm1pbihyWzBdLGlbMF0pO3JbMV09TWF0aC5taW4oclsxXSxpWzFdKTtyWzJdPU1hdGgubWF4KHJbMl0saVswXSk7clszXT1NYXRoLm1heChyWzNdLGlbMV0pfX19cGFyc2VDb2xvclNwYWNlKHtjczplLHJlc291cmNlczp0LGxvY2FsQ29sb3JTcGFjZUNhY2hlOml9KXtyZXR1cm4gQ29sb3JTcGFjZS5wYXJzZUFzeW5jKHtjczplLHhyZWY6dGhpcy54cmVmLHJlc291cmNlczp0LHBkZkZ1bmN0aW9uRmFjdG9yeTp0aGlzLl9wZGZGdW5jdGlvbkZhY3RvcnksbG9jYWxDb2xvclNwYWNlQ2FjaGU6aX0pLmNhdGNoKChlPT57aWYoZSBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uKXJldHVybiBudWxsO2lmKHRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpe3dhcm4oYHBhcnNlQ29sb3JTcGFjZSAtIGlnbm9yaW5nIENvbG9yU3BhY2U6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH10aHJvdyBlfSkpfXBhcnNlU2hhZGluZyh7c2hhZGluZzplLHJlc291cmNlczp0LGxvY2FsQ29sb3JTcGFjZUNhY2hlOmksbG9jYWxTaGFkaW5nUGF0dGVybkNhY2hlOmF9KXtsZXQgcyxyPWEuZ2V0KGUpO2lmKHIpcmV0dXJuIHI7dHJ5e3M9UGF0dGVybi5wYXJzZVNoYWRpbmcoZSx0aGlzLnhyZWYsdCx0aGlzLl9wZGZGdW5jdGlvbkZhY3RvcnksaSkuZ2V0SVIoKX1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24pcmV0dXJuIG51bGw7aWYodGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl7d2FybihgcGFyc2VTaGFkaW5nIC0gaWdub3Jpbmcgc2hhZGluZzogIiR7dH0iLmApO2Euc2V0KGUsbnVsbCk7cmV0dXJuIG51bGx9dGhyb3cgdH1yPWBwYXR0ZXJuXyR7dGhpcy5pZEZhY3RvcnkuY3JlYXRlT2JqSWQoKX1gO3RoaXMucGFyc2luZ1R5cGUzRm9udCYmKHI9YCR7dGhpcy5pZEZhY3RvcnkuZ2V0RG9jSWQoKX1fdHlwZTNfJHtyfWApO2Euc2V0KGUscik7dGhpcy5wYXJzaW5nVHlwZTNGb250P3RoaXMuaGFuZGxlci5zZW5kKCJjb21tb25vYmoiLFtyLCJQYXR0ZXJuIixzXSk6dGhpcy5oYW5kbGVyLnNlbmQoIm9iaiIsW3IsdGhpcy5wYWdlSW5kZXgsIlBhdHRlcm4iLHNdKTtyZXR1cm4gcn1oYW5kbGVDb2xvck4oZSx0LGksYSxzLHIsbixvLGcsYyl7Y29uc3QgQz1pLnBvcCgpO2lmKEMgaW5zdGFuY2VvZiBOYW1lKXtjb25zdCBoPXMuZ2V0UmF3KEMubmFtZSksbD1oIGluc3RhbmNlb2YgUmVmJiZnLmdldEJ5UmVmKGgpO2lmKGwpdHJ5e2NvbnN0IHM9YS5iYXNlP2EuYmFzZS5nZXRSZ2IoaSwwKTpudWxsLHI9Z2V0VGlsaW5nUGF0dGVybklSKGwub3BlcmF0b3JMaXN0SVIsbC5kaWN0LHMpO2UuYWRkT3AodCxyKTtyZXR1cm59Y2F0Y2h7fWNvbnN0IFE9dGhpcy54cmVmLmZldGNoSWZSZWYoaCk7aWYoUSl7Y29uc3Qgcz1RIGluc3RhbmNlb2YgQmFzZVN0cmVhbT9RLmRpY3Q6USxDPXMuZ2V0KCJQYXR0ZXJuVHlwZSIpO2lmKEM9PT1Gcyl7Y29uc3Qgbz1hLmJhc2U/YS5iYXNlLmdldFJnYihpLDApOm51bGw7cmV0dXJuIHRoaXMuaGFuZGxlVGlsaW5nVHlwZSh0LG8scixRLHMsZSxuLGcpfWlmKEM9PT1Tcyl7Y29uc3QgaT1zLmdldCgiU2hhZGluZyIpLGE9dGhpcy5wYXJzZVNoYWRpbmcoe3NoYWRpbmc6aSxyZXNvdXJjZXM6cixsb2NhbENvbG9yU3BhY2VDYWNoZTpvLGxvY2FsU2hhZGluZ1BhdHRlcm5DYWNoZTpjfSk7aWYoYSl7Y29uc3QgaT1zLmdldEFycmF5KCJNYXRyaXgiKTtlLmFkZE9wKHQsWyJTaGFkaW5nIixhLGldKX1yZXR1cm59dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbmtub3duIFBhdHRlcm5UeXBlOiAke0N9YCl9fXRocm93IG5ldyBGb3JtYXRFcnJvcihgVW5rbm93biBQYXR0ZXJuTmFtZTogJHtDfWApfV9wYXJzZVZpc2liaWxpdHlFeHByZXNzaW9uKGUsdCxpKXtpZigrK3Q+MTApe3dhcm4oIlZpc2liaWxpdHkgZXhwcmVzc2lvbiBpcyB0b28gZGVlcGx5IG5lc3RlZCIpO3JldHVybn1jb25zdCBhPWUubGVuZ3RoLHM9dGhpcy54cmVmLmZldGNoSWZSZWYoZVswXSk7aWYoIShhPDIpJiZzIGluc3RhbmNlb2YgTmFtZSl7c3dpdGNoKHMubmFtZSl7Y2FzZSJBbmQiOmNhc2UiT3IiOmNhc2UiTm90IjppLnB1c2gocy5uYW1lKTticmVhaztkZWZhdWx0Ondhcm4oYEludmFsaWQgb3BlcmF0b3IgJHtzLm5hbWV9IGluIHZpc2liaWxpdHkgZXhwcmVzc2lvbmApO3JldHVybn1mb3IobGV0IHM9MTtzPGE7cysrKXtjb25zdCBhPWVbc10scj10aGlzLnhyZWYuZmV0Y2hJZlJlZihhKTtpZihBcnJheS5pc0FycmF5KHIpKXtjb25zdCBlPVtdO2kucHVzaChlKTt0aGlzLl9wYXJzZVZpc2liaWxpdHlFeHByZXNzaW9uKHIsdCxlKX1lbHNlIGEgaW5zdGFuY2VvZiBSZWYmJmkucHVzaChhLnRvU3RyaW5nKCkpfX1lbHNlIHdhcm4oIkludmFsaWQgdmlzaWJpbGl0eSBleHByZXNzaW9uIil9YXN5bmMgcGFyc2VNYXJrZWRDb250ZW50UHJvcHMoZSx0KXtsZXQgaTtpZihlIGluc3RhbmNlb2YgTmFtZSl7aT10LmdldCgiUHJvcGVydGllcyIpLmdldChlLm5hbWUpfWVsc2V7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJPcHRpb25hbCBjb250ZW50IHByb3BlcnRpZXMgbWFsZm9ybWVkLiIpO2k9ZX1jb25zdCBhPWkuZ2V0KCJUeXBlIik/Lm5hbWU7aWYoIk9DRyI9PT1hKXJldHVybnt0eXBlOmEsaWQ6aS5vYmpJZH07aWYoIk9DTUQiPT09YSl7Y29uc3QgZT1pLmdldCgiVkUiKTtpZihBcnJheS5pc0FycmF5KGUpKXtjb25zdCB0PVtdO3RoaXMuX3BhcnNlVmlzaWJpbGl0eUV4cHJlc3Npb24oZSwwLHQpO2lmKHQubGVuZ3RoPjApcmV0dXJue3R5cGU6Ik9DTUQiLGV4cHJlc3Npb246dH19Y29uc3QgdD1pLmdldCgiT0NHcyIpO2lmKEFycmF5LmlzQXJyYXkodCl8fHQgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBlPVtdO2lmKEFycmF5LmlzQXJyYXkodCkpZm9yKGNvbnN0IGkgb2YgdCllLnB1c2goaS50b1N0cmluZygpKTtlbHNlIGUucHVzaCh0Lm9iaklkKTtyZXR1cm57dHlwZTphLGlkczplLHBvbGljeTppLmdldCgiUCIpaW5zdGFuY2VvZiBOYW1lP2kuZ2V0KCJQIikubmFtZTpudWxsLGV4cHJlc3Npb246bnVsbH19aWYodCBpbnN0YW5jZW9mIFJlZilyZXR1cm57dHlwZTphLGlkOnQudG9TdHJpbmcoKX19cmV0dXJuIG51bGx9Z2V0T3BlcmF0b3JMaXN0KHtzdHJlYW06ZSx0YXNrOnQscmVzb3VyY2VzOmksb3BlcmF0b3JMaXN0OmEsaW5pdGlhbFN0YXRlOnM9bnVsbCxmYWxsYmFja0ZvbnREaWN0OnI9bnVsbH0pe2l8fD1EaWN0LmVtcHR5O3N8fD1uZXcgRXZhbFN0YXRlO2lmKCFhKXRocm93IG5ldyBFcnJvcignZ2V0T3BlcmF0b3JMaXN0OiBtaXNzaW5nICJvcGVyYXRvckxpc3QiIHBhcmFtZXRlcicpO2NvbnN0IG49dGhpcyxvPXRoaXMueHJlZjtsZXQgZz0hMTtjb25zdCBjPW5ldyBMb2NhbEltYWdlQ2FjaGUsQz1uZXcgTG9jYWxDb2xvclNwYWNlQ2FjaGUsaD1uZXcgTG9jYWxHU3RhdGVDYWNoZSxsPW5ldyBMb2NhbFRpbGluZ1BhdHRlcm5DYWNoZSxRPW5ldyBNYXAsRT1pLmdldCgiWE9iamVjdCIpfHxEaWN0LmVtcHR5LHU9aS5nZXQoIlBhdHRlcm4iKXx8RGljdC5lbXB0eSxkPW5ldyBTdGF0ZU1hbmFnZXIocyksZj1uZXcgRXZhbHVhdG9yUHJlcHJvY2Vzc29yKGUsbyxkKSxwPW5ldyBUaW1lU2xvdE1hbmFnZXI7ZnVuY3Rpb24gY2xvc2VQZW5kaW5nUmVzdG9yZU9QUyhlKXtmb3IobGV0IGU9MCx0PWYuc2F2ZWRTdGF0ZXNEZXB0aDtlPHQ7ZSsrKWEuYWRkT3AoeEEsW10pfXJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24gcHJvbWlzZUJvZHkoZSxzKXtjb25zdCBuZXh0PWZ1bmN0aW9uKHQpe1Byb21pc2UuYWxsKFt0LGEucmVhZHldKS50aGVuKChmdW5jdGlvbigpe3RyeXtwcm9taXNlQm9keShlLHMpfWNhdGNoKGUpe3MoZSl9fSkscyl9O3QuZW5zdXJlTm90VGVybWluYXRlZCgpO3AucmVzZXQoKTtjb25zdCBtPXt9O2xldCB5LHcsYixELEYsUztmb3IoOyEoeT1wLmNoZWNrKCkpOyl7bS5hcmdzPW51bGw7aWYoIWYucmVhZChtKSlicmVhaztsZXQgZT1tLmFyZ3Mscz1tLmZuO3N3aXRjaCgwfHMpe2Nhc2UgVWU6Uz1lWzBdaW5zdGFuY2VvZiBOYW1lO0Y9ZVswXS5uYW1lO2lmKFMpe2NvbnN0IHQ9Yy5nZXRCeU5hbWUoRik7aWYodCl7YS5hZGRJbWFnZU9wcyh0LmZuLHQuYXJncyx0Lm9wdGlvbmFsQ29udGVudCk7aW5jcmVtZW50Q2FjaGVkSW1hZ2VNYXNrQ291bnQodCk7ZT1udWxsO2NvbnRpbnVlfX1uZXh0KG5ldyBQcm9taXNlKChmdW5jdGlvbihlLHMpe2lmKCFTKXRocm93IG5ldyBGb3JtYXRFcnJvcigiWE9iamVjdCBtdXN0IGJlIHJlZmVycmVkIHRvIGJ5IG5hbWUuIik7bGV0IHI9RS5nZXRSYXcoRik7aWYociBpbnN0YW5jZW9mIFJlZil7Y29uc3QgdD1jLmdldEJ5UmVmKHIpfHxuLl9yZWdpb25hbEltYWdlQ2FjaGUuZ2V0QnlSZWYocik7aWYodCl7YS5hZGRJbWFnZU9wcyh0LmZuLHQuYXJncyx0Lm9wdGlvbmFsQ29udGVudCk7aW5jcmVtZW50Q2FjaGVkSW1hZ2VNYXNrQ291bnQodCk7ZSgpO3JldHVybn1jb25zdCBpPW4uZ2xvYmFsSW1hZ2VDYWNoZS5nZXREYXRhKHIsbi5wYWdlSW5kZXgpO2lmKGkpe2EuYWRkRGVwZW5kZW5jeShpLm9iaklkKTthLmFkZEltYWdlT3BzKGkuZm4saS5hcmdzLGkub3B0aW9uYWxDb250ZW50KTtlKCk7cmV0dXJufXI9by5mZXRjaChyKX1pZighKHIgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlhPYmplY3Qgc2hvdWxkIGJlIGEgc3RyZWFtIik7Y29uc3QgZz1yLmRpY3QuZ2V0KCJTdWJ0eXBlIik7aWYoIShnIGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJYT2JqZWN0IHNob3VsZCBoYXZlIGEgTmFtZSBzdWJ0eXBlIik7aWYoIkZvcm0iIT09Zy5uYW1lKWlmKCJJbWFnZSIhPT1nLm5hbWUpe2lmKCJQUyIhPT1nLm5hbWUpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbmhhbmRsZWQgWE9iamVjdCBzdWJ0eXBlICR7Zy5uYW1lfWApO2luZm8oIklnbm9yZWQgWE9iamVjdCBzdWJ0eXBlIFBTIik7ZSgpfWVsc2Ugbi5idWlsZFBhaW50SW1hZ2VYT2JqZWN0KHtyZXNvdXJjZXM6aSxpbWFnZTpyLG9wZXJhdG9yTGlzdDphLGNhY2hlS2V5OkYsbG9jYWxJbWFnZUNhY2hlOmMsbG9jYWxDb2xvclNwYWNlQ2FjaGU6Q30pLnRoZW4oZSxzKTtlbHNle2Quc2F2ZSgpO24uYnVpbGRGb3JtWE9iamVjdChpLHIsbnVsbCxhLHQsZC5zdGF0ZS5jbG9uZSgpLEMpLnRoZW4oKGZ1bmN0aW9uKCl7ZC5yZXN0b3JlKCk7ZSgpfSkscyl9fSkpLmNhdGNoKChmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbikpe2lmKCFuLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IGU7d2FybihgZ2V0T3BlcmF0b3JMaXN0IC0gaWdub3JpbmcgWE9iamVjdDogIiR7ZX0iLmApfX0pKSk7cmV0dXJuO2Nhc2Ugc2U6dmFyIGs9ZVsxXTtuZXh0KG4uaGFuZGxlU2V0Rm9udChpLGUsbnVsbCxhLHQsZC5zdGF0ZSxyKS50aGVuKChmdW5jdGlvbihlKXthLmFkZERlcGVuZGVuY3koZSk7YS5hZGRPcChzZSxbZSxrXSl9KSkpO3JldHVybjtjYXNlICRBOmc9ITA7YnJlYWs7Y2FzZSBBZTpnPSExO2JyZWFrO2Nhc2UgeGU6dmFyIE49ZVswXS5jYWNoZUtleTtpZihOKXtjb25zdCB0PWMuZ2V0QnlOYW1lKE4pO2lmKHQpe2EuYWRkSW1hZ2VPcHModC5mbix0LmFyZ3MsdC5vcHRpb25hbENvbnRlbnQpO2luY3JlbWVudENhY2hlZEltYWdlTWFza0NvdW50KHQpO2U9bnVsbDtjb250aW51ZX19bmV4dChuLmJ1aWxkUGFpbnRJbWFnZVhPYmplY3Qoe3Jlc291cmNlczppLGltYWdlOmVbMF0saXNJbmxpbmU6ITAsb3BlcmF0b3JMaXN0OmEsY2FjaGVLZXk6Tixsb2NhbEltYWdlQ2FjaGU6Yyxsb2NhbENvbG9yU3BhY2VDYWNoZTpDfSkpO3JldHVybjtjYXNlIENlOmlmKCFkLnN0YXRlLmZvbnQpe24uZW5zdXJlU3RhdGVGb250KGQuc3RhdGUpO2NvbnRpbnVlfWVbMF09bi5oYW5kbGVUZXh0KGVbMF0sZC5zdGF0ZSk7YnJlYWs7Y2FzZSBoZTppZighZC5zdGF0ZS5mb250KXtuLmVuc3VyZVN0YXRlRm9udChkLnN0YXRlKTtjb250aW51ZX12YXIgUj1bXSxHPWQuc3RhdGU7Zm9yKGNvbnN0IHQgb2YgZVswXSkic3RyaW5nIj09dHlwZW9mIHQ/Ui5wdXNoKC4uLm4uaGFuZGxlVGV4dCh0LEcpKToibnVtYmVyIj09dHlwZW9mIHQmJlIucHVzaCh0KTtlWzBdPVI7cz1DZTticmVhaztjYXNlIGxlOmlmKCFkLnN0YXRlLmZvbnQpe24uZW5zdXJlU3RhdGVGb250KGQuc3RhdGUpO2NvbnRpbnVlfWEuYWRkT3AoY2UpO2VbMF09bi5oYW5kbGVUZXh0KGVbMF0sZC5zdGF0ZSk7cz1DZTticmVhaztjYXNlIEJlOmlmKCFkLnN0YXRlLmZvbnQpe24uZW5zdXJlU3RhdGVGb250KGQuc3RhdGUpO2NvbnRpbnVlfWEuYWRkT3AoY2UpO2EuYWRkT3AodGUsW2Uuc2hpZnQoKV0pO2EuYWRkT3AoZWUsW2Uuc2hpZnQoKV0pO2VbMF09bi5oYW5kbGVUZXh0KGVbMF0sZC5zdGF0ZSk7cz1DZTticmVhaztjYXNlIHJlOmQuc3RhdGUudGV4dFJlbmRlcmluZ01vZGU9ZVswXTticmVhaztjYXNlIGRlOntjb25zdCB0PUNvbG9yU3BhY2UuZ2V0Q2FjaGVkKGVbMF0sbyxDKTtpZih0KXtkLnN0YXRlLmZpbGxDb2xvclNwYWNlPXQ7Y29udGludWV9bmV4dChuLnBhcnNlQ29sb3JTcGFjZSh7Y3M6ZVswXSxyZXNvdXJjZXM6aSxsb2NhbENvbG9yU3BhY2VDYWNoZTpDfSkudGhlbigoZnVuY3Rpb24oZSl7ZSYmKGQuc3RhdGUuZmlsbENvbG9yU3BhY2U9ZSl9KSkpO3JldHVybn1jYXNlIHVlOntjb25zdCB0PUNvbG9yU3BhY2UuZ2V0Q2FjaGVkKGVbMF0sbyxDKTtpZih0KXtkLnN0YXRlLnN0cm9rZUNvbG9yU3BhY2U9dDtjb250aW51ZX1uZXh0KG4ucGFyc2VDb2xvclNwYWNlKHtjczplWzBdLHJlc291cmNlczppLGxvY2FsQ29sb3JTcGFjZUNhY2hlOkN9KS50aGVuKChmdW5jdGlvbihlKXtlJiYoZC5zdGF0ZS5zdHJva2VDb2xvclNwYWNlPWUpfSkpKTtyZXR1cm59Y2FzZSBtZTpEPWQuc3RhdGUuZmlsbENvbG9yU3BhY2U7ZT1ELmdldFJnYihlLDApO3M9RmU7YnJlYWs7Y2FzZSBmZTpEPWQuc3RhdGUuc3Ryb2tlQ29sb3JTcGFjZTtlPUQuZ2V0UmdiKGUsMCk7cz1EZTticmVhaztjYXNlIGJlOmQuc3RhdGUuZmlsbENvbG9yU3BhY2U9Q29sb3JTcGFjZS5zaW5nbGV0b25zLmdyYXk7ZT1Db2xvclNwYWNlLnNpbmdsZXRvbnMuZ3JheS5nZXRSZ2IoZSwwKTtzPUZlO2JyZWFrO2Nhc2Ugd2U6ZC5zdGF0ZS5zdHJva2VDb2xvclNwYWNlPUNvbG9yU3BhY2Uuc2luZ2xldG9ucy5ncmF5O2U9Q29sb3JTcGFjZS5zaW5nbGV0b25zLmdyYXkuZ2V0UmdiKGUsMCk7cz1EZTticmVhaztjYXNlIGtlOmQuc3RhdGUuZmlsbENvbG9yU3BhY2U9Q29sb3JTcGFjZS5zaW5nbGV0b25zLmNteWs7ZT1Db2xvclNwYWNlLnNpbmdsZXRvbnMuY215ay5nZXRSZ2IoZSwwKTtzPUZlO2JyZWFrO2Nhc2UgU2U6ZC5zdGF0ZS5zdHJva2VDb2xvclNwYWNlPUNvbG9yU3BhY2Uuc2luZ2xldG9ucy5jbXlrO2U9Q29sb3JTcGFjZS5zaW5nbGV0b25zLmNteWsuZ2V0UmdiKGUsMCk7cz1EZTticmVhaztjYXNlIEZlOmQuc3RhdGUuZmlsbENvbG9yU3BhY2U9Q29sb3JTcGFjZS5zaW5nbGV0b25zLnJnYjtlPUNvbG9yU3BhY2Uuc2luZ2xldG9ucy5yZ2IuZ2V0UmdiKGUsMCk7YnJlYWs7Y2FzZSBEZTpkLnN0YXRlLnN0cm9rZUNvbG9yU3BhY2U9Q29sb3JTcGFjZS5zaW5nbGV0b25zLnJnYjtlPUNvbG9yU3BhY2Uuc2luZ2xldG9ucy5yZ2IuZ2V0UmdiKGUsMCk7YnJlYWs7Y2FzZSB5ZTpEPWQuc3RhdGUuZmlsbENvbG9yU3BhY2U7aWYoIlBhdHRlcm4iPT09RC5uYW1lKXtuZXh0KG4uaGFuZGxlQ29sb3JOKGEseWUsZSxELHUsaSx0LEMsbCxRKSk7cmV0dXJufWU9RC5nZXRSZ2IoZSwwKTtzPUZlO2JyZWFrO2Nhc2UgcGU6RD1kLnN0YXRlLnN0cm9rZUNvbG9yU3BhY2U7aWYoIlBhdHRlcm4iPT09RC5uYW1lKXtuZXh0KG4uaGFuZGxlQ29sb3JOKGEscGUsZSxELHUsaSx0LEMsbCxRKSk7cmV0dXJufWU9RC5nZXRSZ2IoZSwwKTtzPURlO2JyZWFrO2Nhc2UgTmU6dmFyIHg9aS5nZXQoIlNoYWRpbmciKTtpZigheCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk5vIHNoYWRpbmcgcmVzb3VyY2UgZm91bmQiKTt2YXIgVT14LmdldChlWzBdLm5hbWUpO2lmKCFVKXRocm93IG5ldyBGb3JtYXRFcnJvcigiTm8gc2hhZGluZyBvYmplY3QgZm91bmQiKTtjb25zdCBmPW4ucGFyc2VTaGFkaW5nKHtzaGFkaW5nOlUscmVzb3VyY2VzOmksbG9jYWxDb2xvclNwYWNlQ2FjaGU6Qyxsb2NhbFNoYWRpbmdQYXR0ZXJuQ2FjaGU6UX0pO2lmKCFmKWNvbnRpbnVlO2U9W2ZdO3M9TmU7YnJlYWs7Y2FzZSBSQTpTPWVbMF1pbnN0YW5jZW9mIE5hbWU7Rj1lWzBdLm5hbWU7aWYoUyl7Y29uc3QgdD1oLmdldEJ5TmFtZShGKTtpZih0KXt0Lmxlbmd0aD4wJiZhLmFkZE9wKFJBLFt0XSk7ZT1udWxsO2NvbnRpbnVlfX1uZXh0KG5ldyBQcm9taXNlKChmdW5jdGlvbihlLHMpe2lmKCFTKXRocm93IG5ldyBGb3JtYXRFcnJvcigiR1N0YXRlIG11c3QgYmUgcmVmZXJyZWQgdG8gYnkgbmFtZS4iKTtjb25zdCByPWkuZ2V0KCJFeHRHU3RhdGUiKTtpZighKHIgaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkV4dEdTdGF0ZSBzaG91bGQgYmUgYSBkaWN0aW9uYXJ5LiIpO2NvbnN0IG89ci5nZXQoRik7aWYoIShvIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJHU3RhdGUgc2hvdWxkIGJlIGEgZGljdGlvbmFyeS4iKTtuLnNldEdTdGF0ZSh7cmVzb3VyY2VzOmksZ1N0YXRlOm8sb3BlcmF0b3JMaXN0OmEsY2FjaGVLZXk6Rix0YXNrOnQsc3RhdGVNYW5hZ2VyOmQsbG9jYWxHU3RhdGVDYWNoZTpoLGxvY2FsQ29sb3JTcGFjZUNhY2hlOkN9KS50aGVuKGUscyl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uKSl7aWYoIW4ub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt3YXJuKGBnZXRPcGVyYXRvckxpc3QgLSBpZ25vcmluZyBFeHRHU3RhdGU6ICIke2V9Ii5gKX19KSkpO3JldHVybjtjYXNlIE1BOmNhc2UgTEE6Y2FzZSBIQTpjYXNlIEpBOmNhc2UgWUE6Y2FzZSB2QTpjYXNlIEtBOm4uYnVpbGRQYXRoKGEscyxlLGcpO2NvbnRpbnVlO2Nhc2UgTWU6Y2FzZSBMZTpjYXNlIHZlOmNhc2UgS2U6Y29udGludWU7Y2FzZSBKZTppZighKGVbMF1pbnN0YW5jZW9mIE5hbWUpKXt3YXJuKGBFeHBlY3RlZCBuYW1lIGZvciBiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyBhcmcwPSR7ZVswXX1gKTthLmFkZE9wKEplLFsiT0MiLG51bGxdKTtjb250aW51ZX1pZigiT0MiPT09ZVswXS5uYW1lKXtuZXh0KG4ucGFyc2VNYXJrZWRDb250ZW50UHJvcHMoZVsxXSxpKS50aGVuKChlPT57YS5hZGRPcChKZSxbIk9DIixlXSl9KSkuY2F0Y2goKGU9PntpZighKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbikpe2lmKCFuLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IGU7d2FybihgZ2V0T3BlcmF0b3JMaXN0IC0gaWdub3JpbmcgYmVnaW5NYXJrZWRDb250ZW50UHJvcHM6ICIke2V9Ii5gKTthLmFkZE9wKEplLFsiT0MiLG51bGxdKX19KSkpO3JldHVybn1lPVtlWzBdLm5hbWUsZVsxXWluc3RhbmNlb2YgRGljdD9lWzFdLmdldCgiTUNJRCIpOm51bGxdO2JyZWFrO2RlZmF1bHQ6aWYobnVsbCE9PWUpe2Zvcih3PTAsYj1lLmxlbmd0aDt3PGImJiEoZVt3XWluc3RhbmNlb2YgRGljdCk7dysrKTtpZih3PGIpe3dhcm4oImdldE9wZXJhdG9yTGlzdCAtIGlnbm9yaW5nIG9wZXJhdG9yOiAiK3MpO2NvbnRpbnVlfX19YS5hZGRPcChzLGUpfWlmKHkpbmV4dChrcyk7ZWxzZXtjbG9zZVBlbmRpbmdSZXN0b3JlT1BTKCk7ZSgpfX0pKS5jYXRjaCgoZT0+e2lmKCEoZSBpbnN0YW5jZW9mIEFib3J0RXhjZXB0aW9uKSl7aWYoIXRoaXMub3B0aW9ucy5pZ25vcmVFcnJvcnMpdGhyb3cgZTt3YXJuKGBnZXRPcGVyYXRvckxpc3QgLSBpZ25vcmluZyBlcnJvcnMgZHVyaW5nICIke3QubmFtZX0iIHRhc2s6ICIke2V9Ii5gKTtjbG9zZVBlbmRpbmdSZXN0b3JlT1BTKCl9fSkpfWdldFRleHRDb250ZW50KHtzdHJlYW06ZSx0YXNrOnQscmVzb3VyY2VzOnMsc3RhdGVNYW5hZ2VyOnI9bnVsbCxpbmNsdWRlTWFya2VkQ29udGVudDpuPSExLHNpbms6byxzZWVuU3R5bGVzOmc9bmV3IFNldCx2aWV3Qm94OmMsbWFya2VkQ29udGVudERhdGE6Qz1udWxsLGRpc2FibGVOb3JtYWxpemF0aW9uOmg9ITEsa2VlcFdoaXRlU3BhY2U6bD0hMX0pe3N8fD1EaWN0LmVtcHR5O3J8fD1uZXcgU3RhdGVNYW5hZ2VyKG5ldyBUZXh0U3RhdGUpO24mJihDfHw9e2xldmVsOjB9KTtjb25zdCBRPXtpdGVtczpbXSxzdHlsZXM6T2JqZWN0LmNyZWF0ZShudWxsKX0sRT17aW5pdGlhbGl6ZWQ6ITEsc3RyOltdLHRvdGFsV2lkdGg6MCx0b3RhbEhlaWdodDowLHdpZHRoOjAsaGVpZ2h0OjAsdmVydGljYWw6ITEscHJldlRyYW5zZm9ybTpudWxsLHRleHRBZHZhbmNlU2NhbGU6MCxzcGFjZUluRmxvd01pbjowLHNwYWNlSW5GbG93TWF4OjAsdHJhY2tpbmdTcGFjZU1pbjoxLzAsbmVnYXRpdmVTcGFjZU1heDotMS8wLG5vdEFTcGFjZTotMS8wLHRyYW5zZm9ybTpudWxsLGZvbnROYW1lOm51bGwsaGFzRU9MOiExfSx1PVsiICIsIiAiXTtsZXQgZD0wO2Z1bmN0aW9uIHNhdmVMYXN0Q2hhcihlKXtjb25zdCB0PShkKzEpJTIsaT0iICIhPT11W2RdJiYiICI9PT11W3RdO3VbZF09ZTtkPXQ7cmV0dXJuIWwmJml9ZnVuY3Rpb24gc2hvdWxkQWRkV2hpdGVwc2FjZSgpe3JldHVybiFsJiYiICIhPT11W2RdJiYiICI9PT11WyhkKzEpJTJdfWZ1bmN0aW9uIHJlc2V0TGFzdENoYXJzKCl7dVswXT11WzFdPSIgIjtkPTB9Y29uc3QgZj10aGlzLHA9dGhpcy54cmVmLG09W107bGV0IHk9bnVsbDtjb25zdCB3PW5ldyBMb2NhbEltYWdlQ2FjaGUsYj1uZXcgTG9jYWxHU3RhdGVDYWNoZSxEPW5ldyBFdmFsdWF0b3JQcmVwcm9jZXNzb3IoZSxwLHIpO2xldCBGO2Z1bmN0aW9uIHB1c2hXaGl0ZXNwYWNlKHt3aWR0aDplPTAsaGVpZ2h0OnQ9MCx0cmFuc2Zvcm06aT1FLnByZXZUcmFuc2Zvcm0sZm9udE5hbWU6YT1FLmZvbnROYW1lfSl7US5pdGVtcy5wdXNoKHtzdHI6IiAiLGRpcjoibHRyIix3aWR0aDplLGhlaWdodDp0LHRyYW5zZm9ybTppLGZvbnROYW1lOmEsaGFzRU9MOiExfSl9ZnVuY3Rpb24gZ2V0Q3VycmVudFRleHRUcmFuc2Zvcm0oKXtjb25zdCBlPUYuZm9udCx0PVtGLmZvbnRTaXplKkYudGV4dEhTY2FsZSwwLDAsRi5mb250U2l6ZSwwLEYudGV4dFJpc2VdO2lmKGUuaXNUeXBlM0ZvbnQmJihGLmZvbnRTaXplPD0xfHxlLmlzQ2hhckJCb3gpJiYhaXNBcnJheUVxdWFsKEYuZm9udE1hdHJpeCxhKSl7Y29uc3QgaT1lLmJib3hbM10tZS5iYm94WzFdO2k+MCYmKHRbM10qPWkqRi5mb250TWF0cml4WzNdKX1yZXR1cm4gVXRpbC50cmFuc2Zvcm0oRi5jdG0sVXRpbC50cmFuc2Zvcm0oRi50ZXh0TWF0cml4LHQpKX1mdW5jdGlvbiBlbnN1cmVUZXh0Q29udGVudEl0ZW0oKXtpZihFLmluaXRpYWxpemVkKXJldHVybiBFO2NvbnN0e2ZvbnQ6ZSxsb2FkZWROYW1lOnR9PUY7aWYoIWcuaGFzKHQpKXtnLmFkZCh0KTtRLnN0eWxlc1t0XT17Zm9udEZhbWlseTplLmZhbGxiYWNrTmFtZSxhc2NlbnQ6ZS5hc2NlbnQsZGVzY2VudDplLmRlc2NlbnQsdmVydGljYWw6ZS52ZXJ0aWNhbH07aWYoZi5vcHRpb25zLmZvbnRFeHRyYVByb3BlcnRpZXMmJmUuc3lzdGVtRm9udEluZm8pe2NvbnN0IGk9US5zdHlsZXNbdF07aS5mb250U3Vic3RpdHV0aW9uPWUuc3lzdGVtRm9udEluZm8uY3NzO2kuZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWU9ZS5zeXN0ZW1Gb250SW5mby5sb2FkZWROYW1lfX1FLmZvbnROYW1lPXQ7Y29uc3QgaT1FLnRyYW5zZm9ybT1nZXRDdXJyZW50VGV4dFRyYW5zZm9ybSgpO2lmKGUudmVydGljYWwpe0Uud2lkdGg9RS50b3RhbFdpZHRoPU1hdGguaHlwb3QoaVswXSxpWzFdKTtFLmhlaWdodD1FLnRvdGFsSGVpZ2h0PTA7RS52ZXJ0aWNhbD0hMH1lbHNle0Uud2lkdGg9RS50b3RhbFdpZHRoPTA7RS5oZWlnaHQ9RS50b3RhbEhlaWdodD1NYXRoLmh5cG90KGlbMl0saVszXSk7RS52ZXJ0aWNhbD0hMX1jb25zdCBhPU1hdGguaHlwb3QoRi50ZXh0TGluZU1hdHJpeFswXSxGLnRleHRMaW5lTWF0cml4WzFdKSxzPU1hdGguaHlwb3QoRi5jdG1bMF0sRi5jdG1bMV0pO0UudGV4dEFkdmFuY2VTY2FsZT1zKmE7Y29uc3R7Zm9udFNpemU6cn09RjtFLnRyYWNraW5nU3BhY2VNaW49LjEwMipyO0Uubm90QVNwYWNlPS4wMypyO0UubmVnYXRpdmVTcGFjZU1heD0tLjIqcjtFLnNwYWNlSW5GbG93TWluPS4xMDIqcjtFLnNwYWNlSW5GbG93TWF4PS42KnI7RS5oYXNFT0w9ITE7RS5pbml0aWFsaXplZD0hMDtyZXR1cm4gRX1mdW5jdGlvbiB1cGRhdGVBZHZhbmNlU2NhbGUoKXtpZighRS5pbml0aWFsaXplZClyZXR1cm47Y29uc3QgZT1NYXRoLmh5cG90KEYudGV4dExpbmVNYXRyaXhbMF0sRi50ZXh0TGluZU1hdHJpeFsxXSksdD1NYXRoLmh5cG90KEYuY3RtWzBdLEYuY3RtWzFdKSplO2lmKHQhPT1FLnRleHRBZHZhbmNlU2NhbGUpe2lmKEUudmVydGljYWwpe0UudG90YWxIZWlnaHQrPUUuaGVpZ2h0KkUudGV4dEFkdmFuY2VTY2FsZTtFLmhlaWdodD0wfWVsc2V7RS50b3RhbFdpZHRoKz1FLndpZHRoKkUudGV4dEFkdmFuY2VTY2FsZTtFLndpZHRoPTB9RS50ZXh0QWR2YW5jZVNjYWxlPXR9fWZ1bmN0aW9uIHJ1bkJpZGlUcmFuc2Zvcm0oZSl7bGV0IHQ9ZS5zdHIuam9pbigiIik7aHx8KHQ9ZnVuY3Rpb24gbm9ybWFsaXplVW5pY29kZShlKXtpZighZ3Qpe2d0PS8oW1x1MDBhMFx1MDBiNVx1MDM3ZVx1MGViM1x1MjAwMC1cdTIwMGFcdTIwMmZcdTIxMjZcdWZiMDAtXHVmYjA0XHVmYjA2XHVmYjIwLVx1ZmIzNlx1ZmIzOC1cdWZiM2NcdWZiM2VcdWZiNDAtXHVmYjQxXHVmYjQzLVx1ZmI0NFx1ZmI0Ni1cdWZiYTFcdWZiYTQtXHVmYmE5XHVmYmFlLVx1ZmJiMVx1ZmJkMy1cdWZiZGNcdWZiZGUtXHVmYmU3XHVmYmVhLVx1ZmJmOFx1ZmJmYy1cdWZiZmRcdWZjMDAtXHVmYzVkXHVmYzY0LVx1ZmNmMVx1ZmNmNS1cdWZkM2RcdWZkODhcdWZkZjRcdWZkZmEtXHVmZGZiXHVmZTcxXHVmZTc3XHVmZTc5XHVmZTdiXHVmZTdkXSspfChcdWZiMDUrKS9ndTtJdD1uZXcgTWFwKFtbIu+shSIsIsW/dCJdXSl9cmV0dXJuIGUucmVwbGFjZUFsbChndCwoKGUsdCxpKT0+dD90Lm5vcm1hbGl6ZSgiTkZLQyIpOkl0LmdldChpKSkpfSh0KSk7Y29uc3QgaT1iaWRpKHQsLTEsZS52ZXJ0aWNhbCk7cmV0dXJue3N0cjppLnN0cixkaXI6aS5kaXIsd2lkdGg6TWF0aC5hYnMoZS50b3RhbFdpZHRoKSxoZWlnaHQ6TWF0aC5hYnMoZS50b3RhbEhlaWdodCksdHJhbnNmb3JtOmUudHJhbnNmb3JtLGZvbnROYW1lOmUuZm9udE5hbWUsaGFzRU9MOmUuaGFzRU9MfX1hc3luYyBmdW5jdGlvbiBoYW5kbGVTZXRGb250KGUsaSl7Y29uc3Qgcj1hd2FpdCBmLmxvYWRGb250KGUsaSxzKTtpZihyLmZvbnQuaXNUeXBlM0ZvbnQpdHJ5e2F3YWl0IHIubG9hZFR5cGUzRGF0YShmLHMsdCl9Y2F0Y2h7fUYubG9hZGVkTmFtZT1yLmxvYWRlZE5hbWU7Ri5mb250PXIuZm9udDtGLmZvbnRNYXRyaXg9ci5mb250LmZvbnRNYXRyaXh8fGF9ZnVuY3Rpb24gYXBwbHlJbnZlcnNlUm90YXRpb24oZSx0LGkpe2NvbnN0IGE9TWF0aC5oeXBvdChpWzBdLGlbMV0pO3JldHVyblsoaVswXSplK2lbMV0qdCkvYSwoaVsyXSplK2lbM10qdCkvYV19ZnVuY3Rpb24gY29tcGFyZVdpdGhMYXN0UG9zaXRpb24oZSl7Y29uc3QgdD1nZXRDdXJyZW50VGV4dFRyYW5zZm9ybSgpO2xldCBpPXRbNF0sYT10WzVdO2lmKEYuZm9udD8udmVydGljYWwpe2lmKGk8Y1swXXx8aT5jWzJdfHxhK2U8Y1sxXXx8YT5jWzNdKXJldHVybiExfWVsc2UgaWYoaStlPGNbMF18fGk+Y1syXXx8YTxjWzFdfHxhPmNbM10pcmV0dXJuITE7aWYoIUYuZm9udHx8IUUucHJldlRyYW5zZm9ybSlyZXR1cm4hMDtsZXQgcz1FLnByZXZUcmFuc2Zvcm1bNF0scj1FLnByZXZUcmFuc2Zvcm1bNV07aWYocz09PWkmJnI9PT1hKXJldHVybiEwO2xldCBuPS0xO3RbMF0mJjA9PT10WzFdJiYwPT09dFsyXT9uPXRbMF0+MD8wOjE4MDp0WzFdJiYwPT09dFswXSYmMD09PXRbM10mJihuPXRbMV0+MD85MDoyNzApO3N3aXRjaChuKXtjYXNlIDA6YnJlYWs7Y2FzZSA5MDpbaSxhXT1bYSxpXTtbcyxyXT1bcixzXTticmVhaztjYXNlIDE4MDpbaSxhLHMscl09Wy1pLC1hLC1zLC1yXTticmVhaztjYXNlIDI3MDpbaSxhXT1bLWEsLWldO1tzLHJdPVstciwtc107YnJlYWs7ZGVmYXVsdDpbaSxhXT1hcHBseUludmVyc2VSb3RhdGlvbihpLGEsdCk7W3Mscl09YXBwbHlJbnZlcnNlUm90YXRpb24ocyxyLEUucHJldlRyYW5zZm9ybSl9aWYoRi5mb250LnZlcnRpY2FsKXtjb25zdCBlPShyLWEpL0UudGV4dEFkdmFuY2VTY2FsZSx0PWktcyxuPU1hdGguc2lnbihFLmhlaWdodCk7aWYoZTxuKkUubmVnYXRpdmVTcGFjZU1heCl7aWYoTWF0aC5hYnModCk+LjUqRS53aWR0aCl7YXBwZW5kRU9MKCk7cmV0dXJuITB9cmVzZXRMYXN0Q2hhcnMoKTtmbHVzaFRleHRDb250ZW50SXRlbSgpO3JldHVybiEwfWlmKE1hdGguYWJzKHQpPkUud2lkdGgpe2FwcGVuZEVPTCgpO3JldHVybiEwfWU8PW4qRS5ub3RBU3BhY2UmJnJlc2V0TGFzdENoYXJzKCk7aWYoZTw9bipFLnRyYWNraW5nU3BhY2VNaW4paWYoc2hvdWxkQWRkV2hpdGVwc2FjZSgpKXtyZXNldExhc3RDaGFycygpO2ZsdXNoVGV4dENvbnRlbnRJdGVtKCk7cHVzaFdoaXRlc3BhY2Uoe2hlaWdodDpNYXRoLmFicyhlKX0pfWVsc2UgRS5oZWlnaHQrPWU7ZWxzZSBpZighYWRkRmFrZVNwYWNlcyhlLEUucHJldlRyYW5zZm9ybSxuKSlpZigwPT09RS5zdHIubGVuZ3RoKXtyZXNldExhc3RDaGFycygpO3B1c2hXaGl0ZXNwYWNlKHtoZWlnaHQ6TWF0aC5hYnMoZSl9KX1lbHNlIEUuaGVpZ2h0Kz1lO01hdGguYWJzKHQpPi4yNSpFLndpZHRoJiZmbHVzaFRleHRDb250ZW50SXRlbSgpO3JldHVybiEwfWNvbnN0IG89KGktcykvRS50ZXh0QWR2YW5jZVNjYWxlLGc9YS1yLEM9TWF0aC5zaWduKEUud2lkdGgpO2lmKG88QypFLm5lZ2F0aXZlU3BhY2VNYXgpe2lmKE1hdGguYWJzKGcpPi41KkUuaGVpZ2h0KXthcHBlbmRFT0woKTtyZXR1cm4hMH1yZXNldExhc3RDaGFycygpO2ZsdXNoVGV4dENvbnRlbnRJdGVtKCk7cmV0dXJuITB9aWYoTWF0aC5hYnMoZyk+RS5oZWlnaHQpe2FwcGVuZEVPTCgpO3JldHVybiEwfW88PUMqRS5ub3RBU3BhY2UmJnJlc2V0TGFzdENoYXJzKCk7aWYobzw9QypFLnRyYWNraW5nU3BhY2VNaW4paWYoc2hvdWxkQWRkV2hpdGVwc2FjZSgpKXtyZXNldExhc3RDaGFycygpO2ZsdXNoVGV4dENvbnRlbnRJdGVtKCk7cHVzaFdoaXRlc3BhY2Uoe3dpZHRoOk1hdGguYWJzKG8pfSl9ZWxzZSBFLndpZHRoKz1vO2Vsc2UgaWYoIWFkZEZha2VTcGFjZXMobyxFLnByZXZUcmFuc2Zvcm0sQykpaWYoMD09PUUuc3RyLmxlbmd0aCl7cmVzZXRMYXN0Q2hhcnMoKTtwdXNoV2hpdGVzcGFjZSh7d2lkdGg6TWF0aC5hYnMobyl9KX1lbHNlIEUud2lkdGgrPW87TWF0aC5hYnMoZyk+LjI1KkUuaGVpZ2h0JiZmbHVzaFRleHRDb250ZW50SXRlbSgpO3JldHVybiEwfWZ1bmN0aW9uIGJ1aWxkVGV4dENvbnRlbnRJdGVtKHtjaGFyczplLGV4dHJhU3BhY2luZzp0fSl7Y29uc3QgaT1GLmZvbnQ7aWYoIWUpe2NvbnN0IGU9Ri5jaGFyU3BhY2luZyt0O2UmJihpLnZlcnRpY2FsP0YudHJhbnNsYXRlVGV4dE1hdHJpeCgwLC1lKTpGLnRyYW5zbGF0ZVRleHRNYXRyaXgoZSpGLnRleHRIU2NhbGUsMCkpO2wmJmNvbXBhcmVXaXRoTGFzdFBvc2l0aW9uKDApO3JldHVybn1jb25zdCBhPWkuY2hhcnNUb0dseXBocyhlKSxzPUYuZm9udE1hdHJpeFswXSpGLmZvbnRTaXplO2ZvcihsZXQgZT0wLHI9YS5sZW5ndGg7ZTxyO2UrKyl7Y29uc3Qgbj1hW2VdLHtjYXRlZ29yeTpvfT1uO2lmKG8uaXNJbnZpc2libGVGb3JtYXRNYXJrKWNvbnRpbnVlO2xldCBnPUYuY2hhclNwYWNpbmcrKGUrMT09PXI/dDowKSxjPW4ud2lkdGg7aS52ZXJ0aWNhbCYmKGM9bi52bWV0cmljP24udm1ldHJpY1swXTotYyk7bGV0IEM9YypzO2lmKCFsJiZvLmlzV2hpdGVzcGFjZSl7aWYoaS52ZXJ0aWNhbCl7Zys9LUMrRi53b3JkU3BhY2luZztGLnRyYW5zbGF0ZVRleHRNYXRyaXgoMCwtZyl9ZWxzZXtnKz1DK0Yud29yZFNwYWNpbmc7Ri50cmFuc2xhdGVUZXh0TWF0cml4KGcqRi50ZXh0SFNjYWxlLDApfXNhdmVMYXN0Q2hhcigiICIpO2NvbnRpbnVlfWlmKCFvLmlzWmVyb1dpZHRoRGlhY3JpdGljJiYhY29tcGFyZVdpdGhMYXN0UG9zaXRpb24oQykpe2kudmVydGljYWw/Ri50cmFuc2xhdGVUZXh0TWF0cml4KDAsQyk6Ri50cmFuc2xhdGVUZXh0TWF0cml4KEMqRi50ZXh0SFNjYWxlLDApO2NvbnRpbnVlfWNvbnN0IGg9ZW5zdXJlVGV4dENvbnRlbnRJdGVtKCk7by5pc1plcm9XaWR0aERpYWNyaXRpYyYmKEM9MCk7aWYoaS52ZXJ0aWNhbCl7Ri50cmFuc2xhdGVUZXh0TWF0cml4KDAsQyk7Qz1NYXRoLmFicyhDKTtoLmhlaWdodCs9Q31lbHNle0MqPUYudGV4dEhTY2FsZTtGLnRyYW5zbGF0ZVRleHRNYXRyaXgoQywwKTtoLndpZHRoKz1DfUMmJihoLnByZXZUcmFuc2Zvcm09Z2V0Q3VycmVudFRleHRUcmFuc2Zvcm0oKSk7Y29uc3QgUT1uLnVuaWNvZGU7c2F2ZUxhc3RDaGFyKFEpJiZoLnN0ci5wdXNoKCIgIik7aC5zdHIucHVzaChRKTtnJiYoaS52ZXJ0aWNhbD9GLnRyYW5zbGF0ZVRleHRNYXRyaXgoMCwtZyk6Ri50cmFuc2xhdGVUZXh0TWF0cml4KGcqRi50ZXh0SFNjYWxlLDApKX19ZnVuY3Rpb24gYXBwZW5kRU9MKCl7cmVzZXRMYXN0Q2hhcnMoKTtpZihFLmluaXRpYWxpemVkKXtFLmhhc0VPTD0hMDtmbHVzaFRleHRDb250ZW50SXRlbSgpfWVsc2UgUS5pdGVtcy5wdXNoKHtzdHI6IiIsZGlyOiJsdHIiLHdpZHRoOjAsaGVpZ2h0OjAsdHJhbnNmb3JtOmdldEN1cnJlbnRUZXh0VHJhbnNmb3JtKCksZm9udE5hbWU6Ri5sb2FkZWROYW1lLGhhc0VPTDohMH0pfWZ1bmN0aW9uIGFkZEZha2VTcGFjZXMoZSx0LGkpe2lmKGkqRS5zcGFjZUluRmxvd01pbjw9ZSYmZTw9aSpFLnNwYWNlSW5GbG93TWF4KXtpZihFLmluaXRpYWxpemVkKXtyZXNldExhc3RDaGFycygpO0Uuc3RyLnB1c2goIiAiKX1yZXR1cm4hMX1jb25zdCBhPUUuZm9udE5hbWU7bGV0IHM9MDtpZihFLnZlcnRpY2FsKXtzPWU7ZT0wfWZsdXNoVGV4dENvbnRlbnRJdGVtKCk7cmVzZXRMYXN0Q2hhcnMoKTtwdXNoV2hpdGVzcGFjZSh7d2lkdGg6TWF0aC5hYnMoZSksaGVpZ2h0Ok1hdGguYWJzKHMpLHRyYW5zZm9ybTp0fHxnZXRDdXJyZW50VGV4dFRyYW5zZm9ybSgpLGZvbnROYW1lOmF9KTtyZXR1cm4hMH1mdW5jdGlvbiBmbHVzaFRleHRDb250ZW50SXRlbSgpe2lmKEUuaW5pdGlhbGl6ZWQmJkUuc3RyKXtFLnZlcnRpY2FsP0UudG90YWxIZWlnaHQrPUUuaGVpZ2h0KkUudGV4dEFkdmFuY2VTY2FsZTpFLnRvdGFsV2lkdGgrPUUud2lkdGgqRS50ZXh0QWR2YW5jZVNjYWxlO1EuaXRlbXMucHVzaChydW5CaWRpVHJhbnNmb3JtKEUpKTtFLmluaXRpYWxpemVkPSExO0Uuc3RyLmxlbmd0aD0wfX1mdW5jdGlvbiBlbnF1ZXVlQ2h1bmsoZT0hMSl7Y29uc3QgdD1RLml0ZW1zLmxlbmd0aDtpZigwIT09dCYmIShlJiZ0PDEwKSl7by5lbnF1ZXVlKFEsdCk7US5pdGVtcz1bXTtRLnN0eWxlcz1PYmplY3QuY3JlYXRlKG51bGwpfX1jb25zdCBTPW5ldyBUaW1lU2xvdE1hbmFnZXI7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbiBwcm9taXNlQm9keShlLGEpe2NvbnN0IG5leHQ9ZnVuY3Rpb24odCl7ZW5xdWV1ZUNodW5rKCEwKTtQcm9taXNlLmFsbChbdCxvLnJlYWR5XSkudGhlbigoZnVuY3Rpb24oKXt0cnl7cHJvbWlzZUJvZHkoZSxhKX1jYXRjaChlKXthKGUpfX0pLGEpfTt0LmVuc3VyZU5vdFRlcm1pbmF0ZWQoKTtTLnJlc2V0KCk7Y29uc3QgRT17fTtsZXQgdSxkPVtdO2Zvcig7ISh1PVMuY2hlY2soKSk7KXtkLmxlbmd0aD0wO0UuYXJncz1kO2lmKCFELnJlYWQoRSkpYnJlYWs7Y29uc3QgZT1GO0Y9ci5zdGF0ZTtjb25zdCBhPUUuZm47ZD1FLmFyZ3M7c3dpdGNoKDB8YSl7Y2FzZSBzZTp2YXIgaz1kWzBdLm5hbWUsTj1kWzFdO2lmKEYuZm9udCYmaz09PUYuZm9udE5hbWUmJk49PT1GLmZvbnRTaXplKWJyZWFrO2ZsdXNoVGV4dENvbnRlbnRJdGVtKCk7Ri5mb250TmFtZT1rO0YuZm9udFNpemU9TjtuZXh0KGhhbmRsZVNldEZvbnQoayxudWxsKSk7cmV0dXJuO2Nhc2UgbmU6Ri50ZXh0UmlzZT1kWzBdO2JyZWFrO2Nhc2UgaWU6Ri50ZXh0SFNjYWxlPWRbMF0vMTAwO2JyZWFrO2Nhc2UgYWU6Ri5sZWFkaW5nPWRbMF07YnJlYWs7Y2FzZSBvZTpGLnRyYW5zbGF0ZVRleHRMaW5lTWF0cml4KGRbMF0sZFsxXSk7Ri50ZXh0TWF0cml4PUYudGV4dExpbmVNYXRyaXguc2xpY2UoKTticmVhaztjYXNlIGdlOkYubGVhZGluZz0tZFsxXTtGLnRyYW5zbGF0ZVRleHRMaW5lTWF0cml4KGRbMF0sZFsxXSk7Ri50ZXh0TWF0cml4PUYudGV4dExpbmVNYXRyaXguc2xpY2UoKTticmVhaztjYXNlIGNlOkYuY2FycmlhZ2VSZXR1cm4oKTticmVhaztjYXNlIEllOkYuc2V0VGV4dE1hdHJpeChkWzBdLGRbMV0sZFsyXSxkWzNdLGRbNF0sZFs1XSk7Ri5zZXRUZXh0TGluZU1hdHJpeChkWzBdLGRbMV0sZFsyXSxkWzNdLGRbNF0sZFs1XSk7dXBkYXRlQWR2YW5jZVNjYWxlKCk7YnJlYWs7Y2FzZSBlZTpGLmNoYXJTcGFjaW5nPWRbMF07YnJlYWs7Y2FzZSB0ZTpGLndvcmRTcGFjaW5nPWRbMF07YnJlYWs7Y2FzZSAkQTpGLnRleHRNYXRyaXg9aS5zbGljZSgpO0YudGV4dExpbmVNYXRyaXg9aS5zbGljZSgpO2JyZWFrO2Nhc2UgaGU6aWYoIXIuc3RhdGUuZm9udCl7Zi5lbnN1cmVTdGF0ZUZvbnQoci5zdGF0ZSk7Y29udGludWV9Y29uc3QgYT0oRi5mb250LnZlcnRpY2FsPzE6LTEpKkYuZm9udFNpemUvMWUzLEU9ZFswXTtmb3IobGV0IGU9MCx0PUUubGVuZ3RoO2U8dDtlKyspe2NvbnN0IHQ9RVtlXTtpZigic3RyaW5nIj09dHlwZW9mIHQpbS5wdXNoKHQpO2Vsc2UgaWYoIm51bWJlciI9PXR5cGVvZiB0JiYwIT09dCl7Y29uc3QgZT1tLmpvaW4oIiIpO20ubGVuZ3RoPTA7YnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOmUsZXh0cmFTcGFjaW5nOnQqYX0pfX1pZihtLmxlbmd0aD4wKXtjb25zdCBlPW0uam9pbigiIik7bS5sZW5ndGg9MDtidWlsZFRleHRDb250ZW50SXRlbSh7Y2hhcnM6ZSxleHRyYVNwYWNpbmc6MH0pfWJyZWFrO2Nhc2UgQ2U6aWYoIXIuc3RhdGUuZm9udCl7Zi5lbnN1cmVTdGF0ZUZvbnQoci5zdGF0ZSk7Y29udGludWV9YnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOmRbMF0sZXh0cmFTcGFjaW5nOjB9KTticmVhaztjYXNlIGxlOmlmKCFyLnN0YXRlLmZvbnQpe2YuZW5zdXJlU3RhdGVGb250KHIuc3RhdGUpO2NvbnRpbnVlfUYuY2FycmlhZ2VSZXR1cm4oKTtidWlsZFRleHRDb250ZW50SXRlbSh7Y2hhcnM6ZFswXSxleHRyYVNwYWNpbmc6MH0pO2JyZWFrO2Nhc2UgQmU6aWYoIXIuc3RhdGUuZm9udCl7Zi5lbnN1cmVTdGF0ZUZvbnQoci5zdGF0ZSk7Y29udGludWV9Ri53b3JkU3BhY2luZz1kWzBdO0YuY2hhclNwYWNpbmc9ZFsxXTtGLmNhcnJpYWdlUmV0dXJuKCk7YnVpbGRUZXh0Q29udGVudEl0ZW0oe2NoYXJzOmRbMl0sZXh0cmFTcGFjaW5nOjB9KTticmVhaztjYXNlIFVlOmZsdXNoVGV4dENvbnRlbnRJdGVtKCk7eXx8KHk9cy5nZXQoIlhPYmplY3QiKXx8RGljdC5lbXB0eSk7dmFyIFI9ZFswXWluc3RhbmNlb2YgTmFtZSxHPWRbMF0ubmFtZTtpZihSJiZ3LmdldEJ5TmFtZShHKSlicmVhaztuZXh0KG5ldyBQcm9taXNlKChmdW5jdGlvbihlLGkpe2lmKCFSKXRocm93IG5ldyBGb3JtYXRFcnJvcigiWE9iamVjdCBtdXN0IGJlIHJlZmVycmVkIHRvIGJ5IG5hbWUuIik7bGV0IGE9eS5nZXRSYXcoRyk7aWYoYSBpbnN0YW5jZW9mIFJlZil7aWYody5nZXRCeVJlZihhKSl7ZSgpO3JldHVybn1pZihmLmdsb2JhbEltYWdlQ2FjaGUuZ2V0RGF0YShhLGYucGFnZUluZGV4KSl7ZSgpO3JldHVybn1hPXAuZmV0Y2goYSl9aWYoIShhIGluc3RhbmNlb2YgQmFzZVN0cmVhbSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJYT2JqZWN0IHNob3VsZCBiZSBhIHN0cmVhbSIpO2NvbnN0IFE9YS5kaWN0LmdldCgiU3VidHlwZSIpO2lmKCEoUSBpbnN0YW5jZW9mIE5hbWUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiWE9iamVjdCBzaG91bGQgaGF2ZSBhIE5hbWUgc3VidHlwZSIpO2lmKCJGb3JtIiE9PVEubmFtZSl7dy5zZXQoRyxhLmRpY3Qub2JqSWQsITApO2UoKTtyZXR1cm59Y29uc3QgRT1yLnN0YXRlLmNsb25lKCksdT1uZXcgU3RhdGVNYW5hZ2VyKEUpLGQ9YS5kaWN0LmdldEFycmF5KCJNYXRyaXgiKTtBcnJheS5pc0FycmF5KGQpJiY2PT09ZC5sZW5ndGgmJnUudHJhbnNmb3JtKGQpO2VucXVldWVDaHVuaygpO2NvbnN0IG09e2VucXVldWVJbnZva2VkOiExLGVucXVldWUoZSx0KXt0aGlzLmVucXVldWVJbnZva2VkPSEwO28uZW5xdWV1ZShlLHQpfSxnZXQgZGVzaXJlZFNpemUoKXtyZXR1cm4gby5kZXNpcmVkU2l6ZX0sZ2V0IHJlYWR5KCl7cmV0dXJuIG8ucmVhZHl9fTtmLmdldFRleHRDb250ZW50KHtzdHJlYW06YSx0YXNrOnQscmVzb3VyY2VzOmEuZGljdC5nZXQoIlJlc291cmNlcyIpfHxzLHN0YXRlTWFuYWdlcjp1LGluY2x1ZGVNYXJrZWRDb250ZW50Om4sc2luazptLHNlZW5TdHlsZXM6Zyx2aWV3Qm94OmMsbWFya2VkQ29udGVudERhdGE6QyxkaXNhYmxlTm9ybWFsaXphdGlvbjpoLGtlZXBXaGl0ZVNwYWNlOmx9KS50aGVuKChmdW5jdGlvbigpe20uZW5xdWV1ZUludm9rZWR8fHcuc2V0KEcsYS5kaWN0Lm9iaklkLCEwKTtlKCl9KSxpKX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24pKXtpZighZi5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3dhcm4oYGdldFRleHRDb250ZW50IC0gaWdub3JpbmcgWE9iamVjdDogIiR7ZX0iLmApfX0pKSk7cmV0dXJuO2Nhc2UgUkE6Uj1kWzBdaW5zdGFuY2VvZiBOYW1lO0c9ZFswXS5uYW1lO2lmKFImJmIuZ2V0QnlOYW1lKEcpKWJyZWFrO25leHQobmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsdCl7aWYoIVIpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJHU3RhdGUgbXVzdCBiZSByZWZlcnJlZCB0byBieSBuYW1lLiIpO2NvbnN0IGk9cy5nZXQoIkV4dEdTdGF0ZSIpO2lmKCEoaSBpbnN0YW5jZW9mIERpY3QpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiRXh0R1N0YXRlIHNob3VsZCBiZSBhIGRpY3Rpb25hcnkuIik7Y29uc3QgYT1pLmdldChHKTtpZighKGEgaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkdTdGF0ZSBzaG91bGQgYmUgYSBkaWN0aW9uYXJ5LiIpO2NvbnN0IHI9YS5nZXQoIkZvbnQiKTtpZihyKXtmbHVzaFRleHRDb250ZW50SXRlbSgpO0YuZm9udE5hbWU9bnVsbDtGLmZvbnRTaXplPXJbMV07aGFuZGxlU2V0Rm9udChudWxsLHJbMF0pLnRoZW4oZSx0KX1lbHNle2Iuc2V0KEcsYS5vYmpJZCwhMCk7ZSgpfX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24pKXtpZighZi5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3dhcm4oYGdldFRleHRDb250ZW50IC0gaWdub3JpbmcgRXh0R1N0YXRlOiAiJHtlfSIuYCl9fSkpKTtyZXR1cm47Y2FzZSBIZTpmbHVzaFRleHRDb250ZW50SXRlbSgpO2lmKG4pe0MubGV2ZWwrKztRLml0ZW1zLnB1c2goe3R5cGU6ImJlZ2luTWFya2VkQ29udGVudCIsdGFnOmRbMF1pbnN0YW5jZW9mIE5hbWU/ZFswXS5uYW1lOm51bGx9KX1icmVhaztjYXNlIEplOmZsdXNoVGV4dENvbnRlbnRJdGVtKCk7aWYobil7Qy5sZXZlbCsrO2xldCBlPW51bGw7ZFsxXWluc3RhbmNlb2YgRGljdCYmKGU9ZFsxXS5nZXQoIk1DSUQiKSk7US5pdGVtcy5wdXNoKHt0eXBlOiJiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyIsaWQ6TnVtYmVyLmlzSW50ZWdlcihlKT9gJHtmLmlkRmFjdG9yeS5nZXRQYWdlT2JqSWQoKX1fbWMke2V9YDpudWxsLHRhZzpkWzBdaW5zdGFuY2VvZiBOYW1lP2RbMF0ubmFtZTpudWxsfSl9YnJlYWs7Y2FzZSBZZTpmbHVzaFRleHRDb250ZW50SXRlbSgpO2lmKG4pe2lmKDA9PT1DLmxldmVsKWJyZWFrO0MubGV2ZWwtLTtRLml0ZW1zLnB1c2goe3R5cGU6ImVuZE1hcmtlZENvbnRlbnQifSl9YnJlYWs7Y2FzZSB4QTohZXx8ZS5mb250PT09Ri5mb250JiZlLmZvbnRTaXplPT09Ri5mb250U2l6ZSYmZS5mb250TmFtZT09PUYuZm9udE5hbWV8fGZsdXNoVGV4dENvbnRlbnRJdGVtKCl9aWYoUS5pdGVtcy5sZW5ndGg+PW8uZGVzaXJlZFNpemUpe3U9ITA7YnJlYWt9fWlmKHUpbmV4dChrcyk7ZWxzZXtmbHVzaFRleHRDb250ZW50SXRlbSgpO2VucXVldWVDaHVuaygpO2UoKX19KSkuY2F0Y2goKGU9PntpZighKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbikpe2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IGU7d2FybihgZ2V0VGV4dENvbnRlbnQgLSBpZ25vcmluZyBlcnJvcnMgZHVyaW5nICIke3QubmFtZX0iIHRhc2s6ICIke2V9Ii5gKTtmbHVzaFRleHRDb250ZW50SXRlbSgpO2VucXVldWVDaHVuaygpfX0pKX1hc3luYyBleHRyYWN0RGF0YVN0cnVjdHVyZXMoZSx0KXtjb25zdCBpPXRoaXMueHJlZjtsZXQgYTtjb25zdCBzPXRoaXMucmVhZFRvVW5pY29kZSh0LnRvVW5pY29kZSk7aWYodC5jb21wb3NpdGUpe2NvbnN0IGk9ZS5nZXQoIkNJRFN5c3RlbUluZm8iKTtpIGluc3RhbmNlb2YgRGljdCYmKHQuY2lkU3lzdGVtSW5mbz17cmVnaXN0cnk6c3RyaW5nVG9QREZTdHJpbmcoaS5nZXQoIlJlZ2lzdHJ5IikpLG9yZGVyaW5nOnN0cmluZ1RvUERGU3RyaW5nKGkuZ2V0KCJPcmRlcmluZyIpKSxzdXBwbGVtZW50OmkuZ2V0KCJTdXBwbGVtZW50Iil9KTt0cnl7Y29uc3QgdD1lLmdldCgiQ0lEVG9HSURNYXAiKTt0IGluc3RhbmNlb2YgQmFzZVN0cmVhbSYmKGE9dC5nZXRCeXRlcygpKX1jYXRjaChlKXtpZighdGhpcy5vcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3dhcm4oYGV4dHJhY3REYXRhU3RydWN0dXJlcyAtIGlnbm9yaW5nIENJRFRvR0lETWFwIGRhdGE6ICIke2V9Ii5gKX19Y29uc3Qgcj1bXTtsZXQgbixvPW51bGw7aWYoZS5oYXMoIkVuY29kaW5nIikpe249ZS5nZXQoIkVuY29kaW5nIik7aWYobiBpbnN0YW5jZW9mIERpY3Qpe289bi5nZXQoIkJhc2VFbmNvZGluZyIpO289byBpbnN0YW5jZW9mIE5hbWU/by5uYW1lOm51bGw7aWYobi5oYXMoIkRpZmZlcmVuY2VzIikpe2NvbnN0IGU9bi5nZXQoIkRpZmZlcmVuY2VzIik7bGV0IHQ9MDtmb3IoY29uc3QgYSBvZiBlKXtjb25zdCBlPWkuZmV0Y2hJZlJlZihhKTtpZigibnVtYmVyIj09dHlwZW9mIGUpdD1lO2Vsc2V7aWYoIShlIGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIGVudHJ5IGluICdEaWZmZXJlbmNlcycgYXJyYXk6ICR7ZX1gKTtyW3QrK109ZS5uYW1lfX19fWVsc2UgaWYobiBpbnN0YW5jZW9mIE5hbWUpbz1uLm5hbWU7ZWxzZXtjb25zdCBlPSJFbmNvZGluZyBpcyBub3QgYSBOYW1lIG5vciBhIERpY3QiO2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IG5ldyBGb3JtYXRFcnJvcihlKTt3YXJuKGUpfSJNYWNSb21hbkVuY29kaW5nIiE9PW8mJiJNYWNFeHBlcnRFbmNvZGluZyIhPT1vJiYiV2luQW5zaUVuY29kaW5nIiE9PW8mJihvPW51bGwpfWNvbnN0IGc9IXQuZmlsZXx8dC5pc0ludGVybmFsRm9udCxjPVppKClbdC5uYW1lXTtvJiZnJiZjJiYobz1udWxsKTtpZihvKXQuZGVmYXVsdEVuY29kaW5nPWdldEVuY29kaW5nKG8pO2Vsc2V7Y29uc3QgZT0hISh0LmZsYWdzJlRpKSxpPSEhKHQuZmxhZ3MmcWkpO249Zmk7IlRydWVUeXBlIiE9PXQudHlwZXx8aXx8KG49cGkpO2lmKGV8fGMpe249ZGk7ZyYmKC9TeW1ib2wvaS50ZXN0KHQubmFtZSk/bj1taTovRGluZ2JhdHMvaS50ZXN0KHQubmFtZSk/bj15aTovV2luZ2RpbmdzL2kudGVzdCh0Lm5hbWUpJiYobj1waSkpfXQuZGVmYXVsdEVuY29kaW5nPW59dC5kaWZmZXJlbmNlcz1yO3QuYmFzZUVuY29kaW5nTmFtZT1vO3QuaGFzRW5jb2Rpbmc9ISFvfHxyLmxlbmd0aD4wO3QuZGljdD1lO3QudG9Vbmljb2RlPWF3YWl0IHM7Y29uc3QgQz1hd2FpdCB0aGlzLmJ1aWxkVG9Vbmljb2RlKHQpO3QudG9Vbmljb2RlPUM7YSYmKHQuY2lkVG9HaWRNYXA9dGhpcy5yZWFkQ2lkVG9HaWRNYXAoYSxDKSk7cmV0dXJuIHR9X3NpbXBsZUZvbnRUb1VuaWNvZGUoZSx0PSExKXthc3NlcnQoIWUuY29tcG9zaXRlLCJNdXN0IGJlIGEgc2ltcGxlIGZvbnQuIik7Y29uc3QgaT1bXSxhPWUuZGVmYXVsdEVuY29kaW5nLnNsaWNlKCkscz1lLmJhc2VFbmNvZGluZ05hbWUscj1lLmRpZmZlcmVuY2VzO2Zvcihjb25zdCBlIGluIHIpe2NvbnN0IHQ9cltlXTsiLm5vdGRlZiIhPT10JiYoYVtlXT10KX1jb25zdCBuPVJpKCk7Zm9yKGNvbnN0IHIgaW4gYSl7bGV0IG89YVtyXTtpZigiIj09PW8pY29udGludWU7bGV0IGc9bltvXTtpZih2b2lkIDAhPT1nKXtpW3JdPVN0cmluZy5mcm9tQ2hhckNvZGUoZyk7Y29udGludWV9bGV0IGM9MDtzd2l0Y2gob1swXSl7Y2FzZSJHIjozPT09by5sZW5ndGgmJihjPXBhcnNlSW50KG8uc3Vic3RyaW5nKDEpLDE2KSk7YnJlYWs7Y2FzZSJnIjo1PT09by5sZW5ndGgmJihjPXBhcnNlSW50KG8uc3Vic3RyaW5nKDEpLDE2KSk7YnJlYWs7Y2FzZSJDIjpjYXNlImMiOmlmKG8ubGVuZ3RoPj0zJiZvLmxlbmd0aDw9NCl7Y29uc3QgaT1vLnN1YnN0cmluZygxKTtpZih0KXtjPXBhcnNlSW50KGksMTYpO2JyZWFrfWM9K2k7aWYoTnVtYmVyLmlzTmFOKGMpJiZOdW1iZXIuaXNJbnRlZ2VyKHBhcnNlSW50KGksMTYpKSlyZXR1cm4gdGhpcy5fc2ltcGxlRm9udFRvVW5pY29kZShlLCEwKX1icmVhaztjYXNlInUiOmc9Z2V0VW5pY29kZUZvckdseXBoKG8sbik7LTEhPT1nJiYoYz1nKTticmVhaztkZWZhdWx0OnN3aXRjaChvKXtjYXNlImZfaCI6Y2FzZSJmX3QiOmNhc2UiVF9oIjppW3JdPW8ucmVwbGFjZUFsbCgiXyIsIiIpO2NvbnRpbnVlfX1pZihjPjAmJmM8PTExMTQxMTEmJk51bWJlci5pc0ludGVnZXIoYykpe2lmKHMmJmM9PT0rcil7Y29uc3QgZT1nZXRFbmNvZGluZyhzKTtpZihlJiYobz1lW3JdKSl7aVtyXT1TdHJpbmcuZnJvbUNoYXJDb2RlKG5bb10pO2NvbnRpbnVlfX1pW3JdPVN0cmluZy5mcm9tQ29kZVBvaW50KGMpfX1yZXR1cm4gaX1hc3luYyBidWlsZFRvVW5pY29kZShlKXtlLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwPWUudG9Vbmljb2RlPy5sZW5ndGg+MDtpZihlLmhhc0luY2x1ZGVkVG9Vbmljb2RlTWFwKXshZS5jb21wb3NpdGUmJmUuaGFzRW5jb2RpbmcmJihlLmZhbGxiYWNrVG9Vbmljb2RlPXRoaXMuX3NpbXBsZUZvbnRUb1VuaWNvZGUoZSkpO3JldHVybiBlLnRvVW5pY29kZX1pZighZS5jb21wb3NpdGUpcmV0dXJuIG5ldyBUb1VuaWNvZGVNYXAodGhpcy5fc2ltcGxlRm9udFRvVW5pY29kZShlKSk7aWYoZS5jb21wb3NpdGUmJihlLmNNYXAuYnVpbHRJbkNNYXAmJiEoZS5jTWFwIGluc3RhbmNlb2YgSWRlbnRpdHlDTWFwKXx8IkFkb2JlIj09PWUuY2lkU3lzdGVtSW5mbz8ucmVnaXN0cnkmJigiR0IxIj09PWUuY2lkU3lzdGVtSW5mby5vcmRlcmluZ3x8IkNOUzEiPT09ZS5jaWRTeXN0ZW1JbmZvLm9yZGVyaW5nfHwiSmFwYW4xIj09PWUuY2lkU3lzdGVtSW5mby5vcmRlcmluZ3x8IktvcmVhMSI9PT1lLmNpZFN5c3RlbUluZm8ub3JkZXJpbmcpKSl7Y29uc3R7cmVnaXN0cnk6dCxvcmRlcmluZzppfT1lLmNpZFN5c3RlbUluZm8sYT1OYW1lLmdldChgJHt0fS0ke2l9LVVDUzJgKSxzPWF3YWl0IENNYXBGYWN0b3J5LmNyZWF0ZSh7ZW5jb2Rpbmc6YSxmZXRjaEJ1aWx0SW5DTWFwOnRoaXMuX2ZldGNoQnVpbHRJbkNNYXBCb3VuZCx1c2VDTWFwOm51bGx9KSxyPVtdLG49W107ZS5jTWFwLmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7aWYodD42NTUzNSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk1heCBzaXplIG9mIENJRCBpcyA2NSw1MzUiKTtjb25zdCBpPXMubG9va3VwKHQpO2lmKGkpe24ubGVuZ3RoPTA7Zm9yKGxldCBlPTAsdD1pLmxlbmd0aDtlPHQ7ZSs9MiluLnB1c2goKGkuY2hhckNvZGVBdChlKTw8OCkraS5jaGFyQ29kZUF0KGUrMSkpO3JbZV09U3RyaW5nLmZyb21DaGFyQ29kZSguLi5uKX19KSk7cmV0dXJuIG5ldyBUb1VuaWNvZGVNYXAocil9cmV0dXJuIG5ldyBJZGVudGl0eVRvVW5pY29kZU1hcChlLmZpcnN0Q2hhcixlLmxhc3RDaGFyKX1hc3luYyByZWFkVG9Vbmljb2RlKGUpe2lmKCFlKXJldHVybiBudWxsO2lmKGUgaW5zdGFuY2VvZiBOYW1lKXtjb25zdCB0PWF3YWl0IENNYXBGYWN0b3J5LmNyZWF0ZSh7ZW5jb2Rpbmc6ZSxmZXRjaEJ1aWx0SW5DTWFwOnRoaXMuX2ZldGNoQnVpbHRJbkNNYXBCb3VuZCx1c2VDTWFwOm51bGx9KTtyZXR1cm4gdCBpbnN0YW5jZW9mIElkZW50aXR5Q01hcD9uZXcgSWRlbnRpdHlUb1VuaWNvZGVNYXAoMCw2NTUzNSk6bmV3IFRvVW5pY29kZU1hcCh0LmdldE1hcCgpKX1pZihlIGluc3RhbmNlb2YgQmFzZVN0cmVhbSl0cnl7Y29uc3QgdD1hd2FpdCBDTWFwRmFjdG9yeS5jcmVhdGUoe2VuY29kaW5nOmUsZmV0Y2hCdWlsdEluQ01hcDp0aGlzLl9mZXRjaEJ1aWx0SW5DTWFwQm91bmQsdXNlQ01hcDpudWxsfSk7aWYodCBpbnN0YW5jZW9mIElkZW50aXR5Q01hcClyZXR1cm4gbmV3IElkZW50aXR5VG9Vbmljb2RlTWFwKDAsNjU1MzUpO2NvbnN0IGk9bmV3IEFycmF5KHQubGVuZ3RoKTt0LmZvckVhY2goKGZ1bmN0aW9uKGUsdCl7aWYoIm51bWJlciI9PXR5cGVvZiB0KXtpW2VdPVN0cmluZy5mcm9tQ29kZVBvaW50KHQpO3JldHVybn1jb25zdCBhPVtdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSs9Mil7Y29uc3QgaT10LmNoYXJDb2RlQXQoZSk8PDh8dC5jaGFyQ29kZUF0KGUrMSk7aWYoNTUyOTYhPSg2MzQ4OCZpKSl7YS5wdXNoKGkpO2NvbnRpbnVlfWUrPTI7Y29uc3Qgcz10LmNoYXJDb2RlQXQoZSk8PDh8dC5jaGFyQ29kZUF0KGUrMSk7YS5wdXNoKCgoMTAyMyZpKTw8MTApKygxMDIzJnMpKzY1NTM2KX1pW2VdPVN0cmluZy5mcm9tQ29kZVBvaW50KC4uLmEpfSkpO3JldHVybiBuZXcgVG9Vbmljb2RlTWFwKGkpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBBYm9ydEV4Y2VwdGlvbilyZXR1cm4gbnVsbDtpZih0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXt3YXJuKGByZWFkVG9Vbmljb2RlIC0gaWdub3JpbmcgVG9Vbmljb2RlIGRhdGE6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH10aHJvdyBlfXJldHVybiBudWxsfXJlYWRDaWRUb0dpZE1hcChlLHQpe2NvbnN0IGk9W107Zm9yKGxldCBhPTAscz1lLmxlbmd0aDthPHM7YSsrKXtjb25zdCBzPWVbYSsrXTw8OHxlW2FdLHI9YT4+MTsoMCE9PXN8fHQuaGFzKHIpKSYmKGlbcl09cyl9cmV0dXJuIGl9ZXh0cmFjdFdpZHRocyhlLHQsaSl7Y29uc3QgYT10aGlzLnhyZWY7bGV0IHM9W10scj0wO2NvbnN0IG49W107bGV0IG87aWYoaS5jb21wb3NpdGUpe2NvbnN0IHQ9ZS5nZXQoIkRXIik7cj1OdW1iZXIuaXNJbnRlZ2VyKHQpP3Q6MWUzO2NvbnN0IGc9ZS5nZXQoIlciKTtpZihBcnJheS5pc0FycmF5KGcpKWZvcihsZXQgZT0wLHQ9Zy5sZW5ndGg7ZTx0O2UrKyl7bGV0IHQ9YS5mZXRjaElmUmVmKGdbZSsrXSk7aWYoIU51bWJlci5pc0ludGVnZXIodCkpYnJlYWs7Y29uc3QgaT1hLmZldGNoSWZSZWYoZ1tlXSk7aWYoQXJyYXkuaXNBcnJheShpKSlmb3IoY29uc3QgZSBvZiBpKXtjb25zdCBpPWEuZmV0Y2hJZlJlZihlKTsibnVtYmVyIj09dHlwZW9mIGkmJihzW3RdPWkpO3QrK31lbHNle2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGkpKWJyZWFrO3tjb25zdCByPWEuZmV0Y2hJZlJlZihnWysrZV0pO2lmKCJudW1iZXIiIT10eXBlb2Ygciljb250aW51ZTtmb3IobGV0IGU9dDtlPD1pO2UrKylzW2VdPXJ9fX1pZihpLnZlcnRpY2FsKXtjb25zdCB0PWUuZ2V0QXJyYXkoIkRXMiIpO2xldCBpPWlzTnVtYmVyQXJyYXkodCwyKT90Ols4ODAsLTFlM107bz1baVsxXSwuNSpyLGlbMF1dO2k9ZS5nZXQoIlcyIik7aWYoQXJyYXkuaXNBcnJheShpKSlmb3IobGV0IGU9MCx0PWkubGVuZ3RoO2U8dDtlKyspe2xldCB0PWEuZmV0Y2hJZlJlZihpW2UrK10pO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHQpKWJyZWFrO2NvbnN0IHM9YS5mZXRjaElmUmVmKGlbZV0pO2lmKEFycmF5LmlzQXJyYXkocykpZm9yKGxldCBlPTAsaT1zLmxlbmd0aDtlPGk7ZSsrKXtjb25zdCBpPVthLmZldGNoSWZSZWYoc1tlKytdKSxhLmZldGNoSWZSZWYoc1tlKytdKSxhLmZldGNoSWZSZWYoc1tlXSldO2lzTnVtYmVyQXJyYXkoaSxudWxsKSYmKG5bdF09aSk7dCsrfWVsc2V7aWYoIU51bWJlci5pc0ludGVnZXIocykpYnJlYWs7e2NvbnN0IHI9W2EuZmV0Y2hJZlJlZihpWysrZV0pLGEuZmV0Y2hJZlJlZihpWysrZV0pLGEuZmV0Y2hJZlJlZihpWysrZV0pXTtpZighaXNOdW1iZXJBcnJheShyLG51bGwpKWNvbnRpbnVlO2ZvcihsZXQgZT10O2U8PXM7ZSsrKW5bZV09cn19fX19ZWxzZXtjb25zdCBuPWUuZ2V0KCJXaWR0aHMiKTtpZihBcnJheS5pc0FycmF5KG4pKXtsZXQgZT1pLmZpcnN0Q2hhcjtmb3IoY29uc3QgdCBvZiBuKXtjb25zdCBpPWEuZmV0Y2hJZlJlZih0KTsibnVtYmVyIj09dHlwZW9mIGkmJihzW2VdPWkpO2UrK31jb25zdCBvPXQuZ2V0KCJNaXNzaW5nV2lkdGgiKTtyPSJudW1iZXIiPT10eXBlb2Ygbz9vOjB9ZWxzZXtjb25zdCB0PWUuZ2V0KCJCYXNlRm9udCIpO2lmKHQgaW5zdGFuY2VvZiBOYW1lKXtjb25zdCBlPXRoaXMuZ2V0QmFzZUZvbnRNZXRyaWNzKHQubmFtZSk7cz10aGlzLmJ1aWxkQ2hhckNvZGVUb1dpZHRoKGUud2lkdGhzLGkpO3I9ZS5kZWZhdWx0V2lkdGh9fX1sZXQgZz0hMCxjPXI7Zm9yKGNvbnN0IGUgaW4gcyl7Y29uc3QgdD1zW2VdO2lmKHQpaWYoYyl7aWYoYyE9PXQpe2c9ITE7YnJlYWt9fWVsc2UgYz10fWc/aS5mbGFnc3w9dmk6aS5mbGFncyY9fnZpO2kuZGVmYXVsdFdpZHRoPXI7aS53aWR0aHM9cztpLmRlZmF1bHRWTWV0cmljcz1vO2kudm1ldHJpY3M9bn1pc1NlcmlmRm9udChlKXtjb25zdCB0PWUuc3BsaXQoIi0iLDEpWzBdO3JldHVybiB0IGluIFhpKCl8fC9zZXJpZi9naS50ZXN0KHQpfWdldEJhc2VGb250TWV0cmljcyhlKXtsZXQgdD0wLGk9T2JqZWN0LmNyZWF0ZShudWxsKSxhPSExO2xldCBzPVBpKClbZV18fGU7Y29uc3Qgcj1BYSgpO3MgaW4gcnx8KHM9dGhpcy5pc1NlcmlmRm9udChlKT8iVGltZXMtUm9tYW4iOiJIZWx2ZXRpY2EiKTtjb25zdCBuPXJbc107aWYoIm51bWJlciI9PXR5cGVvZiBuKXt0PW47YT0hMH1lbHNlIGk9bigpO3JldHVybntkZWZhdWx0V2lkdGg6dCxtb25vc3BhY2U6YSx3aWR0aHM6aX19YnVpbGRDaGFyQ29kZVRvV2lkdGgoZSx0KXtjb25zdCBpPU9iamVjdC5jcmVhdGUobnVsbCksYT10LmRpZmZlcmVuY2VzLHM9dC5kZWZhdWx0RW5jb2Rpbmc7Zm9yKGxldCB0PTA7dDwyNTY7dCsrKXQgaW4gYSYmZVthW3RdXT9pW3RdPWVbYVt0XV06dCBpbiBzJiZlW3NbdF1dJiYoaVt0XT1lW3NbdF1dKTtyZXR1cm4gaX1wcmVFdmFsdWF0ZUZvbnQoZSl7Y29uc3QgdD1lO2xldCBpPWUuZ2V0KCJTdWJ0eXBlIik7aWYoIShpIGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJpbnZhbGlkIGZvbnQgU3VidHlwZSIpO2xldCBhLHM9ITE7aWYoIlR5cGUwIj09PWkubmFtZSl7Y29uc3QgdD1lLmdldCgiRGVzY2VuZGFudEZvbnRzIik7aWYoIXQpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJEZXNjZW5kYW50IGZvbnRzIGFyZSBub3Qgc3BlY2lmaWVkIik7aWYoISgoZT1BcnJheS5pc0FycmF5KHQpP3RoaXMueHJlZi5mZXRjaElmUmVmKHRbMF0pOnQpaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkRlc2NlbmRhbnQgZm9udCBpcyBub3QgYSBkaWN0aW9uYXJ5LiIpO2k9ZS5nZXQoIlN1YnR5cGUiKTtpZighKGkgaW5zdGFuY2VvZiBOYW1lKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoImludmFsaWQgZm9udCBTdWJ0eXBlIik7cz0hMH1sZXQgcj1lLmdldCgiRmlyc3RDaGFyIik7TnVtYmVyLmlzSW50ZWdlcihyKXx8KHI9MCk7bGV0IG49ZS5nZXQoIkxhc3RDaGFyIik7TnVtYmVyLmlzSW50ZWdlcihuKXx8KG49cz82NTUzNToyNTUpO2NvbnN0IG89ZS5nZXQoIkZvbnREZXNjcmlwdG9yIiksZz1lLmdldCgiVG9Vbmljb2RlIil8fHQuZ2V0KCJUb1VuaWNvZGUiKTtpZihvKXthPW5ldyBNdXJtdXJIYXNoM182NDtjb25zdCBpPXQuZ2V0UmF3KCJFbmNvZGluZyIpO2lmKGkgaW5zdGFuY2VvZiBOYW1lKWEudXBkYXRlKGkubmFtZSk7ZWxzZSBpZihpIGluc3RhbmNlb2YgUmVmKWEudXBkYXRlKGkudG9TdHJpbmcoKSk7ZWxzZSBpZihpIGluc3RhbmNlb2YgRGljdClmb3IoY29uc3QgZSBvZiBpLmdldFJhd1ZhbHVlcygpKWlmKGUgaW5zdGFuY2VvZiBOYW1lKWEudXBkYXRlKGUubmFtZSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgUmVmKWEudXBkYXRlKGUudG9TdHJpbmcoKSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXtjb25zdCB0PWUubGVuZ3RoLGk9bmV3IEFycmF5KHQpO2ZvcihsZXQgYT0wO2E8dDthKyspe2NvbnN0IHQ9ZVthXTt0IGluc3RhbmNlb2YgTmFtZT9pW2FdPXQubmFtZTooIm51bWJlciI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgUmVmKSYmKGlbYV09dC50b1N0cmluZygpKX1hLnVwZGF0ZShpLmpvaW4oKSl9YS51cGRhdGUoYCR7cn0tJHtufWApO2lmKGcgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKXtjb25zdCBlPWcuc3RyfHxnLHQ9ZS5idWZmZXI/bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIuYnVmZmVyLDAsZS5idWZmZXJMZW5ndGgpOm5ldyBVaW50OEFycmF5KGUuYnl0ZXMuYnVmZmVyLGUuc3RhcnQsZS5lbmQtZS5zdGFydCk7YS51cGRhdGUodCl9ZWxzZSBnIGluc3RhbmNlb2YgTmFtZSYmYS51cGRhdGUoZy5uYW1lKTtjb25zdCBvPWUuZ2V0KCJXaWR0aHMiKXx8dC5nZXQoIldpZHRocyIpO2lmKEFycmF5LmlzQXJyYXkobykpe2NvbnN0IGU9W107Zm9yKGNvbnN0IHQgb2YgbykoIm51bWJlciI9PXR5cGVvZiB0fHx0IGluc3RhbmNlb2YgUmVmKSYmZS5wdXNoKHQudG9TdHJpbmcoKSk7YS51cGRhdGUoZS5qb2luKCkpfWlmKHMpe2EudXBkYXRlKCJjb21wb3NpdGVGb250Iik7Y29uc3QgaT1lLmdldCgiVyIpfHx0LmdldCgiVyIpO2lmKEFycmF5LmlzQXJyYXkoaSkpe2NvbnN0IGU9W107Zm9yKGNvbnN0IHQgb2YgaSlpZigibnVtYmVyIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBSZWYpZS5wdXNoKHQudG9TdHJpbmcoKSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KHQpKXtjb25zdCBpPVtdO2Zvcihjb25zdCBlIG9mIHQpKCJudW1iZXIiPT10eXBlb2YgZXx8ZSBpbnN0YW5jZW9mIFJlZikmJmkucHVzaChlLnRvU3RyaW5nKCkpO2UucHVzaChgWyR7aS5qb2luKCl9XWApfWEudXBkYXRlKGUuam9pbigpKX1jb25zdCBzPWUuZ2V0UmF3KCJDSURUb0dJRE1hcCIpfHx0LmdldFJhdygiQ0lEVG9HSURNYXAiKTtzIGluc3RhbmNlb2YgTmFtZT9hLnVwZGF0ZShzLm5hbWUpOnMgaW5zdGFuY2VvZiBSZWY/YS51cGRhdGUocy50b1N0cmluZygpKTpzIGluc3RhbmNlb2YgQmFzZVN0cmVhbSYmYS51cGRhdGUocy5wZWVrQnl0ZXMoKSl9fXJldHVybntkZXNjcmlwdG9yOm8sZGljdDplLGJhc2VEaWN0OnQsY29tcG9zaXRlOnMsdHlwZTppLm5hbWUsZmlyc3RDaGFyOnIsbGFzdENoYXI6bix0b1VuaWNvZGU6ZyxoYXNoOmE/YS5oZXhkaWdlc3QoKToiIn19YXN5bmMgdHJhbnNsYXRlRm9udCh7ZGVzY3JpcHRvcjplLGRpY3Q6dCxiYXNlRGljdDppLGNvbXBvc2l0ZTpzLHR5cGU6cixmaXJzdENoYXI6bixsYXN0Q2hhcjpvLHRvVW5pY29kZTpnLGNzc0ZvbnRJbmZvOmN9KXtjb25zdCBDPSJUeXBlMyI9PT1yO2lmKCFlKXtpZighQyl7bGV0IGU9dC5nZXQoIkJhc2VGb250Iik7aWYoIShlIGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJCYXNlIGZvbnQgaXMgbm90IHNwZWNpZmllZCIpO2U9ZS5uYW1lLnJlcGxhY2VBbGwoL1ssX10vZywiLSIpO2NvbnN0IGE9dGhpcy5nZXRCYXNlRm9udE1ldHJpY3MoZSkscz1lLnNwbGl0KCItIiwxKVswXSxjPSh0aGlzLmlzU2VyaWZGb250KHMpP0tpOjApfChhLm1vbm9zcGFjZT92aTowKXwoWmkoKVtzXT9UaTpxaSksaD17dHlwZTpyLG5hbWU6ZSxsb2FkZWROYW1lOmkubG9hZGVkTmFtZSxzeXN0ZW1Gb250SW5mbzpudWxsLHdpZHRoczphLndpZHRocyxkZWZhdWx0V2lkdGg6YS5kZWZhdWx0V2lkdGgsaXNTaW11bGF0ZWRGbGFnczohMCxmbGFnczpjLGZpcnN0Q2hhcjpuLGxhc3RDaGFyOm8sdG9Vbmljb2RlOmcseEhlaWdodDowLGNhcEhlaWdodDowLGl0YWxpY0FuZ2xlOjAsaXNUeXBlM0ZvbnQ6Q30sbD10LmdldCgiV2lkdGhzIiksUT1nZXRTdGFuZGFyZEZvbnROYW1lKGUpO2xldCBFPW51bGw7aWYoUSl7RT1hd2FpdCB0aGlzLmZldGNoU3RhbmRhcmRGb250RGF0YShRKTtoLmlzSW50ZXJuYWxGb250PSEhRX0haC5pc0ludGVybmFsRm9udCYmdGhpcy5vcHRpb25zLnVzZVN5c3RlbUZvbnRzJiYoaC5zeXN0ZW1Gb250SW5mbz1nZXRGb250U3Vic3RpdHV0aW9uKHRoaXMuc3lzdGVtRm9udENhY2hlLHRoaXMuaWRGYWN0b3J5LHRoaXMub3B0aW9ucy5zdGFuZGFyZEZvbnREYXRhVXJsLGUsUSxyKSk7Y29uc3QgdT1hd2FpdCB0aGlzLmV4dHJhY3REYXRhU3RydWN0dXJlcyh0LGgpO2lmKGwpe2NvbnN0IGU9W107bGV0IHQ9bjtmb3IoY29uc3QgaSBvZiBsKWVbdCsrXT10aGlzLnhyZWYuZmV0Y2hJZlJlZihpKTt1LndpZHRocz1lfWVsc2UgdS53aWR0aHM9dGhpcy5idWlsZENoYXJDb2RlVG9XaWR0aChhLndpZHRocyx1KTtyZXR1cm4gbmV3IEZvbnQoZSxFLHUpfXtsZXQgaT10LmdldEFycmF5KCJGb250QkJveCIpO2lzTnVtYmVyQXJyYXkoaSw0KXx8KGk9WzAsMCwwLDBdKTsoZT1uZXcgRGljdChudWxsKSkuc2V0KCJGb250TmFtZSIsTmFtZS5nZXQocikpO2Uuc2V0KCJGb250QkJveCIsaSl9fWxldCBoPWUuZ2V0KCJGb250TmFtZSIpLGw9dC5nZXQoIkJhc2VGb250Iik7InN0cmluZyI9PXR5cGVvZiBoJiYoaD1OYW1lLmdldChoKSk7InN0cmluZyI9PXR5cGVvZiBsJiYobD1OYW1lLmdldChsKSk7Y29uc3QgUT1oPy5uYW1lLEU9bD8ubmFtZTtpZighQyYmUSE9PUUpe2luZm8oYFRoZSBGb250RGVzY3JpcHRvcidzIEZvbnROYW1lIGlzICIke1F9IiBidXQgc2hvdWxkIGJlIHRoZSBzYW1lIGFzIHRoZSBGb250J3MgQmFzZUZvbnQgIiR7RX0iLmApO1EmJkUmJihFLnN0YXJ0c1dpdGgoUSl8fCFpc0tub3duRm9udE5hbWUoUSkmJmlzS25vd25Gb250TmFtZShFKSkmJihoPW51bGwpfWh8fD1sO2lmKCEoaCBpbnN0YW5jZW9mIE5hbWUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiaW52YWxpZCBmb250IG5hbWUiKTtsZXQgdSxkLGYscCxtO3RyeXt1PWUuZ2V0KCJGb250RmlsZSIsIkZvbnRGaWxlMiIsIkZvbnRGaWxlMyIpfWNhdGNoKGUpe2lmKCF0aGlzLm9wdGlvbnMuaWdub3JlRXJyb3JzKXRocm93IGU7d2FybihgdHJhbnNsYXRlRm9udCAtIGZldGNoaW5nICIke2gubmFtZX0iIGZvbnQgZmlsZTogIiR7ZX0iLmApO3U9bmV3IE51bGxTdHJlYW19bGV0IHk9ITEsdz1udWxsLGI9bnVsbDtpZih1KXtpZih1LmRpY3Qpe2NvbnN0IGU9dS5kaWN0LmdldCgiU3VidHlwZSIpO2UgaW5zdGFuY2VvZiBOYW1lJiYoZD1lLm5hbWUpO2Y9dS5kaWN0LmdldCgiTGVuZ3RoMSIpO3A9dS5kaWN0LmdldCgiTGVuZ3RoMiIpO209dS5kaWN0LmdldCgiTGVuZ3RoMyIpfX1lbHNlIGlmKGMpe2NvbnN0IGU9Z2V0WGZhRm9udE5hbWUoaC5uYW1lKTtpZihlKXtjLmZvbnRGYW1pbHk9YCR7Yy5mb250RmFtaWx5fS1QZGZKUy1YRkFgO2MubWV0cmljcz1lLm1ldHJpY3N8fG51bGw7dz1lLmZhY3RvcnN8fG51bGw7dT1hd2FpdCB0aGlzLmZldGNoU3RhbmRhcmRGb250RGF0YShlLm5hbWUpO3k9ISF1O2k9dD1nZXRYZmFGb250RGljdChoLm5hbWUpO3M9ITB9fWVsc2UgaWYoIUMpe2NvbnN0IGU9Z2V0U3RhbmRhcmRGb250TmFtZShoLm5hbWUpO2lmKGUpe3U9YXdhaXQgdGhpcy5mZXRjaFN0YW5kYXJkRm9udERhdGEoZSk7eT0hIXV9IXkmJnRoaXMub3B0aW9ucy51c2VTeXN0ZW1Gb250cyYmKGI9Z2V0Rm9udFN1YnN0aXR1dGlvbih0aGlzLnN5c3RlbUZvbnRDYWNoZSx0aGlzLmlkRmFjdG9yeSx0aGlzLm9wdGlvbnMuc3RhbmRhcmRGb250RGF0YVVybCxoLm5hbWUsZSxyKSl9bGV0IEQ9dC5nZXRBcnJheSgiRm9udE1hdHJpeCIpO2lzTnVtYmVyQXJyYXkoRCw2KXx8KEQ9YSk7bGV0IEY9ZS5nZXRBcnJheSgiRm9udEJCb3giKXx8dC5nZXRBcnJheSgiRm9udEJCb3giKTtpc051bWJlckFycmF5KEYsNCl8fChGPXZvaWQgMCk7bGV0IFM9ZS5nZXQoIkFzY2VudCIpOyJudW1iZXIiIT10eXBlb2YgUyYmKFM9dm9pZCAwKTtsZXQgaz1lLmdldCgiRGVzY2VudCIpOyJudW1iZXIiIT10eXBlb2YgayYmKGs9dm9pZCAwKTtsZXQgTj1lLmdldCgiWEhlaWdodCIpOyJudW1iZXIiIT10eXBlb2YgTiYmKE49MCk7bGV0IFI9ZS5nZXQoIkNhcEhlaWdodCIpOyJudW1iZXIiIT10eXBlb2YgUiYmKFI9MCk7bGV0IEc9ZS5nZXQoIkZsYWdzIik7TnVtYmVyLmlzSW50ZWdlcihHKXx8KEc9MCk7bGV0IHg9ZS5nZXQoIkl0YWxpY0FuZ2xlIik7Im51bWJlciIhPXR5cGVvZiB4JiYoeD0wKTtjb25zdCBVPXt0eXBlOnIsbmFtZTpoLm5hbWUsc3VidHlwZTpkLGZpbGU6dSxsZW5ndGgxOmYsbGVuZ3RoMjpwLGxlbmd0aDM6bSxpc0ludGVybmFsRm9udDp5LGxvYWRlZE5hbWU6aS5sb2FkZWROYW1lLGNvbXBvc2l0ZTpzLGZpeGVkUGl0Y2g6ITEsZm9udE1hdHJpeDpELGZpcnN0Q2hhcjpuLGxhc3RDaGFyOm8sdG9Vbmljb2RlOmcsYmJveDpGLGFzY2VudDpTLGRlc2NlbnQ6ayx4SGVpZ2h0Ok4sY2FwSGVpZ2h0OlIsZmxhZ3M6RyxpdGFsaWNBbmdsZTp4LGlzVHlwZTNGb250OkMsY3NzRm9udEluZm86YyxzY2FsZUZhY3RvcnM6dyxzeXN0ZW1Gb250SW5mbzpifTtpZihzKXtjb25zdCBlPWkuZ2V0KCJFbmNvZGluZyIpO2UgaW5zdGFuY2VvZiBOYW1lJiYoVS5jaWRFbmNvZGluZz1lLm5hbWUpO2NvbnN0IHQ9YXdhaXQgQ01hcEZhY3RvcnkuY3JlYXRlKHtlbmNvZGluZzplLGZldGNoQnVpbHRJbkNNYXA6dGhpcy5fZmV0Y2hCdWlsdEluQ01hcEJvdW5kLHVzZUNNYXA6bnVsbH0pO1UuY01hcD10O1UudmVydGljYWw9VS5jTWFwLnZlcnRpY2FsfWNvbnN0IE09YXdhaXQgdGhpcy5leHRyYWN0RGF0YVN0cnVjdHVyZXModCxVKTt0aGlzLmV4dHJhY3RXaWR0aHModCxlLE0pO3JldHVybiBuZXcgRm9udChoLm5hbWUsdSxNKX1zdGF0aWMgYnVpbGRGb250UGF0aHMoZSx0LGksYSl7ZnVuY3Rpb24gYnVpbGRQYXRoKHQpe2NvbnN0IHM9YCR7ZS5sb2FkZWROYW1lfV9wYXRoXyR7dH1gO3RyeXtpZihlLnJlbmRlcmVyLmhhc0J1aWx0UGF0aCh0KSlyZXR1cm47aS5zZW5kKCJjb21tb25vYmoiLFtzLCJGb250UGF0aCIsZS5yZW5kZXJlci5nZXRQYXRoSnModCldKX1jYXRjaChlKXtpZihhLmlnbm9yZUVycm9ycyl7d2FybihgYnVpbGRGb250UGF0aHMgLSBpZ25vcmluZyAke3N9IGdseXBoOiAiJHtlfSIuYCk7cmV0dXJufXRocm93IGV9fWZvcihjb25zdCBlIG9mIHQpe2J1aWxkUGF0aChlLmZvbnRDaGFyKTtjb25zdCB0PWUuYWNjZW50O3Q/LmZvbnRDaGFyJiZidWlsZFBhdGgodC5mb250Q2hhcil9fXN0YXRpYyBnZXQgZmFsbGJhY2tGb250RGljdCgpe2NvbnN0IGU9bmV3IERpY3Q7ZS5zZXQoIkJhc2VGb250IixOYW1lLmdldCgiSGVsdmV0aWNhIikpO2Uuc2V0KCJUeXBlIixOYW1lLmdldCgiRmFsbGJhY2tUeXBlIikpO2Uuc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiRmFsbGJhY2tUeXBlIikpO2Uuc2V0KCJFbmNvZGluZyIsTmFtZS5nZXQoIldpbkFuc2lFbmNvZGluZyIpKTtyZXR1cm4gc2hhZG93KHRoaXMsImZhbGxiYWNrRm9udERpY3QiLGUpfX1jbGFzcyBUcmFuc2xhdGVkRm9udHtjb25zdHJ1Y3Rvcih7bG9hZGVkTmFtZTplLGZvbnQ6dCxkaWN0OmksZXZhbHVhdG9yT3B0aW9uczphfSl7dGhpcy5sb2FkZWROYW1lPWU7dGhpcy5mb250PXQ7dGhpcy5kaWN0PWk7dGhpcy5fZXZhbHVhdG9yT3B0aW9ucz1hfHxEczt0aGlzLnR5cGUzTG9hZGVkPW51bGw7dGhpcy50eXBlM0RlcGVuZGVuY2llcz10LmlzVHlwZTNGb250P25ldyBTZXQ6bnVsbDt0aGlzLnNlbnQ9ITF9c2VuZChlKXtpZighdGhpcy5zZW50KXt0aGlzLnNlbnQ9ITA7ZS5zZW5kKCJjb21tb25vYmoiLFt0aGlzLmxvYWRlZE5hbWUsIkZvbnQiLHRoaXMuZm9udC5leHBvcnREYXRhKHRoaXMuX2V2YWx1YXRvck9wdGlvbnMuZm9udEV4dHJhUHJvcGVydGllcyldKX19ZmFsbGJhY2soZSl7aWYodGhpcy5mb250LmRhdGEpe3RoaXMuZm9udC5kaXNhYmxlRm9udEZhY2U9ITA7UGFydGlhbEV2YWx1YXRvci5idWlsZEZvbnRQYXRocyh0aGlzLmZvbnQsdGhpcy5mb250LmdseXBoQ2FjaGVWYWx1ZXMsZSx0aGlzLl9ldmFsdWF0b3JPcHRpb25zKX19bG9hZFR5cGUzRGF0YShlLHQsaSl7aWYodGhpcy50eXBlM0xvYWRlZClyZXR1cm4gdGhpcy50eXBlM0xvYWRlZDtpZighdGhpcy5mb250LmlzVHlwZTNGb250KXRocm93IG5ldyBFcnJvcigiTXVzdCBiZSBhIFR5cGUzIGZvbnQuIik7Y29uc3QgYT1lLmNsb25lKHtpZ25vcmVFcnJvcnM6ITF9KTthLnBhcnNpbmdUeXBlM0ZvbnQ9ITA7Y29uc3Qgcz1uZXcgUmVmU2V0KGUudHlwZTNGb250UmVmcyk7dGhpcy5kaWN0Lm9iaklkJiYhcy5oYXModGhpcy5kaWN0Lm9iaklkKSYmcy5wdXQodGhpcy5kaWN0Lm9iaklkKTthLnR5cGUzRm9udFJlZnM9cztjb25zdCByPXRoaXMuZm9udCxuPXRoaXMudHlwZTNEZXBlbmRlbmNpZXM7bGV0IG89UHJvbWlzZS5yZXNvbHZlKCk7Y29uc3QgZz10aGlzLmRpY3QuZ2V0KCJDaGFyUHJvY3MiKSxjPXRoaXMuZGljdC5nZXQoIlJlc291cmNlcyIpfHx0LEM9T2JqZWN0LmNyZWF0ZShudWxsKSxoPVV0aWwubm9ybWFsaXplUmVjdChyLmJib3h8fFswLDAsMCwwXSksbD1oWzJdLWhbMF0sUT1oWzNdLWhbMV0sRT1NYXRoLmh5cG90KGwsUSk7Zm9yKGNvbnN0IGUgb2YgZy5nZXRLZXlzKCkpbz1vLnRoZW4oKCgpPT57Y29uc3QgdD1nLmdldChlKSxzPW5ldyBPcGVyYXRvckxpc3Q7cmV0dXJuIGEuZ2V0T3BlcmF0b3JMaXN0KHtzdHJlYW06dCx0YXNrOmkscmVzb3VyY2VzOmMsb3BlcmF0b3JMaXN0OnN9KS50aGVuKCgoKT0+e3MuZm5BcnJheVswXT09PUVlJiZ0aGlzLl9yZW1vdmVUeXBlM0NvbG9yT3BlcmF0b3JzKHMsRSk7Q1tlXT1zLmdldElSKCk7Zm9yKGNvbnN0IGUgb2Ygcy5kZXBlbmRlbmNpZXMpbi5hZGQoZSl9KSkuY2F0Y2goKGZ1bmN0aW9uKHQpe3dhcm4oYFR5cGUzIGZvbnQgcmVzb3VyY2UgIiR7ZX0iIGlzIG5vdCBhdmFpbGFibGUuYCk7Y29uc3QgaT1uZXcgT3BlcmF0b3JMaXN0O0NbZV09aS5nZXRJUigpfSkpfSkpO3RoaXMudHlwZTNMb2FkZWQ9by50aGVuKCgoKT0+e3IuY2hhclByb2NPcGVyYXRvckxpc3Q9QztpZih0aGlzLl9iYm94KXtyLmlzQ2hhckJCb3g9ITA7ci5iYm94PXRoaXMuX2Jib3h9fSkpO3JldHVybiB0aGlzLnR5cGUzTG9hZGVkfV9yZW1vdmVUeXBlM0NvbG9yT3BlcmF0b3JzKGUsdD1OYU4pe2NvbnN0IGk9VXRpbC5ub3JtYWxpemVSZWN0KGUuYXJnc0FycmF5WzBdLnNsaWNlKDIpKSxhPWlbMl0taVswXSxzPWlbM10taVsxXSxyPU1hdGguaHlwb3QoYSxzKTtpZigwPT09YXx8MD09PXMpe2UuZm5BcnJheS5zcGxpY2UoMCwxKTtlLmFyZ3NBcnJheS5zcGxpY2UoMCwxKX1lbHNlIGlmKDA9PT10fHxNYXRoLnJvdW5kKHIvdCk+PTEwKXt0aGlzLl9iYm94fHwodGhpcy5fYmJveD1bMS8wLDEvMCwtMS8wLC0xLzBdKTt0aGlzLl9iYm94WzBdPU1hdGgubWluKHRoaXMuX2Jib3hbMF0saVswXSk7dGhpcy5fYmJveFsxXT1NYXRoLm1pbih0aGlzLl9iYm94WzFdLGlbMV0pO3RoaXMuX2Jib3hbMl09TWF0aC5tYXgodGhpcy5fYmJveFsyXSxpWzJdKTt0aGlzLl9iYm94WzNdPU1hdGgubWF4KHRoaXMuX2Jib3hbM10saVszXSl9bGV0IG49MCxvPWUubGVuZ3RoO2Zvcig7bjxvOyl7c3dpdGNoKGUuZm5BcnJheVtuXSl7Y2FzZSBFZTpicmVhaztjYXNlIHVlOmNhc2UgZGU6Y2FzZSBmZTpjYXNlIHBlOmNhc2UgbWU6Y2FzZSB5ZTpjYXNlIHdlOmNhc2UgYmU6Y2FzZSBEZTpjYXNlIEZlOmNhc2UgU2U6Y2FzZSBrZTpjYXNlIE5lOmNhc2Uga0E6ZS5mbkFycmF5LnNwbGljZShuLDEpO2UuYXJnc0FycmF5LnNwbGljZShuLDEpO28tLTtjb250aW51ZTtjYXNlIFJBOmNvbnN0W3RdPWUuYXJnc0FycmF5W25dO2xldCBpPTAsYT10Lmxlbmd0aDtmb3IoO2k8YTspe2NvbnN0W2VdPXRbaV07c3dpdGNoKGUpe2Nhc2UiVFIiOmNhc2UiVFIyIjpjYXNlIkhUIjpjYXNlIkJHIjpjYXNlIkJHMiI6Y2FzZSJVQ1IiOmNhc2UiVUNSMiI6dC5zcGxpY2UoaSwxKTthLS07Y29udGludWV9aSsrfX1uKyt9fX1jbGFzcyBTdGF0ZU1hbmFnZXJ7Y29uc3RydWN0b3IoZT1uZXcgRXZhbFN0YXRlKXt0aGlzLnN0YXRlPWU7dGhpcy5zdGF0ZVN0YWNrPVtdfXNhdmUoKXtjb25zdCBlPXRoaXMuc3RhdGU7dGhpcy5zdGF0ZVN0YWNrLnB1c2godGhpcy5zdGF0ZSk7dGhpcy5zdGF0ZT1lLmNsb25lKCl9cmVzdG9yZSgpe2NvbnN0IGU9dGhpcy5zdGF0ZVN0YWNrLnBvcCgpO2UmJih0aGlzLnN0YXRlPWUpfXRyYW5zZm9ybShlKXt0aGlzLnN0YXRlLmN0bT1VdGlsLnRyYW5zZm9ybSh0aGlzLnN0YXRlLmN0bSxlKX19Y2xhc3MgVGV4dFN0YXRle2NvbnN0cnVjdG9yKCl7dGhpcy5jdG09bmV3IEZsb2F0MzJBcnJheShpKTt0aGlzLmZvbnROYW1lPW51bGw7dGhpcy5mb250U2l6ZT0wO3RoaXMubG9hZGVkTmFtZT1udWxsO3RoaXMuZm9udD1udWxsO3RoaXMuZm9udE1hdHJpeD1hO3RoaXMudGV4dE1hdHJpeD1pLnNsaWNlKCk7dGhpcy50ZXh0TGluZU1hdHJpeD1pLnNsaWNlKCk7dGhpcy5jaGFyU3BhY2luZz0wO3RoaXMud29yZFNwYWNpbmc9MDt0aGlzLmxlYWRpbmc9MDt0aGlzLnRleHRIU2NhbGU9MTt0aGlzLnRleHRSaXNlPTB9c2V0VGV4dE1hdHJpeChlLHQsaSxhLHMscil7Y29uc3Qgbj10aGlzLnRleHRNYXRyaXg7blswXT1lO25bMV09dDtuWzJdPWk7blszXT1hO25bNF09cztuWzVdPXJ9c2V0VGV4dExpbmVNYXRyaXgoZSx0LGksYSxzLHIpe2NvbnN0IG49dGhpcy50ZXh0TGluZU1hdHJpeDtuWzBdPWU7blsxXT10O25bMl09aTtuWzNdPWE7bls0XT1zO25bNV09cn10cmFuc2xhdGVUZXh0TWF0cml4KGUsdCl7Y29uc3QgaT10aGlzLnRleHRNYXRyaXg7aVs0XT1pWzBdKmUraVsyXSp0K2lbNF07aVs1XT1pWzFdKmUraVszXSp0K2lbNV19dHJhbnNsYXRlVGV4dExpbmVNYXRyaXgoZSx0KXtjb25zdCBpPXRoaXMudGV4dExpbmVNYXRyaXg7aVs0XT1pWzBdKmUraVsyXSp0K2lbNF07aVs1XT1pWzFdKmUraVszXSp0K2lbNV19Y2FycmlhZ2VSZXR1cm4oKXt0aGlzLnRyYW5zbGF0ZVRleHRMaW5lTWF0cml4KDAsLXRoaXMubGVhZGluZyk7dGhpcy50ZXh0TWF0cml4PXRoaXMudGV4dExpbmVNYXRyaXguc2xpY2UoKX1jbG9uZSgpe2NvbnN0IGU9T2JqZWN0LmNyZWF0ZSh0aGlzKTtlLnRleHRNYXRyaXg9dGhpcy50ZXh0TWF0cml4LnNsaWNlKCk7ZS50ZXh0TGluZU1hdHJpeD10aGlzLnRleHRMaW5lTWF0cml4LnNsaWNlKCk7ZS5mb250TWF0cml4PXRoaXMuZm9udE1hdHJpeC5zbGljZSgpO3JldHVybiBlfX1jbGFzcyBFdmFsU3RhdGV7Y29uc3RydWN0b3IoKXt0aGlzLmN0bT1uZXcgRmxvYXQzMkFycmF5KGkpO3RoaXMuZm9udD1udWxsO3RoaXMudGV4dFJlbmRlcmluZ01vZGU9eTt0aGlzLmZpbGxDb2xvclNwYWNlPUNvbG9yU3BhY2Uuc2luZ2xldG9ucy5ncmF5O3RoaXMuc3Ryb2tlQ29sb3JTcGFjZT1Db2xvclNwYWNlLnNpbmdsZXRvbnMuZ3JheX1jbG9uZSgpe3JldHVybiBPYmplY3QuY3JlYXRlKHRoaXMpfX1jbGFzcyBFdmFsdWF0b3JQcmVwcm9jZXNzb3J7c3RhdGljIGdldCBvcE1hcCgpe3JldHVybiBzaGFkb3codGhpcywib3BNYXAiLE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSx7dzp7aWQ6d0EsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sSjp7aWQ6YkEsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sajp7aWQ6REEsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sTTp7aWQ6RkEsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sZDp7aWQ6U0EsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX0scmk6e2lkOmtBLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LGk6e2lkOk5BLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LGdzOntpZDpSQSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxxOntpZDpHQSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxROntpZDp4QSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxjbTp7aWQ6VUEsbnVtQXJnczo2LHZhcmlhYmxlQXJnczohMX0sbTp7aWQ6TUEsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX0sbDp7aWQ6TEEsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX0sYzp7aWQ6SEEsbnVtQXJnczo2LHZhcmlhYmxlQXJnczohMX0sdjp7aWQ6SkEsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX0seTp7aWQ6WUEsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX0saDp7aWQ6dkEsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX0scmU6e2lkOktBLG51bUFyZ3M6NCx2YXJpYWJsZUFyZ3M6ITF9LFM6e2lkOlRBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LHM6e2lkOnFBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LGY6e2lkOk9BLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LEY6e2lkOk9BLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LCJmKiI6e2lkOlBBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LEI6e2lkOldBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LCJCKiI6e2lkOmpBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LGI6e2lkOlhBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LCJiKiI6e2lkOlpBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LG46e2lkOlZBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LFc6e2lkOnpBLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LCJXKiI6e2lkOl9BLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LEJUOntpZDokQSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxFVDp7aWQ6QWUsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX0sVGM6e2lkOmVlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LFR3OntpZDp0ZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxUejp7aWQ6aWUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sVEw6e2lkOmFlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LFRmOntpZDpzZSxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfSxUcjp7aWQ6cmUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sVHM6e2lkOm5lLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LFRkOntpZDpvZSxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfSxURDp7aWQ6Z2UsbnVtQXJnczoyLHZhcmlhYmxlQXJnczohMX0sVG06e2lkOkllLG51bUFyZ3M6Nix2YXJpYWJsZUFyZ3M6ITF9LCJUKiI6e2lkOmNlLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LFRqOntpZDpDZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxUSjp7aWQ6aGUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sIiciOntpZDpsZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSwnIic6e2lkOkJlLG51bUFyZ3M6Myx2YXJpYWJsZUFyZ3M6ITF9LGQwOntpZDpRZSxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfSxkMTp7aWQ6RWUsbnVtQXJnczo2LHZhcmlhYmxlQXJnczohMX0sQ1M6e2lkOnVlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LGNzOntpZDpkZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxTQzp7aWQ6ZmUsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMH0sU0NOOntpZDpwZSxudW1BcmdzOjMzLHZhcmlhYmxlQXJnczohMH0sc2M6e2lkOm1lLG51bUFyZ3M6NCx2YXJpYWJsZUFyZ3M6ITB9LHNjbjp7aWQ6eWUsbnVtQXJnczozMyx2YXJpYWJsZUFyZ3M6ITB9LEc6e2lkOndlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LGc6e2lkOmJlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LFJHOntpZDpEZSxudW1BcmdzOjMsdmFyaWFibGVBcmdzOiExfSxyZzp7aWQ6RmUsbnVtQXJnczozLHZhcmlhYmxlQXJnczohMX0sSzp7aWQ6U2UsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX0sazp7aWQ6a2UsbnVtQXJnczo0LHZhcmlhYmxlQXJnczohMX0sc2g6e2lkOk5lLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LEJJOntpZDpSZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxJRDp7aWQ6R2UsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX0sRUk6e2lkOnhlLG51bUFyZ3M6MSx2YXJpYWJsZUFyZ3M6ITF9LERvOntpZDpVZSxudW1BcmdzOjEsdmFyaWFibGVBcmdzOiExfSxNUDp7aWQ6TWUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sRFA6e2lkOkxlLG51bUFyZ3M6Mix2YXJpYWJsZUFyZ3M6ITF9LEJNQzp7aWQ6SGUsbnVtQXJnczoxLHZhcmlhYmxlQXJnczohMX0sQkRDOntpZDpKZSxudW1BcmdzOjIsdmFyaWFibGVBcmdzOiExfSxFTUM6e2lkOlllLG51bUFyZ3M6MCx2YXJpYWJsZUFyZ3M6ITF9LEJYOntpZDp2ZSxudW1BcmdzOjAsdmFyaWFibGVBcmdzOiExfSxFWDp7aWQ6S2UsbnVtQXJnczowLHZhcmlhYmxlQXJnczohMX0sQk06bnVsbCxCRDpudWxsLHRydWU6bnVsbCxmYTpudWxsLGZhbDpudWxsLGZhbHM6bnVsbCxmYWxzZTpudWxsLG51Om51bGwsbnVsOm51bGwsbnVsbDpudWxsfSkpfXN0YXRpYyBNQVhfSU5WQUxJRF9QQVRIX09QUz0xMDtjb25zdHJ1Y3RvcihlLHQsaT1uZXcgU3RhdGVNYW5hZ2VyKXt0aGlzLnBhcnNlcj1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIoZSxFdmFsdWF0b3JQcmVwcm9jZXNzb3Iub3BNYXApLHhyZWY6dH0pO3RoaXMuc3RhdGVNYW5hZ2VyPWk7dGhpcy5ub25Qcm9jZXNzZWRBcmdzPVtdO3RoaXMuX2lzUGF0aE9wPSExO3RoaXMuX251bUludmFsaWRQYXRoT1BTPTB9Z2V0IHNhdmVkU3RhdGVzRGVwdGgoKXtyZXR1cm4gdGhpcy5zdGF0ZU1hbmFnZXIuc3RhdGVTdGFjay5sZW5ndGh9cmVhZChlKXtsZXQgdD1lLmFyZ3M7Zm9yKDs7KXtjb25zdCBpPXRoaXMucGFyc2VyLmdldE9iaigpO2lmKGkgaW5zdGFuY2VvZiBDbWQpe2NvbnN0IGE9aS5jbWQscz1FdmFsdWF0b3JQcmVwcm9jZXNzb3Iub3BNYXBbYV07aWYoIXMpe3dhcm4oYFVua25vd24gY29tbWFuZCAiJHthfSIuYCk7Y29udGludWV9Y29uc3Qgcj1zLmlkLG49cy5udW1BcmdzO2xldCBvPW51bGwhPT10P3QubGVuZ3RoOjA7dGhpcy5faXNQYXRoT3B8fCh0aGlzLl9udW1JbnZhbGlkUGF0aE9QUz0wKTt0aGlzLl9pc1BhdGhPcD1yPj1NQSYmcjw9VkE7aWYocy52YXJpYWJsZUFyZ3Mpbz5uJiZpbmZvKGBDb21tYW5kICR7YX06IGV4cGVjdGVkIFswLCAke259XSBhcmdzLCBidXQgcmVjZWl2ZWQgJHtvfSBhcmdzLmApO2Vsc2V7aWYobyE9PW4pe2NvbnN0IGU9dGhpcy5ub25Qcm9jZXNzZWRBcmdzO2Zvcig7bz5uOyl7ZS5wdXNoKHQuc2hpZnQoKSk7by0tfWZvcig7bzxuJiYwIT09ZS5sZW5ndGg7KXtudWxsPT09dCYmKHQ9W10pO3QudW5zaGlmdChlLnBvcCgpKTtvKyt9fWlmKG88bil7Y29uc3QgZT1gY29tbWFuZCAke2F9OiBleHBlY3RlZCAke259IGFyZ3MsIGJ1dCByZWNlaXZlZCAke299IGFyZ3MuYDtpZih0aGlzLl9pc1BhdGhPcCYmKyt0aGlzLl9udW1JbnZhbGlkUGF0aE9QUz5FdmFsdWF0b3JQcmVwcm9jZXNzb3IuTUFYX0lOVkFMSURfUEFUSF9PUFMpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkICR7ZX1gKTt3YXJuKGBTa2lwcGluZyAke2V9YCk7bnVsbCE9PXQmJih0Lmxlbmd0aD0wKTtjb250aW51ZX19dGhpcy5wcmVwcm9jZXNzQ29tbWFuZChyLHQpO2UuZm49cjtlLmFyZ3M9dDtyZXR1cm4hMH1pZihpPT09cHQpcmV0dXJuITE7aWYobnVsbCE9PWkpe251bGw9PT10JiYodD1bXSk7dC5wdXNoKGkpO2lmKHQubGVuZ3RoPjMzKXRocm93IG5ldyBGb3JtYXRFcnJvcigiVG9vIG1hbnkgYXJndW1lbnRzIil9fX1wcmVwcm9jZXNzQ29tbWFuZChlLHQpe3N3aXRjaCgwfGUpe2Nhc2UgR0E6dGhpcy5zdGF0ZU1hbmFnZXIuc2F2ZSgpO2JyZWFrO2Nhc2UgeEE6dGhpcy5zdGF0ZU1hbmFnZXIucmVzdG9yZSgpO2JyZWFrO2Nhc2UgVUE6dGhpcy5zdGF0ZU1hbmFnZXIudHJhbnNmb3JtKHQpfX19Y2xhc3MgRGVmYXVsdEFwcGVhcmFuY2VFdmFsdWF0b3IgZXh0ZW5kcyBFdmFsdWF0b3JQcmVwcm9jZXNzb3J7Y29uc3RydWN0b3IoZSl7c3VwZXIobmV3IFN0cmluZ1N0cmVhbShlKSl9cGFyc2UoKXtjb25zdCBlPXtmbjowLGFyZ3M6W119LHQ9e2ZvbnRTaXplOjAsZm9udE5hbWU6IiIsZm9udENvbG9yOm5ldyBVaW50OENsYW1wZWRBcnJheSgzKX07dHJ5e2Zvcig7Oyl7ZS5hcmdzLmxlbmd0aD0wO2lmKCF0aGlzLnJlYWQoZSkpYnJlYWs7aWYoMCE9PXRoaXMuc2F2ZWRTdGF0ZXNEZXB0aCljb250aW51ZTtjb25zdHtmbjppLGFyZ3M6YX09ZTtzd2l0Y2goMHxpKXtjYXNlIHNlOmNvbnN0W2UsaV09YTtlIGluc3RhbmNlb2YgTmFtZSYmKHQuZm9udE5hbWU9ZS5uYW1lKTsibnVtYmVyIj09dHlwZW9mIGkmJmk+MCYmKHQuZm9udFNpemU9aSk7YnJlYWs7Y2FzZSBGZTpDb2xvclNwYWNlLnNpbmdsZXRvbnMucmdiLmdldFJnYkl0ZW0oYSwwLHQuZm9udENvbG9yLDApO2JyZWFrO2Nhc2UgYmU6Q29sb3JTcGFjZS5zaW5nbGV0b25zLmdyYXkuZ2V0UmdiSXRlbShhLDAsdC5mb250Q29sb3IsMCk7YnJlYWs7Y2FzZSBrZTpDb2xvclNwYWNlLnNpbmdsZXRvbnMuY215ay5nZXRSZ2JJdGVtKGEsMCx0LmZvbnRDb2xvciwwKX19fWNhdGNoKGUpe3dhcm4oYHBhcnNlRGVmYXVsdEFwcGVhcmFuY2UgLSBpZ25vcmluZyBlcnJvcnM6ICIke2V9Ii5gKX1yZXR1cm4gdH19ZnVuY3Rpb24gcGFyc2VEZWZhdWx0QXBwZWFyYW5jZShlKXtyZXR1cm4gbmV3IERlZmF1bHRBcHBlYXJhbmNlRXZhbHVhdG9yKGUpLnBhcnNlKCl9Y2xhc3MgQXBwZWFyYW5jZVN0cmVhbUV2YWx1YXRvciBleHRlbmRzIEV2YWx1YXRvclByZXByb2Nlc3Nvcntjb25zdHJ1Y3RvcihlLHQsaSl7c3VwZXIoZSk7dGhpcy5zdHJlYW09ZTt0aGlzLmV2YWx1YXRvck9wdGlvbnM9dDt0aGlzLnhyZWY9aTt0aGlzLnJlc291cmNlcz1lLmRpY3Q/LmdldCgiUmVzb3VyY2VzIil9cGFyc2UoKXtjb25zdCBlPXtmbjowLGFyZ3M6W119O2xldCB0PXtzY2FsZUZhY3RvcjoxLGZvbnRTaXplOjAsZm9udE5hbWU6IiIsZm9udENvbG9yOm5ldyBVaW50OENsYW1wZWRBcnJheSgzKSxmaWxsQ29sb3JTcGFjZTpDb2xvclNwYWNlLnNpbmdsZXRvbnMuZ3JheX0saT0hMTtjb25zdCBhPVtdO3RyeXtmb3IoOzspe2UuYXJncy5sZW5ndGg9MDtpZihpfHwhdGhpcy5yZWFkKGUpKWJyZWFrO2NvbnN0e2ZuOnMsYXJnczpyfT1lO3N3aXRjaCgwfHMpe2Nhc2UgR0E6YS5wdXNoKHtzY2FsZUZhY3Rvcjp0LnNjYWxlRmFjdG9yLGZvbnRTaXplOnQuZm9udFNpemUsZm9udE5hbWU6dC5mb250TmFtZSxmb250Q29sb3I6dC5mb250Q29sb3Iuc2xpY2UoKSxmaWxsQ29sb3JTcGFjZTp0LmZpbGxDb2xvclNwYWNlfSk7YnJlYWs7Y2FzZSB4QTp0PWEucG9wKCl8fHQ7YnJlYWs7Y2FzZSBJZTp0LnNjYWxlRmFjdG9yKj1NYXRoLmh5cG90KHJbMF0sclsxXSk7YnJlYWs7Y2FzZSBzZTpjb25zdFtlLHNdPXI7ZSBpbnN0YW5jZW9mIE5hbWUmJih0LmZvbnROYW1lPWUubmFtZSk7Im51bWJlciI9PXR5cGVvZiBzJiZzPjAmJih0LmZvbnRTaXplPXMqdC5zY2FsZUZhY3Rvcik7YnJlYWs7Y2FzZSBkZTp0LmZpbGxDb2xvclNwYWNlPUNvbG9yU3BhY2UucGFyc2Uoe2NzOnJbMF0seHJlZjp0aGlzLnhyZWYscmVzb3VyY2VzOnRoaXMucmVzb3VyY2VzLHBkZkZ1bmN0aW9uRmFjdG9yeTp0aGlzLl9wZGZGdW5jdGlvbkZhY3RvcnksbG9jYWxDb2xvclNwYWNlQ2FjaGU6dGhpcy5fbG9jYWxDb2xvclNwYWNlQ2FjaGV9KTticmVhaztjYXNlIG1lOnQuZmlsbENvbG9yU3BhY2UuZ2V0UmdiSXRlbShyLDAsdC5mb250Q29sb3IsMCk7YnJlYWs7Y2FzZSBGZTpDb2xvclNwYWNlLnNpbmdsZXRvbnMucmdiLmdldFJnYkl0ZW0ociwwLHQuZm9udENvbG9yLDApO2JyZWFrO2Nhc2UgYmU6Q29sb3JTcGFjZS5zaW5nbGV0b25zLmdyYXkuZ2V0UmdiSXRlbShyLDAsdC5mb250Q29sb3IsMCk7YnJlYWs7Y2FzZSBrZTpDb2xvclNwYWNlLnNpbmdsZXRvbnMuY215ay5nZXRSZ2JJdGVtKHIsMCx0LmZvbnRDb2xvciwwKTticmVhaztjYXNlIENlOmNhc2UgaGU6Y2FzZSBsZTpjYXNlIEJlOmk9ITB9fX1jYXRjaChlKXt3YXJuKGBwYXJzZUFwcGVhcmFuY2VTdHJlYW0gLSBpZ25vcmluZyBlcnJvcnM6ICIke2V9Ii5gKX10aGlzLnN0cmVhbS5yZXNldCgpO2RlbGV0ZSB0LnNjYWxlRmFjdG9yO2RlbGV0ZSB0LmZpbGxDb2xvclNwYWNlO3JldHVybiB0fWdldCBfbG9jYWxDb2xvclNwYWNlQ2FjaGUoKXtyZXR1cm4gc2hhZG93KHRoaXMsIl9sb2NhbENvbG9yU3BhY2VDYWNoZSIsbmV3IExvY2FsQ29sb3JTcGFjZUNhY2hlKX1nZXQgX3BkZkZ1bmN0aW9uRmFjdG9yeSgpe3JldHVybiBzaGFkb3codGhpcywiX3BkZkZ1bmN0aW9uRmFjdG9yeSIsbmV3IFBERkZ1bmN0aW9uRmFjdG9yeSh7eHJlZjp0aGlzLnhyZWYsaXNFdmFsU3VwcG9ydGVkOnRoaXMuZXZhbHVhdG9yT3B0aW9ucy5pc0V2YWxTdXBwb3J0ZWR9KSl9fWZ1bmN0aW9uIGdldFBkZkNvbG9yKGUsdCl7aWYoZVswXT09PWVbMV0mJmVbMV09PT1lWzJdKXtyZXR1cm5gJHtudW1iZXJUb1N0cmluZyhlWzBdLzI1NSl9ICR7dD8iZyI6IkcifWB9cmV0dXJuIEFycmF5LmZyb20oZSwoZT0+bnVtYmVyVG9TdHJpbmcoZS8yNTUpKSkuam9pbigiICIpKyIgIisodD8icmciOiJSRyIpfWNsYXNzIEZha2VVbmljb2RlRm9udHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMueHJlZj1lO3RoaXMud2lkdGhzPW51bGw7dGhpcy5maXJzdENoYXI9MS8wO3RoaXMubGFzdENoYXI9LTEvMDt0aGlzLmZvbnRGYW1pbHk9dDtjb25zdCBpPW5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTt0aGlzLmN0eE1lYXN1cmU9aS5nZXRDb250ZXh0KCIyZCIpO0Zha2VVbmljb2RlRm9udC5fZm9udE5hbWVJZHx8KEZha2VVbmljb2RlRm9udC5fZm9udE5hbWVJZD0xKTt0aGlzLmZvbnROYW1lPU5hbWUuZ2V0KGBJbnZhbGlkUERGanNGb250XyR7dH1fJHtGYWtlVW5pY29kZUZvbnQuX2ZvbnROYW1lSWQrK31gKX1nZXQgZm9udERlc2NyaXB0b3JSZWYoKXtpZighRmFrZVVuaWNvZGVGb250Ll9mb250RGVzY3JpcHRvclJlZil7Y29uc3QgZT1uZXcgRGljdCh0aGlzLnhyZWYpO2Uuc2V0KCJUeXBlIixOYW1lLmdldCgiRm9udERlc2NyaXB0b3IiKSk7ZS5zZXQoIkZvbnROYW1lIix0aGlzLmZvbnROYW1lKTtlLnNldCgiRm9udEZhbWlseSIsIk15cmlhZFBybyBSZWd1bGFyIik7ZS5zZXQoIkZvbnRCQm94IixbMCwwLDAsMF0pO2Uuc2V0KCJGb250U3RyZXRjaCIsTmFtZS5nZXQoIk5vcm1hbCIpKTtlLnNldCgiRm9udFdlaWdodCIsNDAwKTtlLnNldCgiSXRhbGljQW5nbGUiLDApO0Zha2VVbmljb2RlRm9udC5fZm9udERlc2NyaXB0b3JSZWY9dGhpcy54cmVmLmdldE5ld1BlcnNpc3RlbnRSZWYoZSl9cmV0dXJuIEZha2VVbmljb2RlRm9udC5fZm9udERlc2NyaXB0b3JSZWZ9Z2V0IGRlc2NlbmRhbnRGb250UmVmKCl7Y29uc3QgZT1uZXcgRGljdCh0aGlzLnhyZWYpO2Uuc2V0KCJCYXNlRm9udCIsdGhpcy5mb250TmFtZSk7ZS5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJGb250IikpO2Uuc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiQ0lERm9udFR5cGUwIikpO2Uuc2V0KCJDSURUb0dJRE1hcCIsTmFtZS5nZXQoIklkZW50aXR5IikpO2Uuc2V0KCJGaXJzdENoYXIiLHRoaXMuZmlyc3RDaGFyKTtlLnNldCgiTGFzdENoYXIiLHRoaXMubGFzdENoYXIpO2Uuc2V0KCJGb250RGVzY3JpcHRvciIsdGhpcy5mb250RGVzY3JpcHRvclJlZik7ZS5zZXQoIkRXIiwxZTMpO2NvbnN0IHQ9W10saT1bLi4udGhpcy53aWR0aHMuZW50cmllcygpXS5zb3J0KCk7bGV0IGE9bnVsbCxzPW51bGw7Zm9yKGNvbnN0W2Uscl1vZiBpKWlmKGEpaWYoZT09PWErcy5sZW5ndGgpcy5wdXNoKHIpO2Vsc2V7dC5wdXNoKGEscyk7YT1lO3M9W3JdfWVsc2V7YT1lO3M9W3JdfWEmJnQucHVzaChhLHMpO2Uuc2V0KCJXIix0KTtjb25zdCByPW5ldyBEaWN0KHRoaXMueHJlZik7ci5zZXQoIk9yZGVyaW5nIiwiSWRlbnRpdHkiKTtyLnNldCgiUmVnaXN0cnkiLCJBZG9iZSIpO3Iuc2V0KCJTdXBwbGVtZW50IiwwKTtlLnNldCgiQ0lEU3lzdGVtSW5mbyIscik7cmV0dXJuIHRoaXMueHJlZi5nZXROZXdQZXJzaXN0ZW50UmVmKGUpfWdldCBiYXNlRm9udFJlZigpe2NvbnN0IGU9bmV3IERpY3QodGhpcy54cmVmKTtlLnNldCgiQmFzZUZvbnQiLHRoaXMuZm9udE5hbWUpO2Uuc2V0KCJUeXBlIixOYW1lLmdldCgiRm9udCIpKTtlLnNldCgiU3VidHlwZSIsTmFtZS5nZXQoIlR5cGUwIikpO2Uuc2V0KCJFbmNvZGluZyIsTmFtZS5nZXQoIklkZW50aXR5LUgiKSk7ZS5zZXQoIkRlc2NlbmRhbnRGb250cyIsW3RoaXMuZGVzY2VuZGFudEZvbnRSZWZdKTtlLnNldCgiVG9Vbmljb2RlIixOYW1lLmdldCgiSWRlbnRpdHktSCIpKTtyZXR1cm4gdGhpcy54cmVmLmdldE5ld1BlcnNpc3RlbnRSZWYoZSl9Z2V0IHJlc291cmNlcygpe2NvbnN0IGU9bmV3IERpY3QodGhpcy54cmVmKSx0PW5ldyBEaWN0KHRoaXMueHJlZik7dC5zZXQodGhpcy5mb250TmFtZS5uYW1lLHRoaXMuYmFzZUZvbnRSZWYpO2Uuc2V0KCJGb250Iix0KTtyZXR1cm4gZX1fY3JlYXRlQ29udGV4dCgpe3RoaXMud2lkdGhzPW5ldyBNYXA7dGhpcy5jdHhNZWFzdXJlLmZvbnQ9YDEwMDBweCAke3RoaXMuZm9udEZhbWlseX1gO3JldHVybiB0aGlzLmN0eE1lYXN1cmV9Y3JlYXRlRm9udFJlc291cmNlcyhlKXtjb25zdCB0PXRoaXMuX2NyZWF0ZUNvbnRleHQoKTtmb3IoY29uc3QgaSBvZiBlLnNwbGl0KC9cclxuP3xcbi8pKWZvcihjb25zdCBlIG9mIGkuc3BsaXQoIiIpKXtjb25zdCBpPWUuY2hhckNvZGVBdCgwKTtpZih0aGlzLndpZHRocy5oYXMoaSkpY29udGludWU7Y29uc3QgYT10Lm1lYXN1cmVUZXh0KGUpLHM9TWF0aC5jZWlsKGEud2lkdGgpO3RoaXMud2lkdGhzLnNldChpLHMpO3RoaXMuZmlyc3RDaGFyPU1hdGgubWluKGksdGhpcy5maXJzdENoYXIpO3RoaXMubGFzdENoYXI9TWF0aC5tYXgoaSx0aGlzLmxhc3RDaGFyKX1yZXR1cm4gdGhpcy5yZXNvdXJjZXN9c3RhdGljIGdldEZpcnN0UG9zaXRpb25JbmZvKGUsdCxpKXtjb25zdFthLG4sbyxnXT1lO2xldCBjPW8tYSxDPWctbjt0JTE4MCE9MCYmKFtjLENdPVtDLGNdKTtjb25zdCBoPXMqaTtyZXR1cm57Y29vcmRzOlswLEMrcippLWhdLGJib3g6WzAsMCxjLENdLG1hdHJpeDowIT09dD9nZXRSb3RhdGlvbk1hdHJpeCh0LEMsaCk6dm9pZCAwfX1jcmVhdGVBcHBlYXJhbmNlKGUsdCxpLGEsbixvKXtjb25zdCBnPXRoaXMuX2NyZWF0ZUNvbnRleHQoKSxjPVtdO2xldCBDPS0xLzA7Zm9yKGNvbnN0IHQgb2YgZS5zcGxpdCgvXHJcbj98XG4vKSl7Yy5wdXNoKHQpO2NvbnN0IGU9Zy5tZWFzdXJlVGV4dCh0KS53aWR0aDtDPU1hdGgubWF4KEMsZSk7Zm9yKGNvbnN0IGUgb2YgY29kZVBvaW50SXRlcih0KSl7Y29uc3QgdD1TdHJpbmcuZnJvbUNvZGVQb2ludChlKTtsZXQgaT10aGlzLndpZHRocy5nZXQoZSk7aWYodm9pZCAwPT09aSl7Y29uc3QgYT1nLm1lYXN1cmVUZXh0KHQpO2k9TWF0aC5jZWlsKGEud2lkdGgpO3RoaXMud2lkdGhzLnNldChlLGkpO3RoaXMuZmlyc3RDaGFyPU1hdGgubWluKGUsdGhpcy5maXJzdENoYXIpO3RoaXMubGFzdENoYXI9TWF0aC5tYXgoZSx0aGlzLmxhc3RDaGFyKX19fUMqPWEvMWUzO2NvbnN0W2gsbCxRLEVdPXQ7bGV0IHU9US1oLGQ9RS1sO2klMTgwIT0wJiYoW3UsZF09W2QsdV0pO2xldCBmPTE7Qz51JiYoZj11L0MpO2xldCBwPTE7Y29uc3QgbT1zKmEseT1yKmEsdz1tKmMubGVuZ3RoO3c+ZCYmKHA9ZC93KTtjb25zdCBiPWEqTWF0aC5taW4oZixwKSxEPVsicSIsYDAgMCAke251bWJlclRvU3RyaW5nKHUpfSAke251bWJlclRvU3RyaW5nKGQpfSByZSBXIG5gLCJCVCIsYDEgMCAwIDEgMCAke251bWJlclRvU3RyaW5nKGQreSl9IFRtIDAgVGMgJHtnZXRQZGZDb2xvcihuLCEwKX1gLGAvJHt0aGlzLmZvbnROYW1lLm5hbWV9ICR7bnVtYmVyVG9TdHJpbmcoYil9IFRmYF0se3Jlc291cmNlczpGfT10aGlzO2lmKDEhPT0obz0ibnVtYmVyIj09dHlwZW9mIG8mJm8+PTAmJm88PTE/bzoxKSl7RC5wdXNoKCIvUjAgZ3MiKTtjb25zdCBlPW5ldyBEaWN0KHRoaXMueHJlZiksdD1uZXcgRGljdCh0aGlzLnhyZWYpO3Quc2V0KCJjYSIsbyk7dC5zZXQoIkNBIixvKTt0LnNldCgiVHlwZSIsTmFtZS5nZXQoIkV4dEdTdGF0ZSIpKTtlLnNldCgiUjAiLHQpO0Yuc2V0KCJFeHRHU3RhdGUiLGUpfWNvbnN0IFM9bnVtYmVyVG9TdHJpbmcobSk7Zm9yKGNvbnN0IGUgb2YgYylELnB1c2goYDAgLSR7U30gVGQgPCR7c3RyaW5nVG9VVEYxNkhleFN0cmluZyhlKX0+IFRqYCk7RC5wdXNoKCJFVCIsIlEiKTtjb25zdCBrPUQuam9pbigiXG4iKSxOPW5ldyBEaWN0KHRoaXMueHJlZik7Ti5zZXQoIlN1YnR5cGUiLE5hbWUuZ2V0KCJGb3JtIikpO04uc2V0KCJUeXBlIixOYW1lLmdldCgiWE9iamVjdCIpKTtOLnNldCgiQkJveCIsWzAsMCx1LGRdKTtOLnNldCgiTGVuZ3RoIixrLmxlbmd0aCk7Ti5zZXQoIlJlc291cmNlcyIsRik7aWYoaSl7Y29uc3QgZT1nZXRSb3RhdGlvbk1hdHJpeChpLHUsZCk7Ti5zZXQoIk1hdHJpeCIsZSl9Y29uc3QgUj1uZXcgU3RyaW5nU3RyZWFtKGspO1IuZGljdD1OO3JldHVybiBSfX1jbGFzcyBOYW1lT3JOdW1iZXJUcmVle2NvbnN0cnVjdG9yKGUsdCxpKXt0aGlzLmNvbnN0cnVjdG9yPT09TmFtZU9yTnVtYmVyVHJlZSYmdW5yZWFjaGFibGUoIkNhbm5vdCBpbml0aWFsaXplIE5hbWVPck51bWJlclRyZWUuIik7dGhpcy5yb290PWU7dGhpcy54cmVmPXQ7dGhpcy5fdHlwZT1pfWdldEFsbCgpe2NvbnN0IGU9bmV3IE1hcDtpZighdGhpcy5yb290KXJldHVybiBlO2NvbnN0IHQ9dGhpcy54cmVmLGk9bmV3IFJlZlNldDtpLnB1dCh0aGlzLnJvb3QpO2NvbnN0IGE9W3RoaXMucm9vdF07Zm9yKDthLmxlbmd0aD4wOyl7Y29uc3Qgcz10LmZldGNoSWZSZWYoYS5zaGlmdCgpKTtpZighKHMgaW5zdGFuY2VvZiBEaWN0KSljb250aW51ZTtpZihzLmhhcygiS2lkcyIpKXtjb25zdCBlPXMuZ2V0KCJLaWRzIik7aWYoIUFycmF5LmlzQXJyYXkoZSkpY29udGludWU7Zm9yKGNvbnN0IHQgb2YgZSl7aWYoaS5oYXModCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBEdXBsaWNhdGUgZW50cnkgaW4gIiR7dGhpcy5fdHlwZX0iIHRyZWUuYCk7YS5wdXNoKHQpO2kucHV0KHQpfWNvbnRpbnVlfWNvbnN0IHI9cy5nZXQodGhpcy5fdHlwZSk7aWYoQXJyYXkuaXNBcnJheShyKSlmb3IobGV0IGk9MCxhPXIubGVuZ3RoO2k8YTtpKz0yKWUuc2V0KHQuZmV0Y2hJZlJlZihyW2ldKSx0LmZldGNoSWZSZWYocltpKzFdKSl9cmV0dXJuIGV9Z2V0KGUpe2lmKCF0aGlzLnJvb3QpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLnhyZWY7bGV0IGk9dC5mZXRjaElmUmVmKHRoaXMucm9vdCksYT0wO2Zvcig7aS5oYXMoIktpZHMiKTspe2lmKCsrYT4xMCl7d2FybihgU2VhcmNoIGRlcHRoIGxpbWl0IHJlYWNoZWQgZm9yICIke3RoaXMuX3R5cGV9IiB0cmVlLmApO3JldHVybiBudWxsfWNvbnN0IHM9aS5nZXQoIktpZHMiKTtpZighQXJyYXkuaXNBcnJheShzKSlyZXR1cm4gbnVsbDtsZXQgcj0wLG49cy5sZW5ndGgtMTtmb3IoO3I8PW47KXtjb25zdCBhPXIrbj4+MSxvPXQuZmV0Y2hJZlJlZihzW2FdKSxnPW8uZ2V0KCJMaW1pdHMiKTtpZihlPHQuZmV0Y2hJZlJlZihnWzBdKSluPWEtMTtlbHNle2lmKCEoZT50LmZldGNoSWZSZWYoZ1sxXSkpKXtpPW87YnJlYWt9cj1hKzF9fWlmKHI+bilyZXR1cm4gbnVsbH1jb25zdCBzPWkuZ2V0KHRoaXMuX3R5cGUpO2lmKEFycmF5LmlzQXJyYXkocykpe2xldCBpPTAsYT1zLmxlbmd0aC0yO2Zvcig7aTw9YTspe2NvbnN0IHI9aSthPj4xLG49cisoMSZyKSxvPXQuZmV0Y2hJZlJlZihzW25dKTtpZihlPG8pYT1uLTI7ZWxzZXtpZighKGU+bykpcmV0dXJuIHQuZmV0Y2hJZlJlZihzW24rMV0pO2k9bisyfX19cmV0dXJuIG51bGx9fWNsYXNzIE5hbWVUcmVlIGV4dGVuZHMgTmFtZU9yTnVtYmVyVHJlZXtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGUsdCwiTmFtZXMiKX19Y2xhc3MgTnVtYmVyVHJlZSBleHRlbmRzIE5hbWVPck51bWJlclRyZWV7Y29uc3RydWN0b3IoZSx0KXtzdXBlcihlLHQsIk51bXMiKX19ZnVuY3Rpb24gY2xlYXJHbG9iYWxDYWNoZXMoKXshZnVuY3Rpb24gY2xlYXJQYXR0ZXJuQ2FjaGVzKCl7eWE9T2JqZWN0LmNyZWF0ZShudWxsKX0oKTshZnVuY3Rpb24gY2xlYXJQcmltaXRpdmVDYWNoZXMoKXttdD1PYmplY3QuY3JlYXRlKG51bGwpO3l0PU9iamVjdC5jcmVhdGUobnVsbCk7d3Q9T2JqZWN0LmNyZWF0ZShudWxsKX0oKTshZnVuY3Rpb24gY2xlYXJVbmljb2RlQ2FjaGVzKCl7SmkuY2xlYXIoKX0oKTtKcHhJbWFnZS5jbGVhbnVwKCl9ZnVuY3Rpb24gcGlja1BsYXRmb3JtSXRlbShlKXtyZXR1cm4gZS5oYXMoIlVGIik/ZS5nZXQoIlVGIik6ZS5oYXMoIkYiKT9lLmdldCgiRiIpOmUuaGFzKCJVbml4Iik/ZS5nZXQoIlVuaXgiKTplLmhhcygiTWFjIik/ZS5nZXQoIk1hYyIpOmUuaGFzKCJET1MiKT9lLmdldCgiRE9TIik6bnVsbH1jbGFzcyBGaWxlU3BlY3sjdz0hMTtjb25zdHJ1Y3RvcihlLHQsaT0hMSl7aWYoZSBpbnN0YW5jZW9mIERpY3Qpe3RoaXMueHJlZj10O3RoaXMucm9vdD1lO2UuaGFzKCJGUyIpJiYodGhpcy5mcz1lLmdldCgiRlMiKSk7dGhpcy5kZXNjcmlwdGlvbj1lLmhhcygiRGVzYyIpP3N0cmluZ1RvUERGU3RyaW5nKGUuZ2V0KCJEZXNjIikpOiIiO2UuaGFzKCJSRiIpJiZ3YXJuKCJSZWxhdGVkIGZpbGUgc3BlY2lmaWNhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQiKTtpfHwoZS5oYXMoIkVGIik/dGhpcy4jdz0hMDp3YXJuKCJOb24tZW1iZWRkZWQgZmlsZSBzcGVjaWZpY2F0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCIpKX19Z2V0IGZpbGVuYW1lKCl7aWYoIXRoaXMuX2ZpbGVuYW1lJiZ0aGlzLnJvb3Qpe2NvbnN0IGU9cGlja1BsYXRmb3JtSXRlbSh0aGlzLnJvb3QpfHwidW5uYW1lZCI7dGhpcy5fZmlsZW5hbWU9c3RyaW5nVG9QREZTdHJpbmcoZSkucmVwbGFjZUFsbCgiXFxcXCIsIlxcIikucmVwbGFjZUFsbCgiXFwvIiwiLyIpLnJlcGxhY2VBbGwoIlxcIiwiLyIpfXJldHVybiB0aGlzLl9maWxlbmFtZX1nZXQgY29udGVudCgpe2lmKCF0aGlzLiN3KXJldHVybiBudWxsOyF0aGlzLmNvbnRlbnRSZWYmJnRoaXMucm9vdCYmKHRoaXMuY29udGVudFJlZj1waWNrUGxhdGZvcm1JdGVtKHRoaXMucm9vdC5nZXQoIkVGIikpKTtsZXQgZT1udWxsO2lmKHRoaXMuY29udGVudFJlZil7Y29uc3QgdD10aGlzLnhyZWYuZmV0Y2hJZlJlZih0aGlzLmNvbnRlbnRSZWYpO3QgaW5zdGFuY2VvZiBCYXNlU3RyZWFtP2U9dC5nZXRCeXRlcygpOndhcm4oIkVtYmVkZGVkIGZpbGUgc3BlY2lmaWNhdGlvbiBwb2ludHMgdG8gbm9uLWV4aXN0aW5nL2ludmFsaWQgY29udGVudCIpfWVsc2Ugd2FybigiRW1iZWRkZWQgZmlsZSBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGhhdmUgYSBjb250ZW50Iik7cmV0dXJuIGV9Z2V0IHNlcmlhbGl6YWJsZSgpe3JldHVybntmaWxlbmFtZTp0aGlzLmZpbGVuYW1lLGNvbnRlbnQ6dGhpcy5jb250ZW50fX19Y29uc3QgTnM9MCxScz0tMixHcz0tMyx4cz0tNCxVcz0tNSxNcz0tNixMcz0tOTtmdW5jdGlvbiBpc1doaXRlc3BhY2UoZSx0KXtjb25zdCBpPWVbdF07cmV0dXJuIiAiPT09aXx8IlxuIj09PWl8fCJcciI9PT1pfHwiXHQiPT09aX1jbGFzcyBYTUxQYXJzZXJCYXNle19yZXNvbHZlRW50aXRpZXMoZSl7cmV0dXJuIGUucmVwbGFjZUFsbCgvJihbXjtdKyk7L2csKChlLHQpPT57aWYoIiN4Ij09PXQuc3Vic3RyaW5nKDAsMikpcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KHQuc3Vic3RyaW5nKDIpLDE2KSk7aWYoIiMiPT09dC5zdWJzdHJpbmcoMCwxKSlyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQodC5zdWJzdHJpbmcoMSksMTApKTtzd2l0Y2godCl7Y2FzZSJsdCI6cmV0dXJuIjwiO2Nhc2UiZ3QiOnJldHVybiI+IjtjYXNlImFtcCI6cmV0dXJuIiYiO2Nhc2UicXVvdCI6cmV0dXJuJyInO2Nhc2UiYXBvcyI6cmV0dXJuIicifXJldHVybiB0aGlzLm9uUmVzb2x2ZUVudGl0eSh0KX0pKX1fcGFyc2VDb250ZW50KGUsdCl7Y29uc3QgaT1bXTtsZXQgYT10O2Z1bmN0aW9uIHNraXBXcygpe2Zvcig7YTxlLmxlbmd0aCYmaXNXaGl0ZXNwYWNlKGUsYSk7KSsrYX1mb3IoO2E8ZS5sZW5ndGgmJiFpc1doaXRlc3BhY2UoZSxhKSYmIj4iIT09ZVthXSYmIi8iIT09ZVthXTspKythO2NvbnN0IHM9ZS5zdWJzdHJpbmcodCxhKTtza2lwV3MoKTtmb3IoO2E8ZS5sZW5ndGgmJiI+IiE9PWVbYV0mJiIvIiE9PWVbYV0mJiI/IiE9PWVbYV07KXtza2lwV3MoKTtsZXQgdD0iIixzPSIiO2Zvcig7YTxlLmxlbmd0aCYmIWlzV2hpdGVzcGFjZShlLGEpJiYiPSIhPT1lW2FdOyl7dCs9ZVthXTsrK2F9c2tpcFdzKCk7aWYoIj0iIT09ZVthXSlyZXR1cm4gbnVsbDsrK2E7c2tpcFdzKCk7Y29uc3Qgcj1lW2FdO2lmKCciJyE9PXImJiInIiE9PXIpcmV0dXJuIG51bGw7Y29uc3Qgbj1lLmluZGV4T2YociwrK2EpO2lmKG48MClyZXR1cm4gbnVsbDtzPWUuc3Vic3RyaW5nKGEsbik7aS5wdXNoKHtuYW1lOnQsdmFsdWU6dGhpcy5fcmVzb2x2ZUVudGl0aWVzKHMpfSk7YT1uKzE7c2tpcFdzKCl9cmV0dXJue25hbWU6cyxhdHRyaWJ1dGVzOmkscGFyc2VkOmEtdH19X3BhcnNlUHJvY2Vzc2luZ0luc3RydWN0aW9uKGUsdCl7bGV0IGk9dDtmb3IoO2k8ZS5sZW5ndGgmJiFpc1doaXRlc3BhY2UoZSxpKSYmIj4iIT09ZVtpXSYmIj8iIT09ZVtpXSYmIi8iIT09ZVtpXTspKytpO2NvbnN0IGE9ZS5zdWJzdHJpbmcodCxpKTshZnVuY3Rpb24gc2tpcFdzKCl7Zm9yKDtpPGUubGVuZ3RoJiZpc1doaXRlc3BhY2UoZSxpKTspKytpfSgpO2NvbnN0IHM9aTtmb3IoO2k8ZS5sZW5ndGgmJigiPyIhPT1lW2ldfHwiPiIhPT1lW2krMV0pOykrK2k7cmV0dXJue25hbWU6YSx2YWx1ZTplLnN1YnN0cmluZyhzLGkpLHBhcnNlZDppLXR9fXBhcnNlWG1sKGUpe2xldCB0PTA7Zm9yKDt0PGUubGVuZ3RoOyl7bGV0IGk9dDtpZigiPCI9PT1lW3RdKXsrK2k7bGV0IHQ7c3dpdGNoKGVbaV0pe2Nhc2UiLyI6KytpO3Q9ZS5pbmRleE9mKCI+IixpKTtpZih0PDApe3RoaXMub25FcnJvcihMcyk7cmV0dXJufXRoaXMub25FbmRFbGVtZW50KGUuc3Vic3RyaW5nKGksdCkpO2k9dCsxO2JyZWFrO2Nhc2UiPyI6KytpO2NvbnN0IGE9dGhpcy5fcGFyc2VQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oZSxpKTtpZigiPz4iIT09ZS5zdWJzdHJpbmcoaSthLnBhcnNlZCxpK2EucGFyc2VkKzIpKXt0aGlzLm9uRXJyb3IoR3MpO3JldHVybn10aGlzLm9uUGkoYS5uYW1lLGEudmFsdWUpO2krPWEucGFyc2VkKzI7YnJlYWs7Y2FzZSIhIjppZigiLS0iPT09ZS5zdWJzdHJpbmcoaSsxLGkrMykpe3Q9ZS5pbmRleE9mKCItLVx4M2UiLGkrMyk7aWYodDwwKXt0aGlzLm9uRXJyb3IoVXMpO3JldHVybn10aGlzLm9uQ29tbWVudChlLnN1YnN0cmluZyhpKzMsdCkpO2k9dCszfWVsc2UgaWYoIltDREFUQVsiPT09ZS5zdWJzdHJpbmcoaSsxLGkrOCkpe3Q9ZS5pbmRleE9mKCJdXT4iLGkrOCk7aWYodDwwKXt0aGlzLm9uRXJyb3IoUnMpO3JldHVybn10aGlzLm9uQ2RhdGEoZS5zdWJzdHJpbmcoaSs4LHQpKTtpPXQrM31lbHNle2lmKCJET0NUWVBFIiE9PWUuc3Vic3RyaW5nKGkrMSxpKzgpKXt0aGlzLm9uRXJyb3IoTXMpO3JldHVybn17Y29uc3QgYT1lLmluZGV4T2YoIlsiLGkrOCk7bGV0IHM9ITE7dD1lLmluZGV4T2YoIj4iLGkrOCk7aWYodDwwKXt0aGlzLm9uRXJyb3IoeHMpO3JldHVybn1pZihhPjAmJnQ+YSl7dD1lLmluZGV4T2YoIl0+IixpKzgpO2lmKHQ8MCl7dGhpcy5vbkVycm9yKHhzKTtyZXR1cm59cz0hMH1jb25zdCByPWUuc3Vic3RyaW5nKGkrOCx0KyhzPzE6MCkpO3RoaXMub25Eb2N0eXBlKHIpO2k9dCsocz8yOjEpfX1icmVhaztkZWZhdWx0OmNvbnN0IHM9dGhpcy5fcGFyc2VDb250ZW50KGUsaSk7aWYobnVsbD09PXMpe3RoaXMub25FcnJvcihNcyk7cmV0dXJufWxldCByPSExO2lmKCIvPiI9PT1lLnN1YnN0cmluZyhpK3MucGFyc2VkLGkrcy5wYXJzZWQrMikpcj0hMDtlbHNlIGlmKCI+IiE9PWUuc3Vic3RyaW5nKGkrcy5wYXJzZWQsaStzLnBhcnNlZCsxKSl7dGhpcy5vbkVycm9yKExzKTtyZXR1cm59dGhpcy5vbkJlZ2luRWxlbWVudChzLm5hbWUscy5hdHRyaWJ1dGVzLHIpO2krPXMucGFyc2VkKyhyPzI6MSl9fWVsc2V7Zm9yKDtpPGUubGVuZ3RoJiYiPCIhPT1lW2ldOylpKys7Y29uc3QgYT1lLnN1YnN0cmluZyh0LGkpO3RoaXMub25UZXh0KHRoaXMuX3Jlc29sdmVFbnRpdGllcyhhKSl9dD1pfX1vblJlc29sdmVFbnRpdHkoZSl7cmV0dXJuYCYke2V9O2B9b25QaShlLHQpe31vbkNvbW1lbnQoZSl7fW9uQ2RhdGEoZSl7fW9uRG9jdHlwZShlKXt9b25UZXh0KGUpe31vbkJlZ2luRWxlbWVudChlLHQsaSl7fW9uRW5kRWxlbWVudChlKXt9b25FcnJvcihlKXt9fWNsYXNzIFNpbXBsZURPTU5vZGV7Y29uc3RydWN0b3IoZSx0KXt0aGlzLm5vZGVOYW1lPWU7dGhpcy5ub2RlVmFsdWU9dDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFyZW50Tm9kZSIse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KX1nZXQgZmlyc3RDaGlsZCgpe3JldHVybiB0aGlzLmNoaWxkTm9kZXM/LlswXX1nZXQgbmV4dFNpYmxpbmcoKXtjb25zdCBlPXRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO2lmKCFlKXJldHVybjtjb25zdCB0PWUuaW5kZXhPZih0aGlzKTtyZXR1cm4tMSE9PXQ/ZVt0KzFdOnZvaWQgMH1nZXQgdGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5jaGlsZE5vZGVzP3RoaXMuY2hpbGROb2Rlcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRleHRDb250ZW50fSkpLmpvaW4oIiIpOnRoaXMubm9kZVZhbHVlfHwiIn1nZXQgY2hpbGRyZW4oKXtyZXR1cm4gdGhpcy5jaGlsZE5vZGVzfHxbXX1oYXNDaGlsZE5vZGVzKCl7cmV0dXJuIHRoaXMuY2hpbGROb2Rlcz8ubGVuZ3RoPjB9c2VhcmNoTm9kZShlLHQpe2lmKHQ+PWUubGVuZ3RoKXJldHVybiB0aGlzO2NvbnN0IGk9ZVt0XTtpZihpLm5hbWUuc3RhcnRzV2l0aCgiIyIpJiZ0PGUubGVuZ3RoLTEpcmV0dXJuIHRoaXMuc2VhcmNoTm9kZShlLHQrMSk7Y29uc3QgYT1bXTtsZXQgcz10aGlzO2Zvcig7Oyl7aWYoaS5uYW1lPT09cy5ub2RlTmFtZSl7aWYoMCE9PWkucG9zKXtpZigwPT09YS5sZW5ndGgpcmV0dXJuIG51bGw7e2NvbnN0W3JdPWEucG9wKCk7bGV0IG49MDtmb3IoY29uc3QgYSBvZiByLmNoaWxkTm9kZXMpaWYoaS5uYW1lPT09YS5ub2RlTmFtZSl7aWYobj09PWkucG9zKXJldHVybiBhLnNlYXJjaE5vZGUoZSx0KzEpO24rK31yZXR1cm4gcy5zZWFyY2hOb2RlKGUsdCsxKX19e2NvbnN0IGk9cy5zZWFyY2hOb2RlKGUsdCsxKTtpZihudWxsIT09aSlyZXR1cm4gaX19aWYocy5jaGlsZE5vZGVzPy5sZW5ndGg+MCl7YS5wdXNoKFtzLDBdKTtzPXMuY2hpbGROb2Rlc1swXX1lbHNle2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IoOzAhPT1hLmxlbmd0aDspe2NvbnN0W2UsdF09YS5wb3AoKSxpPXQrMTtpZihpPGUuY2hpbGROb2Rlcy5sZW5ndGgpe2EucHVzaChbZSxpXSk7cz1lLmNoaWxkTm9kZXNbaV07YnJlYWt9fWlmKDA9PT1hLmxlbmd0aClyZXR1cm4gbnVsbH19fWR1bXAoZSl7aWYoIiN0ZXh0IiE9PXRoaXMubm9kZU5hbWUpe2UucHVzaChgPCR7dGhpcy5ub2RlTmFtZX1gKTtpZih0aGlzLmF0dHJpYnV0ZXMpZm9yKGNvbnN0IHQgb2YgdGhpcy5hdHRyaWJ1dGVzKWUucHVzaChgICR7dC5uYW1lfT0iJHtlbmNvZGVUb1htbFN0cmluZyh0LnZhbHVlKX0iYCk7aWYodGhpcy5oYXNDaGlsZE5vZGVzKCkpe2UucHVzaCgiPiIpO2Zvcihjb25zdCB0IG9mIHRoaXMuY2hpbGROb2Rlcyl0LmR1bXAoZSk7ZS5wdXNoKGA8LyR7dGhpcy5ub2RlTmFtZX0+YCl9ZWxzZSB0aGlzLm5vZGVWYWx1ZT9lLnB1c2goYD4ke2VuY29kZVRvWG1sU3RyaW5nKHRoaXMubm9kZVZhbHVlKX08LyR7dGhpcy5ub2RlTmFtZX0+YCk6ZS5wdXNoKCIvPiIpfWVsc2UgZS5wdXNoKGVuY29kZVRvWG1sU3RyaW5nKHRoaXMubm9kZVZhbHVlKSl9fWNsYXNzIFNpbXBsZVhNTFBhcnNlciBleHRlbmRzIFhNTFBhcnNlckJhc2V7Y29uc3RydWN0b3Ioe2hhc0F0dHJpYnV0ZXM6ZT0hMSxsb3dlckNhc2VOYW1lOnQ9ITF9KXtzdXBlcigpO3RoaXMuX2N1cnJlbnRGcmFnbWVudD1udWxsO3RoaXMuX3N0YWNrPW51bGw7dGhpcy5fZXJyb3JDb2RlPU5zO3RoaXMuX2hhc0F0dHJpYnV0ZXM9ZTt0aGlzLl9sb3dlckNhc2VOYW1lPXR9cGFyc2VGcm9tU3RyaW5nKGUpe3RoaXMuX2N1cnJlbnRGcmFnbWVudD1bXTt0aGlzLl9zdGFjaz1bXTt0aGlzLl9lcnJvckNvZGU9TnM7dGhpcy5wYXJzZVhtbChlKTtpZih0aGlzLl9lcnJvckNvZGUhPT1OcylyZXR1cm47Y29uc3RbdF09dGhpcy5fY3VycmVudEZyYWdtZW50O3JldHVybiB0P3tkb2N1bWVudEVsZW1lbnQ6dH06dm9pZCAwfW9uVGV4dChlKXtpZihmdW5jdGlvbiBpc1doaXRlc3BhY2VTdHJpbmcoZSl7Zm9yKGxldCB0PTAsaT1lLmxlbmd0aDt0PGk7dCsrKWlmKCFpc1doaXRlc3BhY2UoZSx0KSlyZXR1cm4hMTtyZXR1cm4hMH0oZSkpcmV0dXJuO2NvbnN0IHQ9bmV3IFNpbXBsZURPTU5vZGUoIiN0ZXh0IixlKTt0aGlzLl9jdXJyZW50RnJhZ21lbnQucHVzaCh0KX1vbkNkYXRhKGUpe2NvbnN0IHQ9bmV3IFNpbXBsZURPTU5vZGUoIiN0ZXh0IixlKTt0aGlzLl9jdXJyZW50RnJhZ21lbnQucHVzaCh0KX1vbkJlZ2luRWxlbWVudChlLHQsaSl7dGhpcy5fbG93ZXJDYXNlTmFtZSYmKGU9ZS50b0xvd2VyQ2FzZSgpKTtjb25zdCBhPW5ldyBTaW1wbGVET01Ob2RlKGUpO2EuY2hpbGROb2Rlcz1bXTt0aGlzLl9oYXNBdHRyaWJ1dGVzJiYoYS5hdHRyaWJ1dGVzPXQpO3RoaXMuX2N1cnJlbnRGcmFnbWVudC5wdXNoKGEpO2lmKCFpKXt0aGlzLl9zdGFjay5wdXNoKHRoaXMuX2N1cnJlbnRGcmFnbWVudCk7dGhpcy5fY3VycmVudEZyYWdtZW50PWEuY2hpbGROb2Rlc319b25FbmRFbGVtZW50KGUpe3RoaXMuX2N1cnJlbnRGcmFnbWVudD10aGlzLl9zdGFjay5wb3AoKXx8W107Y29uc3QgdD10aGlzLl9jdXJyZW50RnJhZ21lbnQuYXQoLTEpO2lmKCF0KXJldHVybiBudWxsO2Zvcihjb25zdCBlIG9mIHQuY2hpbGROb2RlcyllLnBhcmVudE5vZGU9dDtyZXR1cm4gdH1vbkVycm9yKGUpe3RoaXMuX2Vycm9yQ29kZT1lfX1jbGFzcyBNZXRhZGF0YVBhcnNlcntjb25zdHJ1Y3RvcihlKXtlPXRoaXMuX3JlcGFpcihlKTtjb25zdCB0PW5ldyBTaW1wbGVYTUxQYXJzZXIoe2xvd2VyQ2FzZU5hbWU6ITB9KS5wYXJzZUZyb21TdHJpbmcoZSk7dGhpcy5fbWV0YWRhdGFNYXA9bmV3IE1hcDt0aGlzLl9kYXRhPWU7dCYmdGhpcy5fcGFyc2UodCl9X3JlcGFpcihlKXtyZXR1cm4gZS5yZXBsYWNlKC9eW148XSsvLCIiKS5yZXBsYWNlQWxsKC8+XFwzNzZcXDM3NyhbXjxdKykvZywoZnVuY3Rpb24oZSx0KXtjb25zdCBpPXQucmVwbGFjZUFsbCgvXFwoWzAtM10pKFswLTddKShbMC03XSkvZywoZnVuY3Rpb24oZSx0LGksYSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjQqdCs4KmkrMSphKX0pKS5yZXBsYWNlQWxsKC8mKGFtcHxhcG9zfGd0fGx0fHF1b3QpOy9nLChmdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlImFtcCI6cmV0dXJuIiYiO2Nhc2UiYXBvcyI6cmV0dXJuIiciO2Nhc2UiZ3QiOnJldHVybiI+IjtjYXNlImx0IjpyZXR1cm4iPCI7Y2FzZSJxdW90IjpyZXR1cm4nIid9dGhyb3cgbmV3IEVycm9yKGBfcmVwYWlyOiAke3R9IGlzbid0IGRlZmluZWQuYCl9KSksYT1bIj4iXTtmb3IobGV0IGU9MCx0PWkubGVuZ3RoO2U8dDtlKz0yKXtjb25zdCB0PTI1NippLmNoYXJDb2RlQXQoZSkraS5jaGFyQ29kZUF0KGUrMSk7dD49MzImJnQ8MTI3JiY2MCE9PXQmJjYyIT09dCYmMzghPT10P2EucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHQpKTphLnB1c2goIiYjeCIrKDY1NTM2K3QpLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSkrIjsiKX1yZXR1cm4gYS5qb2luKCIiKX0pKX1fZ2V0U2VxdWVuY2UoZSl7Y29uc3QgdD1lLm5vZGVOYW1lO3JldHVybiJyZGY6YmFnIiE9PXQmJiJyZGY6c2VxIiE9PXQmJiJyZGY6YWx0IiE9PXQ/bnVsbDplLmNoaWxkTm9kZXMuZmlsdGVyKChlPT4icmRmOmxpIj09PWUubm9kZU5hbWUpKX1fcGFyc2VBcnJheShlKXtpZighZS5oYXNDaGlsZE5vZGVzKCkpcmV0dXJuO2NvbnN0W3RdPWUuY2hpbGROb2RlcyxpPXRoaXMuX2dldFNlcXVlbmNlKHQpfHxbXTt0aGlzLl9tZXRhZGF0YU1hcC5zZXQoZS5ub2RlTmFtZSxpLm1hcCgoZT0+ZS50ZXh0Q29udGVudC50cmltKCkpKSl9X3BhcnNlKGUpe2xldCB0PWUuZG9jdW1lbnRFbGVtZW50O2lmKCJyZGY6cmRmIiE9PXQubm9kZU5hbWUpe3Q9dC5maXJzdENoaWxkO2Zvcig7dCYmInJkZjpyZGYiIT09dC5ub2RlTmFtZTspdD10Lm5leHRTaWJsaW5nfWlmKHQmJiJyZGY6cmRmIj09PXQubm9kZU5hbWUmJnQuaGFzQ2hpbGROb2RlcygpKWZvcihjb25zdCBlIG9mIHQuY2hpbGROb2RlcylpZigicmRmOmRlc2NyaXB0aW9uIj09PWUubm9kZU5hbWUpZm9yKGNvbnN0IHQgb2YgZS5jaGlsZE5vZGVzKXtjb25zdCBlPXQubm9kZU5hbWU7c3dpdGNoKGUpe2Nhc2UiI3RleHQiOmNvbnRpbnVlO2Nhc2UiZGM6Y3JlYXRvciI6Y2FzZSJkYzpzdWJqZWN0Ijp0aGlzLl9wYXJzZUFycmF5KHQpO2NvbnRpbnVlfXRoaXMuX21ldGFkYXRhTWFwLnNldChlLHQudGV4dENvbnRlbnQudHJpbSgpKX19Z2V0IHNlcmlhbGl6YWJsZSgpe3JldHVybntwYXJzZWREYXRhOnRoaXMuX21ldGFkYXRhTWFwLHJhd0RhdGE6dGhpcy5fZGF0YX19fWNsYXNzIERlY3J5cHRTdHJlYW0gZXh0ZW5kcyBEZWNvZGVTdHJlYW17Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKHQpO3RoaXMuc3RyPWU7dGhpcy5kaWN0PWUuZGljdDt0aGlzLmRlY3J5cHQ9aTt0aGlzLm5leHRDaHVuaz1udWxsO3RoaXMuaW5pdGlhbGl6ZWQ9ITF9cmVhZEJsb2NrKCl7bGV0IGU7aWYodGhpcy5pbml0aWFsaXplZCllPXRoaXMubmV4dENodW5rO2Vsc2V7ZT10aGlzLnN0ci5nZXRCeXRlcyg1MTIpO3RoaXMuaW5pdGlhbGl6ZWQ9ITB9aWYoIWV8fDA9PT1lLmxlbmd0aCl7dGhpcy5lb2Y9ITA7cmV0dXJufXRoaXMubmV4dENodW5rPXRoaXMuc3RyLmdldEJ5dGVzKDUxMik7Y29uc3QgdD10aGlzLm5leHRDaHVuaz8ubGVuZ3RoPjA7ZT0oMCx0aGlzLmRlY3J5cHQpKGUsIXQpO2NvbnN0IGk9dGhpcy5idWZmZXJMZW5ndGgsYT1pK2UubGVuZ3RoO3RoaXMuZW5zdXJlQnVmZmVyKGEpLnNldChlLGkpO3RoaXMuYnVmZmVyTGVuZ3RoPWF9fWNsYXNzIEFSQ0ZvdXJDaXBoZXJ7Y29uc3RydWN0b3IoZSl7dGhpcy5hPTA7dGhpcy5iPTA7Y29uc3QgdD1uZXcgVWludDhBcnJheSgyNTYpLGk9ZS5sZW5ndGg7Zm9yKGxldCBlPTA7ZTwyNTY7KytlKXRbZV09ZTtmb3IobGV0IGE9MCxzPTA7YTwyNTY7KythKXtjb25zdCByPXRbYV07cz1zK3IrZVthJWldJjI1NTt0W2FdPXRbc107dFtzXT1yfXRoaXMucz10fWVuY3J5cHRCbG9jayhlKXtsZXQgdD10aGlzLmEsaT10aGlzLmI7Y29uc3QgYT10aGlzLnMscz1lLmxlbmd0aCxyPW5ldyBVaW50OEFycmF5KHMpO2ZvcihsZXQgbj0wO248czsrK24pe3Q9dCsxJjI1NTtjb25zdCBzPWFbdF07aT1pK3MmMjU1O2NvbnN0IG89YVtpXTthW3RdPW87YVtpXT1zO3Jbbl09ZVtuXV5hW3MrbyYyNTVdfXRoaXMuYT10O3RoaXMuYj1pO3JldHVybiByfWRlY3J5cHRCbG9jayhlKXtyZXR1cm4gdGhpcy5lbmNyeXB0QmxvY2soZSl9ZW5jcnlwdChlKXtyZXR1cm4gdGhpcy5lbmNyeXB0QmxvY2soZSl9fWNvbnN0IEhzPWZ1bmN0aW9uIGNhbGN1bGF0ZU1ENUNsb3N1cmUoKXtjb25zdCBlPW5ldyBVaW50OEFycmF5KFs3LDEyLDE3LDIyLDcsMTIsMTcsMjIsNywxMiwxNywyMiw3LDEyLDE3LDIyLDUsOSwxNCwyMCw1LDksMTQsMjAsNSw5LDE0LDIwLDUsOSwxNCwyMCw0LDExLDE2LDIzLDQsMTEsMTYsMjMsNCwxMSwxNiwyMyw0LDExLDE2LDIzLDYsMTAsMTUsMjEsNiwxMCwxNSwyMSw2LDEwLDE1LDIxLDYsMTAsMTUsMjFdKSx0PW5ldyBJbnQzMkFycmF5KFstNjgwODc2OTM2LC0zODk1NjQ1ODYsNjA2MTA1ODE5LC0xMDQ0NTI1MzMwLC0xNzY0MTg4OTcsMTIwMDA4MDQyNiwtMTQ3MzIzMTM0MSwtNDU3MDU5ODMsMTc3MDAzNTQxNiwtMTk1ODQxNDQxNywtNDIwNjMsLTE5OTA0MDQxNjIsMTgwNDYwMzY4MiwtNDAzNDExMDEsLTE1MDIwMDIyOTAsMTIzNjUzNTMyOSwtMTY1Nzk2NTEwLC0xMDY5NTAxNjMyLDY0MzcxNzcxMywtMzczODk3MzAyLC03MDE1NTg2OTEsMzgwMTYwODMsLTY2MDQ3ODMzNSwtNDA1NTM3ODQ4LDU2ODQ0NjQzOCwtMTAxOTgwMzY5MCwtMTg3MzYzOTYxLDExNjM1MzE1MDEsLTE0NDQ2ODE0NjcsLTUxNDAzNzg0LDE3MzUzMjg0NzMsLTE5MjY2MDc3MzQsLTM3ODU1OCwtMjAyMjU3NDQ2MywxODM5MDMwNTYyLC0zNTMwOTU1NiwtMTUzMDk5MjA2MCwxMjcyODkzMzUzLC0xNTU0OTc2MzIsLTEwOTQ3MzA2NDAsNjgxMjc5MTc0LC0zNTg1MzcyMjIsLTcyMjUyMTk3OSw3NjAyOTE4OSwtNjQwMzY0NDg3LC00MjE4MTU4MzUsNTMwNzQyNTIwLC05OTUzMzg2NTEsLTE5ODYzMDg0NCwxMTI2ODkxNDE1LC0xNDE2MzU0OTA1LC01NzQzNDA1NSwxNzAwNDg1NTcxLC0xODk0OTg2NjA2LC0xMDUxNTIzLC0yMDU0OTIyNzk5LDE4NzMzMTMzNTksLTMwNjExNzQ0LC0xNTYwMTk4MzgwLDEzMDkxNTE2NDksLTE0NTUyMzA3MCwtMTEyMDIxMDM3OSw3MTg3ODcyNTksLTM0MzQ4NTU1MV0pO3JldHVybiBmdW5jdGlvbiBoYXNoKGksYSxzKXtsZXQgcj0xNzMyNTg0MTkzLG49LTI3MTczMzg3OSxvPS0xNzMyNTg0MTk0LGc9MjcxNzMzODc4O2NvbnN0IGM9cys3MiYtNjQsQz1uZXcgVWludDhBcnJheShjKTtsZXQgaCxsO2ZvcihoPTA7aDxzOysraClDW2hdPWlbYSsrXTtDW2grK109MTI4O2NvbnN0IFE9Yy04O2Zvcig7aDxROylDW2grK109MDtDW2grK109czw8MyYyNTU7Q1toKytdPXM+PjUmMjU1O0NbaCsrXT1zPj4xMyYyNTU7Q1toKytdPXM+PjIxJjI1NTtDW2grK109cz4+PjI5JjI1NTtDW2grK109MDtDW2grK109MDtDW2grK109MDtjb25zdCBFPW5ldyBJbnQzMkFycmF5KDE2KTtmb3IoaD0wO2g8Yzspe2ZvcihsPTA7bDwxNjsrK2wsaCs9NClFW2xdPUNbaF18Q1toKzFdPDw4fENbaCsyXTw8MTZ8Q1toKzNdPDwyNDtsZXQgaSxhLHM9cixjPW4sUT1vLHU9Zztmb3IobD0wO2w8NjQ7KytsKXtpZihsPDE2KXtpPWMmUXx+YyZ1O2E9bH1lbHNlIGlmKGw8MzIpe2k9dSZjfH51JlE7YT01KmwrMSYxNX1lbHNlIGlmKGw8NDgpe2k9Y15RXnU7YT0zKmwrNSYxNX1lbHNle2k9UV4oY3x+dSk7YT03KmwmMTV9Y29uc3Qgcj11LG49cytpK3RbbF0rRVthXXwwLG89ZVtsXTt1PVE7UT1jO2M9Yysobjw8b3xuPj4+MzItbyl8MDtzPXJ9cj1yK3N8MDtuPW4rY3wwO289bytRfDA7Zz1nK3V8MH1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzI1NSZyLHI+PjgmMjU1LHI+PjE2JjI1NSxyPj4+MjQmMjU1LDI1NSZuLG4+PjgmMjU1LG4+PjE2JjI1NSxuPj4+MjQmMjU1LDI1NSZvLG8+PjgmMjU1LG8+PjE2JjI1NSxvPj4+MjQmMjU1LDI1NSZnLGc+PjgmMjU1LGc+PjE2JjI1NSxnPj4+MjQmMjU1XSl9fSgpO2NsYXNzIFdvcmQ2NHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuaGlnaD0wfGU7dGhpcy5sb3c9MHx0fWFuZChlKXt0aGlzLmhpZ2gmPWUuaGlnaDt0aGlzLmxvdyY9ZS5sb3d9eG9yKGUpe3RoaXMuaGlnaF49ZS5oaWdoO3RoaXMubG93Xj1lLmxvd31vcihlKXt0aGlzLmhpZ2h8PWUuaGlnaDt0aGlzLmxvd3w9ZS5sb3d9c2hpZnRSaWdodChlKXtpZihlPj0zMil7dGhpcy5sb3c9dGhpcy5oaWdoPj4+ZS0zMnwwO3RoaXMuaGlnaD0wfWVsc2V7dGhpcy5sb3c9dGhpcy5sb3c+Pj5lfHRoaXMuaGlnaDw8MzItZTt0aGlzLmhpZ2g9dGhpcy5oaWdoPj4+ZXwwfX1zaGlmdExlZnQoZSl7aWYoZT49MzIpe3RoaXMuaGlnaD10aGlzLmxvdzw8ZS0zMjt0aGlzLmxvdz0wfWVsc2V7dGhpcy5oaWdoPXRoaXMuaGlnaDw8ZXx0aGlzLmxvdz4+PjMyLWU7dGhpcy5sb3c8PD1lfX1yb3RhdGVSaWdodChlKXtsZXQgdCxpO2lmKDMyJmUpe2k9dGhpcy5sb3c7dD10aGlzLmhpZ2h9ZWxzZXt0PXRoaXMubG93O2k9dGhpcy5oaWdofWUmPTMxO3RoaXMubG93PXQ+Pj5lfGk8PDMyLWU7dGhpcy5oaWdoPWk+Pj5lfHQ8PDMyLWV9bm90KCl7dGhpcy5oaWdoPX50aGlzLmhpZ2g7dGhpcy5sb3c9fnRoaXMubG93fWFkZChlKXtjb25zdCB0PSh0aGlzLmxvdz4+PjApKyhlLmxvdz4+PjApO2xldCBpPSh0aGlzLmhpZ2g+Pj4wKSsoZS5oaWdoPj4+MCk7dD40Mjk0OTY3Mjk1JiYoaSs9MSk7dGhpcy5sb3c9MHx0O3RoaXMuaGlnaD0wfGl9Y29weVRvKGUsdCl7ZVt0XT10aGlzLmhpZ2g+Pj4yNCYyNTU7ZVt0KzFdPXRoaXMuaGlnaD4+MTYmMjU1O2VbdCsyXT10aGlzLmhpZ2g+PjgmMjU1O2VbdCszXT0yNTUmdGhpcy5oaWdoO2VbdCs0XT10aGlzLmxvdz4+PjI0JjI1NTtlW3QrNV09dGhpcy5sb3c+PjE2JjI1NTtlW3QrNl09dGhpcy5sb3c+PjgmMjU1O2VbdCs3XT0yNTUmdGhpcy5sb3d9YXNzaWduKGUpe3RoaXMuaGlnaD1lLmhpZ2g7dGhpcy5sb3c9ZS5sb3d9fWNvbnN0IEpzPWZ1bmN0aW9uIGNhbGN1bGF0ZVNIQTI1NkNsb3N1cmUoKXtmdW5jdGlvbiByb3RyKGUsdCl7cmV0dXJuIGU+Pj50fGU8PDMyLXR9ZnVuY3Rpb24gY2goZSx0LGkpe3JldHVybiBlJnRefmUmaX1mdW5jdGlvbiBtYWooZSx0LGkpe3JldHVybiBlJnReZSZpXnQmaX1mdW5jdGlvbiBzaWdtYShlKXtyZXR1cm4gcm90cihlLDIpXnJvdHIoZSwxMylecm90cihlLDIyKX1mdW5jdGlvbiBzaWdtYVByaW1lKGUpe3JldHVybiByb3RyKGUsNilecm90cihlLDExKV5yb3RyKGUsMjUpfWZ1bmN0aW9uIGxpdHRsZVNpZ21hKGUpe3JldHVybiByb3RyKGUsNylecm90cihlLDE4KV5lPj4+M31jb25zdCBlPVsxMTE2MzUyNDA4LDE4OTk0NDc0NDEsMzA0OTMyMzQ3MSwzOTIxMDA5NTczLDk2MTk4NzE2MywxNTA4OTcwOTkzLDI0NTM2MzU3NDgsMjg3MDc2MzIyMSwzNjI0MzgxMDgwLDMxMDU5ODQwMSw2MDcyMjUyNzgsMTQyNjg4MTk4NywxOTI1MDc4Mzg4LDIxNjIwNzgyMDYsMjYxNDg4ODEwMywzMjQ4MjIyNTgwLDM4MzUzOTA0MDEsNDAyMjIyNDc3NCwyNjQzNDcwNzgsNjA0ODA3NjI4LDc3MDI1NTk4MywxMjQ5MTUwMTIyLDE1NTUwODE2OTIsMTk5NjA2NDk4NiwyNTU0MjIwODgyLDI4MjE4MzQzNDksMjk1Mjk5NjgwOCwzMjEwMzEzNjcxLDMzMzY1NzE4OTEsMzU4NDUyODcxMSwxMTM5MjY5OTMsMzM4MjQxODk1LDY2NjMwNzIwNSw3NzM1Mjk5MTIsMTI5NDc1NzM3MiwxMzk2MTgyMjkxLDE2OTUxODM3MDAsMTk4NjY2MTA1MSwyMTc3MDI2MzUwLDI0NTY5NTYwMzcsMjczMDQ4NTkyMSwyODIwMzAyNDExLDMyNTk3MzA4MDAsMzM0NTc2NDc3MSwzNTE2MDY1ODE3LDM2MDAzNTI4MDQsNDA5NDU3MTkwOSwyNzU0MjMzNDQsNDMwMjI3NzM0LDUwNjk0ODYxNiw2NTkwNjA1NTYsODgzOTk3ODc3LDk1ODEzOTU3MSwxMzIyODIyMjE4LDE1MzcwMDIwNjMsMTc0Nzg3Mzc3OSwxOTU1NTYyMjIyLDIwMjQxMDQ4MTUsMjIyNzczMDQ1MiwyMzYxODUyNDI0LDI0Mjg0MzY0NzQsMjc1NjczNDE4NywzMjA0MDMxNDc5LDMzMjkzMjUyOThdO3JldHVybiBmdW5jdGlvbiBoYXNoKHQsaSxhKXtsZXQgcz0xNzc5MDMzNzAzLHI9MzE0NDEzNDI3NyxuPTEwMTM5MDQyNDIsbz0yNzczNDgwNzYyLGc9MTM1OTg5MzExOSxjPTI2MDA4MjI5MjQsQz01Mjg3MzQ2MzUsaD0xNTQxNDU5MjI1O2NvbnN0IGw9NjQqTWF0aC5jZWlsKChhKzkpLzY0KSxRPW5ldyBVaW50OEFycmF5KGwpO2xldCBFLHU7Zm9yKEU9MDtFPGE7KytFKVFbRV09dFtpKytdO1FbRSsrXT0xMjg7Y29uc3QgZD1sLTg7Zm9yKDtFPGQ7KVFbRSsrXT0wO1FbRSsrXT0wO1FbRSsrXT0wO1FbRSsrXT0wO1FbRSsrXT1hPj4+MjkmMjU1O1FbRSsrXT1hPj4yMSYyNTU7UVtFKytdPWE+PjEzJjI1NTtRW0UrK109YT4+NSYyNTU7UVtFKytdPWE8PDMmMjU1O2NvbnN0IGY9bmV3IFVpbnQzMkFycmF5KDY0KTtmb3IoRT0wO0U8bDspe2Zvcih1PTA7dTwxNjsrK3Upe2ZbdV09UVtFXTw8MjR8UVtFKzFdPDwxNnxRW0UrMl08PDh8UVtFKzNdO0UrPTR9Zm9yKHU9MTY7dTw2NDsrK3UpZlt1XT0ocm90cihwPWZbdS0yXSwxNylecm90cihwLDE5KV5wPj4+MTApK2ZbdS03XStsaXR0bGVTaWdtYShmW3UtMTVdKStmW3UtMTZdfDA7bGV0IHQsaSxhPXMsbD1yLGQ9bixtPW8seT1nLHc9YyxiPUMsRD1oO2Zvcih1PTA7dTw2NDsrK3Upe3Q9RCtzaWdtYVByaW1lKHkpK2NoKHksdyxiKStlW3VdK2ZbdV07aT1zaWdtYShhKSttYWooYSxsLGQpO0Q9YjtiPXc7dz15O3k9bSt0fDA7bT1kO2Q9bDtsPWE7YT10K2l8MH1zPXMrYXwwO3I9citsfDA7bj1uK2R8MDtvPW8rbXwwO2c9Zyt5fDA7Yz1jK3d8MDtDPUMrYnwwO2g9aCtEfDB9dmFyIHA7cmV0dXJuIG5ldyBVaW50OEFycmF5KFtzPj4yNCYyNTUscz4+MTYmMjU1LHM+PjgmMjU1LDI1NSZzLHI+PjI0JjI1NSxyPj4xNiYyNTUscj4+OCYyNTUsMjU1JnIsbj4+MjQmMjU1LG4+PjE2JjI1NSxuPj44JjI1NSwyNTUmbixvPj4yNCYyNTUsbz4+MTYmMjU1LG8+PjgmMjU1LDI1NSZvLGc+PjI0JjI1NSxnPj4xNiYyNTUsZz4+OCYyNTUsMjU1JmcsYz4+MjQmMjU1LGM+PjE2JjI1NSxjPj44JjI1NSwyNTUmYyxDPj4yNCYyNTUsQz4+MTYmMjU1LEM+PjgmMjU1LDI1NSZDLGg+PjI0JjI1NSxoPj4xNiYyNTUsaD4+OCYyNTUsMjU1JmhdKX19KCksWXM9ZnVuY3Rpb24gY2FsY3VsYXRlU0hBNTEyQ2xvc3VyZSgpe2Z1bmN0aW9uIGNoKGUsdCxpLGEscyl7ZS5hc3NpZ24odCk7ZS5hbmQoaSk7cy5hc3NpZ24odCk7cy5ub3QoKTtzLmFuZChhKTtlLnhvcihzKX1mdW5jdGlvbiBtYWooZSx0LGksYSxzKXtlLmFzc2lnbih0KTtlLmFuZChpKTtzLmFzc2lnbih0KTtzLmFuZChhKTtlLnhvcihzKTtzLmFzc2lnbihpKTtzLmFuZChhKTtlLnhvcihzKX1mdW5jdGlvbiBzaWdtYShlLHQsaSl7ZS5hc3NpZ24odCk7ZS5yb3RhdGVSaWdodCgyOCk7aS5hc3NpZ24odCk7aS5yb3RhdGVSaWdodCgzNCk7ZS54b3IoaSk7aS5hc3NpZ24odCk7aS5yb3RhdGVSaWdodCgzOSk7ZS54b3IoaSl9ZnVuY3Rpb24gc2lnbWFQcmltZShlLHQsaSl7ZS5hc3NpZ24odCk7ZS5yb3RhdGVSaWdodCgxNCk7aS5hc3NpZ24odCk7aS5yb3RhdGVSaWdodCgxOCk7ZS54b3IoaSk7aS5hc3NpZ24odCk7aS5yb3RhdGVSaWdodCg0MSk7ZS54b3IoaSl9ZnVuY3Rpb24gbGl0dGxlU2lnbWEoZSx0LGkpe2UuYXNzaWduKHQpO2Uucm90YXRlUmlnaHQoMSk7aS5hc3NpZ24odCk7aS5yb3RhdGVSaWdodCg4KTtlLnhvcihpKTtpLmFzc2lnbih0KTtpLnNoaWZ0UmlnaHQoNyk7ZS54b3IoaSl9ZnVuY3Rpb24gbGl0dGxlU2lnbWFQcmltZShlLHQsaSl7ZS5hc3NpZ24odCk7ZS5yb3RhdGVSaWdodCgxOSk7aS5hc3NpZ24odCk7aS5yb3RhdGVSaWdodCg2MSk7ZS54b3IoaSk7aS5hc3NpZ24odCk7aS5zaGlmdFJpZ2h0KDYpO2UueG9yKGkpfWNvbnN0IGU9W25ldyBXb3JkNjQoMTExNjM1MjQwOCwzNjA5NzY3NDU4KSxuZXcgV29yZDY0KDE4OTk0NDc0NDEsNjAyODkxNzI1KSxuZXcgV29yZDY0KDMwNDkzMjM0NzEsMzk2NDQ4NDM5OSksbmV3IFdvcmQ2NCgzOTIxMDA5NTczLDIxNzMyOTU1NDgpLG5ldyBXb3JkNjQoOTYxOTg3MTYzLDQwODE2Mjg0NzIpLG5ldyBXb3JkNjQoMTUwODk3MDk5MywzMDUzODM0MjY1KSxuZXcgV29yZDY0KDI0NTM2MzU3NDgsMjkzNzY3MTU3OSksbmV3IFdvcmQ2NCgyODcwNzYzMjIxLDM2NjQ2MDk1NjApLG5ldyBXb3JkNjQoMzYyNDM4MTA4MCwyNzM0ODgzMzk0KSxuZXcgV29yZDY0KDMxMDU5ODQwMSwxMTY0OTk2NTQyKSxuZXcgV29yZDY0KDYwNzIyNTI3OCwxMzIzNjEwNzY0KSxuZXcgV29yZDY0KDE0MjY4ODE5ODcsMzU5MDMwNDk5NCksbmV3IFdvcmQ2NCgxOTI1MDc4Mzg4LDQwNjgxODIzODMpLG5ldyBXb3JkNjQoMjE2MjA3ODIwNiw5OTEzMzYxMTMpLG5ldyBXb3JkNjQoMjYxNDg4ODEwMyw2MzM4MDMzMTcpLG5ldyBXb3JkNjQoMzI0ODIyMjU4MCwzNDc5Nzc0ODY4KSxuZXcgV29yZDY0KDM4MzUzOTA0MDEsMjY2NjYxMzQ1OCksbmV3IFdvcmQ2NCg0MDIyMjI0Nzc0LDk0NDcxMTEzOSksbmV3IFdvcmQ2NCgyNjQzNDcwNzgsMjM0MTI2Mjc3MyksbmV3IFdvcmQ2NCg2MDQ4MDc2MjgsMjAwNzgwMDkzMyksbmV3IFdvcmQ2NCg3NzAyNTU5ODMsMTQ5NTk5MDkwMSksbmV3IFdvcmQ2NCgxMjQ5MTUwMTIyLDE4NTY0MzEyMzUpLG5ldyBXb3JkNjQoMTU1NTA4MTY5MiwzMTc1MjE4MTMyKSxuZXcgV29yZDY0KDE5OTYwNjQ5ODYsMjE5ODk1MDgzNyksbmV3IFdvcmQ2NCgyNTU0MjIwODgyLDM5OTk3MTkzMzkpLG5ldyBXb3JkNjQoMjgyMTgzNDM0OSw3NjY3ODQwMTYpLG5ldyBXb3JkNjQoMjk1Mjk5NjgwOCwyNTY2NTk0ODc5KSxuZXcgV29yZDY0KDMyMTAzMTM2NzEsMzIwMzMzNzk1NiksbmV3IFdvcmQ2NCgzMzM2NTcxODkxLDEwMzQ0NTcwMjYpLG5ldyBXb3JkNjQoMzU4NDUyODcxMSwyNDY2OTQ4OTAxKSxuZXcgV29yZDY0KDExMzkyNjk5MywzNzU4MzI2MzgzKSxuZXcgV29yZDY0KDMzODI0MTg5NSwxNjg3MTc5MzYpLG5ldyBXb3JkNjQoNjY2MzA3MjA1LDExODgxNzk5NjQpLG5ldyBXb3JkNjQoNzczNTI5OTEyLDE1NDYwNDU3MzQpLG5ldyBXb3JkNjQoMTI5NDc1NzM3MiwxNTIyODA1NDg1KSxuZXcgV29yZDY0KDEzOTYxODIyOTEsMjY0MzgzMzgyMyksbmV3IFdvcmQ2NCgxNjk1MTgzNzAwLDIzNDM1MjczOTApLG5ldyBXb3JkNjQoMTk4NjY2MTA1MSwxMDE0NDc3NDgwKSxuZXcgV29yZDY0KDIxNzcwMjYzNTAsMTIwNjc1OTE0MiksbmV3IFdvcmQ2NCgyNDU2OTU2MDM3LDM0NDA3NzYyNyksbmV3IFdvcmQ2NCgyNzMwNDg1OTIxLDEyOTA4NjM0NjApLG5ldyBXb3JkNjQoMjgyMDMwMjQxMSwzMTU4NDU0MjczKSxuZXcgV29yZDY0KDMyNTk3MzA4MDAsMzUwNTk1MjY1NyksbmV3IFdvcmQ2NCgzMzQ1NzY0NzcxLDEwNjIxNzAwOCksbmV3IFdvcmQ2NCgzNTE2MDY1ODE3LDM2MDYwMDgzNDQpLG5ldyBXb3JkNjQoMzYwMDM1MjgwNCwxNDMyNzI1Nzc2KSxuZXcgV29yZDY0KDQwOTQ1NzE5MDksMTQ2NzAzMTU5NCksbmV3IFdvcmQ2NCgyNzU0MjMzNDQsODUxMTY5NzIwKSxuZXcgV29yZDY0KDQzMDIyNzczNCwzMTAwODIzNzUyKSxuZXcgV29yZDY0KDUwNjk0ODYxNiwxMzYzMjU4MTk1KSxuZXcgV29yZDY0KDY1OTA2MDU1NiwzNzUwNjg1NTkzKSxuZXcgV29yZDY0KDg4Mzk5Nzg3NywzNzg1MDUwMjgwKSxuZXcgV29yZDY0KDk1ODEzOTU3MSwzMzE4MzA3NDI3KSxuZXcgV29yZDY0KDEzMjI4MjIyMTgsMzgxMjcyMzQwMyksbmV3IFdvcmQ2NCgxNTM3MDAyMDYzLDIwMDMwMzQ5OTUpLG5ldyBXb3JkNjQoMTc0Nzg3Mzc3OSwzNjAyMDM2ODk5KSxuZXcgV29yZDY0KDE5NTU1NjIyMjIsMTU3NTk5MDAxMiksbmV3IFdvcmQ2NCgyMDI0MTA0ODE1LDExMjU1OTI5MjgpLG5ldyBXb3JkNjQoMjIyNzczMDQ1MiwyNzE2OTA0MzA2KSxuZXcgV29yZDY0KDIzNjE4NTI0MjQsNDQyNzc2MDQ0KSxuZXcgV29yZDY0KDI0Mjg0MzY0NzQsNTkzNjk4MzQ0KSxuZXcgV29yZDY0KDI3NTY3MzQxODcsMzczMzExMDI0OSksbmV3IFdvcmQ2NCgzMjA0MDMxNDc5LDI5OTkzNTE1NzMpLG5ldyBXb3JkNjQoMzMyOTMyNTI5OCwzODE1OTIwNDI3KSxuZXcgV29yZDY0KDMzOTE1Njk2MTQsMzkyODM4MzkwMCksbmV3IFdvcmQ2NCgzNTE1MjY3MjcxLDU2NjI4MDcxMSksbmV3IFdvcmQ2NCgzOTQwMTg3NjA2LDM0NTQwNjk1MzQpLG5ldyBXb3JkNjQoNDExODYzMDI3MSw0MDAwMjM5OTkyKSxuZXcgV29yZDY0KDExNjQxODQ3NCwxOTE0MTM4NTU0KSxuZXcgV29yZDY0KDE3NDI5MjQyMSwyNzMxMDU1MjcwKSxuZXcgV29yZDY0KDI4OTM4MDM1NiwzMjAzOTkzMDA2KSxuZXcgV29yZDY0KDQ2MDM5MzI2OSwzMjA2MjAzMTUpLG5ldyBXb3JkNjQoNjg1NDcxNzMzLDU4NzQ5NjgzNiksbmV3IFdvcmQ2NCg4NTIxNDI5NzEsMTA4Njc5Mjg1MSksbmV3IFdvcmQ2NCgxMDE3MDM2Mjk4LDM2NTU0MzEwMCksbmV3IFdvcmQ2NCgxMTI2MDAwNTgwLDI2MTgyOTc2NzYpLG5ldyBXb3JkNjQoMTI4ODAzMzQ3MCwzNDA5ODU1MTU4KSxuZXcgV29yZDY0KDE1MDE1MDU5NDgsNDIzNDUwOTg2NiksbmV3IFdvcmQ2NCgxNjA3MTY3OTE1LDk4NzE2NzQ2OCksbmV3IFdvcmQ2NCgxODE2NDAyMzE2LDEyNDYxODk1OTEpXTtyZXR1cm4gZnVuY3Rpb24gaGFzaCh0LGksYSxzPSExKXtsZXQgcixuLG8sZyxjLEMsaCxsO2lmKHMpe3I9bmV3IFdvcmQ2NCgzNDE4MDcwMzY1LDMyMzgzNzEwMzIpO249bmV3IFdvcmQ2NCgxNjU0MjcwMjUwLDkxNDE1MDY2Myk7bz1uZXcgV29yZDY0KDI0Mzg1MjkzNzAsODEyNzAyOTk5KTtnPW5ldyBXb3JkNjQoMzU1NDYyMzYwLDQxNDQ5MTI2OTcpO2M9bmV3IFdvcmQ2NCgxNzMxNDA1NDE1LDQyOTA3NzU4NTcpO0M9bmV3IFdvcmQ2NCgyMzk0MTgwMjMxLDE3NTA2MDMwMjUpO2g9bmV3IFdvcmQ2NCgzNjc1MDA4NTI1LDE2OTQwNzY4MzkpO2w9bmV3IFdvcmQ2NCgxMjAzMDYyODEzLDMyMDQwNzU0MjgpfWVsc2V7cj1uZXcgV29yZDY0KDE3NzkwMzM3MDMsNDA4OTIzNTcyMCk7bj1uZXcgV29yZDY0KDMxNDQxMzQyNzcsMjIyNzg3MzU5NSk7bz1uZXcgV29yZDY0KDEwMTM5MDQyNDIsNDI3MTE3NTcyMyk7Zz1uZXcgV29yZDY0KDI3NzM0ODA3NjIsMTU5NTc1MDEyOSk7Yz1uZXcgV29yZDY0KDEzNTk4OTMxMTksMjkxNzU2NTEzNyk7Qz1uZXcgV29yZDY0KDI2MDA4MjI5MjQsNzI1NTExMTk5KTtoPW5ldyBXb3JkNjQoNTI4NzM0NjM1LDQyMTUzODk1NDcpO2w9bmV3IFdvcmQ2NCgxNTQxNDU5MjI1LDMyNzAzMzIwOSl9Y29uc3QgUT0xMjgqTWF0aC5jZWlsKChhKzE3KS8xMjgpLEU9bmV3IFVpbnQ4QXJyYXkoUSk7bGV0IHUsZDtmb3IodT0wO3U8YTsrK3UpRVt1XT10W2krK107RVt1KytdPTEyODtjb25zdCBmPVEtMTY7Zm9yKDt1PGY7KUVbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT0wO0VbdSsrXT1hPj4+MjkmMjU1O0VbdSsrXT1hPj4yMSYyNTU7RVt1KytdPWE+PjEzJjI1NTtFW3UrK109YT4+NSYyNTU7RVt1KytdPWE8PDMmMjU1O2NvbnN0IHA9bmV3IEFycmF5KDgwKTtmb3IodT0wO3U8ODA7dSsrKXBbdV09bmV3IFdvcmQ2NCgwLDApO2xldCBtPW5ldyBXb3JkNjQoMCwwKSx5PW5ldyBXb3JkNjQoMCwwKSx3PW5ldyBXb3JkNjQoMCwwKSxiPW5ldyBXb3JkNjQoMCwwKSxEPW5ldyBXb3JkNjQoMCwwKSxGPW5ldyBXb3JkNjQoMCwwKSxTPW5ldyBXb3JkNjQoMCwwKSxrPW5ldyBXb3JkNjQoMCwwKTtjb25zdCBOPW5ldyBXb3JkNjQoMCwwKSxSPW5ldyBXb3JkNjQoMCwwKSxHPW5ldyBXb3JkNjQoMCwwKSx4PW5ldyBXb3JkNjQoMCwwKTtsZXQgVSxNO2Zvcih1PTA7dTxROyl7Zm9yKGQ9MDtkPDE2OysrZCl7cFtkXS5oaWdoPUVbdV08PDI0fEVbdSsxXTw8MTZ8RVt1KzJdPDw4fEVbdSszXTtwW2RdLmxvdz1FW3UrNF08PDI0fEVbdSs1XTw8MTZ8RVt1KzZdPDw4fEVbdSs3XTt1Kz04fWZvcihkPTE2O2Q8ODA7KytkKXtVPXBbZF07bGl0dGxlU2lnbWFQcmltZShVLHBbZC0yXSx4KTtVLmFkZChwW2QtN10pO2xpdHRsZVNpZ21hKEcscFtkLTE1XSx4KTtVLmFkZChHKTtVLmFkZChwW2QtMTZdKX1tLmFzc2lnbihyKTt5LmFzc2lnbihuKTt3LmFzc2lnbihvKTtiLmFzc2lnbihnKTtELmFzc2lnbihjKTtGLmFzc2lnbihDKTtTLmFzc2lnbihoKTtrLmFzc2lnbihsKTtmb3IoZD0wO2Q8ODA7KytkKXtOLmFzc2lnbihrKTtzaWdtYVByaW1lKEcsRCx4KTtOLmFkZChHKTtjaChHLEQsRixTLHgpO04uYWRkKEcpO04uYWRkKGVbZF0pO04uYWRkKHBbZF0pO3NpZ21hKFIsbSx4KTttYWooRyxtLHksdyx4KTtSLmFkZChHKTtVPWs7az1TO1M9RjtGPUQ7Yi5hZGQoTik7RD1iO2I9dzt3PXk7eT1tO1UuYXNzaWduKE4pO1UuYWRkKFIpO209VX1yLmFkZChtKTtuLmFkZCh5KTtvLmFkZCh3KTtnLmFkZChiKTtjLmFkZChEKTtDLmFkZChGKTtoLmFkZChTKTtsLmFkZChrKX1pZihzKXtNPW5ldyBVaW50OEFycmF5KDQ4KTtyLmNvcHlUbyhNLDApO24uY29weVRvKE0sOCk7by5jb3B5VG8oTSwxNik7Zy5jb3B5VG8oTSwyNCk7Yy5jb3B5VG8oTSwzMik7Qy5jb3B5VG8oTSw0MCl9ZWxzZXtNPW5ldyBVaW50OEFycmF5KDY0KTtyLmNvcHlUbyhNLDApO24uY29weVRvKE0sOCk7by5jb3B5VG8oTSwxNik7Zy5jb3B5VG8oTSwyNCk7Yy5jb3B5VG8oTSwzMik7Qy5jb3B5VG8oTSw0MCk7aC5jb3B5VG8oTSw0OCk7bC5jb3B5VG8oTSw1Nil9cmV0dXJuIE19fSgpO2NsYXNzIE51bGxDaXBoZXJ7ZGVjcnlwdEJsb2NrKGUpe3JldHVybiBlfWVuY3J5cHQoZSl7cmV0dXJuIGV9fWNsYXNzIEFFU0Jhc2VDaXBoZXJ7Y29uc3RydWN0b3IoKXt0aGlzLmNvbnN0cnVjdG9yPT09QUVTQmFzZUNpcGhlciYmdW5yZWFjaGFibGUoIkNhbm5vdCBpbml0aWFsaXplIEFFU0Jhc2VDaXBoZXIuIik7dGhpcy5fcz1uZXcgVWludDhBcnJheShbOTksMTI0LDExOSwxMjMsMjQyLDEwNywxMTEsMTk3LDQ4LDEsMTAzLDQzLDI1NCwyMTUsMTcxLDExOCwyMDIsMTMwLDIwMSwxMjUsMjUwLDg5LDcxLDI0MCwxNzMsMjEyLDE2MiwxNzUsMTU2LDE2NCwxMTQsMTkyLDE4MywyNTMsMTQ3LDM4LDU0LDYzLDI0NywyMDQsNTIsMTY1LDIyOSwyNDEsMTEzLDIxNiw0OSwyMSw0LDE5OSwzNSwxOTUsMjQsMTUwLDUsMTU0LDcsMTgsMTI4LDIyNiwyMzUsMzksMTc4LDExNyw5LDEzMSw0NCwyNiwyNywxMTAsOTAsMTYwLDgyLDU5LDIxNCwxNzksNDEsMjI3LDQ3LDEzMiw4MywyMDksMCwyMzcsMzIsMjUyLDE3Nyw5MSwxMDYsMjAzLDE5MCw1Nyw3NCw3Niw4OCwyMDcsMjA4LDIzOSwxNzAsMjUxLDY3LDc3LDUxLDEzMyw2OSwyNDksMiwxMjcsODAsNjAsMTU5LDE2OCw4MSwxNjMsNjQsMTQzLDE0NiwxNTcsNTYsMjQ1LDE4OCwxODIsMjE4LDMzLDE2LDI1NSwyNDMsMjEwLDIwNSwxMiwxOSwyMzYsOTUsMTUxLDY4LDIzLDE5NiwxNjcsMTI2LDYxLDEwMCw5MywyNSwxMTUsOTYsMTI5LDc5LDIyMCwzNCw0MiwxNDQsMTM2LDcwLDIzOCwxODQsMjAsMjIyLDk0LDExLDIxOSwyMjQsNTAsNTgsMTAsNzMsNiwzNiw5MiwxOTQsMjExLDE3Miw5OCwxNDUsMTQ5LDIyOCwxMjEsMjMxLDIwMCw1NSwxMDksMTQxLDIxMyw3OCwxNjksMTA4LDg2LDI0NCwyMzQsMTAxLDEyMiwxNzQsOCwxODYsMTIwLDM3LDQ2LDI4LDE2NiwxODAsMTk4LDIzMiwyMjEsMTE2LDMxLDc1LDE4OSwxMzksMTM4LDExMiw2MiwxODEsMTAyLDcyLDMsMjQ2LDE0LDk3LDUzLDg3LDE4NSwxMzQsMTkzLDI5LDE1OCwyMjUsMjQ4LDE1MiwxNywxMDUsMjE3LDE0MiwxNDgsMTU1LDMwLDEzNSwyMzMsMjA2LDg1LDQwLDIyMywxNDAsMTYxLDEzNywxMywxOTEsMjMwLDY2LDEwNCw2NSwxNTMsNDUsMTUsMTc2LDg0LDE4NywyMl0pO3RoaXMuX2ludl9zPW5ldyBVaW50OEFycmF5KFs4Miw5LDEwNiwyMTMsNDgsNTQsMTY1LDU2LDE5MSw2NCwxNjMsMTU4LDEyOSwyNDMsMjE1LDI1MSwxMjQsMjI3LDU3LDEzMCwxNTUsNDcsMjU1LDEzNSw1MiwxNDIsNjcsNjgsMTk2LDIyMiwyMzMsMjAzLDg0LDEyMywxNDgsNTAsMTY2LDE5NCwzNSw2MSwyMzgsNzYsMTQ5LDExLDY2LDI1MCwxOTUsNzgsOCw0NiwxNjEsMTAyLDQwLDIxNywzNiwxNzgsMTE4LDkxLDE2Miw3MywxMDksMTM5LDIwOSwzNywxMTQsMjQ4LDI0NiwxMDAsMTM0LDEwNCwxNTIsMjIsMjEyLDE2NCw5MiwyMDQsOTMsMTAxLDE4MiwxNDYsMTA4LDExMiw3Miw4MCwyNTMsMjM3LDE4NSwyMTgsOTQsMjEsNzAsODcsMTY3LDE0MSwxNTcsMTMyLDE0NCwyMTYsMTcxLDAsMTQwLDE4OCwyMTEsMTAsMjQ3LDIyOCw4OCw1LDE4NCwxNzksNjksNiwyMDgsNDQsMzAsMTQzLDIwMiw2MywxNSwyLDE5MywxNzUsMTg5LDMsMSwxOSwxMzgsMTA3LDU4LDE0NSwxNyw2NSw3OSwxMDMsMjIwLDIzNCwxNTEsMjQyLDIwNywyMDYsMjQwLDE4MCwyMzAsMTE1LDE1MCwxNzIsMTE2LDM0LDIzMSwxNzMsNTMsMTMzLDIyNiwyNDksNTUsMjMyLDI4LDExNywyMjMsMTEwLDcxLDI0MSwyNiwxMTMsMjksNDEsMTk3LDEzNywxMTEsMTgzLDk4LDE0LDE3MCwyNCwxOTAsMjcsMjUyLDg2LDYyLDc1LDE5OCwyMTAsMTIxLDMyLDE1NCwyMTksMTkyLDI1NCwxMjAsMjA1LDkwLDI0NCwzMSwyMjEsMTY4LDUxLDEzNiw3LDE5OSw0OSwxNzcsMTgsMTYsODksMzksMTI4LDIzNiw5NSw5Niw4MSwxMjcsMTY5LDI1LDE4MSw3NCwxMyw0NSwyMjksMTIyLDE1OSwxNDcsMjAxLDE1NiwyMzksMTYwLDIyNCw1OSw3NywxNzQsNDIsMjQ1LDE3NiwyMDAsMjM1LDE4Nyw2MCwxMzEsODMsMTUzLDk3LDIzLDQzLDQsMTI2LDE4NiwxMTksMjE0LDM4LDIyNSwxMDUsMjAsOTksODUsMzMsMTIsMTI1XSk7dGhpcy5fbWl4PW5ldyBVaW50MzJBcnJheShbMCwyMzU0NzQxODcsNDcwOTQ4Mzc0LDMwMzc2NTI3Nyw5NDE4OTY3NDgsOTA4OTMzNDE1LDYwNzUzMDU1NCw3MDg3ODA4NDksMTg4Mzc5MzQ5NiwyMTE4MjE0OTk1LDE4MTc4NjY4MzAsMTY0OTYzOTIzNywxMjE1MDYxMTA4LDExODEwNDUxMTksMTQxNzU2MTY5OCwxNTE3NzY3NTI5LDM3Njc1ODY5OTIsNDAwMzA2MTE3OSw0MjM2NDI5OTkwLDQwNjkyNDY4OTMsMzYzNTczMzY2MCwzNjAyNzcwMzI3LDMyOTkyNzg0NzQsMzQwMDUyODc2OSwyNDMwMTIyMjE2LDI2NjQ1NDM3MTUsMjM2MjA5MDIzOCwyMTkzODYyNjQ1LDI4MzUxMjMzOTYsMjgwMTEwNzQwNywzMDM1NTM1MDU4LDMxMzU3NDA4ODksMzY3ODEyNDkyMywzNTc2ODcwNTEyLDMzNDEzOTQyODUsMzM3NDM2MTcwMiwzODEwNDk2MzQzLDM5Nzc2NzUzNTYsNDI3OTA4MDI1Nyw0MDQzNjEwMTg2LDI4NzY0OTQ2MjcsMjc3NjI5MjkwNCwzMDc2NjM5MDI5LDMxMTA2NTA5NDIsMjQ3MjAxMTUzNSwyNjQwMjQzMjA0LDI0MDM3Mjg2NjUsMjE2OTMwMzA1OCwxMDAxMDg5OTk1LDg5OTgzNTU4NCw2NjY0NjQ3MzMsNjk5NDMyMTUwLDU5NzI3ODQ3LDIyNjkwNjg2MCw1MzA0MDA3NTMsMjk0OTMwNjgyLDEyNzMxNjg3ODcsMTE3Mjk2NzA2NCwxNDc1NDE4NTAxLDE1MDk0MzA0MTQsMTk0MjQzNTc3NSwyMTEwNjY3NDQ0LDE4NzYyNDE4MzMsMTY0MTgxNjIyNiwyOTEwMjE5NzY2LDI3NDMwMzQxMDksMjk3NjE1MTUyMCwzMjExNjIzMTQ3LDI1MDUyMDIxMzgsMjYwNjQ1Mzk2OSwyMzAyNjkwMjUyLDIyNjk3Mjg0NTUsMzcxMTgyOTQyMiwzNTQzNTk5MjY5LDMyNDA4OTQzOTIsMzQ3NTMxMzMzMSwzODQzNjk5MDc0LDM5NDM5MDY0NDEsNDE3ODA2MjIyOCw0MTQ0MDQ3Nzc1LDEzMDY5NjczNjYsMTEzOTc4MTcwOSwxMzc0OTg4MTEyLDE2MTA0NTk3MzksMTk3NTY4MzQzNCwyMDc2OTM1MjY1LDE3NzUyNzY5MjQsMTc0MjMxNTEyNywxMDM0ODY3OTk4LDg2NjYzNzg0NSw1NjYwMjE4OTYsODAwNDQwODM1LDkyOTg3Njk4LDE5MzE5NTA2NSw0Mjk0NTYxNjQsMzk1NDQxNzExLDE5ODQ4MTI2ODUsMjAxNzc3ODU2NiwxNzg0NjYzMTk1LDE2ODM0MDcyNDgsMTMxNTU2MjE0NSwxMDgwMDk0NjM0LDEzODM4NTYzMTEsMTU1MTAzNzg4NCwxMDEwMzk4MjksMTM1MDUwMjA2LDQzNzc1NzEyMywzMzc1NTM4NjQsMTA0MjM4NTY1Nyw4MDc5NjI2MTAsNTczODA0NzgzLDc0MjAzOTAxMiwyNTMxMDY3NDUzLDI1NjQwMzMzMzQsMjMyODgyODk3MSwyMjI3NTczMDI0LDI5MzU1NjY4NjUsMjcwMDA5OTM1NCwzMDAxNzU1NjU1LDMxNjg5MzcyMjgsMzg2ODU1MjgwNSwzOTAyNTYzMTgyLDQyMDMxODExNzEsNDEwMjk3NzkxMiwzNzM2MTY0OTM3LDM1MDE3NDE4OTAsMzI2NTQ3ODc1MSwzNDMzNzEyOTgwLDExMDYwNDE1OTEsMTM0MDQ2MzEwMCwxNTc2OTc2NjA5LDE0MDg3NDkwMzQsMjA0MzIxMTQ4MywyMDA5MTk1NDcyLDE3MDg4NDgzMzMsMTgwOTA1NDE1MCw4MzI4NzcyMzEsMTA2ODM1MTM5Niw3NjY5NDU0NjUsNTk5NzYyMzU0LDE1OTQxNzk4NywxMjY0NTQ2NjQsMzYxOTI5ODc3LDQ2MzE4MDE5MCwyNzA5MjYwODcxLDI5NDM2ODIzODAsMzE3ODEwNjk2MSwzMDA5ODc5Mzg2LDI1NzI2OTcxOTUsMjUzODY4MTE4NCwyMjM2MjI4NzMzLDIzMzY0MzQ1NTAsMzUwOTg3MTEzNSwzNzQ1MzQ1MzAwLDM0NDE4NTAzNzcsMzI3NDY2NzI2NiwzOTEwMTYxOTcxLDM4NzcxOTg2NDgsNDExMDU2ODQ4NSw0MjExODE4Nzk4LDI1OTc4MDY0NzYsMjQ5NzYwNDc0MywyMjYxMDg5MTc4LDIyOTUxMDEwNzMsMjczMzg1NjE2MCwyOTAyMDg3ODUxLDMyMDI0MzcwNDYsMjk2ODAxMTQ1MywzOTM2MjkxMjg0LDM4MzUwMzY4OTUsNDEzNjQ0MDc3MCw0MTY5NDA4MjAxLDM1MzU0ODY0NTYsMzcwMjY2NTQ1OSwzNDY3MTkyMzAyLDMyMzE3MjIyMTMsMjA1MTUxODc4MCwxOTUxMzE3MDQ3LDE3MTY4OTA0MTAsMTc1MDkwMjMwNSwxMTEzODE4Mzg0LDEyODIwNTAwNzUsMTU4NDUwNDU4MiwxMzUwMDc4OTg5LDE2ODgxMDg1Miw2NzU1NjQ2MywzNzEwNDkzMzAsNDA0MDE2NzYxLDg0MTczOTU5MiwxMDA4OTE4NTk1LDc3NTU1MDgxNCw1NDAwODA3MjUsMzk2OTU2MjM2OSwzODAxMzMyMjM0LDQwMzU0ODkwNDcsNDI2OTkwNzk5NiwzNTY5MjU1MjEzLDM2Njk0NjI1NjYsMzM2Njc1NDYxOSwzMzMyNzQwMTQ0LDI2MzEwNjU0MzMsMjQ2Mzg3OTc2MiwyMTYwMTE3MDcxLDIzOTU1ODg2NzYsMjc2NzY0NTU1NywyODY4ODk3NDA2LDMxMDIwMTE3NDcsMzA2OTA0OTk2MCwyMDIwMDg0OTcsMzM3NzgzNjIsMjcwMDQwNDg3LDUwNDQ1OTQzNiw4NzU0NTEyOTMsOTc1NjU4NjQ2LDY3NTAzOTYyNyw2NDEwMjUxNTIsMjA4NDcwNDIzMywxOTE3NTE4NTYyLDE2MTU4NjEyNDcsMTg1MTMzMjg1MiwxMTQ3NTUwNjYxLDEyNDg4MDI1MTAsMTQ4NDAwNTg0MywxNDUxMDQ0MDU2LDkzMzMwMTM3MCw5NjczMTE3MjksNzMzMTU2OTcyLDYzMjk1MzcwMywyNjAzODg5NTAsMjU5NjU5MTcsMzI4NjcxODA4LDQ5NjkwNjA1OSwxMjA2NDc3ODU4LDEyMzk0NDM3NTMsMTU0MzIwODUwMCwxNDQxOTUyNTc1LDIxNDQxNjE4MDYsMTkwODY5NDI3NywxNjc1NTc3ODgwLDE4NDI3NTk0NDMsMzYxMDM2OTIyNiwzNjQ0Mzc5NTg1LDM0MDgxMTk1MTYsMzMwNzkxNjI0Nyw0MDExMTkwNTAyLDM3NzY3Njc0NjksNDA3NzM4NDQzMiw0MjQ1NjE4NjgzLDI4MDk3NzExNTQsMjg0MjczNzA0OSwzMTQ0Mzk2NDIwLDMwNDMxNDA0OTUsMjY3MzcwNTE1MCwyNDM4MjM3NjIxLDIyMDMwMzIyMzIsMjM3MDIxMzc5NV0pO3RoaXMuX21peENvbD1uZXcgVWludDhBcnJheSgyNTYpO2ZvcihsZXQgZT0wO2U8MjU2O2UrKyl0aGlzLl9taXhDb2xbZV09ZTwxMjg/ZTw8MTplPDwxXjI3O3RoaXMuYnVmZmVyPW5ldyBVaW50OEFycmF5KDE2KTt0aGlzLmJ1ZmZlclBvc2l0aW9uPTB9X2V4cGFuZEtleShlKXt1bnJlYWNoYWJsZSgiQ2Fubm90IGNhbGwgYF9leHBhbmRLZXlgIG9uIHRoZSBiYXNlIGNsYXNzIil9X2RlY3J5cHQoZSx0KXtsZXQgaSxhLHM7Y29uc3Qgcj1uZXcgVWludDhBcnJheSgxNik7ci5zZXQoZSk7Zm9yKGxldCBlPTAsaT10aGlzLl9rZXlTaXplO2U8MTY7KytlLCsraSlyW2VdXj10W2ldO2ZvcihsZXQgZT10aGlzLl9jeWNsZXNPZlJlcGV0aXRpb24tMTtlPj0xOy0tZSl7aT1yWzEzXTtyWzEzXT1yWzldO3JbOV09cls1XTtyWzVdPXJbMV07clsxXT1pO2k9clsxNF07YT1yWzEwXTtyWzE0XT1yWzZdO3JbMTBdPXJbMl07cls2XT1pO3JbMl09YTtpPXJbMTVdO2E9clsxMV07cz1yWzddO3JbMTVdPXJbM107clsxMV09aTtyWzddPWE7clszXT1zO2ZvcihsZXQgZT0wO2U8MTY7KytlKXJbZV09dGhpcy5faW52X3NbcltlXV07Zm9yKGxldCBpPTAsYT0xNiplO2k8MTY7KytpLCsrYSlyW2ldXj10W2FdO2ZvcihsZXQgZT0wO2U8MTY7ZSs9NCl7Y29uc3QgdD10aGlzLl9taXhbcltlXV0sYT10aGlzLl9taXhbcltlKzFdXSxzPXRoaXMuX21peFtyW2UrMl1dLG49dGhpcy5fbWl4W3JbZSszXV07aT10XmE+Pj44XmE8PDI0XnM+Pj4xNl5zPDwxNl5uPj4+MjRebjw8ODtyW2VdPWk+Pj4yNCYyNTU7cltlKzFdPWk+PjE2JjI1NTtyW2UrMl09aT4+OCYyNTU7cltlKzNdPTI1NSZpfX1pPXJbMTNdO3JbMTNdPXJbOV07cls5XT1yWzVdO3JbNV09clsxXTtyWzFdPWk7aT1yWzE0XTthPXJbMTBdO3JbMTRdPXJbNl07clsxMF09clsyXTtyWzZdPWk7clsyXT1hO2k9clsxNV07YT1yWzExXTtzPXJbN107clsxNV09clszXTtyWzExXT1pO3JbN109YTtyWzNdPXM7Zm9yKGxldCBlPTA7ZTwxNjsrK2Upe3JbZV09dGhpcy5faW52X3NbcltlXV07cltlXV49dFtlXX1yZXR1cm4gcn1fZW5jcnlwdChlLHQpe2NvbnN0IGk9dGhpcy5fcztsZXQgYSxzLHI7Y29uc3Qgbj1uZXcgVWludDhBcnJheSgxNik7bi5zZXQoZSk7Zm9yKGxldCBlPTA7ZTwxNjsrK2UpbltlXV49dFtlXTtmb3IobGV0IGU9MTtlPHRoaXMuX2N5Y2xlc09mUmVwZXRpdGlvbjtlKyspe2ZvcihsZXQgZT0wO2U8MTY7KytlKW5bZV09aVtuW2VdXTtyPW5bMV07blsxXT1uWzVdO25bNV09bls5XTtuWzldPW5bMTNdO25bMTNdPXI7cj1uWzJdO3M9bls2XTtuWzJdPW5bMTBdO25bNl09blsxNF07blsxMF09cjtuWzE0XT1zO3I9blszXTtzPW5bN107YT1uWzExXTtuWzNdPW5bMTVdO25bN109cjtuWzExXT1zO25bMTVdPWE7Zm9yKGxldCBlPTA7ZTwxNjtlKz00KXtjb25zdCB0PW5bZSswXSxpPW5bZSsxXSxzPW5bZSsyXSxyPW5bZSszXTthPXReaV5zXnI7bltlKzBdXj1hXnRoaXMuX21peENvbFt0XmldO25bZSsxXV49YV50aGlzLl9taXhDb2xbaV5zXTtuW2UrMl1ePWFedGhpcy5fbWl4Q29sW3Necl07bltlKzNdXj1hXnRoaXMuX21peENvbFtyXnRdfWZvcihsZXQgaT0wLGE9MTYqZTtpPDE2OysraSwrK2EpbltpXV49dFthXX1mb3IobGV0IGU9MDtlPDE2OysrZSluW2VdPWlbbltlXV07cj1uWzFdO25bMV09bls1XTtuWzVdPW5bOV07bls5XT1uWzEzXTtuWzEzXT1yO3I9blsyXTtzPW5bNl07blsyXT1uWzEwXTtuWzZdPW5bMTRdO25bMTBdPXI7blsxNF09cztyPW5bM107cz1uWzddO2E9blsxMV07blszXT1uWzE1XTtuWzddPXI7blsxMV09cztuWzE1XT1hO2ZvcihsZXQgZT0wLGk9dGhpcy5fa2V5U2l6ZTtlPDE2OysrZSwrK2kpbltlXV49dFtpXTtyZXR1cm4gbn1fZGVjcnlwdEJsb2NrMihlLHQpe2NvbnN0IGk9ZS5sZW5ndGg7bGV0IGE9dGhpcy5idWZmZXIscz10aGlzLmJ1ZmZlclBvc2l0aW9uO2NvbnN0IHI9W107bGV0IG49dGhpcy5pdjtmb3IobGV0IHQ9MDt0PGk7Kyt0KXthW3NdPWVbdF07KytzO2lmKHM8MTYpY29udGludWU7Y29uc3QgaT10aGlzLl9kZWNyeXB0KGEsdGhpcy5fa2V5KTtmb3IobGV0IGU9MDtlPDE2OysrZSlpW2VdXj1uW2VdO249YTtyLnB1c2goaSk7YT1uZXcgVWludDhBcnJheSgxNik7cz0wfXRoaXMuYnVmZmVyPWE7dGhpcy5idWZmZXJMZW5ndGg9czt0aGlzLml2PW47aWYoMD09PXIubGVuZ3RoKXJldHVybiBuZXcgVWludDhBcnJheSgwKTtsZXQgbz0xNipyLmxlbmd0aDtpZih0KXtjb25zdCBlPXIuYXQoLTEpO2xldCB0PWVbMTVdO2lmKHQ8PTE2KXtmb3IobGV0IGk9MTUsYT0xNi10O2k+PWE7LS1pKWlmKGVbaV0hPT10KXt0PTA7YnJlYWt9by09dDtyW3IubGVuZ3RoLTFdPWUuc3ViYXJyYXkoMCwxNi10KX19Y29uc3QgZz1uZXcgVWludDhBcnJheShvKTtmb3IobGV0IGU9MCx0PTAsaT1yLmxlbmd0aDtlPGk7KytlLHQrPTE2KWcuc2V0KHJbZV0sdCk7cmV0dXJuIGd9ZGVjcnlwdEJsb2NrKGUsdCxpPW51bGwpe2NvbnN0IGE9ZS5sZW5ndGgscz10aGlzLmJ1ZmZlcjtsZXQgcj10aGlzLmJ1ZmZlclBvc2l0aW9uO2lmKGkpdGhpcy5pdj1pO2Vsc2V7Zm9yKGxldCB0PTA7cjwxNiYmdDxhOysrdCwrK3Ipc1tyXT1lW3RdO2lmKHI8MTYpe3RoaXMuYnVmZmVyTGVuZ3RoPXI7cmV0dXJuIG5ldyBVaW50OEFycmF5KDApfXRoaXMuaXY9cztlPWUuc3ViYXJyYXkoMTYpfXRoaXMuYnVmZmVyPW5ldyBVaW50OEFycmF5KDE2KTt0aGlzLmJ1ZmZlckxlbmd0aD0wO3RoaXMuZGVjcnlwdEJsb2NrPXRoaXMuX2RlY3J5cHRCbG9jazI7cmV0dXJuIHRoaXMuZGVjcnlwdEJsb2NrKGUsdCl9ZW5jcnlwdChlLHQpe2NvbnN0IGk9ZS5sZW5ndGg7bGV0IGE9dGhpcy5idWZmZXIscz10aGlzLmJ1ZmZlclBvc2l0aW9uO2NvbnN0IHI9W107dHx8KHQ9bmV3IFVpbnQ4QXJyYXkoMTYpKTtmb3IobGV0IG49MDtuPGk7KytuKXthW3NdPWVbbl07KytzO2lmKHM8MTYpY29udGludWU7Zm9yKGxldCBlPTA7ZTwxNjsrK2UpYVtlXV49dFtlXTtjb25zdCBpPXRoaXMuX2VuY3J5cHQoYSx0aGlzLl9rZXkpO3Q9aTtyLnB1c2goaSk7YT1uZXcgVWludDhBcnJheSgxNik7cz0wfXRoaXMuYnVmZmVyPWE7dGhpcy5idWZmZXJMZW5ndGg9czt0aGlzLml2PXQ7aWYoMD09PXIubGVuZ3RoKXJldHVybiBuZXcgVWludDhBcnJheSgwKTtjb25zdCBuPTE2KnIubGVuZ3RoLG89bmV3IFVpbnQ4QXJyYXkobik7Zm9yKGxldCBlPTAsdD0wLGk9ci5sZW5ndGg7ZTxpOysrZSx0Kz0xNilvLnNldChyW2VdLHQpO3JldHVybiBvfX1jbGFzcyBBRVMxMjhDaXBoZXIgZXh0ZW5kcyBBRVNCYXNlQ2lwaGVye2NvbnN0cnVjdG9yKGUpe3N1cGVyKCk7dGhpcy5fY3ljbGVzT2ZSZXBldGl0aW9uPTEwO3RoaXMuX2tleVNpemU9MTYwO3RoaXMuX3Jjb249bmV3IFVpbnQ4QXJyYXkoWzE0MSwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NCwxMDgsMjE2LDE3MSw3NywxNTQsNDcsOTQsMTg4LDk5LDE5OCwxNTEsNTMsMTA2LDIxMiwxNzksMTI1LDI1MCwyMzksMTk3LDE0NSw1NywxMTQsMjI4LDIxMSwxODksOTcsMTk0LDE1OSwzNyw3NCwxNDgsNTEsMTAyLDIwNCwxMzEsMjksNTgsMTE2LDIzMiwyMDMsMTQxLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0LDEwOCwyMTYsMTcxLDc3LDE1NCw0Nyw5NCwxODgsOTksMTk4LDE1MSw1MywxMDYsMjEyLDE3OSwxMjUsMjUwLDIzOSwxOTcsMTQ1LDU3LDExNCwyMjgsMjExLDE4OSw5NywxOTQsMTU5LDM3LDc0LDE0OCw1MSwxMDIsMjA0LDEzMSwyOSw1OCwxMTYsMjMyLDIwMywxNDEsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTQsMTA4LDIxNiwxNzEsNzcsMTU0LDQ3LDk0LDE4OCw5OSwxOTgsMTUxLDUzLDEwNiwyMTIsMTc5LDEyNSwyNTAsMjM5LDE5NywxNDUsNTcsMTE0LDIyOCwyMTEsMTg5LDk3LDE5NCwxNTksMzcsNzQsMTQ4LDUxLDEwMiwyMDQsMTMxLDI5LDU4LDExNiwyMzIsMjAzLDE0MSwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NCwxMDgsMjE2LDE3MSw3NywxNTQsNDcsOTQsMTg4LDk5LDE5OCwxNTEsNTMsMTA2LDIxMiwxNzksMTI1LDI1MCwyMzksMTk3LDE0NSw1NywxMTQsMjI4LDIxMSwxODksOTcsMTk0LDE1OSwzNyw3NCwxNDgsNTEsMTAyLDIwNCwxMzEsMjksNTgsMTE2LDIzMiwyMDMsMTQxLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0LDEwOCwyMTYsMTcxLDc3LDE1NCw0Nyw5NCwxODgsOTksMTk4LDE1MSw1MywxMDYsMjEyLDE3OSwxMjUsMjUwLDIzOSwxOTcsMTQ1LDU3LDExNCwyMjgsMjExLDE4OSw5NywxOTQsMTU5LDM3LDc0LDE0OCw1MSwxMDIsMjA0LDEzMSwyOSw1OCwxMTYsMjMyLDIwMywxNDFdKTt0aGlzLl9rZXk9dGhpcy5fZXhwYW5kS2V5KGUpfV9leHBhbmRLZXkoZSl7Y29uc3QgdD10aGlzLl9zLGk9dGhpcy5fcmNvbixhPW5ldyBVaW50OEFycmF5KDE3Nik7YS5zZXQoZSk7Zm9yKGxldCBlPTE2LHM9MTtlPDE3NjsrK3Mpe2xldCByPWFbZS0zXSxuPWFbZS0yXSxvPWFbZS0xXSxnPWFbZS00XTtyPXRbcl07bj10W25dO289dFtvXTtnPXRbZ107cl49aVtzXTtmb3IobGV0IHQ9MDt0PDQ7Kyt0KXthW2VdPXJePWFbZS0xNl07ZSsrO2FbZV09bl49YVtlLTE2XTtlKys7YVtlXT1vXj1hW2UtMTZdO2UrKzthW2VdPWdePWFbZS0xNl07ZSsrfX1yZXR1cm4gYX19Y2xhc3MgQUVTMjU2Q2lwaGVyIGV4dGVuZHMgQUVTQmFzZUNpcGhlcntjb25zdHJ1Y3RvcihlKXtzdXBlcigpO3RoaXMuX2N5Y2xlc09mUmVwZXRpdGlvbj0xNDt0aGlzLl9rZXlTaXplPTIyNDt0aGlzLl9rZXk9dGhpcy5fZXhwYW5kS2V5KGUpfV9leHBhbmRLZXkoZSl7Y29uc3QgdD10aGlzLl9zLGk9bmV3IFVpbnQ4QXJyYXkoMjQwKTtpLnNldChlKTtsZXQgYSxzLHIsbixvPTE7Zm9yKGxldCBlPTMyLGc9MTtlPDI0MDsrK2cpe2lmKGUlMzI9PTE2KXthPXRbYV07cz10W3NdO3I9dFtyXTtuPXRbbl19ZWxzZSBpZihlJTMyPT0wKXthPWlbZS0zXTtzPWlbZS0yXTtyPWlbZS0xXTtuPWlbZS00XTthPXRbYV07cz10W3NdO3I9dFtyXTtuPXRbbl07YV49bzsobzw8PTEpPj0yNTYmJihvPTI1NSYoMjdebykpfWZvcihsZXQgdD0wO3Q8NDsrK3Qpe2lbZV09YV49aVtlLTMyXTtlKys7aVtlXT1zXj1pW2UtMzJdO2UrKztpW2VdPXJePWlbZS0zMl07ZSsrO2lbZV09bl49aVtlLTMyXTtlKyt9fXJldHVybiBpfX1jbGFzcyBQREYxN3tjaGVja093bmVyUGFzc3dvcmQoZSx0LGksYSl7Y29uc3Qgcz1uZXcgVWludDhBcnJheShlLmxlbmd0aCs1Nik7cy5zZXQoZSwwKTtzLnNldCh0LGUubGVuZ3RoKTtzLnNldChpLGUubGVuZ3RoK3QubGVuZ3RoKTtyZXR1cm4gaXNBcnJheUVxdWFsKEpzKHMsMCxzLmxlbmd0aCksYSl9Y2hlY2tVc2VyUGFzc3dvcmQoZSx0LGkpe2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgrOCk7YS5zZXQoZSwwKTthLnNldCh0LGUubGVuZ3RoKTtyZXR1cm4gaXNBcnJheUVxdWFsKEpzKGEsMCxhLmxlbmd0aCksaSl9Z2V0T3duZXJLZXkoZSx0LGksYSl7Y29uc3Qgcz1uZXcgVWludDhBcnJheShlLmxlbmd0aCs1Nik7cy5zZXQoZSwwKTtzLnNldCh0LGUubGVuZ3RoKTtzLnNldChpLGUubGVuZ3RoK3QubGVuZ3RoKTtjb25zdCByPUpzKHMsMCxzLmxlbmd0aCk7cmV0dXJuIG5ldyBBRVMyNTZDaXBoZXIocikuZGVjcnlwdEJsb2NrKGEsITEsbmV3IFVpbnQ4QXJyYXkoMTYpKX1nZXRVc2VyS2V5KGUsdCxpKXtjb25zdCBhPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKzgpO2Euc2V0KGUsMCk7YS5zZXQodCxlLmxlbmd0aCk7Y29uc3Qgcz1KcyhhLDAsYS5sZW5ndGgpO3JldHVybiBuZXcgQUVTMjU2Q2lwaGVyKHMpLmRlY3J5cHRCbG9jayhpLCExLG5ldyBVaW50OEFycmF5KDE2KSl9fWNsYXNzIFBERjIwe19oYXNoKGUsdCxpKXtsZXQgYT1Kcyh0LDAsdC5sZW5ndGgpLnN1YmFycmF5KDAsMzIpLHM9WzBdLHI9MDtmb3IoO3I8NjR8fHMuYXQoLTEpPnItMzI7KXtjb25zdCB0PWUubGVuZ3RoK2EubGVuZ3RoK2kubGVuZ3RoLGM9bmV3IFVpbnQ4QXJyYXkodCk7bGV0IEM9MDtjLnNldChlLEMpO0MrPWUubGVuZ3RoO2Muc2V0KGEsQyk7Qys9YS5sZW5ndGg7Yy5zZXQoaSxDKTtjb25zdCBoPW5ldyBVaW50OEFycmF5KDY0KnQpO2ZvcihsZXQgZT0wLGk9MDtlPDY0O2UrKyxpKz10KWguc2V0KGMsaSk7cz1uZXcgQUVTMTI4Q2lwaGVyKGEuc3ViYXJyYXkoMCwxNikpLmVuY3J5cHQoaCxhLnN1YmFycmF5KDE2LDMyKSk7Y29uc3QgbD1zLnNsaWNlKDAsMTYpLnJlZHVjZSgoKGUsdCk9PmUrdCksMCklMzswPT09bD9hPUpzKHMsMCxzLmxlbmd0aCk6MT09PWw/YT0obj1zLG89MCxnPXMubGVuZ3RoLFlzKG4sbyxnLCEwKSk6Mj09PWwmJihhPVlzKHMsMCxzLmxlbmd0aCkpO3IrK312YXIgbixvLGc7cmV0dXJuIGEuc3ViYXJyYXkoMCwzMil9Y2hlY2tPd25lclBhc3N3b3JkKGUsdCxpLGEpe2NvbnN0IHM9bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgrNTYpO3Muc2V0KGUsMCk7cy5zZXQodCxlLmxlbmd0aCk7cy5zZXQoaSxlLmxlbmd0aCt0Lmxlbmd0aCk7cmV0dXJuIGlzQXJyYXlFcXVhbCh0aGlzLl9oYXNoKGUscyxpKSxhKX1jaGVja1VzZXJQYXNzd29yZChlLHQsaSl7Y29uc3QgYT1uZXcgVWludDhBcnJheShlLmxlbmd0aCs4KTthLnNldChlLDApO2Euc2V0KHQsZS5sZW5ndGgpO3JldHVybiBpc0FycmF5RXF1YWwodGhpcy5faGFzaChlLGEsW10pLGkpfWdldE93bmVyS2V5KGUsdCxpLGEpe2NvbnN0IHM9bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgrNTYpO3Muc2V0KGUsMCk7cy5zZXQodCxlLmxlbmd0aCk7cy5zZXQoaSxlLmxlbmd0aCt0Lmxlbmd0aCk7Y29uc3Qgcj10aGlzLl9oYXNoKGUscyxpKTtyZXR1cm4gbmV3IEFFUzI1NkNpcGhlcihyKS5kZWNyeXB0QmxvY2soYSwhMSxuZXcgVWludDhBcnJheSgxNikpfWdldFVzZXJLZXkoZSx0LGkpe2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgrOCk7YS5zZXQoZSwwKTthLnNldCh0LGUubGVuZ3RoKTtjb25zdCBzPXRoaXMuX2hhc2goZSxhLFtdKTtyZXR1cm4gbmV3IEFFUzI1NkNpcGhlcihzKS5kZWNyeXB0QmxvY2soaSwhMSxuZXcgVWludDhBcnJheSgxNikpfX1jbGFzcyBDaXBoZXJUcmFuc2Zvcm17Y29uc3RydWN0b3IoZSx0KXt0aGlzLlN0cmluZ0NpcGhlckNvbnN0cnVjdG9yPWU7dGhpcy5TdHJlYW1DaXBoZXJDb25zdHJ1Y3Rvcj10fWNyZWF0ZVN0cmVhbShlLHQpe2NvbnN0IGk9bmV3IHRoaXMuU3RyZWFtQ2lwaGVyQ29uc3RydWN0b3I7cmV0dXJuIG5ldyBEZWNyeXB0U3RyZWFtKGUsdCwoZnVuY3Rpb24gY2lwaGVyVHJhbnNmb3JtRGVjcnlwdFN0cmVhbShlLHQpe3JldHVybiBpLmRlY3J5cHRCbG9jayhlLHQpfSkpfWRlY3J5cHRTdHJpbmcoZSl7Y29uc3QgdD1uZXcgdGhpcy5TdHJpbmdDaXBoZXJDb25zdHJ1Y3RvcjtsZXQgaT1zdHJpbmdUb0J5dGVzKGUpO2k9dC5kZWNyeXB0QmxvY2soaSwhMCk7cmV0dXJuIGJ5dGVzVG9TdHJpbmcoaSl9ZW5jcnlwdFN0cmluZyhlKXtjb25zdCB0PW5ldyB0aGlzLlN0cmluZ0NpcGhlckNvbnN0cnVjdG9yO2lmKHQgaW5zdGFuY2VvZiBBRVNCYXNlQ2lwaGVyKXtjb25zdCBpPTE2LWUubGVuZ3RoJTE2O2UrPVN0cmluZy5mcm9tQ2hhckNvZGUoaSkucmVwZWF0KGkpO2NvbnN0IGE9bmV3IFVpbnQ4QXJyYXkoMTYpO2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgY3J5cHRvKWNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYSk7ZWxzZSBmb3IobGV0IGU9MDtlPDE2O2UrKylhW2VdPU1hdGguZmxvb3IoMjU2Kk1hdGgucmFuZG9tKCkpO2xldCBzPXN0cmluZ1RvQnl0ZXMoZSk7cz10LmVuY3J5cHQocyxhKTtjb25zdCByPW5ldyBVaW50OEFycmF5KDE2K3MubGVuZ3RoKTtyLnNldChhKTtyLnNldChzLDE2KTtyZXR1cm4gYnl0ZXNUb1N0cmluZyhyKX1sZXQgaT1zdHJpbmdUb0J5dGVzKGUpO2k9dC5lbmNyeXB0KGkpO3JldHVybiBieXRlc1RvU3RyaW5nKGkpfX1jbGFzcyBDaXBoZXJUcmFuc2Zvcm1GYWN0b3J5e3N0YXRpYyNiPW5ldyBVaW50OEFycmF5KFs0MCwxOTEsNzgsOTQsNzgsMTE3LDEzOCw2NSwxMDAsMCw3OCw4NiwyNTUsMjUwLDEsOCw0Niw0NiwwLDE4MiwyMDgsMTA0LDYyLDEyOCw0NywxMiwxNjksMjU0LDEwMCw4MywxMDUsMTIyXSk7I0QoZSx0LGksYSxzLHIsbixvLGcsYyxDLGgpe2lmKHQpe2NvbnN0IGU9TWF0aC5taW4oMTI3LHQubGVuZ3RoKTt0PXQuc3ViYXJyYXkoMCxlKX1lbHNlIHQ9W107Y29uc3QgbD02PT09ZT9uZXcgUERGMjA6bmV3IFBERjE3O3JldHVybiBsLmNoZWNrVXNlclBhc3N3b3JkKHQsbyxuKT9sLmdldFVzZXJLZXkodCxnLEMpOnQubGVuZ3RoJiZsLmNoZWNrT3duZXJQYXNzd29yZCh0LGEscixpKT9sLmdldE93bmVyS2V5KHQscyxyLGMpOm51bGx9I0YoZSx0LGksYSxzLHIsbixvKXtjb25zdCBnPTQwK2kubGVuZ3RoK2UubGVuZ3RoLGM9bmV3IFVpbnQ4QXJyYXkoZyk7bGV0IEMsaCxsPTA7aWYodCl7aD1NYXRoLm1pbigzMix0Lmxlbmd0aCk7Zm9yKDtsPGg7KytsKWNbbF09dFtsXX1DPTA7Zm9yKDtsPDMyOyljW2wrK109Q2lwaGVyVHJhbnNmb3JtRmFjdG9yeS4jYltDKytdO2ZvcihDPTAsaD1pLmxlbmd0aDtDPGg7KytDKWNbbCsrXT1pW0NdO2NbbCsrXT0yNTUmcztjW2wrK109cz4+OCYyNTU7Y1tsKytdPXM+PjE2JjI1NTtjW2wrK109cz4+PjI0JjI1NTtmb3IoQz0wLGg9ZS5sZW5ndGg7QzxoOysrQyljW2wrK109ZVtDXTtpZihyPj00JiYhbyl7Y1tsKytdPTI1NTtjW2wrK109MjU1O2NbbCsrXT0yNTU7Y1tsKytdPTI1NX1sZXQgUT1IcyhjLDAsbCk7Y29uc3QgRT1uPj4zO2lmKHI+PTMpZm9yKEM9MDtDPDUwOysrQylRPUhzKFEsMCxFKTtjb25zdCB1PVEuc3ViYXJyYXkoMCxFKTtsZXQgZCxmO2lmKHI+PTMpe2ZvcihsPTA7bDwzMjsrK2wpY1tsXT1DaXBoZXJUcmFuc2Zvcm1GYWN0b3J5LiNiW2xdO2ZvcihDPTAsaD1lLmxlbmd0aDtDPGg7KytDKWNbbCsrXT1lW0NdO2Q9bmV3IEFSQ0ZvdXJDaXBoZXIodSk7Zj1kLmVuY3J5cHRCbG9jayhIcyhjLDAsbCkpO2g9dS5sZW5ndGg7Y29uc3QgdD1uZXcgVWludDhBcnJheShoKTtmb3IoQz0xO0M8PTE5OysrQyl7Zm9yKGxldCBlPTA7ZTxoOysrZSl0W2VdPXVbZV1eQztkPW5ldyBBUkNGb3VyQ2lwaGVyKHQpO2Y9ZC5lbmNyeXB0QmxvY2soZil9Zm9yKEM9MCxoPWYubGVuZ3RoO0M8aDsrK0MpaWYoYVtDXSE9PWZbQ10pcmV0dXJuIG51bGx9ZWxzZXtkPW5ldyBBUkNGb3VyQ2lwaGVyKHUpO2Y9ZC5lbmNyeXB0QmxvY2soQ2lwaGVyVHJhbnNmb3JtRmFjdG9yeS4jYik7Zm9yKEM9MCxoPWYubGVuZ3RoO0M8aDsrK0MpaWYoYVtDXSE9PWZbQ10pcmV0dXJuIG51bGx9cmV0dXJuIHV9I1MoZSx0LGksYSl7Y29uc3Qgcz1uZXcgVWludDhBcnJheSgzMik7bGV0IHI9MDtjb25zdCBuPU1hdGgubWluKDMyLGUubGVuZ3RoKTtmb3IoO3I8bjsrK3Ipc1tyXT1lW3JdO2xldCBvPTA7Zm9yKDtyPDMyOylzW3IrK109Q2lwaGVyVHJhbnNmb3JtRmFjdG9yeS4jYltvKytdO2xldCBnPUhzKHMsMCxyKTtjb25zdCBjPWE+PjM7aWYoaT49Mylmb3Iobz0wO288NTA7KytvKWc9SHMoZywwLGcubGVuZ3RoKTtsZXQgQyxoO2lmKGk+PTMpe2g9dDtjb25zdCBlPW5ldyBVaW50OEFycmF5KGMpO2ZvcihvPTE5O28+PTA7by0tKXtmb3IobGV0IHQ9MDt0PGM7Kyt0KWVbdF09Z1t0XV5vO0M9bmV3IEFSQ0ZvdXJDaXBoZXIoZSk7aD1DLmVuY3J5cHRCbG9jayhoKX19ZWxzZXtDPW5ldyBBUkNGb3VyQ2lwaGVyKGcuc3ViYXJyYXkoMCxjKSk7aD1DLmVuY3J5cHRCbG9jayh0KX1yZXR1cm4gaH0jayhlLHQsaSxhPSExKXtjb25zdCBzPW5ldyBVaW50OEFycmF5KGkubGVuZ3RoKzkpLHI9aS5sZW5ndGg7bGV0IG47Zm9yKG49MDtuPHI7KytuKXNbbl09aVtuXTtzW24rK109MjU1JmU7c1tuKytdPWU+PjgmMjU1O3NbbisrXT1lPj4xNiYyNTU7c1tuKytdPTI1NSZ0O3NbbisrXT10Pj44JjI1NTtpZihhKXtzW24rK109MTE1O3NbbisrXT02NTtzW24rK109MTA4O3NbbisrXT04NH1yZXR1cm4gSHMocywwLG4pLnN1YmFycmF5KDAsTWF0aC5taW4oaS5sZW5ndGgrNSwxNikpfSNOKGUsdCxpLGEscyl7aWYoISh0IGluc3RhbmNlb2YgTmFtZSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIGNyeXB0IGZpbHRlciBuYW1lLiIpO2NvbnN0IHI9dGhpcyxuPWUuZ2V0KHQubmFtZSksbz1uPy5nZXQoIkNGTSIpO2lmKCFvfHwiTm9uZSI9PT1vLm5hbWUpcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBOdWxsQ2lwaGVyfTtpZigiVjIiPT09by5uYW1lKXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgQVJDRm91ckNpcGhlcihyLiNrKGksYSxzLCExKSl9O2lmKCJBRVNWMiI9PT1vLm5hbWUpcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBBRVMxMjhDaXBoZXIoci4jayhpLGEscywhMCkpfTtpZigiQUVTVjMiPT09by5uYW1lKXJldHVybiBmdW5jdGlvbigpe3JldHVybiBuZXcgQUVTMjU2Q2lwaGVyKHMpfTt0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlVua25vd24gY3J5cHRvIG1ldGhvZCIpfWNvbnN0cnVjdG9yKGUsdCxpKXtjb25zdCBhPWUuZ2V0KCJGaWx0ZXIiKTtpZighaXNOYW1lKGEsIlN0YW5kYXJkIikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJ1bmtub3duIGVuY3J5cHRpb24gbWV0aG9kIik7dGhpcy5maWx0ZXJOYW1lPWEubmFtZTt0aGlzLmRpY3Q9ZTtjb25zdCBzPWUuZ2V0KCJWIik7aWYoIU51bWJlci5pc0ludGVnZXIocyl8fDEhPT1zJiYyIT09cyYmNCE9PXMmJjUhPT1zKXRocm93IG5ldyBGb3JtYXRFcnJvcigidW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBhbGdvcml0aG0iKTt0aGlzLmFsZ29yaXRobT1zO2xldCByPWUuZ2V0KCJMZW5ndGgiKTtpZighcilpZihzPD0zKXI9NDA7ZWxzZXtjb25zdCB0PWUuZ2V0KCJDRiIpLGk9ZS5nZXQoIlN0bUYiKTtpZih0IGluc3RhbmNlb2YgRGljdCYmaSBpbnN0YW5jZW9mIE5hbWUpe3Quc3VwcHJlc3NFbmNyeXB0aW9uPSEwO2NvbnN0IGU9dC5nZXQoaS5uYW1lKTtyPWU/LmdldCgiTGVuZ3RoIil8fDEyODtyPDQwJiYocjw8PTMpfX1pZighTnVtYmVyLmlzSW50ZWdlcihyKXx8cjw0MHx8ciU4IT0wKXRocm93IG5ldyBGb3JtYXRFcnJvcigiaW52YWxpZCBrZXkgbGVuZ3RoIik7Y29uc3Qgbj1zdHJpbmdUb0J5dGVzKGUuZ2V0KCJPIikpLG89c3RyaW5nVG9CeXRlcyhlLmdldCgiVSIpKSxnPW4uc3ViYXJyYXkoMCwzMiksYz1vLnN1YmFycmF5KDAsMzIpLEM9ZS5nZXQoIlAiKSxoPWUuZ2V0KCJSIiksbD0oND09PXN8fDU9PT1zKSYmITEhPT1lLmdldCgiRW5jcnlwdE1ldGFkYXRhIik7dGhpcy5lbmNyeXB0TWV0YWRhdGE9bDtjb25zdCBRPXN0cmluZ1RvQnl0ZXModCk7bGV0IEUsdTtpZihpKXtpZig2PT09aCl0cnl7aT11dGY4U3RyaW5nVG9TdHJpbmcoaSl9Y2F0Y2h7d2FybigiQ2lwaGVyVHJhbnNmb3JtRmFjdG9yeTogVW5hYmxlIHRvIGNvbnZlcnQgVVRGOCBlbmNvZGVkIHBhc3N3b3JkLiIpfUU9c3RyaW5nVG9CeXRlcyhpKX1pZig1IT09cyl1PXRoaXMuI0YoUSxFLGcsYyxDLGgscixsKTtlbHNle2NvbnN0IHQ9bi5zdWJhcnJheSgzMiw0MCksaT1uLnN1YmFycmF5KDQwLDQ4KSxhPW8uc3ViYXJyYXkoMCw0OCkscz1vLnN1YmFycmF5KDMyLDQwKSxyPW8uc3ViYXJyYXkoNDAsNDgpLEM9c3RyaW5nVG9CeXRlcyhlLmdldCgiT0UiKSksbD1zdHJpbmdUb0J5dGVzKGUuZ2V0KCJVRSIpKSxRPXN0cmluZ1RvQnl0ZXMoZS5nZXQoIlBlcm1zIikpO3U9dGhpcy4jRChoLEUsZyx0LGksYSxjLHMscixDLGwsUSl9aWYoIXUmJiFpKXRocm93IG5ldyBQYXNzd29yZEV4Y2VwdGlvbigiTm8gcGFzc3dvcmQgZ2l2ZW4iLGl0KTtpZighdSYmaSl7Y29uc3QgZT10aGlzLiNTKEUsZyxoLHIpO3U9dGhpcy4jRihRLGUsZyxjLEMsaCxyLGwpfWlmKCF1KXRocm93IG5ldyBQYXNzd29yZEV4Y2VwdGlvbigiSW5jb3JyZWN0IFBhc3N3b3JkIixhdCk7dGhpcy5lbmNyeXB0aW9uS2V5PXU7aWYocz49NCl7Y29uc3QgdD1lLmdldCgiQ0YiKTt0IGluc3RhbmNlb2YgRGljdCYmKHQuc3VwcHJlc3NFbmNyeXB0aW9uPSEwKTt0aGlzLmNmPXQ7dGhpcy5zdG1mPWUuZ2V0KCJTdG1GIil8fE5hbWUuZ2V0KCJJZGVudGl0eSIpO3RoaXMuc3RyZj1lLmdldCgiU3RyRiIpfHxOYW1lLmdldCgiSWRlbnRpdHkiKTt0aGlzLmVmZj1lLmdldCgiRUZGIil8fHRoaXMuc3RtZn19Y3JlYXRlQ2lwaGVyVHJhbnNmb3JtKGUsdCl7aWYoND09PXRoaXMuYWxnb3JpdGhtfHw1PT09dGhpcy5hbGdvcml0aG0pcmV0dXJuIG5ldyBDaXBoZXJUcmFuc2Zvcm0odGhpcy4jTih0aGlzLmNmLHRoaXMuc3RyZixlLHQsdGhpcy5lbmNyeXB0aW9uS2V5KSx0aGlzLiNOKHRoaXMuY2YsdGhpcy5zdG1mLGUsdCx0aGlzLmVuY3J5cHRpb25LZXkpKTtjb25zdCBpPXRoaXMuI2soZSx0LHRoaXMuZW5jcnlwdGlvbktleSwhMSksY2lwaGVyQ29uc3RydWN0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEFSQ0ZvdXJDaXBoZXIoaSl9O3JldHVybiBuZXcgQ2lwaGVyVHJhbnNmb3JtKGNpcGhlckNvbnN0cnVjdG9yLGNpcGhlckNvbnN0cnVjdG9yKX19YXN5bmMgZnVuY3Rpb24gd3JpdGVPYmplY3QoZSx0LGkse2VuY3J5cHQ6YT1udWxsfSl7Y29uc3Qgcz1hPy5jcmVhdGVDaXBoZXJUcmFuc2Zvcm0oZS5udW0sZS5nZW4pO2kucHVzaChgJHtlLm51bX0gJHtlLmdlbn0gb2JqXG5gKTt0IGluc3RhbmNlb2YgRGljdD9hd2FpdCB3cml0ZURpY3QodCxpLHMpOnQgaW5zdGFuY2VvZiBCYXNlU3RyZWFtP2F3YWl0IHdyaXRlU3RyZWFtKHQsaSxzKTooQXJyYXkuaXNBcnJheSh0KXx8QXJyYXlCdWZmZXIuaXNWaWV3KHQpKSYmYXdhaXQgd3JpdGVBcnJheSh0LGkscyk7aS5wdXNoKCJcbmVuZG9ialxuIil9YXN5bmMgZnVuY3Rpb24gd3JpdGVEaWN0KGUsdCxpKXt0LnB1c2goIjw8Iik7Zm9yKGNvbnN0IGEgb2YgZS5nZXRLZXlzKCkpe3QucHVzaChgIC8ke2VzY2FwZVBERk5hbWUoYSl9IGApO2F3YWl0IHdyaXRlVmFsdWUoZS5nZXRSYXcoYSksdCxpKX10LnB1c2goIj4+Iil9YXN5bmMgZnVuY3Rpb24gd3JpdGVTdHJlYW0oZSx0LGkpe2xldCBhPWUuZ2V0Qnl0ZXMoKTtjb25zdHtkaWN0OnN9PWUsW3Isbl09YXdhaXQgUHJvbWlzZS5hbGwoW3MuZ2V0QXN5bmMoIkZpbHRlciIpLHMuZ2V0QXN5bmMoIkRlY29kZVBhcm1zIildKSxvPWlzTmFtZShBcnJheS5pc0FycmF5KHIpP2F3YWl0IHMueHJlZi5mZXRjaElmUmVmQXN5bmMoclswXSk6ciwiRmxhdGVEZWNvZGUiKTtpZihhLmxlbmd0aD49MjU2fHxvKXRyeXtjb25zdCBlPW5ldyBDb21wcmVzc2lvblN0cmVhbSgiZGVmbGF0ZSIpLHQ9ZS53cml0YWJsZS5nZXRXcml0ZXIoKTt0LndyaXRlKGEpO3QuY2xvc2UoKTtjb25zdCBpPWF3YWl0IG5ldyBSZXNwb25zZShlLnJlYWRhYmxlKS5hcnJheUJ1ZmZlcigpO2E9bmV3IFVpbnQ4QXJyYXkoaSk7bGV0IGcsYztpZihyKXtpZighbyl7Zz1BcnJheS5pc0FycmF5KHIpP1tOYW1lLmdldCgiRmxhdGVEZWNvZGUiKSwuLi5yXTpbTmFtZS5nZXQoIkZsYXRlRGVjb2RlIikscl07biYmKGM9QXJyYXkuaXNBcnJheShuKT9bbnVsbCwuLi5uXTpbbnVsbCxuXSl9fWVsc2UgZz1OYW1lLmdldCgiRmxhdGVEZWNvZGUiKTtnJiZzLnNldCgiRmlsdGVyIixnKTtjJiZzLnNldCgiRGVjb2RlUGFybXMiLGMpfWNhdGNoKGUpe2luZm8oYHdyaXRlU3RyZWFtIC0gY2Fubm90IGNvbXByZXNzIGRhdGE6ICIke2V9Ii5gKX1sZXQgZz1ieXRlc1RvU3RyaW5nKGEpO2kmJihnPWkuZW5jcnlwdFN0cmluZyhnKSk7cy5zZXQoIkxlbmd0aCIsZy5sZW5ndGgpO2F3YWl0IHdyaXRlRGljdChzLHQsaSk7dC5wdXNoKCIgc3RyZWFtXG4iLGcsIlxuZW5kc3RyZWFtIil9YXN5bmMgZnVuY3Rpb24gd3JpdGVBcnJheShlLHQsaSl7dC5wdXNoKCJbIik7bGV0IGE9ITA7Zm9yKGNvbnN0IHMgb2YgZSl7YT9hPSExOnQucHVzaCgiICIpO2F3YWl0IHdyaXRlVmFsdWUocyx0LGkpfXQucHVzaCgiXSIpfWFzeW5jIGZ1bmN0aW9uIHdyaXRlVmFsdWUoZSx0LGkpe2lmKGUgaW5zdGFuY2VvZiBOYW1lKXQucHVzaChgLyR7ZXNjYXBlUERGTmFtZShlLm5hbWUpfWApO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIFJlZil0LnB1c2goYCR7ZS5udW19ICR7ZS5nZW59IFJgKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkoZSl8fEFycmF5QnVmZmVyLmlzVmlldyhlKSlhd2FpdCB3cml0ZUFycmF5KGUsdCxpKTtlbHNlIGlmKCJzdHJpbmciPT10eXBlb2YgZSl7aSYmKGU9aS5lbmNyeXB0U3RyaW5nKGUpKTt0LnB1c2goYCgke2VzY2FwZVN0cmluZyhlKX0pYCl9ZWxzZSJudW1iZXIiPT10eXBlb2YgZT90LnB1c2gobnVtYmVyVG9TdHJpbmcoZSkpOiJib29sZWFuIj09dHlwZW9mIGU/dC5wdXNoKGUudG9TdHJpbmcoKSk6ZSBpbnN0YW5jZW9mIERpY3Q/YXdhaXQgd3JpdGVEaWN0KGUsdCxpKTplIGluc3RhbmNlb2YgQmFzZVN0cmVhbT9hd2FpdCB3cml0ZVN0cmVhbShlLHQsaSk6bnVsbD09PWU/dC5wdXNoKCJudWxsIik6d2FybihgVW5oYW5kbGVkIHZhbHVlIGluIHdyaXRlcjogJHt0eXBlb2YgZX0sIHBsZWFzZSBmaWxlIGEgYnVnLmApfWZ1bmN0aW9uIHdyaXRlSW50KGUsdCxpLGEpe2ZvcihsZXQgcz10K2ktMTtzPmktMTtzLS0pe2Fbc109MjU1JmU7ZT4+PTh9cmV0dXJuIGkrdH1mdW5jdGlvbiB3cml0ZVN0cmluZyhlLHQsaSl7Zm9yKGxldCBhPTAscz1lLmxlbmd0aDthPHM7YSsrKWlbdCthXT0yNTUmZS5jaGFyQ29kZUF0KGEpfWZ1bmN0aW9uIHVwZGF0ZVhGQSh7eGZhRGF0YTplLHhmYURhdGFzZXRzUmVmOnQsbmV3UmVmczppLHhyZWY6YX0pe2lmKG51bGw9PT1lKXtlPWZ1bmN0aW9uIHdyaXRlWEZBRGF0YUZvckFjcm9mb3JtKGUsdCl7Y29uc3QgaT1uZXcgU2ltcGxlWE1MUGFyc2VyKHtoYXNBdHRyaWJ1dGVzOiEwfSkucGFyc2VGcm9tU3RyaW5nKGUpO2Zvcihjb25zdHt4ZmE6ZX1vZiB0KXtpZighZSljb250aW51ZTtjb25zdHtwYXRoOnQsdmFsdWU6YX09ZTtpZighdCljb250aW51ZTtjb25zdCBzPXBhcnNlWEZBUGF0aCh0KTtsZXQgcj1pLmRvY3VtZW50RWxlbWVudC5zZWFyY2hOb2RlKHMsMCk7IXImJnMubGVuZ3RoPjEmJihyPWkuZG9jdW1lbnRFbGVtZW50LnNlYXJjaE5vZGUoW3MuYXQoLTEpXSwwKSk7cj9yLmNoaWxkTm9kZXM9QXJyYXkuaXNBcnJheShhKT9hLm1hcCgoZT0+bmV3IFNpbXBsZURPTU5vZGUoInZhbHVlIixlKSkpOltuZXcgU2ltcGxlRE9NTm9kZSgiI3RleHQiLGEpXTp3YXJuKGBOb2RlIG5vdCBmb3VuZCBmb3IgcGF0aDogJHt0fWApfWNvbnN0IGE9W107aS5kb2N1bWVudEVsZW1lbnQuZHVtcChhKTtyZXR1cm4gYS5qb2luKCIiKX0oYS5mZXRjaElmUmVmKHQpLmdldFN0cmluZygpLGkpfWNvbnN0IHM9YS5lbmNyeXB0O2lmKHMpe2U9cy5jcmVhdGVDaXBoZXJUcmFuc2Zvcm0odC5udW0sdC5nZW4pLmVuY3J5cHRTdHJpbmcoZSl9Y29uc3Qgcj1gJHt0Lm51bX0gJHt0Lmdlbn0gb2JqXG48PCAvVHlwZSAvRW1iZWRkZWRGaWxlIC9MZW5ndGggJHtlLmxlbmd0aH0+Plxuc3RyZWFtXG5gK2UrIlxuZW5kc3RyZWFtXG5lbmRvYmpcbiI7aS5wdXNoKHtyZWY6dCxkYXRhOnJ9KX1mdW5jdGlvbiBnZXRJbmRleGVzKGUpe2NvbnN0IHQ9W107Zm9yKGNvbnN0e3JlZjppfW9mIGUpaS5udW09PT10LmF0KC0yKSt0LmF0KC0xKT90W3QubGVuZ3RoLTFdKz0xOnQucHVzaChpLm51bSwxKTtyZXR1cm4gdH1mdW5jdGlvbiBjb21wdXRlSURzKGUsdCxpKXtpZihBcnJheS5pc0FycmF5KHQuZmlsZUlkcykmJnQuZmlsZUlkcy5sZW5ndGg+MCl7Y29uc3QgYT1mdW5jdGlvbiBjb21wdXRlTUQ1KGUsdCl7Y29uc3QgaT1NYXRoLmZsb29yKERhdGUubm93KCkvMWUzKSxhPXQuZmlsZW5hbWV8fCIiLHM9W2kudG9TdHJpbmcoKSxhLGUudG9TdHJpbmcoKV07bGV0IHI9cy5yZWR1Y2UoKChlLHQpPT5lK3QubGVuZ3RoKSwwKTtmb3IoY29uc3QgZSBvZiBPYmplY3QudmFsdWVzKHQuaW5mbykpe3MucHVzaChlKTtyKz1lLmxlbmd0aH1jb25zdCBuPW5ldyBVaW50OEFycmF5KHIpO2xldCBvPTA7Zm9yKGNvbnN0IGUgb2Ygcyl7d3JpdGVTdHJpbmcoZSxvLG4pO28rPWUubGVuZ3RofXJldHVybiBieXRlc1RvU3RyaW5nKEhzKG4pKX0oZSx0KTtpLnNldCgiSUQiLFt0LmZpbGVJZHNbMF0sYV0pfX1hc3luYyBmdW5jdGlvbiBpbmNyZW1lbnRhbFVwZGF0ZSh7b3JpZ2luYWxEYXRhOmUseHJlZkluZm86dCxuZXdSZWZzOmkseHJlZjphPW51bGwsaGFzWGZhOnM9ITEseGZhRGF0YXNldHNSZWY6cj1udWxsLGhhc1hmYURhdGFzZXRzRW50cnk6bj0hMSxuZWVkQXBwZWFyYW5jZXM6byxhY3JvRm9ybVJlZjpnPW51bGwsYWNyb0Zvcm06Yz1udWxsLHhmYURhdGE6Qz1udWxsLHVzZVhyZWZTdHJlYW06aD0hMX0pe2F3YWl0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUFjcm9mb3JtKHt4cmVmOmUsYWNyb0Zvcm06dCxhY3JvRm9ybVJlZjppLGhhc1hmYTphLGhhc1hmYURhdGFzZXRzRW50cnk6cyx4ZmFEYXRhc2V0c1JlZjpyLG5lZWRBcHBlYXJhbmNlczpuLG5ld1JlZnM6b30peyFhfHxzfHxyfHx3YXJuKCJYRkEgLSBDYW5ub3Qgc2F2ZSBpdCIpO2lmKCFuJiYoIWF8fCFyfHxzKSlyZXR1cm47Y29uc3QgZz10LmNsb25lKCk7aWYoYSYmIXMpe2NvbnN0IGU9dC5nZXQoIlhGQSIpLnNsaWNlKCk7ZS5zcGxpY2UoMiwwLCJkYXRhc2V0cyIpO2Uuc3BsaWNlKDMsMCxyKTtnLnNldCgiWEZBIixlKX1uJiZnLnNldCgiTmVlZEFwcGVhcmFuY2VzIiwhMCk7Y29uc3QgYz1bXTthd2FpdCB3cml0ZU9iamVjdChpLGcsYyxlKTtvLnB1c2goe3JlZjppLGRhdGE6Yy5qb2luKCIiKX0pfSh7eHJlZjphLGFjcm9Gb3JtOmMsYWNyb0Zvcm1SZWY6ZyxoYXNYZmE6cyxoYXNYZmFEYXRhc2V0c0VudHJ5Om4seGZhRGF0YXNldHNSZWY6cixuZWVkQXBwZWFyYW5jZXM6byxuZXdSZWZzOml9KTtzJiZ1cGRhdGVYRkEoe3hmYURhdGE6Qyx4ZmFEYXRhc2V0c1JlZjpyLG5ld1JlZnM6aSx4cmVmOmF9KTtjb25zdCBsPVtdO2xldCBRPWUubGVuZ3RoO2NvbnN0IEU9ZS5hdCgtMSk7aWYoMTAhPT1FJiYxMyE9PUUpe2wucHVzaCgiXG4iKTtRKz0xfWNvbnN0IHU9ZnVuY3Rpb24gZ2V0VHJhaWxlckRpY3QoZSx0LGkpe2NvbnN0IGE9bmV3IERpY3QobnVsbCk7YS5zZXQoIlByZXYiLGUuc3RhcnRYUmVmKTtjb25zdCBzPWUubmV3UmVmO2lmKGkpe3QucHVzaCh7cmVmOnMsZGF0YToiIn0pO2Euc2V0KCJTaXplIixzLm51bSsxKTthLnNldCgiVHlwZSIsTmFtZS5nZXQoIlhSZWYiKSl9ZWxzZSBhLnNldCgiU2l6ZSIscy5udW0pO251bGwhPT1lLnJvb3RSZWYmJmEuc2V0KCJSb290IixlLnJvb3RSZWYpO251bGwhPT1lLmluZm9SZWYmJmEuc2V0KCJJbmZvIixlLmluZm9SZWYpO251bGwhPT1lLmVuY3J5cHRSZWYmJmEuc2V0KCJFbmNyeXB0IixlLmVuY3J5cHRSZWYpO3JldHVybiBhfSh0LGksaCk7aT1pLnNvcnQoKChlLHQpPT5lLnJlZi5udW0tdC5yZWYubnVtKSk7Zm9yKGNvbnN0e2RhdGE6ZX1vZiBpKW51bGwhPT1lJiZsLnB1c2goZSk7YXdhaXQoaD9hc3luYyBmdW5jdGlvbiBnZXRYUmVmU3RyZWFtVGFibGUoZSx0LGksYSxzKXtjb25zdCByPVtdO2xldCBuPTAsbz0wO2Zvcihjb25zdHtyZWY6ZSxkYXRhOmF9b2YgaSl7bGV0IGk7bj1NYXRoLm1heChuLHQpO2lmKG51bGwhPT1hKXtpPU1hdGgubWluKGUuZ2VuLDY1NTM1KTtyLnB1c2goWzEsdCxpXSk7dCs9YS5sZW5ndGh9ZWxzZXtpPU1hdGgubWluKGUuZ2VuKzEsNjU1MzUpO3IucHVzaChbMCwwLGldKX1vPU1hdGgubWF4KG8saSl9YS5zZXQoIkluZGV4IixnZXRJbmRleGVzKGkpKTtjb25zdCBnPVsxLGdldFNpemVJbkJ5dGVzKG4pLGdldFNpemVJbkJ5dGVzKG8pXTthLnNldCgiVyIsZyk7Y29tcHV0ZUlEcyh0LGUsYSk7Y29uc3QgYz1nLnJlZHVjZSgoKGUsdCk9PmUrdCksMCksQz1uZXcgVWludDhBcnJheShjKnIubGVuZ3RoKSxoPW5ldyBTdHJlYW0oQyk7aC5kaWN0PWE7bGV0IGw9MDtmb3IoY29uc3RbZSx0LGldb2Ygcil7bD13cml0ZUludChlLGdbMF0sbCxDKTtsPXdyaXRlSW50KHQsZ1sxXSxsLEMpO2w9d3JpdGVJbnQoaSxnWzJdLGwsQyl9YXdhaXQgd3JpdGVPYmplY3QoZS5uZXdSZWYsaCxzLHt9KTtzLnB1c2goInN0YXJ0eHJlZlxuIix0LnRvU3RyaW5nKCksIlxuJSVFT0ZcbiIpfSh0LFEsaSx1LGwpOmFzeW5jIGZ1bmN0aW9uIGdldFhSZWZUYWJsZShlLHQsaSxhLHMpe3MucHVzaCgieHJlZlxuIik7Y29uc3Qgcj1nZXRJbmRleGVzKGkpO2xldCBuPTA7Zm9yKGNvbnN0e3JlZjplLGRhdGE6YX1vZiBpKXtpZihlLm51bT09PXJbbl0pe3MucHVzaChgJHtyW25dfSAke3JbbisxXX1cbmApO24rPTJ9aWYobnVsbCE9PWEpe3MucHVzaChgJHt0LnRvU3RyaW5nKCkucGFkU3RhcnQoMTAsIjAiKX0gJHtNYXRoLm1pbihlLmdlbiw2NTUzNSkudG9TdHJpbmcoKS5wYWRTdGFydCg1LCIwIil9IG5cclxuYCk7dCs9YS5sZW5ndGh9ZWxzZSBzLnB1c2goYDAwMDAwMDAwMDAgJHtNYXRoLm1pbihlLmdlbisxLDY1NTM1KS50b1N0cmluZygpLnBhZFN0YXJ0KDUsIjAiKX0gZlxyXG5gKX1jb21wdXRlSURzKHQsZSxhKTtzLnB1c2goInRyYWlsZXJcbiIpO2F3YWl0IHdyaXRlRGljdChhLHMpO3MucHVzaCgiXG5zdGFydHhyZWZcbiIsdC50b1N0cmluZygpLCJcbiUlRU9GXG4iKX0odCxRLGksdSxsKSk7Y29uc3QgZD1sLnJlZHVjZSgoKGUsdCk9PmUrdC5sZW5ndGgpLGUubGVuZ3RoKSxmPW5ldyBVaW50OEFycmF5KGQpO2Yuc2V0KGUpO2xldCBwPWUubGVuZ3RoO2Zvcihjb25zdCBlIG9mIGwpe3dyaXRlU3RyaW5nKGUscCxmKTtwKz1lLmxlbmd0aH1yZXR1cm4gZn1jb25zdCB2cz0xLEtzPTIsVHM9Myxxcz00LE9zPTU7Y2xhc3MgU3RydWN0VHJlZVJvb3R7Y29uc3RydWN0b3IoZSx0KXt0aGlzLmRpY3Q9ZTt0aGlzLnJlZj10IGluc3RhbmNlb2YgUmVmP3Q6bnVsbDt0aGlzLnJvbGVNYXA9bmV3IE1hcDt0aGlzLnN0cnVjdFBhcmVudElkcz1udWxsfWluaXQoKXt0aGlzLnJlYWRSb2xlTWFwKCl9I1IoZSx0LGkpe2lmKCEoZSBpbnN0YW5jZW9mIFJlZil8fHQ8MClyZXR1cm47dGhpcy5zdHJ1Y3RQYXJlbnRJZHN8fD1uZXcgUmVmU2V0Q2FjaGU7bGV0IGE9dGhpcy5zdHJ1Y3RQYXJlbnRJZHMuZ2V0KGUpO2lmKCFhKXthPVtdO3RoaXMuc3RydWN0UGFyZW50SWRzLnB1dChlLGEpfWEucHVzaChbdCxpXSl9YWRkQW5ub3RhdGlvbklkVG9QYWdlKGUsdCl7dGhpcy4jUihlLHQscXMpfXJlYWRSb2xlTWFwKCl7Y29uc3QgZT10aGlzLmRpY3QuZ2V0KCJSb2xlTWFwIik7ZSBpbnN0YW5jZW9mIERpY3QmJmUuZm9yRWFjaCgoKGUsdCk9Pnt0IGluc3RhbmNlb2YgTmFtZSYmdGhpcy5yb2xlTWFwLnNldChlLHQubmFtZSl9KSl9c3RhdGljIGFzeW5jIGNhbkNyZWF0ZVN0cnVjdHVyZVRyZWUoe2NhdGFsb2dSZWY6ZSxwZGZNYW5hZ2VyOnQsbmV3QW5ub3RhdGlvbnNCeVBhZ2U6aX0pe2lmKCEoZSBpbnN0YW5jZW9mIFJlZikpe3dhcm4oIkNhbm5vdCBzYXZlIHRoZSBzdHJ1Y3QgdHJlZTogbm8gY2F0YWxvZyByZWZlcmVuY2UuIik7cmV0dXJuITF9bGV0IGE9MCxzPSEwO2Zvcihjb25zdFtlLHJdb2YgaSl7Y29uc3R7cmVmOml9PWF3YWl0IHQuZ2V0UGFnZShlKTtpZighKGkgaW5zdGFuY2VvZiBSZWYpKXt3YXJuKGBDYW5ub3Qgc2F2ZSB0aGUgc3RydWN0IHRyZWU6IHBhZ2UgJHtlfSBoYXMgbm8gcmVmLmApO3M9ITA7YnJlYWt9Zm9yKGNvbnN0IGUgb2YgcilpZihlLmFjY2Vzc2liaWxpdHlEYXRhPy50eXBlKXtlLnBhcmVudFRyZWVJZD1hKys7cz0hMX19aWYocyl7Zm9yKGNvbnN0IGUgb2YgaS52YWx1ZXMoKSlmb3IoY29uc3QgdCBvZiBlKWRlbGV0ZSB0LnBhcmVudFRyZWVJZDtyZXR1cm4hMX1yZXR1cm4hMH1zdGF0aWMgYXN5bmMgY3JlYXRlU3RydWN0dXJlVHJlZSh7bmV3QW5ub3RhdGlvbnNCeVBhZ2U6ZSx4cmVmOnQsY2F0YWxvZ1JlZjppLHBkZk1hbmFnZXI6YSxuZXdSZWZzOnN9KXtjb25zdCByPWEuY2F0YWxvZy5jbG9uZURpY3QoKSxuPW5ldyBSZWZTZXRDYWNoZTtuLnB1dChpLHIpO2NvbnN0IG89dC5nZXROZXdUZW1wb3JhcnlSZWYoKTtyLnNldCgiU3RydWN0VHJlZVJvb3QiLG8pO2NvbnN0IGc9bmV3IERpY3QodCk7Zy5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJTdHJ1Y3RUcmVlUm9vdCIpKTtjb25zdCBjPXQuZ2V0TmV3VGVtcG9yYXJ5UmVmKCk7Zy5zZXQoIlBhcmVudFRyZWUiLGMpO2NvbnN0IEM9W107Zy5zZXQoIksiLEMpO24ucHV0KG8sZyk7Y29uc3QgaD1uZXcgRGljdCh0KSxsPVtdO2guc2V0KCJOdW1zIixsKTtjb25zdCBRPWF3YWl0IHRoaXMuI0coe25ld0Fubm90YXRpb25zQnlQYWdlOmUsc3RydWN0VHJlZVJvb3RSZWY6byxraWRzOkMsbnVtczpsLHhyZWY6dCxwZGZNYW5hZ2VyOmEsY2FjaGU6bn0pO2cuc2V0KCJQYXJlbnRUcmVlTmV4dEtleSIsUSk7bi5wdXQoYyxoKTtjb25zdCBFPVtdO2Zvcihjb25zdFtlLGldb2Ygbi5pdGVtcygpKXtFLmxlbmd0aD0wO2F3YWl0IHdyaXRlT2JqZWN0KGUsaSxFLHQpO3MucHVzaCh7cmVmOmUsZGF0YTpFLmpvaW4oIiIpfSl9fWFzeW5jIGNhblVwZGF0ZVN0cnVjdFRyZWUoe3BkZk1hbmFnZXI6ZSx4cmVmOnQsbmV3QW5ub3RhdGlvbnNCeVBhZ2U6aX0pe2lmKCF0aGlzLnJlZil7d2FybigiQ2Fubm90IHVwZGF0ZSB0aGUgc3RydWN0IHRyZWU6IG5vIHJvb3QgcmVmZXJlbmNlLiIpO3JldHVybiExfWxldCBhPXRoaXMuZGljdC5nZXQoIlBhcmVudFRyZWVOZXh0S2V5Iik7aWYoIU51bWJlci5pc0ludGVnZXIoYSl8fGE8MCl7d2FybigiQ2Fubm90IHVwZGF0ZSB0aGUgc3RydWN0IHRyZWU6IGludmFsaWQgbmV4dCBrZXkuIik7cmV0dXJuITF9Y29uc3Qgcz10aGlzLmRpY3QuZ2V0KCJQYXJlbnRUcmVlIik7aWYoIShzIGluc3RhbmNlb2YgRGljdCkpe3dhcm4oIkNhbm5vdCB1cGRhdGUgdGhlIHN0cnVjdCB0cmVlOiBQYXJlbnRUcmVlIGlzbid0IGEgZGljdC4iKTtyZXR1cm4hMX1jb25zdCByPXMuZ2V0KCJOdW1zIik7aWYoIUFycmF5LmlzQXJyYXkocikpe3dhcm4oIkNhbm5vdCB1cGRhdGUgdGhlIHN0cnVjdCB0cmVlOiBudW1zIGlzbid0IGFuIGFycmF5LiIpO3JldHVybiExfWNvbnN0IG49bmV3IE51bWJlclRyZWUocyx0KTtmb3IoY29uc3QgdCBvZiBpLmtleXMoKSl7Y29uc3R7cGFnZURpY3Q6aX09YXdhaXQgZS5nZXRQYWdlKHQpO2lmKCFpLmhhcygiU3RydWN0UGFyZW50cyIpKWNvbnRpbnVlO2NvbnN0IGE9aS5nZXQoIlN0cnVjdFBhcmVudHMiKTtpZighTnVtYmVyLmlzSW50ZWdlcihhKXx8IUFycmF5LmlzQXJyYXkobi5nZXQoYSkpKXt3YXJuKGBDYW5ub3Qgc2F2ZSB0aGUgc3RydWN0IHRyZWU6IHBhZ2UgJHt0fSBoYXMgYSB3cm9uZyBpZC5gKTtyZXR1cm4hMX19bGV0IG89ITA7Zm9yKGNvbnN0W3Qsc11vZiBpKXtjb25zdHtwYWdlRGljdDppfT1hd2FpdCBlLmdldFBhZ2UodCk7U3RydWN0VHJlZVJvb3QuI3goe2VsZW1lbnRzOnMseHJlZjp0aGlzLmRpY3QueHJlZixwYWdlRGljdDppLG51bWJlclRyZWU6bn0pO2Zvcihjb25zdCBlIG9mIHMpaWYoZS5hY2Nlc3NpYmlsaXR5RGF0YT8udHlwZSl7ZS5wYXJlbnRUcmVlSWQ9YSsrO289ITF9fWlmKG8pe2Zvcihjb25zdCBlIG9mIGkudmFsdWVzKCkpZm9yKGNvbnN0IHQgb2YgZSl7ZGVsZXRlIHQucGFyZW50VHJlZUlkO2RlbGV0ZSB0LnN0cnVjdFRyZWVQYXJlbnR9cmV0dXJuITF9cmV0dXJuITB9YXN5bmMgdXBkYXRlU3RydWN0dXJlVHJlZSh7bmV3QW5ub3RhdGlvbnNCeVBhZ2U6ZSxwZGZNYW5hZ2VyOnQsbmV3UmVmczppfSl7Y29uc3QgYT10aGlzLmRpY3QueHJlZixzPXRoaXMuZGljdC5jbG9uZSgpLHI9dGhpcy5yZWYsbj1uZXcgUmVmU2V0Q2FjaGU7bi5wdXQocixzKTtsZXQgbyxnPXMuZ2V0UmF3KCJQYXJlbnRUcmVlIik7aWYoZyBpbnN0YW5jZW9mIFJlZilvPWEuZmV0Y2goZyk7ZWxzZXtvPWc7Zz1hLmdldE5ld1RlbXBvcmFyeVJlZigpO3Muc2V0KCJQYXJlbnRUcmVlIixnKX1vPW8uY2xvbmUoKTtuLnB1dChnLG8pO2xldCBjPW8uZ2V0UmF3KCJOdW1zIiksQz1udWxsO2lmKGMgaW5zdGFuY2VvZiBSZWYpe0M9YztjPWEuZmV0Y2goQyl9Yz1jLnNsaWNlKCk7Q3x8by5zZXQoIk51bXMiLGMpO2NvbnN0IGg9YXdhaXQgU3RydWN0VHJlZVJvb3QuI0coe25ld0Fubm90YXRpb25zQnlQYWdlOmUsc3RydWN0VHJlZVJvb3RSZWY6cixraWRzOm51bGwsbnVtczpjLHhyZWY6YSxwZGZNYW5hZ2VyOnQsY2FjaGU6bn0pO3Muc2V0KCJQYXJlbnRUcmVlTmV4dEtleSIsaCk7QyYmbi5wdXQoQyxjKTtjb25zdCBsPVtdO2Zvcihjb25zdFtlLHRdb2Ygbi5pdGVtcygpKXtsLmxlbmd0aD0wO2F3YWl0IHdyaXRlT2JqZWN0KGUsdCxsLGEpO2kucHVzaCh7cmVmOmUsZGF0YTpsLmpvaW4oIiIpfSl9fXN0YXRpYyBhc3luYyNHKHtuZXdBbm5vdGF0aW9uc0J5UGFnZTplLHN0cnVjdFRyZWVSb290UmVmOnQsa2lkczppLG51bXM6YSx4cmVmOnMscGRmTWFuYWdlcjpyLGNhY2hlOm59KXtjb25zdCBvPU5hbWUuZ2V0KCJPQkpSIik7bGV0IGc9LTEvMDtmb3IoY29uc3RbYyxDXW9mIGUpe2NvbnN0e3JlZjplfT1hd2FpdCByLmdldFBhZ2UoYyksaD1lIGluc3RhbmNlb2YgUmVmO2Zvcihjb25zdHthY2Nlc3NpYmlsaXR5RGF0YTpyLHJlZjpjLHBhcmVudFRyZWVJZDpsLHN0cnVjdFRyZWVQYXJlbnQ6UX1vZiBDKXtpZighcj8udHlwZSljb250aW51ZTtjb25zdHt0eXBlOkMsdGl0bGU6RSxsYW5nOnUsYWx0OmQsZXhwYW5kZWQ6ZixhY3R1YWxUZXh0OnB9PXI7Zz1NYXRoLm1heChnLGwpO2NvbnN0IG09cy5nZXROZXdUZW1wb3JhcnlSZWYoKSx5PW5ldyBEaWN0KHMpO3kuc2V0KCJTIixOYW1lLmdldChDKSk7RSYmeS5zZXQoIlQiLEUpO3UmJnkuc2V0KCJMYW5nIix1KTtkJiZ5LnNldCgiQWx0IixkKTtmJiZ5LnNldCgiRSIsZik7cCYmeS5zZXQoIkFjdHVhbFRleHQiLHApO2F3YWl0IHRoaXMuI1Uoe3N0cnVjdFRyZWVQYXJlbnQ6USx0YWdEaWN0OnksbmV3VGFnUmVmOm0sc3RydWN0VHJlZVJvb3RSZWY6dCxmYWxsYmFja0tpZHM6aSx4cmVmOnMsY2FjaGU6bn0pO2NvbnN0IHc9bmV3IERpY3Qocyk7eS5zZXQoIksiLHcpO3cuc2V0KCJUeXBlIixvKTtoJiZ3LnNldCgiUGciLGUpO3cuc2V0KCJPYmoiLGMpO24ucHV0KG0seSk7YS5wdXNoKGwsbSl9fXJldHVybiBnKzF9c3RhdGljI3goe2VsZW1lbnRzOmUseHJlZjp0LHBhZ2VEaWN0OmksbnVtYmVyVHJlZTphfSl7Y29uc3Qgcz1uZXcgTWFwO2Zvcihjb25zdCB0IG9mIGUpaWYodC5zdHJ1Y3RUcmVlUGFyZW50SWQpe2NvbnN0IGU9cGFyc2VJbnQodC5zdHJ1Y3RUcmVlUGFyZW50SWQuc3BsaXQoIl9tYyIpWzFdLDEwKTtsZXQgaT1zLmdldChlKTtpZighaSl7aT1bXTtzLnNldChlLGkpfWkucHVzaCh0KX1jb25zdCByPWkuZ2V0KCJTdHJ1Y3RQYXJlbnRzIik7aWYoIU51bWJlci5pc0ludGVnZXIocikpcmV0dXJuO2NvbnN0IG49YS5nZXQociksdXBkYXRlRWxlbWVudD0oZSxpLGEpPT57Y29uc3Qgcj1zLmdldChlKTtpZihyKXtjb25zdCBlPWkuZ2V0UmF3KCJQIikscz10LmZldGNoSWZSZWYoZSk7aWYoZSBpbnN0YW5jZW9mIFJlZiYmcyBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9e3JlZjphLGRpY3Q6aX07Zm9yKGNvbnN0IHQgb2Ygcil0LnN0cnVjdFRyZWVQYXJlbnQ9ZX1yZXR1cm4hMH1yZXR1cm4hMX07Zm9yKGNvbnN0IGUgb2Ygbil7aWYoIShlIGluc3RhbmNlb2YgUmVmKSljb250aW51ZTtjb25zdCBpPXQuZmV0Y2goZSksYT1pLmdldCgiSyIpO2lmKE51bWJlci5pc0ludGVnZXIoYSkpdXBkYXRlRWxlbWVudChhLGksZSk7ZWxzZSBpZihBcnJheS5pc0FycmF5KGEpKWZvcihsZXQgcyBvZiBhKXtzPXQuZmV0Y2hJZlJlZihzKTtpZihOdW1iZXIuaXNJbnRlZ2VyKHMpJiZ1cGRhdGVFbGVtZW50KHMsaSxlKSlicmVhaztpZighKHMgaW5zdGFuY2VvZiBEaWN0KSljb250aW51ZTtpZighaXNOYW1lKHMuZ2V0KCJUeXBlIiksIk1DUiIpKWJyZWFrO2NvbnN0IGE9cy5nZXQoIk1DSUQiKTtpZihOdW1iZXIuaXNJbnRlZ2VyKGEpJiZ1cGRhdGVFbGVtZW50KGEsaSxlKSlicmVha319fXN0YXRpYyBhc3luYyNVKHtzdHJ1Y3RUcmVlUGFyZW50OmUsdGFnRGljdDp0LG5ld1RhZ1JlZjppLHN0cnVjdFRyZWVSb290UmVmOmEsZmFsbGJhY2tLaWRzOnMseHJlZjpyLGNhY2hlOm59KXtsZXQgbyxnPW51bGw7aWYoZSl7KHtyZWY6Z309ZSk7bz1lLmRpY3QuZ2V0UmF3KCJQIil8fGF9ZWxzZSBvPWE7dC5zZXQoIlAiLG8pO2NvbnN0IGM9ci5mZXRjaElmUmVmKG8pO2lmKCFjKXtzLnB1c2goaSk7cmV0dXJufWxldCBDPW4uZ2V0KG8pO2lmKCFDKXtDPWMuY2xvbmUoKTtuLnB1dChvLEMpfWNvbnN0IGg9Qy5nZXRSYXcoIksiKTtsZXQgbD1oIGluc3RhbmNlb2YgUmVmP24uZ2V0KGgpOm51bGw7aWYoIWwpe2w9ci5mZXRjaElmUmVmKGgpO2w9QXJyYXkuaXNBcnJheShsKT9sLnNsaWNlKCk6W2hdO2NvbnN0IGU9ci5nZXROZXdUZW1wb3JhcnlSZWYoKTtDLnNldCgiSyIsZSk7bi5wdXQoZSxsKX1jb25zdCBRPWwuaW5kZXhPZihnKTtsLnNwbGljZShRPj0wP1ErMTpsLmxlbmd0aCwwLGkpfX1jbGFzcyBTdHJ1Y3RFbGVtZW50Tm9kZXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMudHJlZT1lO3RoaXMuZGljdD10O3RoaXMua2lkcz1bXTt0aGlzLnBhcnNlS2lkcygpfWdldCByb2xlKCl7Y29uc3QgZT10aGlzLmRpY3QuZ2V0KCJTIiksdD1lIGluc3RhbmNlb2YgTmFtZT9lLm5hbWU6IiIse3Jvb3Q6aX09dGhpcy50cmVlO3JldHVybiBpLnJvbGVNYXAuaGFzKHQpP2kucm9sZU1hcC5nZXQodCk6dH1wYXJzZUtpZHMoKXtsZXQgZT1udWxsO2NvbnN0IHQ9dGhpcy5kaWN0LmdldFJhdygiUGciKTt0IGluc3RhbmNlb2YgUmVmJiYoZT10LnRvU3RyaW5nKCkpO2NvbnN0IGk9dGhpcy5kaWN0LmdldCgiSyIpO2lmKEFycmF5LmlzQXJyYXkoaSkpZm9yKGNvbnN0IHQgb2YgaSl7Y29uc3QgaT10aGlzLnBhcnNlS2lkKGUsdCk7aSYmdGhpcy5raWRzLnB1c2goaSl9ZWxzZXtjb25zdCB0PXRoaXMucGFyc2VLaWQoZSxpKTt0JiZ0aGlzLmtpZHMucHVzaCh0KX19cGFyc2VLaWQoZSx0KXtpZihOdW1iZXIuaXNJbnRlZ2VyKHQpKXJldHVybiB0aGlzLnRyZWUucGFnZURpY3Qub2JqSWQhPT1lP251bGw6bmV3IFN0cnVjdEVsZW1lbnQoe3R5cGU6dnMsbWNpZDp0LHBhZ2VPYmpJZDplfSk7bGV0IGk9bnVsbDt0IGluc3RhbmNlb2YgUmVmP2k9dGhpcy5kaWN0LnhyZWYuZmV0Y2godCk6dCBpbnN0YW5jZW9mIERpY3QmJihpPXQpO2lmKCFpKXJldHVybiBudWxsO2NvbnN0IGE9aS5nZXRSYXcoIlBnIik7YSBpbnN0YW5jZW9mIFJlZiYmKGU9YS50b1N0cmluZygpKTtjb25zdCBzPWkuZ2V0KCJUeXBlIilpbnN0YW5jZW9mIE5hbWU/aS5nZXQoIlR5cGUiKS5uYW1lOm51bGw7aWYoIk1DUiI9PT1zKXtpZih0aGlzLnRyZWUucGFnZURpY3Qub2JqSWQhPT1lKXJldHVybiBudWxsO2NvbnN0IHQ9aS5nZXRSYXcoIlN0bSIpO3JldHVybiBuZXcgU3RydWN0RWxlbWVudCh7dHlwZTpLcyxyZWZPYmpJZDp0IGluc3RhbmNlb2YgUmVmP3QudG9TdHJpbmcoKTpudWxsLHBhZ2VPYmpJZDplLG1jaWQ6aS5nZXQoIk1DSUQiKX0pfWlmKCJPQkpSIj09PXMpe2lmKHRoaXMudHJlZS5wYWdlRGljdC5vYmpJZCE9PWUpcmV0dXJuIG51bGw7Y29uc3QgdD1pLmdldFJhdygiT2JqIik7cmV0dXJuIG5ldyBTdHJ1Y3RFbGVtZW50KHt0eXBlOlRzLHJlZk9iaklkOnQgaW5zdGFuY2VvZiBSZWY/dC50b1N0cmluZygpOm51bGwscGFnZU9iaklkOmV9KX1yZXR1cm4gbmV3IFN0cnVjdEVsZW1lbnQoe3R5cGU6T3MsZGljdDppfSl9fWNsYXNzIFN0cnVjdEVsZW1lbnR7Y29uc3RydWN0b3Ioe3R5cGU6ZSxkaWN0OnQ9bnVsbCxtY2lkOmk9bnVsbCxwYWdlT2JqSWQ6YT1udWxsLHJlZk9iaklkOnM9bnVsbH0pe3RoaXMudHlwZT1lO3RoaXMuZGljdD10O3RoaXMubWNpZD1pO3RoaXMucGFnZU9iaklkPWE7dGhpcy5yZWZPYmpJZD1zO3RoaXMucGFyZW50Tm9kZT1udWxsfX1jbGFzcyBTdHJ1Y3RUcmVlUGFnZXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMucm9vdD1lO3RoaXMucm9vdERpY3Q9ZT9lLmRpY3Q6bnVsbDt0aGlzLnBhZ2VEaWN0PXQ7dGhpcy5ub2Rlcz1bXX1wYXJzZShlKXtpZighdGhpcy5yb290fHwhdGhpcy5yb290RGljdClyZXR1cm47Y29uc3QgdD10aGlzLnJvb3REaWN0LmdldCgiUGFyZW50VHJlZSIpO2lmKCF0KXJldHVybjtjb25zdCBpPXRoaXMucGFnZURpY3QuZ2V0KCJTdHJ1Y3RQYXJlbnRzIiksYT1lIGluc3RhbmNlb2YgUmVmJiZ0aGlzLnJvb3Quc3RydWN0UGFyZW50SWRzPy5nZXQoZSk7aWYoIU51bWJlci5pc0ludGVnZXIoaSkmJiFhKXJldHVybjtjb25zdCBzPW5ldyBNYXAscj1uZXcgTnVtYmVyVHJlZSh0LHRoaXMucm9vdERpY3QueHJlZik7aWYoTnVtYmVyLmlzSW50ZWdlcihpKSl7Y29uc3QgZT1yLmdldChpKTtpZihBcnJheS5pc0FycmF5KGUpKWZvcihjb25zdCB0IG9mIGUpdCBpbnN0YW5jZW9mIFJlZiYmdGhpcy5hZGROb2RlKHRoaXMucm9vdERpY3QueHJlZi5mZXRjaCh0KSxzKX1pZihhKWZvcihjb25zdFtlLHRdb2YgYSl7Y29uc3QgaT1yLmdldChlKTtpZihpKXtjb25zdCBlPXRoaXMuYWRkTm9kZSh0aGlzLnJvb3REaWN0LnhyZWYuZmV0Y2hJZlJlZihpKSxzKTsxPT09ZT8ua2lkcz8ubGVuZ3RoJiZlLmtpZHNbMF0udHlwZT09PVRzJiYoZS5raWRzWzBdLnR5cGU9dCl9fX1hZGROb2RlKGUsdCxpPTApe2lmKGk+NDApe3dhcm4oIlN0cnVjdFRyZWUgTUFYX0RFUFRIIHJlYWNoZWQuIik7cmV0dXJuIG51bGx9aWYodC5oYXMoZSkpcmV0dXJuIHQuZ2V0KGUpO2NvbnN0IGE9bmV3IFN0cnVjdEVsZW1lbnROb2RlKHRoaXMsZSk7dC5zZXQoZSxhKTtjb25zdCBzPWUuZ2V0KCJQIik7aWYoIXN8fGlzTmFtZShzLmdldCgiVHlwZSIpLCJTdHJ1Y3RUcmVlUm9vdCIpKXt0aGlzLmFkZFRvcExldmVsTm9kZShlLGEpfHx0LmRlbGV0ZShlKTtyZXR1cm4gYX1jb25zdCByPXRoaXMuYWRkTm9kZShzLHQsaSsxKTtpZighcilyZXR1cm4gYTtsZXQgbj0hMTtmb3IoY29uc3QgdCBvZiByLmtpZHMpaWYodC50eXBlPT09T3MmJnQuZGljdD09PWUpe3QucGFyZW50Tm9kZT1hO249ITB9bnx8dC5kZWxldGUoZSk7cmV0dXJuIGF9YWRkVG9wTGV2ZWxOb2RlKGUsdCl7Y29uc3QgaT10aGlzLnJvb3REaWN0LmdldCgiSyIpO2lmKCFpKXJldHVybiExO2lmKGkgaW5zdGFuY2VvZiBEaWN0KXtpZihpLm9iaklkIT09ZS5vYmpJZClyZXR1cm4hMTt0aGlzLm5vZGVzWzBdPXQ7cmV0dXJuITB9aWYoIUFycmF5LmlzQXJyYXkoaSkpcmV0dXJuITA7bGV0IGE9ITE7Zm9yKGxldCBzPTA7czxpLmxlbmd0aDtzKyspe2NvbnN0IHI9aVtzXTtpZihyPy50b1N0cmluZygpPT09ZS5vYmpJZCl7dGhpcy5ub2Rlc1tzXT10O2E9ITB9fXJldHVybiBhfWdldCBzZXJpYWxpemFibGUoKXtmdW5jdGlvbiBub2RlVG9TZXJpYWxpemFibGUoZSx0LGk9MCl7aWYoaT40MCl7d2FybigiU3RydWN0VHJlZSB0b28gZGVlcCB0byBiZSBmdWxseSBzZXJpYWxpemVkLiIpO3JldHVybn1jb25zdCBhPU9iamVjdC5jcmVhdGUobnVsbCk7YS5yb2xlPWUucm9sZTthLmNoaWxkcmVuPVtdO3QuY2hpbGRyZW4ucHVzaChhKTtjb25zdCBzPWUuZGljdC5nZXQoIkFsdCIpOyJzdHJpbmciPT10eXBlb2YgcyYmKGEuYWx0PXN0cmluZ1RvUERGU3RyaW5nKHMpKTtjb25zdCByPWUuZGljdC5nZXQoIkxhbmciKTsic3RyaW5nIj09dHlwZW9mIHImJihhLmxhbmc9c3RyaW5nVG9QREZTdHJpbmcocikpO2Zvcihjb25zdCB0IG9mIGUua2lkcyl7Y29uc3QgZT10LnR5cGU9PT1Pcz90LnBhcmVudE5vZGU6bnVsbDtlP25vZGVUb1NlcmlhbGl6YWJsZShlLGEsaSsxKTp0LnR5cGU9PT12c3x8dC50eXBlPT09S3M/YS5jaGlsZHJlbi5wdXNoKHt0eXBlOiJjb250ZW50IixpZDpgcCR7dC5wYWdlT2JqSWR9X21jJHt0Lm1jaWR9YH0pOnQudHlwZT09PVRzP2EuY2hpbGRyZW4ucHVzaCh7dHlwZToib2JqZWN0IixpZDp0LnJlZk9iaklkfSk6dC50eXBlPT09cXMmJmEuY2hpbGRyZW4ucHVzaCh7dHlwZToiYW5ub3RhdGlvbiIsaWQ6YHBkZmpzX2ludGVybmFsX2lkXyR7dC5yZWZPYmpJZH1gfSl9fWNvbnN0IGU9T2JqZWN0LmNyZWF0ZShudWxsKTtlLmNoaWxkcmVuPVtdO2Uucm9sZT0iUm9vdCI7Zm9yKGNvbnN0IHQgb2YgdGhpcy5ub2Rlcyl0JiZub2RlVG9TZXJpYWxpemFibGUodCxlKTtyZXR1cm4gZX19ZnVuY3Rpb24gaXNWYWxpZEV4cGxpY2l0RGVzdChlKXtpZighQXJyYXkuaXNBcnJheShlKXx8ZS5sZW5ndGg8MilyZXR1cm4hMTtjb25zdFt0LGksLi4uYV09ZTtpZighKHQgaW5zdGFuY2VvZiBSZWZ8fE51bWJlci5pc0ludGVnZXIodCkpKXJldHVybiExO2lmKCEoaSBpbnN0YW5jZW9mIE5hbWUpKXJldHVybiExO2xldCBzPSEwO3N3aXRjaChpLm5hbWUpe2Nhc2UiWFlaIjppZigzIT09YS5sZW5ndGgpcmV0dXJuITE7YnJlYWs7Y2FzZSJGaXQiOmNhc2UiRml0QiI6cmV0dXJuIDA9PT1hLmxlbmd0aDtjYXNlIkZpdEgiOmNhc2UiRml0QkgiOmNhc2UiRml0ViI6Y2FzZSJGaXRCViI6aWYoMSE9PWEubGVuZ3RoKXJldHVybiExO2JyZWFrO2Nhc2UiRml0UiI6aWYoNCE9PWEubGVuZ3RoKXJldHVybiExO3M9ITE7YnJlYWs7ZGVmYXVsdDpyZXR1cm4hMX1mb3IoY29uc3QgZSBvZiBhKWlmKCEoIm51bWJlciI9PXR5cGVvZiBlfHxzJiZudWxsPT09ZSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gZmV0Y2hEZXN0KGUpe2UgaW5zdGFuY2VvZiBEaWN0JiYoZT1lLmdldCgiRCIpKTtyZXR1cm4gaXNWYWxpZEV4cGxpY2l0RGVzdChlKT9lOm51bGx9ZnVuY3Rpb24gZmV0Y2hSZW1vdGVEZXN0KGUpe2xldCB0PWUuZ2V0KCJEIik7aWYodCl7dCBpbnN0YW5jZW9mIE5hbWUmJih0PXQubmFtZSk7aWYoInN0cmluZyI9PXR5cGVvZiB0KXJldHVybiBzdHJpbmdUb1BERlN0cmluZyh0KTtpZihpc1ZhbGlkRXhwbGljaXREZXN0KHQpKXJldHVybiBKU09OLnN0cmluZ2lmeSh0KX1yZXR1cm4gbnVsbH1jbGFzcyBDYXRhbG9ne2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5wZGZNYW5hZ2VyPWU7dGhpcy54cmVmPXQ7dGhpcy5fY2F0RGljdD10LmdldENhdGFsb2dPYmooKTtpZighKHRoaXMuX2NhdERpY3QgaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkNhdGFsb2cgb2JqZWN0IGlzIG5vdCBhIGRpY3Rpb25hcnkuIik7dGhpcy50b3BsZXZlbFBhZ2VzRGljdDt0aGlzLl9hY3R1YWxOdW1QYWdlcz1udWxsO3RoaXMuZm9udENhY2hlPW5ldyBSZWZTZXRDYWNoZTt0aGlzLmJ1aWx0SW5DTWFwQ2FjaGU9bmV3IE1hcDt0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZT1uZXcgTWFwO3RoaXMuZ2xvYmFsSW1hZ2VDYWNoZT1uZXcgR2xvYmFsSW1hZ2VDYWNoZTt0aGlzLnBhZ2VLaWRzQ291bnRDYWNoZT1uZXcgUmVmU2V0Q2FjaGU7dGhpcy5wYWdlSW5kZXhDYWNoZT1uZXcgUmVmU2V0Q2FjaGU7dGhpcy5ub25CbGVuZE1vZGVzU2V0PW5ldyBSZWZTZXQ7dGhpcy5zeXN0ZW1Gb250Q2FjaGU9bmV3IE1hcH1jbG9uZURpY3QoKXtyZXR1cm4gdGhpcy5fY2F0RGljdC5jbG9uZSgpfWdldCB2ZXJzaW9uKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiVmVyc2lvbiIpO2lmKGUgaW5zdGFuY2VvZiBOYW1lKXtpZihEdC50ZXN0KGUubmFtZSkpcmV0dXJuIHNoYWRvdyh0aGlzLCJ2ZXJzaW9uIixlLm5hbWUpO3dhcm4oYEludmFsaWQgUERGIGNhdGFsb2cgdmVyc2lvbjogJHtlLm5hbWV9YCl9cmV0dXJuIHNoYWRvdyh0aGlzLCJ2ZXJzaW9uIixudWxsKX1nZXQgbGFuZygpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIkxhbmciKTtyZXR1cm4gc2hhZG93KHRoaXMsImxhbmciLCJzdHJpbmciPT10eXBlb2YgZT9zdHJpbmdUb1BERlN0cmluZyhlKTpudWxsKX1nZXQgbmVlZHNSZW5kZXJpbmcoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0KCJOZWVkc1JlbmRlcmluZyIpO3JldHVybiBzaGFkb3codGhpcywibmVlZHNSZW5kZXJpbmciLCJib29sZWFuIj09dHlwZW9mIGUmJmUpfWdldCBjb2xsZWN0aW9uKCl7bGV0IGU9bnVsbDt0cnl7Y29uc3QgdD10aGlzLl9jYXREaWN0LmdldCgiQ29sbGVjdGlvbiIpO3QgaW5zdGFuY2VvZiBEaWN0JiZ0LnNpemU+MCYmKGU9dCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7aW5mbygiQ2Fubm90IGZldGNoIENvbGxlY3Rpb24gZW50cnk7IGFzc3VtaW5nIG5vIGNvbGxlY3Rpb24gaXMgcHJlc2VudC4iKX1yZXR1cm4gc2hhZG93KHRoaXMsImNvbGxlY3Rpb24iLGUpfWdldCBhY3JvRm9ybSgpe2xldCBlPW51bGw7dHJ5e2NvbnN0IHQ9dGhpcy5fY2F0RGljdC5nZXQoIkFjcm9Gb3JtIik7dCBpbnN0YW5jZW9mIERpY3QmJnQuc2l6ZT4wJiYoZT10KX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTtpbmZvKCJDYW5ub3QgZmV0Y2ggQWNyb0Zvcm0gZW50cnk7IGFzc3VtaW5nIG5vIGZvcm1zIGFyZSBwcmVzZW50LiIpfXJldHVybiBzaGFkb3codGhpcywiYWNyb0Zvcm0iLGUpfWdldCBhY3JvRm9ybVJlZigpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXRSYXcoIkFjcm9Gb3JtIik7cmV0dXJuIHNoYWRvdyh0aGlzLCJhY3JvRm9ybVJlZiIsZSBpbnN0YW5jZW9mIFJlZj9lOm51bGwpfWdldCBtZXRhZGF0YSgpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXRSYXcoIk1ldGFkYXRhIik7aWYoIShlIGluc3RhbmNlb2YgUmVmKSlyZXR1cm4gc2hhZG93KHRoaXMsIm1ldGFkYXRhIixudWxsKTtsZXQgdD1udWxsO3RyeXtjb25zdCBpPXRoaXMueHJlZi5mZXRjaChlLCF0aGlzLnhyZWYuZW5jcnlwdD8uZW5jcnlwdE1ldGFkYXRhKTtpZihpIGluc3RhbmNlb2YgQmFzZVN0cmVhbSYmaS5kaWN0IGluc3RhbmNlb2YgRGljdCl7Y29uc3QgZT1pLmRpY3QuZ2V0KCJUeXBlIiksYT1pLmRpY3QuZ2V0KCJTdWJ0eXBlIik7aWYoaXNOYW1lKGUsIk1ldGFkYXRhIikmJmlzTmFtZShhLCJYTUwiKSl7Y29uc3QgZT1zdHJpbmdUb1VURjhTdHJpbmcoaS5nZXRTdHJpbmcoKSk7ZSYmKHQ9bmV3IE1ldGFkYXRhUGFyc2VyKGUpLnNlcmlhbGl6YWJsZSl9fX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTtpbmZvKGBTa2lwcGluZyBpbnZhbGlkIE1ldGFkYXRhOiAiJHtlfSIuYCl9cmV0dXJuIHNoYWRvdyh0aGlzLCJtZXRhZGF0YSIsdCl9Z2V0IG1hcmtJbmZvKCl7bGV0IGU9bnVsbDt0cnl7ZT10aGlzLl9yZWFkTWFya0luZm8oKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTt3YXJuKCJVbmFibGUgdG8gcmVhZCBtYXJrIGluZm8uIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJtYXJrSW5mbyIsZSl9X3JlYWRNYXJrSW5mbygpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIk1hcmtJbmZvIik7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuIG51bGw7Y29uc3QgdD17TWFya2VkOiExLFVzZXJQcm9wZXJ0aWVzOiExLFN1c3BlY3RzOiExfTtmb3IoY29uc3QgaSBpbiB0KXtjb25zdCBhPWUuZ2V0KGkpOyJib29sZWFuIj09dHlwZW9mIGEmJih0W2ldPWEpfXJldHVybiB0fWdldCBzdHJ1Y3RUcmVlUm9vdCgpe2xldCBlPW51bGw7dHJ5e2U9dGhpcy5fcmVhZFN0cnVjdFRyZWVSb290KCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybigiVW5hYmxlIHJlYWQgdG8gc3RydWN0VHJlZVJvb3QgaW5mby4iKX1yZXR1cm4gc2hhZG93KHRoaXMsInN0cnVjdFRyZWVSb290IixlKX1fcmVhZFN0cnVjdFRyZWVSb290KCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldFJhdygiU3RydWN0VHJlZVJvb3QiKSx0PXRoaXMueHJlZi5mZXRjaElmUmVmKGUpO2lmKCEodCBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBudWxsO2NvbnN0IGk9bmV3IFN0cnVjdFRyZWVSb290KHQsZSk7aS5pbml0KCk7cmV0dXJuIGl9Z2V0IHRvcGxldmVsUGFnZXNEaWN0KCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiUGFnZXMiKTtpZighKGUgaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgdG9wLWxldmVsIHBhZ2VzIGRpY3Rpb25hcnkuIik7cmV0dXJuIHNoYWRvdyh0aGlzLCJ0b3BsZXZlbFBhZ2VzRGljdCIsZSl9Z2V0IGRvY3VtZW50T3V0bGluZSgpe2xldCBlPW51bGw7dHJ5e2U9dGhpcy5fcmVhZERvY3VtZW50T3V0bGluZSgpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO3dhcm4oIlVuYWJsZSB0byByZWFkIGRvY3VtZW50IG91dGxpbmUuIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJkb2N1bWVudE91dGxpbmUiLGUpfV9yZWFkRG9jdW1lbnRPdXRsaW5lKCl7bGV0IGU9dGhpcy5fY2F0RGljdC5nZXQoIk91dGxpbmVzIik7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuIG51bGw7ZT1lLmdldFJhdygiRmlyc3QiKTtpZighKGUgaW5zdGFuY2VvZiBSZWYpKXJldHVybiBudWxsO2NvbnN0IHQ9e2l0ZW1zOltdfSxpPVt7b2JqOmUscGFyZW50OnR9XSxhPW5ldyBSZWZTZXQ7YS5wdXQoZSk7Y29uc3Qgcz10aGlzLnhyZWYscj1uZXcgVWludDhDbGFtcGVkQXJyYXkoMyk7Zm9yKDtpLmxlbmd0aD4wOyl7Y29uc3QgdD1pLnNoaWZ0KCksbj1zLmZldGNoSWZSZWYodC5vYmopO2lmKG51bGw9PT1uKWNvbnRpbnVlO24uaGFzKCJUaXRsZSIpfHx3YXJuKCJJbnZhbGlkIG91dGxpbmUgaXRlbSBlbmNvdW50ZXJlZC4iKTtjb25zdCBvPXt1cmw6bnVsbCxkZXN0Om51bGwsYWN0aW9uOm51bGx9O0NhdGFsb2cucGFyc2VEZXN0RGljdGlvbmFyeSh7ZGVzdERpY3Q6bixyZXN1bHRPYmo6byxkb2NCYXNlVXJsOnRoaXMuYmFzZVVybCxkb2NBdHRhY2htZW50czp0aGlzLmF0dGFjaG1lbnRzfSk7Y29uc3QgZz1uLmdldCgiVGl0bGUiKSxjPW4uZ2V0KCJGIil8fDAsQz1uLmdldEFycmF5KCJDIiksaD1uLmdldCgiQ291bnQiKTtsZXQgbD1yOyFBcnJheS5pc0FycmF5KEMpfHwzIT09Qy5sZW5ndGh8fDA9PT1DWzBdJiYwPT09Q1sxXSYmMD09PUNbMl18fChsPUNvbG9yU3BhY2Uuc2luZ2xldG9ucy5yZ2IuZ2V0UmdiKEMsMCkpO2NvbnN0IFE9e2FjdGlvbjpvLmFjdGlvbixhdHRhY2htZW50Om8uYXR0YWNobWVudCxkZXN0Om8uZGVzdCx1cmw6by51cmwsdW5zYWZlVXJsOm8udW5zYWZlVXJsLG5ld1dpbmRvdzpvLm5ld1dpbmRvdyxzZXRPQ0dTdGF0ZTpvLnNldE9DR1N0YXRlLHRpdGxlOiJzdHJpbmciPT10eXBlb2YgZz9zdHJpbmdUb1BERlN0cmluZyhnKToiIixjb2xvcjpsLGNvdW50Ok51bWJlci5pc0ludGVnZXIoaCk/aDp2b2lkIDAsYm9sZDohISgyJmMpLGl0YWxpYzohISgxJmMpLGl0ZW1zOltdfTt0LnBhcmVudC5pdGVtcy5wdXNoKFEpO2U9bi5nZXRSYXcoIkZpcnN0Iik7aWYoZSBpbnN0YW5jZW9mIFJlZiYmIWEuaGFzKGUpKXtpLnB1c2goe29iajplLHBhcmVudDpRfSk7YS5wdXQoZSl9ZT1uLmdldFJhdygiTmV4dCIpO2lmKGUgaW5zdGFuY2VvZiBSZWYmJiFhLmhhcyhlKSl7aS5wdXNoKHtvYmo6ZSxwYXJlbnQ6dC5wYXJlbnR9KTthLnB1dChlKX19cmV0dXJuIHQuaXRlbXMubGVuZ3RoPjA/dC5pdGVtczpudWxsfWdldCBwZXJtaXNzaW9ucygpe2xldCBlPW51bGw7dHJ5e2U9dGhpcy5fcmVhZFBlcm1pc3Npb25zKCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybigiVW5hYmxlIHRvIHJlYWQgcGVybWlzc2lvbnMuIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJwZXJtaXNzaW9ucyIsZSl9X3JlYWRQZXJtaXNzaW9ucygpe2NvbnN0IGU9dGhpcy54cmVmLnRyYWlsZXIuZ2V0KCJFbmNyeXB0Iik7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuIG51bGw7bGV0IHQ9ZS5nZXQoIlAiKTtpZigibnVtYmVyIiE9dHlwZW9mIHQpcmV0dXJuIG51bGw7dCs9MioqMzI7Y29uc3QgaT1bXTtmb3IoY29uc3QgZSBpbiBtKXtjb25zdCBhPW1bZV07dCZhJiZpLnB1c2goYSl9cmV0dXJuIGl9Z2V0IG9wdGlvbmFsQ29udGVudENvbmZpZygpe2xldCBlPW51bGw7dHJ5e2NvbnN0IHQ9dGhpcy5fY2F0RGljdC5nZXQoIk9DUHJvcGVydGllcyIpO2lmKCF0KXJldHVybiBzaGFkb3codGhpcywib3B0aW9uYWxDb250ZW50Q29uZmlnIixudWxsKTtjb25zdCBpPXQuZ2V0KCJEIik7aWYoIWkpcmV0dXJuIHNoYWRvdyh0aGlzLCJvcHRpb25hbENvbnRlbnRDb25maWciLG51bGwpO2NvbnN0IGE9dC5nZXQoIk9DR3MiKTtpZighQXJyYXkuaXNBcnJheShhKSlyZXR1cm4gc2hhZG93KHRoaXMsIm9wdGlvbmFsQ29udGVudENvbmZpZyIsbnVsbCk7Y29uc3Qgcz1bXSxyPW5ldyBSZWZTZXQ7Zm9yKGNvbnN0IGUgb2YgYSlpZihlIGluc3RhbmNlb2YgUmVmJiYhci5oYXMoZSkpe3IucHV0KGUpO3MucHVzaCh0aGlzLiNNKGUpKX1lPXRoaXMuI0woaSxyKTtlLmdyb3Vwcz1zfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO3dhcm4oYFVuYWJsZSB0byByZWFkIG9wdGlvbmFsIGNvbnRlbnQgY29uZmlnOiAke2V9YCl9cmV0dXJuIHNoYWRvdyh0aGlzLCJvcHRpb25hbENvbnRlbnRDb25maWciLGUpfSNNKGUpe2NvbnN0IHQ9dGhpcy54cmVmLmZldGNoKGUpLGk9e2lkOmUudG9TdHJpbmcoKSxuYW1lOm51bGwsaW50ZW50Om51bGwsdXNhZ2U6e3ByaW50Om51bGwsdmlldzpudWxsfX0sYT10LmdldCgiTmFtZSIpOyJzdHJpbmciPT10eXBlb2YgYSYmKGkubmFtZT1zdHJpbmdUb1BERlN0cmluZyhhKSk7bGV0IHM9dC5nZXRBcnJheSgiSW50ZW50Iik7QXJyYXkuaXNBcnJheShzKXx8KHM9W3NdKTtzLmV2ZXJ5KChlPT5lIGluc3RhbmNlb2YgTmFtZSkpJiYoaS5pbnRlbnQ9cy5tYXAoKGU9PmUubmFtZSkpKTtjb25zdCByPXQuZ2V0KCJVc2FnZSIpO2lmKCEociBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBpO2NvbnN0IG49aS51c2FnZSxvPXIuZ2V0KCJQcmludCIpO2lmKG8gaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBlPW8uZ2V0KCJQcmludFN0YXRlIik7aWYoZSBpbnN0YW5jZW9mIE5hbWUpc3dpdGNoKGUubmFtZSl7Y2FzZSJPTiI6Y2FzZSJPRkYiOm4ucHJpbnQ9e3ByaW50U3RhdGU6ZS5uYW1lfX19Y29uc3QgZz1yLmdldCgiVmlldyIpO2lmKGcgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBlPWcuZ2V0KCJWaWV3U3RhdGUiKTtpZihlIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goZS5uYW1lKXtjYXNlIk9OIjpjYXNlIk9GRiI6bi52aWV3PXt2aWV3U3RhdGU6ZS5uYW1lfX19cmV0dXJuIGl9I0woZSx0KXtmdW5jdGlvbiBwYXJzZU9uT2ZmKGUpe2NvbnN0IGk9W107aWYoQXJyYXkuaXNBcnJheShlKSlmb3IoY29uc3QgYSBvZiBlKWEgaW5zdGFuY2VvZiBSZWYmJnQuaGFzKGEpJiZpLnB1c2goYS50b1N0cmluZygpKTtyZXR1cm4gaX1mdW5jdGlvbiBwYXJzZU9yZGVyKGUsaT0wKXtpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gbnVsbDtjb25zdCBzPVtdO2Zvcihjb25zdCByIG9mIGUpe2lmKHIgaW5zdGFuY2VvZiBSZWYmJnQuaGFzKHIpKXthLnB1dChyKTtzLnB1c2goci50b1N0cmluZygpKTtjb250aW51ZX1jb25zdCBlPXBhcnNlTmVzdGVkT3JkZXIocixpKTtlJiZzLnB1c2goZSl9aWYoaT4wKXJldHVybiBzO2NvbnN0IHI9W107Zm9yKGNvbnN0IGUgb2YgdClhLmhhcyhlKXx8ci5wdXNoKGUudG9TdHJpbmcoKSk7ci5sZW5ndGgmJnMucHVzaCh7bmFtZTpudWxsLG9yZGVyOnJ9KTtyZXR1cm4gc31mdW5jdGlvbiBwYXJzZU5lc3RlZE9yZGVyKGUsdCl7aWYoKyt0PnMpe3dhcm4oInBhcnNlTmVzdGVkT3JkZXIgLSByZWFjaGVkIE1BWF9ORVNURURfTEVWRUxTLiIpO3JldHVybiBudWxsfWNvbnN0IGE9aS5mZXRjaElmUmVmKGUpO2lmKCFBcnJheS5pc0FycmF5KGEpKXJldHVybiBudWxsO2NvbnN0IHI9aS5mZXRjaElmUmVmKGFbMF0pO2lmKCJzdHJpbmciIT10eXBlb2YgcilyZXR1cm4gbnVsbDtjb25zdCBuPXBhcnNlT3JkZXIoYS5zbGljZSgxKSx0KTtyZXR1cm4gbiYmbi5sZW5ndGg/e25hbWU6c3RyaW5nVG9QREZTdHJpbmcociksb3JkZXI6bn06bnVsbH1jb25zdCBpPXRoaXMueHJlZixhPW5ldyBSZWZTZXQscz0xMDtyZXR1cm57bmFtZToic3RyaW5nIj09dHlwZW9mIGUuZ2V0KCJOYW1lIik/c3RyaW5nVG9QREZTdHJpbmcoZS5nZXQoIk5hbWUiKSk6bnVsbCxjcmVhdG9yOiJzdHJpbmciPT10eXBlb2YgZS5nZXQoIkNyZWF0b3IiKT9zdHJpbmdUb1BERlN0cmluZyhlLmdldCgiQ3JlYXRvciIpKTpudWxsLGJhc2VTdGF0ZTplLmdldCgiQmFzZVN0YXRlIilpbnN0YW5jZW9mIE5hbWU/ZS5nZXQoIkJhc2VTdGF0ZSIpLm5hbWU6bnVsbCxvbjpwYXJzZU9uT2ZmKGUuZ2V0KCJPTiIpKSxvZmY6cGFyc2VPbk9mZihlLmdldCgiT0ZGIikpLG9yZGVyOnBhcnNlT3JkZXIoZS5nZXQoIk9yZGVyIikpLGdyb3VwczpudWxsfX1zZXRBY3R1YWxOdW1QYWdlcyhlPW51bGwpe3RoaXMuX2FjdHVhbE51bVBhZ2VzPWV9Z2V0IGhhc0FjdHVhbE51bVBhZ2VzKCl7cmV0dXJuIG51bGwhPT10aGlzLl9hY3R1YWxOdW1QYWdlc31nZXQgX3BhZ2VzQ291bnQoKXtjb25zdCBlPXRoaXMudG9wbGV2ZWxQYWdlc0RpY3QuZ2V0KCJDb3VudCIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiUGFnZSBjb3VudCBpbiB0b3AtbGV2ZWwgcGFnZXMgZGljdGlvbmFyeSBpcyBub3QgYW4gaW50ZWdlci4iKTtyZXR1cm4gc2hhZG93KHRoaXMsIl9wYWdlc0NvdW50IixlKX1nZXQgbnVtUGFnZXMoKXtyZXR1cm4gdGhpcy5oYXNBY3R1YWxOdW1QYWdlcz90aGlzLl9hY3R1YWxOdW1QYWdlczp0aGlzLl9wYWdlc0NvdW50fWdldCBkZXN0aW5hdGlvbnMoKXtjb25zdCBlPXRoaXMuX3JlYWREZXN0cygpLHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihlIGluc3RhbmNlb2YgTmFtZVRyZWUpZm9yKGNvbnN0W2ksYV1vZiBlLmdldEFsbCgpKXtjb25zdCBlPWZldGNoRGVzdChhKTtlJiYodFtzdHJpbmdUb1BERlN0cmluZyhpKV09ZSl9ZWxzZSBlIGluc3RhbmNlb2YgRGljdCYmZS5mb3JFYWNoKChmdW5jdGlvbihlLGkpe2NvbnN0IGE9ZmV0Y2hEZXN0KGkpO2EmJih0W2VdPWEpfSkpO3JldHVybiBzaGFkb3codGhpcywiZGVzdGluYXRpb25zIix0KX1nZXREZXN0aW5hdGlvbihlKXtjb25zdCB0PXRoaXMuX3JlYWREZXN0cygpO2lmKHQgaW5zdGFuY2VvZiBOYW1lVHJlZSl7Y29uc3QgaT1mZXRjaERlc3QodC5nZXQoZSkpO2lmKGkpcmV0dXJuIGk7Y29uc3QgYT10aGlzLmRlc3RpbmF0aW9uc1tlXTtpZihhKXt3YXJuKGBGb3VuZCAiJHtlfSIgYXQgYW4gaW5jb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBOYW1lVHJlZS5gKTtyZXR1cm4gYX19ZWxzZSBpZih0IGluc3RhbmNlb2YgRGljdCl7Y29uc3QgaT1mZXRjaERlc3QodC5nZXQoZSkpO2lmKGkpcmV0dXJuIGl9cmV0dXJuIG51bGx9X3JlYWREZXN0cygpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIk5hbWVzIik7cmV0dXJuIGU/LmhhcygiRGVzdHMiKT9uZXcgTmFtZVRyZWUoZS5nZXRSYXcoIkRlc3RzIiksdGhpcy54cmVmKTp0aGlzLl9jYXREaWN0LmhhcygiRGVzdHMiKT90aGlzLl9jYXREaWN0LmdldCgiRGVzdHMiKTp2b2lkIDB9Z2V0IHBhZ2VMYWJlbHMoKXtsZXQgZT1udWxsO3RyeXtlPXRoaXMuX3JlYWRQYWdlTGFiZWxzKCl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybigiVW5hYmxlIHRvIHJlYWQgcGFnZSBsYWJlbHMuIil9cmV0dXJuIHNoYWRvdyh0aGlzLCJwYWdlTGFiZWxzIixlKX1fcmVhZFBhZ2VMYWJlbHMoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0UmF3KCJQYWdlTGFiZWxzIik7aWYoIWUpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5udW1QYWdlcyk7bGV0IGk9bnVsbCxhPSIiO2NvbnN0IHM9bmV3IE51bWJlclRyZWUoZSx0aGlzLnhyZWYpLmdldEFsbCgpO2xldCByPSIiLG49MTtmb3IobGV0IGU9MCxvPXRoaXMubnVtUGFnZXM7ZTxvO2UrKyl7Y29uc3Qgbz1zLmdldChlKTtpZih2b2lkIDAhPT1vKXtpZighKG8gaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlBhZ2VMYWJlbCBpcyBub3QgYSBkaWN0aW9uYXJ5LiIpO2lmKG8uaGFzKCJUeXBlIikmJiFpc05hbWUoby5nZXQoIlR5cGUiKSwiUGFnZUxhYmVsIikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIHR5cGUgaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7aWYoby5oYXMoIlMiKSl7Y29uc3QgZT1vLmdldCgiUyIpO2lmKCEoZSBpbnN0YW5jZW9mIE5hbWUpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBzdHlsZSBpbiBQYWdlTGFiZWwgZGljdGlvbmFyeS4iKTtpPWUubmFtZX1lbHNlIGk9bnVsbDtpZihvLmhhcygiUCIpKXtjb25zdCBlPW8uZ2V0KCJQIik7aWYoInN0cmluZyIhPXR5cGVvZiBlKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBwcmVmaXggaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7YT1zdHJpbmdUb1BERlN0cmluZyhlKX1lbHNlIGE9IiI7aWYoby5oYXMoIlN0Iikpe2NvbnN0IGU9by5nZXQoIlN0Iik7aWYoIShOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0xKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgc3RhcnQgaW4gUGFnZUxhYmVsIGRpY3Rpb25hcnkuIik7bj1lfWVsc2Ugbj0xfXN3aXRjaChpKXtjYXNlIkQiOnI9bjticmVhaztjYXNlIlIiOmNhc2UiciI6cj10b1JvbWFuTnVtZXJhbHMobiwiciI9PT1pKTticmVhaztjYXNlIkEiOmNhc2UiYSI6Y29uc3QgZT0yNix0PSJhIj09PWk/OTc6NjUsYT1uLTE7cj1TdHJpbmcuZnJvbUNoYXJDb2RlKHQrYSVlKS5yZXBlYXQoTWF0aC5mbG9vcihhL2UpKzEpO2JyZWFrO2RlZmF1bHQ6aWYoaSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgc3R5bGUgIiR7aX0iIGluIFBhZ2VMYWJlbCBkaWN0aW9uYXJ5LmApO3I9IiJ9dFtlXT1hK3I7bisrfXJldHVybiB0fWdldCBwYWdlTGF5b3V0KCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiUGFnZUxheW91dCIpO2xldCB0PSIiO2lmKGUgaW5zdGFuY2VvZiBOYW1lKXN3aXRjaChlLm5hbWUpe2Nhc2UiU2luZ2xlUGFnZSI6Y2FzZSJPbmVDb2x1bW4iOmNhc2UiVHdvQ29sdW1uTGVmdCI6Y2FzZSJUd29Db2x1bW5SaWdodCI6Y2FzZSJUd29QYWdlTGVmdCI6Y2FzZSJUd29QYWdlUmlnaHQiOnQ9ZS5uYW1lfXJldHVybiBzaGFkb3codGhpcywicGFnZUxheW91dCIsdCl9Z2V0IHBhZ2VNb2RlKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiUGFnZU1vZGUiKTtsZXQgdD0iVXNlTm9uZSI7aWYoZSBpbnN0YW5jZW9mIE5hbWUpc3dpdGNoKGUubmFtZSl7Y2FzZSJVc2VOb25lIjpjYXNlIlVzZU91dGxpbmVzIjpjYXNlIlVzZVRodW1icyI6Y2FzZSJGdWxsU2NyZWVuIjpjYXNlIlVzZU9DIjpjYXNlIlVzZUF0dGFjaG1lbnRzIjp0PWUubmFtZX1yZXR1cm4gc2hhZG93KHRoaXMsInBhZ2VNb2RlIix0KX1nZXQgdmlld2VyUHJlZmVyZW5jZXMoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0KCJWaWV3ZXJQcmVmZXJlbmNlcyIpO2lmKCEoZSBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBzaGFkb3codGhpcywidmlld2VyUHJlZmVyZW5jZXMiLG51bGwpO2xldCB0PW51bGw7Zm9yKGNvbnN0IGkgb2YgZS5nZXRLZXlzKCkpe2NvbnN0IGE9ZS5nZXQoaSk7bGV0IHM7c3dpdGNoKGkpe2Nhc2UiSGlkZVRvb2xiYXIiOmNhc2UiSGlkZU1lbnViYXIiOmNhc2UiSGlkZVdpbmRvd1VJIjpjYXNlIkZpdFdpbmRvdyI6Y2FzZSJDZW50ZXJXaW5kb3ciOmNhc2UiRGlzcGxheURvY1RpdGxlIjpjYXNlIlBpY2tUcmF5QnlQREZTaXplIjoiYm9vbGVhbiI9PXR5cGVvZiBhJiYocz1hKTticmVhaztjYXNlIk5vbkZ1bGxTY3JlZW5QYWdlTW9kZSI6aWYoYSBpbnN0YW5jZW9mIE5hbWUpc3dpdGNoKGEubmFtZSl7Y2FzZSJVc2VOb25lIjpjYXNlIlVzZU91dGxpbmVzIjpjYXNlIlVzZVRodW1icyI6Y2FzZSJVc2VPQyI6cz1hLm5hbWU7YnJlYWs7ZGVmYXVsdDpzPSJVc2VOb25lIn1icmVhaztjYXNlIkRpcmVjdGlvbiI6aWYoYSBpbnN0YW5jZW9mIE5hbWUpc3dpdGNoKGEubmFtZSl7Y2FzZSJMMlIiOmNhc2UiUjJMIjpzPWEubmFtZTticmVhaztkZWZhdWx0OnM9IkwyUiJ9YnJlYWs7Y2FzZSJWaWV3QXJlYSI6Y2FzZSJWaWV3Q2xpcCI6Y2FzZSJQcmludEFyZWEiOmNhc2UiUHJpbnRDbGlwIjppZihhIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goYS5uYW1lKXtjYXNlIk1lZGlhQm94IjpjYXNlIkNyb3BCb3giOmNhc2UiQmxlZWRCb3giOmNhc2UiVHJpbUJveCI6Y2FzZSJBcnRCb3giOnM9YS5uYW1lO2JyZWFrO2RlZmF1bHQ6cz0iQ3JvcEJveCJ9YnJlYWs7Y2FzZSJQcmludFNjYWxpbmciOmlmKGEgaW5zdGFuY2VvZiBOYW1lKXN3aXRjaChhLm5hbWUpe2Nhc2UiTm9uZSI6Y2FzZSJBcHBEZWZhdWx0IjpzPWEubmFtZTticmVhaztkZWZhdWx0OnM9IkFwcERlZmF1bHQifWJyZWFrO2Nhc2UiRHVwbGV4IjppZihhIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goYS5uYW1lKXtjYXNlIlNpbXBsZXgiOmNhc2UiRHVwbGV4RmxpcFNob3J0RWRnZSI6Y2FzZSJEdXBsZXhGbGlwTG9uZ0VkZ2UiOnM9YS5uYW1lO2JyZWFrO2RlZmF1bHQ6cz0iTm9uZSJ9YnJlYWs7Y2FzZSJQcmludFBhZ2VSYW5nZSI6aWYoQXJyYXkuaXNBcnJheShhKSYmYS5sZW5ndGglMj09MCl7YS5ldmVyeSgoKGUsdCxpKT0+TnVtYmVyLmlzSW50ZWdlcihlKSYmZT4wJiYoMD09PXR8fGU+PWlbdC0xXSkmJmU8PXRoaXMubnVtUGFnZXMpKSYmKHM9YSl9YnJlYWs7Y2FzZSJOdW1Db3BpZXMiOk51bWJlci5pc0ludGVnZXIoYSkmJmE+MCYmKHM9YSk7YnJlYWs7ZGVmYXVsdDp3YXJuKGBJZ25vcmluZyBub24tc3RhbmRhcmQga2V5IGluIFZpZXdlclByZWZlcmVuY2VzOiAke2l9LmApO2NvbnRpbnVlfWlmKHZvaWQgMCE9PXMpe3R8fCh0PU9iamVjdC5jcmVhdGUobnVsbCkpO3RbaV09c31lbHNlIHdhcm4oYEJhZCB2YWx1ZSwgZm9yIGtleSAiJHtpfSIsIGluIFZpZXdlclByZWZlcmVuY2VzOiAke2F9LmApfXJldHVybiBzaGFkb3codGhpcywidmlld2VyUHJlZmVyZW5jZXMiLHQpfWdldCBvcGVuQWN0aW9uKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiT3BlbkFjdGlvbiIpLHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihlIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgaT1uZXcgRGljdCh0aGlzLnhyZWYpO2kuc2V0KCJBIixlKTtjb25zdCBhPXt1cmw6bnVsbCxkZXN0Om51bGwsYWN0aW9uOm51bGx9O0NhdGFsb2cucGFyc2VEZXN0RGljdGlvbmFyeSh7ZGVzdERpY3Q6aSxyZXN1bHRPYmo6YX0pO0FycmF5LmlzQXJyYXkoYS5kZXN0KT90LmRlc3Q9YS5kZXN0OmEuYWN0aW9uJiYodC5hY3Rpb249YS5hY3Rpb24pfWVsc2UgQXJyYXkuaXNBcnJheShlKSYmKHQuZGVzdD1lKTtyZXR1cm4gc2hhZG93KHRoaXMsIm9wZW5BY3Rpb24iLG9iamVjdFNpemUodCk+MD90Om51bGwpfWdldCBhdHRhY2htZW50cygpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIk5hbWVzIik7bGV0IHQ9bnVsbDtpZihlIGluc3RhbmNlb2YgRGljdCYmZS5oYXMoIkVtYmVkZGVkRmlsZXMiKSl7Y29uc3QgaT1uZXcgTmFtZVRyZWUoZS5nZXRSYXcoIkVtYmVkZGVkRmlsZXMiKSx0aGlzLnhyZWYpO2Zvcihjb25zdFtlLGFdb2YgaS5nZXRBbGwoKSl7Y29uc3QgaT1uZXcgRmlsZVNwZWMoYSx0aGlzLnhyZWYpO3R8fCh0PU9iamVjdC5jcmVhdGUobnVsbCkpO3Rbc3RyaW5nVG9QREZTdHJpbmcoZSldPWkuc2VyaWFsaXphYmxlfX1yZXR1cm4gc2hhZG93KHRoaXMsImF0dGFjaG1lbnRzIix0KX1nZXQgeGZhSW1hZ2VzKCl7Y29uc3QgZT10aGlzLl9jYXREaWN0LmdldCgiTmFtZXMiKTtsZXQgdD1udWxsO2lmKGUgaW5zdGFuY2VvZiBEaWN0JiZlLmhhcygiWEZBSW1hZ2VzIikpe2NvbnN0IGk9bmV3IE5hbWVUcmVlKGUuZ2V0UmF3KCJYRkFJbWFnZXMiKSx0aGlzLnhyZWYpO2Zvcihjb25zdFtlLGFdb2YgaS5nZXRBbGwoKSl7dHx8KHQ9bmV3IERpY3QodGhpcy54cmVmKSk7dC5zZXQoc3RyaW5nVG9QREZTdHJpbmcoZSksYSl9fXJldHVybiBzaGFkb3codGhpcywieGZhSW1hZ2VzIix0KX1fY29sbGVjdEphdmFTY3JpcHQoKXtjb25zdCBlPXRoaXMuX2NhdERpY3QuZ2V0KCJOYW1lcyIpO2xldCB0PW51bGw7ZnVuY3Rpb24gYXBwZW5kSWZKYXZhU2NyaXB0RGljdChlLGkpe2lmKCEoaSBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtpZighaXNOYW1lKGkuZ2V0KCJTIiksIkphdmFTY3JpcHQiKSlyZXR1cm47bGV0IGE9aS5nZXQoIkpTIik7aWYoYSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pYT1hLmdldFN0cmluZygpO2Vsc2UgaWYoInN0cmluZyIhPXR5cGVvZiBhKXJldHVybjthPXN0cmluZ1RvUERGU3RyaW5nKGEpLnJlcGxhY2VBbGwoIlwwIiwiIik7YSYmKHR8fD1uZXcgTWFwKS5zZXQoZSxhKX1pZihlIGluc3RhbmNlb2YgRGljdCYmZS5oYXMoIkphdmFTY3JpcHQiKSl7Y29uc3QgdD1uZXcgTmFtZVRyZWUoZS5nZXRSYXcoIkphdmFTY3JpcHQiKSx0aGlzLnhyZWYpO2Zvcihjb25zdFtlLGldb2YgdC5nZXRBbGwoKSlhcHBlbmRJZkphdmFTY3JpcHREaWN0KHN0cmluZ1RvUERGU3RyaW5nKGUpLGkpfWNvbnN0IGk9dGhpcy5fY2F0RGljdC5nZXQoIk9wZW5BY3Rpb24iKTtpJiZhcHBlbmRJZkphdmFTY3JpcHREaWN0KCJPcGVuQWN0aW9uIixpKTtyZXR1cm4gdH1nZXQganNBY3Rpb25zKCl7Y29uc3QgZT10aGlzLl9jb2xsZWN0SmF2YVNjcmlwdCgpO2xldCB0PWNvbGxlY3RBY3Rpb25zKHRoaXMueHJlZix0aGlzLl9jYXREaWN0LGRBKTtpZihlKXt0fHw9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IoY29uc3RbaSxhXW9mIGUpaSBpbiB0P3RbaV0ucHVzaChhKTp0W2ldPVthXX1yZXR1cm4gc2hhZG93KHRoaXMsImpzQWN0aW9ucyIsdCl9YXN5bmMgZm9udEZhbGxiYWNrKGUsdCl7Y29uc3QgaT1hd2FpdCBQcm9taXNlLmFsbCh0aGlzLmZvbnRDYWNoZSk7Zm9yKGNvbnN0IGEgb2YgaSlpZihhLmxvYWRlZE5hbWU9PT1lKXthLmZhbGxiYWNrKHQpO3JldHVybn19YXN5bmMgY2xlYW51cChlPSExKXtjbGVhckdsb2JhbENhY2hlcygpO3RoaXMuZ2xvYmFsSW1hZ2VDYWNoZS5jbGVhcihlKTt0aGlzLnBhZ2VLaWRzQ291bnRDYWNoZS5jbGVhcigpO3RoaXMucGFnZUluZGV4Q2FjaGUuY2xlYXIoKTt0aGlzLm5vbkJsZW5kTW9kZXNTZXQuY2xlYXIoKTtjb25zdCB0PWF3YWl0IFByb21pc2UuYWxsKHRoaXMuZm9udENhY2hlKTtmb3IoY29uc3R7ZGljdDplfW9mIHQpZGVsZXRlIGUuY2FjaGVLZXk7dGhpcy5mb250Q2FjaGUuY2xlYXIoKTt0aGlzLmJ1aWx0SW5DTWFwQ2FjaGUuY2xlYXIoKTt0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZS5jbGVhcigpO3RoaXMuc3lzdGVtRm9udENhY2hlLmNsZWFyKCl9YXN5bmMgZ2V0UGFnZURpY3QoZSl7Y29uc3QgdD1bdGhpcy50b3BsZXZlbFBhZ2VzRGljdF0saT1uZXcgUmVmU2V0LGE9dGhpcy5fY2F0RGljdC5nZXRSYXcoIlBhZ2VzIik7YSBpbnN0YW5jZW9mIFJlZiYmaS5wdXQoYSk7Y29uc3Qgcz10aGlzLnhyZWYscj10aGlzLnBhZ2VLaWRzQ291bnRDYWNoZSxuPXRoaXMucGFnZUluZGV4Q2FjaGU7bGV0IG89MDtmb3IoO3QubGVuZ3RoOyl7Y29uc3QgYT10LnBvcCgpO2lmKGEgaW5zdGFuY2VvZiBSZWYpe2NvbnN0IGc9ci5nZXQoYSk7aWYoZz49MCYmbytnPD1lKXtvKz1nO2NvbnRpbnVlfWlmKGkuaGFzKGEpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiUGFnZXMgdHJlZSBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2UuIik7aS5wdXQoYSk7Y29uc3QgYz1hd2FpdCBzLmZldGNoQXN5bmMoYSk7aWYoYyBpbnN0YW5jZW9mIERpY3Qpe2xldCB0PWMuZ2V0UmF3KCJUeXBlIik7dCBpbnN0YW5jZW9mIFJlZiYmKHQ9YXdhaXQgcy5mZXRjaEFzeW5jKHQpKTtpZihpc05hbWUodCwiUGFnZSIpfHwhYy5oYXMoIktpZHMiKSl7ci5oYXMoYSl8fHIucHV0KGEsMSk7bi5oYXMoYSl8fG4ucHV0KGEsbyk7aWYobz09PWUpcmV0dXJuW2MsYV07bysrO2NvbnRpbnVlfX10LnB1c2goYyk7Y29udGludWV9aWYoIShhIGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkIHJlZmVyZW5jZSBwb2ludHMgdG8gd3JvbmcgdHlwZSBvZiBvYmplY3QuIik7Y29uc3R7b2JqSWQ6Z309YTtsZXQgYz1hLmdldFJhdygiQ291bnQiKTtjIGluc3RhbmNlb2YgUmVmJiYoYz1hd2FpdCBzLmZldGNoQXN5bmMoYykpO2lmKE51bWJlci5pc0ludGVnZXIoYykmJmM+PTApe2cmJiFyLmhhcyhnKSYmci5wdXQoZyxjKTtpZihvK2M8PWUpe28rPWM7Y29udGludWV9fWxldCBDPWEuZ2V0UmF3KCJLaWRzIik7QyBpbnN0YW5jZW9mIFJlZiYmKEM9YXdhaXQgcy5mZXRjaEFzeW5jKEMpKTtpZighQXJyYXkuaXNBcnJheShDKSl7bGV0IHQ9YS5nZXRSYXcoIlR5cGUiKTt0IGluc3RhbmNlb2YgUmVmJiYodD1hd2FpdCBzLmZldGNoQXN5bmModCkpO2lmKGlzTmFtZSh0LCJQYWdlIil8fCFhLmhhcygiS2lkcyIpKXtpZihvPT09ZSlyZXR1cm5bYSxudWxsXTtvKys7Y29udGludWV9dGhyb3cgbmV3IEZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkcyBvYmplY3QgaXMgbm90IGFuIGFycmF5LiIpfWZvcihsZXQgZT1DLmxlbmd0aC0xO2U+PTA7ZS0tKXQucHVzaChDW2VdKX10aHJvdyBuZXcgRXJyb3IoYFBhZ2UgaW5kZXggJHtlfSBub3QgZm91bmQuYCl9YXN5bmMgZ2V0QWxsUGFnZURpY3RzKGU9ITEpe2NvbnN0e2lnbm9yZUVycm9yczp0fT10aGlzLnBkZk1hbmFnZXIuZXZhbHVhdG9yT3B0aW9ucyxpPVt7Y3VycmVudE5vZGU6dGhpcy50b3BsZXZlbFBhZ2VzRGljdCxwb3NJbktpZHM6MH1dLGE9bmV3IFJlZlNldCxzPXRoaXMuX2NhdERpY3QuZ2V0UmF3KCJQYWdlcyIpO3MgaW5zdGFuY2VvZiBSZWYmJmEucHV0KHMpO2NvbnN0IHI9bmV3IE1hcCxuPXRoaXMueHJlZixvPXRoaXMucGFnZUluZGV4Q2FjaGU7bGV0IGc9MDtmdW5jdGlvbiBhZGRQYWdlRGljdChlLHQpe3QmJiFvLmhhcyh0KSYmby5wdXQodCxnKTtyLnNldChnKyssW2UsdF0pfWZ1bmN0aW9uIGFkZFBhZ2VFcnJvcihpKXtpZihpIGluc3RhbmNlb2YgWFJlZkVudHJ5RXhjZXB0aW9uJiYhZSl0aHJvdyBpO2lmKGUmJnQmJjA9PT1nKXt3YXJuKGBnZXRBbGxQYWdlRGljdHMgLSBTa2lwcGluZyBpbnZhbGlkIGZpcnN0IHBhZ2U6ICIke2l9Ii5gKTtpPURpY3QuZW1wdHl9ci5zZXQoZysrLFtpLG51bGxdKX1mb3IoO2kubGVuZ3RoPjA7KXtjb25zdCBlPWkuYXQoLTEpLHtjdXJyZW50Tm9kZTp0LHBvc0luS2lkczpzfT1lO2xldCByPXQuZ2V0UmF3KCJLaWRzIik7aWYociBpbnN0YW5jZW9mIFJlZil0cnl7cj1hd2FpdCBuLmZldGNoQXN5bmMocil9Y2F0Y2goZSl7YWRkUGFnZUVycm9yKGUpO2JyZWFrfWlmKCFBcnJheS5pc0FycmF5KHIpKXthZGRQYWdlRXJyb3IobmV3IEZvcm1hdEVycm9yKCJQYWdlIGRpY3Rpb25hcnkga2lkcyBvYmplY3QgaXMgbm90IGFuIGFycmF5LiIpKTticmVha31pZihzPj1yLmxlbmd0aCl7aS5wb3AoKTtjb250aW51ZX1jb25zdCBvPXJbc107bGV0IGc7aWYobyBpbnN0YW5jZW9mIFJlZil7aWYoYS5oYXMobykpe2FkZFBhZ2VFcnJvcihuZXcgRm9ybWF0RXJyb3IoIlBhZ2VzIHRyZWUgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlLiIpKTticmVha31hLnB1dChvKTt0cnl7Zz1hd2FpdCBuLmZldGNoQXN5bmMobyl9Y2F0Y2goZSl7YWRkUGFnZUVycm9yKGUpO2JyZWFrfX1lbHNlIGc9bztpZighKGcgaW5zdGFuY2VvZiBEaWN0KSl7YWRkUGFnZUVycm9yKG5ldyBGb3JtYXRFcnJvcigiUGFnZSBkaWN0aW9uYXJ5IGtpZCByZWZlcmVuY2UgcG9pbnRzIHRvIHdyb25nIHR5cGUgb2Ygb2JqZWN0LiIpKTticmVha31sZXQgYz1nLmdldFJhdygiVHlwZSIpO2lmKGMgaW5zdGFuY2VvZiBSZWYpdHJ5e2M9YXdhaXQgbi5mZXRjaEFzeW5jKGMpfWNhdGNoKGUpe2FkZFBhZ2VFcnJvcihlKTticmVha31pc05hbWUoYywiUGFnZSIpfHwhZy5oYXMoIktpZHMiKT9hZGRQYWdlRGljdChnLG8gaW5zdGFuY2VvZiBSZWY/bzpudWxsKTppLnB1c2goe2N1cnJlbnROb2RlOmcscG9zSW5LaWRzOjB9KTtlLnBvc0luS2lkcysrfXJldHVybiByfWdldFBhZ2VJbmRleChlKXtjb25zdCB0PXRoaXMucGFnZUluZGV4Q2FjaGUuZ2V0KGUpO2lmKHZvaWQgMCE9PXQpcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0KTtjb25zdCBpPXRoaXMueHJlZjtsZXQgYT0wO2NvbnN0IG5leHQ9dD0+ZnVuY3Rpb24gcGFnZXNCZWZvcmVSZWYodCl7bGV0IGEscz0wO3JldHVybiBpLmZldGNoQXN5bmModCkudGhlbigoZnVuY3Rpb24oaSl7aWYoaXNSZWZzRXF1YWwodCxlKSYmIWlzRGljdChpLCJQYWdlIikmJiEoaSBpbnN0YW5jZW9mIERpY3QmJiFpLmhhcygiVHlwZSIpJiZpLmhhcygiQ29udGVudHMiKSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJUaGUgcmVmZXJlbmNlIGRvZXMgbm90IHBvaW50IHRvIGEgL1BhZ2UgZGljdGlvbmFyeS4iKTtpZighaSlyZXR1cm4gbnVsbDtpZighKGkgaW5zdGFuY2VvZiBEaWN0KSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIk5vZGUgbXVzdCBiZSBhIGRpY3Rpb25hcnkuIik7YT1pLmdldFJhdygiUGFyZW50Iik7cmV0dXJuIGkuZ2V0QXN5bmMoIlBhcmVudCIpfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCFlKXJldHVybiBudWxsO2lmKCEoZSBpbnN0YW5jZW9mIERpY3QpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiUGFyZW50IG11c3QgYmUgYSBkaWN0aW9uYXJ5LiIpO3JldHVybiBlLmdldEFzeW5jKCJLaWRzIil9KSkudGhlbigoZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuIG51bGw7Y29uc3Qgcj1bXTtsZXQgbj0hMTtmb3IoY29uc3QgYSBvZiBlKXtpZighKGEgaW5zdGFuY2VvZiBSZWYpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiS2lkIG11c3QgYmUgYSByZWZlcmVuY2UuIik7aWYoaXNSZWZzRXF1YWwoYSx0KSl7bj0hMDticmVha31yLnB1c2goaS5mZXRjaEFzeW5jKGEpLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIERpY3QpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiS2lkIG5vZGUgbXVzdCBiZSBhIGRpY3Rpb25hcnkuIik7ZS5oYXMoIkNvdW50Iik/cys9ZS5nZXQoIkNvdW50Iik6cysrfSkpKX1pZighbil0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIktpZCByZWZlcmVuY2Ugbm90IGZvdW5kIGluIHBhcmVudCdzIGtpZHMuIik7cmV0dXJuIFByb21pc2UuYWxsKHIpLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuW3MsYV19KSl9KSl9KHQpLnRoZW4oKHQ9PntpZighdCl7dGhpcy5wYWdlSW5kZXhDYWNoZS5wdXQoZSxhKTtyZXR1cm4gYX1jb25zdFtpLHNdPXQ7YSs9aTtyZXR1cm4gbmV4dChzKX0pKTtyZXR1cm4gbmV4dChlKX1nZXQgYmFzZVVybCgpe2NvbnN0IGU9dGhpcy5fY2F0RGljdC5nZXQoIlVSSSIpO2lmKGUgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCB0PWUuZ2V0KCJCYXNlIik7aWYoInN0cmluZyI9PXR5cGVvZiB0KXtjb25zdCBlPWNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodCxudWxsLHt0cnlDb252ZXJ0RW5jb2Rpbmc6ITB9KTtpZihlKXJldHVybiBzaGFkb3codGhpcywiYmFzZVVybCIsZS5ocmVmKX19cmV0dXJuIHNoYWRvdyh0aGlzLCJiYXNlVXJsIix0aGlzLnBkZk1hbmFnZXIuZG9jQmFzZVVybCl9c3RhdGljIHBhcnNlRGVzdERpY3Rpb25hcnkoe2Rlc3REaWN0OmUscmVzdWx0T2JqOnQsZG9jQmFzZVVybDppPW51bGwsZG9jQXR0YWNobWVudHM6YT1udWxsfSl7aWYoIShlIGluc3RhbmNlb2YgRGljdCkpe3dhcm4oInBhcnNlRGVzdERpY3Rpb25hcnk6IGBkZXN0RGljdGAgbXVzdCBiZSBhIGRpY3Rpb25hcnkuIik7cmV0dXJufWxldCBzLHIsbj1lLmdldCgiQSIpO2lmKCEobiBpbnN0YW5jZW9mIERpY3QpKWlmKGUuaGFzKCJEZXN0Iikpbj1lLmdldCgiRGVzdCIpO2Vsc2V7bj1lLmdldCgiQUEiKTtuIGluc3RhbmNlb2YgRGljdCYmKG4uaGFzKCJEIik/bj1uLmdldCgiRCIpOm4uaGFzKCJVIikmJihuPW4uZ2V0KCJVIikpKX1pZihuIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgZT1uLmdldCgiUyIpO2lmKCEoZSBpbnN0YW5jZW9mIE5hbWUpKXt3YXJuKCJwYXJzZURlc3REaWN0aW9uYXJ5OiBJbnZhbGlkIHR5cGUgaW4gQWN0aW9uIGRpY3Rpb25hcnkuIik7cmV0dXJufWNvbnN0IGk9ZS5uYW1lO3N3aXRjaChpKXtjYXNlIlJlc2V0Rm9ybSI6Y29uc3QgZT1uLmdldCgiRmxhZ3MiKSxvPTA9PSgxJigibnVtYmVyIj09dHlwZW9mIGU/ZTowKSksZz1bXSxjPVtdO2Zvcihjb25zdCBlIG9mIG4uZ2V0KCJGaWVsZHMiKXx8W10pZSBpbnN0YW5jZW9mIFJlZj9jLnB1c2goZS50b1N0cmluZygpKToic3RyaW5nIj09dHlwZW9mIGUmJmcucHVzaChzdHJpbmdUb1BERlN0cmluZyhlKSk7dC5yZXNldEZvcm09e2ZpZWxkczpnLHJlZnM6YyxpbmNsdWRlOm99O2JyZWFrO2Nhc2UiVVJJIjpzPW4uZ2V0KCJVUkkiKTtzIGluc3RhbmNlb2YgTmFtZSYmKHM9Ii8iK3MubmFtZSk7YnJlYWs7Y2FzZSJHb1RvIjpyPW4uZ2V0KCJEIik7YnJlYWs7Y2FzZSJMYXVuY2giOmNhc2UiR29Ub1IiOmNvbnN0IEM9bi5nZXQoIkYiKTtpZihDIGluc3RhbmNlb2YgRGljdCl7Y29uc3QgZT1uZXcgRmlsZVNwZWMoQyxudWxsLCEwKSx7ZmlsZW5hbWU6dH09ZS5zZXJpYWxpemFibGU7cz10fWVsc2Uic3RyaW5nIj09dHlwZW9mIEMmJihzPUMpO2NvbnN0IGg9ZmV0Y2hSZW1vdGVEZXN0KG4pO2gmJiJzdHJpbmciPT10eXBlb2YgcyYmKHM9cy5zcGxpdCgiIyIsMSlbMF0rIiMiK2gpO2NvbnN0IGw9bi5nZXQoIk5ld1dpbmRvdyIpOyJib29sZWFuIj09dHlwZW9mIGwmJih0Lm5ld1dpbmRvdz1sKTticmVhaztjYXNlIkdvVG9FIjpjb25zdCBRPW4uZ2V0KCJUIik7bGV0IEU7aWYoYSYmUSBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9US5nZXQoIlIiKSx0PVEuZ2V0KCJOIik7aXNOYW1lKGUsIkMiKSYmInN0cmluZyI9PXR5cGVvZiB0JiYoRT1hW3N0cmluZ1RvUERGU3RyaW5nKHQpXSl9aWYoRSl7dC5hdHRhY2htZW50PUU7Y29uc3QgZT1mZXRjaFJlbW90ZURlc3Qobik7ZSYmKHQuYXR0YWNobWVudERlc3Q9ZSl9ZWxzZSB3YXJuKCdwYXJzZURlc3REaWN0aW9uYXJ5IC0gdW5pbXBsZW1lbnRlZCAiR29Ub0UiIGFjdGlvbi4nKTticmVhaztjYXNlIk5hbWVkIjpjb25zdCB1PW4uZ2V0KCJOIik7dSBpbnN0YW5jZW9mIE5hbWUmJih0LmFjdGlvbj11Lm5hbWUpO2JyZWFrO2Nhc2UiU2V0T0NHU3RhdGUiOmNvbnN0IGQ9bi5nZXQoIlN0YXRlIiksZj1uLmdldCgiUHJlc2VydmVSQiIpO2lmKCFBcnJheS5pc0FycmF5KGQpfHwwPT09ZC5sZW5ndGgpYnJlYWs7Y29uc3QgcD1bXTtmb3IoY29uc3QgZSBvZiBkKWlmKGUgaW5zdGFuY2VvZiBOYW1lKXN3aXRjaChlLm5hbWUpe2Nhc2UiT04iOmNhc2UiT0ZGIjpjYXNlIlRvZ2dsZSI6cC5wdXNoKGUubmFtZSl9ZWxzZSBlIGluc3RhbmNlb2YgUmVmJiZwLnB1c2goZS50b1N0cmluZygpKTtpZihwLmxlbmd0aCE9PWQubGVuZ3RoKWJyZWFrO3Quc2V0T0NHU3RhdGU9e3N0YXRlOnAscHJlc2VydmVSQjoiYm9vbGVhbiIhPXR5cGVvZiBmfHxmfTticmVhaztjYXNlIkphdmFTY3JpcHQiOmNvbnN0IG09bi5nZXQoIkpTIik7bGV0IHk7bSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/eT1tLmdldFN0cmluZygpOiJzdHJpbmciPT10eXBlb2YgbSYmKHk9bSk7Y29uc3Qgdz15JiZyZWNvdmVySnNVUkwoc3RyaW5nVG9QREZTdHJpbmcoeSkpO2lmKHcpe3M9dy51cmw7dC5uZXdXaW5kb3c9dy5uZXdXaW5kb3c7YnJlYWt9ZGVmYXVsdDppZigiSmF2YVNjcmlwdCI9PT1pfHwiU3VibWl0Rm9ybSI9PT1pKWJyZWFrO3dhcm4oYHBhcnNlRGVzdERpY3Rpb25hcnkgLSB1bnN1cHBvcnRlZCBhY3Rpb246ICIke2l9Ii5gKX19ZWxzZSBlLmhhcygiRGVzdCIpJiYocj1lLmdldCgiRGVzdCIpKTtpZigic3RyaW5nIj09dHlwZW9mIHMpe2NvbnN0IGU9Y3JlYXRlVmFsaWRBYnNvbHV0ZVVybChzLGkse2FkZERlZmF1bHRQcm90b2NvbDohMCx0cnlDb252ZXJ0RW5jb2Rpbmc6ITB9KTtlJiYodC51cmw9ZS5ocmVmKTt0LnVuc2FmZVVybD1zfWlmKHIpe3IgaW5zdGFuY2VvZiBOYW1lJiYocj1yLm5hbWUpOyJzdHJpbmciPT10eXBlb2Ygcj90LmRlc3Q9c3RyaW5nVG9QREZTdHJpbmcocik6aXNWYWxpZEV4cGxpY2l0RGVzdChyKSYmKHQuZGVzdD1yKX19fWZ1bmN0aW9uIGFkZENoaWxkcmVuKGUsdCl7aWYoZSBpbnN0YW5jZW9mIERpY3QpZT1lLmdldFJhd1ZhbHVlcygpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pZT1lLmRpY3QuZ2V0UmF3VmFsdWVzKCk7ZWxzZSBpZighQXJyYXkuaXNBcnJheShlKSlyZXR1cm47Zm9yKGNvbnN0IGEgb2YgZSkoKGk9YSlpbnN0YW5jZW9mIFJlZnx8aSBpbnN0YW5jZW9mIERpY3R8fGkgaW5zdGFuY2VvZiBCYXNlU3RyZWFtfHxBcnJheS5pc0FycmF5KGkpKSYmdC5wdXNoKGEpO3ZhciBpfWNsYXNzIE9iamVjdExvYWRlcntjb25zdHJ1Y3RvcihlLHQsaSl7dGhpcy5kaWN0PWU7dGhpcy5rZXlzPXQ7dGhpcy54cmVmPWk7dGhpcy5yZWZTZXQ9bnVsbH1hc3luYyBsb2FkKCl7aWYodGhpcy54cmVmLnN0cmVhbS5pc0RhdGFMb2FkZWQpcmV0dXJuO2NvbnN0e2tleXM6ZSxkaWN0OnR9PXRoaXM7dGhpcy5yZWZTZXQ9bmV3IFJlZlNldDtjb25zdCBpPVtdO2Zvcihjb25zdCBhIG9mIGUpe2NvbnN0IGU9dC5nZXRSYXcoYSk7dm9pZCAwIT09ZSYmaS5wdXNoKGUpfXJldHVybiB0aGlzLl93YWxrKGkpfWFzeW5jIF93YWxrKGUpe2NvbnN0IHQ9W10saT1bXTtmb3IoO2UubGVuZ3RoOyl7bGV0IGE9ZS5wb3AoKTtpZihhIGluc3RhbmNlb2YgUmVmKXtpZih0aGlzLnJlZlNldC5oYXMoYSkpY29udGludWU7dHJ5e3RoaXMucmVmU2V0LnB1dChhKTthPXRoaXMueHJlZi5mZXRjaChhKX1jYXRjaChlKXtpZighKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbikpe3dhcm4oYE9iamVjdExvYWRlci5fd2FsayAtIHJlcXVlc3RpbmcgYWxsIGRhdGE6ICIke2V9Ii5gKTt0aGlzLnJlZlNldD1udWxsO2NvbnN0e21hbmFnZXI6dH09dGhpcy54cmVmLnN0cmVhbTtyZXR1cm4gdC5yZXF1ZXN0QWxsQ2h1bmtzKCl9dC5wdXNoKGEpO2kucHVzaCh7YmVnaW46ZS5iZWdpbixlbmQ6ZS5lbmR9KX19aWYoYSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pe2NvbnN0IGU9YS5nZXRCYXNlU3RyZWFtcygpO2lmKGUpe2xldCBzPSExO2Zvcihjb25zdCB0IG9mIGUpaWYoIXQuaXNEYXRhTG9hZGVkKXtzPSEwO2kucHVzaCh7YmVnaW46dC5zdGFydCxlbmQ6dC5lbmR9KX1zJiZ0LnB1c2goYSl9fWFkZENoaWxkcmVuKGEsZSl9aWYoaS5sZW5ndGgpe2F3YWl0IHRoaXMueHJlZi5zdHJlYW0ubWFuYWdlci5yZXF1ZXN0UmFuZ2VzKGkpO2Zvcihjb25zdCBlIG9mIHQpZSBpbnN0YW5jZW9mIFJlZiYmdGhpcy5yZWZTZXQucmVtb3ZlKGUpO3JldHVybiB0aGlzLl93YWxrKHQpfXRoaXMucmVmU2V0PW51bGx9fWNvbnN0IFdzPVN5bWJvbCgpLGpzPVN5bWJvbCgpLFhzPVN5bWJvbCgpLFpzPVN5bWJvbCgpLFZzPVN5bWJvbCgpLHpzPVN5bWJvbCgpLF9zPVN5bWJvbCgpLCRzPVN5bWJvbCgpLEFyPVN5bWJvbCgpLGVyPVN5bWJvbCgiY29udGVudCIpLHRyPVN5bWJvbCgiZGF0YSIpLGlyPVN5bWJvbCgpLGFyPVN5bWJvbCgiZXh0cmEiKSxzcj1TeW1ib2woKSxycj1TeW1ib2woKSxucj1TeW1ib2woKSxvcj1TeW1ib2woKSxncj1TeW1ib2woKSxJcj1TeW1ib2woKSxjcj1TeW1ib2woKSxDcj1TeW1ib2woKSxocj1TeW1ib2woKSxscj1TeW1ib2woKSxRcj1TeW1ib2woKSxFcj1TeW1ib2woKSx1cj1TeW1ib2woKSxkcj1TeW1ib2woKSxmcj1TeW1ib2woKSxwcj1TeW1ib2woKSxtcj1TeW1ib2woKSx5cj1TeW1ib2woKSx3cj1TeW1ib2woKSxicj1TeW1ib2woKSxEcj1TeW1ib2woKSxGcj1TeW1ib2woKSxTcj1TeW1ib2woKSxrcj1TeW1ib2woKSxOcj1TeW1ib2woKSxScj1TeW1ib2woKSxHcj1TeW1ib2woKSx4cj1TeW1ib2woKSxVcj1TeW1ib2woKSxNcj1TeW1ib2woKSxMcj1TeW1ib2woKSxIcj1TeW1ib2woKSxKcj1TeW1ib2woIm5hbWVzcGFjZUlkIiksWXI9U3ltYm9sKCJub2RlTmFtZSIpLHZyPVN5bWJvbCgpLEtyPVN5bWJvbCgpLFRyPVN5bWJvbCgpLHFyPVN5bWJvbCgpLE9yPVN5bWJvbCgpLFByPVN5bWJvbCgpLFdyPVN5bWJvbCgpLGpyPVN5bWJvbCgpLFhyPVN5bWJvbCgicm9vdCIpLFpyPVN5bWJvbCgpLFZyPVN5bWJvbCgpLHpyPVN5bWJvbCgpLF9yPVN5bWJvbCgpLCRyPVN5bWJvbCgpLEFuPVN5bWJvbCgpLGVuPVN5bWJvbCgpLHRuPVN5bWJvbCgpLGFuPVN5bWJvbCgpLHNuPVN5bWJvbCgpLHJuPVN5bWJvbCgpLG5uPVN5bWJvbCgidWlkIiksb249U3ltYm9sKCksZ249e2NvbmZpZzp7aWQ6MCxjaGVjazplPT5lLnN0YXJ0c1dpdGgoImh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGNpLyIpfSxjb25uZWN0aW9uU2V0OntpZDoxLGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtY29ubmVjdGlvbi1zZXQvIil9LGRhdGFzZXRzOntpZDoyLGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtZGF0YS8iKX0sZm9ybTp7aWQ6MyxjaGVjazplPT5lLnN0YXJ0c1dpdGgoImh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGZhLWZvcm0vIil9LGxvY2FsZVNldDp7aWQ6NCxjaGVjazplPT5lLnN0YXJ0c1dpdGgoImh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGZhLWxvY2FsZS1zZXQvIil9LHBkZjp7aWQ6NSxjaGVjazplPT4iaHR0cDovL25zLmFkb2JlLmNvbS94ZHAvcGRmLyI9PT1lfSxzaWduYXR1cmU6e2lkOjYsY2hlY2s6ZT0+Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDkveG1sZHNpZyMiPT09ZX0sc291cmNlU2V0OntpZDo3LGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtc291cmNlLXNldC8iKX0sc3R5bGVzaGVldDp7aWQ6OCxjaGVjazplPT4iaHR0cDovL3d3dy53My5vcmcvMTk5OS9YU0wvVHJhbnNmb3JtIj09PWV9LHRlbXBsYXRlOntpZDo5LGNoZWNrOmU9PmUuc3RhcnRzV2l0aCgiaHR0cDovL3d3dy54ZmEub3JnL3NjaGVtYS94ZmEtdGVtcGxhdGUvIil9LHhkYzp7aWQ6MTAsY2hlY2s6ZT0+ZS5zdGFydHNXaXRoKCJodHRwOi8vd3d3LnhmYS5vcmcvc2NoZW1hL3hkYy8iKX0seGRwOntpZDoxMSxjaGVjazplPT4iaHR0cDovL25zLmFkb2JlLmNvbS94ZHAvIj09PWV9LHhmZGY6e2lkOjEyLGNoZWNrOmU9PiJodHRwOi8vbnMuYWRvYmUuY29tL3hmZGYvIj09PWV9LHhodG1sOntpZDoxMyxjaGVjazplPT4iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI9PT1lfSx4bXBtZXRhOntpZDoxNCxjaGVjazplPT4iaHR0cDovL25zLmFkb2JlLmNvbS94bXBtZXRhLyI9PT1lfX0sSW49e3B0OmU9PmUsY206ZT0+ZS8yLjU0KjcyLG1tOmU9PmUvMjUuNCo3MixpbjplPT43MiplLHB4OmU9PmV9LGNuPS8oWystXT9cZCtcLj9cZCopKC4qKS87ZnVuY3Rpb24gc3RyaXBRdW90ZXMoZSl7cmV0dXJuIGUuc3RhcnRzV2l0aCgiJyIpfHxlLnN0YXJ0c1dpdGgoJyInKT9lLnNsaWNlKDEsLTEpOmV9ZnVuY3Rpb24gZ2V0SW50ZWdlcih7ZGF0YTplLGRlZmF1bHRWYWx1ZTp0LHZhbGlkYXRlOml9KXtpZighZSlyZXR1cm4gdDtlPWUudHJpbSgpO2NvbnN0IGE9cGFyc2VJbnQoZSwxMCk7cmV0dXJuIWlzTmFOKGEpJiZpKGEpP2E6dH1mdW5jdGlvbiBnZXRGbG9hdCh7ZGF0YTplLGRlZmF1bHRWYWx1ZTp0LHZhbGlkYXRlOml9KXtpZighZSlyZXR1cm4gdDtlPWUudHJpbSgpO2NvbnN0IGE9cGFyc2VGbG9hdChlKTtyZXR1cm4haXNOYU4oYSkmJmkoYSk/YTp0fWZ1bmN0aW9uIGdldEtleXdvcmQoe2RhdGE6ZSxkZWZhdWx0VmFsdWU6dCx2YWxpZGF0ZTppfSl7cmV0dXJuIGUmJmkoZT1lLnRyaW0oKSk/ZTp0fWZ1bmN0aW9uIGdldFN0cmluZ09wdGlvbihlLHQpe3JldHVybiBnZXRLZXl3b3JkKHtkYXRhOmUsZGVmYXVsdFZhbHVlOnRbMF0sdmFsaWRhdGU6ZT0+dC5pbmNsdWRlcyhlKX0pfWZ1bmN0aW9uIGdldE1lYXN1cmVtZW50KGUsdD0iMCIpe3R8fD0iMCI7aWYoIWUpcmV0dXJuIGdldE1lYXN1cmVtZW50KHQpO2NvbnN0IGk9ZS50cmltKCkubWF0Y2goY24pO2lmKCFpKXJldHVybiBnZXRNZWFzdXJlbWVudCh0KTtjb25zdFssYSxzXT1pLHI9cGFyc2VGbG9hdChhKTtpZihpc05hTihyKSlyZXR1cm4gZ2V0TWVhc3VyZW1lbnQodCk7aWYoMD09PXIpcmV0dXJuIDA7Y29uc3Qgbj1JbltzXTtyZXR1cm4gbj9uKHIpOnJ9ZnVuY3Rpb24gZ2V0UmF0aW8oZSl7aWYoIWUpcmV0dXJue251bToxLGRlbjoxfTtjb25zdCB0PWUudHJpbSgpLnNwbGl0KC9ccyo6XHMqLykubWFwKChlPT5wYXJzZUZsb2F0KGUpKSkuZmlsdGVyKChlPT4haXNOYU4oZSkpKTsxPT09dC5sZW5ndGgmJnQucHVzaCgxKTtpZigwPT09dC5sZW5ndGgpcmV0dXJue251bToxLGRlbjoxfTtjb25zdFtpLGFdPXQ7cmV0dXJue251bTppLGRlbjphfX1mdW5jdGlvbiBnZXRSZWxldmFudChlKXtyZXR1cm4gZT9lLnRyaW0oKS5zcGxpdCgvXHMrLykubWFwKChlPT4oe2V4Y2x1ZGVkOiItIj09PWVbMF0sdmlld25hbWU6ZS5zdWJzdHJpbmcoMSl9KSkpOltdfWNsYXNzIEhUTUxSZXN1bHR7c3RhdGljIGdldCBGQUlMVVJFKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJGQUlMVVJFIixuZXcgSFRNTFJlc3VsdCghMSxudWxsLG51bGwsbnVsbCkpfXN0YXRpYyBnZXQgRU1QVFkoKXtyZXR1cm4gc2hhZG93KHRoaXMsIkVNUFRZIixuZXcgSFRNTFJlc3VsdCghMCxudWxsLG51bGwsbnVsbCkpfWNvbnN0cnVjdG9yKGUsdCxpLGEpe3RoaXMuc3VjY2Vzcz1lO3RoaXMuaHRtbD10O3RoaXMuYmJveD1pO3RoaXMuYnJlYWtOb2RlPWF9aXNCcmVhaygpe3JldHVybiEhdGhpcy5icmVha05vZGV9c3RhdGljIGJyZWFrTm9kZShlKXtyZXR1cm4gbmV3IEhUTUxSZXN1bHQoITEsbnVsbCxudWxsLGUpfXN0YXRpYyBzdWNjZXNzKGUsdD1udWxsKXtyZXR1cm4gbmV3IEhUTUxSZXN1bHQoITAsZSx0LG51bGwpfX1jbGFzcyBGb250RmluZGVye2NvbnN0cnVjdG9yKGUpe3RoaXMuZm9udHM9bmV3IE1hcDt0aGlzLmNhY2hlPW5ldyBNYXA7dGhpcy53YXJuZWQ9bmV3IFNldDt0aGlzLmRlZmF1bHRGb250PW51bGw7dGhpcy5hZGQoZSl9YWRkKGUsdD1udWxsKXtmb3IoY29uc3QgdCBvZiBlKXRoaXMuYWRkUGRmRm9udCh0KTtmb3IoY29uc3QgZSBvZiB0aGlzLmZvbnRzLnZhbHVlcygpKWUucmVndWxhcnx8KGUucmVndWxhcj1lLml0YWxpY3x8ZS5ib2xkfHxlLmJvbGRpdGFsaWMpO2lmKCF0fHwwPT09dC5zaXplKXJldHVybjtjb25zdCBpPXRoaXMuZm9udHMuZ2V0KCJQZGZKUy1GYWxsYmFjay1QZGZKUy1YRkEiKTtmb3IoY29uc3QgZSBvZiB0KXRoaXMuZm9udHMuc2V0KGUsaSl9YWRkUGRmRm9udChlKXtjb25zdCB0PWUuY3NzRm9udEluZm8saT10LmZvbnRGYW1pbHk7bGV0IGE9dGhpcy5mb250cy5nZXQoaSk7aWYoIWEpe2E9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLmZvbnRzLnNldChpLGEpO3RoaXMuZGVmYXVsdEZvbnR8fCh0aGlzLmRlZmF1bHRGb250PWEpfWxldCBzPSIiO2NvbnN0IHI9cGFyc2VGbG9hdCh0LmZvbnRXZWlnaHQpOzAhPT1wYXJzZUZsb2F0KHQuaXRhbGljQW5nbGUpP3M9cj49NzAwPyJib2xkaXRhbGljIjoiaXRhbGljIjpyPj03MDAmJihzPSJib2xkIik7aWYoIXMpeyhlLm5hbWUuaW5jbHVkZXMoIkJvbGQiKXx8ZS5wc05hbWU/LmluY2x1ZGVzKCJCb2xkIikpJiYocz0iYm9sZCIpOyhlLm5hbWUuaW5jbHVkZXMoIkl0YWxpYyIpfHxlLm5hbWUuZW5kc1dpdGgoIkl0Iil8fGUucHNOYW1lPy5pbmNsdWRlcygiSXRhbGljIil8fGUucHNOYW1lPy5lbmRzV2l0aCgiSXQiKSkmJihzKz0iaXRhbGljIil9c3x8KHM9InJlZ3VsYXIiKTthW3NdPWV9Z2V0RGVmYXVsdCgpe3JldHVybiB0aGlzLmRlZmF1bHRGb250fWZpbmQoZSx0PSEwKXtsZXQgaT10aGlzLmZvbnRzLmdldChlKXx8dGhpcy5jYWNoZS5nZXQoZSk7aWYoaSlyZXR1cm4gaTtjb25zdCBhPS8sfC18X3wgfGJvbGRpdGFsaWN8Ym9sZHxpdGFsaWN8cmVndWxhcnxpdC9naTtsZXQgcz1lLnJlcGxhY2VBbGwoYSwiIik7aT10aGlzLmZvbnRzLmdldChzKTtpZihpKXt0aGlzLmNhY2hlLnNldChlLGkpO3JldHVybiBpfXM9cy50b0xvd2VyQ2FzZSgpO2NvbnN0IHI9W107Zm9yKGNvbnN0W2UsdF1vZiB0aGlzLmZvbnRzLmVudHJpZXMoKSllLnJlcGxhY2VBbGwoYSwiIikudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKHMpJiZyLnB1c2godCk7aWYoMD09PXIubGVuZ3RoKWZvcihjb25zdFssZV1vZiB0aGlzLmZvbnRzLmVudHJpZXMoKSllLnJlZ3VsYXIubmFtZT8ucmVwbGFjZUFsbChhLCIiKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgocykmJnIucHVzaChlKTtpZigwPT09ci5sZW5ndGgpe3M9cy5yZXBsYWNlQWxsKC9wc210fG10L2dpLCIiKTtmb3IoY29uc3RbZSx0XW9mIHRoaXMuZm9udHMuZW50cmllcygpKWUucmVwbGFjZUFsbChhLCIiKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgocykmJnIucHVzaCh0KX1pZigwPT09ci5sZW5ndGgpZm9yKGNvbnN0IGUgb2YgdGhpcy5mb250cy52YWx1ZXMoKSllLnJlZ3VsYXIubmFtZT8ucmVwbGFjZUFsbChhLCIiKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgocykmJnIucHVzaChlKTtpZihyLmxlbmd0aD49MSl7MSE9PXIubGVuZ3RoJiZ0JiZ3YXJuKGBYRkEgLSBUb28gbWFueSBjaG9pY2VzIHRvIGd1ZXNzIHRoZSBjb3JyZWN0IGZvbnQ6ICR7ZX1gKTt0aGlzLmNhY2hlLnNldChlLHJbMF0pO3JldHVybiByWzBdfWlmKHQmJiF0aGlzLndhcm5lZC5oYXMoZSkpe3RoaXMud2FybmVkLmFkZChlKTt3YXJuKGBYRkEgLSBDYW5ub3QgZmluZCB0aGUgZm9udDogJHtlfWApfXJldHVybiBudWxsfX1mdW5jdGlvbiBzZWxlY3RGb250KGUsdCl7cmV0dXJuIml0YWxpYyI9PT1lLnBvc3R1cmU/ImJvbGQiPT09ZS53ZWlnaHQ/dC5ib2xkaXRhbGljOnQuaXRhbGljOiJib2xkIj09PWUud2VpZ2h0P3QuYm9sZDp0LnJlZ3VsYXJ9Y2xhc3MgRm9udEluZm97Y29uc3RydWN0b3IoZSx0LGksYSl7dGhpcy5saW5lSGVpZ2h0PWk7dGhpcy5wYXJhTWFyZ2luPXR8fHt0b3A6MCxib3R0b206MCxsZWZ0OjAscmlnaHQ6MH07aWYoIWUpe1t0aGlzLnBkZkZvbnQsdGhpcy54ZmFGb250XT10aGlzLmRlZmF1bHRGb250KGEpO3JldHVybn10aGlzLnhmYUZvbnQ9e3R5cGVmYWNlOmUudHlwZWZhY2UscG9zdHVyZTplLnBvc3R1cmUsd2VpZ2h0OmUud2VpZ2h0LHNpemU6ZS5zaXplLGxldHRlclNwYWNpbmc6ZS5sZXR0ZXJTcGFjaW5nfTtjb25zdCBzPWEuZmluZChlLnR5cGVmYWNlKTtpZihzKXt0aGlzLnBkZkZvbnQ9c2VsZWN0Rm9udChlLHMpO3RoaXMucGRmRm9udHx8KFt0aGlzLnBkZkZvbnQsdGhpcy54ZmFGb250XT10aGlzLmRlZmF1bHRGb250KGEpKX1lbHNlW3RoaXMucGRmRm9udCx0aGlzLnhmYUZvbnRdPXRoaXMuZGVmYXVsdEZvbnQoYSl9ZGVmYXVsdEZvbnQoZSl7Y29uc3QgdD1lLmZpbmQoIkhlbHZldGljYSIsITEpfHxlLmZpbmQoIk15cmlhZCBQcm8iLCExKXx8ZS5maW5kKCJBcmlhbCIsITEpfHxlLmdldERlZmF1bHQoKTtpZih0Py5yZWd1bGFyKXtjb25zdCBlPXQucmVndWxhcjtyZXR1cm5bZSx7dHlwZWZhY2U6ZS5jc3NGb250SW5mby5mb250RmFtaWx5LHBvc3R1cmU6Im5vcm1hbCIsd2VpZ2h0OiJub3JtYWwiLHNpemU6MTAsbGV0dGVyU3BhY2luZzowfV19cmV0dXJuW251bGwse3R5cGVmYWNlOiJDb3VyaWVyIixwb3N0dXJlOiJub3JtYWwiLHdlaWdodDoibm9ybWFsIixzaXplOjEwLGxldHRlclNwYWNpbmc6MH1dfX1jbGFzcyBGb250U2VsZWN0b3J7Y29uc3RydWN0b3IoZSx0LGksYSl7dGhpcy5mb250RmluZGVyPWE7dGhpcy5zdGFjaz1bbmV3IEZvbnRJbmZvKGUsdCxpLGEpXX1wdXNoRGF0YShlLHQsaSl7Y29uc3QgYT10aGlzLnN0YWNrLmF0KC0xKTtmb3IoY29uc3QgdCBvZlsidHlwZWZhY2UiLCJwb3N0dXJlIiwid2VpZ2h0Iiwic2l6ZSIsImxldHRlclNwYWNpbmciXSllW3RdfHwoZVt0XT1hLnhmYUZvbnRbdF0pO2Zvcihjb25zdCBlIG9mWyJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiXSlpc05hTih0W2VdKSYmKHRbZV09YS5wYXJhTWFyZ2luW2VdKTtjb25zdCBzPW5ldyBGb250SW5mbyhlLHQsaXx8YS5saW5lSGVpZ2h0LHRoaXMuZm9udEZpbmRlcik7cy5wZGZGb250fHwocy5wZGZGb250PWEucGRmRm9udCk7dGhpcy5zdGFjay5wdXNoKHMpfXBvcEZvbnQoKXt0aGlzLnN0YWNrLnBvcCgpfXRvcEZvbnQoKXtyZXR1cm4gdGhpcy5zdGFjay5hdCgtMSl9fWNsYXNzIFRleHRNZWFzdXJle2NvbnN0cnVjdG9yKGUsdCxpLGEpe3RoaXMuZ2x5cGhzPVtdO3RoaXMuZm9udFNlbGVjdG9yPW5ldyBGb250U2VsZWN0b3IoZSx0LGksYSk7dGhpcy5leHRyYUhlaWdodD0wfXB1c2hEYXRhKGUsdCxpKXt0aGlzLmZvbnRTZWxlY3Rvci5wdXNoRGF0YShlLHQsaSl9cG9wRm9udChlKXtyZXR1cm4gdGhpcy5mb250U2VsZWN0b3IucG9wRm9udCgpfWFkZFBhcmEoKXtjb25zdCBlPXRoaXMuZm9udFNlbGVjdG9yLnRvcEZvbnQoKTt0aGlzLmV4dHJhSGVpZ2h0Kz1lLnBhcmFNYXJnaW4udG9wK2UucGFyYU1hcmdpbi5ib3R0b219YWRkU3RyaW5nKGUpe2lmKCFlKXJldHVybjtjb25zdCB0PXRoaXMuZm9udFNlbGVjdG9yLnRvcEZvbnQoKSxpPXQueGZhRm9udC5zaXplO2lmKHQucGRmRm9udCl7Y29uc3QgYT10LnhmYUZvbnQubGV0dGVyU3BhY2luZyxzPXQucGRmRm9udCxyPXMubGluZUhlaWdodHx8MS4yLG49dC5saW5lSGVpZ2h0fHxNYXRoLm1heCgxLjIscikqaSxvPXItKHZvaWQgMD09PXMubGluZUdhcD8uMjpzLmxpbmVHYXApLGc9TWF0aC5tYXgoMSxvKSppLGM9aS8xZTMsQz1zLmRlZmF1bHRXaWR0aHx8cy5jaGFyc1RvR2x5cGhzKCIgIilbMF0ud2lkdGg7Zm9yKGNvbnN0IHQgb2YgZS5zcGxpdCgvW1x1MjAyOVxuXS8pKXtjb25zdCBlPXMuZW5jb2RlU3RyaW5nKHQpLmpvaW4oIiIpLGk9cy5jaGFyc1RvR2x5cGhzKGUpO2Zvcihjb25zdCBlIG9mIGkpe2NvbnN0IHQ9ZS53aWR0aHx8Qzt0aGlzLmdseXBocy5wdXNoKFt0KmMrYSxuLGcsZS51bmljb2RlLCExXSl9dGhpcy5nbHlwaHMucHVzaChbMCwwLDAsIlxuIiwhMF0pfXRoaXMuZ2x5cGhzLnBvcCgpfWVsc2V7Zm9yKGNvbnN0IHQgb2YgZS5zcGxpdCgvW1x1MjAyOVxuXS8pKXtmb3IoY29uc3QgZSBvZiB0LnNwbGl0KCIiKSl0aGlzLmdseXBocy5wdXNoKFtpLDEuMippLGksZSwhMV0pO3RoaXMuZ2x5cGhzLnB1c2goWzAsMCwwLCJcbiIsITBdKX10aGlzLmdseXBocy5wb3AoKX19Y29tcHV0ZShlKXtsZXQgdD0tMSxpPTAsYT0wLHM9MCxyPTAsbj0wLG89ITEsZz0hMDtmb3IobGV0IGM9MCxDPXRoaXMuZ2x5cGhzLmxlbmd0aDtjPEM7YysrKXtjb25zdFtDLGgsbCxRLEVdPXRoaXMuZ2x5cGhzW2NdLHU9IiAiPT09USxkPWc/bDpoO2lmKEUpe2E9TWF0aC5tYXgoYSxyKTtyPTA7cys9bjtuPWQ7dD0tMTtpPTA7Zz0hMX1lbHNlIGlmKHUpaWYocitDPmUpe2E9TWF0aC5tYXgoYSxyKTtyPTA7cys9bjtuPWQ7dD0tMTtpPTA7bz0hMDtnPSExfWVsc2V7bj1NYXRoLm1heChkLG4pO2k9cjtyKz1DO3Q9Y31lbHNlIGlmKHIrQz5lKXtzKz1uO249ZDtpZigtMSE9PXQpe2M9dDthPU1hdGgubWF4KGEsaSk7cj0wO3Q9LTE7aT0wfWVsc2V7YT1NYXRoLm1heChhLHIpO3I9Q31vPSEwO2c9ITF9ZWxzZXtyKz1DO249TWF0aC5tYXgoZCxuKX19YT1NYXRoLm1heChhLHIpO3MrPW4rdGhpcy5leHRyYUhlaWdodDtyZXR1cm57d2lkdGg6MS4wMiphLGhlaWdodDpzLGlzQnJva2VuOm99fX1jb25zdCBDbj0vXlteLltdKy8saG49L15bXlxdXSsvLGxuPXtkb3Q6MCxkb3REb3Q6MSxkb3RIYXNoOjIsZG90QnJhY2tldDozLGRvdFBhcmVuOjR9LEJuPW5ldyBNYXAoW1siJGRhdGEiLChlLHQpPT5lLmRhdGFzZXRzP2UuZGF0YXNldHMuZGF0YTplXSxbIiRyZWNvcmQiLChlLHQpPT4oZS5kYXRhc2V0cz9lLmRhdGFzZXRzLmRhdGE6ZSlbRXJdKClbMF1dLFsiJHRlbXBsYXRlIiwoZSx0KT0+ZS50ZW1wbGF0ZV0sWyIkY29ubmVjdGlvblNldCIsKGUsdCk9PmUuY29ubmVjdGlvblNldF0sWyIkZm9ybSIsKGUsdCk9PmUuZm9ybV0sWyIkbGF5b3V0IiwoZSx0KT0+ZS5sYXlvdXRdLFsiJGhvc3QiLChlLHQpPT5lLmhvc3RdLFsiJGRhdGFXaW5kb3ciLChlLHQpPT5lLmRhdGFXaW5kb3ddLFsiJGV2ZW50IiwoZSx0KT0+ZS5ldmVudF0sWyIhIiwoZSx0KT0+ZS5kYXRhc2V0c10sWyIkeGZhIiwoZSx0KT0+ZV0sWyJ4ZmEiLChlLHQpPT5lXSxbIiQiLChlLHQpPT50XV0pLFFuPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihlLHQsaT0hMCl7bGV0IGE9ZS5tYXRjaChDbik7aWYoIWEpcmV0dXJuIG51bGw7bGV0W3NdPWE7Y29uc3Qgcj1be25hbWU6cyxjYWNoZU5hbWU6Ii4iK3MsaW5kZXg6MCxqczpudWxsLGZvcm1DYWxjOm51bGwsb3BlcmF0b3I6bG4uZG90fV07bGV0IG49cy5sZW5ndGg7Zm9yKDtuPGUubGVuZ3RoOyl7Y29uc3QgZz1uO2lmKCJbIj09PWUuY2hhckF0KG4rKykpe2E9ZS5zbGljZShuKS5tYXRjaChobik7aWYoIWEpe3dhcm4oIlhGQSAtIEludmFsaWQgaW5kZXggaW4gU09NIGV4cHJlc3Npb24iKTtyZXR1cm4gbnVsbH1yLmF0KC0xKS5pbmRleD0iKiI9PT0obz0obz1hWzBdKS50cmltKCkpPzEvMDpwYXJzZUludChvLDEwKXx8MDtuKz1hWzBdLmxlbmd0aCsxO2NvbnRpbnVlfWxldCBjO3N3aXRjaChlLmNoYXJBdChuKSl7Y2FzZSIuIjppZighdClyZXR1cm4gbnVsbDtuKys7Yz1sbi5kb3REb3Q7YnJlYWs7Y2FzZSIjIjpuKys7Yz1sbi5kb3RIYXNoO2JyZWFrO2Nhc2UiWyI6aWYoaSl7d2FybigiWEZBIC0gU09NIGV4cHJlc3Npb24gY29udGFpbnMgYSBGb3JtQ2FsYyBzdWJleHByZXNzaW9uIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdy4iKTtyZXR1cm4gbnVsbH1jPWxuLmRvdEJyYWNrZXQ7YnJlYWs7Y2FzZSIoIjppZihpKXt3YXJuKCJYRkEgLSBTT00gZXhwcmVzc2lvbiBjb250YWlucyBhIEphdmFTY3JpcHQgc3ViZXhwcmVzc2lvbiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkIGZvciBub3cuIik7cmV0dXJuIG51bGx9Yz1sbi5kb3RQYXJlbjticmVhaztkZWZhdWx0OmM9bG4uZG90fWE9ZS5zbGljZShuKS5tYXRjaChDbik7aWYoIWEpYnJlYWs7W3NdPWE7bis9cy5sZW5ndGg7ci5wdXNoKHtuYW1lOnMsY2FjaGVOYW1lOmUuc2xpY2UoZyxuKSxvcGVyYXRvcjpjLGluZGV4OjAsanM6bnVsbCxmb3JtQ2FsYzpudWxsfSl9dmFyIG87cmV0dXJuIHJ9ZnVuY3Rpb24gc2VhcmNoTm9kZShlLHQsaSxhPSEwLHM9ITApe2NvbnN0IHI9cGFyc2VFeHByZXNzaW9uKGksYSk7aWYoIXIpcmV0dXJuIG51bGw7Y29uc3Qgbj1Cbi5nZXQoclswXS5uYW1lKTtsZXQgbyxnPTA7aWYobil7bz0hMDtlPVtuKGUsdCldO2c9MX1lbHNle289bnVsbD09PXQ7ZT1bdHx8ZV19Zm9yKGxldCBpPXIubGVuZ3RoO2c8aTtnKyspe2NvbnN0e25hbWU6aSxjYWNoZU5hbWU6YSxvcGVyYXRvcjpuLGluZGV4OmN9PXJbZ10sQz1bXTtmb3IoY29uc3QgdCBvZiBlKXtpZighdC5pc1hGQU9iamVjdCljb250aW51ZTtsZXQgZSxyO2lmKHMpe3I9UW4uZ2V0KHQpO2lmKCFyKXtyPW5ldyBNYXA7UW4uc2V0KHQscil9ZT1yLmdldChhKX1pZighZSl7c3dpdGNoKG4pe2Nhc2UgbG4uZG90OmU9dFtjcl0oaSwhMSk7YnJlYWs7Y2FzZSBsbi5kb3REb3Q6ZT10W2NyXShpLCEwKTticmVhaztjYXNlIGxuLmRvdEhhc2g6ZT10W0lyXShpKTtlPWUuaXNYRkFPYmplY3RBcnJheT9lLmNoaWxkcmVuOltlXX1zJiZyLnNldChhLGUpfWUubGVuZ3RoPjAmJkMucHVzaChlKX1pZigwIT09Qy5sZW5ndGh8fG98fDAhPT1nKWU9aXNGaW5pdGUoYyk/Qy5maWx0ZXIoKGU9PmM8ZS5sZW5ndGgpKS5tYXAoKGU9PmVbY10pKTpDLmZsYXQoKTtlbHNle2NvbnN0IGk9dFtwcl0oKTtpZighKHQ9aSkpcmV0dXJuIG51bGw7Zz0tMTtlPVt0XX19cmV0dXJuIDA9PT1lLmxlbmd0aD9udWxsOmV9ZnVuY3Rpb24gY3JlYXRlRGF0YU5vZGUoZSx0LGkpe2NvbnN0IGE9cGFyc2VFeHByZXNzaW9uKGkpO2lmKCFhKXJldHVybiBudWxsO2lmKGEuc29tZSgoZT0+ZS5vcGVyYXRvcj09PWxuLmRvdERvdCkpKXJldHVybiBudWxsO2NvbnN0IHM9Qm4uZ2V0KGFbMF0ubmFtZSk7bGV0IHI9MDtpZihzKXtlPXMoZSx0KTtyPTF9ZWxzZSBlPXR8fGU7Zm9yKGxldCB0PWEubGVuZ3RoO3I8dDtyKyspe2NvbnN0e25hbWU6dCxvcGVyYXRvcjppLGluZGV4OnN9PWFbcl07aWYoIWlzRmluaXRlKHMpKXthW3JdLmluZGV4PTA7cmV0dXJuIGUuY3JlYXRlTm9kZXMoYS5zbGljZShyKSl9bGV0IG47c3dpdGNoKGkpe2Nhc2UgbG4uZG90Om49ZVtjcl0odCwhMSk7YnJlYWs7Y2FzZSBsbi5kb3REb3Q6bj1lW2NyXSh0LCEwKTticmVhaztjYXNlIGxuLmRvdEhhc2g6bj1lW0lyXSh0KTtuPW4uaXNYRkFPYmplY3RBcnJheT9uLmNoaWxkcmVuOltuXX1pZigwPT09bi5sZW5ndGgpcmV0dXJuIGUuY3JlYXRlTm9kZXMoYS5zbGljZShyKSk7aWYoIShzPG4ubGVuZ3RoKSl7YVtyXS5pbmRleD1zLW4ubGVuZ3RoO3JldHVybiBlLmNyZWF0ZU5vZGVzKGEuc2xpY2UocikpfXtjb25zdCB0PW5bc107aWYoIXQuaXNYRkFPYmplY3Qpe3dhcm4oIlhGQSAtIENhbm5vdCBjcmVhdGUgYSBub2RlLiIpO3JldHVybiBudWxsfWU9dH19cmV0dXJuIG51bGx9Y29uc3QgRW49U3ltYm9sKCksdW49U3ltYm9sKCksZG49U3ltYm9sKCksZm49U3ltYm9sKCJfY2hpbGRyZW4iKSxwbj1TeW1ib2woKSxtbj1TeW1ib2woKSx5bj1TeW1ib2woKSx3bj1TeW1ib2woKSxibj1TeW1ib2woKSxEbj1TeW1ib2woKSxGbj1TeW1ib2woKSxTbj1TeW1ib2woKSxrbj1TeW1ib2woKSxObj1TeW1ib2woInBhcmVudCIpLFJuPVN5bWJvbCgpLEduPVN5bWJvbCgpLHhuPVN5bWJvbCgpO2xldCBVbj0wO2NvbnN0IE1uPWduLmRhdGFzZXRzLmlkO2NsYXNzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlLHQsaT0hMSl7dGhpc1tKcl09ZTt0aGlzW1lyXT10O3RoaXNbRm5dPWk7dGhpc1tObl09bnVsbDt0aGlzW2ZuXT1bXTt0aGlzW25uXT1gJHt0fSR7VW4rK31gO3RoaXNbeXJdPW51bGx9Z2V0IGlzWEZBT2JqZWN0KCl7cmV0dXJuITB9Z2V0IGlzWEZBT2JqZWN0QXJyYXkoKXtyZXR1cm4hMX1jcmVhdGVOb2RlcyhlKXtsZXQgdD10aGlzLGk9bnVsbDtmb3IoY29uc3R7bmFtZTphLGluZGV4OnN9b2YgZSl7Zm9yKGxldCBlPTAscj1pc0Zpbml0ZShzKT9zOjA7ZTw9cjtlKyspe2NvbnN0IGU9dFtKcl09PT1Nbj8tMTp0W0pyXTtpPW5ldyBYbWxPYmplY3QoZSxhKTt0W1hzXShpKX10PWl9cmV0dXJuIGl9W0tyXShlKXtpZighdGhpc1tGbl18fCF0aGlzW1RyXShlKSlyZXR1cm4hMTtjb25zdCB0PWVbWXJdLGk9dGhpc1t0XTtpZighKGkgaW5zdGFuY2VvZiBYRkFPYmplY3RBcnJheSkpe251bGwhPT1pJiZ0aGlzW2pyXShpKTt0aGlzW3RdPWU7dGhpc1tYc10oZSk7cmV0dXJuITB9aWYoaS5wdXNoKGUpKXt0aGlzW1hzXShlKTtyZXR1cm4hMH1sZXQgYT0iIjt0aGlzLmlkP2E9YCAoaWQ6ICR7dGhpcy5pZH0pYDp0aGlzLm5hbWUmJihhPWAgKG5hbWU6ICR7dGhpcy5uYW1lfSAke3RoaXMuaC52YWx1ZX0pYCk7d2FybihgWEZBIC0gbm9kZSAiJHt0aGlzW1lyXX0iJHthfSBoYXMgYWxyZWFkeSBlbm91Z2ggIiR7dH0iIWApO3JldHVybiExfVtUcl0oZSl7cmV0dXJuIHRoaXMuaGFzT3duUHJvcGVydHkoZVtZcl0pJiZlW0pyXT09PXRoaXNbSnJdfVtHcl0oKXtyZXR1cm4hMX1bV3NdKCl7cmV0dXJuITF9W1NyXSgpe3JldHVybiExfVtrcl0oKXtyZXR1cm4hMX1bUHJdKCl7dGhpcy5wYXJhJiZ0aGlzW21yXSgpW2FyXS5wYXJhU3RhY2sucG9wKCl9W1dyXSgpe3RoaXNbbXJdKClbYXJdLnBhcmFTdGFjay5wdXNoKHRoaXMucGFyYSl9W3pyXShlKXt0aGlzLmlkJiZ0aGlzW0pyXT09PWduLnRlbXBsYXRlLmlkJiZlLnNldCh0aGlzLmlkLHRoaXMpfVttcl0oKXtyZXR1cm4gdGhpc1t5cl0udGVtcGxhdGV9W3hyXSgpe3JldHVybiExfVtVcl0oKXtyZXR1cm4hMX1bWHNdKGUpe2VbTm5dPXRoaXM7dGhpc1tmbl0ucHVzaChlKTshZVt5cl0mJnRoaXNbeXJdJiYoZVt5cl09dGhpc1t5cl0pfVtqcl0oZSl7Y29uc3QgdD10aGlzW2ZuXS5pbmRleE9mKGUpO3RoaXNbZm5dLnNwbGljZSh0LDEpfVt3cl0oKXtyZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eSgidmFsdWUiKX1bJHJdKGUpe31bcXJdKGUpe31bc3JdKCl7fVtWc10oZSl7ZGVsZXRlIHRoaXNbRm5dO2lmKHRoaXNbX3NdKXtlLmNsZWFuKHRoaXNbX3NdKTtkZWxldGUgdGhpc1tfc119fVtEcl0oZSl7cmV0dXJuIHRoaXNbZm5dLmluZGV4T2YoZSl9W0ZyXShlLHQpe3RbTm5dPXRoaXM7dGhpc1tmbl0uc3BsaWNlKGUsMCx0KTshdFt5cl0mJnRoaXNbeXJdJiYodFt5cl09dGhpc1t5cl0pfVtNcl0oKXtyZXR1cm4hdGhpcy5uYW1lfVtIcl0oKXtyZXR1cm4iIn1bZW5dKCl7cmV0dXJuIDA9PT10aGlzW2ZuXS5sZW5ndGg/dGhpc1tlcl06dGhpc1tmbl0ubWFwKChlPT5lW2VuXSgpKSkuam9pbigiIil9Z2V0W2RuXSgpe2NvbnN0IGU9T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO2lmKCFlLl9hdHRyaWJ1dGVzKXtjb25zdCB0PWUuX2F0dHJpYnV0ZXM9bmV3IFNldDtmb3IoY29uc3QgZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7aWYobnVsbD09PXRoaXNbZV18fHRoaXNbZV1pbnN0YW5jZW9mIFhGQU9iamVjdHx8dGhpc1tlXWluc3RhbmNlb2YgWEZBT2JqZWN0QXJyYXkpYnJlYWs7dC5hZGQoZSl9fXJldHVybiBzaGFkb3codGhpcyxkbixlLl9hdHRyaWJ1dGVzKX1bUnJdKGUpe2xldCB0PXRoaXM7Zm9yKDt0Oyl7aWYodD09PWUpcmV0dXJuITA7dD10W3ByXSgpfXJldHVybiExfVtwcl0oKXtyZXR1cm4gdGhpc1tObl19W2ZyXSgpe3JldHVybiB0aGlzW3ByXSgpfVtFcl0oZT1udWxsKXtyZXR1cm4gZT90aGlzW2VdOnRoaXNbZm5dfVtpcl0oKXtjb25zdCBlPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpc1tlcl0mJihlLiRjb250ZW50PXRoaXNbZXJdKTtmb3IoY29uc3QgdCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7Y29uc3QgaT10aGlzW3RdO251bGwhPT1pJiYoaSBpbnN0YW5jZW9mIFhGQU9iamVjdD9lW3RdPWlbaXJdKCk6aSBpbnN0YW5jZW9mIFhGQU9iamVjdEFycmF5P2kuaXNFbXB0eSgpfHwoZVt0XT1pLmR1bXAoKSk6ZVt0XT1pKX1yZXR1cm4gZX1bcm5dKCl7cmV0dXJuIG51bGx9W2FuXSgpe3JldHVybiBIVE1MUmVzdWx0LkVNUFRZfSpbdXJdKCl7Zm9yKGNvbnN0IGUgb2YgdGhpc1tFcl0oKSl5aWVsZCBlfSpbd25dKGUsdCl7Zm9yKGNvbnN0IGkgb2YgdGhpc1t1cl0oKSlpZighZXx8dD09PWUuaGFzKGlbWXJdKSl7Y29uc3QgZT10aGlzW2dyXSgpLHQ9aVthbl0oZSk7dC5zdWNjZXNzfHwodGhpc1thcl0uZmFpbGluZ05vZGU9aSk7eWllbGQgdH19W3JyXSgpe3JldHVybiBudWxsfVtqc10oZSx0KXt0aGlzW2FyXS5jaGlsZHJlbi5wdXNoKGUpfVtncl0oKXt9W1pzXSh7ZmlsdGVyOmU9bnVsbCxpbmNsdWRlOnQ9ITB9KXtpZih0aGlzW2FyXS5nZW5lcmF0b3Ipe2NvbnN0IGU9dGhpc1tncl0oKSx0PXRoaXNbYXJdLmZhaWxpbmdOb2RlW2FuXShlKTtpZighdC5zdWNjZXNzKXJldHVybiB0O3QuaHRtbCYmdGhpc1tqc10odC5odG1sLHQuYmJveCk7ZGVsZXRlIHRoaXNbYXJdLmZhaWxpbmdOb2RlfWVsc2UgdGhpc1thcl0uZ2VuZXJhdG9yPXRoaXNbd25dKGUsdCk7Zm9yKDs7KXtjb25zdCBlPXRoaXNbYXJdLmdlbmVyYXRvci5uZXh0KCk7aWYoZS5kb25lKWJyZWFrO2NvbnN0IHQ9ZS52YWx1ZTtpZighdC5zdWNjZXNzKXJldHVybiB0O3QuaHRtbCYmdGhpc1tqc10odC5odG1sLHQuYmJveCl9dGhpc1thcl0uZ2VuZXJhdG9yPW51bGw7cmV0dXJuIEhUTUxSZXN1bHQuRU1QVFl9W19yXShlKXt0aGlzW0duXT1uZXcgU2V0KE9iamVjdC5rZXlzKGUpKX1bRG5dKGUpe2NvbnN0IHQ9dGhpc1tkbl0saT10aGlzW0duXTtyZXR1cm5bLi4uZV0uZmlsdGVyKChlPT50LmhhcyhlKSYmIWkuaGFzKGUpKSl9W1pyXShlLHQ9bmV3IFNldCl7Zm9yKGNvbnN0IGkgb2YgdGhpc1tmbl0paVtSbl0oZSx0KX1bUm5dKGUsdCl7Y29uc3QgaT10aGlzW2JuXShlLHQpO2k/dGhpc1tFbl0oaSxlLHQpOnRoaXNbWnJdKGUsdCl9W2JuXShlLHQpe2NvbnN0e3VzZTppLHVzZWhyZWY6YX09dGhpcztpZighaSYmIWEpcmV0dXJuIG51bGw7bGV0IHM9bnVsbCxyPW51bGwsbj1udWxsLG89aTtpZihhKXtvPWE7YS5zdGFydHNXaXRoKCIjc29tKCIpJiZhLmVuZHNXaXRoKCIpIik/cj1hLnNsaWNlKDUsLTEpOmEuc3RhcnRzV2l0aCgiLiNzb20oIikmJmEuZW5kc1dpdGgoIikiKT9yPWEuc2xpY2UoNiwtMSk6YS5zdGFydHNXaXRoKCIjIik/bj1hLnNsaWNlKDEpOmEuc3RhcnRzV2l0aCgiLiMiKSYmKG49YS5zbGljZSgyKSl9ZWxzZSBpLnN0YXJ0c1dpdGgoIiMiKT9uPWkuc2xpY2UoMSk6cj1pO3RoaXMudXNlPXRoaXMudXNlaHJlZj0iIjtpZihuKXM9ZS5nZXQobik7ZWxzZXtzPXNlYXJjaE5vZGUoZS5nZXQoWHIpLHRoaXMsciwhMCwhMSk7cyYmKHM9c1swXSl9aWYoIXMpe3dhcm4oYFhGQSAtIEludmFsaWQgcHJvdG90eXBlIHJlZmVyZW5jZTogJHtvfS5gKTtyZXR1cm4gbnVsbH1pZihzW1lyXSE9PXRoaXNbWXJdKXt3YXJuKGBYRkEgLSBJbmNvbXBhdGlibGUgcHJvdG90eXBlOiAke3NbWXJdfSAhPT0gJHt0aGlzW1lyXX0uYCk7cmV0dXJuIG51bGx9aWYodC5oYXMocykpe3dhcm4oIlhGQSAtIEN5Y2xlIGRldGVjdGVkIGluIHByb3RvdHlwZXMgdXNlLiIpO3JldHVybiBudWxsfXQuYWRkKHMpO2NvbnN0IGc9c1tibl0oZSx0KTtnJiZzW0VuXShnLGUsdCk7c1tacl0oZSx0KTt0LmRlbGV0ZShzKTtyZXR1cm4gc31bRW5dKGUsdCxpKXtpZihpLmhhcyhlKSl7d2FybigiWEZBIC0gQ3ljbGUgZGV0ZWN0ZWQgaW4gcHJvdG90eXBlcyB1c2UuIik7cmV0dXJufSF0aGlzW2VyXSYmZVtlcl0mJih0aGlzW2VyXT1lW2VyXSk7bmV3IFNldChpKS5hZGQoZSk7Zm9yKGNvbnN0IHQgb2YgdGhpc1tEbl0oZVtHbl0pKXt0aGlzW3RdPWVbdF07dGhpc1tHbl0mJnRoaXNbR25dLmFkZCh0KX1mb3IoY29uc3QgYSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSl7aWYodGhpc1tkbl0uaGFzKGEpKWNvbnRpbnVlO2NvbnN0IHM9dGhpc1thXSxyPWVbYV07aWYocyBpbnN0YW5jZW9mIFhGQU9iamVjdEFycmF5KXtmb3IoY29uc3QgZSBvZiBzW2ZuXSllW1JuXSh0LGkpO2ZvcihsZXQgYT1zW2ZuXS5sZW5ndGgsbj1yW2ZuXS5sZW5ndGg7YTxuO2ErKyl7Y29uc3Qgcj1lW2ZuXVthXVskc10oKTtpZighcy5wdXNoKHIpKWJyZWFrO3JbTm5dPXRoaXM7dGhpc1tmbl0ucHVzaChyKTtyW1JuXSh0LGkpfX1lbHNlIGlmKG51bGw9PT1zKXtpZihudWxsIT09cil7Y29uc3QgZT1yWyRzXSgpO2VbTm5dPXRoaXM7dGhpc1thXT1lO3RoaXNbZm5dLnB1c2goZSk7ZVtSbl0odCxpKX19ZWxzZXtzW1pyXSh0LGkpO3ImJnNbRW5dKHIsdCxpKX19fXN0YXRpY1twbl0oZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5tYXAoKGU9PlhGQU9iamVjdFtwbl0oZSkpKToib2JqZWN0Ij09dHlwZW9mIGUmJm51bGwhPT1lP09iamVjdC5hc3NpZ24oe30sZSk6ZX1bJHNdKCl7Y29uc3QgZT1PYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0aGlzKSl0cnl7ZVt0XT10aGlzW3RdfWNhdGNoe3NoYWRvdyhlLHQsdGhpc1t0XSl9ZVtubl09YCR7ZVtZcl19JHtVbisrfWA7ZVtmbl09W107Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpe2lmKHRoaXNbZG5dLmhhcyh0KSl7ZVt0XT1YRkFPYmplY3RbcG5dKHRoaXNbdF0pO2NvbnRpbnVlfWNvbnN0IGk9dGhpc1t0XTtlW3RdPWkgaW5zdGFuY2VvZiBYRkFPYmplY3RBcnJheT9uZXcgWEZBT2JqZWN0QXJyYXkoaVtTbl0pOm51bGx9Zm9yKGNvbnN0IHQgb2YgdGhpc1tmbl0pe2NvbnN0IGk9dFtZcl0sYT10WyRzXSgpO2VbZm5dLnB1c2goYSk7YVtObl09ZTtudWxsPT09ZVtpXT9lW2ldPWE6ZVtpXVtmbl0ucHVzaChhKX1yZXR1cm4gZX1bRXJdKGU9bnVsbCl7cmV0dXJuIGU/dGhpc1tmbl0uZmlsdGVyKCh0PT50W1lyXT09PWUpKTp0aGlzW2ZuXX1bSXJdKGUpe3JldHVybiB0aGlzW2VdfVtjcl0oZSx0LGk9ITApe3JldHVybiBBcnJheS5mcm9tKHRoaXNbQ3JdKGUsdCxpKSl9KltDcl0oZSx0LGk9ITApe2lmKCJwYXJlbnQiIT09ZSl7Zm9yKGNvbnN0IGkgb2YgdGhpc1tmbl0pe2lbWXJdPT09ZSYmKHlpZWxkIGkpO2kubmFtZT09PWUmJih5aWVsZCBpKTsodHx8aVtNcl0oKSkmJih5aWVsZCppW0NyXShlLHQsITEpKX1pJiZ0aGlzW2RuXS5oYXMoZSkmJih5aWVsZCBuZXcgWEZBQXR0cmlidXRlKHRoaXMsZSx0aGlzW2VdKSl9ZWxzZSB5aWVsZCB0aGlzW05uXX19Y2xhc3MgWEZBT2JqZWN0QXJyYXl7Y29uc3RydWN0b3IoZT0xLzApe3RoaXNbU25dPWU7dGhpc1tmbl09W119Z2V0IGlzWEZBT2JqZWN0KCl7cmV0dXJuITF9Z2V0IGlzWEZBT2JqZWN0QXJyYXkoKXtyZXR1cm4hMH1wdXNoKGUpe2lmKHRoaXNbZm5dLmxlbmd0aDw9dGhpc1tTbl0pe3RoaXNbZm5dLnB1c2goZSk7cmV0dXJuITB9d2FybihgWEZBIC0gbm9kZSAiJHtlW1lyXX0iIGFjY2VwdHMgbm8gbW9yZSB0aGFuICR7dGhpc1tTbl19IGNoaWxkcmVuYCk7cmV0dXJuITF9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpc1tmbl0ubGVuZ3RofWR1bXAoKXtyZXR1cm4gMT09PXRoaXNbZm5dLmxlbmd0aD90aGlzW2ZuXVswXVtpcl0oKTp0aGlzW2ZuXS5tYXAoKGU9PmVbaXJdKCkpKX1bJHNdKCl7Y29uc3QgZT1uZXcgWEZBT2JqZWN0QXJyYXkodGhpc1tTbl0pO2VbZm5dPXRoaXNbZm5dLm1hcCgoZT0+ZVskc10oKSkpO3JldHVybiBlfWdldCBjaGlsZHJlbigpe3JldHVybiB0aGlzW2ZuXX1jbGVhcigpe3RoaXNbZm5dLmxlbmd0aD0wfX1jbGFzcyBYRkFBdHRyaWJ1dGV7Y29uc3RydWN0b3IoZSx0LGkpe3RoaXNbTm5dPWU7dGhpc1tZcl09dDt0aGlzW2VyXT1pO3RoaXNbQXJdPSExO3RoaXNbbm5dPSJhdHRyaWJ1dGUiK1VuKyt9W3ByXSgpe3JldHVybiB0aGlzW05uXX1bTnJdKCl7cmV0dXJuITB9W2hyXSgpe3JldHVybiB0aGlzW2VyXS50cmltKCl9WyRyXShlKXtlPWUudmFsdWV8fCIiO3RoaXNbZXJdPWUudG9TdHJpbmcoKX1bZW5dKCl7cmV0dXJuIHRoaXNbZXJdfVtScl0oZSl7cmV0dXJuIHRoaXNbTm5dPT09ZXx8dGhpc1tObl1bUnJdKGUpfX1jbGFzcyBYbWxPYmplY3QgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSx0LGk9e30pe3N1cGVyKGUsdCk7dGhpc1tlcl09IiI7dGhpc1ttbl09bnVsbDtpZigiI3RleHQiIT09dCl7Y29uc3QgZT1uZXcgTWFwO3RoaXNbdW5dPWU7Zm9yKGNvbnN0W3QsYV1vZiBPYmplY3QuZW50cmllcyhpKSllLnNldCh0LG5ldyBYRkFBdHRyaWJ1dGUodGhpcyx0LGEpKTtpZihpLmhhc093blByb3BlcnR5KHZyKSl7Y29uc3QgZT1pW3ZyXS54ZmEuZGF0YU5vZGU7dm9pZCAwIT09ZSYmKCJkYXRhR3JvdXAiPT09ZT90aGlzW21uXT0hMToiZGF0YVZhbHVlIj09PWUmJih0aGlzW21uXT0hMCkpfX10aGlzW0FyXT0hMX1bc25dKGUpe2NvbnN0IHQ9dGhpc1tZcl07aWYoIiN0ZXh0Ij09PXQpe2UucHVzaChlbmNvZGVUb1htbFN0cmluZyh0aGlzW2VyXSkpO3JldHVybn1jb25zdCBpPXV0ZjhTdHJpbmdUb1N0cmluZyh0KSxhPXRoaXNbSnJdPT09TW4/InhmYToiOiIiO2UucHVzaChgPCR7YX0ke2l9YCk7Zm9yKGNvbnN0W3QsaV1vZiB0aGlzW3VuXS5lbnRyaWVzKCkpe2NvbnN0IGE9dXRmOFN0cmluZ1RvU3RyaW5nKHQpO2UucHVzaChgICR7YX09IiR7ZW5jb2RlVG9YbWxTdHJpbmcoaVtlcl0pfSJgKX1udWxsIT09dGhpc1ttbl0mJih0aGlzW21uXT9lLnB1c2goJyB4ZmE6ZGF0YU5vZGU9ImRhdGFWYWx1ZSInKTplLnB1c2goJyB4ZmE6ZGF0YU5vZGU9ImRhdGFHcm91cCInKSk7aWYodGhpc1tlcl18fDAhPT10aGlzW2ZuXS5sZW5ndGgpe2UucHVzaCgiPiIpO2lmKHRoaXNbZXJdKSJzdHJpbmciPT10eXBlb2YgdGhpc1tlcl0/ZS5wdXNoKGVuY29kZVRvWG1sU3RyaW5nKHRoaXNbZXJdKSk6dGhpc1tlcl1bc25dKGUpO2Vsc2UgZm9yKGNvbnN0IHQgb2YgdGhpc1tmbl0pdFtzbl0oZSk7ZS5wdXNoKGA8LyR7YX0ke2l9PmApfWVsc2UgZS5wdXNoKCIvPiIpfVtLcl0oZSl7aWYodGhpc1tlcl0pe2NvbnN0IGU9bmV3IFhtbE9iamVjdCh0aGlzW0pyXSwiI3RleHQiKTt0aGlzW1hzXShlKTtlW2VyXT10aGlzW2VyXTt0aGlzW2VyXT0iIn10aGlzW1hzXShlKTtyZXR1cm4hMH1bcXJdKGUpe3RoaXNbZXJdKz1lfVtzcl0oKXtpZih0aGlzW2VyXSYmdGhpc1tmbl0ubGVuZ3RoPjApe2NvbnN0IGU9bmV3IFhtbE9iamVjdCh0aGlzW0pyXSwiI3RleHQiKTt0aGlzW1hzXShlKTtlW2VyXT10aGlzW2VyXTtkZWxldGUgdGhpc1tlcl19fVthbl0oKXtyZXR1cm4iI3RleHQiPT09dGhpc1tZcl0/SFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiIjdGV4dCIsdmFsdWU6dGhpc1tlcl19KTpIVE1MUmVzdWx0LkVNUFRZfVtFcl0oZT1udWxsKXtyZXR1cm4gZT90aGlzW2ZuXS5maWx0ZXIoKHQ9PnRbWXJdPT09ZSkpOnRoaXNbZm5dfVtvcl0oKXtyZXR1cm4gdGhpc1t1bl19W0lyXShlKXtjb25zdCB0PXRoaXNbdW5dLmdldChlKTtyZXR1cm4gdm9pZCAwIT09dD90OnRoaXNbRXJdKGUpfSpbQ3JdKGUsdCl7Y29uc3QgaT10aGlzW3VuXS5nZXQoZSk7aSYmKHlpZWxkIGkpO2Zvcihjb25zdCBpIG9mIHRoaXNbZm5dKXtpW1lyXT09PWUmJih5aWVsZCBpKTt0JiYoeWllbGQqaVtDcl0oZSx0KSl9fSpbbnJdKGUsdCl7Y29uc3QgaT10aGlzW3VuXS5nZXQoZSk7IWl8fHQmJmlbQXJdfHwoeWllbGQgaSk7Zm9yKGNvbnN0IGkgb2YgdGhpc1tmbl0peWllbGQqaVtucl0oZSx0KX0qW1FyXShlLHQsaSl7Zm9yKGNvbnN0IGEgb2YgdGhpc1tmbl0pe2FbWXJdIT09ZXx8aSYmYVtBcl18fCh5aWVsZCBhKTt0JiYoeWllbGQqYVtRcl0oZSx0LGkpKX19W05yXSgpe3JldHVybiBudWxsPT09dGhpc1ttbl0/MD09PXRoaXNbZm5dLmxlbmd0aHx8dGhpc1tmbl1bMF1bSnJdPT09Z24ueGh0bWwuaWQ6dGhpc1ttbl19W2hyXSgpe3JldHVybiBudWxsPT09dGhpc1ttbl0/MD09PXRoaXNbZm5dLmxlbmd0aD90aGlzW2VyXS50cmltKCk6dGhpc1tmbl1bMF1bSnJdPT09Z24ueGh0bWwuaWQ/dGhpc1tmbl1bMF1bZW5dKCkudHJpbSgpOm51bGw6dGhpc1tlcl0udHJpbSgpfVskcl0oZSl7ZT1lLnZhbHVlfHwiIjt0aGlzW2VyXT1lLnRvU3RyaW5nKCl9W2lyXShlPSExKXtjb25zdCB0PU9iamVjdC5jcmVhdGUobnVsbCk7ZSYmKHQuJG5zPXRoaXNbSnJdKTt0aGlzW2VyXSYmKHQuJGNvbnRlbnQ9dGhpc1tlcl0pO3QuJG5hbWU9dGhpc1tZcl07dC5jaGlsZHJlbj1bXTtmb3IoY29uc3QgaSBvZiB0aGlzW2ZuXSl0LmNoaWxkcmVuLnB1c2goaVtpcl0oZSkpO3QuYXR0cmlidXRlcz1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdFtlLGldb2YgdGhpc1t1bl0pdC5hdHRyaWJ1dGVzW2VdPWlbZXJdO3JldHVybiB0fX1jbGFzcyBDb250ZW50T2JqZWN0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSx0KTt0aGlzW2VyXT0iIn1bcXJdKGUpe3RoaXNbZXJdKz1lfVtzcl0oKXt9fWNsYXNzIE9wdGlvbk9iamVjdCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKGUsdCk7dGhpc1trbl09aX1bc3JdKCl7dGhpc1tlcl09Z2V0S2V5d29yZCh7ZGF0YTp0aGlzW2VyXSxkZWZhdWx0VmFsdWU6dGhpc1trbl1bMF0sdmFsaWRhdGU6ZT0+dGhpc1trbl0uaW5jbHVkZXMoZSl9KX1bVnNdKGUpe3N1cGVyW1ZzXShlKTtkZWxldGUgdGhpc1trbl19fWNsYXNzIFN0cmluZ09iamVjdCBleHRlbmRzIENvbnRlbnRPYmplY3R7W3NyXSgpe3RoaXNbZXJdPXRoaXNbZXJdLnRyaW0oKX19Y2xhc3MgSW50ZWdlck9iamVjdCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSx0LGksYSl7c3VwZXIoZSx0KTt0aGlzW3luXT1pO3RoaXNbeG5dPWF9W3NyXSgpe3RoaXNbZXJdPWdldEludGVnZXIoe2RhdGE6dGhpc1tlcl0sZGVmYXVsdFZhbHVlOnRoaXNbeW5dLHZhbGlkYXRlOnRoaXNbeG5dfSl9W1ZzXShlKXtzdXBlcltWc10oZSk7ZGVsZXRlIHRoaXNbeW5dO2RlbGV0ZSB0aGlzW3huXX19Y2xhc3MgT3B0aW9uMDEgZXh0ZW5kcyBJbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoZSx0LDAsKGU9PjE9PT1lKSl9fWNsYXNzIE9wdGlvbjEwIGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlLHQpe3N1cGVyKGUsdCwxLChlPT4wPT09ZSkpfX1mdW5jdGlvbiBtZWFzdXJlVG9TdHJpbmcoZSl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiBlPyIwcHgiOk51bWJlci5pc0ludGVnZXIoZSk/YCR7ZX1weGA6YCR7ZS50b0ZpeGVkKDIpfXB4YH1jb25zdCBMbj17YW5jaG9yVHlwZShlLHQpe2NvbnN0IGk9ZVtmcl0oKTtpZihpJiYoIWkubGF5b3V0fHwicG9zaXRpb24iPT09aS5sYXlvdXQpKXsidHJhbnNmb3JtImluIHR8fCh0LnRyYW5zZm9ybT0iIik7c3dpdGNoKGUuYW5jaG9yVHlwZSl7Y2FzZSJib3R0b21DZW50ZXIiOnQudHJhbnNmb3JtKz0idHJhbnNsYXRlKC01MCUsIC0xMDAlKSI7YnJlYWs7Y2FzZSJib3R0b21MZWZ0Ijp0LnRyYW5zZm9ybSs9InRyYW5zbGF0ZSgwLC0xMDAlKSI7YnJlYWs7Y2FzZSJib3R0b21SaWdodCI6dC50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoLTEwMCUsLTEwMCUpIjticmVhaztjYXNlIm1pZGRsZUNlbnRlciI6dC50cmFuc2Zvcm0rPSJ0cmFuc2xhdGUoLTUwJSwtNTAlKSI7YnJlYWs7Y2FzZSJtaWRkbGVMZWZ0Ijp0LnRyYW5zZm9ybSs9InRyYW5zbGF0ZSgwLC01MCUpIjticmVhaztjYXNlIm1pZGRsZVJpZ2h0Ijp0LnRyYW5zZm9ybSs9InRyYW5zbGF0ZSgtMTAwJSwtNTAlKSI7YnJlYWs7Y2FzZSJ0b3BDZW50ZXIiOnQudHJhbnNmb3JtKz0idHJhbnNsYXRlKC01MCUsMCkiO2JyZWFrO2Nhc2UidG9wUmlnaHQiOnQudHJhbnNmb3JtKz0idHJhbnNsYXRlKC0xMDAlLDApIn19fSxkaW1lbnNpb25zKGUsdCl7Y29uc3QgaT1lW2ZyXSgpO2xldCBhPWUudztjb25zdCBzPWUuaDtpZihpLmxheW91dD8uaW5jbHVkZXMoInJvdyIpKXtjb25zdCB0PWlbYXJdLHM9ZS5jb2xTcGFuO2xldCByO2lmKC0xPT09cyl7cj10LmNvbHVtbldpZHRocy5zbGljZSh0LmN1cnJlbnRDb2x1bW4pLnJlZHVjZSgoKGUsdCk9PmUrdCksMCk7dC5jdXJyZW50Q29sdW1uPTB9ZWxzZXtyPXQuY29sdW1uV2lkdGhzLnNsaWNlKHQuY3VycmVudENvbHVtbix0LmN1cnJlbnRDb2x1bW4rcykucmVkdWNlKCgoZSx0KT0+ZSt0KSwwKTt0LmN1cnJlbnRDb2x1bW49KHQuY3VycmVudENvbHVtbitlLmNvbFNwYW4pJXQuY29sdW1uV2lkdGhzLmxlbmd0aH1pc05hTihyKXx8KGE9ZS53PXIpfXQud2lkdGg9IiIhPT1hP21lYXN1cmVUb1N0cmluZyhhKToiYXV0byI7dC5oZWlnaHQ9IiIhPT1zP21lYXN1cmVUb1N0cmluZyhzKToiYXV0byJ9LHBvc2l0aW9uKGUsdCl7Y29uc3QgaT1lW2ZyXSgpO2lmKCFpPy5sYXlvdXR8fCJwb3NpdGlvbiI9PT1pLmxheW91dCl7dC5wb3NpdGlvbj0iYWJzb2x1dGUiO3QubGVmdD1tZWFzdXJlVG9TdHJpbmcoZS54KTt0LnRvcD1tZWFzdXJlVG9TdHJpbmcoZS55KX19LHJvdGF0ZShlLHQpe2lmKGUucm90YXRlKXsidHJhbnNmb3JtImluIHR8fCh0LnRyYW5zZm9ybT0iIik7dC50cmFuc2Zvcm0rPWByb3RhdGUoLSR7ZS5yb3RhdGV9ZGVnKWA7dC50cmFuc2Zvcm1PcmlnaW49InRvcCBsZWZ0In19LHByZXNlbmNlKGUsdCl7c3dpdGNoKGUucHJlc2VuY2Upe2Nhc2UiaW52aXNpYmxlIjp0LnZpc2liaWxpdHk9ImhpZGRlbiI7YnJlYWs7Y2FzZSJoaWRkZW4iOmNhc2UiaW5hY3RpdmUiOnQuZGlzcGxheT0ibm9uZSJ9fSxoQWxpZ24oZSx0KXtpZigicGFyYSI9PT1lW1lyXSlzd2l0Y2goZS5oQWxpZ24pe2Nhc2UianVzdGlmeUFsbCI6dC50ZXh0QWxpZ249Imp1c3RpZnktYWxsIjticmVhaztjYXNlInJhZGl4Ijp0LnRleHRBbGlnbj0ibGVmdCI7YnJlYWs7ZGVmYXVsdDp0LnRleHRBbGlnbj1lLmhBbGlnbn1lbHNlIHN3aXRjaChlLmhBbGlnbil7Y2FzZSJsZWZ0Ijp0LmFsaWduU2VsZj0ic3RhcnQiO2JyZWFrO2Nhc2UiY2VudGVyIjp0LmFsaWduU2VsZj0iY2VudGVyIjticmVhaztjYXNlInJpZ2h0Ijp0LmFsaWduU2VsZj0iZW5kIn19LG1hcmdpbihlLHQpe2UubWFyZ2luJiYodC5tYXJnaW49ZS5tYXJnaW5bcm5dKCkubWFyZ2luKX19O2Z1bmN0aW9uIHNldE1pbk1heERpbWVuc2lvbnMoZSx0KXtpZigicG9zaXRpb24iPT09ZVtmcl0oKS5sYXlvdXQpe2UubWluVz4wJiYodC5taW5XaWR0aD1tZWFzdXJlVG9TdHJpbmcoZS5taW5XKSk7ZS5tYXhXPjAmJih0Lm1heFdpZHRoPW1lYXN1cmVUb1N0cmluZyhlLm1heFcpKTtlLm1pbkg+MCYmKHQubWluSGVpZ2h0PW1lYXN1cmVUb1N0cmluZyhlLm1pbkgpKTtlLm1heEg+MCYmKHQubWF4SGVpZ2h0PW1lYXN1cmVUb1N0cmluZyhlLm1heEgpKX19ZnVuY3Rpb24gbGF5b3V0VGV4dChlLHQsaSxhLHMscil7Y29uc3Qgbj1uZXcgVGV4dE1lYXN1cmUodCxpLGEscyk7InN0cmluZyI9PXR5cGVvZiBlP24uYWRkU3RyaW5nKGUpOmVbT3JdKG4pO3JldHVybiBuLmNvbXB1dGUocil9ZnVuY3Rpb24gbGF5b3V0Tm9kZShlLHQpe2xldCBpPW51bGwsYT1udWxsLHM9ITE7aWYoKCFlLnd8fCFlLmgpJiZlLnZhbHVlKXtsZXQgcj0wLG49MDtpZihlLm1hcmdpbil7cj1lLm1hcmdpbi5sZWZ0SW5zZXQrZS5tYXJnaW4ucmlnaHRJbnNldDtuPWUubWFyZ2luLnRvcEluc2V0K2UubWFyZ2luLmJvdHRvbUluc2V0fWxldCBvPW51bGwsZz1udWxsO2lmKGUucGFyYSl7Zz1PYmplY3QuY3JlYXRlKG51bGwpO289IiI9PT1lLnBhcmEubGluZUhlaWdodD9udWxsOmUucGFyYS5saW5lSGVpZ2h0O2cudG9wPSIiPT09ZS5wYXJhLnNwYWNlQWJvdmU/MDplLnBhcmEuc3BhY2VBYm92ZTtnLmJvdHRvbT0iIj09PWUucGFyYS5zcGFjZUJlbG93PzA6ZS5wYXJhLnNwYWNlQmVsb3c7Zy5sZWZ0PSIiPT09ZS5wYXJhLm1hcmdpbkxlZnQ/MDplLnBhcmEubWFyZ2luTGVmdDtnLnJpZ2h0PSIiPT09ZS5wYXJhLm1hcmdpblJpZ2h0PzA6ZS5wYXJhLm1hcmdpblJpZ2h0fWxldCBjPWUuZm9udDtpZighYyl7Y29uc3QgdD1lW21yXSgpO2xldCBpPWVbcHJdKCk7Zm9yKDtpJiZpIT09dDspe2lmKGkuZm9udCl7Yz1pLmZvbnQ7YnJlYWt9aT1pW3ByXSgpfX1jb25zdCBDPShlLnd8fHQud2lkdGgpLXIsaD1lW3lyXS5mb250RmluZGVyO2lmKGUudmFsdWUuZXhEYXRhJiZlLnZhbHVlLmV4RGF0YVtlcl0mJiJ0ZXh0L2h0bWwiPT09ZS52YWx1ZS5leERhdGEuY29udGVudFR5cGUpe2NvbnN0IHQ9bGF5b3V0VGV4dChlLnZhbHVlLmV4RGF0YVtlcl0sYyxnLG8saCxDKTthPXQud2lkdGg7aT10LmhlaWdodDtzPXQuaXNCcm9rZW59ZWxzZXtjb25zdCB0PWUudmFsdWVbZW5dKCk7aWYodCl7Y29uc3QgZT1sYXlvdXRUZXh0KHQsYyxnLG8saCxDKTthPWUud2lkdGg7aT1lLmhlaWdodDtzPWUuaXNCcm9rZW59fW51bGw9PT1hfHxlLnd8fChhKz1yKTtudWxsPT09aXx8ZS5ofHwoaSs9bil9cmV0dXJue3c6YSxoOmksaXNCcm9rZW46c319ZnVuY3Rpb24gY29tcHV0ZUJib3goZSx0LGkpe2xldCBhO2lmKCIiIT09ZS53JiYiIiE9PWUuaClhPVtlLngsZS55LGUudyxlLmhdO2Vsc2V7aWYoIWkpcmV0dXJuIG51bGw7bGV0IHM9ZS53O2lmKCIiPT09cyl7aWYoMD09PWUubWF4Vyl7Y29uc3QgdD1lW2ZyXSgpO3M9InBvc2l0aW9uIj09PXQubGF5b3V0JiYiIiE9PXQudz8wOmUubWluV31lbHNlIHM9TWF0aC5taW4oZS5tYXhXLGkud2lkdGgpO3QuYXR0cmlidXRlcy5zdHlsZS53aWR0aD1tZWFzdXJlVG9TdHJpbmcocyl9bGV0IHI9ZS5oO2lmKCIiPT09cil7aWYoMD09PWUubWF4SCl7Y29uc3QgdD1lW2ZyXSgpO3I9InBvc2l0aW9uIj09PXQubGF5b3V0JiYiIiE9PXQuaD8wOmUubWluSH1lbHNlIHI9TWF0aC5taW4oZS5tYXhILGkuaGVpZ2h0KTt0LmF0dHJpYnV0ZXMuc3R5bGUuaGVpZ2h0PW1lYXN1cmVUb1N0cmluZyhyKX1hPVtlLngsZS55LHMscl19cmV0dXJuIGF9ZnVuY3Rpb24gZml4RGltZW5zaW9ucyhlKXtjb25zdCB0PWVbZnJdKCk7aWYodC5sYXlvdXQ/LmluY2x1ZGVzKCJyb3ciKSl7Y29uc3QgaT10W2FyXSxhPWUuY29sU3BhbjtsZXQgcztzPS0xPT09YT9pLmNvbHVtbldpZHRocy5zbGljZShpLmN1cnJlbnRDb2x1bW4pLnJlZHVjZSgoKGUsdCk9PmUrdCksMCk6aS5jb2x1bW5XaWR0aHMuc2xpY2UoaS5jdXJyZW50Q29sdW1uLGkuY3VycmVudENvbHVtbithKS5yZWR1Y2UoKChlLHQpPT5lK3QpLDApO2lzTmFOKHMpfHwoZS53PXMpfXQubGF5b3V0JiYicG9zaXRpb24iIT09dC5sYXlvdXQmJihlLng9ZS55PTApOyJ0YWJsZSI9PT1lLmxheW91dCYmIiI9PT1lLncmJkFycmF5LmlzQXJyYXkoZS5jb2x1bW5XaWR0aHMpJiYoZS53PWUuY29sdW1uV2lkdGhzLnJlZHVjZSgoKGUsdCk9PmUrdCksMCkpfWZ1bmN0aW9uIGxheW91dENsYXNzKGUpe3N3aXRjaChlLmxheW91dCl7Y2FzZSJwb3NpdGlvbiI6ZGVmYXVsdDpyZXR1cm4ieGZhUG9zaXRpb24iO2Nhc2UibHItdGIiOnJldHVybiJ4ZmFMclRiIjtjYXNlInJsLXJvdyI6cmV0dXJuInhmYVJsUm93IjtjYXNlInJsLXRiIjpyZXR1cm4ieGZhUmxUYiI7Y2FzZSJyb3ciOnJldHVybiJ4ZmFSb3ciO2Nhc2UidGFibGUiOnJldHVybiJ4ZmFUYWJsZSI7Y2FzZSJ0YiI6cmV0dXJuInhmYVRiIn19ZnVuY3Rpb24gdG9TdHlsZShlLC4uLnQpe2NvbnN0IGk9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IoY29uc3QgYSBvZiB0KXtjb25zdCB0PWVbYV07aWYobnVsbCE9PXQpaWYoTG4uaGFzT3duUHJvcGVydHkoYSkpTG5bYV0oZSxpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBYRkFPYmplY3Qpe2NvbnN0IGU9dFtybl0oKTtlP09iamVjdC5hc3NpZ24oaSxlKTp3YXJuKGAoREVCVUcpIC0gWEZBIC0gc3R5bGUgZm9yICR7YX0gbm90IGltcGxlbWVudGVkIHlldGApfX1yZXR1cm4gaX1mdW5jdGlvbiBjcmVhdGVXcmFwcGVyKGUsdCl7Y29uc3R7YXR0cmlidXRlczppfT10LHtzdHlsZTphfT1pLHM9e25hbWU6ImRpdiIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFXcmFwcGVyIl0sc3R5bGU6T2JqZWN0LmNyZWF0ZShudWxsKX0sY2hpbGRyZW46W119O2kuY2xhc3MucHVzaCgieGZhV3JhcHBlZCIpO2lmKGUuYm9yZGVyKXtjb25zdHt3aWR0aHM6aSxpbnNldHM6cn09ZS5ib3JkZXJbYXJdO2xldCBuLG8sZz1yWzBdLGM9clszXTtjb25zdCBDPXJbMF0rclsyXSxoPXJbMV0rclszXTtzd2l0Y2goZS5ib3JkZXIuaGFuZCl7Y2FzZSJldmVuIjpnLT1pWzBdLzI7Yy09aVszXS8yO249YGNhbGMoMTAwJSArICR7KGlbMV0raVszXSkvMi1ofXB4KWA7bz1gY2FsYygxMDAlICsgJHsoaVswXStpWzJdKS8yLUN9cHgpYDticmVhaztjYXNlImxlZnQiOmctPWlbMF07Yy09aVszXTtuPWBjYWxjKDEwMCUgKyAke2lbMV0raVszXS1ofXB4KWA7bz1gY2FsYygxMDAlICsgJHtpWzBdK2lbMl0tQ31weClgO2JyZWFrO2Nhc2UicmlnaHQiOm49aD9gY2FsYygxMDAlIC0gJHtofXB4KWA6IjEwMCUiO289Qz9gY2FsYygxMDAlIC0gJHtDfXB4KWA6IjEwMCUifWNvbnN0IGw9WyJ4ZmFCb3JkZXIiXTtpc1ByaW50T25seShlLmJvcmRlcikmJmwucHVzaCgieGZhUHJpbnRPbmx5Iik7Y29uc3QgUT17bmFtZToiZGl2IixhdHRyaWJ1dGVzOntjbGFzczpsLHN0eWxlOnt0b3A6YCR7Z31weGAsbGVmdDpgJHtjfXB4YCx3aWR0aDpuLGhlaWdodDpvfX0sY2hpbGRyZW46W119O2Zvcihjb25zdCBlIG9mWyJib3JkZXIiLCJib3JkZXJXaWR0aCIsImJvcmRlckNvbG9yIiwiYm9yZGVyUmFkaXVzIiwiYm9yZGVyU3R5bGUiXSlpZih2b2lkIDAhPT1hW2VdKXtRLmF0dHJpYnV0ZXMuc3R5bGVbZV09YVtlXTtkZWxldGUgYVtlXX1zLmNoaWxkcmVuLnB1c2goUSx0KX1lbHNlIHMuY2hpbGRyZW4ucHVzaCh0KTtmb3IoY29uc3QgZSBvZlsiYmFja2dyb3VuZCIsImJhY2tncm91bmRDbGlwIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwibWluV2lkdGgiLCJtaW5IZWlnaHQiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInRyYW5zZm9ybSIsInRyYW5zZm9ybU9yaWdpbiIsInZpc2liaWxpdHkiXSlpZih2b2lkIDAhPT1hW2VdKXtzLmF0dHJpYnV0ZXMuc3R5bGVbZV09YVtlXTtkZWxldGUgYVtlXX1zLmF0dHJpYnV0ZXMuc3R5bGUucG9zaXRpb249ImFic29sdXRlIj09PWEucG9zaXRpb24/ImFic29sdXRlIjoicmVsYXRpdmUiO2RlbGV0ZSBhLnBvc2l0aW9uO2lmKGEuYWxpZ25TZWxmKXtzLmF0dHJpYnV0ZXMuc3R5bGUuYWxpZ25TZWxmPWEuYWxpZ25TZWxmO2RlbGV0ZSBhLmFsaWduU2VsZn1yZXR1cm4gc31mdW5jdGlvbiBmaXhUZXh0SW5kZW50KGUpe2NvbnN0IHQ9Z2V0TWVhc3VyZW1lbnQoZS50ZXh0SW5kZW50LCIwcHgiKTtpZih0Pj0wKXJldHVybjtjb25zdCBpPSJwYWRkaW5nIisoImxlZnQiPT09KCJyaWdodCI9PT1lLnRleHRBbGlnbj8icmlnaHQiOiJsZWZ0Iik/IkxlZnQiOiJSaWdodCIpLGE9Z2V0TWVhc3VyZW1lbnQoZVtpXSwiMHB4Iik7ZVtpXT1hLXQrInB4In1mdW5jdGlvbiBzZXRBY2Nlc3MoZSx0KXtzd2l0Y2goZS5hY2Nlc3Mpe2Nhc2Uibm9uSW50ZXJhY3RpdmUiOnQucHVzaCgieGZhTm9uSW50ZXJhY3RpdmUiKTticmVhaztjYXNlInJlYWRPbmx5Ijp0LnB1c2goInhmYVJlYWRPbmx5Iik7YnJlYWs7Y2FzZSJwcm90ZWN0ZWQiOnQucHVzaCgieGZhRGlzYWJsZWQiKX19ZnVuY3Rpb24gaXNQcmludE9ubHkoZSl7cmV0dXJuIGUucmVsZXZhbnQubGVuZ3RoPjAmJiFlLnJlbGV2YW50WzBdLmV4Y2x1ZGVkJiYicHJpbnQiPT09ZS5yZWxldmFudFswXS52aWV3bmFtZX1mdW5jdGlvbiBnZXRDdXJyZW50UGFyYShlKXtjb25zdCB0PWVbbXJdKClbYXJdLnBhcmFTdGFjaztyZXR1cm4gdC5sZW5ndGg/dC5hdCgtMSk6bnVsbH1mdW5jdGlvbiBzZXRQYXJhKGUsdCxpKXtpZihpLmF0dHJpYnV0ZXMuY2xhc3M/LmluY2x1ZGVzKCJ4ZmFSaWNoIikpe2lmKHQpeyIiPT09ZS5oJiYodC5oZWlnaHQ9ImF1dG8iKTsiIj09PWUudyYmKHQud2lkdGg9ImF1dG8iKX1jb25zdCBhPWdldEN1cnJlbnRQYXJhKGUpO2lmKGEpe2NvbnN0IGU9aS5hdHRyaWJ1dGVzLnN0eWxlO2UuZGlzcGxheT0iZmxleCI7ZS5mbGV4RGlyZWN0aW9uPSJjb2x1bW4iO3N3aXRjaChhLnZBbGlnbil7Y2FzZSJ0b3AiOmUuanVzdGlmeUNvbnRlbnQ9InN0YXJ0IjticmVhaztjYXNlImJvdHRvbSI6ZS5qdXN0aWZ5Q29udGVudD0iZW5kIjticmVhaztjYXNlIm1pZGRsZSI6ZS5qdXN0aWZ5Q29udGVudD0iY2VudGVyIn1jb25zdCB0PWFbcm5dKCk7Zm9yKGNvbnN0W2ksYV1vZiBPYmplY3QuZW50cmllcyh0KSlpIGluIGV8fChlW2ldPWEpfX19ZnVuY3Rpb24gc2V0Rm9udEZhbWlseShlLHQsaSxhKXtpZighaSl7ZGVsZXRlIGEuZm9udEZhbWlseTtyZXR1cm59Y29uc3Qgcz1zdHJpcFF1b3RlcyhlLnR5cGVmYWNlKTthLmZvbnRGYW1pbHk9YCIke3N9ImA7Y29uc3Qgcj1pLmZpbmQocyk7aWYocil7Y29uc3R7Zm9udEZhbWlseTppfT1yLnJlZ3VsYXIuY3NzRm9udEluZm87aSE9PXMmJihhLmZvbnRGYW1pbHk9YCIke2l9ImApO2NvbnN0IG49Z2V0Q3VycmVudFBhcmEodCk7aWYobiYmIiIhPT1uLmxpbmVIZWlnaHQpcmV0dXJuO2lmKGEubGluZUhlaWdodClyZXR1cm47Y29uc3Qgbz1zZWxlY3RGb250KGUscik7byYmKGEubGluZUhlaWdodD1NYXRoLm1heCgxLjIsby5saW5lSGVpZ2h0KSl9fWZ1bmN0aW9uIGZpeFVSTChlKXtjb25zdCB0PWNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwoZSxudWxsLHthZGREZWZhdWx0UHJvdG9jb2w6ITAsdHJ5Q29udmVydEVuY29kaW5nOiEwfSk7cmV0dXJuIHQ/dC5ocmVmOm51bGx9ZnVuY3Rpb24gY3JlYXRlTGluZShlLHQpe3JldHVybntuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e2NsYXNzOlsibHItdGIiPT09ZS5sYXlvdXQ/InhmYUxyIjoieGZhUmwiXX0sY2hpbGRyZW46dH19ZnVuY3Rpb24gZmx1c2hIVE1MKGUpe2lmKCFlW2FyXSlyZXR1cm4gbnVsbDtjb25zdCB0PXtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6ZVthcl0uYXR0cmlidXRlcyxjaGlsZHJlbjplW2FyXS5jaGlsZHJlbn07aWYoZVthcl0uZmFpbGluZ05vZGUpe2NvbnN0IGk9ZVthcl0uZmFpbGluZ05vZGVbcnJdKCk7aSYmKGUubGF5b3V0LmVuZHNXaXRoKCItdGIiKT90LmNoaWxkcmVuLnB1c2goY3JlYXRlTGluZShlLFtpXSkpOnQuY2hpbGRyZW4ucHVzaChpKSl9cmV0dXJuIDA9PT10LmNoaWxkcmVuLmxlbmd0aD9udWxsOnR9ZnVuY3Rpb24gYWRkSFRNTChlLHQsaSl7Y29uc3QgYT1lW2FyXSxzPWEuYXZhaWxhYmxlU3BhY2UsW3IsbixvLGddPWk7c3dpdGNoKGUubGF5b3V0KXtjYXNlInBvc2l0aW9uIjphLndpZHRoPU1hdGgubWF4KGEud2lkdGgscitvKTthLmhlaWdodD1NYXRoLm1heChhLmhlaWdodCxuK2cpO2EuY2hpbGRyZW4ucHVzaCh0KTticmVhaztjYXNlImxyLXRiIjpjYXNlInJsLXRiIjppZighYS5saW5lfHwxPT09YS5hdHRlbXB0KXthLmxpbmU9Y3JlYXRlTGluZShlLFtdKTthLmNoaWxkcmVuLnB1c2goYS5saW5lKTthLm51bWJlckluTGluZT0wfWEubnVtYmVySW5MaW5lKz0xO2EubGluZS5jaGlsZHJlbi5wdXNoKHQpO2lmKDA9PT1hLmF0dGVtcHQpe2EuY3VycmVudFdpZHRoKz1vO2EuaGVpZ2h0PU1hdGgubWF4KGEuaGVpZ2h0LGEucHJldkhlaWdodCtnKX1lbHNle2EuY3VycmVudFdpZHRoPW87YS5wcmV2SGVpZ2h0PWEuaGVpZ2h0O2EuaGVpZ2h0Kz1nO2EuYXR0ZW1wdD0wfWEud2lkdGg9TWF0aC5tYXgoYS53aWR0aCxhLmN1cnJlbnRXaWR0aCk7YnJlYWs7Y2FzZSJybC1yb3ciOmNhc2Uicm93Ijp7YS5jaGlsZHJlbi5wdXNoKHQpO2Eud2lkdGgrPW87YS5oZWlnaHQ9TWF0aC5tYXgoYS5oZWlnaHQsZyk7Y29uc3QgZT1tZWFzdXJlVG9TdHJpbmcoYS5oZWlnaHQpO2Zvcihjb25zdCB0IG9mIGEuY2hpbGRyZW4pdC5hdHRyaWJ1dGVzLnN0eWxlLmhlaWdodD1lO2JyZWFrfWNhc2UidGFibGUiOmNhc2UidGIiOmEud2lkdGg9TWF0aC5taW4ocy53aWR0aCxNYXRoLm1heChhLndpZHRoLG8pKTthLmhlaWdodCs9ZzthLmNoaWxkcmVuLnB1c2godCl9fWZ1bmN0aW9uIGdldEF2YWlsYWJsZVNwYWNlKGUpe2NvbnN0IHQ9ZVthcl0uYXZhaWxhYmxlU3BhY2UsaT1lLm1hcmdpbj9lLm1hcmdpbi50b3BJbnNldCtlLm1hcmdpbi5ib3R0b21JbnNldDowLGE9ZS5tYXJnaW4/ZS5tYXJnaW4ubGVmdEluc2V0K2UubWFyZ2luLnJpZ2h0SW5zZXQ6MDtzd2l0Y2goZS5sYXlvdXQpe2Nhc2UibHItdGIiOmNhc2UicmwtdGIiOnJldHVybiAwPT09ZVthcl0uYXR0ZW1wdD97d2lkdGg6dC53aWR0aC1hLWVbYXJdLmN1cnJlbnRXaWR0aCxoZWlnaHQ6dC5oZWlnaHQtaS1lW2FyXS5wcmV2SGVpZ2h0fTp7d2lkdGg6dC53aWR0aC1hLGhlaWdodDp0LmhlaWdodC1pLWVbYXJdLmhlaWdodH07Y2FzZSJybC1yb3ciOmNhc2Uicm93IjpyZXR1cm57d2lkdGg6ZVthcl0uY29sdW1uV2lkdGhzLnNsaWNlKGVbYXJdLmN1cnJlbnRDb2x1bW4pLnJlZHVjZSgoKGUsdCk9PmUrdCkpLGhlaWdodDp0LmhlaWdodC1hfTtjYXNlInRhYmxlIjpjYXNlInRiIjpyZXR1cm57d2lkdGg6dC53aWR0aC1hLGhlaWdodDp0LmhlaWdodC1pLWVbYXJdLmhlaWdodH07ZGVmYXVsdDpyZXR1cm4gdH19ZnVuY3Rpb24gY2hlY2tEaW1lbnNpb25zKGUsdCl7aWYobnVsbD09PWVbbXJdKClbYXJdLmZpcnN0VW5zcGxpdHRhYmxlKXJldHVybiEwO2lmKDA9PT1lLnd8fDA9PT1lLmgpcmV0dXJuITA7Y29uc3QgaT1lW2ZyXSgpLGE9aVthcl0/LmF0dGVtcHR8fDAsWyxzLHIsbl09ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtZWRCQm94KGUpe2xldCB0LGksYT0iIj09PWUudz9OYU46ZS53LHM9IiI9PT1lLmg/TmFOOmUuaCxbcixuXT1bMCwwXTtzd2l0Y2goZS5hbmNob3JUeXBlfHwiIil7Y2FzZSJib3R0b21DZW50ZXIiOltyLG5dPVthLzIsc107YnJlYWs7Y2FzZSJib3R0b21MZWZ0IjpbcixuXT1bMCxzXTticmVhaztjYXNlImJvdHRvbVJpZ2h0IjpbcixuXT1bYSxzXTticmVhaztjYXNlIm1pZGRsZUNlbnRlciI6W3Isbl09W2EvMixzLzJdO2JyZWFrO2Nhc2UibWlkZGxlTGVmdCI6W3Isbl09WzAscy8yXTticmVhaztjYXNlIm1pZGRsZVJpZ2h0IjpbcixuXT1bYSxzLzJdO2JyZWFrO2Nhc2UidG9wQ2VudGVyIjpbcixuXT1bYS8yLDBdO2JyZWFrO2Nhc2UidG9wUmlnaHQiOltyLG5dPVthLDBdfXN3aXRjaChlLnJvdGF0ZXx8MCl7Y2FzZSAwOlt0LGldPVstciwtbl07YnJlYWs7Y2FzZSA5MDpbdCxpXT1bLW4scl07W2Esc109W3MsLWFdO2JyZWFrO2Nhc2UgMTgwOlt0LGldPVtyLG5dO1thLHNdPVstYSwtc107YnJlYWs7Y2FzZSAyNzA6W3QsaV09W24sLXJdO1thLHNdPVstcyxhXX1yZXR1cm5bZS54K3QrTWF0aC5taW4oMCxhKSxlLnkraStNYXRoLm1pbigwLHMpLE1hdGguYWJzKGEpLE1hdGguYWJzKHMpXX0oZSk7c3dpdGNoKGkubGF5b3V0KXtjYXNlImxyLXRiIjpjYXNlInJsLXRiIjpyZXR1cm4gMD09PWE/ZVttcl0oKVthcl0ubm9MYXlvdXRGYWlsdXJlPyIiIT09ZS53P01hdGgucm91bmQoci10LndpZHRoKTw9Mjp0LndpZHRoPjI6ISgiIiE9PWUuaCYmTWF0aC5yb3VuZChuLXQuaGVpZ2h0KT4yKSYmKCIiIT09ZS53P01hdGgucm91bmQoci10LndpZHRoKTw9Mnx8MD09PWlbYXJdLm51bWJlckluTGluZSYmdC5oZWlnaHQ+Mjp0LndpZHRoPjIpOiEhZVttcl0oKVthcl0ubm9MYXlvdXRGYWlsdXJlfHwhKCIiIT09ZS5oJiZNYXRoLnJvdW5kKG4tdC5oZWlnaHQpPjIpJiYoKCIiPT09ZS53fHxNYXRoLnJvdW5kKHItdC53aWR0aCk8PTJ8fCFpW1VyXSgpKSYmdC5oZWlnaHQ+Mik7Y2FzZSJ0YWJsZSI6Y2FzZSJ0YiI6cmV0dXJuISFlW21yXSgpW2FyXS5ub0xheW91dEZhaWx1cmV8fCgiIj09PWUuaHx8ZVt4cl0oKT8oIiI9PT1lLnd8fE1hdGgucm91bmQoci10LndpZHRoKTw9Mnx8IWlbVXJdKCkpJiZ0LmhlaWdodD4yOk1hdGgucm91bmQobi10LmhlaWdodCk8PTIpO2Nhc2UicG9zaXRpb24iOmlmKGVbbXJdKClbYXJdLm5vTGF5b3V0RmFpbHVyZSlyZXR1cm4hMDtpZigiIj09PWUuaHx8TWF0aC5yb3VuZChuK3MtdC5oZWlnaHQpPD0yKXJldHVybiEwO3JldHVybiBuK3M+ZVttcl0oKVthcl0uY3VycmVudENvbnRlbnRBcmVhLmg7Y2FzZSJybC1yb3ciOmNhc2Uicm93IjpyZXR1cm4hIWVbbXJdKClbYXJdLm5vTGF5b3V0RmFpbHVyZXx8KCIiPT09ZS5ofHxNYXRoLnJvdW5kKG4tdC5oZWlnaHQpPD0yKTtkZWZhdWx0OnJldHVybiEwfX1jb25zdCBIbj1nbi50ZW1wbGF0ZS5pZCxKbj0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciLFluPS9eSChcZCspJC8sdm49bmV3IFNldChbImltYWdlL2dpZiIsImltYWdlL2pwZWciLCJpbWFnZS9qcGciLCJpbWFnZS9wanBlZyIsImltYWdlL3BuZyIsImltYWdlL2FwbmciLCJpbWFnZS94LXBuZyIsImltYWdlL2JtcCIsImltYWdlL3gtbXMtYm1wIiwiaW1hZ2UvdGlmZiIsImltYWdlL3RpZiIsImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSJdKSxLbj1bW1s2Niw3N10sImltYWdlL2JtcCJdLFtbMjU1LDIxNiwyNTVdLCJpbWFnZS9qcGVnIl0sW1s3Myw3Myw0MiwwXSwiaW1hZ2UvdGlmZiJdLFtbNzcsNzcsMCw0Ml0sImltYWdlL3RpZmYiXSxbWzcxLDczLDcwLDU2LDU3LDk3XSwiaW1hZ2UvZ2lmIl0sW1sxMzcsODAsNzgsNzEsMTMsMTAsMjYsMTBdLCJpbWFnZS9wbmciXV07ZnVuY3Rpb24gZ2V0Qm9yZGVyRGltcyhlKXtpZighZXx8IWUuYm9yZGVyKXJldHVybnt3OjAsaDowfTtjb25zdCB0PWUuYm9yZGVyW2xyXSgpO3JldHVybiB0P3t3OnQud2lkdGhzWzBdK3Qud2lkdGhzWzJdK3QuaW5zZXRzWzBdK3QuaW5zZXRzWzJdLGg6dC53aWR0aHNbMV0rdC53aWR0aHNbM10rdC5pbnNldHNbMV0rdC5pbnNldHNbM119Ont3OjAsaDowfX1mdW5jdGlvbiBoYXNNYXJnaW4oZSl7cmV0dXJuIGUubWFyZ2luJiYoZS5tYXJnaW4udG9wSW5zZXR8fGUubWFyZ2luLnJpZ2h0SW5zZXR8fGUubWFyZ2luLmJvdHRvbUluc2V0fHxlLm1hcmdpbi5sZWZ0SW5zZXQpfWZ1bmN0aW9uIF9zZXRWYWx1ZShlLHQpe2lmKCFlLnZhbHVlKXtjb25zdCB0PW5ldyBWYWx1ZSh7fSk7ZVtYc10odCk7ZS52YWx1ZT10fWUudmFsdWVbJHJdKHQpfWZ1bmN0aW9uKmdldENvbnRhaW5lZENoaWxkcmVuKGUpe2Zvcihjb25zdCB0IG9mIGVbRXJdKCkpdCBpbnN0YW5jZW9mIFN1YmZvcm1TZXQ/eWllbGQqdFt1cl0oKTp5aWVsZCB0fWZ1bmN0aW9uIGlzUmVxdWlyZWQoZSl7cmV0dXJuImVycm9yIj09PWUudmFsaWRhdGU/Lm51bGxUZXN0fWZ1bmN0aW9uIHNldFRhYkluZGV4KGUpe2Zvcig7ZTspe2lmKCFlLnRyYXZlcnNhbCl7ZVtBbl09ZVtwcl0oKVtBbl07cmV0dXJufWlmKGVbQW5dKXJldHVybjtsZXQgdD1udWxsO2Zvcihjb25zdCBpIG9mIGUudHJhdmVyc2FsW0VyXSgpKWlmKCJuZXh0Ij09PWkub3BlcmF0aW9uKXt0PWk7YnJlYWt9aWYoIXR8fCF0LnJlZil7ZVtBbl09ZVtwcl0oKVtBbl07cmV0dXJufWNvbnN0IGk9ZVttcl0oKTtlW0FuXT0rK2lbQW5dO2NvbnN0IGE9aVtWcl0odC5yZWYsZSk7aWYoIWEpcmV0dXJuO2U9YVswXX19ZnVuY3Rpb24gYXBwbHlBc3Npc3QoZSx0KXtjb25zdCBpPWUuYXNzaXN0O2lmKGkpe2NvbnN0IGU9aVthbl0oKTtlJiYodC50aXRsZT1lKTtjb25zdCBhPWkucm9sZS5tYXRjaChZbik7aWYoYSl7Y29uc3QgZT0iaGVhZGluZyIsaT1hWzFdO3Qucm9sZT1lO3RbImFyaWEtbGV2ZWwiXT1pfX1pZigidGFibGUiPT09ZS5sYXlvdXQpdC5yb2xlPSJ0YWJsZSI7ZWxzZSBpZigicm93Ij09PWUubGF5b3V0KXQucm9sZT0icm93IjtlbHNle2NvbnN0IGk9ZVtwcl0oKTsicm93Ij09PWkubGF5b3V0JiYodC5yb2xlPSJUSCI9PT1pLmFzc2lzdD8ucm9sZT8iY29sdW1uaGVhZGVyIjoiY2VsbCIpfX1mdW5jdGlvbiBhcmlhTGFiZWwoZSl7aWYoIWUuYXNzaXN0KXJldHVybiBudWxsO2NvbnN0IHQ9ZS5hc3Npc3Q7cmV0dXJuIHQuc3BlYWsmJiIiIT09dC5zcGVha1tlcl0/dC5zcGVha1tlcl06dC50b29sVGlwP3QudG9vbFRpcFtlcl06bnVsbH1mdW5jdGlvbiB2YWx1ZVRvSHRtbChlKXtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhUmljaCJdLHN0eWxlOk9iamVjdC5jcmVhdGUobnVsbCl9LGNoaWxkcmVuOlt7bmFtZToic3BhbiIsYXR0cmlidXRlczp7c3R5bGU6T2JqZWN0LmNyZWF0ZShudWxsKX0sdmFsdWU6ZX1dfSl9ZnVuY3Rpb24gc2V0Rmlyc3RVbnNwbGl0dGFibGUoZSl7Y29uc3QgdD1lW21yXSgpO2lmKG51bGw9PT10W2FyXS5maXJzdFVuc3BsaXR0YWJsZSl7dFthcl0uZmlyc3RVbnNwbGl0dGFibGU9ZTt0W2FyXS5ub0xheW91dEZhaWx1cmU9ITB9fWZ1bmN0aW9uIHVuc2V0Rmlyc3RVbnNwbGl0dGFibGUoZSl7Y29uc3QgdD1lW21yXSgpO3RbYXJdLmZpcnN0VW5zcGxpdHRhYmxlPT09ZSYmKHRbYXJdLm5vTGF5b3V0RmFpbHVyZT0hMSl9ZnVuY3Rpb24gaGFuZGxlQnJlYWsoZSl7aWYoZVthcl0pcmV0dXJuITE7ZVthcl09T2JqZWN0LmNyZWF0ZShudWxsKTtpZigiYXV0byI9PT1lLnRhcmdldFR5cGUpcmV0dXJuITE7Y29uc3QgdD1lW21yXSgpO2xldCBpPW51bGw7aWYoZS50YXJnZXQpe2k9dFtWcl0oZS50YXJnZXQsZVtwcl0oKSk7aWYoIWkpcmV0dXJuITE7aT1pWzBdfWNvbnN0e2N1cnJlbnRQYWdlQXJlYTphLGN1cnJlbnRDb250ZW50QXJlYTpzfT10W2FyXTtpZigicGFnZUFyZWEiPT09ZS50YXJnZXRUeXBlKXtpIGluc3RhbmNlb2YgUGFnZUFyZWF8fChpPW51bGwpO2lmKGUuc3RhcnROZXcpe2VbYXJdLnRhcmdldD1pfHxhO3JldHVybiEwfWlmKGkmJmkhPT1hKXtlW2FyXS50YXJnZXQ9aTtyZXR1cm4hMH1yZXR1cm4hMX1pIGluc3RhbmNlb2YgQ29udGVudEFyZWF8fChpPW51bGwpO2NvbnN0IHI9aSYmaVtwcl0oKTtsZXQgbixvPXI7aWYoZS5zdGFydE5ldylpZihpKXtjb25zdCBlPXIuY29udGVudEFyZWEuY2hpbGRyZW4sdD1lLmluZGV4T2YocyksYT1lLmluZGV4T2YoaSk7LTEhPT10JiZ0PGEmJihvPW51bGwpO249YS0xfWVsc2Ugbj1hLmNvbnRlbnRBcmVhLmNoaWxkcmVuLmluZGV4T2Yocyk7ZWxzZXtpZighaXx8aT09PXMpcmV0dXJuITE7bj1yLmNvbnRlbnRBcmVhLmNoaWxkcmVuLmluZGV4T2YoaSktMTtvPXI9PT1hP251bGw6cn1lW2FyXS50YXJnZXQ9bztlW2FyXS5pbmRleD1uO3JldHVybiEwfWZ1bmN0aW9uIGhhbmRsZU92ZXJmbG93KGUsdCxpKXtjb25zdCBhPWVbbXJdKCkscz1hW2FyXS5ub0xheW91dEZhaWx1cmUscj10W2ZyXTt0W2ZyXT0oKT0+ZTthW2FyXS5ub0xheW91dEZhaWx1cmU9ITA7Y29uc3Qgbj10W2FuXShpKTtlW2pzXShuLmh0bWwsbi5iYm94KTthW2FyXS5ub0xheW91dEZhaWx1cmU9czt0W2ZyXT1yfWNsYXNzIEFwcGVhcmFuY2VGaWx0ZXIgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImFwcGVhcmFuY2VGaWx0ZXIiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIEFyYyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiYXJjIiwhMCk7dGhpcy5jaXJjdWxhcj1nZXRJbnRlZ2VyKHtkYXRhOmUuY2lyY3VsYXIsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmhhbmQ9Z2V0U3RyaW5nT3B0aW9uKGUuaGFuZCxbImV2ZW4iLCJsZWZ0IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnN0YXJ0QW5nbGU9Z2V0RmxvYXQoe2RhdGE6ZS5zdGFydEFuZ2xlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PiEwfSk7dGhpcy5zd2VlcEFuZ2xlPWdldEZsb2F0KHtkYXRhOmUuc3dlZXBBbmdsZSxkZWZhdWx0VmFsdWU6MzYwLHZhbGlkYXRlOmU9PiEwfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZWRnZT1udWxsO3RoaXMuZmlsbD1udWxsfVthbl0oKXtjb25zdCBlPXRoaXMuZWRnZXx8bmV3IEVkZ2Uoe30pLHQ9ZVtybl0oKSxpPU9iamVjdC5jcmVhdGUobnVsbCk7InZpc2libGUiPT09dGhpcy5maWxsPy5wcmVzZW5jZT9PYmplY3QuYXNzaWduKGksdGhpcy5maWxsW3JuXSgpKTppLmZpbGw9InRyYW5zcGFyZW50IjtpLnN0cm9rZVdpZHRoPW1lYXN1cmVUb1N0cmluZygidmlzaWJsZSI9PT1lLnByZXNlbmNlP2UudGhpY2tuZXNzOjApO2kuc3Ryb2tlPXQuY29sb3I7bGV0IGE7Y29uc3Qgcz17eG1sbnM6Sm4sc3R5bGU6e3dpZHRoOiIxMDAlIixoZWlnaHQ6IjEwMCUiLG92ZXJmbG93OiJ2aXNpYmxlIn19O2lmKDM2MD09PXRoaXMuc3dlZXBBbmdsZSlhPXtuYW1lOiJlbGxpcHNlIixhdHRyaWJ1dGVzOnt4bWxuczpKbixjeDoiNTAlIixjeToiNTAlIixyeDoiNTAlIixyeToiNTAlIixzdHlsZTppfX07ZWxzZXtjb25zdCBlPXRoaXMuc3RhcnRBbmdsZSpNYXRoLlBJLzE4MCx0PXRoaXMuc3dlZXBBbmdsZSpNYXRoLlBJLzE4MCxyPXRoaXMuc3dlZXBBbmdsZT4xODA/MTowLFtuLG8sZyxjXT1bNTAqKDErTWF0aC5jb3MoZSkpLDUwKigxLU1hdGguc2luKGUpKSw1MCooMStNYXRoLmNvcyhlK3QpKSw1MCooMS1NYXRoLnNpbihlK3QpKV07YT17bmFtZToicGF0aCIsYXR0cmlidXRlczp7eG1sbnM6Sm4sZDpgTSAke259ICR7b30gQSA1MCA1MCAwICR7cn0gMCAke2d9ICR7Y31gLHZlY3RvckVmZmVjdDoibm9uLXNjYWxpbmctc3Ryb2tlIixzdHlsZTppfX07T2JqZWN0LmFzc2lnbihzLHt2aWV3Qm94OiIwIDAgMTAwIDEwMCIscHJlc2VydmVBc3BlY3RSYXRpbzoibm9uZSJ9KX1jb25zdCByPXtuYW1lOiJzdmciLGNoaWxkcmVuOlthXSxhdHRyaWJ1dGVzOnN9O2lmKGhhc01hcmdpbih0aGlzW3ByXSgpW3ByXSgpKSlyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e3N0eWxlOntkaXNwbGF5OiJpbmxpbmUiLHdpZHRoOiIxMDAlIixoZWlnaHQ6IjEwMCUifX0sY2hpbGRyZW46W3JdfSk7ci5hdHRyaWJ1dGVzLnN0eWxlLnBvc2l0aW9uPSJhYnNvbHV0ZSI7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhyKX19Y2xhc3MgQXJlYSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiYXJlYSIsITApO3RoaXMuY29sU3Bhbj1nZXRJbnRlZ2VyKHtkYXRhOmUuY29sU3BhbixkZWZhdWx0VmFsdWU6MSx2YWxpZGF0ZTplPT5lPj0xfHwtMT09PWV9KTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmVsZXZhbnQ9Z2V0UmVsZXZhbnQoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMueD1nZXRNZWFzdXJlbWVudChlLngsIjBwdCIpO3RoaXMueT1nZXRNZWFzdXJlbWVudChlLnksIjBwdCIpO3RoaXMuZGVzYz1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5hcmVhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRyYXc9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhPYmplY3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhjbEdyb3VwPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZpZWxkPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm09bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3ViZm9ybVNldD1uZXcgWEZBT2JqZWN0QXJyYXl9Klt1cl0oKXt5aWVsZCpnZXRDb250YWluZWRDaGlsZHJlbih0aGlzKX1bTXJdKCl7cmV0dXJuITB9W2tyXSgpe3JldHVybiEwfVtqc10oZSx0KXtjb25zdFtpLGEscyxyXT10O3RoaXNbYXJdLndpZHRoPU1hdGgubWF4KHRoaXNbYXJdLndpZHRoLGkrcyk7dGhpc1thcl0uaGVpZ2h0PU1hdGgubWF4KHRoaXNbYXJdLmhlaWdodCxhK3IpO3RoaXNbYXJdLmNoaWxkcmVuLnB1c2goZSl9W2dyXSgpe3JldHVybiB0aGlzW2FyXS5hdmFpbGFibGVTcGFjZX1bYW5dKGUpe2NvbnN0IHQ9dG9TdHlsZSh0aGlzLCJwb3NpdGlvbiIpLGk9e3N0eWxlOnQsaWQ6dGhpc1tubl0sY2xhc3M6WyJ4ZmFBcmVhIl19O2lzUHJpbnRPbmx5KHRoaXMpJiZpLmNsYXNzLnB1c2goInhmYVByaW50T25seSIpO3RoaXMubmFtZSYmKGkueGZhTmFtZT10aGlzLm5hbWUpO2NvbnN0IGE9W107dGhpc1thcl09e2NoaWxkcmVuOmEsd2lkdGg6MCxoZWlnaHQ6MCxhdmFpbGFibGVTcGFjZTplfTtjb25zdCBzPXRoaXNbWnNdKHtmaWx0ZXI6bmV3IFNldChbImFyZWEiLCJkcmF3IiwiZmllbGQiLCJleGNsR3JvdXAiLCJzdWJmb3JtIiwic3ViZm9ybVNldCJdKSxpbmNsdWRlOiEwfSk7aWYoIXMuc3VjY2Vzcyl7aWYocy5pc0JyZWFrKCkpcmV0dXJuIHM7ZGVsZXRlIHRoaXNbYXJdO3JldHVybiBIVE1MUmVzdWx0LkZBSUxVUkV9dC53aWR0aD1tZWFzdXJlVG9TdHJpbmcodGhpc1thcl0ud2lkdGgpO3QuaGVpZ2h0PW1lYXN1cmVUb1N0cmluZyh0aGlzW2FyXS5oZWlnaHQpO2NvbnN0IHI9e25hbWU6ImRpdiIsYXR0cmlidXRlczppLGNoaWxkcmVuOmF9LG49W3RoaXMueCx0aGlzLnksdGhpc1thcl0ud2lkdGgsdGhpc1thcl0uaGVpZ2h0XTtkZWxldGUgdGhpc1thcl07cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhyLG4pfX1jbGFzcyBBc3Npc3QgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImFzc2lzdCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5yb2xlPWUucm9sZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuc3BlYWs9bnVsbDt0aGlzLnRvb2xUaXA9bnVsbH1bYW5dKCl7cmV0dXJuIHRoaXMudG9vbFRpcD8uW2VyXXx8bnVsbH19Y2xhc3MgQmFyY29kZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiYmFyY29kZSIsITApO3RoaXMuY2hhckVuY29kaW5nPWdldEtleXdvcmQoe2RhdGE6ZS5jaGFyRW5jb2Rpbmc/ZS5jaGFyRW5jb2RpbmcudG9Mb3dlckNhc2UoKToiIixkZWZhdWx0VmFsdWU6IiIsdmFsaWRhdGU6ZT0+WyJ1dGYtOCIsImJpZy1maXZlIiwiZm9udHNwZWNpZmljIiwiZ2JrIiwiZ2ItMTgwMzAiLCJnYi0yMzEyIiwia3NjLTU2MDEiLCJub25lIiwic2hpZnQtamlzIiwidWNzLTIiLCJ1dGYtMTYiXS5pbmNsdWRlcyhlKXx8ZS5tYXRjaCgvaXNvLTg4NTktXGR7Mn0vKX0pO3RoaXMuY2hlY2tzdW09Z2V0U3RyaW5nT3B0aW9uKGUuY2hlY2tzdW0sWyJub25lIiwiMW1vZDEwIiwiMW1vZDEwXzFtb2QxMSIsIjJtb2QxMCIsImF1dG8iXSk7dGhpcy5kYXRhQ29sdW1uQ291bnQ9Z2V0SW50ZWdlcih7ZGF0YTplLmRhdGFDb2x1bW5Db3VudCxkZWZhdWx0VmFsdWU6LTEsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMuZGF0YUxlbmd0aD1nZXRJbnRlZ2VyKHtkYXRhOmUuZGF0YUxlbmd0aCxkZWZhdWx0VmFsdWU6LTEsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMuZGF0YVByZXA9Z2V0U3RyaW5nT3B0aW9uKGUuZGF0YVByZXAsWyJub25lIiwiZmxhdGVDb21wcmVzcyJdKTt0aGlzLmRhdGFSb3dDb3VudD1nZXRJbnRlZ2VyKHtkYXRhOmUuZGF0YVJvd0NvdW50LGRlZmF1bHRWYWx1ZTotMSx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy5lbmRDaGFyPWUuZW5kQ2hhcnx8IiI7dGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbD1nZXRJbnRlZ2VyKHtkYXRhOmUuZXJyb3JDb3JyZWN0aW9uTGV2ZWwsZGVmYXVsdFZhbHVlOi0xLHZhbGlkYXRlOmU9PmU+PTAmJmU8PTh9KTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubW9kdWxlSGVpZ2h0PWdldE1lYXN1cmVtZW50KGUubW9kdWxlSGVpZ2h0LCI1bW0iKTt0aGlzLm1vZHVsZVdpZHRoPWdldE1lYXN1cmVtZW50KGUubW9kdWxlV2lkdGgsIjAuMjVtbSIpO3RoaXMucHJpbnRDaGVja0RpZ2l0PWdldEludGVnZXIoe2RhdGE6ZS5wcmludENoZWNrRGlnaXQsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLnJvd0NvbHVtblJhdGlvPWdldFJhdGlvKGUucm93Q29sdW1uUmF0aW8pO3RoaXMuc3RhcnRDaGFyPWUuc3RhcnRDaGFyfHwiIjt0aGlzLnRleHRMb2NhdGlvbj1nZXRTdHJpbmdPcHRpb24oZS50ZXh0TG9jYXRpb24sWyJiZWxvdyIsImFib3ZlIiwiYWJvdmVFbWJlZGRlZCIsImJlbG93RW1iZWRkZWQiLCJub25lIl0pO3RoaXMudHJ1bmNhdGU9Z2V0SW50ZWdlcih7ZGF0YTplLnRydW5jYXRlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGU/ZS50eXBlLnRvTG93ZXJDYXNlKCk6IiIsWyJhenRlYyIsImNvZGFiYXIiLCJjb2RlMm9mNWluZHVzdHJpYWwiLCJjb2RlMm9mNWludGVybGVhdmVkIiwiY29kZTJvZjVtYXRyaXgiLCJjb2RlMm9mNXN0YW5kYXJkIiwiY29kZTNvZjkiLCJjb2RlM29mOWV4dGVuZGVkIiwiY29kZTExIiwiY29kZTQ5IiwiY29kZTkzIiwiY29kZTEyOCIsImNvZGUxMjhhIiwiY29kZTEyOGIiLCJjb2RlMTI4YyIsImNvZGUxMjhzc2NjIiwiZGF0YW1hdHJpeCIsImVhbjgiLCJlYW44YWRkMiIsImVhbjhhZGQ1IiwiZWFuMTMiLCJlYW4xM2FkZDIiLCJlYW4xM2FkZDUiLCJlYW4xM3B3Y2QiLCJmaW0iLCJsb2dtYXJzIiwibWF4aWNvZGUiLCJtc2kiLCJwZGY0MTciLCJwZGY0MTdtYWNybyIsInBsZXNzZXkiLCJwb3N0YXVzY3VzdDIiLCJwb3N0YXVzY3VzdDMiLCJwb3N0YXVzcmVwbHlwYWlkIiwicG9zdGF1c3N0YW5kYXJkIiwicG9zdHVrcm00c2NjIiwicG9zdHVzZHBiYyIsInBvc3R1c2ltYiIsInBvc3R1c3N0YW5kYXJkIiwicG9zdHVzNXppcCIsInFyY29kZSIsInJmaWQiLCJyc3MxNCIsInJzczE0ZXhwYW5kZWQiLCJyc3MxNGxpbWl0ZWQiLCJyc3MxNHN0YWNrZWQiLCJyc3MxNHN0YWNrZWRvbW5pIiwicnNzMTR0cnVuY2F0ZWQiLCJ0ZWxlcGVuIiwidWNjMTI4IiwidWNjMTI4cmFuZG9tIiwidWNjMTI4c3NjYyIsInVwY2EiLCJ1cGNhYWRkMiIsInVwY2FhZGQ1IiwidXBjYXB3Y2QiLCJ1cGNlIiwidXBjZWFkZDIiLCJ1cGNlYWRkNSIsInVwY2VhbjIiLCJ1cGNlYW41IiwidXBzbWF4aWNvZGUiXSk7dGhpcy51cHNNb2RlPWdldFN0cmluZ09wdGlvbihlLnVwc01vZGUsWyJ1c0NhcnJpZXIiLCJpbnRlcm5hdGlvbmFsQ2FycmllciIsInNlY3VyZVN5bWJvbCIsInN0YW5kYXJkU3ltYm9sIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLndpZGVOYXJyb3dSYXRpbz1nZXRSYXRpbyhlLndpZGVOYXJyb3dSYXRpbyk7dGhpcy5lbmNyeXB0PW51bGw7dGhpcy5leHRyYXM9bnVsbH19Y2xhc3MgQmluZCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiYmluZCIsITApO3RoaXMubWF0Y2g9Z2V0U3RyaW5nT3B0aW9uKGUubWF0Y2gsWyJvbmNlIiwiZGF0YVJlZiIsImdsb2JhbCIsIm5vbmUiXSk7dGhpcy5yZWY9ZS5yZWZ8fCIiO3RoaXMucGljdHVyZT1udWxsfX1jbGFzcyBCaW5kSXRlbXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImJpbmRJdGVtcyIpO3RoaXMuY29ubmVjdGlvbj1lLmNvbm5lY3Rpb258fCIiO3RoaXMubGFiZWxSZWY9ZS5sYWJlbFJlZnx8IiI7dGhpcy5yZWY9ZS5yZWZ8fCIiO3RoaXMudmFsdWVSZWY9ZS52YWx1ZVJlZnx8IiJ9fWNsYXNzIEJvb2tlbmQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImJvb2tlbmQiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubGVhZGVyPWUubGVhZGVyfHwiIjt0aGlzLnRyYWlsZXI9ZS50cmFpbGVyfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIEJvb2xlYW5FbGVtZW50IGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImJvb2xlYW4iKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bYW5dKGUpe3JldHVybiB2YWx1ZVRvSHRtbCgxPT09dGhpc1tlcl0/IjEiOiIwIil9fWNsYXNzIEJvcmRlciBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiYm9yZGVyIiwhMCk7dGhpcy5icmVhaz1nZXRTdHJpbmdPcHRpb24oZS5icmVhayxbImNsb3NlIiwib3BlbiJdKTt0aGlzLmhhbmQ9Z2V0U3RyaW5nT3B0aW9uKGUuaGFuZCxbImV2ZW4iLCJsZWZ0IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnByZXNlbmNlPWdldFN0cmluZ09wdGlvbihlLnByZXNlbmNlLFsidmlzaWJsZSIsImhpZGRlbiIsImluYWN0aXZlIiwiaW52aXNpYmxlIl0pO3RoaXMucmVsZXZhbnQ9Z2V0UmVsZXZhbnQoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29ybmVyPW5ldyBYRkFPYmplY3RBcnJheSg0KTt0aGlzLmVkZ2U9bmV3IFhGQU9iamVjdEFycmF5KDQpO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5maWxsPW51bGw7dGhpcy5tYXJnaW49bnVsbH1bbHJdKCl7aWYoIXRoaXNbYXJdKXtjb25zdCBlPXRoaXMuZWRnZS5jaGlsZHJlbi5zbGljZSgpO2lmKGUubGVuZ3RoPDQpe2NvbnN0IHQ9ZS5hdCgtMSl8fG5ldyBFZGdlKHt9KTtmb3IobGV0IGk9ZS5sZW5ndGg7aTw0O2krKyllLnB1c2godCl9Y29uc3QgdD1lLm1hcCgoZT0+ZS50aGlja25lc3MpKSxpPVswLDAsMCwwXTtpZih0aGlzLm1hcmdpbil7aVswXT10aGlzLm1hcmdpbi50b3BJbnNldDtpWzFdPXRoaXMubWFyZ2luLnJpZ2h0SW5zZXQ7aVsyXT10aGlzLm1hcmdpbi5ib3R0b21JbnNldDtpWzNdPXRoaXMubWFyZ2luLmxlZnRJbnNldH10aGlzW2FyXT17d2lkdGhzOnQsaW5zZXRzOmksZWRnZXM6ZX19cmV0dXJuIHRoaXNbYXJdfVtybl0oKXtjb25zdHtlZGdlczplfT10aGlzW2xyXSgpLHQ9ZS5tYXAoKGU9Pntjb25zdCB0PWVbcm5dKCk7dC5jb2xvcnx8PSIjMDAwMDAwIjtyZXR1cm4gdH0pKSxpPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5tYXJnaW4mJk9iamVjdC5hc3NpZ24oaSx0aGlzLm1hcmdpbltybl0oKSk7InZpc2libGUiPT09dGhpcy5maWxsPy5wcmVzZW5jZSYmT2JqZWN0LmFzc2lnbihpLHRoaXMuZmlsbFtybl0oKSk7aWYodGhpcy5jb3JuZXIuY2hpbGRyZW4uc29tZSgoZT0+MCE9PWUucmFkaXVzKSkpe2NvbnN0IGU9dGhpcy5jb3JuZXIuY2hpbGRyZW4ubWFwKChlPT5lW3JuXSgpKSk7aWYoMj09PWUubGVuZ3RofHwzPT09ZS5sZW5ndGgpe2NvbnN0IHQ9ZS5hdCgtMSk7Zm9yKGxldCBpPWUubGVuZ3RoO2k8NDtpKyspZS5wdXNoKHQpfWkuYm9yZGVyUmFkaXVzPWUubWFwKChlPT5lLnJhZGl1cykpLmpvaW4oIiAiKX1zd2l0Y2godGhpcy5wcmVzZW5jZSl7Y2FzZSJpbnZpc2libGUiOmNhc2UiaGlkZGVuIjppLmJvcmRlclN0eWxlPSIiO2JyZWFrO2Nhc2UiaW5hY3RpdmUiOmkuYm9yZGVyU3R5bGU9Im5vbmUiO2JyZWFrO2RlZmF1bHQ6aS5ib3JkZXJTdHlsZT10Lm1hcCgoZT0+ZS5zdHlsZSkpLmpvaW4oIiAiKX1pLmJvcmRlcldpZHRoPXQubWFwKChlPT5lLndpZHRoKSkuam9pbigiICIpO2kuYm9yZGVyQ29sb3I9dC5tYXAoKGU9PmUuY29sb3IpKS5qb2luKCIgIik7cmV0dXJuIGl9fWNsYXNzIEJyZWFrIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJicmVhayIsITApO3RoaXMuYWZ0ZXI9Z2V0U3RyaW5nT3B0aW9uKGUuYWZ0ZXIsWyJhdXRvIiwiY29udGVudEFyZWEiLCJwYWdlQXJlYSIsInBhZ2VFdmVuIiwicGFnZU9kZCJdKTt0aGlzLmFmdGVyVGFyZ2V0PWUuYWZ0ZXJUYXJnZXR8fCIiO3RoaXMuYmVmb3JlPWdldFN0cmluZ09wdGlvbihlLmJlZm9yZSxbImF1dG8iLCJjb250ZW50QXJlYSIsInBhZ2VBcmVhIiwicGFnZUV2ZW4iLCJwYWdlT2RkIl0pO3RoaXMuYmVmb3JlVGFyZ2V0PWUuYmVmb3JlVGFyZ2V0fHwiIjt0aGlzLmJvb2tlbmRMZWFkZXI9ZS5ib29rZW5kTGVhZGVyfHwiIjt0aGlzLmJvb2tlbmRUcmFpbGVyPWUuYm9va2VuZFRyYWlsZXJ8fCIiO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vdmVyZmxvd0xlYWRlcj1lLm92ZXJmbG93TGVhZGVyfHwiIjt0aGlzLm92ZXJmbG93VGFyZ2V0PWUub3ZlcmZsb3dUYXJnZXR8fCIiO3RoaXMub3ZlcmZsb3dUcmFpbGVyPWUub3ZlcmZsb3dUcmFpbGVyfHwiIjt0aGlzLnN0YXJ0TmV3PWdldEludGVnZXIoe2RhdGE6ZS5zdGFydE5ldyxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsfX1jbGFzcyBCcmVha0FmdGVyIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJicmVha0FmdGVyIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWRlcj1lLmxlYWRlcnx8IiI7dGhpcy5zdGFydE5ldz1nZXRJbnRlZ2VyKHtkYXRhOmUuc3RhcnROZXcsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLnRhcmdldD1lLnRhcmdldHx8IiI7dGhpcy50YXJnZXRUeXBlPWdldFN0cmluZ09wdGlvbihlLnRhcmdldFR5cGUsWyJhdXRvIiwiY29udGVudEFyZWEiLCJwYWdlQXJlYSJdKTt0aGlzLnRyYWlsZXI9ZS50cmFpbGVyfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5zY3JpcHQ9bnVsbH19Y2xhc3MgQnJlYWtCZWZvcmUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImJyZWFrQmVmb3JlIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWRlcj1lLmxlYWRlcnx8IiI7dGhpcy5zdGFydE5ldz1nZXRJbnRlZ2VyKHtkYXRhOmUuc3RhcnROZXcsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLnRhcmdldD1lLnRhcmdldHx8IiI7dGhpcy50YXJnZXRUeXBlPWdldFN0cmluZ09wdGlvbihlLnRhcmdldFR5cGUsWyJhdXRvIiwiY29udGVudEFyZWEiLCJwYWdlQXJlYSJdKTt0aGlzLnRyYWlsZXI9ZS50cmFpbGVyfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5zY3JpcHQ9bnVsbH1bYW5dKGUpe3RoaXNbYXJdPXt9O3JldHVybiBIVE1MUmVzdWx0LkZBSUxVUkV9fWNsYXNzIEJ1dHRvbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiYnV0dG9uIiwhMCk7dGhpcy5oaWdobGlnaHQ9Z2V0U3RyaW5nT3B0aW9uKGUuaGlnaGxpZ2h0LFsiaW52ZXJ0ZWQiLCJub25lIiwib3V0bGluZSIsInB1c2giXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbH1bYW5dKGUpe2NvbnN0IHQ9dGhpc1twcl0oKVtwcl0oKSxpPXtuYW1lOiJidXR0b24iLGF0dHJpYnV0ZXM6e2lkOnRoaXNbbm5dLGNsYXNzOlsieGZhQnV0dG9uIl0sc3R5bGU6e319LGNoaWxkcmVuOltdfTtmb3IoY29uc3QgZSBvZiB0LmV2ZW50LmNoaWxkcmVuKXtpZigiY2xpY2siIT09ZS5hY3Rpdml0eXx8IWUuc2NyaXB0KWNvbnRpbnVlO2NvbnN0IHQ9cmVjb3ZlckpzVVJMKGUuc2NyaXB0W2VyXSk7aWYoIXQpY29udGludWU7Y29uc3QgYT1maXhVUkwodC51cmwpO2EmJmkuY2hpbGRyZW4ucHVzaCh7bmFtZToiYSIsYXR0cmlidXRlczp7aWQ6ImxpbmsiK3RoaXNbbm5dLGhyZWY6YSxuZXdXaW5kb3c6dC5uZXdXaW5kb3csY2xhc3M6WyJ4ZmFMaW5rIl0sc3R5bGU6e319LGNoaWxkcmVuOltdfSl9cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhpKX19Y2xhc3MgQ2FsY3VsYXRlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJjYWxjdWxhdGUiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMub3ZlcnJpZGU9Z2V0U3RyaW5nT3B0aW9uKGUub3ZlcnJpZGUsWyJkaXNhYmxlZCIsImVycm9yIiwiaWdub3JlIiwid2FybmluZyJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1lc3NhZ2U9bnVsbDt0aGlzLnNjcmlwdD1udWxsfX1jbGFzcyBDYXB0aW9uIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJjYXB0aW9uIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnBsYWNlbWVudD1nZXRTdHJpbmdPcHRpb24oZS5wbGFjZW1lbnQsWyJsZWZ0IiwiYm90dG9tIiwiaW5saW5lIiwicmlnaHQiLCJ0b3AiXSk7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlc2VydmU9TWF0aC5jZWlsKGdldE1lYXN1cmVtZW50KGUucmVzZXJ2ZSkpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMuZm9udD1udWxsO3RoaXMubWFyZ2luPW51bGw7dGhpcy5wYXJhPW51bGw7dGhpcy52YWx1ZT1udWxsfVskcl0oZSl7X3NldFZhbHVlKHRoaXMsZSl9W2xyXShlKXtpZighdGhpc1thcl0pe2xldHt3aWR0aDp0LGhlaWdodDppfT1lO3N3aXRjaCh0aGlzLnBsYWNlbWVudCl7Y2FzZSJsZWZ0IjpjYXNlInJpZ2h0IjpjYXNlImlubGluZSI6dD10aGlzLnJlc2VydmU8PTA/dDp0aGlzLnJlc2VydmU7YnJlYWs7Y2FzZSJ0b3AiOmNhc2UiYm90dG9tIjppPXRoaXMucmVzZXJ2ZTw9MD9pOnRoaXMucmVzZXJ2ZX10aGlzW2FyXT1sYXlvdXROb2RlKHRoaXMse3dpZHRoOnQsaGVpZ2h0Oml9KX1yZXR1cm4gdGhpc1thcl19W2FuXShlKXtpZighdGhpcy52YWx1ZSlyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTt0aGlzW1dyXSgpO2NvbnN0IHQ9dGhpcy52YWx1ZVthbl0oZSkuaHRtbDtpZighdCl7dGhpc1tQcl0oKTtyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWX1jb25zdCBpPXRoaXMucmVzZXJ2ZTtpZih0aGlzLnJlc2VydmU8PTApe2NvbnN0e3c6dCxoOml9PXRoaXNbbHJdKGUpO3N3aXRjaCh0aGlzLnBsYWNlbWVudCl7Y2FzZSJsZWZ0IjpjYXNlInJpZ2h0IjpjYXNlImlubGluZSI6dGhpcy5yZXNlcnZlPXQ7YnJlYWs7Y2FzZSJ0b3AiOmNhc2UiYm90dG9tIjp0aGlzLnJlc2VydmU9aX19Y29uc3QgYT1bXTsic3RyaW5nIj09dHlwZW9mIHQ/YS5wdXNoKHtuYW1lOiIjdGV4dCIsdmFsdWU6dH0pOmEucHVzaCh0KTtjb25zdCBzPXRvU3R5bGUodGhpcywiZm9udCIsIm1hcmdpbiIsInZpc2liaWxpdHkiKTtzd2l0Y2godGhpcy5wbGFjZW1lbnQpe2Nhc2UibGVmdCI6Y2FzZSJyaWdodCI6dGhpcy5yZXNlcnZlPjAmJihzLndpZHRoPW1lYXN1cmVUb1N0cmluZyh0aGlzLnJlc2VydmUpKTticmVhaztjYXNlInRvcCI6Y2FzZSJib3R0b20iOnRoaXMucmVzZXJ2ZT4wJiYocy5oZWlnaHQ9bWVhc3VyZVRvU3RyaW5nKHRoaXMucmVzZXJ2ZSkpfXNldFBhcmEodGhpcyxudWxsLHQpO3RoaXNbUHJdKCk7dGhpcy5yZXNlcnZlPWk7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixhdHRyaWJ1dGVzOntzdHlsZTpzLGNsYXNzOlsieGZhQ2FwdGlvbiJdfSxjaGlsZHJlbjphfSl9fWNsYXNzIENlcnRpZmljYXRlIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJjZXJ0aWZpY2F0ZSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBDZXJ0aWZpY2F0ZXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImNlcnRpZmljYXRlcyIsITApO3RoaXMuY3JlZGVudGlhbFNlcnZlclBvbGljeT1nZXRTdHJpbmdPcHRpb24oZS5jcmVkZW50aWFsU2VydmVyUG9saWN5LFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXJsPWUudXJsfHwiIjt0aGlzLnVybFBvbGljeT1lLnVybFBvbGljeXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZW5jcnlwdGlvbj1udWxsO3RoaXMuaXNzdWVycz1udWxsO3RoaXMua2V5VXNhZ2U9bnVsbDt0aGlzLm9pZHM9bnVsbDt0aGlzLnNpZ25pbmc9bnVsbDt0aGlzLnN1YmplY3RETnM9bnVsbH19Y2xhc3MgQ2hlY2tCdXR0b24gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImNoZWNrQnV0dG9uIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm1hcms9Z2V0U3RyaW5nT3B0aW9uKGUubWFyayxbImRlZmF1bHQiLCJjaGVjayIsImNpcmNsZSIsImNyb3NzIiwiZGlhbW9uZCIsInNxdWFyZSIsInN0YXIiXSk7dGhpcy5zaGFwZT1nZXRTdHJpbmdPcHRpb24oZS5zaGFwZSxbInNxdWFyZSIsInJvdW5kIl0pO3RoaXMuc2l6ZT1nZXRNZWFzdXJlbWVudChlLnNpemUsIjEwcHQiKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMubWFyZ2luPW51bGx9W2FuXShlKXtjb25zdCB0PXRvU3R5bGUoIm1hcmdpbiIpLGk9bWVhc3VyZVRvU3RyaW5nKHRoaXMuc2l6ZSk7dC53aWR0aD10LmhlaWdodD1pO2xldCBhLHMscjtjb25zdCBuPXRoaXNbcHJdKClbcHJdKCksbz1uLml0ZW1zLmNoaWxkcmVuLmxlbmd0aCYmbi5pdGVtcy5jaGlsZHJlblswXVthbl0oKS5odG1sfHxbXSxnPXtvbjoodm9pZCAwIT09b1swXT9vWzBdOiJvbiIpLnRvU3RyaW5nKCksb2ZmOih2b2lkIDAhPT1vWzFdP29bMV06Im9mZiIpLnRvU3RyaW5nKCl9LGM9KG4udmFsdWU/Lltlbl0oKXx8Im9mZiIpPT09Zy5vbnx8dm9pZCAwLEM9bltmcl0oKSxoPW5bbm5dO2xldCBsO2lmKEMgaW5zdGFuY2VvZiBFeGNsR3JvdXApe3I9Q1tubl07YT0icmFkaW8iO3M9InhmYVJhZGlvIjtsPUNbdHJdPy5bbm5dfHxDW25uXX1lbHNle2E9ImNoZWNrYm94IjtzPSJ4ZmFDaGVja2JveCI7bD1uW3RyXT8uW25uXXx8bltubl19Y29uc3QgUT17bmFtZToiaW5wdXQiLGF0dHJpYnV0ZXM6e2NsYXNzOltzXSxzdHlsZTp0LGZpZWxkSWQ6aCxkYXRhSWQ6bCx0eXBlOmEsY2hlY2tlZDpjLHhmYU9uOmcub24seGZhT2ZmOmcub2ZmLCJhcmlhLWxhYmVsIjphcmlhTGFiZWwobiksImFyaWEtcmVxdWlyZWQiOiExfX07ciYmKFEuYXR0cmlidXRlcy5uYW1lPXIpO2lmKGlzUmVxdWlyZWQobikpe1EuYXR0cmlidXRlc1siYXJpYS1yZXF1aXJlZCJdPSEwO1EuYXR0cmlidXRlcy5yZXF1aXJlZD0hMH1yZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJsYWJlbCIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFMYWJlbCJdfSxjaGlsZHJlbjpbUV19KX19Y2xhc3MgQ2hvaWNlTGlzdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiY2hvaWNlTGlzdCIsITApO3RoaXMuY29tbWl0T249Z2V0U3RyaW5nT3B0aW9uKGUuY29tbWl0T24sWyJzZWxlY3QiLCJleGl0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vcGVuPWdldFN0cmluZ09wdGlvbihlLm9wZW4sWyJ1c2VyQ29udHJvbCIsImFsd2F5cyIsIm11bHRpU2VsZWN0Iiwib25FbnRyeSJdKTt0aGlzLnRleHRFbnRyeT1nZXRJbnRlZ2VyKHtkYXRhOmUudGV4dEVudHJ5LGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfVthbl0oZSl7Y29uc3QgdD10b1N0eWxlKHRoaXMsImJvcmRlciIsIm1hcmdpbiIpLGk9dGhpc1twcl0oKVtwcl0oKSxhPXtmb250U2l6ZTpgY2FsYygke2kuZm9udD8uc2l6ZXx8MTB9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWB9LHM9W107aWYoaS5pdGVtcy5jaGlsZHJlbi5sZW5ndGg+MCl7Y29uc3QgZT1pLml0ZW1zO2xldCB0PTAscj0wO2lmKDI9PT1lLmNoaWxkcmVuLmxlbmd0aCl7dD1lLmNoaWxkcmVuWzBdLnNhdmU7cj0xLXR9Y29uc3Qgbj1lLmNoaWxkcmVuW3RdW2FuXSgpLmh0bWwsbz1lLmNoaWxkcmVuW3JdW2FuXSgpLmh0bWw7bGV0IGc9ITE7Y29uc3QgYz1pLnZhbHVlPy5bZW5dKCl8fCIiO2ZvcihsZXQgZT0wLHQ9bi5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD17bmFtZToib3B0aW9uIixhdHRyaWJ1dGVzOnt2YWx1ZTpvW2VdfHxuW2VdLHN0eWxlOmF9LHZhbHVlOm5bZV19O29bZV09PT1jJiYodC5hdHRyaWJ1dGVzLnNlbGVjdGVkPWc9ITApO3MucHVzaCh0KX1nfHxzLnNwbGljZSgwLDAse25hbWU6Im9wdGlvbiIsYXR0cmlidXRlczp7aGlkZGVuOiEwLHNlbGVjdGVkOiEwfSx2YWx1ZToiICJ9KX1jb25zdCByPXtjbGFzczpbInhmYVNlbGVjdCJdLGZpZWxkSWQ6aVtubl0sZGF0YUlkOmlbdHJdPy5bbm5dfHxpW25uXSxzdHlsZTp0LCJhcmlhLWxhYmVsIjphcmlhTGFiZWwoaSksImFyaWEtcmVxdWlyZWQiOiExfTtpZihpc1JlcXVpcmVkKGkpKXtyWyJhcmlhLXJlcXVpcmVkIl09ITA7ci5yZXF1aXJlZD0hMH0ibXVsdGlTZWxlY3QiPT09dGhpcy5vcGVuJiYoci5tdWx0aXBsZT0hMCk7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToibGFiZWwiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhTGFiZWwiXX0sY2hpbGRyZW46W3tuYW1lOiJzZWxlY3QiLGNoaWxkcmVuOnMsYXR0cmlidXRlczpyfV19KX19Y2xhc3MgQ29sb3IgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImNvbG9yIiwhMCk7dGhpcy5jU3BhY2U9Z2V0U3RyaW5nT3B0aW9uKGUuY1NwYWNlLFsiU1JHQiJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnZhbHVlPWUudmFsdWU/ZnVuY3Rpb24gZ2V0Q29sb3IoZSx0PVswLDAsMF0pe2xldFtpLGEsc109dDtpZighZSlyZXR1cm57cjppLGc6YSxiOnN9O2NvbnN0IHI9ZS50cmltKCkuc3BsaXQoL1xzKixccyovKS5tYXAoKGU9Pk1hdGgubWluKE1hdGgubWF4KDAscGFyc2VJbnQoZS50cmltKCksMTApKSwyNTUpKSkubWFwKChlPT5pc05hTihlKT8wOmUpKTtpZihyLmxlbmd0aDwzKXJldHVybntyOmksZzphLGI6c307W2ksYSxzXT1yO3JldHVybntyOmksZzphLGI6c319KGUudmFsdWUpOiIiO3RoaXMuZXh0cmFzPW51bGx9W3dyXSgpe3JldHVybiExfVtybl0oKXtyZXR1cm4gdGhpcy52YWx1ZT9VdGlsLm1ha2VIZXhDb2xvcih0aGlzLnZhbHVlLnIsdGhpcy52YWx1ZS5nLHRoaXMudmFsdWUuYik6bnVsbH19Y2xhc3MgQ29tYiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiY29tYiIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5udW1iZXJPZkNlbGxzPWdldEludGVnZXIoe2RhdGE6ZS5udW1iZXJPZkNlbGxzLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIENvbm5lY3QgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImNvbm5lY3QiLCEwKTt0aGlzLmNvbm5lY3Rpb249ZS5jb25uZWN0aW9ufHwiIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnVzYWdlPWdldFN0cmluZ09wdGlvbihlLnVzYWdlLFsiZXhwb3J0QW5kSW1wb3J0IiwiZXhwb3J0T25seSIsImltcG9ydE9ubHkiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMucGljdHVyZT1udWxsfX1jbGFzcyBDb250ZW50QXJlYSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiY29udGVudEFyZWEiLCEwKTt0aGlzLmg9Z2V0TWVhc3VyZW1lbnQoZS5oKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmVsZXZhbnQ9Z2V0UmVsZXZhbnQoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMudz1nZXRNZWFzdXJlbWVudChlLncpO3RoaXMueD1nZXRNZWFzdXJlbWVudChlLngsIjBwdCIpO3RoaXMueT1nZXRNZWFzdXJlbWVudChlLnksIjBwdCIpO3RoaXMuZGVzYz1udWxsO3RoaXMuZXh0cmFzPW51bGx9W2FuXShlKXtjb25zdCB0PXtsZWZ0Om1lYXN1cmVUb1N0cmluZyh0aGlzLngpLHRvcDptZWFzdXJlVG9TdHJpbmcodGhpcy55KSx3aWR0aDptZWFzdXJlVG9TdHJpbmcodGhpcy53KSxoZWlnaHQ6bWVhc3VyZVRvU3RyaW5nKHRoaXMuaCl9LGk9WyJ4ZmFDb250ZW50YXJlYSJdO2lzUHJpbnRPbmx5KHRoaXMpJiZpLnB1c2goInhmYVByaW50T25seSIpO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsY2hpbGRyZW46W10sYXR0cmlidXRlczp7c3R5bGU6dCxjbGFzczppLGlkOnRoaXNbbm5dfX0pfX1jbGFzcyBDb3JuZXIgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImNvcm5lciIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5pbnZlcnRlZD1nZXRJbnRlZ2VyKHtkYXRhOmUuaW52ZXJ0ZWQsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmpvaW49Z2V0U3RyaW5nT3B0aW9uKGUuam9pbixbInNxdWFyZSIsInJvdW5kIl0pO3RoaXMucHJlc2VuY2U9Z2V0U3RyaW5nT3B0aW9uKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yYWRpdXM9Z2V0TWVhc3VyZW1lbnQoZS5yYWRpdXMpO3RoaXMuc3Ryb2tlPWdldFN0cmluZ09wdGlvbihlLnN0cm9rZSxbInNvbGlkIiwiZGFzaERvdCIsImRhc2hEb3REb3QiLCJkYXNoZWQiLCJkb3R0ZWQiLCJlbWJvc3NlZCIsImV0Y2hlZCIsImxvd2VyZWQiLCJyYWlzZWQiXSk7dGhpcy50aGlja25lc3M9Z2V0TWVhc3VyZW1lbnQoZS50aGlja25lc3MsIjAuNXB0Iik7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVtybl0oKXtjb25zdCBlPXRvU3R5bGUodGhpcywidmlzaWJpbGl0eSIpO2UucmFkaXVzPW1lYXN1cmVUb1N0cmluZygic3F1YXJlIj09PXRoaXMuam9pbj8wOnRoaXMucmFkaXVzKTtyZXR1cm4gZX19Y2xhc3MgRGF0ZUVsZW1lbnQgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJkYXRlIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W3NyXSgpe2NvbnN0IGU9dGhpc1tlcl0udHJpbSgpO3RoaXNbZXJdPWU/bmV3IERhdGUoZSk6bnVsbH1bYW5dKGUpe3JldHVybiB2YWx1ZVRvSHRtbCh0aGlzW2VyXT90aGlzW2VyXS50b1N0cmluZygpOiIiKX19Y2xhc3MgRGF0ZVRpbWUgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJkYXRlVGltZSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtzcl0oKXtjb25zdCBlPXRoaXNbZXJdLnRyaW0oKTt0aGlzW2VyXT1lP25ldyBEYXRlKGUpOm51bGx9W2FuXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwodGhpc1tlcl0/dGhpc1tlcl0udG9TdHJpbmcoKToiIil9fWNsYXNzIERhdGVUaW1lRWRpdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZGF0ZVRpbWVFZGl0IiwhMCk7dGhpcy5oU2Nyb2xsUG9saWN5PWdldFN0cmluZ09wdGlvbihlLmhTY3JvbGxQb2xpY3ksWyJhdXRvIiwib2ZmIiwib24iXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnBpY2tlcj1nZXRTdHJpbmdPcHRpb24oZS5waWNrZXIsWyJob3N0Iiwibm9uZSJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmNvbWI9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMubWFyZ2luPW51bGx9W2FuXShlKXtjb25zdCB0PXRvU3R5bGUodGhpcywiYm9yZGVyIiwiZm9udCIsIm1hcmdpbiIpLGk9dGhpc1twcl0oKVtwcl0oKSxhPXtuYW1lOiJpbnB1dCIsYXR0cmlidXRlczp7dHlwZToidGV4dCIsZmllbGRJZDppW25uXSxkYXRhSWQ6aVt0cl0/Lltubl18fGlbbm5dLGNsYXNzOlsieGZhVGV4dGZpZWxkIl0sc3R5bGU6dCwiYXJpYS1sYWJlbCI6YXJpYUxhYmVsKGkpLCJhcmlhLXJlcXVpcmVkIjohMX19O2lmKGlzUmVxdWlyZWQoaSkpe2EuYXR0cmlidXRlc1siYXJpYS1yZXF1aXJlZCJdPSEwO2EuYXR0cmlidXRlcy5yZXF1aXJlZD0hMH1yZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJsYWJlbCIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFMYWJlbCJdfSxjaGlsZHJlbjpbYV19KX19Y2xhc3MgRGVjaW1hbCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImRlY2ltYWwiKTt0aGlzLmZyYWNEaWdpdHM9Z2V0SW50ZWdlcih7ZGF0YTplLmZyYWNEaWdpdHMsZGVmYXVsdFZhbHVlOjIsdmFsaWRhdGU6ZT0+ITB9KTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubGVhZERpZ2l0cz1nZXRJbnRlZ2VyKHtkYXRhOmUubGVhZERpZ2l0cyxkZWZhdWx0VmFsdWU6LTEsdmFsaWRhdGU6ZT0+ITB9KTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W3NyXSgpe2NvbnN0IGU9cGFyc2VGbG9hdCh0aGlzW2VyXS50cmltKCkpO3RoaXNbZXJdPWlzTmFOKGUpP251bGw6ZX1bYW5dKGUpe3JldHVybiB2YWx1ZVRvSHRtbChudWxsIT09dGhpc1tlcl0/dGhpc1tlcl0udG9TdHJpbmcoKToiIil9fWNsYXNzIERlZmF1bHRVaSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZGVmYXVsdFVpIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbH19Y2xhc3MgRGVzYyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZGVzYyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9vbGVhbj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGVUaW1lPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRlY2ltYWw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhEYXRhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZsb2F0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmltYWdlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmludGVnZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGV4dD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50aW1lPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgRGlnZXN0TWV0aG9kIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJkaWdlc3RNZXRob2QiLFsiIiwiU0hBMSIsIlNIQTI1NiIsIlNIQTUxMiIsIlJJUEVNRDE2MCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgRGlnZXN0TWV0aG9kcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZGlnZXN0TWV0aG9kcyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmRpZ2VzdE1ldGhvZD1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIERyYXcgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImRyYXciLCEwKTt0aGlzLmFuY2hvclR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUuYW5jaG9yVHlwZSxbInRvcExlZnQiLCJib3R0b21DZW50ZXIiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJtaWRkbGVDZW50ZXIiLCJtaWRkbGVMZWZ0IiwibWlkZGxlUmlnaHQiLCJ0b3BDZW50ZXIiLCJ0b3BSaWdodCJdKTt0aGlzLmNvbFNwYW49Z2V0SW50ZWdlcih7ZGF0YTplLmNvbFNwYW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ZT49MXx8LTE9PT1lfSk7dGhpcy5oPWUuaD9nZXRNZWFzdXJlbWVudChlLmgpOiIiO3RoaXMuaEFsaWduPWdldFN0cmluZ09wdGlvbihlLmhBbGlnbixbImxlZnQiLCJjZW50ZXIiLCJqdXN0aWZ5IiwianVzdGlmeUFsbCIsInJhZGl4IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxvY2FsZT1lLmxvY2FsZXx8IiI7dGhpcy5tYXhIPWdldE1lYXN1cmVtZW50KGUubWF4SCwiMHB0Iik7dGhpcy5tYXhXPWdldE1lYXN1cmVtZW50KGUubWF4VywiMHB0Iik7dGhpcy5taW5IPWdldE1lYXN1cmVtZW50KGUubWluSCwiMHB0Iik7dGhpcy5taW5XPWdldE1lYXN1cmVtZW50KGUubWluVywiMHB0Iik7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMucm90YXRlPWdldEludGVnZXIoe2RhdGE6ZS5yb3RhdGUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+ZSU5MD09MH0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnc9ZS53P2dldE1lYXN1cmVtZW50KGUudyk6IiI7dGhpcy54PWdldE1lYXN1cmVtZW50KGUueCwiMHB0Iik7dGhpcy55PWdldE1lYXN1cmVtZW50KGUueSwiMHB0Iik7dGhpcy5hc3Npc3Q9bnVsbDt0aGlzLmJvcmRlcj1udWxsO3RoaXMuY2FwdGlvbj1udWxsO3RoaXMuZGVzYz1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5mb250PW51bGw7dGhpcy5rZWVwPW51bGw7dGhpcy5tYXJnaW49bnVsbDt0aGlzLnBhcmE9bnVsbDt0aGlzLnRyYXZlcnNhbD1udWxsO3RoaXMudWk9bnVsbDt0aGlzLnZhbHVlPW51bGw7dGhpcy5zZXRQcm9wZXJ0eT1uZXcgWEZBT2JqZWN0QXJyYXl9WyRyXShlKXtfc2V0VmFsdWUodGhpcyxlKX1bYW5dKGUpe3NldFRhYkluZGV4KHRoaXMpO2lmKCJoaWRkZW4iPT09dGhpcy5wcmVzZW5jZXx8ImluYWN0aXZlIj09PXRoaXMucHJlc2VuY2UpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7Zml4RGltZW5zaW9ucyh0aGlzKTt0aGlzW1dyXSgpO2NvbnN0IHQ9dGhpcy53LGk9dGhpcy5oLHt3OmEsaDpzLGlzQnJva2VuOnJ9PWxheW91dE5vZGUodGhpcyxlKTtpZihhJiYiIj09PXRoaXMudyl7aWYociYmdGhpc1tmcl0oKVtVcl0oKSl7dGhpc1tQcl0oKTtyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFfXRoaXMudz1hfXMmJiIiPT09dGhpcy5oJiYodGhpcy5oPXMpO3NldEZpcnN0VW5zcGxpdHRhYmxlKHRoaXMpO2lmKCFjaGVja0RpbWVuc2lvbnModGhpcyxlKSl7dGhpcy53PXQ7dGhpcy5oPWk7dGhpc1tQcl0oKTtyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFfXVuc2V0Rmlyc3RVbnNwbGl0dGFibGUodGhpcyk7Y29uc3Qgbj10b1N0eWxlKHRoaXMsImZvbnQiLCJoQWxpZ24iLCJkaW1lbnNpb25zIiwicG9zaXRpb24iLCJwcmVzZW5jZSIsInJvdGF0ZSIsImFuY2hvclR5cGUiLCJib3JkZXIiLCJtYXJnaW4iKTtzZXRNaW5NYXhEaW1lbnNpb25zKHRoaXMsbik7aWYobi5tYXJnaW4pe24ucGFkZGluZz1uLm1hcmdpbjtkZWxldGUgbi5tYXJnaW59Y29uc3Qgbz1bInhmYURyYXciXTt0aGlzLmZvbnQmJm8ucHVzaCgieGZhRm9udCIpO2lzUHJpbnRPbmx5KHRoaXMpJiZvLnB1c2goInhmYVByaW50T25seSIpO2NvbnN0IGc9e3N0eWxlOm4saWQ6dGhpc1tubl0sY2xhc3M6b307dGhpcy5uYW1lJiYoZy54ZmFOYW1lPXRoaXMubmFtZSk7Y29uc3QgYz17bmFtZToiZGl2IixhdHRyaWJ1dGVzOmcsY2hpbGRyZW46W119O2FwcGx5QXNzaXN0KHRoaXMsZyk7Y29uc3QgQz1jb21wdXRlQmJveCh0aGlzLGMsZSksaD10aGlzLnZhbHVlP3RoaXMudmFsdWVbYW5dKGUpLmh0bWw6bnVsbDtpZihudWxsPT09aCl7dGhpcy53PXQ7dGhpcy5oPWk7dGhpc1tQcl0oKTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyxjKSxDKX1jLmNoaWxkcmVuLnB1c2goaCk7c2V0UGFyYSh0aGlzLG4saCk7dGhpcy53PXQ7dGhpcy5oPWk7dGhpc1tQcl0oKTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyxjKSxDKX19Y2xhc3MgRWRnZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZWRnZSIsITApO3RoaXMuY2FwPWdldFN0cmluZ09wdGlvbihlLmNhcCxbInNxdWFyZSIsImJ1dHQiLCJyb3VuZCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucHJlc2VuY2U9Z2V0U3RyaW5nT3B0aW9uKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5zdHJva2U9Z2V0U3RyaW5nT3B0aW9uKGUuc3Ryb2tlLFsic29saWQiLCJkYXNoRG90IiwiZGFzaERvdERvdCIsImRhc2hlZCIsImRvdHRlZCIsImVtYm9zc2VkIiwiZXRjaGVkIiwibG93ZXJlZCIsInJhaXNlZCJdKTt0aGlzLnRoaWNrbmVzcz1nZXRNZWFzdXJlbWVudChlLnRoaWNrbmVzcywiMC41cHQiKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5jb2xvcj1udWxsO3RoaXMuZXh0cmFzPW51bGx9W3JuXSgpe2NvbnN0IGU9dG9TdHlsZSh0aGlzLCJ2aXNpYmlsaXR5Iik7T2JqZWN0LmFzc2lnbihlLHtsaW5lY2FwOnRoaXMuY2FwLHdpZHRoOm1lYXN1cmVUb1N0cmluZyh0aGlzLnRoaWNrbmVzcyksY29sb3I6dGhpcy5jb2xvcj90aGlzLmNvbG9yW3JuXSgpOiIjMDAwMDAwIixzdHlsZToiIn0pO2lmKCJ2aXNpYmxlIiE9PXRoaXMucHJlc2VuY2UpZS5zdHlsZT0ibm9uZSI7ZWxzZSBzd2l0Y2godGhpcy5zdHJva2Upe2Nhc2Uic29saWQiOmUuc3R5bGU9InNvbGlkIjticmVhaztjYXNlImRhc2hEb3QiOmNhc2UiZGFzaERvdERvdCI6Y2FzZSJkYXNoZWQiOmUuc3R5bGU9ImRhc2hlZCI7YnJlYWs7Y2FzZSJkb3R0ZWQiOmUuc3R5bGU9ImRvdHRlZCI7YnJlYWs7Y2FzZSJlbWJvc3NlZCI6ZS5zdHlsZT0icmlkZ2UiO2JyZWFrO2Nhc2UiZXRjaGVkIjplLnN0eWxlPSJncm9vdmUiO2JyZWFrO2Nhc2UibG93ZXJlZCI6ZS5zdHlsZT0iaW5zZXQiO2JyZWFrO2Nhc2UicmFpc2VkIjplLnN0eWxlPSJvdXRzZXQifXJldHVybiBlfX1jbGFzcyBFbmNvZGluZyBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZW5jb2RpbmciLFsiYWRiZS54NTA5LnJzYV9zaGExIiwiYWRiZS5wa2NzNy5kZXRhY2hlZCIsImFkYmUucGtjczcuc2hhMSJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgRW5jb2RpbmdzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJlbmNvZGluZ3MiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5lbmNvZGluZz1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEVuY3J5cHQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImVuY3J5cHQiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmNlcnRpZmljYXRlPW51bGx9fWNsYXNzIEVuY3J5cHREYXRhIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJlbmNyeXB0RGF0YSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vcGVyYXRpb249Z2V0U3RyaW5nT3B0aW9uKGUub3BlcmF0aW9uLFsiZW5jcnlwdCIsImRlY3J5cHQiXSk7dGhpcy50YXJnZXQ9ZS50YXJnZXR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmZpbHRlcj1udWxsO3RoaXMubWFuaWZlc3Q9bnVsbH19Y2xhc3MgRW5jcnlwdGlvbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZW5jcnlwdGlvbiIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmNlcnRpZmljYXRlPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgRW5jcnlwdGlvbk1ldGhvZCBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZW5jcnlwdGlvbk1ldGhvZCIsWyIiLCJBRVMyNTYtQ0JDIiwiVFJJUExFREVTLUNCQyIsIkFFUzEyOC1DQkMiLCJBRVMxOTItQ0JDIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBFbmNyeXB0aW9uTWV0aG9kcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZW5jcnlwdGlvbk1ldGhvZHMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5lbmNyeXB0aW9uTWV0aG9kPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgRXZlbnQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImV2ZW50IiwhMCk7dGhpcy5hY3Rpdml0eT1nZXRTdHJpbmdPcHRpb24oZS5hY3Rpdml0eSxbImNsaWNrIiwiY2hhbmdlIiwiZG9jQ2xvc2UiLCJkb2NSZWFkeSIsImVudGVyIiwiZXhpdCIsImZ1bGwiLCJpbmRleENoYW5nZSIsImluaXRpYWxpemUiLCJtb3VzZURvd24iLCJtb3VzZUVudGVyIiwibW91c2VFeGl0IiwibW91c2VVcCIsInBvc3RFeGVjdXRlIiwicG9zdE9wZW4iLCJwb3N0UHJpbnQiLCJwb3N0U2F2ZSIsInBvc3RTaWduIiwicG9zdFN1Ym1pdCIsInByZUV4ZWN1dGUiLCJwcmVPcGVuIiwicHJlUHJpbnQiLCJwcmVTYXZlIiwicHJlU2lnbiIsInByZVN1Ym1pdCIsInJlYWR5IiwidmFsaWRhdGlvblN0YXRlIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5saXN0ZW49Z2V0U3RyaW5nT3B0aW9uKGUubGlzdGVuLFsicmVmT25seSIsInJlZkFuZERlc2NlbmRlbnRzIl0pO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmVuY3J5cHREYXRhPW51bGw7dGhpcy5leGVjdXRlPW51bGw7dGhpcy5zY3JpcHQ9bnVsbDt0aGlzLnNpZ25EYXRhPW51bGw7dGhpcy5zdWJtaXQ9bnVsbH19Y2xhc3MgRXhEYXRhIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZXhEYXRhIik7dGhpcy5jb250ZW50VHlwZT1lLmNvbnRlbnRUeXBlfHwiIjt0aGlzLmhyZWY9ZS5ocmVmfHwiIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubWF4TGVuZ3RoPWdldEludGVnZXIoe2RhdGE6ZS5tYXhMZW5ndGgsZGVmYXVsdFZhbHVlOi0xLHZhbGlkYXRlOmU9PmU+PS0xfSk7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5yaWQ9ZS5yaWR8fCIiO3RoaXMudHJhbnNmZXJFbmNvZGluZz1nZXRTdHJpbmdPcHRpb24oZS50cmFuc2ZlckVuY29kaW5nLFsibm9uZSIsImJhc2U2NCIsInBhY2thZ2UiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtTcl0oKXtyZXR1cm4idGV4dC9odG1sIj09PXRoaXMuY29udGVudFR5cGV9W0tyXShlKXtpZigidGV4dC9odG1sIj09PXRoaXMuY29udGVudFR5cGUmJmVbSnJdPT09Z24ueGh0bWwuaWQpe3RoaXNbZXJdPWU7cmV0dXJuITB9aWYoInRleHQveG1sIj09PXRoaXMuY29udGVudFR5cGUpe3RoaXNbZXJdPWU7cmV0dXJuITB9cmV0dXJuITF9W2FuXShlKXtyZXR1cm4idGV4dC9odG1sIj09PXRoaXMuY29udGVudFR5cGUmJnRoaXNbZXJdP3RoaXNbZXJdW2FuXShlKTpIVE1MUmVzdWx0LkVNUFRZfX1jbGFzcyBFeE9iamVjdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZXhPYmplY3QiLCEwKTt0aGlzLmFyY2hpdmU9ZS5hcmNoaXZlfHwiIjt0aGlzLmNsYXNzSWQ9ZS5jbGFzc0lkfHwiIjt0aGlzLmNvZGVCYXNlPWUuY29kZUJhc2V8fCIiO3RoaXMuY29kZVR5cGU9ZS5jb2RlVHlwZXx8IiI7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmJvb2xlYW49bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlVGltZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kZWNpbWFsPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4RGF0YT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5leE9iamVjdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbWFnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRleHQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGltZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEV4Y2xHcm91cCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZXhjbEdyb3VwIiwhMCk7dGhpcy5hY2Nlc3M9Z2V0U3RyaW5nT3B0aW9uKGUuYWNjZXNzLFsib3BlbiIsIm5vbkludGVyYWN0aXZlIiwicHJvdGVjdGVkIiwicmVhZE9ubHkiXSk7dGhpcy5hY2Nlc3NLZXk9ZS5hY2Nlc3NLZXl8fCIiO3RoaXMuYW5jaG9yVHlwZT1nZXRTdHJpbmdPcHRpb24oZS5hbmNob3JUeXBlLFsidG9wTGVmdCIsImJvdHRvbUNlbnRlciIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsIm1pZGRsZUNlbnRlciIsIm1pZGRsZUxlZnQiLCJtaWRkbGVSaWdodCIsInRvcENlbnRlciIsInRvcFJpZ2h0Il0pO3RoaXMuY29sU3Bhbj1nZXRJbnRlZ2VyKHtkYXRhOmUuY29sU3BhbixkZWZhdWx0VmFsdWU6MSx2YWxpZGF0ZTplPT5lPj0xfHwtMT09PWV9KTt0aGlzLmg9ZS5oP2dldE1lYXN1cmVtZW50KGUuaCk6IiI7dGhpcy5oQWxpZ249Z2V0U3RyaW5nT3B0aW9uKGUuaEFsaWduLFsibGVmdCIsImNlbnRlciIsImp1c3RpZnkiLCJqdXN0aWZ5QWxsIiwicmFkaXgiLCJyaWdodCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubGF5b3V0PWdldFN0cmluZ09wdGlvbihlLmxheW91dCxbInBvc2l0aW9uIiwibHItdGIiLCJybC1yb3ciLCJybC10YiIsInJvdyIsInRhYmxlIiwidGIiXSk7dGhpcy5tYXhIPWdldE1lYXN1cmVtZW50KGUubWF4SCwiMHB0Iik7dGhpcy5tYXhXPWdldE1lYXN1cmVtZW50KGUubWF4VywiMHB0Iik7dGhpcy5taW5IPWdldE1lYXN1cmVtZW50KGUubWluSCwiMHB0Iik7dGhpcy5taW5XPWdldE1lYXN1cmVtZW50KGUubWluVywiMHB0Iik7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnc9ZS53P2dldE1lYXN1cmVtZW50KGUudyk6IiI7dGhpcy54PWdldE1lYXN1cmVtZW50KGUueCwiMHB0Iik7dGhpcy55PWdldE1lYXN1cmVtZW50KGUueSwiMHB0Iik7dGhpcy5hc3Npc3Q9bnVsbDt0aGlzLmJpbmQ9bnVsbDt0aGlzLmJvcmRlcj1udWxsO3RoaXMuY2FsY3VsYXRlPW51bGw7dGhpcy5jYXB0aW9uPW51bGw7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsO3RoaXMucGFyYT1udWxsO3RoaXMudHJhdmVyc2FsPW51bGw7dGhpcy52YWxpZGF0ZT1udWxsO3RoaXMuY29ubmVjdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5ldmVudD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5maWVsZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zZXRQcm9wZXJ0eT1uZXcgWEZBT2JqZWN0QXJyYXl9W2tyXSgpe3JldHVybiEwfVt3cl0oKXtyZXR1cm4hMH1bJHJdKGUpe2Zvcihjb25zdCB0IG9mIHRoaXMuZmllbGQuY2hpbGRyZW4pe2lmKCF0LnZhbHVlKXtjb25zdCBlPW5ldyBWYWx1ZSh7fSk7dFtYc10oZSk7dC52YWx1ZT1lfXQudmFsdWVbJHJdKGUpfX1bVXJdKCl7cmV0dXJuIHRoaXMubGF5b3V0LmVuZHNXaXRoKCItdGIiKSYmMD09PXRoaXNbYXJdLmF0dGVtcHQmJnRoaXNbYXJdLm51bWJlckluTGluZT4wfHx0aGlzW3ByXSgpW1VyXSgpfVt4cl0oKXtjb25zdCBlPXRoaXNbZnJdKCk7aWYoIWVbeHJdKCkpcmV0dXJuITE7aWYodm9pZCAwIT09dGhpc1thcl0uX2lzU3BsaXR0YWJsZSlyZXR1cm4gdGhpc1thcl0uX2lzU3BsaXR0YWJsZTtpZigicG9zaXRpb24iPT09dGhpcy5sYXlvdXR8fHRoaXMubGF5b3V0LmluY2x1ZGVzKCJyb3ciKSl7dGhpc1thcl0uX2lzU3BsaXR0YWJsZT0hMTtyZXR1cm4hMX1pZihlLmxheW91dD8uZW5kc1dpdGgoIi10YiIpJiYwIT09ZVthcl0ubnVtYmVySW5MaW5lKXJldHVybiExO3RoaXNbYXJdLl9pc1NwbGl0dGFibGU9ITA7cmV0dXJuITB9W3JyXSgpe3JldHVybiBmbHVzaEhUTUwodGhpcyl9W2pzXShlLHQpe2FkZEhUTUwodGhpcyxlLHQpfVtncl0oKXtyZXR1cm4gZ2V0QXZhaWxhYmxlU3BhY2UodGhpcyl9W2FuXShlKXtzZXRUYWJJbmRleCh0aGlzKTtpZigiaGlkZGVuIj09PXRoaXMucHJlc2VuY2V8fCJpbmFjdGl2ZSI9PT10aGlzLnByZXNlbmNlfHwwPT09dGhpcy5ofHwwPT09dGhpcy53KXJldHVybiBIVE1MUmVzdWx0LkVNUFRZO2ZpeERpbWVuc2lvbnModGhpcyk7Y29uc3QgdD1bXSxpPXtpZDp0aGlzW25uXSxjbGFzczpbXX07c2V0QWNjZXNzKHRoaXMsaS5jbGFzcyk7dGhpc1thcl18fCh0aGlzW2FyXT1PYmplY3QuY3JlYXRlKG51bGwpKTtPYmplY3QuYXNzaWduKHRoaXNbYXJdLHtjaGlsZHJlbjp0LGF0dHJpYnV0ZXM6aSxhdHRlbXB0OjAsbGluZTpudWxsLG51bWJlckluTGluZTowLGF2YWlsYWJsZVNwYWNlOnt3aWR0aDpNYXRoLm1pbih0aGlzLnd8fDEvMCxlLndpZHRoKSxoZWlnaHQ6TWF0aC5taW4odGhpcy5ofHwxLzAsZS5oZWlnaHQpfSx3aWR0aDowLGhlaWdodDowLHByZXZIZWlnaHQ6MCxjdXJyZW50V2lkdGg6MH0pO2NvbnN0IGE9dGhpc1t4cl0oKTthfHxzZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTtpZighY2hlY2tEaW1lbnNpb25zKHRoaXMsZSkpcmV0dXJuIEhUTUxSZXN1bHQuRkFJTFVSRTtjb25zdCBzPW5ldyBTZXQoWyJmaWVsZCJdKTtpZih0aGlzLmxheW91dC5pbmNsdWRlcygicm93Iikpe2NvbnN0IGU9dGhpc1tmcl0oKS5jb2x1bW5XaWR0aHM7aWYoQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg+MCl7dGhpc1thcl0uY29sdW1uV2lkdGhzPWU7dGhpc1thcl0uY3VycmVudENvbHVtbj0wfX1jb25zdCByPXRvU3R5bGUodGhpcywiYW5jaG9yVHlwZSIsImRpbWVuc2lvbnMiLCJwb3NpdGlvbiIsInByZXNlbmNlIiwiYm9yZGVyIiwibWFyZ2luIiwiaEFsaWduIiksbj1bInhmYUV4Y2xncm91cCJdLG89bGF5b3V0Q2xhc3ModGhpcyk7byYmbi5wdXNoKG8pO2lzUHJpbnRPbmx5KHRoaXMpJiZuLnB1c2goInhmYVByaW50T25seSIpO2kuc3R5bGU9cjtpLmNsYXNzPW47dGhpcy5uYW1lJiYoaS54ZmFOYW1lPXRoaXMubmFtZSk7dGhpc1tXcl0oKTtjb25zdCBnPSJsci10YiI9PT10aGlzLmxheW91dHx8InJsLXRiIj09PXRoaXMubGF5b3V0LGM9Zz8yOjE7Zm9yKDt0aGlzW2FyXS5hdHRlbXB0PGM7dGhpc1thcl0uYXR0ZW1wdCsrKXtnJiYxPT09dGhpc1thcl0uYXR0ZW1wdCYmKHRoaXNbYXJdLm51bWJlckluTGluZT0wKTtjb25zdCBlPXRoaXNbWnNdKHtmaWx0ZXI6cyxpbmNsdWRlOiEwfSk7aWYoZS5zdWNjZXNzKWJyZWFrO2lmKGUuaXNCcmVhaygpKXt0aGlzW1ByXSgpO3JldHVybiBlfWlmKGcmJjA9PT10aGlzW2FyXS5hdHRlbXB0JiYwPT09dGhpc1thcl0ubnVtYmVySW5MaW5lJiYhdGhpc1ttcl0oKVthcl0ubm9MYXlvdXRGYWlsdXJlKXt0aGlzW2FyXS5hdHRlbXB0PWM7YnJlYWt9fXRoaXNbUHJdKCk7YXx8dW5zZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTtpZih0aGlzW2FyXS5hdHRlbXB0PT09Yyl7YXx8ZGVsZXRlIHRoaXNbYXJdO3JldHVybiBIVE1MUmVzdWx0LkZBSUxVUkV9bGV0IEM9MCxoPTA7aWYodGhpcy5tYXJnaW4pe0M9dGhpcy5tYXJnaW4ubGVmdEluc2V0K3RoaXMubWFyZ2luLnJpZ2h0SW5zZXQ7aD10aGlzLm1hcmdpbi50b3BJbnNldCt0aGlzLm1hcmdpbi5ib3R0b21JbnNldH1jb25zdCBsPU1hdGgubWF4KHRoaXNbYXJdLndpZHRoK0MsdGhpcy53fHwwKSxRPU1hdGgubWF4KHRoaXNbYXJdLmhlaWdodCtoLHRoaXMuaHx8MCksRT1bdGhpcy54LHRoaXMueSxsLFFdOyIiPT09dGhpcy53JiYoci53aWR0aD1tZWFzdXJlVG9TdHJpbmcobCkpOyIiPT09dGhpcy5oJiYoci5oZWlnaHQ9bWVhc3VyZVRvU3RyaW5nKFEpKTtjb25zdCB1PXtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6aSxjaGlsZHJlbjp0fTthcHBseUFzc2lzdCh0aGlzLGkpO2RlbGV0ZSB0aGlzW2FyXTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyx1KSxFKX19Y2xhc3MgRXhlY3V0ZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZXhlY3V0ZSIpO3RoaXMuY29ubmVjdGlvbj1lLmNvbm5lY3Rpb258fCIiO3RoaXMuZXhlY3V0ZVR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUuZXhlY3V0ZVR5cGUsWyJpbXBvcnQiLCJyZW1lcmdlIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5ydW5BdD1nZXRTdHJpbmdPcHRpb24oZS5ydW5BdCxbImNsaWVudCIsImJvdGgiLCJzZXJ2ZXIiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBFeHRyYXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImV4dHJhcyIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9vbGVhbj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGVUaW1lPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRlY2ltYWw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhEYXRhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4dHJhcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbWFnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRleHQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGltZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEZpZWxkIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJmaWVsZCIsITApO3RoaXMuYWNjZXNzPWdldFN0cmluZ09wdGlvbihlLmFjY2VzcyxbIm9wZW4iLCJub25JbnRlcmFjdGl2ZSIsInByb3RlY3RlZCIsInJlYWRPbmx5Il0pO3RoaXMuYWNjZXNzS2V5PWUuYWNjZXNzS2V5fHwiIjt0aGlzLmFuY2hvclR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUuYW5jaG9yVHlwZSxbInRvcExlZnQiLCJib3R0b21DZW50ZXIiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJtaWRkbGVDZW50ZXIiLCJtaWRkbGVMZWZ0IiwibWlkZGxlUmlnaHQiLCJ0b3BDZW50ZXIiLCJ0b3BSaWdodCJdKTt0aGlzLmNvbFNwYW49Z2V0SW50ZWdlcih7ZGF0YTplLmNvbFNwYW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ZT49MXx8LTE9PT1lfSk7dGhpcy5oPWUuaD9nZXRNZWFzdXJlbWVudChlLmgpOiIiO3RoaXMuaEFsaWduPWdldFN0cmluZ09wdGlvbihlLmhBbGlnbixbImxlZnQiLCJjZW50ZXIiLCJqdXN0aWZ5IiwianVzdGlmeUFsbCIsInJhZGl4IiwicmlnaHQiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxvY2FsZT1lLmxvY2FsZXx8IiI7dGhpcy5tYXhIPWdldE1lYXN1cmVtZW50KGUubWF4SCwiMHB0Iik7dGhpcy5tYXhXPWdldE1lYXN1cmVtZW50KGUubWF4VywiMHB0Iik7dGhpcy5taW5IPWdldE1lYXN1cmVtZW50KGUubWluSCwiMHB0Iik7dGhpcy5taW5XPWdldE1lYXN1cmVtZW50KGUubWluVywiMHB0Iik7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy5wcmVzZW5jZT1nZXRTdHJpbmdPcHRpb24oZS5wcmVzZW5jZSxbInZpc2libGUiLCJoaWRkZW4iLCJpbmFjdGl2ZSIsImludmlzaWJsZSJdKTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMucm90YXRlPWdldEludGVnZXIoe2RhdGE6ZS5yb3RhdGUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+ZSU5MD09MH0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnc9ZS53P2dldE1lYXN1cmVtZW50KGUudyk6IiI7dGhpcy54PWdldE1lYXN1cmVtZW50KGUueCwiMHB0Iik7dGhpcy55PWdldE1lYXN1cmVtZW50KGUueSwiMHB0Iik7dGhpcy5hc3Npc3Q9bnVsbDt0aGlzLmJpbmQ9bnVsbDt0aGlzLmJvcmRlcj1udWxsO3RoaXMuY2FsY3VsYXRlPW51bGw7dGhpcy5jYXB0aW9uPW51bGw7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmZvbnQ9bnVsbDt0aGlzLmZvcm1hdD1udWxsO3RoaXMuaXRlbXM9bmV3IFhGQU9iamVjdEFycmF5KDIpO3RoaXMua2VlcD1udWxsO3RoaXMubWFyZ2luPW51bGw7dGhpcy5wYXJhPW51bGw7dGhpcy50cmF2ZXJzYWw9bnVsbDt0aGlzLnVpPW51bGw7dGhpcy52YWxpZGF0ZT1udWxsO3RoaXMudmFsdWU9bnVsbDt0aGlzLmJpbmRJdGVtcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5jb25uZWN0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV2ZW50PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnNldFByb3BlcnR5PW5ldyBYRkFPYmplY3RBcnJheX1ba3JdKCl7cmV0dXJuITB9WyRyXShlKXtfc2V0VmFsdWUodGhpcyxlKX1bYW5dKGUpe3NldFRhYkluZGV4KHRoaXMpO2lmKCF0aGlzLnVpKXt0aGlzLnVpPW5ldyBVaSh7fSk7dGhpcy51aVt5cl09dGhpc1t5cl07dGhpc1tYc10odGhpcy51aSk7bGV0IGU7c3dpdGNoKHRoaXMuaXRlbXMuY2hpbGRyZW4ubGVuZ3RoKXtjYXNlIDA6ZT1uZXcgVGV4dEVkaXQoe30pO3RoaXMudWkudGV4dEVkaXQ9ZTticmVhaztjYXNlIDE6ZT1uZXcgQ2hlY2tCdXR0b24oe30pO3RoaXMudWkuY2hlY2tCdXR0b249ZTticmVhaztjYXNlIDI6ZT1uZXcgQ2hvaWNlTGlzdCh7fSk7dGhpcy51aS5jaG9pY2VMaXN0PWV9dGhpcy51aVtYc10oZSl9aWYoIXRoaXMudWl8fCJoaWRkZW4iPT09dGhpcy5wcmVzZW5jZXx8ImluYWN0aXZlIj09PXRoaXMucHJlc2VuY2V8fDA9PT10aGlzLmh8fDA9PT10aGlzLncpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7dGhpcy5jYXB0aW9uJiZkZWxldGUgdGhpcy5jYXB0aW9uW2FyXTt0aGlzW1dyXSgpO2NvbnN0IHQ9dGhpcy5jYXB0aW9uP3RoaXMuY2FwdGlvblthbl0oZSkuaHRtbDpudWxsLGk9dGhpcy53LGE9dGhpcy5oO2xldCBzPTAscj0wO2lmKHRoaXMubWFyZ2luKXtzPXRoaXMubWFyZ2luLmxlZnRJbnNldCt0aGlzLm1hcmdpbi5yaWdodEluc2V0O3I9dGhpcy5tYXJnaW4udG9wSW5zZXQrdGhpcy5tYXJnaW4uYm90dG9tSW5zZXR9bGV0IG49bnVsbDtpZigiIj09PXRoaXMud3x8IiI9PT10aGlzLmgpe2xldCB0PW51bGwsaT1udWxsLGE9MCxvPTA7aWYodGhpcy51aS5jaGVja0J1dHRvbilhPW89dGhpcy51aS5jaGVja0J1dHRvbi5zaXplO2Vsc2V7Y29uc3R7dzp0LGg6aX09bGF5b3V0Tm9kZSh0aGlzLGUpO2lmKG51bGwhPT10KXthPXQ7bz1pfWVsc2Ugbz1mdW5jdGlvbiBmb250c19nZXRNZXRyaWNzKGUsdD0hMSl7bGV0IGk9bnVsbDtpZihlKXtjb25zdCB0PXN0cmlwUXVvdGVzKGUudHlwZWZhY2UpLGE9ZVt5cl0uZm9udEZpbmRlci5maW5kKHQpO2k9c2VsZWN0Rm9udChlLGEpfWlmKCFpKXJldHVybntsaW5lSGVpZ2h0OjEyLGxpbmVHYXA6MixsaW5lTm9HYXA6MTB9O2NvbnN0IGE9ZS5zaXplfHwxMCxzPWkubGluZUhlaWdodD9NYXRoLm1heCh0PzA6MS4yLGkubGluZUhlaWdodCk6MS4yLHI9dm9pZCAwPT09aS5saW5lR2FwPy4yOmkubGluZUdhcDtyZXR1cm57bGluZUhlaWdodDpzKmEsbGluZUdhcDpyKmEsbGluZU5vR2FwOk1hdGgubWF4KDEscy1yKSphfX0odGhpcy5mb250LCEwKS5saW5lTm9HYXB9bj1nZXRCb3JkZXJEaW1zKHRoaXMudWlbbHJdKCkpO2ErPW4udztvKz1uLmg7aWYodGhpcy5jYXB0aW9uKXtjb25zdHt3OnMsaDpyLGlzQnJva2VuOm59PXRoaXMuY2FwdGlvbltscl0oZSk7aWYobiYmdGhpc1tmcl0oKVtVcl0oKSl7dGhpc1tQcl0oKTtyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFfXQ9cztpPXI7c3dpdGNoKHRoaXMuY2FwdGlvbi5wbGFjZW1lbnQpe2Nhc2UibGVmdCI6Y2FzZSJyaWdodCI6Y2FzZSJpbmxpbmUiOnQrPWE7YnJlYWs7Y2FzZSJ0b3AiOmNhc2UiYm90dG9tIjppKz1vfX1lbHNle3Q9YTtpPW99aWYodCYmIiI9PT10aGlzLncpe3QrPXM7dGhpcy53PU1hdGgubWluKHRoaXMubWF4Vzw9MD8xLzA6dGhpcy5tYXhXLHRoaXMubWluVysxPHQ/dDp0aGlzLm1pblcpfWlmKGkmJiIiPT09dGhpcy5oKXtpKz1yO3RoaXMuaD1NYXRoLm1pbih0aGlzLm1heEg8PTA/MS8wOnRoaXMubWF4SCx0aGlzLm1pbkgrMTxpP2k6dGhpcy5taW5IKX19dGhpc1tQcl0oKTtmaXhEaW1lbnNpb25zKHRoaXMpO3NldEZpcnN0VW5zcGxpdHRhYmxlKHRoaXMpO2lmKCFjaGVja0RpbWVuc2lvbnModGhpcyxlKSl7dGhpcy53PWk7dGhpcy5oPWE7dGhpc1tQcl0oKTtyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFfXVuc2V0Rmlyc3RVbnNwbGl0dGFibGUodGhpcyk7Y29uc3Qgbz10b1N0eWxlKHRoaXMsImZvbnQiLCJkaW1lbnNpb25zIiwicG9zaXRpb24iLCJyb3RhdGUiLCJhbmNob3JUeXBlIiwicHJlc2VuY2UiLCJtYXJnaW4iLCJoQWxpZ24iKTtzZXRNaW5NYXhEaW1lbnNpb25zKHRoaXMsbyk7Y29uc3QgZz1bInhmYUZpZWxkIl07dGhpcy5mb250JiZnLnB1c2goInhmYUZvbnQiKTtpc1ByaW50T25seSh0aGlzKSYmZy5wdXNoKCJ4ZmFQcmludE9ubHkiKTtjb25zdCBjPXtzdHlsZTpvLGlkOnRoaXNbbm5dLGNsYXNzOmd9O2lmKG8ubWFyZ2luKXtvLnBhZGRpbmc9by5tYXJnaW47ZGVsZXRlIG8ubWFyZ2lufXNldEFjY2Vzcyh0aGlzLGcpO3RoaXMubmFtZSYmKGMueGZhTmFtZT10aGlzLm5hbWUpO2NvbnN0IEM9W10saD17bmFtZToiZGl2IixhdHRyaWJ1dGVzOmMsY2hpbGRyZW46Q307YXBwbHlBc3Npc3QodGhpcyxjKTtjb25zdCBsPXRoaXMuYm9yZGVyP3RoaXMuYm9yZGVyW3JuXSgpOm51bGwsUT1jb21wdXRlQmJveCh0aGlzLGgsZSksRT10aGlzLnVpW2FuXSgpLmh0bWw7aWYoIUUpe09iamVjdC5hc3NpZ24obyxsKTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyxoKSxRKX10aGlzW0FuXSYmKEUuY2hpbGRyZW4/LlswXT9FLmNoaWxkcmVuWzBdLmF0dHJpYnV0ZXMudGFiaW5kZXg9dGhpc1tBbl06RS5hdHRyaWJ1dGVzLnRhYmluZGV4PXRoaXNbQW5dKTtFLmF0dHJpYnV0ZXMuc3R5bGV8fChFLmF0dHJpYnV0ZXMuc3R5bGU9T2JqZWN0LmNyZWF0ZShudWxsKSk7bGV0IHU9bnVsbDtpZih0aGlzLnVpLmJ1dHRvbil7MT09PUUuY2hpbGRyZW4ubGVuZ3RoJiYoW3VdPUUuY2hpbGRyZW4uc3BsaWNlKDAsMSkpO09iamVjdC5hc3NpZ24oRS5hdHRyaWJ1dGVzLnN0eWxlLGwpfWVsc2UgT2JqZWN0LmFzc2lnbihvLGwpO0MucHVzaChFKTtpZih0aGlzLnZhbHVlKWlmKHRoaXMudWkuaW1hZ2VFZGl0KUUuY2hpbGRyZW4ucHVzaCh0aGlzLnZhbHVlW2FuXSgpLmh0bWwpO2Vsc2UgaWYoIXRoaXMudWkuYnV0dG9uKXtsZXQgZT0iIjtpZih0aGlzLnZhbHVlLmV4RGF0YSllPXRoaXMudmFsdWUuZXhEYXRhW2VuXSgpO2Vsc2UgaWYodGhpcy52YWx1ZS50ZXh0KWU9dGhpcy52YWx1ZS50ZXh0W2xyXSgpO2Vsc2V7Y29uc3QgdD10aGlzLnZhbHVlW2FuXSgpLmh0bWw7bnVsbCE9PXQmJihlPXQuY2hpbGRyZW5bMF0udmFsdWUpfXRoaXMudWkudGV4dEVkaXQmJnRoaXMudmFsdWUudGV4dD8ubWF4Q2hhcnMmJihFLmNoaWxkcmVuWzBdLmF0dHJpYnV0ZXMubWF4TGVuZ3RoPXRoaXMudmFsdWUudGV4dC5tYXhDaGFycyk7aWYoZSl7aWYodGhpcy51aS5udW1lcmljRWRpdCl7ZT1wYXJzZUZsb2F0KGUpO2U9aXNOYU4oZSk/IiI6ZS50b1N0cmluZygpfSJ0ZXh0YXJlYSI9PT1FLmNoaWxkcmVuWzBdLm5hbWU/RS5jaGlsZHJlblswXS5hdHRyaWJ1dGVzLnRleHRDb250ZW50PWU6RS5jaGlsZHJlblswXS5hdHRyaWJ1dGVzLnZhbHVlPWV9fWlmKCF0aGlzLnVpLmltYWdlRWRpdCYmRS5jaGlsZHJlbj8uWzBdJiZ0aGlzLmgpe249bnx8Z2V0Qm9yZGVyRGltcyh0aGlzLnVpW2xyXSgpKTtsZXQgdD0wO2lmKHRoaXMuY2FwdGlvbiYmWyJ0b3AiLCJib3R0b20iXS5pbmNsdWRlcyh0aGlzLmNhcHRpb24ucGxhY2VtZW50KSl7dD10aGlzLmNhcHRpb24ucmVzZXJ2ZTt0PD0wJiYodD10aGlzLmNhcHRpb25bbHJdKGUpLmgpO2NvbnN0IGk9dGhpcy5oLXQtci1uLmg7RS5jaGlsZHJlblswXS5hdHRyaWJ1dGVzLnN0eWxlLmhlaWdodD1tZWFzdXJlVG9TdHJpbmcoaSl9ZWxzZSBFLmNoaWxkcmVuWzBdLmF0dHJpYnV0ZXMuc3R5bGUuaGVpZ2h0PSIxMDAlIn11JiZFLmNoaWxkcmVuLnB1c2godSk7aWYoIXQpe0UuYXR0cmlidXRlcy5jbGFzcyYmRS5hdHRyaWJ1dGVzLmNsYXNzLnB1c2goInhmYUxlZnQiKTt0aGlzLnc9aTt0aGlzLmg9YTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyxoKSxRKX1pZih0aGlzLnVpLmJ1dHRvbil7by5wYWRkaW5nJiZkZWxldGUgby5wYWRkaW5nOyJkaXYiPT09dC5uYW1lJiYodC5uYW1lPSJzcGFuIik7RS5jaGlsZHJlbi5wdXNoKHQpO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3MoaCxRKX10aGlzLnVpLmNoZWNrQnV0dG9uJiYodC5hdHRyaWJ1dGVzLmNsYXNzWzBdPSJ4ZmFDYXB0aW9uRm9yQ2hlY2tCdXR0b24iKTtFLmF0dHJpYnV0ZXMuY2xhc3N8fChFLmF0dHJpYnV0ZXMuY2xhc3M9W10pO0UuY2hpbGRyZW4uc3BsaWNlKDAsMCx0KTtzd2l0Y2godGhpcy5jYXB0aW9uLnBsYWNlbWVudCl7Y2FzZSJsZWZ0IjpjYXNlImlubGluZSI6RS5hdHRyaWJ1dGVzLmNsYXNzLnB1c2goInhmYUxlZnQiKTticmVhaztjYXNlInJpZ2h0IjpFLmF0dHJpYnV0ZXMuY2xhc3MucHVzaCgieGZhUmlnaHQiKTticmVhaztjYXNlInRvcCI6RS5hdHRyaWJ1dGVzLmNsYXNzLnB1c2goInhmYVRvcCIpO2JyZWFrO2Nhc2UiYm90dG9tIjpFLmF0dHJpYnV0ZXMuY2xhc3MucHVzaCgieGZhQm90dG9tIil9dGhpcy53PWk7dGhpcy5oPWE7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhjcmVhdGVXcmFwcGVyKHRoaXMsaCksUSl9fWNsYXNzIEZpbGwgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImZpbGwiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucHJlc2VuY2U9Z2V0U3RyaW5nT3B0aW9uKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMubGluZWFyPW51bGw7dGhpcy5wYXR0ZXJuPW51bGw7dGhpcy5yYWRpYWw9bnVsbDt0aGlzLnNvbGlkPW51bGw7dGhpcy5zdGlwcGxlPW51bGx9W3JuXSgpe2NvbnN0IGU9dGhpc1twcl0oKSx0PWVbcHJdKClbcHJdKCksaT1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBhPSJjb2xvciIscz1hO2lmKGUgaW5zdGFuY2VvZiBCb3JkZXIpe2E9ImJhY2tncm91bmQtY29sb3IiO3M9ImJhY2tncm91bmQiO3QgaW5zdGFuY2VvZiBVaSYmKGkuYmFja2dyb3VuZENvbG9yPSJ3aGl0ZSIpfWlmKGUgaW5zdGFuY2VvZiBSZWN0YW5nbGV8fGUgaW5zdGFuY2VvZiBBcmMpe2E9cz0iZmlsbCI7aS5maWxsPSJ3aGl0ZSJ9Zm9yKGNvbnN0IGUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpe2lmKCJleHRyYXMiPT09ZXx8ImNvbG9yIj09PWUpY29udGludWU7Y29uc3QgdD10aGlzW2VdO2lmKCEodCBpbnN0YW5jZW9mIFhGQU9iamVjdCkpY29udGludWU7Y29uc3Qgcj10W3JuXSh0aGlzLmNvbG9yKTtyJiYoaVtyLnN0YXJ0c1dpdGgoIiMiKT9hOnNdPXIpO3JldHVybiBpfWlmKHRoaXMuY29sb3I/LnZhbHVlKXtjb25zdCBlPXRoaXMuY29sb3Jbcm5dKCk7aVtlLnN0YXJ0c1dpdGgoIiMiKT9hOnNdPWV9cmV0dXJuIGl9fWNsYXNzIEZpbHRlciBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiZmlsdGVyIiwhMCk7dGhpcy5hZGRSZXZvY2F0aW9uSW5mbz1nZXRTdHJpbmdPcHRpb24oZS5hZGRSZXZvY2F0aW9uSW5mbyxbIiIsInJlcXVpcmVkIiwib3B0aW9uYWwiLCJub25lIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMudmVyc2lvbj1nZXRJbnRlZ2VyKHtkYXRhOnRoaXMudmVyc2lvbixkZWZhdWx0VmFsdWU6NSx2YWxpZGF0ZTplPT5lPj0xJiZlPD01fSk7dGhpcy5hcHBlYXJhbmNlRmlsdGVyPW51bGw7dGhpcy5jZXJ0aWZpY2F0ZXM9bnVsbDt0aGlzLmRpZ2VzdE1ldGhvZHM9bnVsbDt0aGlzLmVuY29kaW5ncz1udWxsO3RoaXMuZW5jcnlwdGlvbk1ldGhvZHM9bnVsbDt0aGlzLmhhbmRsZXI9bnVsbDt0aGlzLmxvY2tEb2N1bWVudD1udWxsO3RoaXMubWRwPW51bGw7dGhpcy5yZWFzb25zPW51bGw7dGhpcy50aW1lU3RhbXA9bnVsbH19Y2xhc3MgRmxvYXQgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJmbG9hdCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtzcl0oKXtjb25zdCBlPXBhcnNlRmxvYXQodGhpc1tlcl0udHJpbSgpKTt0aGlzW2VyXT1pc05hTihlKT9udWxsOmV9W2FuXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwobnVsbCE9PXRoaXNbZXJdP3RoaXNbZXJdLnRvU3RyaW5nKCk6IiIpfX1jbGFzcyB0ZW1wbGF0ZV9Gb250IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJmb250IiwhMCk7dGhpcy5iYXNlbGluZVNoaWZ0PWdldE1lYXN1cmVtZW50KGUuYmFzZWxpbmVTaGlmdCk7dGhpcy5mb250SG9yaXpvbnRhbFNjYWxlPWdldEZsb2F0KHtkYXRhOmUuZm9udEhvcml6b250YWxTY2FsZSxkZWZhdWx0VmFsdWU6MTAwLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLmZvbnRWZXJ0aWNhbFNjYWxlPWdldEZsb2F0KHtkYXRhOmUuZm9udFZlcnRpY2FsU2NhbGUsZGVmYXVsdFZhbHVlOjEwMCx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmtlcm5pbmdNb2RlPWdldFN0cmluZ09wdGlvbihlLmtlcm5pbmdNb2RlLFsibm9uZSIsInBhaXIiXSk7dGhpcy5sZXR0ZXJTcGFjaW5nPWdldE1lYXN1cmVtZW50KGUubGV0dGVyU3BhY2luZywiMCIpO3RoaXMubGluZVRocm91Z2g9Z2V0SW50ZWdlcih7ZGF0YTplLmxpbmVUaHJvdWdoLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfHwyPT09ZX0pO3RoaXMubGluZVRocm91Z2hQZXJpb2Q9Z2V0U3RyaW5nT3B0aW9uKGUubGluZVRocm91Z2hQZXJpb2QsWyJhbGwiLCJ3b3JkIl0pO3RoaXMub3ZlcmxpbmU9Z2V0SW50ZWdlcih7ZGF0YTplLm92ZXJsaW5lLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfHwyPT09ZX0pO3RoaXMub3ZlcmxpbmVQZXJpb2Q9Z2V0U3RyaW5nT3B0aW9uKGUub3ZlcmxpbmVQZXJpb2QsWyJhbGwiLCJ3b3JkIl0pO3RoaXMucG9zdHVyZT1nZXRTdHJpbmdPcHRpb24oZS5wb3N0dXJlLFsibm9ybWFsIiwiaXRhbGljIl0pO3RoaXMuc2l6ZT1nZXRNZWFzdXJlbWVudChlLnNpemUsIjEwcHQiKTt0aGlzLnR5cGVmYWNlPWUudHlwZWZhY2V8fCJDb3VyaWVyIjt0aGlzLnVuZGVybGluZT1nZXRJbnRlZ2VyKHtkYXRhOmUudW5kZXJsaW5lLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfHwyPT09ZX0pO3RoaXMudW5kZXJsaW5lUGVyaW9kPWdldFN0cmluZ09wdGlvbihlLnVuZGVybGluZVBlcmlvZCxbImFsbCIsIndvcmQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMud2VpZ2h0PWdldFN0cmluZ09wdGlvbihlLndlaWdodCxbIm5vcm1hbCIsImJvbGQiXSk7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmZpbGw9bnVsbH1bVnNdKGUpe3N1cGVyW1ZzXShlKTt0aGlzW3lyXS51c2VkVHlwZWZhY2VzLmFkZCh0aGlzLnR5cGVmYWNlKX1bcm5dKCl7Y29uc3QgZT10b1N0eWxlKHRoaXMsImZpbGwiKSx0PWUuY29sb3I7aWYodClpZigiIzAwMDAwMCI9PT10KWRlbGV0ZSBlLmNvbG9yO2Vsc2UgaWYoIXQuc3RhcnRzV2l0aCgiIyIpKXtlLmJhY2tncm91bmQ9dDtlLmJhY2tncm91bmRDbGlwPSJ0ZXh0IjtlLmNvbG9yPSJ0cmFuc3BhcmVudCJ9dGhpcy5iYXNlbGluZVNoaWZ0JiYoZS52ZXJ0aWNhbEFsaWduPW1lYXN1cmVUb1N0cmluZyh0aGlzLmJhc2VsaW5lU2hpZnQpKTtlLmZvbnRLZXJuaW5nPSJub25lIj09PXRoaXMua2VybmluZ01vZGU/Im5vbmUiOiJub3JtYWwiO2UubGV0dGVyU3BhY2luZz1tZWFzdXJlVG9TdHJpbmcodGhpcy5sZXR0ZXJTcGFjaW5nKTtpZigwIT09dGhpcy5saW5lVGhyb3VnaCl7ZS50ZXh0RGVjb3JhdGlvbj0ibGluZS10aHJvdWdoIjsyPT09dGhpcy5saW5lVGhyb3VnaCYmKGUudGV4dERlY29yYXRpb25TdHlsZT0iZG91YmxlIil9aWYoMCE9PXRoaXMub3ZlcmxpbmUpe2UudGV4dERlY29yYXRpb249Im92ZXJsaW5lIjsyPT09dGhpcy5vdmVybGluZSYmKGUudGV4dERlY29yYXRpb25TdHlsZT0iZG91YmxlIil9ZS5mb250U3R5bGU9dGhpcy5wb3N0dXJlO2UuZm9udFNpemU9bWVhc3VyZVRvU3RyaW5nKC45OSp0aGlzLnNpemUpO3NldEZvbnRGYW1pbHkodGhpcyx0aGlzLHRoaXNbeXJdLmZvbnRGaW5kZXIsZSk7aWYoMCE9PXRoaXMudW5kZXJsaW5lKXtlLnRleHREZWNvcmF0aW9uPSJ1bmRlcmxpbmUiOzI9PT10aGlzLnVuZGVybGluZSYmKGUudGV4dERlY29yYXRpb25TdHlsZT0iZG91YmxlIil9ZS5mb250V2VpZ2h0PXRoaXMud2VpZ2h0O3JldHVybiBlfX1jbGFzcyBGb3JtYXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImZvcm1hdCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5waWN0dXJlPW51bGx9fWNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImhhbmRsZXIiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIEh5cGhlbmF0aW9uIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJoeXBoZW5hdGlvbiIpO3RoaXMuZXhjbHVkZUFsbENhcHM9Z2V0SW50ZWdlcih7ZGF0YTplLmV4Y2x1ZGVBbGxDYXBzLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5leGNsdWRlSW5pdGlhbENhcD1nZXRJbnRlZ2VyKHtkYXRhOmUuZXhjbHVkZUluaXRpYWxDYXAsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmh5cGhlbmF0ZT1nZXRJbnRlZ2VyKHtkYXRhOmUuaHlwaGVuYXRlLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnB1c2hDaGFyYWN0ZXJDb3VudD1nZXRJbnRlZ2VyKHtkYXRhOmUucHVzaENoYXJhY3RlckNvdW50LGRlZmF1bHRWYWx1ZTozLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLnJlbWFpbkNoYXJhY3RlckNvdW50PWdldEludGVnZXIoe2RhdGE6ZS5yZW1haW5DaGFyYWN0ZXJDb3VudCxkZWZhdWx0VmFsdWU6Myx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMud29yZENoYXJhY3RlckNvdW50PWdldEludGVnZXIoe2RhdGE6ZS53b3JkQ2hhcmFjdGVyQ291bnQsZGVmYXVsdFZhbHVlOjcsdmFsaWRhdGU6ZT0+ZT49MH0pfX1jbGFzcyBJbWFnZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiaW1hZ2UiKTt0aGlzLmFzcGVjdD1nZXRTdHJpbmdPcHRpb24oZS5hc3BlY3QsWyJmaXQiLCJhY3R1YWwiLCJoZWlnaHQiLCJub25lIiwid2lkdGgiXSk7dGhpcy5jb250ZW50VHlwZT1lLmNvbnRlbnRUeXBlfHwiIjt0aGlzLmhyZWY9ZS5ocmVmfHwiIjt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudHJhbnNmZXJFbmNvZGluZz1nZXRTdHJpbmdPcHRpb24oZS50cmFuc2ZlckVuY29kaW5nLFsiYmFzZTY0Iiwibm9uZSIsInBhY2thZ2UiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVthbl0oKXtpZih0aGlzLmNvbnRlbnRUeXBlJiYhdm4uaGFzKHRoaXMuY29udGVudFR5cGUudG9Mb3dlckNhc2UoKSkpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7bGV0IGU9dGhpc1t5cl0uaW1hZ2VzJiZ0aGlzW3lyXS5pbWFnZXMuZ2V0KHRoaXMuaHJlZik7aWYoIWUmJih0aGlzLmhyZWZ8fCF0aGlzW2VyXSkpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7ZXx8ImJhc2U2NCIhPT10aGlzLnRyYW5zZmVyRW5jb2Rpbmd8fChlPXN0cmluZ1RvQnl0ZXMoYXRvYih0aGlzW2VyXSkpKTtpZighZSlyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTtpZighdGhpcy5jb250ZW50VHlwZSl7Zm9yKGNvbnN0W3QsaV1vZiBLbilpZihlLmxlbmd0aD50Lmxlbmd0aCYmdC5ldmVyeSgoKHQsaSk9PnQ9PT1lW2ldKSkpe3RoaXMuY29udGVudFR5cGU9aTticmVha31pZighdGhpcy5jb250ZW50VHlwZSlyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWX1jb25zdCB0PW5ldyBCbG9iKFtlXSx7dHlwZTp0aGlzLmNvbnRlbnRUeXBlfSk7bGV0IGk7c3dpdGNoKHRoaXMuYXNwZWN0KXtjYXNlImZpdCI6Y2FzZSJhY3R1YWwiOmJyZWFrO2Nhc2UiaGVpZ2h0IjppPXtoZWlnaHQ6IjEwMCUiLG9iamVjdEZpdDoiZmlsbCJ9O2JyZWFrO2Nhc2Uibm9uZSI6aT17d2lkdGg6IjEwMCUiLGhlaWdodDoiMTAwJSIsb2JqZWN0Rml0OiJmaWxsIn07YnJlYWs7Y2FzZSJ3aWR0aCI6aT17d2lkdGg6IjEwMCUiLG9iamVjdEZpdDoiZmlsbCJ9fWNvbnN0IGE9dGhpc1twcl0oKTtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJpbWciLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhSW1hZ2UiXSxzdHlsZTppLHNyYzpVUkwuY3JlYXRlT2JqZWN0VVJMKHQpLGFsdDphP2FyaWFMYWJlbChhW3ByXSgpKTpudWxsfX0pfX1jbGFzcyBJbWFnZUVkaXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sImltYWdlRWRpdCIsITApO3RoaXMuZGF0YT1nZXRTdHJpbmdPcHRpb24oZS5kYXRhLFsibGluayIsImVtYmVkIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1hcmdpbj1udWxsfVthbl0oZSl7cmV0dXJuImVtYmVkIj09PXRoaXMuZGF0YT9IVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsY2hpbGRyZW46W10sYXR0cmlidXRlczp7fX0pOkhUTUxSZXN1bHQuRU1QVFl9fWNsYXNzIEludGVnZXIgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJpbnRlZ2VyIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W3NyXSgpe2NvbnN0IGU9cGFyc2VJbnQodGhpc1tlcl0udHJpbSgpLDEwKTt0aGlzW2VyXT1pc05hTihlKT9udWxsOmV9W2FuXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwobnVsbCE9PXRoaXNbZXJdP3RoaXNbZXJdLnRvU3RyaW5nKCk6IiIpfX1jbGFzcyBJc3N1ZXJzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJpc3N1ZXJzIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY2VydGlmaWNhdGU9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBJdGVtcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwiaXRlbXMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucHJlc2VuY2U9Z2V0U3RyaW5nT3B0aW9uKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yZWY9ZS5yZWZ8fCIiO3RoaXMuc2F2ZT1nZXRJbnRlZ2VyKHtkYXRhOmUuc2F2ZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvb2xlYW49bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlVGltZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kZWNpbWFsPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4RGF0YT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbWFnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRleHQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGltZT1uZXcgWEZBT2JqZWN0QXJyYXl9W2FuXSgpe2NvbnN0IGU9W107Zm9yKGNvbnN0IHQgb2YgdGhpc1tFcl0oKSllLnB1c2godFtlbl0oKSk7cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhlKX19Y2xhc3MgS2VlcCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwia2VlcCIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7Y29uc3QgdD1bIm5vbmUiLCJjb250ZW50QXJlYSIsInBhZ2VBcmVhIl07dGhpcy5pbnRhY3Q9Z2V0U3RyaW5nT3B0aW9uKGUuaW50YWN0LHQpO3RoaXMubmV4dD1nZXRTdHJpbmdPcHRpb24oZS5uZXh0LHQpO3RoaXMucHJldmlvdXM9Z2V0U3RyaW5nT3B0aW9uKGUucHJldmlvdXMsdCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9fWNsYXNzIEtleVVzYWdlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJrZXlVc2FnZSIpO2NvbnN0IHQ9WyIiLCJ5ZXMiLCJubyJdO3RoaXMuY3JsU2lnbj1nZXRTdHJpbmdPcHRpb24oZS5jcmxTaWduLHQpO3RoaXMuZGF0YUVuY2lwaGVybWVudD1nZXRTdHJpbmdPcHRpb24oZS5kYXRhRW5jaXBoZXJtZW50LHQpO3RoaXMuZGVjaXBoZXJPbmx5PWdldFN0cmluZ09wdGlvbihlLmRlY2lwaGVyT25seSx0KTt0aGlzLmRpZ2l0YWxTaWduYXR1cmU9Z2V0U3RyaW5nT3B0aW9uKGUuZGlnaXRhbFNpZ25hdHVyZSx0KTt0aGlzLmVuY2lwaGVyT25seT1nZXRTdHJpbmdPcHRpb24oZS5lbmNpcGhlck9ubHksdCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmtleUFncmVlbWVudD1nZXRTdHJpbmdPcHRpb24oZS5rZXlBZ3JlZW1lbnQsdCk7dGhpcy5rZXlDZXJ0U2lnbj1nZXRTdHJpbmdPcHRpb24oZS5rZXlDZXJ0U2lnbix0KTt0aGlzLmtleUVuY2lwaGVybWVudD1nZXRTdHJpbmdPcHRpb24oZS5rZXlFbmNpcGhlcm1lbnQsdCk7dGhpcy5ub25SZXB1ZGlhdGlvbj1nZXRTdHJpbmdPcHRpb24oZS5ub25SZXB1ZGlhdGlvbix0KTt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBMaW5lIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJsaW5lIiwhMCk7dGhpcy5oYW5kPWdldFN0cmluZ09wdGlvbihlLmhhbmQsWyJldmVuIiwibGVmdCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5zbG9wZT1nZXRTdHJpbmdPcHRpb24oZS5zbG9wZSxbIlxcIiwiLyJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5lZGdlPW51bGx9W2FuXSgpe2NvbnN0IGU9dGhpc1twcl0oKVtwcl0oKSx0PXRoaXMuZWRnZXx8bmV3IEVkZ2Uoe30pLGk9dFtybl0oKSxhPU9iamVjdC5jcmVhdGUobnVsbCkscz0idmlzaWJsZSI9PT10LnByZXNlbmNlP3QudGhpY2tuZXNzOjA7YS5zdHJva2VXaWR0aD1tZWFzdXJlVG9TdHJpbmcocyk7YS5zdHJva2U9aS5jb2xvcjtsZXQgcixuLG8sZyxjPSIxMDAlIixDPSIxMDAlIjtpZihlLnc8PXMpe1tyLG4sbyxnXT1bIjUwJSIsMCwiNTAlIiwiMTAwJSJdO2M9YS5zdHJva2VXaWR0aH1lbHNlIGlmKGUuaDw9cyl7W3IsbixvLGddPVswLCI1MCUiLCIxMDAlIiwiNTAlIl07Qz1hLnN0cm9rZVdpZHRofWVsc2UiXFwiPT09dGhpcy5zbG9wZT9bcixuLG8sZ109WzAsMCwiMTAwJSIsIjEwMCUiXTpbcixuLG8sZ109WzAsIjEwMCUiLCIxMDAlIiwwXTtjb25zdCBoPXtuYW1lOiJzdmciLGNoaWxkcmVuOlt7bmFtZToibGluZSIsYXR0cmlidXRlczp7eG1sbnM6Sm4seDE6cix5MTpuLHgyOm8seTI6ZyxzdHlsZTphfX1dLGF0dHJpYnV0ZXM6e3htbG5zOkpuLHdpZHRoOmMsaGVpZ2h0OkMsc3R5bGU6e292ZXJmbG93OiJ2aXNpYmxlIn19fTtpZihoYXNNYXJnaW4oZSkpcmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixhdHRyaWJ1dGVzOntzdHlsZTp7ZGlzcGxheToiaW5saW5lIix3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIn19LGNoaWxkcmVuOltoXX0pO2guYXR0cmlidXRlcy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3MoaCl9fWNsYXNzIExpbmVhciBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwibGluZWFyIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbInRvUmlnaHQiLCJ0b0JvdHRvbSIsInRvTGVmdCIsInRvVG9wIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmNvbG9yPW51bGw7dGhpcy5leHRyYXM9bnVsbH1bcm5dKGUpe2U9ZT9lW3JuXSgpOiIjRkZGRkZGIjtyZXR1cm5gbGluZWFyLWdyYWRpZW50KCR7dGhpcy50eXBlLnJlcGxhY2UoLyhbUkJMVF0pLywiICQxIikudG9Mb3dlckNhc2UoKX0sICR7ZX0sICR7dGhpcy5jb2xvcj90aGlzLmNvbG9yW3JuXSgpOiIjMDAwMDAwIn0pYH19Y2xhc3MgTG9ja0RvY3VtZW50IGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwibG9ja0RvY3VtZW50Iik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtzcl0oKXt0aGlzW2VyXT1nZXRTdHJpbmdPcHRpb24odGhpc1tlcl0sWyJhdXRvIiwiMCIsIjEiXSl9fWNsYXNzIE1hbmlmZXN0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJtYW5pZmVzdCIsITApO3RoaXMuYWN0aW9uPWdldFN0cmluZ09wdGlvbihlLmFjdGlvbixbImluY2x1ZGUiLCJhbGwiLCJleGNsdWRlIl0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5yZWY9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBNYXJnaW4gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sIm1hcmdpbiIsITApO3RoaXMuYm90dG9tSW5zZXQ9Z2V0TWVhc3VyZW1lbnQoZS5ib3R0b21JbnNldCwiMCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5sZWZ0SW5zZXQ9Z2V0TWVhc3VyZW1lbnQoZS5sZWZ0SW5zZXQsIjAiKTt0aGlzLnJpZ2h0SW5zZXQ9Z2V0TWVhc3VyZW1lbnQoZS5yaWdodEluc2V0LCIwIik7dGhpcy50b3BJbnNldD1nZXRNZWFzdXJlbWVudChlLnRvcEluc2V0LCIwIik7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZXh0cmFzPW51bGx9W3JuXSgpe3JldHVybnttYXJnaW46bWVhc3VyZVRvU3RyaW5nKHRoaXMudG9wSW5zZXQpKyIgIittZWFzdXJlVG9TdHJpbmcodGhpcy5yaWdodEluc2V0KSsiICIrbWVhc3VyZVRvU3RyaW5nKHRoaXMuYm90dG9tSW5zZXQpKyIgIittZWFzdXJlVG9TdHJpbmcodGhpcy5sZWZ0SW5zZXQpfX19Y2xhc3MgTWRwIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJtZHAiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMucGVybWlzc2lvbnM9Z2V0SW50ZWdlcih7ZGF0YTplLnBlcm1pc3Npb25zLGRlZmF1bHRWYWx1ZToyLHZhbGlkYXRlOmU9PjE9PT1lfHwzPT09ZX0pO3RoaXMuc2lnbmF0dXJlVHlwZT1nZXRTdHJpbmdPcHRpb24oZS5zaWduYXR1cmVUeXBlLFsiZmlsbGVyIiwiYXV0aG9yIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgTWVkaXVtIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJtZWRpdW0iKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMuaW1hZ2luZ0JCb3g9ZnVuY3Rpb24gZ2V0QkJveChlKXtjb25zdCB0PS0xO2lmKCFlKXJldHVybnt4OnQseTp0LHdpZHRoOnQsaGVpZ2h0OnR9O2NvbnN0IGk9ZS50cmltKCkuc3BsaXQoL1xzKixccyovKS5tYXAoKGU9PmdldE1lYXN1cmVtZW50KGUsIi0xIikpKTtpZihpLmxlbmd0aDw0fHxpWzJdPDB8fGlbM108MClyZXR1cm57eDp0LHk6dCx3aWR0aDp0LGhlaWdodDp0fTtjb25zdFthLHMscixuXT1pO3JldHVybnt4OmEseTpzLHdpZHRoOnIsaGVpZ2h0Om59fShlLmltYWdpbmdCQm94KTt0aGlzLmxvbmc9Z2V0TWVhc3VyZW1lbnQoZS5sb25nKTt0aGlzLm9yaWVudGF0aW9uPWdldFN0cmluZ09wdGlvbihlLm9yaWVudGF0aW9uLFsicG9ydHJhaXQiLCJsYW5kc2NhcGUiXSk7dGhpcy5zaG9ydD1nZXRNZWFzdXJlbWVudChlLnNob3J0KTt0aGlzLnN0b2NrPWUuc3RvY2t8fCIiO3RoaXMudHJheUluPWdldFN0cmluZ09wdGlvbihlLnRyYXlJbixbImF1dG8iLCJkZWxlZ2F0ZSIsInBhZ2VGcm9udCJdKTt0aGlzLnRyYXlPdXQ9Z2V0U3RyaW5nT3B0aW9uKGUudHJheU91dCxbImF1dG8iLCJkZWxlZ2F0ZSJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIE1lc3NhZ2UgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sIm1lc3NhZ2UiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnRleHQ9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBOdW1lcmljRWRpdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwibnVtZXJpY0VkaXQiLCEwKTt0aGlzLmhTY3JvbGxQb2xpY3k9Z2V0U3RyaW5nT3B0aW9uKGUuaFNjcm9sbFBvbGljeSxbImF1dG8iLCJvZmYiLCJvbiJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvcmRlcj1udWxsO3RoaXMuY29tYj1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tYXJnaW49bnVsbH1bYW5dKGUpe2NvbnN0IHQ9dG9TdHlsZSh0aGlzLCJib3JkZXIiLCJmb250IiwibWFyZ2luIiksaT10aGlzW3ByXSgpW3ByXSgpLGE9e25hbWU6ImlucHV0IixhdHRyaWJ1dGVzOnt0eXBlOiJ0ZXh0IixmaWVsZElkOmlbbm5dLGRhdGFJZDppW3RyXT8uW25uXXx8aVtubl0sY2xhc3M6WyJ4ZmFUZXh0ZmllbGQiXSxzdHlsZTp0LCJhcmlhLWxhYmVsIjphcmlhTGFiZWwoaSksImFyaWEtcmVxdWlyZWQiOiExfX07aWYoaXNSZXF1aXJlZChpKSl7YS5hdHRyaWJ1dGVzWyJhcmlhLXJlcXVpcmVkIl09ITA7YS5hdHRyaWJ1dGVzLnJlcXVpcmVkPSEwfXJldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImxhYmVsIixhdHRyaWJ1dGVzOntjbGFzczpbInhmYUxhYmVsIl19LGNoaWxkcmVuOlthXX0pfX1jbGFzcyBPY2N1ciBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwib2NjdXIiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMuaW5pdGlhbD0iIiE9PWUuaW5pdGlhbD9nZXRJbnRlZ2VyKHtkYXRhOmUuaW5pdGlhbCxkZWZhdWx0VmFsdWU6IiIsdmFsaWRhdGU6ZT0+ITB9KToiIjt0aGlzLm1heD0iIiE9PWUubWF4P2dldEludGVnZXIoe2RhdGE6ZS5tYXgsZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ITB9KToiIjt0aGlzLm1pbj0iIiE9PWUubWluP2dldEludGVnZXIoe2RhdGE6ZS5taW4sZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ITB9KToiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbH1bVnNdKCl7Y29uc3QgZT10aGlzW3ByXSgpLHQ9dGhpcy5taW47IiI9PT10aGlzLm1pbiYmKHRoaXMubWluPWUgaW5zdGFuY2VvZiBQYWdlQXJlYXx8ZSBpbnN0YW5jZW9mIFBhZ2VTZXQ/MDoxKTsiIj09PXRoaXMubWF4JiYodGhpcy5tYXg9IiI9PT10P2UgaW5zdGFuY2VvZiBQYWdlQXJlYXx8ZSBpbnN0YW5jZW9mIFBhZ2VTZXQ/LTE6MTp0aGlzLm1pbik7LTEhPT10aGlzLm1heCYmdGhpcy5tYXg8dGhpcy5taW4mJih0aGlzLm1heD10aGlzLm1pbik7IiI9PT10aGlzLmluaXRpYWwmJih0aGlzLmluaXRpYWw9ZSBpbnN0YW5jZW9mIFRlbXBsYXRlPzE6dGhpcy5taW4pfX1jbGFzcyBPaWQgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sIm9pZCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBPaWRzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJvaWRzIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMub2lkPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgT3ZlcmZsb3cgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sIm92ZXJmbG93Iik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmxlYWRlcj1lLmxlYWRlcnx8IiI7dGhpcy50YXJnZXQ9ZS50YXJnZXR8fCIiO3RoaXMudHJhaWxlcj1lLnRyYWlsZXJ8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn1bbHJdKCl7aWYoIXRoaXNbYXJdKXtjb25zdCBlPXRoaXNbcHJdKCksdD10aGlzW21yXSgpLGk9dFtWcl0odGhpcy50YXJnZXQsZSksYT10W1ZyXSh0aGlzLmxlYWRlcixlKSxzPXRbVnJdKHRoaXMudHJhaWxlcixlKTt0aGlzW2FyXT17dGFyZ2V0Omk/LlswXXx8bnVsbCxsZWFkZXI6YT8uWzBdfHxudWxsLHRyYWlsZXI6cz8uWzBdfHxudWxsLGFkZExlYWRlcjohMSxhZGRUcmFpbGVyOiExfX1yZXR1cm4gdGhpc1thcl19fWNsYXNzIFBhZ2VBcmVhIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJwYWdlQXJlYSIsITApO3RoaXMuYmxhbmtPck5vdEJsYW5rPWdldFN0cmluZ09wdGlvbihlLmJsYW5rT3JOb3RCbGFuayxbImFueSIsImJsYW5rIiwibm90QmxhbmsiXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLmluaXRpYWxOdW1iZXI9Z2V0SW50ZWdlcih7ZGF0YTplLmluaXRpYWxOdW1iZXIsZGVmYXVsdFZhbHVlOjEsdmFsaWRhdGU6ZT0+ITB9KTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLm51bWJlcmVkPWdldEludGVnZXIoe2RhdGE6ZS5udW1iZXJlZCxkZWZhdWx0VmFsdWU6MSx2YWxpZGF0ZTplPT4hMH0pO3RoaXMub2RkT3JFdmVuPWdldFN0cmluZ09wdGlvbihlLm9kZE9yRXZlbixbImFueSIsImV2ZW4iLCJvZGQiXSk7dGhpcy5wYWdlUG9zaXRpb249Z2V0U3RyaW5nT3B0aW9uKGUucGFnZVBvc2l0aW9uLFsiYW55IiwiZmlyc3QiLCJsYXN0Iiwib25seSIsInJlc3QiXSk7dGhpcy5yZWxldmFudD1nZXRSZWxldmFudChlLnJlbGV2YW50KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5kZXNjPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm1lZGl1bT1udWxsO3RoaXMub2NjdXI9bnVsbDt0aGlzLmFyZWE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY29udGVudEFyZWE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZHJhdz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5leGNsR3JvdXA9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZmllbGQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3ViZm9ybT1uZXcgWEZBT2JqZWN0QXJyYXl9W0xyXSgpe2lmKCF0aGlzW2FyXSl7dGhpc1thcl09e251bWJlck9mVXNlOjB9O3JldHVybiEwfXJldHVybiF0aGlzLm9jY3VyfHwtMT09PXRoaXMub2NjdXIubWF4fHx0aGlzW2FyXS5udW1iZXJPZlVzZTx0aGlzLm9jY3VyLm1heH1benNdKCl7ZGVsZXRlIHRoaXNbYXJdfVtkcl0oKXt0aGlzW2FyXXx8KHRoaXNbYXJdPXtudW1iZXJPZlVzZTowfSk7Y29uc3QgZT10aGlzW3ByXSgpO2lmKCJvcmRlcmVkT2NjdXJyZW5jZSI9PT1lLnJlbGF0aW9uJiZ0aGlzW0xyXSgpKXt0aGlzW2FyXS5udW1iZXJPZlVzZSs9MTtyZXR1cm4gdGhpc31yZXR1cm4gZVtkcl0oKX1bZ3JdKCl7cmV0dXJuIHRoaXNbYXJdLnNwYWNlfHx7d2lkdGg6MCxoZWlnaHQ6MH19W2FuXSgpe3RoaXNbYXJdfHwodGhpc1thcl09e251bWJlck9mVXNlOjF9KTtjb25zdCBlPVtdO3RoaXNbYXJdLmNoaWxkcmVuPWU7Y29uc3QgdD1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHRoaXMubWVkaXVtJiZ0aGlzLm1lZGl1bS5zaG9ydCYmdGhpcy5tZWRpdW0ubG9uZyl7dC53aWR0aD1tZWFzdXJlVG9TdHJpbmcodGhpcy5tZWRpdW0uc2hvcnQpO3QuaGVpZ2h0PW1lYXN1cmVUb1N0cmluZyh0aGlzLm1lZGl1bS5sb25nKTt0aGlzW2FyXS5zcGFjZT17d2lkdGg6dGhpcy5tZWRpdW0uc2hvcnQsaGVpZ2h0OnRoaXMubWVkaXVtLmxvbmd9O2lmKCJsYW5kc2NhcGUiPT09dGhpcy5tZWRpdW0ub3JpZW50YXRpb24pe2NvbnN0IGU9dC53aWR0aDt0LndpZHRoPXQuaGVpZ2h0O3QuaGVpZ2h0PWU7dGhpc1thcl0uc3BhY2U9e3dpZHRoOnRoaXMubWVkaXVtLmxvbmcsaGVpZ2h0OnRoaXMubWVkaXVtLnNob3J0fX19ZWxzZSB3YXJuKCJYRkEgLSBObyBtZWRpdW0gc3BlY2lmaWVkIGluIHBhZ2VBcmVhOiBwbGVhc2UgZmlsZSBhIGJ1Zy4iKTt0aGlzW1pzXSh7ZmlsdGVyOm5ldyBTZXQoWyJhcmVhIiwiZHJhdyIsImZpZWxkIiwic3ViZm9ybSJdKSxpbmNsdWRlOiEwfSk7dGhpc1tac10oe2ZpbHRlcjpuZXcgU2V0KFsiY29udGVudEFyZWEiXSksaW5jbHVkZTohMH0pO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImRpdiIsY2hpbGRyZW46ZSxhdHRyaWJ1dGVzOntjbGFzczpbInhmYVBhZ2UiXSxpZDp0aGlzW25uXSxzdHlsZTp0LHhmYU5hbWU6dGhpcy5uYW1lfX0pfX1jbGFzcyBQYWdlU2V0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJwYWdlU2V0IiwhMCk7dGhpcy5kdXBsZXhJbXBvc2l0aW9uPWdldFN0cmluZ09wdGlvbihlLmR1cGxleEltcG9zaXRpb24sWyJsb25nRWRnZSIsInNob3J0RWRnZSJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmVsYXRpb249Z2V0U3RyaW5nT3B0aW9uKGUucmVsYXRpb24sWyJvcmRlcmVkT2NjdXJyZW5jZSIsImR1cGxleFBhZ2luYXRlZCIsInNpbXBsZXhQYWdpbmF0ZWQiXSk7dGhpcy5yZWxldmFudD1nZXRSZWxldmFudChlLnJlbGV2YW50KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5leHRyYXM9bnVsbDt0aGlzLm9jY3VyPW51bGw7dGhpcy5wYWdlQXJlYT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5wYWdlU2V0PW5ldyBYRkFPYmplY3RBcnJheX1benNdKCl7Zm9yKGNvbnN0IGUgb2YgdGhpcy5wYWdlQXJlYS5jaGlsZHJlbillW3pzXSgpO2Zvcihjb25zdCBlIG9mIHRoaXMucGFnZVNldC5jaGlsZHJlbillW3pzXSgpfVtMcl0oKXtyZXR1cm4hdGhpcy5vY2N1cnx8LTE9PT10aGlzLm9jY3VyLm1heHx8dGhpc1thcl0ubnVtYmVyT2ZVc2U8dGhpcy5vY2N1ci5tYXh9W2RyXSgpe3RoaXNbYXJdfHwodGhpc1thcl09e251bWJlck9mVXNlOjEscGFnZUluZGV4Oi0xLHBhZ2VTZXRJbmRleDotMX0pO2lmKCJvcmRlcmVkT2NjdXJyZW5jZSI9PT10aGlzLnJlbGF0aW9uKXtpZih0aGlzW2FyXS5wYWdlSW5kZXgrMTx0aGlzLnBhZ2VBcmVhLmNoaWxkcmVuLmxlbmd0aCl7dGhpc1thcl0ucGFnZUluZGV4Kz0xO3JldHVybiB0aGlzLnBhZ2VBcmVhLmNoaWxkcmVuW3RoaXNbYXJdLnBhZ2VJbmRleF1bZHJdKCl9aWYodGhpc1thcl0ucGFnZVNldEluZGV4KzE8dGhpcy5wYWdlU2V0LmNoaWxkcmVuLmxlbmd0aCl7dGhpc1thcl0ucGFnZVNldEluZGV4Kz0xO3JldHVybiB0aGlzLnBhZ2VTZXQuY2hpbGRyZW5bdGhpc1thcl0ucGFnZVNldEluZGV4XVtkcl0oKX1pZih0aGlzW0xyXSgpKXt0aGlzW2FyXS5udW1iZXJPZlVzZSs9MTt0aGlzW2FyXS5wYWdlSW5kZXg9LTE7dGhpc1thcl0ucGFnZVNldEluZGV4PS0xO3JldHVybiB0aGlzW2RyXSgpfWNvbnN0IGU9dGhpc1twcl0oKTtpZihlIGluc3RhbmNlb2YgUGFnZVNldClyZXR1cm4gZVtkcl0oKTt0aGlzW3pzXSgpO3JldHVybiB0aGlzW2RyXSgpfWNvbnN0IGU9dGhpc1ttcl0oKVthcl0ucGFnZU51bWJlcix0PWUlMj09MD8iZXZlbiI6Im9kZCIsaT0wPT09ZT8iZmlyc3QiOiJyZXN0IjtsZXQgYT10aGlzLnBhZ2VBcmVhLmNoaWxkcmVuLmZpbmQoKGU9PmUub2RkT3JFdmVuPT09dCYmZS5wYWdlUG9zaXRpb249PT1pKSk7aWYoYSlyZXR1cm4gYTthPXRoaXMucGFnZUFyZWEuY2hpbGRyZW4uZmluZCgoZT0+ImFueSI9PT1lLm9kZE9yRXZlbiYmZS5wYWdlUG9zaXRpb249PT1pKSk7aWYoYSlyZXR1cm4gYTthPXRoaXMucGFnZUFyZWEuY2hpbGRyZW4uZmluZCgoZT0+ImFueSI9PT1lLm9kZE9yRXZlbiYmImFueSI9PT1lLnBhZ2VQb3NpdGlvbikpO3JldHVybiBhfHx0aGlzLnBhZ2VBcmVhLmNoaWxkcmVuWzBdfX1jbGFzcyBQYXJhIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJwYXJhIiwhMCk7dGhpcy5oQWxpZ249Z2V0U3RyaW5nT3B0aW9uKGUuaEFsaWduLFsibGVmdCIsImNlbnRlciIsImp1c3RpZnkiLCJqdXN0aWZ5QWxsIiwicmFkaXgiLCJyaWdodCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubGluZUhlaWdodD1lLmxpbmVIZWlnaHQ/Z2V0TWVhc3VyZW1lbnQoZS5saW5lSGVpZ2h0LCIwcHQiKToiIjt0aGlzLm1hcmdpbkxlZnQ9ZS5tYXJnaW5MZWZ0P2dldE1lYXN1cmVtZW50KGUubWFyZ2luTGVmdCwiMHB0Iik6IiI7dGhpcy5tYXJnaW5SaWdodD1lLm1hcmdpblJpZ2h0P2dldE1lYXN1cmVtZW50KGUubWFyZ2luUmlnaHQsIjBwdCIpOiIiO3RoaXMub3JwaGFucz1nZXRJbnRlZ2VyKHtkYXRhOmUub3JwaGFucyxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT5lPj0wfSk7dGhpcy5wcmVzZXJ2ZT1lLnByZXNlcnZlfHwiIjt0aGlzLnJhZGl4T2Zmc2V0PWUucmFkaXhPZmZzZXQ/Z2V0TWVhc3VyZW1lbnQoZS5yYWRpeE9mZnNldCwiMHB0Iik6IiI7dGhpcy5zcGFjZUFib3ZlPWUuc3BhY2VBYm92ZT9nZXRNZWFzdXJlbWVudChlLnNwYWNlQWJvdmUsIjBwdCIpOiIiO3RoaXMuc3BhY2VCZWxvdz1lLnNwYWNlQmVsb3c/Z2V0TWVhc3VyZW1lbnQoZS5zcGFjZUJlbG93LCIwcHQiKToiIjt0aGlzLnRhYkRlZmF1bHQ9ZS50YWJEZWZhdWx0P2dldE1lYXN1cmVtZW50KHRoaXMudGFiRGVmYXVsdCk6IiI7dGhpcy50YWJTdG9wcz0oZS50YWJTdG9wc3x8IiIpLnRyaW0oKS5zcGxpdCgvXHMrLykubWFwKCgoZSx0KT0+dCUyPT0xP2dldE1lYXN1cmVtZW50KGUpOmUpKTt0aGlzLnRleHRJbmRlbnQ9ZS50ZXh0SW5kZW50P2dldE1lYXN1cmVtZW50KGUudGV4dEluZGVudCwiMHB0Iik6IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMudkFsaWduPWdldFN0cmluZ09wdGlvbihlLnZBbGlnbixbInRvcCIsImJvdHRvbSIsIm1pZGRsZSJdKTt0aGlzLndpZG93cz1nZXRJbnRlZ2VyKHtkYXRhOmUud2lkb3dzLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PmU+PTB9KTt0aGlzLmh5cGhlbmF0aW9uPW51bGx9W3JuXSgpe2NvbnN0IGU9dG9TdHlsZSh0aGlzLCJoQWxpZ24iKTsiIiE9PXRoaXMubWFyZ2luTGVmdCYmKGUucGFkZGluZ0xlZnQ9bWVhc3VyZVRvU3RyaW5nKHRoaXMubWFyZ2luTGVmdCkpOyIiIT09dGhpcy5tYXJnaW5SaWdodCYmKGUucGFkZGluZ2lnaHQ9bWVhc3VyZVRvU3RyaW5nKHRoaXMubWFyZ2luUmlnaHQpKTsiIiE9PXRoaXMuc3BhY2VBYm92ZSYmKGUucGFkZGluZ1RvcD1tZWFzdXJlVG9TdHJpbmcodGhpcy5zcGFjZUFib3ZlKSk7IiIhPT10aGlzLnNwYWNlQmVsb3cmJihlLnBhZGRpbmdCb3R0b209bWVhc3VyZVRvU3RyaW5nKHRoaXMuc3BhY2VCZWxvdykpO2lmKCIiIT09dGhpcy50ZXh0SW5kZW50KXtlLnRleHRJbmRlbnQ9bWVhc3VyZVRvU3RyaW5nKHRoaXMudGV4dEluZGVudCk7Zml4VGV4dEluZGVudChlKX10aGlzLmxpbmVIZWlnaHQ+MCYmKGUubGluZUhlaWdodD1tZWFzdXJlVG9TdHJpbmcodGhpcy5saW5lSGVpZ2h0KSk7IiIhPT10aGlzLnRhYkRlZmF1bHQmJihlLnRhYlNpemU9bWVhc3VyZVRvU3RyaW5nKHRoaXMudGFiRGVmYXVsdCkpO3RoaXMudGFiU3RvcHMubGVuZ3RoO3RoaXMuaHlwaGVuYXRhdGlvbiYmT2JqZWN0LmFzc2lnbihlLHRoaXMuaHlwaGVuYXRhdGlvbltybl0oKSk7cmV0dXJuIGV9fWNsYXNzIFBhc3N3b3JkRWRpdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwicGFzc3dvcmRFZGl0IiwhMCk7dGhpcy5oU2Nyb2xsUG9saWN5PWdldFN0cmluZ09wdGlvbihlLmhTY3JvbGxQb2xpY3ksWyJhdXRvIiwib2ZmIiwib24iXSk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnBhc3N3b3JkQ2hhcj1lLnBhc3N3b3JkQ2hhcnx8IioiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmJvcmRlcj1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tYXJnaW49bnVsbH19Y2xhc3MgdGVtcGxhdGVfUGF0dGVybiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwicGF0dGVybiIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJjcm9zc0hhdGNoIiwiY3Jvc3NEaWFnb25hbCIsImRpYWdvbmFsTGVmdCIsImRpYWdvbmFsUmlnaHQiLCJob3Jpem9udGFsIiwidmVydGljYWwiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVtybl0oZSl7ZT1lP2Vbcm5dKCk6IiNGRkZGRkYiO2NvbnN0IHQ9dGhpcy5jb2xvcj90aGlzLmNvbG9yW3JuXSgpOiIjMDAwMDAwIixpPSJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50IixhPWAke2V9LCR7ZX0gNXB4LCR7dH0gNXB4LCR7dH0gMTBweGA7c3dpdGNoKHRoaXMudHlwZSl7Y2FzZSJjcm9zc0hhdGNoIjpyZXR1cm5gJHtpfSh0byB0b3AsJHthfSkgJHtpfSh0byByaWdodCwke2F9KWA7Y2FzZSJjcm9zc0RpYWdvbmFsIjpyZXR1cm5gJHtpfSg0NWRlZywke2F9KSAke2l9KC00NWRlZywke2F9KWA7Y2FzZSJkaWFnb25hbExlZnQiOnJldHVybmAke2l9KDQ1ZGVnLCR7YX0pYDtjYXNlImRpYWdvbmFsUmlnaHQiOnJldHVybmAke2l9KC00NWRlZywke2F9KWA7Y2FzZSJob3Jpem9udGFsIjpyZXR1cm5gJHtpfSh0byB0b3AsJHthfSlgO2Nhc2UidmVydGljYWwiOnJldHVybmAke2l9KHRvIHJpZ2h0LCR7YX0pYH1yZXR1cm4iIn19Y2xhc3MgUGljdHVyZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwicGljdHVyZSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBQcm90byBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwicHJvdG8iLCEwKTt0aGlzLmFwcGVhcmFuY2VGaWx0ZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYXJjPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmFyZWE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYXNzaXN0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmJhcmNvZGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYmluZEl0ZW1zPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmJvb2tlbmQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYm9vbGVhbj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5ib3JkZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYnJlYWs9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuYnJlYWtBZnRlcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5icmVha0JlZm9yZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5idXR0b249bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY2FsY3VsYXRlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmNhcHRpb249bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY2VydGlmaWNhdGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY2VydGlmaWNhdGVzPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmNoZWNrQnV0dG9uPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmNob2ljZUxpc3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY29sb3I9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuY29tYj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5jb25uZWN0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmNvbnRlbnRBcmVhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmNvcm5lcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kYXRlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGVUaW1lPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGVUaW1lRWRpdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kZWNpbWFsPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRlZmF1bHRVaT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kZXNjPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRpZ2VzdE1ldGhvZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5kaWdlc3RNZXRob2RzPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRyYXc9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZWRnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNvZGluZz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNvZGluZ3M9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZW5jcnlwdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNyeXB0RGF0YT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5lbmNyeXB0aW9uPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmVuY3J5cHRpb25NZXRob2Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZW5jcnlwdGlvbk1ldGhvZHM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXZlbnQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXhEYXRhPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4T2JqZWN0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4Y2xHcm91cD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5leGVjdXRlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmV4dHJhcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5maWVsZD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5maWxsPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZpbHRlcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5mbG9hdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5mb250PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmZvcm1hdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5oYW5kbGVyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmh5cGhlbmF0aW9uPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmltYWdlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmltYWdlRWRpdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5pbnRlZ2VyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmlzc3VlcnM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaXRlbXM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMua2VlcD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5rZXlVc2FnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5saW5lPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmxpbmVhcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5sb2NrRG9jdW1lbnQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMubWFuaWZlc3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMubWFyZ2luPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLm1kcD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5tZWRpdW09bmV3IFhGQU9iamVjdEFycmF5O3RoaXMubWVzc2FnZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5udW1lcmljRWRpdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5vY2N1cj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5vaWQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMub2lkcz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5vdmVyZmxvdz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5wYWdlQXJlYT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5wYWdlU2V0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnBhcmE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucGFzc3dvcmRFZGl0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnBhdHRlcm49bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucGljdHVyZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5yYWRpYWw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucmVhc29uPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnJlYXNvbnM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucmVjdGFuZ2xlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnJlZj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zY3JpcHQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc2V0UHJvcGVydHk9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc2lnbkRhdGE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc2lnbmF0dXJlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnNpZ25pbmc9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc29saWQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3BlYWs9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3RpcHBsZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm1TZXQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3ViamVjdEROPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmplY3RETnM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3VibWl0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRleHQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGV4dEVkaXQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGltZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50aW1lU3RhbXA9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudG9vbFRpcD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50cmF2ZXJzYWw9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudHJhdmVyc2U9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudWk9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudmFsaWRhdGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudmFsdWU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudmFyaWFibGVzPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgUmFkaWFsIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJyYWRpYWwiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsidG9FZGdlIiwidG9DZW50ZXIiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY29sb3I9bnVsbDt0aGlzLmV4dHJhcz1udWxsfVtybl0oZSl7ZT1lP2Vbcm5dKCk6IiNGRkZGRkYiO2NvbnN0IHQ9dGhpcy5jb2xvcj90aGlzLmNvbG9yW3JuXSgpOiIjMDAwMDAwIjtyZXR1cm5gcmFkaWFsLWdyYWRpZW50KGNpcmNsZSBhdCBjZW50ZXIsICR7InRvRWRnZSI9PT10aGlzLnR5cGU/YCR7ZX0sJHt0fWA6YCR7dH0sJHtlfWB9KWB9fWNsYXNzIFJlYXNvbiBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwicmVhc29uIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFJlYXNvbnMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sInJlYXNvbnMiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudHlwZT1nZXRTdHJpbmdPcHRpb24oZS50eXBlLFsib3B0aW9uYWwiLCJyZXF1aXJlZCJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5yZWFzb249bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sInJlY3RhbmdsZSIsITApO3RoaXMuaGFuZD1nZXRTdHJpbmdPcHRpb24oZS5oYW5kLFsiZXZlbiIsImxlZnQiLCJyaWdodCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmNvcm5lcj1uZXcgWEZBT2JqZWN0QXJyYXkoNCk7dGhpcy5lZGdlPW5ldyBYRkFPYmplY3RBcnJheSg0KTt0aGlzLmZpbGw9bnVsbH1bYW5dKCl7Y29uc3QgZT10aGlzLmVkZ2UuY2hpbGRyZW4ubGVuZ3RoP3RoaXMuZWRnZS5jaGlsZHJlblswXTpuZXcgRWRnZSh7fSksdD1lW3JuXSgpLGk9T2JqZWN0LmNyZWF0ZShudWxsKTsidmlzaWJsZSI9PT10aGlzLmZpbGw/LnByZXNlbmNlP09iamVjdC5hc3NpZ24oaSx0aGlzLmZpbGxbcm5dKCkpOmkuZmlsbD0idHJhbnNwYXJlbnQiO2kuc3Ryb2tlV2lkdGg9bWVhc3VyZVRvU3RyaW5nKCJ2aXNpYmxlIj09PWUucHJlc2VuY2U/ZS50aGlja25lc3M6MCk7aS5zdHJva2U9dC5jb2xvcjtjb25zdCBhPSh0aGlzLmNvcm5lci5jaGlsZHJlbi5sZW5ndGg/dGhpcy5jb3JuZXIuY2hpbGRyZW5bMF06bmV3IENvcm5lcih7fSkpW3JuXSgpLHM9e25hbWU6InN2ZyIsY2hpbGRyZW46W3tuYW1lOiJyZWN0IixhdHRyaWJ1dGVzOnt4bWxuczpKbix3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIix4OjAseTowLHJ4OmEucmFkaXVzLHJ5OmEucmFkaXVzLHN0eWxlOml9fV0sYXR0cmlidXRlczp7eG1sbnM6Sm4sc3R5bGU6e292ZXJmbG93OiJ2aXNpYmxlIn0sd2lkdGg6IjEwMCUiLGhlaWdodDoiMTAwJSJ9fTtpZihoYXNNYXJnaW4odGhpc1twcl0oKVtwcl0oKSkpcmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixhdHRyaWJ1dGVzOntzdHlsZTp7ZGlzcGxheToiaW5saW5lIix3aWR0aDoiMTAwJSIsaGVpZ2h0OiIxMDAlIn19LGNoaWxkcmVuOltzXX0pO3MuYXR0cmlidXRlcy5zdHlsZS5wb3NpdGlvbj0iYWJzb2x1dGUiO3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Mocyl9fWNsYXNzIFJlZkVsZW1lbnQgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sInJlZiIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBTY3JpcHQgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sInNjcmlwdCIpO3RoaXMuYmluZGluZz1lLmJpbmRpbmd8fCIiO3RoaXMuY29udGVudFR5cGU9ZS5jb250ZW50VHlwZXx8IiI7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnJ1bkF0PWdldFN0cmluZ09wdGlvbihlLnJ1bkF0LFsiY2xpZW50IiwiYm90aCIsInNlcnZlciJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFNldFByb3BlcnR5IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzZXRQcm9wZXJ0eSIpO3RoaXMuY29ubmVjdGlvbj1lLmNvbm5lY3Rpb258fCIiO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnRhcmdldD1lLnRhcmdldHx8IiJ9fWNsYXNzIFNpZ25EYXRhIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzaWduRGF0YSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vcGVyYXRpb249Z2V0U3RyaW5nT3B0aW9uKGUub3BlcmF0aW9uLFsic2lnbiIsImNsZWFyIiwidmVyaWZ5Il0pO3RoaXMucmVmPWUucmVmfHwiIjt0aGlzLnRhcmdldD1lLnRhcmdldHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuZmlsdGVyPW51bGw7dGhpcy5tYW5pZmVzdD1udWxsfX1jbGFzcyBTaWduYXR1cmUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sInNpZ25hdHVyZSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJQREYxLjMiLCJQREYxLjYiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9yZGVyPW51bGw7dGhpcy5leHRyYXM9bnVsbDt0aGlzLmZpbHRlcj1udWxsO3RoaXMubWFuaWZlc3Q9bnVsbDt0aGlzLm1hcmdpbj1udWxsfX1jbGFzcyBTaWduaW5nIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzaWduaW5nIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuY2VydGlmaWNhdGU9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBTb2xpZCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwic29saWQiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsfVtybl0oZSl7cmV0dXJuIGU/ZVtybl0oKToiI0ZGRkZGRiJ9fWNsYXNzIFNwZWFrIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzcGVhayIpO3RoaXMuZGlzYWJsZT1nZXRJbnRlZ2VyKHtkYXRhOmUuZGlzYWJsZSxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5wcmlvcml0eT1nZXRTdHJpbmdPcHRpb24oZS5wcmlvcml0eSxbImN1c3RvbSIsImNhcHRpb24iLCJuYW1lIiwidG9vbFRpcCJdKTt0aGlzLnJpZD1lLnJpZHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBTdGlwcGxlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzdGlwcGxlIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnJhdGU9Z2V0SW50ZWdlcih7ZGF0YTplLnJhdGUsZGVmYXVsdFZhbHVlOjUwLHZhbGlkYXRlOmU9PmU+PTAmJmU8PTEwMH0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmNvbG9yPW51bGw7dGhpcy5leHRyYXM9bnVsbH1bcm5dKGUpe2NvbnN0IHQ9dGhpcy5yYXRlLzEwMDtyZXR1cm4gVXRpbC5tYWtlSGV4Q29sb3IoTWF0aC5yb3VuZChlLnZhbHVlLnIqKDEtdCkrdGhpcy52YWx1ZS5yKnQpLE1hdGgucm91bmQoZS52YWx1ZS5nKigxLXQpK3RoaXMudmFsdWUuZyp0KSxNYXRoLnJvdW5kKGUudmFsdWUuYiooMS10KSt0aGlzLnZhbHVlLmIqdCkpfX1jbGFzcyBTdWJmb3JtIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzdWJmb3JtIiwhMCk7dGhpcy5hY2Nlc3M9Z2V0U3RyaW5nT3B0aW9uKGUuYWNjZXNzLFsib3BlbiIsIm5vbkludGVyYWN0aXZlIiwicHJvdGVjdGVkIiwicmVhZE9ubHkiXSk7dGhpcy5hbGxvd01hY3JvPWdldEludGVnZXIoe2RhdGE6ZS5hbGxvd01hY3JvLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5hbmNob3JUeXBlPWdldFN0cmluZ09wdGlvbihlLmFuY2hvclR5cGUsWyJ0b3BMZWZ0IiwiYm90dG9tQ2VudGVyIiwiYm90dG9tTGVmdCIsImJvdHRvbVJpZ2h0IiwibWlkZGxlQ2VudGVyIiwibWlkZGxlTGVmdCIsIm1pZGRsZVJpZ2h0IiwidG9wQ2VudGVyIiwidG9wUmlnaHQiXSk7dGhpcy5jb2xTcGFuPWdldEludGVnZXIoe2RhdGE6ZS5jb2xTcGFuLGRlZmF1bHRWYWx1ZToxLHZhbGlkYXRlOmU9PmU+PTF8fC0xPT09ZX0pO3RoaXMuY29sdW1uV2lkdGhzPShlLmNvbHVtbldpZHRoc3x8IiIpLnRyaW0oKS5zcGxpdCgvXHMrLykubWFwKChlPT4iLTEiPT09ZT8tMTpnZXRNZWFzdXJlbWVudChlKSkpO3RoaXMuaD1lLmg/Z2V0TWVhc3VyZW1lbnQoZS5oKToiIjt0aGlzLmhBbGlnbj1nZXRTdHJpbmdPcHRpb24oZS5oQWxpZ24sWyJsZWZ0IiwiY2VudGVyIiwianVzdGlmeSIsImp1c3RpZnlBbGwiLCJyYWRpeCIsInJpZ2h0Il0pO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5sYXlvdXQ9Z2V0U3RyaW5nT3B0aW9uKGUubGF5b3V0LFsicG9zaXRpb24iLCJsci10YiIsInJsLXJvdyIsInJsLXRiIiwicm93IiwidGFibGUiLCJ0YiJdKTt0aGlzLmxvY2FsZT1lLmxvY2FsZXx8IiI7dGhpcy5tYXhIPWdldE1lYXN1cmVtZW50KGUubWF4SCwiMHB0Iik7dGhpcy5tYXhXPWdldE1lYXN1cmVtZW50KGUubWF4VywiMHB0Iik7dGhpcy5tZXJnZU1vZGU9Z2V0U3RyaW5nT3B0aW9uKGUubWVyZ2VNb2RlLFsiY29uc3VtZURhdGEiLCJtYXRjaFRlbXBsYXRlIl0pO3RoaXMubWluSD1nZXRNZWFzdXJlbWVudChlLm1pbkgsIjBwdCIpO3RoaXMubWluVz1nZXRNZWFzdXJlbWVudChlLm1pblcsIjBwdCIpO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucHJlc2VuY2U9Z2V0U3RyaW5nT3B0aW9uKGUucHJlc2VuY2UsWyJ2aXNpYmxlIiwiaGlkZGVuIiwiaW5hY3RpdmUiLCJpbnZpc2libGUiXSk7dGhpcy5yZWxldmFudD1nZXRSZWxldmFudChlLnJlbGV2YW50KTt0aGlzLnJlc3RvcmVTdGF0ZT1nZXRTdHJpbmdPcHRpb24oZS5yZXN0b3JlU3RhdGUsWyJtYW51YWwiLCJhdXRvIl0pO3RoaXMuc2NvcGU9Z2V0U3RyaW5nT3B0aW9uKGUuc2NvcGUsWyJuYW1lIiwibm9uZSJdKTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy53PWUudz9nZXRNZWFzdXJlbWVudChlLncpOiIiO3RoaXMueD1nZXRNZWFzdXJlbWVudChlLngsIjBwdCIpO3RoaXMueT1nZXRNZWFzdXJlbWVudChlLnksIjBwdCIpO3RoaXMuYXNzaXN0PW51bGw7dGhpcy5iaW5kPW51bGw7dGhpcy5ib29rZW5kPW51bGw7dGhpcy5ib3JkZXI9bnVsbDt0aGlzLmJyZWFrPW51bGw7dGhpcy5jYWxjdWxhdGU9bnVsbDt0aGlzLmRlc2M9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMua2VlcD1udWxsO3RoaXMubWFyZ2luPW51bGw7dGhpcy5vY2N1cj1udWxsO3RoaXMub3ZlcmZsb3c9bnVsbDt0aGlzLnBhZ2VTZXQ9bnVsbDt0aGlzLnBhcmE9bnVsbDt0aGlzLnRyYXZlcnNhbD1udWxsO3RoaXMudmFsaWRhdGU9bnVsbDt0aGlzLnZhcmlhYmxlcz1udWxsO3RoaXMuYXJlYT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5icmVha0FmdGVyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmJyZWFrQmVmb3JlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmNvbm5lY3Q9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZHJhdz1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5ldmVudD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5leE9iamVjdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5leGNsR3JvdXA9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZmllbGQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucHJvdG89bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc2V0UHJvcGVydHk9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3ViZm9ybT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zdWJmb3JtU2V0PW5ldyBYRkFPYmplY3RBcnJheX1bZnJdKCl7Y29uc3QgZT10aGlzW3ByXSgpO3JldHVybiBlIGluc3RhbmNlb2YgU3ViZm9ybVNldD9lW2ZyXSgpOmV9W2tyXSgpe3JldHVybiEwfVtVcl0oKXtyZXR1cm4gdGhpcy5sYXlvdXQuZW5kc1dpdGgoIi10YiIpJiYwPT09dGhpc1thcl0uYXR0ZW1wdCYmdGhpc1thcl0ubnVtYmVySW5MaW5lPjB8fHRoaXNbcHJdKClbVXJdKCl9Klt1cl0oKXt5aWVsZCpnZXRDb250YWluZWRDaGlsZHJlbih0aGlzKX1bcnJdKCl7cmV0dXJuIGZsdXNoSFRNTCh0aGlzKX1banNdKGUsdCl7YWRkSFRNTCh0aGlzLGUsdCl9W2dyXSgpe3JldHVybiBnZXRBdmFpbGFibGVTcGFjZSh0aGlzKX1beHJdKCl7Y29uc3QgZT10aGlzW2ZyXSgpO2lmKCFlW3hyXSgpKXJldHVybiExO2lmKHZvaWQgMCE9PXRoaXNbYXJdLl9pc1NwbGl0dGFibGUpcmV0dXJuIHRoaXNbYXJdLl9pc1NwbGl0dGFibGU7aWYoInBvc2l0aW9uIj09PXRoaXMubGF5b3V0fHx0aGlzLmxheW91dC5pbmNsdWRlcygicm93Iikpe3RoaXNbYXJdLl9pc1NwbGl0dGFibGU9ITE7cmV0dXJuITF9aWYodGhpcy5rZWVwJiYibm9uZSIhPT10aGlzLmtlZXAuaW50YWN0KXt0aGlzW2FyXS5faXNTcGxpdHRhYmxlPSExO3JldHVybiExfWlmKGUubGF5b3V0Py5lbmRzV2l0aCgiLXRiIikmJjAhPT1lW2FyXS5udW1iZXJJbkxpbmUpcmV0dXJuITE7dGhpc1thcl0uX2lzU3BsaXR0YWJsZT0hMDtyZXR1cm4hMH1bYW5dKGUpe3NldFRhYkluZGV4KHRoaXMpO2lmKHRoaXMuYnJlYWspe2lmKCJhdXRvIiE9PXRoaXMuYnJlYWsuYWZ0ZXJ8fCIiIT09dGhpcy5icmVhay5hZnRlclRhcmdldCl7Y29uc3QgZT1uZXcgQnJlYWtBZnRlcih7dGFyZ2V0VHlwZTp0aGlzLmJyZWFrLmFmdGVyLHRhcmdldDp0aGlzLmJyZWFrLmFmdGVyVGFyZ2V0LHN0YXJ0TmV3OnRoaXMuYnJlYWsuc3RhcnROZXcudG9TdHJpbmcoKX0pO2VbeXJdPXRoaXNbeXJdO3RoaXNbWHNdKGUpO3RoaXMuYnJlYWtBZnRlci5wdXNoKGUpfWlmKCJhdXRvIiE9PXRoaXMuYnJlYWsuYmVmb3JlfHwiIiE9PXRoaXMuYnJlYWsuYmVmb3JlVGFyZ2V0KXtjb25zdCBlPW5ldyBCcmVha0JlZm9yZSh7dGFyZ2V0VHlwZTp0aGlzLmJyZWFrLmJlZm9yZSx0YXJnZXQ6dGhpcy5icmVhay5iZWZvcmVUYXJnZXQsc3RhcnROZXc6dGhpcy5icmVhay5zdGFydE5ldy50b1N0cmluZygpfSk7ZVt5cl09dGhpc1t5cl07dGhpc1tYc10oZSk7dGhpcy5icmVha0JlZm9yZS5wdXNoKGUpfWlmKCIiIT09dGhpcy5icmVhay5vdmVyZmxvd1RhcmdldCl7Y29uc3QgZT1uZXcgT3ZlcmZsb3coe3RhcmdldDp0aGlzLmJyZWFrLm92ZXJmbG93VGFyZ2V0LGxlYWRlcjp0aGlzLmJyZWFrLm92ZXJmbG93TGVhZGVyLHRyYWlsZXI6dGhpcy5icmVhay5vdmVyZmxvd1RyYWlsZXJ9KTtlW3lyXT10aGlzW3lyXTt0aGlzW1hzXShlKTt0aGlzLm92ZXJmbG93LnB1c2goZSl9dGhpc1tqcl0odGhpcy5icmVhayk7dGhpcy5icmVhaz1udWxsfWlmKCJoaWRkZW4iPT09dGhpcy5wcmVzZW5jZXx8ImluYWN0aXZlIj09PXRoaXMucHJlc2VuY2UpcmV0dXJuIEhUTUxSZXN1bHQuRU1QVFk7KHRoaXMuYnJlYWtCZWZvcmUuY2hpbGRyZW4ubGVuZ3RoPjF8fHRoaXMuYnJlYWtBZnRlci5jaGlsZHJlbi5sZW5ndGg+MSkmJndhcm4oIlhGQSAtIFNldmVyYWwgYnJlYWtCZWZvcmUgb3IgYnJlYWtBZnRlciBpbiBzdWJmb3JtczogcGxlYXNlIGZpbGUgYSBidWcuIik7aWYodGhpcy5icmVha0JlZm9yZS5jaGlsZHJlbi5sZW5ndGg+PTEpe2NvbnN0IGU9dGhpcy5icmVha0JlZm9yZS5jaGlsZHJlblswXTtpZihoYW5kbGVCcmVhayhlKSlyZXR1cm4gSFRNTFJlc3VsdC5icmVha05vZGUoZSl9aWYodGhpc1thcl0/LmFmdGVyQnJlYWtBZnRlcilyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTtmaXhEaW1lbnNpb25zKHRoaXMpO2NvbnN0IHQ9W10saT17aWQ6dGhpc1tubl0sY2xhc3M6W119O3NldEFjY2Vzcyh0aGlzLGkuY2xhc3MpO3RoaXNbYXJdfHwodGhpc1thcl09T2JqZWN0LmNyZWF0ZShudWxsKSk7T2JqZWN0LmFzc2lnbih0aGlzW2FyXSx7Y2hpbGRyZW46dCxsaW5lOm51bGwsYXR0cmlidXRlczppLGF0dGVtcHQ6MCxudW1iZXJJbkxpbmU6MCxhdmFpbGFibGVTcGFjZTp7d2lkdGg6TWF0aC5taW4odGhpcy53fHwxLzAsZS53aWR0aCksaGVpZ2h0Ok1hdGgubWluKHRoaXMuaHx8MS8wLGUuaGVpZ2h0KX0sd2lkdGg6MCxoZWlnaHQ6MCxwcmV2SGVpZ2h0OjAsY3VycmVudFdpZHRoOjB9KTtjb25zdCBhPXRoaXNbbXJdKCkscz1hW2FyXS5ub0xheW91dEZhaWx1cmUscj10aGlzW3hyXSgpO3J8fHNldEZpcnN0VW5zcGxpdHRhYmxlKHRoaXMpO2lmKCFjaGVja0RpbWVuc2lvbnModGhpcyxlKSlyZXR1cm4gSFRNTFJlc3VsdC5GQUlMVVJFO2NvbnN0IG49bmV3IFNldChbImFyZWEiLCJkcmF3IiwiZXhjbEdyb3VwIiwiZmllbGQiLCJzdWJmb3JtIiwic3ViZm9ybVNldCJdKTtpZih0aGlzLmxheW91dC5pbmNsdWRlcygicm93Iikpe2NvbnN0IGU9dGhpc1tmcl0oKS5jb2x1bW5XaWR0aHM7aWYoQXJyYXkuaXNBcnJheShlKSYmZS5sZW5ndGg+MCl7dGhpc1thcl0uY29sdW1uV2lkdGhzPWU7dGhpc1thcl0uY3VycmVudENvbHVtbj0wfX1jb25zdCBvPXRvU3R5bGUodGhpcywiYW5jaG9yVHlwZSIsImRpbWVuc2lvbnMiLCJwb3NpdGlvbiIsInByZXNlbmNlIiwiYm9yZGVyIiwibWFyZ2luIiwiaEFsaWduIiksZz1bInhmYVN1YmZvcm0iXSxjPWxheW91dENsYXNzKHRoaXMpO2MmJmcucHVzaChjKTtpLnN0eWxlPW87aS5jbGFzcz1nO3RoaXMubmFtZSYmKGkueGZhTmFtZT10aGlzLm5hbWUpO2lmKHRoaXMub3ZlcmZsb3cpe2NvbnN0IHQ9dGhpcy5vdmVyZmxvd1tscl0oKTtpZih0LmFkZExlYWRlcil7dC5hZGRMZWFkZXI9ITE7aGFuZGxlT3ZlcmZsb3codGhpcyx0LmxlYWRlcixlKX19dGhpc1tXcl0oKTtjb25zdCBDPSJsci10YiI9PT10aGlzLmxheW91dHx8InJsLXRiIj09PXRoaXMubGF5b3V0LGg9Qz8yOjE7Zm9yKDt0aGlzW2FyXS5hdHRlbXB0PGg7dGhpc1thcl0uYXR0ZW1wdCsrKXtDJiYxPT09dGhpc1thcl0uYXR0ZW1wdCYmKHRoaXNbYXJdLm51bWJlckluTGluZT0wKTtjb25zdCBlPXRoaXNbWnNdKHtmaWx0ZXI6bixpbmNsdWRlOiEwfSk7aWYoZS5zdWNjZXNzKWJyZWFrO2lmKGUuaXNCcmVhaygpKXt0aGlzW1ByXSgpO3JldHVybiBlfWlmKEMmJjA9PT10aGlzW2FyXS5hdHRlbXB0JiYwPT09dGhpc1thcl0ubnVtYmVySW5MaW5lJiYhYVthcl0ubm9MYXlvdXRGYWlsdXJlKXt0aGlzW2FyXS5hdHRlbXB0PWg7YnJlYWt9fXRoaXNbUHJdKCk7cnx8dW5zZXRGaXJzdFVuc3BsaXR0YWJsZSh0aGlzKTthW2FyXS5ub0xheW91dEZhaWx1cmU9cztpZih0aGlzW2FyXS5hdHRlbXB0PT09aCl7dGhpcy5vdmVyZmxvdyYmKHRoaXNbbXJdKClbYXJdLm92ZXJmbG93Tm9kZT10aGlzLm92ZXJmbG93KTtyfHxkZWxldGUgdGhpc1thcl07cmV0dXJuIEhUTUxSZXN1bHQuRkFJTFVSRX1pZih0aGlzLm92ZXJmbG93KXtjb25zdCB0PXRoaXMub3ZlcmZsb3dbbHJdKCk7aWYodC5hZGRUcmFpbGVyKXt0LmFkZFRyYWlsZXI9ITE7aGFuZGxlT3ZlcmZsb3codGhpcyx0LnRyYWlsZXIsZSl9fWxldCBsPTAsUT0wO2lmKHRoaXMubWFyZ2luKXtsPXRoaXMubWFyZ2luLmxlZnRJbnNldCt0aGlzLm1hcmdpbi5yaWdodEluc2V0O1E9dGhpcy5tYXJnaW4udG9wSW5zZXQrdGhpcy5tYXJnaW4uYm90dG9tSW5zZXR9Y29uc3QgRT1NYXRoLm1heCh0aGlzW2FyXS53aWR0aCtsLHRoaXMud3x8MCksdT1NYXRoLm1heCh0aGlzW2FyXS5oZWlnaHQrUSx0aGlzLmh8fDApLGQ9W3RoaXMueCx0aGlzLnksRSx1XTsiIj09PXRoaXMudyYmKG8ud2lkdGg9bWVhc3VyZVRvU3RyaW5nKEUpKTsiIj09PXRoaXMuaCYmKG8uaGVpZ2h0PW1lYXN1cmVUb1N0cmluZyh1KSk7aWYoKCIwcHgiPT09by53aWR0aHx8IjBweCI9PT1vLmhlaWdodCkmJjA9PT10Lmxlbmd0aClyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTtjb25zdCBmPXtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6aSxjaGlsZHJlbjp0fTthcHBseUFzc2lzdCh0aGlzLGkpO2NvbnN0IHA9SFRNTFJlc3VsdC5zdWNjZXNzKGNyZWF0ZVdyYXBwZXIodGhpcyxmKSxkKTtpZih0aGlzLmJyZWFrQWZ0ZXIuY2hpbGRyZW4ubGVuZ3RoPj0xKXtjb25zdCBlPXRoaXMuYnJlYWtBZnRlci5jaGlsZHJlblswXTtpZihoYW5kbGVCcmVhayhlKSl7dGhpc1thcl0uYWZ0ZXJCcmVha0FmdGVyPXA7cmV0dXJuIEhUTUxSZXN1bHQuYnJlYWtOb2RlKGUpfX1kZWxldGUgdGhpc1thcl07cmV0dXJuIHB9fWNsYXNzIFN1YmZvcm1TZXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sInN1YmZvcm1TZXQiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmVsYXRpb249Z2V0U3RyaW5nT3B0aW9uKGUucmVsYXRpb24sWyJvcmRlcmVkIiwiY2hvaWNlIiwidW5vcmRlcmVkIl0pO3RoaXMucmVsZXZhbnQ9Z2V0UmVsZXZhbnQoZS5yZWxldmFudCk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuYm9va2VuZD1udWxsO3RoaXMuYnJlYWs9bnVsbDt0aGlzLmRlc2M9bnVsbDt0aGlzLmV4dHJhcz1udWxsO3RoaXMub2NjdXI9bnVsbDt0aGlzLm92ZXJmbG93PW51bGw7dGhpcy5icmVha0FmdGVyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmJyZWFrQmVmb3JlPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnN1YmZvcm09bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3ViZm9ybVNldD1uZXcgWEZBT2JqZWN0QXJyYXl9Klt1cl0oKXt5aWVsZCpnZXRDb250YWluZWRDaGlsZHJlbih0aGlzKX1bZnJdKCl7bGV0IGU9dGhpc1twcl0oKTtmb3IoOyEoZSBpbnN0YW5jZW9mIFN1YmZvcm0pOyllPWVbcHJdKCk7cmV0dXJuIGV9W2tyXSgpe3JldHVybiEwfX1jbGFzcyBTdWJqZWN0RE4gZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzdWJqZWN0RE4iKTt0aGlzLmRlbGltaXRlcj1lLmRlbGltaXRlcnx8IiwiO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtzcl0oKXt0aGlzW2VyXT1uZXcgTWFwKHRoaXNbZXJdLnNwbGl0KHRoaXMuZGVsaW1pdGVyKS5tYXAoKGU9PnsoZT1lLnNwbGl0KCI9IiwyKSlbMF09ZVswXS50cmltKCk7cmV0dXJuIGV9KSkpfX1jbGFzcyBTdWJqZWN0RE5zIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzdWJqZWN0RE5zIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnR5cGU9Z2V0U3RyaW5nT3B0aW9uKGUudHlwZSxbIm9wdGlvbmFsIiwicmVxdWlyZWQiXSk7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIiO3RoaXMuc3ViamVjdEROPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgU3VibWl0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJzdWJtaXQiLCEwKTt0aGlzLmVtYmVkUERGPWdldEludGVnZXIoe2RhdGE6ZS5lbWJlZFBERixkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT4xPT09ZX0pO3RoaXMuZm9ybWF0PWdldFN0cmluZ09wdGlvbihlLmZvcm1hdCxbInhkcCIsImZvcm1kYXRhIiwicGRmIiwidXJsZW5jb2RlZCIsInhmZCIsInhtbCJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudGFyZ2V0PWUudGFyZ2V0fHwiIjt0aGlzLnRleHRFbmNvZGluZz1nZXRLZXl3b3JkKHtkYXRhOmUudGV4dEVuY29kaW5nP2UudGV4dEVuY29kaW5nLnRvTG93ZXJDYXNlKCk6IiIsZGVmYXVsdFZhbHVlOiIiLHZhbGlkYXRlOmU9PlsidXRmLTgiLCJiaWctZml2ZSIsImZvbnRzcGVjaWZpYyIsImdiayIsImdiLTE4MDMwIiwiZ2ItMjMxMiIsImtzYy01NjAxIiwibm9uZSIsInNoaWZ0LWppcyIsInVjcy0yIiwidXRmLTE2Il0uaW5jbHVkZXMoZSl8fGUubWF0Y2goL2lzby04ODU5LVxkezJ9Lyl9KTt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy54ZHBDb250ZW50PWUueGRwQ29udGVudHx8IiI7dGhpcy5lbmNyeXB0PW51bGw7dGhpcy5lbmNyeXB0RGF0YT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zaWduRGF0YT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIFRlbXBsYXRlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJ0ZW1wbGF0ZSIsITApO3RoaXMuYmFzZVByb2ZpbGU9Z2V0U3RyaW5nT3B0aW9uKGUuYmFzZVByb2ZpbGUsWyJmdWxsIiwiaW50ZXJhY3RpdmVGb3JtcyJdKTt0aGlzLmV4dHJhcz1udWxsO3RoaXMuc3ViZm9ybT1uZXcgWEZBT2JqZWN0QXJyYXl9W3NyXSgpezA9PT10aGlzLnN1YmZvcm0uY2hpbGRyZW4ubGVuZ3RoJiZ3YXJuKCJYRkEgLSBObyBzdWJmb3JtcyBpbiB0ZW1wbGF0ZSBub2RlLiIpO3RoaXMuc3ViZm9ybS5jaGlsZHJlbi5sZW5ndGg+PTImJndhcm4oIlhGQSAtIFNldmVyYWwgc3ViZm9ybXMgaW4gdGVtcGxhdGUgbm9kZTogcGxlYXNlIGZpbGUgYSBidWcuIik7dGhpc1tBbl09NWUzfVt4cl0oKXtyZXR1cm4hMH1bVnJdKGUsdCl7cmV0dXJuIGUuc3RhcnRzV2l0aCgiIyIpP1t0aGlzW2JyXS5nZXQoZS5zbGljZSgxKSldOnNlYXJjaE5vZGUodGhpcyx0LGUsITAsITApfSpbdG5dKCl7aWYoIXRoaXMuc3ViZm9ybS5jaGlsZHJlbi5sZW5ndGgpcmV0dXJuIEhUTUxSZXN1bHQuc3VjY2Vzcyh7bmFtZToiZGl2IixjaGlsZHJlbjpbXX0pO3RoaXNbYXJdPXtvdmVyZmxvd05vZGU6bnVsbCxmaXJzdFVuc3BsaXR0YWJsZTpudWxsLGN1cnJlbnRDb250ZW50QXJlYTpudWxsLGN1cnJlbnRQYWdlQXJlYTpudWxsLG5vTGF5b3V0RmFpbHVyZTohMSxwYWdlTnVtYmVyOjEscGFnZVBvc2l0aW9uOiJmaXJzdCIsb2RkT3JFdmVuOiJvZGQiLGJsYW5rT3JOb3RCbGFuazoibm9uQmxhbmsiLHBhcmFTdGFjazpbXX07Y29uc3QgZT10aGlzLnN1YmZvcm0uY2hpbGRyZW5bMF07ZS5wYWdlU2V0W3pzXSgpO2NvbnN0IHQ9ZS5wYWdlU2V0LnBhZ2VBcmVhLmNoaWxkcmVuLGk9e25hbWU6ImRpdiIsY2hpbGRyZW46W119O2xldCBhPW51bGwscz1udWxsLHI9bnVsbDtpZihlLmJyZWFrQmVmb3JlLmNoaWxkcmVuLmxlbmd0aD49MSl7cz1lLmJyZWFrQmVmb3JlLmNoaWxkcmVuWzBdO3I9cy50YXJnZXR9ZWxzZSBpZihlLnN1YmZvcm0uY2hpbGRyZW4ubGVuZ3RoPj0xJiZlLnN1YmZvcm0uY2hpbGRyZW5bMF0uYnJlYWtCZWZvcmUuY2hpbGRyZW4ubGVuZ3RoPj0xKXtzPWUuc3ViZm9ybS5jaGlsZHJlblswXS5icmVha0JlZm9yZS5jaGlsZHJlblswXTtyPXMudGFyZ2V0fWVsc2UgaWYoZS5icmVhaz8uYmVmb3JlVGFyZ2V0KXtzPWUuYnJlYWs7cj1zLmJlZm9yZVRhcmdldH1lbHNlIGlmKGUuc3ViZm9ybS5jaGlsZHJlbi5sZW5ndGg+PTEmJmUuc3ViZm9ybS5jaGlsZHJlblswXS5icmVhaz8uYmVmb3JlVGFyZ2V0KXtzPWUuc3ViZm9ybS5jaGlsZHJlblswXS5icmVhaztyPXMuYmVmb3JlVGFyZ2V0fWlmKHMpe2NvbnN0IGU9dGhpc1tWcl0ocixzW3ByXSgpKTtpZihlIGluc3RhbmNlb2YgUGFnZUFyZWEpe2E9ZTtzW2FyXT17fX19YXx8KGE9dFswXSk7YVthcl09e251bWJlck9mVXNlOjF9O2NvbnN0IG49YVtwcl0oKTtuW2FyXT17bnVtYmVyT2ZVc2U6MSxwYWdlSW5kZXg6bi5wYWdlQXJlYS5jaGlsZHJlbi5pbmRleE9mKGEpLHBhZ2VTZXRJbmRleDowfTtsZXQgbyxnPW51bGwsYz1udWxsLEM9ITAsaD0wLGw9MDtmb3IoOzspe2lmKEMpaD0wO2Vsc2V7aS5jaGlsZHJlbi5wb3AoKTtpZigzPT0rK2gpe3dhcm4oIlhGQSAtIFNvbWV0aGluZyBnb2VzIHdyb25nOiBwbGVhc2UgZmlsZSBhIGJ1Zy4iKTtyZXR1cm4gaX19bz1udWxsO3RoaXNbYXJdLmN1cnJlbnRQYWdlQXJlYT1hO2NvbnN0IHQ9YVthbl0oKS5odG1sO2kuY2hpbGRyZW4ucHVzaCh0KTtpZihnKXt0aGlzW2FyXS5ub0xheW91dEZhaWx1cmU9ITA7dC5jaGlsZHJlbi5wdXNoKGdbYW5dKGFbYXJdLnNwYWNlKS5odG1sKTtnPW51bGx9aWYoYyl7dGhpc1thcl0ubm9MYXlvdXRGYWlsdXJlPSEwO3QuY2hpbGRyZW4ucHVzaChjW2FuXShhW2FyXS5zcGFjZSkuaHRtbCk7Yz1udWxsfWNvbnN0IHM9YS5jb250ZW50QXJlYS5jaGlsZHJlbixyPXQuY2hpbGRyZW4uZmlsdGVyKChlPT5lLmF0dHJpYnV0ZXMuY2xhc3MuaW5jbHVkZXMoInhmYUNvbnRlbnRhcmVhIikpKTtDPSExO3RoaXNbYXJdLmZpcnN0VW5zcGxpdHRhYmxlPW51bGw7dGhpc1thcl0ubm9MYXlvdXRGYWlsdXJlPSExO2NvbnN0IGZsdXNoPXQ9Pntjb25zdCBpPWVbcnJdKCk7aWYoaSl7Q3x8PWkuY2hpbGRyZW4/Lmxlbmd0aD4wO3JbdF0uY2hpbGRyZW4ucHVzaChpKX19O2ZvcihsZXQgdD1sLGE9cy5sZW5ndGg7dDxhO3QrKyl7Y29uc3QgYT10aGlzW2FyXS5jdXJyZW50Q29udGVudEFyZWE9c1t0XSxuPXt3aWR0aDphLncsaGVpZ2h0OmEuaH07bD0wO2lmKGcpe3JbdF0uY2hpbGRyZW4ucHVzaChnW2FuXShuKS5odG1sKTtnPW51bGx9aWYoYyl7clt0XS5jaGlsZHJlbi5wdXNoKGNbYW5dKG4pLmh0bWwpO2M9bnVsbH1jb25zdCBoPWVbYW5dKG4pO2lmKGguc3VjY2Vzcyl7aWYoaC5odG1sKXtDfHw9aC5odG1sLmNoaWxkcmVuPy5sZW5ndGg+MDtyW3RdLmNoaWxkcmVuLnB1c2goaC5odG1sKX1lbHNlIUMmJmkuY2hpbGRyZW4ubGVuZ3RoPjEmJmkuY2hpbGRyZW4ucG9wKCk7cmV0dXJuIGl9aWYoaC5pc0JyZWFrKCkpe2NvbnN0IGU9aC5icmVha05vZGU7Zmx1c2godCk7aWYoImF1dG8iPT09ZS50YXJnZXRUeXBlKWNvbnRpbnVlO2lmKGUubGVhZGVyKXtnPXRoaXNbVnJdKGUubGVhZGVyLGVbcHJdKCkpO2c9Zz9nWzBdOm51bGx9aWYoZS50cmFpbGVyKXtjPXRoaXNbVnJdKGUudHJhaWxlcixlW3ByXSgpKTtjPWM/Y1swXTpudWxsfWlmKCJwYWdlQXJlYSI9PT1lLnRhcmdldFR5cGUpe289ZVthcl0udGFyZ2V0O3Q9MS8wfWVsc2UgaWYoZVthcl0udGFyZ2V0KXtvPWVbYXJdLnRhcmdldDtsPWVbYXJdLmluZGV4KzE7dD0xLzB9ZWxzZSB0PWVbYXJdLmluZGV4fWVsc2UgaWYodGhpc1thcl0ub3ZlcmZsb3dOb2RlKXtjb25zdCBlPXRoaXNbYXJdLm92ZXJmbG93Tm9kZTt0aGlzW2FyXS5vdmVyZmxvd05vZGU9bnVsbDtjb25zdCBpPWVbbHJdKCksYT1pLnRhcmdldDtpLmFkZExlYWRlcj1udWxsIT09aS5sZWFkZXI7aS5hZGRUcmFpbGVyPW51bGwhPT1pLnRyYWlsZXI7Zmx1c2godCk7Y29uc3Qgcj10O3Q9MS8wO2lmKGEgaW5zdGFuY2VvZiBQYWdlQXJlYSlvPWE7ZWxzZSBpZihhIGluc3RhbmNlb2YgQ29udGVudEFyZWEpe2NvbnN0IGU9cy5pbmRleE9mKGEpO2lmKC0xIT09ZSllPnI/dD1lLTE6bD1lO2Vsc2V7bz1hW3ByXSgpO2w9by5jb250ZW50QXJlYS5jaGlsZHJlbi5pbmRleE9mKGEpfX19ZWxzZSBmbHVzaCh0KX10aGlzW2FyXS5wYWdlTnVtYmVyKz0xO28mJihvW0xyXSgpP29bYXJdLm51bWJlck9mVXNlKz0xOm89bnVsbCk7YT1vfHxhW2RyXSgpO3lpZWxkIG51bGx9fX1jbGFzcyBUZXh0IGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwidGV4dCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5tYXhDaGFycz1nZXRJbnRlZ2VyKHtkYXRhOmUubWF4Q2hhcnMsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+ZT49MH0pO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMucmlkPWUucmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9W1dzXSgpe3JldHVybiEwfVtLcl0oZSl7aWYoZVtKcl09PT1nbi54aHRtbC5pZCl7dGhpc1tlcl09ZTtyZXR1cm4hMH13YXJuKGBYRkEgLSBJbnZhbGlkIGNvbnRlbnQgaW4gVGV4dDogJHtlW1lyXX0uYCk7cmV0dXJuITF9W3FyXShlKXt0aGlzW2VyXWluc3RhbmNlb2YgWEZBT2JqZWN0fHxzdXBlcltxcl0oZSl9W3NyXSgpeyJzdHJpbmciPT10eXBlb2YgdGhpc1tlcl0mJih0aGlzW2VyXT10aGlzW2VyXS5yZXBsYWNlQWxsKCJcclxuIiwiXG4iKSl9W2xyXSgpe3JldHVybiJzdHJpbmciPT10eXBlb2YgdGhpc1tlcl0/dGhpc1tlcl0uc3BsaXQoL1tcdTIwMjlcdTIwMjhcbl0vKS5yZWR1Y2UoKChlLHQpPT57dCYmZS5wdXNoKHQpO3JldHVybiBlfSksW10pLmpvaW4oIlxuIik6dGhpc1tlcl1bZW5dKCl9W2FuXShlKXtpZigic3RyaW5nIj09dHlwZW9mIHRoaXNbZXJdKXtjb25zdCBlPXZhbHVlVG9IdG1sKHRoaXNbZXJdKS5odG1sO2lmKHRoaXNbZXJdLmluY2x1ZGVzKCJcdTIwMjkiKSl7ZS5uYW1lPSJkaXYiO2UuY2hpbGRyZW49W107dGhpc1tlcl0uc3BsaXQoIlx1MjAyOSIpLm1hcCgoZT0+ZS5zcGxpdCgvW1x1MjAyOFxuXS8pLnJlZHVjZSgoKGUsdCk9PntlLnB1c2goe25hbWU6InNwYW4iLHZhbHVlOnR9LHtuYW1lOiJiciJ9KTtyZXR1cm4gZX0pLFtdKSkpLmZvckVhY2goKHQ9PntlLmNoaWxkcmVuLnB1c2goe25hbWU6InAiLGNoaWxkcmVuOnR9KX0pKX1lbHNlIGlmKC9bXHUyMDI4XG5dLy50ZXN0KHRoaXNbZXJdKSl7ZS5uYW1lPSJkaXYiO2UuY2hpbGRyZW49W107dGhpc1tlcl0uc3BsaXQoL1tcdTIwMjhcbl0vKS5mb3JFYWNoKCh0PT57ZS5jaGlsZHJlbi5wdXNoKHtuYW1lOiJzcGFuIix2YWx1ZTp0fSx7bmFtZToiYnIifSl9KSl9cmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhlKX1yZXR1cm4gdGhpc1tlcl1bYW5dKGUpfX1jbGFzcyBUZXh0RWRpdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwidGV4dEVkaXQiLCEwKTt0aGlzLmFsbG93UmljaFRleHQ9Z2V0SW50ZWdlcih7ZGF0YTplLmFsbG93UmljaFRleHQsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLmhTY3JvbGxQb2xpY3k9Z2V0U3RyaW5nT3B0aW9uKGUuaFNjcm9sbFBvbGljeSxbImF1dG8iLCJvZmYiLCJvbiJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubXVsdGlMaW5lPWdldEludGVnZXIoe2RhdGE6ZS5tdWx0aUxpbmUsZGVmYXVsdFZhbHVlOiIiLHZhbGlkYXRlOmU9PjA9PT1lfHwxPT09ZX0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLnZTY3JvbGxQb2xpY3k9Z2V0U3RyaW5nT3B0aW9uKGUudlNjcm9sbFBvbGljeSxbImF1dG8iLCJvZmYiLCJvbiJdKTt0aGlzLmJvcmRlcj1udWxsO3RoaXMuY29tYj1udWxsO3RoaXMuZXh0cmFzPW51bGw7dGhpcy5tYXJnaW49bnVsbH1bYW5dKGUpe2NvbnN0IHQ9dG9TdHlsZSh0aGlzLCJib3JkZXIiLCJmb250IiwibWFyZ2luIik7bGV0IGk7Y29uc3QgYT10aGlzW3ByXSgpW3ByXSgpOyIiPT09dGhpcy5tdWx0aUxpbmUmJih0aGlzLm11bHRpTGluZT1hIGluc3RhbmNlb2YgRHJhdz8xOjApO2k9MT09PXRoaXMubXVsdGlMaW5lP3tuYW1lOiJ0ZXh0YXJlYSIsYXR0cmlidXRlczp7ZGF0YUlkOmFbdHJdPy5bbm5dfHxhW25uXSxmaWVsZElkOmFbbm5dLGNsYXNzOlsieGZhVGV4dGZpZWxkIl0sc3R5bGU6dCwiYXJpYS1sYWJlbCI6YXJpYUxhYmVsKGEpLCJhcmlhLXJlcXVpcmVkIjohMX19OntuYW1lOiJpbnB1dCIsYXR0cmlidXRlczp7dHlwZToidGV4dCIsZGF0YUlkOmFbdHJdPy5bbm5dfHxhW25uXSxmaWVsZElkOmFbbm5dLGNsYXNzOlsieGZhVGV4dGZpZWxkIl0sc3R5bGU6dCwiYXJpYS1sYWJlbCI6YXJpYUxhYmVsKGEpLCJhcmlhLXJlcXVpcmVkIjohMX19O2lmKGlzUmVxdWlyZWQoYSkpe2kuYXR0cmlidXRlc1siYXJpYS1yZXF1aXJlZCJdPSEwO2kuYXR0cmlidXRlcy5yZXF1aXJlZD0hMH1yZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJsYWJlbCIsYXR0cmlidXRlczp7Y2xhc3M6WyJ4ZmFMYWJlbCJdfSxjaGlsZHJlbjpbaV19KX19Y2xhc3MgVGltZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwidGltZSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifVtzcl0oKXtjb25zdCBlPXRoaXNbZXJdLnRyaW0oKTt0aGlzW2VyXT1lP25ldyBEYXRlKGUpOm51bGx9W2FuXShlKXtyZXR1cm4gdmFsdWVUb0h0bWwodGhpc1tlcl0/dGhpc1tlcl0udG9TdHJpbmcoKToiIil9fWNsYXNzIFRpbWVTdGFtcCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwidGltZVN0YW1wIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnNlcnZlcj1lLnNlcnZlcnx8IiI7dGhpcy50eXBlPWdldFN0cmluZ09wdGlvbihlLnR5cGUsWyJvcHRpb25hbCIsInJlcXVpcmVkIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgVG9vbFRpcCBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwidG9vbFRpcCIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5yaWQ9ZS5yaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgVHJhdmVyc2FsIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJ0cmF2ZXJzYWwiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMudHJhdmVyc2U9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBUcmF2ZXJzZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwidHJhdmVyc2UiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMub3BlcmF0aW9uPWdldFN0cmluZ09wdGlvbihlLm9wZXJhdGlvbixbIm5leHQiLCJiYWNrIiwiZG93biIsImZpcnN0IiwibGVmdCIsInJpZ2h0IiwidXAiXSk7dGhpcy5yZWY9ZS5yZWZ8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMuc2NyaXB0PW51bGx9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpcy5vcGVyYXRpb259W01yXSgpe3JldHVybiExfX1jbGFzcyBVaSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwidWkiLCEwKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMucGljdHVyZT1udWxsO3RoaXMuYmFyY29kZT1udWxsO3RoaXMuYnV0dG9uPW51bGw7dGhpcy5jaGVja0J1dHRvbj1udWxsO3RoaXMuY2hvaWNlTGlzdD1udWxsO3RoaXMuZGF0ZVRpbWVFZGl0PW51bGw7dGhpcy5kZWZhdWx0VWk9bnVsbDt0aGlzLmltYWdlRWRpdD1udWxsO3RoaXMubnVtZXJpY0VkaXQ9bnVsbDt0aGlzLnBhc3N3b3JkRWRpdD1udWxsO3RoaXMuc2lnbmF0dXJlPW51bGw7dGhpcy50ZXh0RWRpdD1udWxsfVtscl0oKXtpZih2b2lkIDA9PT10aGlzW2FyXSl7Zm9yKGNvbnN0IGUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpe2lmKCJleHRyYXMiPT09ZXx8InBpY3R1cmUiPT09ZSljb250aW51ZTtjb25zdCB0PXRoaXNbZV07aWYodCBpbnN0YW5jZW9mIFhGQU9iamVjdCl7dGhpc1thcl09dDtyZXR1cm4gdH19dGhpc1thcl09bnVsbH1yZXR1cm4gdGhpc1thcl19W2FuXShlKXtjb25zdCB0PXRoaXNbbHJdKCk7cmV0dXJuIHQ/dFthbl0oZSk6SFRNTFJlc3VsdC5FTVBUWX19Y2xhc3MgVmFsaWRhdGUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoSG4sInZhbGlkYXRlIiwhMCk7dGhpcy5mb3JtYXRUZXN0PWdldFN0cmluZ09wdGlvbihlLmZvcm1hdFRlc3QsWyJ3YXJuaW5nIiwiZGlzYWJsZWQiLCJlcnJvciJdKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubnVsbFRlc3Q9Z2V0U3RyaW5nT3B0aW9uKGUubnVsbFRlc3QsWyJkaXNhYmxlZCIsImVycm9yIiwid2FybmluZyJdKTt0aGlzLnNjcmlwdFRlc3Q9Z2V0U3RyaW5nT3B0aW9uKGUuc2NyaXB0VGVzdCxbImVycm9yIiwiZGlzYWJsZWQiLCJ3YXJuaW5nIl0pO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmV4dHJhcz1udWxsO3RoaXMubWVzc2FnZT1udWxsO3RoaXMucGljdHVyZT1udWxsO3RoaXMuc2NyaXB0PW51bGx9fWNsYXNzIFZhbHVlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKEhuLCJ2YWx1ZSIsITApO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5vdmVycmlkZT1nZXRJbnRlZ2VyKHtkYXRhOmUub3ZlcnJpZGUsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLnJlbGV2YW50PWdldFJlbGV2YW50KGUucmVsZXZhbnQpO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIjt0aGlzLmFyYz1udWxsO3RoaXMuYm9vbGVhbj1udWxsO3RoaXMuZGF0ZT1udWxsO3RoaXMuZGF0ZVRpbWU9bnVsbDt0aGlzLmRlY2ltYWw9bnVsbDt0aGlzLmV4RGF0YT1udWxsO3RoaXMuZmxvYXQ9bnVsbDt0aGlzLmltYWdlPW51bGw7dGhpcy5pbnRlZ2VyPW51bGw7dGhpcy5saW5lPW51bGw7dGhpcy5yZWN0YW5nbGU9bnVsbDt0aGlzLnRleHQ9bnVsbDt0aGlzLnRpbWU9bnVsbH1bJHJdKGUpe2NvbnN0IHQ9dGhpc1twcl0oKTtpZih0IGluc3RhbmNlb2YgRmllbGQmJnQudWk/LmltYWdlRWRpdCl7aWYoIXRoaXMuaW1hZ2Upe3RoaXMuaW1hZ2U9bmV3IEltYWdlKHt9KTt0aGlzW1hzXSh0aGlzLmltYWdlKX10aGlzLmltYWdlW2VyXT1lW2VyXTtyZXR1cm59Y29uc3QgaT1lW1lyXTtpZihudWxsPT09dGhpc1tpXSl7Zm9yKGNvbnN0IGUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpe2NvbnN0IHQ9dGhpc1tlXTtpZih0IGluc3RhbmNlb2YgWEZBT2JqZWN0KXt0aGlzW2VdPW51bGw7dGhpc1tqcl0odCl9fXRoaXNbZVtZcl1dPWU7dGhpc1tYc10oZSl9ZWxzZSB0aGlzW2ldW2VyXT1lW2VyXX1bZW5dKCl7aWYodGhpcy5leERhdGEpcmV0dXJuInN0cmluZyI9PXR5cGVvZiB0aGlzLmV4RGF0YVtlcl0/dGhpcy5leERhdGFbZXJdLnRyaW0oKTp0aGlzLmV4RGF0YVtlcl1bZW5dKCkudHJpbSgpO2Zvcihjb25zdCBlIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKXtpZigiaW1hZ2UiPT09ZSljb250aW51ZTtjb25zdCB0PXRoaXNbZV07aWYodCBpbnN0YW5jZW9mIFhGQU9iamVjdClyZXR1cm4odFtlcl18fCIiKS50b1N0cmluZygpLnRyaW0oKX1yZXR1cm4gbnVsbH1bYW5dKGUpe2Zvcihjb25zdCB0IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKXtjb25zdCBpPXRoaXNbdF07aWYoaSBpbnN0YW5jZW9mIFhGQU9iamVjdClyZXR1cm4gaVthbl0oZSl9cmV0dXJuIEhUTUxSZXN1bHQuRU1QVFl9fWNsYXNzIFZhcmlhYmxlcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihIbiwidmFyaWFibGVzIiwhMCk7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiI7dGhpcy5ib29sZWFuPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRhdGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGF0ZVRpbWU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZGVjaW1hbD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5leERhdGE9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZmxvYXQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaW1hZ2U9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuaW50ZWdlcj1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5tYW5pZmVzdD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5zY3JpcHQ9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMudGV4dD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy50aW1lPW5ldyBYRkFPYmplY3RBcnJheX1bTXJdKCl7cmV0dXJuITB9fWNsYXNzIFRlbXBsYXRlTmFtZXNwYWNle3N0YXRpY1tvbl0oZSx0KXtpZihUZW1wbGF0ZU5hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSl7Y29uc3QgaT1UZW1wbGF0ZU5hbWVzcGFjZVtlXSh0KTtpW19yXSh0KTtyZXR1cm4gaX19c3RhdGljIGFwcGVhcmFuY2VGaWx0ZXIoZSl7cmV0dXJuIG5ldyBBcHBlYXJhbmNlRmlsdGVyKGUpfXN0YXRpYyBhcmMoZSl7cmV0dXJuIG5ldyBBcmMoZSl9c3RhdGljIGFyZWEoZSl7cmV0dXJuIG5ldyBBcmVhKGUpfXN0YXRpYyBhc3Npc3QoZSl7cmV0dXJuIG5ldyBBc3Npc3QoZSl9c3RhdGljIGJhcmNvZGUoZSl7cmV0dXJuIG5ldyBCYXJjb2RlKGUpfXN0YXRpYyBiaW5kKGUpe3JldHVybiBuZXcgQmluZChlKX1zdGF0aWMgYmluZEl0ZW1zKGUpe3JldHVybiBuZXcgQmluZEl0ZW1zKGUpfXN0YXRpYyBib29rZW5kKGUpe3JldHVybiBuZXcgQm9va2VuZChlKX1zdGF0aWMgYm9vbGVhbihlKXtyZXR1cm4gbmV3IEJvb2xlYW5FbGVtZW50KGUpfXN0YXRpYyBib3JkZXIoZSl7cmV0dXJuIG5ldyBCb3JkZXIoZSl9c3RhdGljIGJyZWFrKGUpe3JldHVybiBuZXcgQnJlYWsoZSl9c3RhdGljIGJyZWFrQWZ0ZXIoZSl7cmV0dXJuIG5ldyBCcmVha0FmdGVyKGUpfXN0YXRpYyBicmVha0JlZm9yZShlKXtyZXR1cm4gbmV3IEJyZWFrQmVmb3JlKGUpfXN0YXRpYyBidXR0b24oZSl7cmV0dXJuIG5ldyBCdXR0b24oZSl9c3RhdGljIGNhbGN1bGF0ZShlKXtyZXR1cm4gbmV3IENhbGN1bGF0ZShlKX1zdGF0aWMgY2FwdGlvbihlKXtyZXR1cm4gbmV3IENhcHRpb24oZSl9c3RhdGljIGNlcnRpZmljYXRlKGUpe3JldHVybiBuZXcgQ2VydGlmaWNhdGUoZSl9c3RhdGljIGNlcnRpZmljYXRlcyhlKXtyZXR1cm4gbmV3IENlcnRpZmljYXRlcyhlKX1zdGF0aWMgY2hlY2tCdXR0b24oZSl7cmV0dXJuIG5ldyBDaGVja0J1dHRvbihlKX1zdGF0aWMgY2hvaWNlTGlzdChlKXtyZXR1cm4gbmV3IENob2ljZUxpc3QoZSl9c3RhdGljIGNvbG9yKGUpe3JldHVybiBuZXcgQ29sb3IoZSl9c3RhdGljIGNvbWIoZSl7cmV0dXJuIG5ldyBDb21iKGUpfXN0YXRpYyBjb25uZWN0KGUpe3JldHVybiBuZXcgQ29ubmVjdChlKX1zdGF0aWMgY29udGVudEFyZWEoZSl7cmV0dXJuIG5ldyBDb250ZW50QXJlYShlKX1zdGF0aWMgY29ybmVyKGUpe3JldHVybiBuZXcgQ29ybmVyKGUpfXN0YXRpYyBkYXRlKGUpe3JldHVybiBuZXcgRGF0ZUVsZW1lbnQoZSl9c3RhdGljIGRhdGVUaW1lKGUpe3JldHVybiBuZXcgRGF0ZVRpbWUoZSl9c3RhdGljIGRhdGVUaW1lRWRpdChlKXtyZXR1cm4gbmV3IERhdGVUaW1lRWRpdChlKX1zdGF0aWMgZGVjaW1hbChlKXtyZXR1cm4gbmV3IERlY2ltYWwoZSl9c3RhdGljIGRlZmF1bHRVaShlKXtyZXR1cm4gbmV3IERlZmF1bHRVaShlKX1zdGF0aWMgZGVzYyhlKXtyZXR1cm4gbmV3IERlc2MoZSl9c3RhdGljIGRpZ2VzdE1ldGhvZChlKXtyZXR1cm4gbmV3IERpZ2VzdE1ldGhvZChlKX1zdGF0aWMgZGlnZXN0TWV0aG9kcyhlKXtyZXR1cm4gbmV3IERpZ2VzdE1ldGhvZHMoZSl9c3RhdGljIGRyYXcoZSl7cmV0dXJuIG5ldyBEcmF3KGUpfXN0YXRpYyBlZGdlKGUpe3JldHVybiBuZXcgRWRnZShlKX1zdGF0aWMgZW5jb2RpbmcoZSl7cmV0dXJuIG5ldyBFbmNvZGluZyhlKX1zdGF0aWMgZW5jb2RpbmdzKGUpe3JldHVybiBuZXcgRW5jb2RpbmdzKGUpfXN0YXRpYyBlbmNyeXB0KGUpe3JldHVybiBuZXcgRW5jcnlwdChlKX1zdGF0aWMgZW5jcnlwdERhdGEoZSl7cmV0dXJuIG5ldyBFbmNyeXB0RGF0YShlKX1zdGF0aWMgZW5jcnlwdGlvbihlKXtyZXR1cm4gbmV3IEVuY3J5cHRpb24oZSl9c3RhdGljIGVuY3J5cHRpb25NZXRob2QoZSl7cmV0dXJuIG5ldyBFbmNyeXB0aW9uTWV0aG9kKGUpfXN0YXRpYyBlbmNyeXB0aW9uTWV0aG9kcyhlKXtyZXR1cm4gbmV3IEVuY3J5cHRpb25NZXRob2RzKGUpfXN0YXRpYyBldmVudChlKXtyZXR1cm4gbmV3IEV2ZW50KGUpfXN0YXRpYyBleERhdGEoZSl7cmV0dXJuIG5ldyBFeERhdGEoZSl9c3RhdGljIGV4T2JqZWN0KGUpe3JldHVybiBuZXcgRXhPYmplY3QoZSl9c3RhdGljIGV4Y2xHcm91cChlKXtyZXR1cm4gbmV3IEV4Y2xHcm91cChlKX1zdGF0aWMgZXhlY3V0ZShlKXtyZXR1cm4gbmV3IEV4ZWN1dGUoZSl9c3RhdGljIGV4dHJhcyhlKXtyZXR1cm4gbmV3IEV4dHJhcyhlKX1zdGF0aWMgZmllbGQoZSl7cmV0dXJuIG5ldyBGaWVsZChlKX1zdGF0aWMgZmlsbChlKXtyZXR1cm4gbmV3IEZpbGwoZSl9c3RhdGljIGZpbHRlcihlKXtyZXR1cm4gbmV3IEZpbHRlcihlKX1zdGF0aWMgZmxvYXQoZSl7cmV0dXJuIG5ldyBGbG9hdChlKX1zdGF0aWMgZm9udChlKXtyZXR1cm4gbmV3IHRlbXBsYXRlX0ZvbnQoZSl9c3RhdGljIGZvcm1hdChlKXtyZXR1cm4gbmV3IEZvcm1hdChlKX1zdGF0aWMgaGFuZGxlcihlKXtyZXR1cm4gbmV3IEhhbmRsZXIoZSl9c3RhdGljIGh5cGhlbmF0aW9uKGUpe3JldHVybiBuZXcgSHlwaGVuYXRpb24oZSl9c3RhdGljIGltYWdlKGUpe3JldHVybiBuZXcgSW1hZ2UoZSl9c3RhdGljIGltYWdlRWRpdChlKXtyZXR1cm4gbmV3IEltYWdlRWRpdChlKX1zdGF0aWMgaW50ZWdlcihlKXtyZXR1cm4gbmV3IEludGVnZXIoZSl9c3RhdGljIGlzc3VlcnMoZSl7cmV0dXJuIG5ldyBJc3N1ZXJzKGUpfXN0YXRpYyBpdGVtcyhlKXtyZXR1cm4gbmV3IEl0ZW1zKGUpfXN0YXRpYyBrZWVwKGUpe3JldHVybiBuZXcgS2VlcChlKX1zdGF0aWMga2V5VXNhZ2UoZSl7cmV0dXJuIG5ldyBLZXlVc2FnZShlKX1zdGF0aWMgbGluZShlKXtyZXR1cm4gbmV3IExpbmUoZSl9c3RhdGljIGxpbmVhcihlKXtyZXR1cm4gbmV3IExpbmVhcihlKX1zdGF0aWMgbG9ja0RvY3VtZW50KGUpe3JldHVybiBuZXcgTG9ja0RvY3VtZW50KGUpfXN0YXRpYyBtYW5pZmVzdChlKXtyZXR1cm4gbmV3IE1hbmlmZXN0KGUpfXN0YXRpYyBtYXJnaW4oZSl7cmV0dXJuIG5ldyBNYXJnaW4oZSl9c3RhdGljIG1kcChlKXtyZXR1cm4gbmV3IE1kcChlKX1zdGF0aWMgbWVkaXVtKGUpe3JldHVybiBuZXcgTWVkaXVtKGUpfXN0YXRpYyBtZXNzYWdlKGUpe3JldHVybiBuZXcgTWVzc2FnZShlKX1zdGF0aWMgbnVtZXJpY0VkaXQoZSl7cmV0dXJuIG5ldyBOdW1lcmljRWRpdChlKX1zdGF0aWMgb2NjdXIoZSl7cmV0dXJuIG5ldyBPY2N1cihlKX1zdGF0aWMgb2lkKGUpe3JldHVybiBuZXcgT2lkKGUpfXN0YXRpYyBvaWRzKGUpe3JldHVybiBuZXcgT2lkcyhlKX1zdGF0aWMgb3ZlcmZsb3coZSl7cmV0dXJuIG5ldyBPdmVyZmxvdyhlKX1zdGF0aWMgcGFnZUFyZWEoZSl7cmV0dXJuIG5ldyBQYWdlQXJlYShlKX1zdGF0aWMgcGFnZVNldChlKXtyZXR1cm4gbmV3IFBhZ2VTZXQoZSl9c3RhdGljIHBhcmEoZSl7cmV0dXJuIG5ldyBQYXJhKGUpfXN0YXRpYyBwYXNzd29yZEVkaXQoZSl7cmV0dXJuIG5ldyBQYXNzd29yZEVkaXQoZSl9c3RhdGljIHBhdHRlcm4oZSl7cmV0dXJuIG5ldyB0ZW1wbGF0ZV9QYXR0ZXJuKGUpfXN0YXRpYyBwaWN0dXJlKGUpe3JldHVybiBuZXcgUGljdHVyZShlKX1zdGF0aWMgcHJvdG8oZSl7cmV0dXJuIG5ldyBQcm90byhlKX1zdGF0aWMgcmFkaWFsKGUpe3JldHVybiBuZXcgUmFkaWFsKGUpfXN0YXRpYyByZWFzb24oZSl7cmV0dXJuIG5ldyBSZWFzb24oZSl9c3RhdGljIHJlYXNvbnMoZSl7cmV0dXJuIG5ldyBSZWFzb25zKGUpfXN0YXRpYyByZWN0YW5nbGUoZSl7cmV0dXJuIG5ldyBSZWN0YW5nbGUoZSl9c3RhdGljIHJlZihlKXtyZXR1cm4gbmV3IFJlZkVsZW1lbnQoZSl9c3RhdGljIHNjcmlwdChlKXtyZXR1cm4gbmV3IFNjcmlwdChlKX1zdGF0aWMgc2V0UHJvcGVydHkoZSl7cmV0dXJuIG5ldyBTZXRQcm9wZXJ0eShlKX1zdGF0aWMgc2lnbkRhdGEoZSl7cmV0dXJuIG5ldyBTaWduRGF0YShlKX1zdGF0aWMgc2lnbmF0dXJlKGUpe3JldHVybiBuZXcgU2lnbmF0dXJlKGUpfXN0YXRpYyBzaWduaW5nKGUpe3JldHVybiBuZXcgU2lnbmluZyhlKX1zdGF0aWMgc29saWQoZSl7cmV0dXJuIG5ldyBTb2xpZChlKX1zdGF0aWMgc3BlYWsoZSl7cmV0dXJuIG5ldyBTcGVhayhlKX1zdGF0aWMgc3RpcHBsZShlKXtyZXR1cm4gbmV3IFN0aXBwbGUoZSl9c3RhdGljIHN1YmZvcm0oZSl7cmV0dXJuIG5ldyBTdWJmb3JtKGUpfXN0YXRpYyBzdWJmb3JtU2V0KGUpe3JldHVybiBuZXcgU3ViZm9ybVNldChlKX1zdGF0aWMgc3ViamVjdEROKGUpe3JldHVybiBuZXcgU3ViamVjdEROKGUpfXN0YXRpYyBzdWJqZWN0RE5zKGUpe3JldHVybiBuZXcgU3ViamVjdEROcyhlKX1zdGF0aWMgc3VibWl0KGUpe3JldHVybiBuZXcgU3VibWl0KGUpfXN0YXRpYyB0ZW1wbGF0ZShlKXtyZXR1cm4gbmV3IFRlbXBsYXRlKGUpfXN0YXRpYyB0ZXh0KGUpe3JldHVybiBuZXcgVGV4dChlKX1zdGF0aWMgdGV4dEVkaXQoZSl7cmV0dXJuIG5ldyBUZXh0RWRpdChlKX1zdGF0aWMgdGltZShlKXtyZXR1cm4gbmV3IFRpbWUoZSl9c3RhdGljIHRpbWVTdGFtcChlKXtyZXR1cm4gbmV3IFRpbWVTdGFtcChlKX1zdGF0aWMgdG9vbFRpcChlKXtyZXR1cm4gbmV3IFRvb2xUaXAoZSl9c3RhdGljIHRyYXZlcnNhbChlKXtyZXR1cm4gbmV3IFRyYXZlcnNhbChlKX1zdGF0aWMgdHJhdmVyc2UoZSl7cmV0dXJuIG5ldyBUcmF2ZXJzZShlKX1zdGF0aWMgdWkoZSl7cmV0dXJuIG5ldyBVaShlKX1zdGF0aWMgdmFsaWRhdGUoZSl7cmV0dXJuIG5ldyBWYWxpZGF0ZShlKX1zdGF0aWMgdmFsdWUoZSl7cmV0dXJuIG5ldyBWYWx1ZShlKX1zdGF0aWMgdmFyaWFibGVzKGUpe3JldHVybiBuZXcgVmFyaWFibGVzKGUpfX1jb25zdCBUbj1nbi5kYXRhc2V0cy5pZDtmdW5jdGlvbiBjcmVhdGVUZXh0KGUpe2NvbnN0IHQ9bmV3IFRleHQoe30pO3RbZXJdPWU7cmV0dXJuIHR9Y2xhc3MgQmluZGVye2NvbnN0cnVjdG9yKGUpe3RoaXMucm9vdD1lO3RoaXMuZGF0YXNldHM9ZS5kYXRhc2V0czt0aGlzLmRhdGE9ZS5kYXRhc2V0cz8uZGF0YXx8bmV3IFhtbE9iamVjdChnbi5kYXRhc2V0cy5pZCwiZGF0YSIpO3RoaXMuZW1wdHlNZXJnZT0wPT09dGhpcy5kYXRhW0VyXSgpLmxlbmd0aDt0aGlzLnJvb3QuZm9ybT10aGlzLmZvcm09ZS50ZW1wbGF0ZVskc10oKX1faXNDb25zdW1lRGF0YSgpe3JldHVybiF0aGlzLmVtcHR5TWVyZ2UmJnRoaXMuX21lcmdlTW9kZX1faXNNYXRjaFRlbXBsYXRlKCl7cmV0dXJuIXRoaXMuX2lzQ29uc3VtZURhdGEoKX1iaW5kKCl7dGhpcy5fYmluZEVsZW1lbnQodGhpcy5mb3JtLHRoaXMuZGF0YSk7cmV0dXJuIHRoaXMuZm9ybX1nZXREYXRhKCl7cmV0dXJuIHRoaXMuZGF0YX1fYmluZFZhbHVlKGUsdCxpKXtlW3RyXT10O2lmKGVbd3JdKCkpaWYodFtOcl0oKSl7Y29uc3QgaT10W2hyXSgpO2VbJHJdKGNyZWF0ZVRleHQoaSkpfWVsc2UgaWYoZSBpbnN0YW5jZW9mIEZpZWxkJiYibXVsdGlTZWxlY3QiPT09ZS51aT8uY2hvaWNlTGlzdD8ub3Blbil7Y29uc3QgaT10W0VyXSgpLm1hcCgoZT0+ZVtlcl0udHJpbSgpKSkuam9pbigiXG4iKTtlWyRyXShjcmVhdGVUZXh0KGkpKX1lbHNlIHRoaXMuX2lzQ29uc3VtZURhdGEoKSYmd2FybigiWEZBIC0gTm9kZXMgaGF2ZW4ndCB0aGUgc2FtZSB0eXBlLiIpO2Vsc2UhdFtOcl0oKXx8dGhpcy5faXNNYXRjaFRlbXBsYXRlKCk/dGhpcy5fYmluZEVsZW1lbnQoZSx0KTp3YXJuKCJYRkEgLSBOb2RlcyBoYXZlbid0IHRoZSBzYW1lIHR5cGUuIil9X2ZpbmREYXRhQnlOYW1lVG9Db25zdW1lKGUsdCxpLGEpe2lmKCFlKXJldHVybiBudWxsO2xldCBzLHI7Zm9yKGxldCBhPTA7YTwzO2ErKyl7cz1pW1FyXShlLCExLCEwKTtmb3IoOzspe3I9cy5uZXh0KCkudmFsdWU7aWYoIXIpYnJlYWs7aWYodD09PXJbTnJdKCkpcmV0dXJuIHJ9aWYoaVtKcl09PT1nbi5kYXRhc2V0cy5pZCYmImRhdGEiPT09aVtZcl0pYnJlYWs7aT1pW3ByXSgpfWlmKCFhKXJldHVybiBudWxsO3M9dGhpcy5kYXRhW1FyXShlLCEwLCExKTtyPXMubmV4dCgpLnZhbHVlO2lmKHIpcmV0dXJuIHI7cz10aGlzLmRhdGFbbnJdKGUsITApO3I9cy5uZXh0KCkudmFsdWU7cmV0dXJuIHI/LltOcl0oKT9yOm51bGx9X3NldFByb3BlcnRpZXMoZSx0KXtpZihlLmhhc093blByb3BlcnR5KCJzZXRQcm9wZXJ0eSIpKWZvcihjb25zdHtyZWY6aSx0YXJnZXQ6YSxjb25uZWN0aW9uOnN9b2YgZS5zZXRQcm9wZXJ0eS5jaGlsZHJlbil7aWYocyljb250aW51ZTtpZighaSljb250aW51ZTtjb25zdCByPXNlYXJjaE5vZGUodGhpcy5yb290LHQsaSwhMSwhMSk7aWYoIXIpe3dhcm4oYFhGQSAtIEludmFsaWQgcmVmZXJlbmNlOiAke2l9LmApO2NvbnRpbnVlfWNvbnN0W25dPXI7aWYoIW5bUnJdKHRoaXMuZGF0YSkpe3dhcm4oIlhGQSAtIEludmFsaWQgbm9kZTogbXVzdCBiZSBhIGRhdGEgbm9kZS4iKTtjb250aW51ZX1jb25zdCBvPXNlYXJjaE5vZGUodGhpcy5yb290LGUsYSwhMSwhMSk7aWYoIW8pe3dhcm4oYFhGQSAtIEludmFsaWQgdGFyZ2V0OiAke2F9LmApO2NvbnRpbnVlfWNvbnN0W2ddPW87aWYoIWdbUnJdKGUpKXt3YXJuKCJYRkEgLSBJbnZhbGlkIHRhcmdldDogbXVzdCBiZSBhIHByb3BlcnR5IG9yIHN1YnByb3BlcnR5LiIpO2NvbnRpbnVlfWNvbnN0IGM9Z1twcl0oKTtpZihnIGluc3RhbmNlb2YgU2V0UHJvcGVydHl8fGMgaW5zdGFuY2VvZiBTZXRQcm9wZXJ0eSl7d2FybigiWEZBIC0gSW52YWxpZCB0YXJnZXQ6IGNhbm5vdCBiZSBhIHNldFByb3BlcnR5IG9yIG9uZSBvZiBpdHMgcHJvcGVydGllcy4iKTtjb250aW51ZX1pZihnIGluc3RhbmNlb2YgQmluZEl0ZW1zfHxjIGluc3RhbmNlb2YgQmluZEl0ZW1zKXt3YXJuKCJYRkEgLSBJbnZhbGlkIHRhcmdldDogY2Fubm90IGJlIGEgYmluZEl0ZW1zIG9yIG9uZSBvZiBpdHMgcHJvcGVydGllcy4iKTtjb250aW51ZX1jb25zdCBDPW5bZW5dKCksaD1nW1lyXTtpZihnIGluc3RhbmNlb2YgWEZBQXR0cmlidXRlKXtjb25zdCBlPU9iamVjdC5jcmVhdGUobnVsbCk7ZVtoXT1DO2NvbnN0IHQ9UmVmbGVjdC5jb25zdHJ1Y3QoT2JqZWN0LmdldFByb3RvdHlwZU9mKGMpLmNvbnN0cnVjdG9yLFtlXSk7Y1toXT10W2hdfWVsc2UgaWYoZy5oYXNPd25Qcm9wZXJ0eShlcikpe2dbdHJdPW47Z1tlcl09QztnW3NyXSgpfWVsc2Ugd2FybigiWEZBIC0gSW52YWxpZCBub2RlIHRvIHVzZSBpbiBzZXRQcm9wZXJ0eSIpfX1fYmluZEl0ZW1zKGUsdCl7aWYoIWUuaGFzT3duUHJvcGVydHkoIml0ZW1zIil8fCFlLmhhc093blByb3BlcnR5KCJiaW5kSXRlbXMiKXx8ZS5iaW5kSXRlbXMuaXNFbXB0eSgpKXJldHVybjtmb3IoY29uc3QgdCBvZiBlLml0ZW1zLmNoaWxkcmVuKWVbanJdKHQpO2UuaXRlbXMuY2xlYXIoKTtjb25zdCBpPW5ldyBJdGVtcyh7fSksYT1uZXcgSXRlbXMoe30pO2VbWHNdKGkpO2UuaXRlbXMucHVzaChpKTtlW1hzXShhKTtlLml0ZW1zLnB1c2goYSk7Zm9yKGNvbnN0e3JlZjpzLGxhYmVsUmVmOnIsdmFsdWVSZWY6bixjb25uZWN0aW9uOm99b2YgZS5iaW5kSXRlbXMuY2hpbGRyZW4pe2lmKG8pY29udGludWU7aWYoIXMpY29udGludWU7Y29uc3QgZT1zZWFyY2hOb2RlKHRoaXMucm9vdCx0LHMsITEsITEpO2lmKGUpZm9yKGNvbnN0IHQgb2YgZSl7aWYoIXRbUnJdKHRoaXMuZGF0YXNldHMpKXt3YXJuKGBYRkEgLSBJbnZhbGlkIHJlZiAoJHtzfSk6IG11c3QgYmUgYSBkYXRhc2V0cyBjaGlsZC5gKTtjb250aW51ZX1jb25zdCBlPXNlYXJjaE5vZGUodGhpcy5yb290LHQsciwhMCwhMSk7aWYoIWUpe3dhcm4oYFhGQSAtIEludmFsaWQgbGFiZWw6ICR7cn0uYCk7Y29udGludWV9Y29uc3Rbb109ZTtpZighb1tScl0odGhpcy5kYXRhc2V0cykpe3dhcm4oIlhGQSAtIEludmFsaWQgbGFiZWw6IG11c3QgYmUgYSBkYXRhc2V0cyBjaGlsZC4iKTtjb250aW51ZX1jb25zdCBnPXNlYXJjaE5vZGUodGhpcy5yb290LHQsbiwhMCwhMSk7aWYoIWcpe3dhcm4oYFhGQSAtIEludmFsaWQgdmFsdWU6ICR7bn0uYCk7Y29udGludWV9Y29uc3RbY109ZztpZighY1tScl0odGhpcy5kYXRhc2V0cykpe3dhcm4oIlhGQSAtIEludmFsaWQgdmFsdWU6IG11c3QgYmUgYSBkYXRhc2V0cyBjaGlsZC4iKTtjb250aW51ZX1jb25zdCBDPWNyZWF0ZVRleHQob1tlbl0oKSksaD1jcmVhdGVUZXh0KGNbZW5dKCkpO2lbWHNdKEMpO2kudGV4dC5wdXNoKEMpO2FbWHNdKGgpO2EudGV4dC5wdXNoKGgpfWVsc2Ugd2FybihgWEZBIC0gSW52YWxpZCByZWZlcmVuY2U6ICR7c30uYCl9fV9iaW5kT2NjdXJyZW5jZXMoZSx0LGkpe2xldCBhO2lmKHQubGVuZ3RoPjEpe2E9ZVskc10oKTthW2pyXShhLm9jY3VyKTthLm9jY3VyPW51bGx9dGhpcy5fYmluZFZhbHVlKGUsdFswXSxpKTt0aGlzLl9zZXRQcm9wZXJ0aWVzKGUsdFswXSk7dGhpcy5fYmluZEl0ZW1zKGUsdFswXSk7aWYoMT09PXQubGVuZ3RoKXJldHVybjtjb25zdCBzPWVbcHJdKCkscj1lW1lyXSxuPXNbRHJdKGUpO2ZvcihsZXQgZT0xLG89dC5sZW5ndGg7ZTxvO2UrKyl7Y29uc3Qgbz10W2VdLGc9YVskc10oKTtzW3JdLnB1c2goZyk7c1tGcl0obitlLGcpO3RoaXMuX2JpbmRWYWx1ZShnLG8saSk7dGhpcy5fc2V0UHJvcGVydGllcyhnLG8pO3RoaXMuX2JpbmRJdGVtcyhnLG8pfX1fY3JlYXRlT2NjdXJyZW5jZXMoZSl7aWYoIXRoaXMuZW1wdHlNZXJnZSlyZXR1cm47Y29uc3R7b2NjdXI6dH09ZTtpZighdHx8dC5pbml0aWFsPD0xKXJldHVybjtjb25zdCBpPWVbcHJdKCksYT1lW1lyXTtpZighKGlbYV1pbnN0YW5jZW9mIFhGQU9iamVjdEFycmF5KSlyZXR1cm47bGV0IHM7cz1lLm5hbWU/aVthXS5jaGlsZHJlbi5maWx0ZXIoKHQ9PnQubmFtZT09PWUubmFtZSkpLmxlbmd0aDppW2FdLmNoaWxkcmVuLmxlbmd0aDtjb25zdCByPWlbRHJdKGUpKzEsbj10LmluaXRpYWwtcztpZihuKXtjb25zdCB0PWVbJHNdKCk7dFtqcl0odC5vY2N1cik7dC5vY2N1cj1udWxsO2lbYV0ucHVzaCh0KTtpW0ZyXShyLHQpO2ZvcihsZXQgZT0xO2U8bjtlKyspe2NvbnN0IHM9dFskc10oKTtpW2FdLnB1c2gocyk7aVtGcl0ocitlLHMpfX19X2dldE9jY3VySW5mbyhlKXtjb25zdHtuYW1lOnQsb2NjdXI6aX09ZTtpZighaXx8IXQpcmV0dXJuWzEsMV07Y29uc3QgYT0tMT09PWkubWF4PzEvMDppLm1heDtyZXR1cm5baS5taW4sYV19X3NldEFuZEJpbmQoZSx0KXt0aGlzLl9zZXRQcm9wZXJ0aWVzKGUsdCk7dGhpcy5fYmluZEl0ZW1zKGUsdCk7dGhpcy5fYmluZEVsZW1lbnQoZSx0KX1fYmluZEVsZW1lbnQoZSx0KXtjb25zdCBpPVtdO3RoaXMuX2NyZWF0ZU9jY3VycmVuY2VzKGUpO2Zvcihjb25zdCBhIG9mIGVbRXJdKCkpe2lmKGFbdHJdKWNvbnRpbnVlO2lmKHZvaWQgMD09PXRoaXMuX21lcmdlTW9kZSYmInN1YmZvcm0iPT09YVtZcl0pe3RoaXMuX21lcmdlTW9kZT0iY29uc3VtZURhdGEiPT09YS5tZXJnZU1vZGU7Y29uc3QgZT10W0VyXSgpO2lmKGUubGVuZ3RoPjApdGhpcy5fYmluZE9jY3VycmVuY2VzKGEsW2VbMF1dLG51bGwpO2Vsc2UgaWYodGhpcy5lbXB0eU1lcmdlKXtjb25zdCBlPXRbSnJdPT09VG4/LTE6dFtKcl0saT1hW3RyXT1uZXcgWG1sT2JqZWN0KGUsYS5uYW1lfHwicm9vdCIpO3RbWHNdKGkpO3RoaXMuX2JpbmRFbGVtZW50KGEsaSl9Y29udGludWV9aWYoIWFba3JdKCkpY29udGludWU7bGV0IGU9ITEscz1udWxsLHI9bnVsbCxuPW51bGw7aWYoYS5iaW5kKXtzd2l0Y2goYS5iaW5kLm1hdGNoKXtjYXNlIm5vbmUiOnRoaXMuX3NldEFuZEJpbmQoYSx0KTtjb250aW51ZTtjYXNlImdsb2JhbCI6ZT0hMDticmVhaztjYXNlImRhdGFSZWYiOmlmKCFhLmJpbmQucmVmKXt3YXJuKGBYRkEgLSByZWYgaXMgZW1wdHkgaW4gbm9kZSAke2FbWXJdfS5gKTt0aGlzLl9zZXRBbmRCaW5kKGEsdCk7Y29udGludWV9cj1hLmJpbmQucmVmfWEuYmluZC5waWN0dXJlJiYocz1hLmJpbmQucGljdHVyZVtlcl0pfWNvbnN0W28sZ109dGhpcy5fZ2V0T2NjdXJJbmZvKGEpO2lmKHIpe249c2VhcmNoTm9kZSh0aGlzLnJvb3QsdCxyLCEwLCExKTtpZihudWxsPT09bil7bj1jcmVhdGVEYXRhTm9kZSh0aGlzLmRhdGEsdCxyKTtpZighbiljb250aW51ZTt0aGlzLl9pc0NvbnN1bWVEYXRhKCkmJihuW0FyXT0hMCk7dGhpcy5fc2V0QW5kQmluZChhLG4pO2NvbnRpbnVlfXRoaXMuX2lzQ29uc3VtZURhdGEoKSYmKG49bi5maWx0ZXIoKGU9PiFlW0FyXSkpKTtuLmxlbmd0aD5nP249bi5zbGljZSgwLGcpOjA9PT1uLmxlbmd0aCYmKG49bnVsbCk7biYmdGhpcy5faXNDb25zdW1lRGF0YSgpJiZuLmZvckVhY2goKGU9PntlW0FyXT0hMH0pKX1lbHNle2lmKCFhLm5hbWUpe3RoaXMuX3NldEFuZEJpbmQoYSx0KTtjb250aW51ZX1pZih0aGlzLl9pc0NvbnN1bWVEYXRhKCkpe2NvbnN0IGk9W107Zm9yKDtpLmxlbmd0aDxnOyl7Y29uc3Qgcz10aGlzLl9maW5kRGF0YUJ5TmFtZVRvQ29uc3VtZShhLm5hbWUsYVt3cl0oKSx0LGUpO2lmKCFzKWJyZWFrO3NbQXJdPSEwO2kucHVzaChzKX1uPWkubGVuZ3RoPjA/aTpudWxsfWVsc2V7bj10W1FyXShhLm5hbWUsITEsdGhpcy5lbXB0eU1lcmdlKS5uZXh0KCkudmFsdWU7aWYoIW4pe2lmKDA9PT1vKXtpLnB1c2goYSk7Y29udGludWV9Y29uc3QgZT10W0pyXT09PVRuPy0xOnRbSnJdO249YVt0cl09bmV3IFhtbE9iamVjdChlLGEubmFtZSk7dGhpcy5lbXB0eU1lcmdlJiYobltBcl09ITApO3RbWHNdKG4pO3RoaXMuX3NldEFuZEJpbmQoYSxuKTtjb250aW51ZX10aGlzLmVtcHR5TWVyZ2UmJihuW0FyXT0hMCk7bj1bbl19fW4/dGhpcy5fYmluZE9jY3VycmVuY2VzKGEsbixzKTpvPjA/dGhpcy5fc2V0QW5kQmluZChhLHQpOmkucHVzaChhKX1pLmZvckVhY2goKGU9PmVbcHJdKClbanJdKGUpKSl9fWNsYXNzIERhdGFIYW5kbGVye2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5kYXRhPXQ7dGhpcy5kYXRhc2V0PWUuZGF0YXNldHN8fG51bGx9c2VyaWFsaXplKGUpe2NvbnN0IHQ9W1stMSx0aGlzLmRhdGFbRXJdKCldXTtmb3IoO3QubGVuZ3RoPjA7KXtjb25zdCBpPXQuYXQoLTEpLFthLHNdPWk7aWYoYSsxPT09cy5sZW5ndGgpe3QucG9wKCk7Y29udGludWV9Y29uc3Qgcj1zWysraVswXV0sbj1lLmdldChyW25uXSk7aWYobilyWyRyXShuKTtlbHNle2NvbnN0IHQ9cltvcl0oKTtmb3IoY29uc3QgaSBvZiB0LnZhbHVlcygpKXtjb25zdCB0PWUuZ2V0KGlbbm5dKTtpZih0KXtpWyRyXSh0KTticmVha319fWNvbnN0IG89cltFcl0oKTtvLmxlbmd0aD4wJiZ0LnB1c2goWy0xLG9dKX1jb25zdCBpPVsnPHhmYTpkYXRhc2V0cyB4bWxuczp4ZmE9Imh0dHA6Ly93d3cueGZhLm9yZy9zY2hlbWEveGZhLWRhdGEvMS4wLyI+J107aWYodGhpcy5kYXRhc2V0KWZvcihjb25zdCBlIG9mIHRoaXMuZGF0YXNldFtFcl0oKSkiZGF0YSIhPT1lW1lyXSYmZVtzbl0oaSk7dGhpcy5kYXRhW3NuXShpKTtpLnB1c2goIjwveGZhOmRhdGFzZXRzPiIpO3JldHVybiBpLmpvaW4oIiIpfX1jb25zdCBxbj1nbi5jb25maWcuaWQ7Y2xhc3MgQWNyb2JhdCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiYWNyb2JhdCIsITApO3RoaXMuYWNyb2JhdDc9bnVsbDt0aGlzLmF1dG9TYXZlPW51bGw7dGhpcy5jb21tb249bnVsbDt0aGlzLnZhbGlkYXRlPW51bGw7dGhpcy52YWxpZGF0ZUFwcHJvdmFsU2lnbmF0dXJlcz1udWxsO3RoaXMuc3VibWl0VXJsPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgQWNyb2JhdDcgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImFjcm9iYXQ3IiwhMCk7dGhpcy5keW5hbWljUmVuZGVyPW51bGx9fWNsYXNzIEFEQkVfSlNDb25zb2xlIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJBREJFX0pTQ29uc29sZSIsWyJkZWxlZ2F0ZSIsIkVuYWJsZSIsIkRpc2FibGUiXSl9fWNsYXNzIEFEQkVfSlNEZWJ1Z2dlciBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiQURCRV9KU0RlYnVnZ2VyIixbImRlbGVnYXRlIiwiRW5hYmxlIiwiRGlzYWJsZSJdKX19Y2xhc3MgQWRkU2lsZW50UHJpbnQgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiYWRkU2lsZW50UHJpbnQiKX19Y2xhc3MgQWRkVmlld2VyUHJlZmVyZW5jZXMgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiYWRkVmlld2VyUHJlZmVyZW5jZXMiKX19Y2xhc3MgQWRqdXN0RGF0YSBleHRlbmRzIE9wdGlvbjEwe2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJhZGp1c3REYXRhIil9fWNsYXNzIEFkb2JlRXh0ZW5zaW9uTGV2ZWwgZXh0ZW5kcyBJbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJhZG9iZUV4dGVuc2lvbkxldmVsIiwwLChlPT5lPj0xJiZlPD04KSl9fWNsYXNzIEFnZW50IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJhZ2VudCIsITApO3RoaXMubmFtZT1lLm5hbWU/ZS5uYW1lLnRyaW0oKToiIjt0aGlzLmNvbW1vbj1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEFsd2F5c0VtYmVkIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiYWx3YXlzRW1iZWQiKX19Y2xhc3MgQW1kIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJhbWQiKX19Y2xhc3MgY29uZmlnX0FyZWEgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImFyZWEiKTt0aGlzLmxldmVsPWdldEludGVnZXIoe2RhdGE6ZS5sZXZlbCxkZWZhdWx0VmFsdWU6MCx2YWxpZGF0ZTplPT5lPj0xJiZlPD0zfSk7dGhpcy5uYW1lPWdldFN0cmluZ09wdGlvbihlLm5hbWUsWyIiLCJiYXJjb2RlIiwiY29yZWluaXQiLCJkZXZpY2VEcml2ZXIiLCJmb250IiwiZ2VuZXJhbCIsImxheW91dCIsIm1lcmdlIiwic2NyaXB0Iiwic2lnbmF0dXJlIiwic291cmNlU2V0IiwidGVtcGxhdGVDYWNoZSJdKX19Y2xhc3MgQXR0cmlidXRlcyBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiYXR0cmlidXRlcyIsWyJwcmVzZXJ2ZSIsImRlbGVnYXRlIiwiaWdub3JlIl0pfX1jbGFzcyBBdXRvU2F2ZSBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiYXV0b1NhdmUiLFsiZGlzYWJsZWQiLCJlbmFibGVkIl0pfX1jbGFzcyBCYXNlIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJiYXNlIil9fWNsYXNzIEJhdGNoT3V0cHV0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJiYXRjaE91dHB1dCIpO3RoaXMuZm9ybWF0PWdldFN0cmluZ09wdGlvbihlLmZvcm1hdCxbIm5vbmUiLCJjb25jYXQiLCJ6aXAiLCJ6aXBDb21wcmVzcyJdKX19Y2xhc3MgQmVoYXZpb3JPdmVycmlkZSBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImJlaGF2aW9yT3ZlcnJpZGUiKX1bc3JdKCl7dGhpc1tlcl09bmV3IE1hcCh0aGlzW2VyXS50cmltKCkuc3BsaXQoL1xzKy8pLmZpbHRlcigoZT0+ZS5pbmNsdWRlcygiOiIpKSkubWFwKChlPT5lLnNwbGl0KCI6IiwyKSkpKX19Y2xhc3MgQ2FjaGUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImNhY2hlIiwhMCk7dGhpcy50ZW1wbGF0ZUNhY2hlPW51bGx9fWNsYXNzIENoYW5nZSBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJjaGFuZ2UiKX19Y2xhc3MgQ29tbW9uIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJjb21tb24iLCEwKTt0aGlzLmRhdGE9bnVsbDt0aGlzLmxvY2FsZT1udWxsO3RoaXMubG9jYWxlU2V0PW51bGw7dGhpcy5tZXNzYWdpbmc9bnVsbDt0aGlzLnN1cHByZXNzQmFubmVyPW51bGw7dGhpcy50ZW1wbGF0ZT1udWxsO3RoaXMudmFsaWRhdGlvbk1lc3NhZ2luZz1udWxsO3RoaXMudmVyc2lvbkNvbnRyb2w9bnVsbDt0aGlzLmxvZz1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIENvbXByZXNzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJjb21wcmVzcyIpO3RoaXMuc2NvcGU9Z2V0U3RyaW5nT3B0aW9uKGUuc2NvcGUsWyJpbWFnZU9ubHkiLCJkb2N1bWVudCJdKX19Y2xhc3MgQ29tcHJlc3NMb2dpY2FsU3RydWN0dXJlIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImNvbXByZXNzTG9naWNhbFN0cnVjdHVyZSIpfX1jbGFzcyBDb21wcmVzc09iamVjdFN0cmVhbSBleHRlbmRzIE9wdGlvbjEwe2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJjb21wcmVzc09iamVjdFN0cmVhbSIpfX1jbGFzcyBDb21wcmVzc2lvbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiY29tcHJlc3Npb24iLCEwKTt0aGlzLmNvbXByZXNzTG9naWNhbFN0cnVjdHVyZT1udWxsO3RoaXMuY29tcHJlc3NPYmplY3RTdHJlYW09bnVsbDt0aGlzLmxldmVsPW51bGw7dGhpcy50eXBlPW51bGx9fWNsYXNzIENvbmZpZyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiY29uZmlnIiwhMCk7dGhpcy5hY3JvYmF0PW51bGw7dGhpcy5wcmVzZW50PW51bGw7dGhpcy50cmFjZT1udWxsO3RoaXMuYWdlbnQ9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBDb25mb3JtYW5jZSBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiY29uZm9ybWFuY2UiLFsiQSIsIkIiXSl9fWNsYXNzIENvbnRlbnRDb3B5IGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImNvbnRlbnRDb3B5Iil9fWNsYXNzIENvcGllcyBleHRlbmRzIEludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImNvcGllcyIsMSwoZT0+ZT49MSkpfX1jbGFzcyBDcmVhdG9yIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJjcmVhdG9yIil9fWNsYXNzIEN1cnJlbnRQYWdlIGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiY3VycmVudFBhZ2UiLDAsKGU9PmU+PTApKX19Y2xhc3MgRGF0YSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiZGF0YSIsITApO3RoaXMuYWRqdXN0RGF0YT1udWxsO3RoaXMuYXR0cmlidXRlcz1udWxsO3RoaXMuaW5jcmVtZW50YWxMb2FkPW51bGw7dGhpcy5vdXRwdXRYU0w9bnVsbDt0aGlzLnJhbmdlPW51bGw7dGhpcy5yZWNvcmQ9bnVsbDt0aGlzLnN0YXJ0Tm9kZT1udWxsO3RoaXMudXJpPW51bGw7dGhpcy53aW5kb3c9bnVsbDt0aGlzLnhzbD1udWxsO3RoaXMuZXhjbHVkZU5TPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRyYW5zZm9ybT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIERlYnVnIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJkZWJ1ZyIsITApO3RoaXMudXJpPW51bGx9fWNsYXNzIERlZmF1bHRUeXBlZmFjZSBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImRlZmF1bHRUeXBlZmFjZSIpO3RoaXMud3JpdGluZ1NjcmlwdD1nZXRTdHJpbmdPcHRpb24oZS53cml0aW5nU2NyaXB0LFsiKiIsIkFyYWJpYyIsIkN5cmlsbGljIiwiRWFzdEV1cm9wZWFuUm9tYW4iLCJHcmVlayIsIkhlYnJldyIsIkphcGFuZXNlIiwiS29yZWFuIiwiUm9tYW4iLCJTaW1wbGlmaWVkQ2hpbmVzZSIsIlRoYWkiLCJUcmFkaXRpb25hbENoaW5lc2UiLCJWaWV0bmFtZXNlIl0pfX1jbGFzcyBEZXN0aW5hdGlvbiBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiZGVzdGluYXRpb24iLFsicGRmIiwicGNsIiwicHMiLCJ3ZWJDbGllbnQiLCJ6cGwiXSl9fWNsYXNzIERvY3VtZW50QXNzZW1ibHkgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiZG9jdW1lbnRBc3NlbWJseSIpfX1jbGFzcyBEcml2ZXIgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImRyaXZlciIsITApO3RoaXMubmFtZT1lLm5hbWU/ZS5uYW1lLnRyaW0oKToiIjt0aGlzLmZvbnRJbmZvPW51bGw7dGhpcy54ZGM9bnVsbH19Y2xhc3MgRHVwbGV4T3B0aW9uIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJkdXBsZXhPcHRpb24iLFsic2ltcGxleCIsImR1cGxleEZsaXBMb25nRWRnZSIsImR1cGxleEZsaXBTaG9ydEVkZ2UiXSl9fWNsYXNzIER5bmFtaWNSZW5kZXIgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImR5bmFtaWNSZW5kZXIiLFsiZm9yYmlkZGVuIiwicmVxdWlyZWQiXSl9fWNsYXNzIEVtYmVkIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImVtYmVkIil9fWNsYXNzIGNvbmZpZ19FbmNyeXB0IGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImVuY3J5cHQiKX19Y2xhc3MgY29uZmlnX0VuY3J5cHRpb24gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImVuY3J5cHRpb24iLCEwKTt0aGlzLmVuY3J5cHQ9bnVsbDt0aGlzLmVuY3J5cHRpb25MZXZlbD1udWxsO3RoaXMucGVybWlzc2lvbnM9bnVsbH19Y2xhc3MgRW5jcnlwdGlvbkxldmVsIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJlbmNyeXB0aW9uTGV2ZWwiLFsiNDBiaXQiLCIxMjhiaXQiXSl9fWNsYXNzIEVuZm9yY2UgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImVuZm9yY2UiKX19Y2xhc3MgRXF1YXRlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJlcXVhdGUiKTt0aGlzLmZvcmNlPWdldEludGVnZXIoe2RhdGE6ZS5mb3JjZSxkZWZhdWx0VmFsdWU6MSx2YWxpZGF0ZTplPT4wPT09ZX0pO3RoaXMuZnJvbT1lLmZyb218fCIiO3RoaXMudG89ZS50b3x8IiJ9fWNsYXNzIEVxdWF0ZVJhbmdlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJlcXVhdGVSYW5nZSIpO3RoaXMuZnJvbT1lLmZyb218fCIiO3RoaXMudG89ZS50b3x8IiI7dGhpcy5fdW5pY29kZVJhbmdlPWUudW5pY29kZVJhbmdlfHwiIn1nZXQgdW5pY29kZVJhbmdlKCl7Y29uc3QgZT1bXSx0PS9VXCsoWzAtOWEtZkEtRl0rKS8saT10aGlzLl91bmljb2RlUmFuZ2U7Zm9yKGxldCBhIG9mIGkuc3BsaXQoIiwiKS5tYXAoKGU9PmUudHJpbSgpKSkuZmlsdGVyKChlPT4hIWUpKSl7YT1hLnNwbGl0KCItIiwyKS5tYXAoKGU9Pntjb25zdCBpPWUubWF0Y2godCk7cmV0dXJuIGk/cGFyc2VJbnQoaVsxXSwxNik6MH0pKTsxPT09YS5sZW5ndGgmJmEucHVzaChhWzBdKTtlLnB1c2goYSl9cmV0dXJuIHNoYWRvdyh0aGlzLCJ1bmljb2RlUmFuZ2UiLGUpfX1jbGFzcyBFeGNsdWRlIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiZXhjbHVkZSIpfVtzcl0oKXt0aGlzW2VyXT10aGlzW2VyXS50cmltKCkuc3BsaXQoL1xzKy8pLmZpbHRlcigoZT0+ZSYmWyJjYWxjdWxhdGUiLCJjbG9zZSIsImVudGVyIiwiZXhpdCIsImluaXRpYWxpemUiLCJyZWFkeSIsInZhbGlkYXRlIl0uaW5jbHVkZXMoZSkpKX19Y2xhc3MgRXhjbHVkZU5TIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJleGNsdWRlTlMiKX19Y2xhc3MgRmxpcExhYmVsIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJmbGlwTGFiZWwiLFsidXNlUHJpbnRlclNldHRpbmciLCJvbiIsIm9mZiJdKX19Y2xhc3MgY29uZmlnX0ZvbnRJbmZvIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJmb250SW5mbyIsITApO3RoaXMuZW1iZWQ9bnVsbDt0aGlzLm1hcD1udWxsO3RoaXMuc3Vic2V0QmVsb3c9bnVsbDt0aGlzLmFsd2F5c0VtYmVkPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLmRlZmF1bHRUeXBlZmFjZT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5uZXZlckVtYmVkPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgRm9ybUZpZWxkRmlsbGluZyBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJmb3JtRmllbGRGaWxsaW5nIil9fWNsYXNzIEdyb3VwUGFyZW50IGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJncm91cFBhcmVudCIpfX1jbGFzcyBJZkVtcHR5IGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJpZkVtcHR5IixbImRhdGFWYWx1ZSIsImRhdGFHcm91cCIsImlnbm9yZSIsInJlbW92ZSJdKX19Y2xhc3MgSW5jbHVkZVhEUENvbnRlbnQgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImluY2x1ZGVYRFBDb250ZW50Iil9fWNsYXNzIEluY3JlbWVudGFsTG9hZCBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiaW5jcmVtZW50YWxMb2FkIixbIm5vbmUiLCJmb3J3YXJkT25seSJdKX19Y2xhc3MgSW5jcmVtZW50YWxNZXJnZSBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJpbmNyZW1lbnRhbE1lcmdlIil9fWNsYXNzIEludGVyYWN0aXZlIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImludGVyYWN0aXZlIil9fWNsYXNzIEpvZyBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwiam9nIixbInVzZVByaW50ZXJTZXR0aW5nIiwibm9uZSIsInBhZ2VTZXQiXSl9fWNsYXNzIExhYmVsUHJpbnRlciBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwibGFiZWxQcmludGVyIiwhMCk7dGhpcy5uYW1lPWdldFN0cmluZ09wdGlvbihlLm5hbWUsWyJ6cGwiLCJkcGwiLCJpcGwiLCJ0Y3BsIl0pO3RoaXMuYmF0Y2hPdXRwdXQ9bnVsbDt0aGlzLmZsaXBMYWJlbD1udWxsO3RoaXMuZm9udEluZm89bnVsbDt0aGlzLnhkYz1udWxsfX1jbGFzcyBMYXlvdXQgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImxheW91dCIsWyJwYWdpbmF0ZSIsInBhbmVsIl0pfX1jbGFzcyBMZXZlbCBleHRlbmRzIEludGVnZXJPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sImxldmVsIiwwLChlPT5lPjApKX19Y2xhc3MgTGluZWFyaXplZCBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJsaW5lYXJpemVkIil9fWNsYXNzIExvY2FsZSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwibG9jYWxlIil9fWNsYXNzIExvY2FsZVNldCBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwibG9jYWxlU2V0Iil9fWNsYXNzIExvZyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwibG9nIiwhMCk7dGhpcy5tb2RlPW51bGw7dGhpcy50aHJlc2hvbGQ9bnVsbDt0aGlzLnRvPW51bGw7dGhpcy51cmk9bnVsbH19Y2xhc3MgTWFwRWxlbWVudCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwibWFwIiwhMCk7dGhpcy5lcXVhdGU9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuZXF1YXRlUmFuZ2U9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBNZWRpdW1JbmZvIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJtZWRpdW1JbmZvIiwhMCk7dGhpcy5tYXA9bnVsbH19Y2xhc3MgY29uZmlnX01lc3NhZ2UgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sIm1lc3NhZ2UiLCEwKTt0aGlzLm1zZ0lkPW51bGw7dGhpcy5zZXZlcml0eT1udWxsfX1jbGFzcyBNZXNzYWdpbmcgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sIm1lc3NhZ2luZyIsITApO3RoaXMubWVzc2FnZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIE1vZGUgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sIm1vZGUiLFsiYXBwZW5kIiwib3ZlcndyaXRlIl0pfX1jbGFzcyBNb2RpZnlBbm5vdHMgZXh0ZW5kcyBPcHRpb24wMXtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwibW9kaWZ5QW5ub3RzIil9fWNsYXNzIE1zZ0lkIGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwibXNnSWQiLDEsKGU9PmU+PTEpKX19Y2xhc3MgTmFtZUF0dHIgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sIm5hbWVBdHRyIil9fWNsYXNzIE5ldmVyRW1iZWQgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJuZXZlckVtYmVkIil9fWNsYXNzIE51bWJlck9mQ29waWVzIGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwibnVtYmVyT2ZDb3BpZXMiLG51bGwsKGU9PmU+PTImJmU8PTUpKX19Y2xhc3MgT3BlbkFjdGlvbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwib3BlbkFjdGlvbiIsITApO3RoaXMuZGVzdGluYXRpb249bnVsbH19Y2xhc3MgT3V0cHV0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJvdXRwdXQiLCEwKTt0aGlzLnRvPW51bGw7dGhpcy50eXBlPW51bGw7dGhpcy51cmk9bnVsbH19Y2xhc3MgT3V0cHV0QmluIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJvdXRwdXRCaW4iKX19Y2xhc3MgT3V0cHV0WFNMIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJvdXRwdXRYU0wiLCEwKTt0aGlzLnVyaT1udWxsfX1jbGFzcyBPdmVycHJpbnQgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sIm92ZXJwcmludCIsWyJub25lIiwiYm90aCIsImRyYXciLCJmaWVsZCJdKX19Y2xhc3MgUGFja2V0cyBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwicGFja2V0cyIpfVtzcl0oKXsiKiIhPT10aGlzW2VyXSYmKHRoaXNbZXJdPXRoaXNbZXJdLnRyaW0oKS5zcGxpdCgvXHMrLykuZmlsdGVyKChlPT5bImNvbmZpZyIsImRhdGFzZXRzIiwidGVtcGxhdGUiLCJ4ZmRmIiwieHNsdCJdLmluY2x1ZGVzKGUpKSkpfX1jbGFzcyBQYWdlT2Zmc2V0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwYWdlT2Zmc2V0Iik7dGhpcy54PWdldEludGVnZXIoe2RhdGE6ZS54LGRlZmF1bHRWYWx1ZToidXNlWERDU2V0dGluZyIsdmFsaWRhdGU6ZT0+ITB9KTt0aGlzLnk9Z2V0SW50ZWdlcih7ZGF0YTplLnksZGVmYXVsdFZhbHVlOiJ1c2VYRENTZXR0aW5nIix2YWxpZGF0ZTplPT4hMH0pfX1jbGFzcyBQYWdlUmFuZ2UgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInBhZ2VSYW5nZSIpfVtzcl0oKXtjb25zdCBlPXRoaXNbZXJdLnRyaW0oKS5zcGxpdCgvXHMrLykubWFwKChlPT5wYXJzZUludChlLDEwKSkpLHQ9W107Zm9yKGxldCBpPTAsYT1lLmxlbmd0aDtpPGE7aSs9Mil0LnB1c2goZS5zbGljZShpLGkrMikpO3RoaXNbZXJdPXR9fWNsYXNzIFBhZ2luYXRpb24gZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInBhZ2luYXRpb24iLFsic2ltcGxleCIsImR1cGxleFNob3J0RWRnZSIsImR1cGxleExvbmdFZGdlIl0pfX1jbGFzcyBQYWdpbmF0aW9uT3ZlcnJpZGUgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInBhZ2luYXRpb25PdmVycmlkZSIsWyJub25lIiwiZm9yY2VEdXBsZXgiLCJmb3JjZUR1cGxleExvbmdFZGdlIiwiZm9yY2VEdXBsZXhTaG9ydEVkZ2UiLCJmb3JjZVNpbXBsZXgiXSl9fWNsYXNzIFBhcnQgZXh0ZW5kcyBJbnRlZ2VyT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwYXJ0IiwxLChlPT4hMSkpfX1jbGFzcyBQY2wgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInBjbCIsITApO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMuYmF0Y2hPdXRwdXQ9bnVsbDt0aGlzLmZvbnRJbmZvPW51bGw7dGhpcy5qb2c9bnVsbDt0aGlzLm1lZGl1bUluZm89bnVsbDt0aGlzLm91dHB1dEJpbj1udWxsO3RoaXMucGFnZU9mZnNldD1udWxsO3RoaXMuc3RhcGxlPW51bGw7dGhpcy54ZGM9bnVsbH19Y2xhc3MgUGRmIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwZGYiLCEwKTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLmFkb2JlRXh0ZW5zaW9uTGV2ZWw9bnVsbDt0aGlzLmJhdGNoT3V0cHV0PW51bGw7dGhpcy5jb21wcmVzc2lvbj1udWxsO3RoaXMuY3JlYXRvcj1udWxsO3RoaXMuZW5jcnlwdGlvbj1udWxsO3RoaXMuZm9udEluZm89bnVsbDt0aGlzLmludGVyYWN0aXZlPW51bGw7dGhpcy5saW5lYXJpemVkPW51bGw7dGhpcy5vcGVuQWN0aW9uPW51bGw7dGhpcy5wZGZhPW51bGw7dGhpcy5wcm9kdWNlcj1udWxsO3RoaXMucmVuZGVyUG9saWN5PW51bGw7dGhpcy5zY3JpcHRNb2RlbD1udWxsO3RoaXMuc2lsZW50UHJpbnQ9bnVsbDt0aGlzLnN1Ym1pdEZvcm1hdD1udWxsO3RoaXMudGFnZ2VkPW51bGw7dGhpcy52ZXJzaW9uPW51bGw7dGhpcy52aWV3ZXJQcmVmZXJlbmNlcz1udWxsO3RoaXMueGRjPW51bGx9fWNsYXNzIFBkZmEgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInBkZmEiLCEwKTt0aGlzLmFtZD1udWxsO3RoaXMuY29uZm9ybWFuY2U9bnVsbDt0aGlzLmluY2x1ZGVYRFBDb250ZW50PW51bGw7dGhpcy5wYXJ0PW51bGx9fWNsYXNzIFBlcm1pc3Npb25zIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwZXJtaXNzaW9ucyIsITApO3RoaXMuYWNjZXNzaWJsZUNvbnRlbnQ9bnVsbDt0aGlzLmNoYW5nZT1udWxsO3RoaXMuY29udGVudENvcHk9bnVsbDt0aGlzLmRvY3VtZW50QXNzZW1ibHk9bnVsbDt0aGlzLmZvcm1GaWVsZEZpbGxpbmc9bnVsbDt0aGlzLm1vZGlmeUFubm90cz1udWxsO3RoaXMucGxhaW50ZXh0TWV0YWRhdGE9bnVsbDt0aGlzLnByaW50PW51bGw7dGhpcy5wcmludEhpZ2hRdWFsaXR5PW51bGx9fWNsYXNzIFBpY2tUcmF5QnlQREZTaXplIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInBpY2tUcmF5QnlQREZTaXplIil9fWNsYXNzIGNvbmZpZ19QaWN0dXJlIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwaWN0dXJlIil9fWNsYXNzIFBsYWludGV4dE1ldGFkYXRhIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInBsYWludGV4dE1ldGFkYXRhIil9fWNsYXNzIFByZXNlbmNlIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwcmVzZW5jZSIsWyJwcmVzZXJ2ZSIsImRpc3NvbHZlIiwiZGlzc29sdmVTdHJ1Y3R1cmUiLCJpZ25vcmUiLCJyZW1vdmUiXSl9fWNsYXNzIFByZXNlbnQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInByZXNlbnQiLCEwKTt0aGlzLmJlaGF2aW9yT3ZlcnJpZGU9bnVsbDt0aGlzLmNhY2hlPW51bGw7dGhpcy5jb21tb249bnVsbDt0aGlzLmNvcGllcz1udWxsO3RoaXMuZGVzdGluYXRpb249bnVsbDt0aGlzLmluY3JlbWVudGFsTWVyZ2U9bnVsbDt0aGlzLmxheW91dD1udWxsO3RoaXMub3V0cHV0PW51bGw7dGhpcy5vdmVycHJpbnQ9bnVsbDt0aGlzLnBhZ2luYXRpb249bnVsbDt0aGlzLnBhZ2luYXRpb25PdmVycmlkZT1udWxsO3RoaXMuc2NyaXB0PW51bGw7dGhpcy52YWxpZGF0ZT1udWxsO3RoaXMueGRwPW51bGw7dGhpcy5kcml2ZXI9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMubGFiZWxQcmludGVyPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnBjbD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy5wZGY9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMucHM9bmV3IFhGQU9iamVjdEFycmF5O3RoaXMuc3VibWl0VXJsPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLndlYkNsaWVudD1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy56cGw9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBQcmludCBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwcmludCIpfX1jbGFzcyBQcmludEhpZ2hRdWFsaXR5IGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInByaW50SGlnaFF1YWxpdHkiKX19Y2xhc3MgUHJpbnRTY2FsaW5nIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwcmludFNjYWxpbmciLFsiYXBwZGVmYXVsdCIsIm5vU2NhbGluZyJdKX19Y2xhc3MgUHJpbnRlck5hbWUgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInByaW50ZXJOYW1lIil9fWNsYXNzIFByb2R1Y2VyIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJwcm9kdWNlciIpfX1jbGFzcyBQcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwicHMiLCEwKTt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLmJhdGNoT3V0cHV0PW51bGw7dGhpcy5mb250SW5mbz1udWxsO3RoaXMuam9nPW51bGw7dGhpcy5tZWRpdW1JbmZvPW51bGw7dGhpcy5vdXRwdXRCaW49bnVsbDt0aGlzLnN0YXBsZT1udWxsO3RoaXMueGRjPW51bGx9fWNsYXNzIFJhbmdlIGV4dGVuZHMgQ29udGVudE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwicmFuZ2UiKX1bc3JdKCl7dGhpc1tlcl09dGhpc1tlcl0udHJpbSgpLnNwbGl0KC9ccyosXHMqLywyKS5tYXAoKGU9PmUuc3BsaXQoIi0iKS5tYXAoKGU9PnBhcnNlSW50KGUudHJpbSgpLDEwKSkpKSkuZmlsdGVyKChlPT5lLmV2ZXJ5KChlPT4haXNOYU4oZSkpKSkpLm1hcCgoZT0+ezE9PT1lLmxlbmd0aCYmZS5wdXNoKGVbMF0pO3JldHVybiBlfSkpfX1jbGFzcyBSZWNvcmQgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJyZWNvcmQiKX1bc3JdKCl7dGhpc1tlcl09dGhpc1tlcl0udHJpbSgpO2NvbnN0IGU9cGFyc2VJbnQodGhpc1tlcl0sMTApOyFpc05hTihlKSYmZT49MCYmKHRoaXNbZXJdPWUpfX1jbGFzcyBSZWxldmFudCBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInJlbGV2YW50Iil9W3NyXSgpe3RoaXNbZXJdPXRoaXNbZXJdLnRyaW0oKS5zcGxpdCgvXHMrLyl9fWNsYXNzIFJlbmFtZSBleHRlbmRzIENvbnRlbnRPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInJlbmFtZSIpfVtzcl0oKXt0aGlzW2VyXT10aGlzW2VyXS50cmltKCk7KHRoaXNbZXJdLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgieG1sIil8fG5ldyBSZWdFeHAoIltcXHB7TH1fXVtcXHB7TH1cXGQuX1xccHtNfS1dKiIsInUiKS50ZXN0KHRoaXNbZXJdKSkmJndhcm4oIlhGQSAtIFJlbmFtZTogaW52YWxpZCBYRkEgbmFtZSIpfX1jbGFzcyBSZW5kZXJQb2xpY3kgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInJlbmRlclBvbGljeSIsWyJzZXJ2ZXIiLCJjbGllbnQiXSl9fWNsYXNzIFJ1blNjcmlwdHMgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInJ1blNjcmlwdHMiLFsiYm90aCIsImNsaWVudCIsIm5vbmUiLCJzZXJ2ZXIiXSl9fWNsYXNzIGNvbmZpZ19TY3JpcHQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInNjcmlwdCIsITApO3RoaXMuY3VycmVudFBhZ2U9bnVsbDt0aGlzLmV4Y2x1ZGU9bnVsbDt0aGlzLnJ1blNjcmlwdHM9bnVsbH19Y2xhc3MgU2NyaXB0TW9kZWwgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInNjcmlwdE1vZGVsIixbIlhGQSIsIm5vbmUiXSl9fWNsYXNzIFNldmVyaXR5IGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJzZXZlcml0eSIsWyJpZ25vcmUiLCJlcnJvciIsImluZm9ybWF0aW9uIiwidHJhY2UiLCJ3YXJuaW5nIl0pfX1jbGFzcyBTaWxlbnRQcmludCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwic2lsZW50UHJpbnQiLCEwKTt0aGlzLmFkZFNpbGVudFByaW50PW51bGw7dGhpcy5wcmludGVyTmFtZT1udWxsfX1jbGFzcyBTdGFwbGUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInN0YXBsZSIpO3RoaXMubW9kZT1nZXRTdHJpbmdPcHRpb24oZS5tb2RlLFsidXNlUHJpbnRlclNldHRpbmciLCJvbiIsIm9mZiJdKX19Y2xhc3MgU3RhcnROb2RlIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJzdGFydE5vZGUiKX19Y2xhc3MgU3RhcnRQYWdlIGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwic3RhcnRQYWdlIiwwLChlPT4hMCkpfX1jbGFzcyBTdWJtaXRGb3JtYXQgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInN1Ym1pdEZvcm1hdCIsWyJodG1sIiwiZGVsZWdhdGUiLCJmZGYiLCJ4bWwiLCJwZGYiXSl9fWNsYXNzIFN1Ym1pdFVybCBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwic3VibWl0VXJsIil9fWNsYXNzIFN1YnNldEJlbG93IGV4dGVuZHMgSW50ZWdlck9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwic3Vic2V0QmVsb3ciLDEwMCwoZT0+ZT49MCYmZTw9MTAwKSl9fWNsYXNzIFN1cHByZXNzQmFubmVyIGV4dGVuZHMgT3B0aW9uMDF7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInN1cHByZXNzQmFubmVyIil9fWNsYXNzIFRhZ2dlZCBleHRlbmRzIE9wdGlvbjAxe2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJ0YWdnZWQiKX19Y2xhc3MgY29uZmlnX1RlbXBsYXRlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJ0ZW1wbGF0ZSIsITApO3RoaXMuYmFzZT1udWxsO3RoaXMucmVsZXZhbnQ9bnVsbDt0aGlzLnN0YXJ0UGFnZT1udWxsO3RoaXMudXJpPW51bGw7dGhpcy54c2w9bnVsbH19Y2xhc3MgVGhyZXNob2xkIGV4dGVuZHMgT3B0aW9uT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJ0aHJlc2hvbGQiLFsidHJhY2UiLCJlcnJvciIsImluZm9ybWF0aW9uIiwid2FybmluZyJdKX19Y2xhc3MgVG8gZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInRvIixbIm51bGwiLCJtZW1vcnkiLCJzdGRlcnIiLCJzdGRvdXQiLCJzeXN0ZW0iLCJ1cmkiXSl9fWNsYXNzIFRlbXBsYXRlQ2FjaGUgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInRlbXBsYXRlQ2FjaGUiKTt0aGlzLm1heEVudHJpZXM9Z2V0SW50ZWdlcih7ZGF0YTplLm1heEVudHJpZXMsZGVmYXVsdFZhbHVlOjUsdmFsaWRhdGU6ZT0+ZT49MH0pfX1jbGFzcyBUcmFjZSBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwidHJhY2UiLCEwKTt0aGlzLmFyZWE9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBUcmFuc2Zvcm0gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInRyYW5zZm9ybSIsITApO3RoaXMuZ3JvdXBQYXJlbnQ9bnVsbDt0aGlzLmlmRW1wdHk9bnVsbDt0aGlzLm5hbWVBdHRyPW51bGw7dGhpcy5waWN0dXJlPW51bGw7dGhpcy5wcmVzZW5jZT1udWxsO3RoaXMucmVuYW1lPW51bGw7dGhpcy53aGl0ZXNwYWNlPW51bGx9fWNsYXNzIFR5cGUgZXh0ZW5kcyBPcHRpb25PYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInR5cGUiLFsibm9uZSIsImFzY2lpODUiLCJhc2NpaUhleCIsImNjaXR0ZmF4IiwiZmxhdGUiLCJsenciLCJydW5MZW5ndGgiLCJuYXRpdmUiLCJ4ZHAiLCJtZXJnZWRYRFAiXSl9fWNsYXNzIFVyaSBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwidXJpIil9fWNsYXNzIGNvbmZpZ19WYWxpZGF0ZSBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwidmFsaWRhdGUiLFsicHJlU3VibWl0IiwicHJlUHJpbnQiLCJwcmVFeGVjdXRlIiwicHJlU2F2ZSJdKX19Y2xhc3MgVmFsaWRhdGVBcHByb3ZhbFNpZ25hdHVyZXMgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJ2YWxpZGF0ZUFwcHJvdmFsU2lnbmF0dXJlcyIpfVtzcl0oKXt0aGlzW2VyXT10aGlzW2VyXS50cmltKCkuc3BsaXQoL1xzKy8pLmZpbHRlcigoZT0+WyJkb2NSZWFkeSIsInBvc3RTaWduIl0uaW5jbHVkZXMoZSkpKX19Y2xhc3MgVmFsaWRhdGlvbk1lc3NhZ2luZyBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwidmFsaWRhdGlvbk1lc3NhZ2luZyIsWyJhbGxNZXNzYWdlc0luZGl2aWR1YWxseSIsImFsbE1lc3NhZ2VzVG9nZXRoZXIiLCJmaXJzdE1lc3NhZ2VPbmx5Iiwibm9NZXNzYWdlcyJdKX19Y2xhc3MgVmVyc2lvbiBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwidmVyc2lvbiIsWyIxLjciLCIxLjYiLCIxLjUiLCIxLjQiLCIxLjMiLCIxLjIiXSl9fWNsYXNzIFZlcnNpb25Db250cm9sIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJWZXJzaW9uQ29udHJvbCIpO3RoaXMub3V0cHV0QmVsb3c9Z2V0U3RyaW5nT3B0aW9uKGUub3V0cHV0QmVsb3csWyJ3YXJuIiwiZXJyb3IiLCJ1cGRhdGUiXSk7dGhpcy5zb3VyY2VBYm92ZT1nZXRTdHJpbmdPcHRpb24oZS5zb3VyY2VBYm92ZSxbIndhcm4iLCJlcnJvciJdKTt0aGlzLnNvdXJjZUJlbG93PWdldFN0cmluZ09wdGlvbihlLnNvdXJjZUJlbG93LFsidXBkYXRlIiwibWFpbnRhaW4iXSl9fWNsYXNzIFZpZXdlclByZWZlcmVuY2VzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJ2aWV3ZXJQcmVmZXJlbmNlcyIsITApO3RoaXMuQURCRV9KU0NvbnNvbGU9bnVsbDt0aGlzLkFEQkVfSlNEZWJ1Z2dlcj1udWxsO3RoaXMuYWRkVmlld2VyUHJlZmVyZW5jZXM9bnVsbDt0aGlzLmR1cGxleE9wdGlvbj1udWxsO3RoaXMuZW5mb3JjZT1udWxsO3RoaXMubnVtYmVyT2ZDb3BpZXM9bnVsbDt0aGlzLnBhZ2VSYW5nZT1udWxsO3RoaXMucGlja1RyYXlCeVBERlNpemU9bnVsbDt0aGlzLnByaW50U2NhbGluZz1udWxsfX1jbGFzcyBXZWJDbGllbnQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sIndlYkNsaWVudCIsITApO3RoaXMubmFtZT1lLm5hbWU/ZS5uYW1lLnRyaW0oKToiIjt0aGlzLmZvbnRJbmZvPW51bGw7dGhpcy54ZGM9bnVsbH19Y2xhc3MgV2hpdGVzcGFjZSBleHRlbmRzIE9wdGlvbk9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihxbiwid2hpdGVzcGFjZSIsWyJwcmVzZXJ2ZSIsImx0cmltIiwibm9ybWFsaXplIiwicnRyaW0iLCJ0cmltIl0pfX1jbGFzcyBXaW5kb3cgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJ3aW5kb3ciKX1bc3JdKCl7Y29uc3QgZT10aGlzW2VyXS50cmltKCkuc3BsaXQoL1xzKixccyovLDIpLm1hcCgoZT0+cGFyc2VJbnQoZSwxMCkpKTtpZihlLnNvbWUoKGU9PmlzTmFOKGUpKSkpdGhpc1tlcl09WzAsMF07ZWxzZXsxPT09ZS5sZW5ndGgmJmUucHVzaChlWzBdKTt0aGlzW2VyXT1lfX19Y2xhc3MgWGRjIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKHFuLCJ4ZGMiLCEwKTt0aGlzLnVyaT1uZXcgWEZBT2JqZWN0QXJyYXk7dGhpcy54c2w9bmV3IFhGQU9iamVjdEFycmF5fX1jbGFzcyBYZHAgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInhkcCIsITApO3RoaXMucGFja2V0cz1udWxsfX1jbGFzcyBYc2wgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInhzbCIsITApO3RoaXMuZGVidWc9bnVsbDt0aGlzLnVyaT1udWxsfX1jbGFzcyBacGwgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIocW4sInpwbCIsITApO3RoaXMubmFtZT1lLm5hbWU/ZS5uYW1lLnRyaW0oKToiIjt0aGlzLmJhdGNoT3V0cHV0PW51bGw7dGhpcy5mbGlwTGFiZWw9bnVsbDt0aGlzLmZvbnRJbmZvPW51bGw7dGhpcy54ZGM9bnVsbH19Y2xhc3MgQ29uZmlnTmFtZXNwYWNle3N0YXRpY1tvbl0oZSx0KXtpZihDb25maWdOYW1lc3BhY2UuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIENvbmZpZ05hbWVzcGFjZVtlXSh0KX1zdGF0aWMgYWNyb2JhdChlKXtyZXR1cm4gbmV3IEFjcm9iYXQoZSl9c3RhdGljIGFjcm9iYXQ3KGUpe3JldHVybiBuZXcgQWNyb2JhdDcoZSl9c3RhdGljIEFEQkVfSlNDb25zb2xlKGUpe3JldHVybiBuZXcgQURCRV9KU0NvbnNvbGUoZSl9c3RhdGljIEFEQkVfSlNEZWJ1Z2dlcihlKXtyZXR1cm4gbmV3IEFEQkVfSlNEZWJ1Z2dlcihlKX1zdGF0aWMgYWRkU2lsZW50UHJpbnQoZSl7cmV0dXJuIG5ldyBBZGRTaWxlbnRQcmludChlKX1zdGF0aWMgYWRkVmlld2VyUHJlZmVyZW5jZXMoZSl7cmV0dXJuIG5ldyBBZGRWaWV3ZXJQcmVmZXJlbmNlcyhlKX1zdGF0aWMgYWRqdXN0RGF0YShlKXtyZXR1cm4gbmV3IEFkanVzdERhdGEoZSl9c3RhdGljIGFkb2JlRXh0ZW5zaW9uTGV2ZWwoZSl7cmV0dXJuIG5ldyBBZG9iZUV4dGVuc2lvbkxldmVsKGUpfXN0YXRpYyBhZ2VudChlKXtyZXR1cm4gbmV3IEFnZW50KGUpfXN0YXRpYyBhbHdheXNFbWJlZChlKXtyZXR1cm4gbmV3IEFsd2F5c0VtYmVkKGUpfXN0YXRpYyBhbWQoZSl7cmV0dXJuIG5ldyBBbWQoZSl9c3RhdGljIGFyZWEoZSl7cmV0dXJuIG5ldyBjb25maWdfQXJlYShlKX1zdGF0aWMgYXR0cmlidXRlcyhlKXtyZXR1cm4gbmV3IEF0dHJpYnV0ZXMoZSl9c3RhdGljIGF1dG9TYXZlKGUpe3JldHVybiBuZXcgQXV0b1NhdmUoZSl9c3RhdGljIGJhc2UoZSl7cmV0dXJuIG5ldyBCYXNlKGUpfXN0YXRpYyBiYXRjaE91dHB1dChlKXtyZXR1cm4gbmV3IEJhdGNoT3V0cHV0KGUpfXN0YXRpYyBiZWhhdmlvck92ZXJyaWRlKGUpe3JldHVybiBuZXcgQmVoYXZpb3JPdmVycmlkZShlKX1zdGF0aWMgY2FjaGUoZSl7cmV0dXJuIG5ldyBDYWNoZShlKX1zdGF0aWMgY2hhbmdlKGUpe3JldHVybiBuZXcgQ2hhbmdlKGUpfXN0YXRpYyBjb21tb24oZSl7cmV0dXJuIG5ldyBDb21tb24oZSl9c3RhdGljIGNvbXByZXNzKGUpe3JldHVybiBuZXcgQ29tcHJlc3MoZSl9c3RhdGljIGNvbXByZXNzTG9naWNhbFN0cnVjdHVyZShlKXtyZXR1cm4gbmV3IENvbXByZXNzTG9naWNhbFN0cnVjdHVyZShlKX1zdGF0aWMgY29tcHJlc3NPYmplY3RTdHJlYW0oZSl7cmV0dXJuIG5ldyBDb21wcmVzc09iamVjdFN0cmVhbShlKX1zdGF0aWMgY29tcHJlc3Npb24oZSl7cmV0dXJuIG5ldyBDb21wcmVzc2lvbihlKX1zdGF0aWMgY29uZmlnKGUpe3JldHVybiBuZXcgQ29uZmlnKGUpfXN0YXRpYyBjb25mb3JtYW5jZShlKXtyZXR1cm4gbmV3IENvbmZvcm1hbmNlKGUpfXN0YXRpYyBjb250ZW50Q29weShlKXtyZXR1cm4gbmV3IENvbnRlbnRDb3B5KGUpfXN0YXRpYyBjb3BpZXMoZSl7cmV0dXJuIG5ldyBDb3BpZXMoZSl9c3RhdGljIGNyZWF0b3IoZSl7cmV0dXJuIG5ldyBDcmVhdG9yKGUpfXN0YXRpYyBjdXJyZW50UGFnZShlKXtyZXR1cm4gbmV3IEN1cnJlbnRQYWdlKGUpfXN0YXRpYyBkYXRhKGUpe3JldHVybiBuZXcgRGF0YShlKX1zdGF0aWMgZGVidWcoZSl7cmV0dXJuIG5ldyBEZWJ1ZyhlKX1zdGF0aWMgZGVmYXVsdFR5cGVmYWNlKGUpe3JldHVybiBuZXcgRGVmYXVsdFR5cGVmYWNlKGUpfXN0YXRpYyBkZXN0aW5hdGlvbihlKXtyZXR1cm4gbmV3IERlc3RpbmF0aW9uKGUpfXN0YXRpYyBkb2N1bWVudEFzc2VtYmx5KGUpe3JldHVybiBuZXcgRG9jdW1lbnRBc3NlbWJseShlKX1zdGF0aWMgZHJpdmVyKGUpe3JldHVybiBuZXcgRHJpdmVyKGUpfXN0YXRpYyBkdXBsZXhPcHRpb24oZSl7cmV0dXJuIG5ldyBEdXBsZXhPcHRpb24oZSl9c3RhdGljIGR5bmFtaWNSZW5kZXIoZSl7cmV0dXJuIG5ldyBEeW5hbWljUmVuZGVyKGUpfXN0YXRpYyBlbWJlZChlKXtyZXR1cm4gbmV3IEVtYmVkKGUpfXN0YXRpYyBlbmNyeXB0KGUpe3JldHVybiBuZXcgY29uZmlnX0VuY3J5cHQoZSl9c3RhdGljIGVuY3J5cHRpb24oZSl7cmV0dXJuIG5ldyBjb25maWdfRW5jcnlwdGlvbihlKX1zdGF0aWMgZW5jcnlwdGlvbkxldmVsKGUpe3JldHVybiBuZXcgRW5jcnlwdGlvbkxldmVsKGUpfXN0YXRpYyBlbmZvcmNlKGUpe3JldHVybiBuZXcgRW5mb3JjZShlKX1zdGF0aWMgZXF1YXRlKGUpe3JldHVybiBuZXcgRXF1YXRlKGUpfXN0YXRpYyBlcXVhdGVSYW5nZShlKXtyZXR1cm4gbmV3IEVxdWF0ZVJhbmdlKGUpfXN0YXRpYyBleGNsdWRlKGUpe3JldHVybiBuZXcgRXhjbHVkZShlKX1zdGF0aWMgZXhjbHVkZU5TKGUpe3JldHVybiBuZXcgRXhjbHVkZU5TKGUpfXN0YXRpYyBmbGlwTGFiZWwoZSl7cmV0dXJuIG5ldyBGbGlwTGFiZWwoZSl9c3RhdGljIGZvbnRJbmZvKGUpe3JldHVybiBuZXcgY29uZmlnX0ZvbnRJbmZvKGUpfXN0YXRpYyBmb3JtRmllbGRGaWxsaW5nKGUpe3JldHVybiBuZXcgRm9ybUZpZWxkRmlsbGluZyhlKX1zdGF0aWMgZ3JvdXBQYXJlbnQoZSl7cmV0dXJuIG5ldyBHcm91cFBhcmVudChlKX1zdGF0aWMgaWZFbXB0eShlKXtyZXR1cm4gbmV3IElmRW1wdHkoZSl9c3RhdGljIGluY2x1ZGVYRFBDb250ZW50KGUpe3JldHVybiBuZXcgSW5jbHVkZVhEUENvbnRlbnQoZSl9c3RhdGljIGluY3JlbWVudGFsTG9hZChlKXtyZXR1cm4gbmV3IEluY3JlbWVudGFsTG9hZChlKX1zdGF0aWMgaW5jcmVtZW50YWxNZXJnZShlKXtyZXR1cm4gbmV3IEluY3JlbWVudGFsTWVyZ2UoZSl9c3RhdGljIGludGVyYWN0aXZlKGUpe3JldHVybiBuZXcgSW50ZXJhY3RpdmUoZSl9c3RhdGljIGpvZyhlKXtyZXR1cm4gbmV3IEpvZyhlKX1zdGF0aWMgbGFiZWxQcmludGVyKGUpe3JldHVybiBuZXcgTGFiZWxQcmludGVyKGUpfXN0YXRpYyBsYXlvdXQoZSl7cmV0dXJuIG5ldyBMYXlvdXQoZSl9c3RhdGljIGxldmVsKGUpe3JldHVybiBuZXcgTGV2ZWwoZSl9c3RhdGljIGxpbmVhcml6ZWQoZSl7cmV0dXJuIG5ldyBMaW5lYXJpemVkKGUpfXN0YXRpYyBsb2NhbGUoZSl7cmV0dXJuIG5ldyBMb2NhbGUoZSl9c3RhdGljIGxvY2FsZVNldChlKXtyZXR1cm4gbmV3IExvY2FsZVNldChlKX1zdGF0aWMgbG9nKGUpe3JldHVybiBuZXcgTG9nKGUpfXN0YXRpYyBtYXAoZSl7cmV0dXJuIG5ldyBNYXBFbGVtZW50KGUpfXN0YXRpYyBtZWRpdW1JbmZvKGUpe3JldHVybiBuZXcgTWVkaXVtSW5mbyhlKX1zdGF0aWMgbWVzc2FnZShlKXtyZXR1cm4gbmV3IGNvbmZpZ19NZXNzYWdlKGUpfXN0YXRpYyBtZXNzYWdpbmcoZSl7cmV0dXJuIG5ldyBNZXNzYWdpbmcoZSl9c3RhdGljIG1vZGUoZSl7cmV0dXJuIG5ldyBNb2RlKGUpfXN0YXRpYyBtb2RpZnlBbm5vdHMoZSl7cmV0dXJuIG5ldyBNb2RpZnlBbm5vdHMoZSl9c3RhdGljIG1zZ0lkKGUpe3JldHVybiBuZXcgTXNnSWQoZSl9c3RhdGljIG5hbWVBdHRyKGUpe3JldHVybiBuZXcgTmFtZUF0dHIoZSl9c3RhdGljIG5ldmVyRW1iZWQoZSl7cmV0dXJuIG5ldyBOZXZlckVtYmVkKGUpfXN0YXRpYyBudW1iZXJPZkNvcGllcyhlKXtyZXR1cm4gbmV3IE51bWJlck9mQ29waWVzKGUpfXN0YXRpYyBvcGVuQWN0aW9uKGUpe3JldHVybiBuZXcgT3BlbkFjdGlvbihlKX1zdGF0aWMgb3V0cHV0KGUpe3JldHVybiBuZXcgT3V0cHV0KGUpfXN0YXRpYyBvdXRwdXRCaW4oZSl7cmV0dXJuIG5ldyBPdXRwdXRCaW4oZSl9c3RhdGljIG91dHB1dFhTTChlKXtyZXR1cm4gbmV3IE91dHB1dFhTTChlKX1zdGF0aWMgb3ZlcnByaW50KGUpe3JldHVybiBuZXcgT3ZlcnByaW50KGUpfXN0YXRpYyBwYWNrZXRzKGUpe3JldHVybiBuZXcgUGFja2V0cyhlKX1zdGF0aWMgcGFnZU9mZnNldChlKXtyZXR1cm4gbmV3IFBhZ2VPZmZzZXQoZSl9c3RhdGljIHBhZ2VSYW5nZShlKXtyZXR1cm4gbmV3IFBhZ2VSYW5nZShlKX1zdGF0aWMgcGFnaW5hdGlvbihlKXtyZXR1cm4gbmV3IFBhZ2luYXRpb24oZSl9c3RhdGljIHBhZ2luYXRpb25PdmVycmlkZShlKXtyZXR1cm4gbmV3IFBhZ2luYXRpb25PdmVycmlkZShlKX1zdGF0aWMgcGFydChlKXtyZXR1cm4gbmV3IFBhcnQoZSl9c3RhdGljIHBjbChlKXtyZXR1cm4gbmV3IFBjbChlKX1zdGF0aWMgcGRmKGUpe3JldHVybiBuZXcgUGRmKGUpfXN0YXRpYyBwZGZhKGUpe3JldHVybiBuZXcgUGRmYShlKX1zdGF0aWMgcGVybWlzc2lvbnMoZSl7cmV0dXJuIG5ldyBQZXJtaXNzaW9ucyhlKX1zdGF0aWMgcGlja1RyYXlCeVBERlNpemUoZSl7cmV0dXJuIG5ldyBQaWNrVHJheUJ5UERGU2l6ZShlKX1zdGF0aWMgcGljdHVyZShlKXtyZXR1cm4gbmV3IGNvbmZpZ19QaWN0dXJlKGUpfXN0YXRpYyBwbGFpbnRleHRNZXRhZGF0YShlKXtyZXR1cm4gbmV3IFBsYWludGV4dE1ldGFkYXRhKGUpfXN0YXRpYyBwcmVzZW5jZShlKXtyZXR1cm4gbmV3IFByZXNlbmNlKGUpfXN0YXRpYyBwcmVzZW50KGUpe3JldHVybiBuZXcgUHJlc2VudChlKX1zdGF0aWMgcHJpbnQoZSl7cmV0dXJuIG5ldyBQcmludChlKX1zdGF0aWMgcHJpbnRIaWdoUXVhbGl0eShlKXtyZXR1cm4gbmV3IFByaW50SGlnaFF1YWxpdHkoZSl9c3RhdGljIHByaW50U2NhbGluZyhlKXtyZXR1cm4gbmV3IFByaW50U2NhbGluZyhlKX1zdGF0aWMgcHJpbnRlck5hbWUoZSl7cmV0dXJuIG5ldyBQcmludGVyTmFtZShlKX1zdGF0aWMgcHJvZHVjZXIoZSl7cmV0dXJuIG5ldyBQcm9kdWNlcihlKX1zdGF0aWMgcHMoZSl7cmV0dXJuIG5ldyBQcyhlKX1zdGF0aWMgcmFuZ2UoZSl7cmV0dXJuIG5ldyBSYW5nZShlKX1zdGF0aWMgcmVjb3JkKGUpe3JldHVybiBuZXcgUmVjb3JkKGUpfXN0YXRpYyByZWxldmFudChlKXtyZXR1cm4gbmV3IFJlbGV2YW50KGUpfXN0YXRpYyByZW5hbWUoZSl7cmV0dXJuIG5ldyBSZW5hbWUoZSl9c3RhdGljIHJlbmRlclBvbGljeShlKXtyZXR1cm4gbmV3IFJlbmRlclBvbGljeShlKX1zdGF0aWMgcnVuU2NyaXB0cyhlKXtyZXR1cm4gbmV3IFJ1blNjcmlwdHMoZSl9c3RhdGljIHNjcmlwdChlKXtyZXR1cm4gbmV3IGNvbmZpZ19TY3JpcHQoZSl9c3RhdGljIHNjcmlwdE1vZGVsKGUpe3JldHVybiBuZXcgU2NyaXB0TW9kZWwoZSl9c3RhdGljIHNldmVyaXR5KGUpe3JldHVybiBuZXcgU2V2ZXJpdHkoZSl9c3RhdGljIHNpbGVudFByaW50KGUpe3JldHVybiBuZXcgU2lsZW50UHJpbnQoZSl9c3RhdGljIHN0YXBsZShlKXtyZXR1cm4gbmV3IFN0YXBsZShlKX1zdGF0aWMgc3RhcnROb2RlKGUpe3JldHVybiBuZXcgU3RhcnROb2RlKGUpfXN0YXRpYyBzdGFydFBhZ2UoZSl7cmV0dXJuIG5ldyBTdGFydFBhZ2UoZSl9c3RhdGljIHN1Ym1pdEZvcm1hdChlKXtyZXR1cm4gbmV3IFN1Ym1pdEZvcm1hdChlKX1zdGF0aWMgc3VibWl0VXJsKGUpe3JldHVybiBuZXcgU3VibWl0VXJsKGUpfXN0YXRpYyBzdWJzZXRCZWxvdyhlKXtyZXR1cm4gbmV3IFN1YnNldEJlbG93KGUpfXN0YXRpYyBzdXBwcmVzc0Jhbm5lcihlKXtyZXR1cm4gbmV3IFN1cHByZXNzQmFubmVyKGUpfXN0YXRpYyB0YWdnZWQoZSl7cmV0dXJuIG5ldyBUYWdnZWQoZSl9c3RhdGljIHRlbXBsYXRlKGUpe3JldHVybiBuZXcgY29uZmlnX1RlbXBsYXRlKGUpfXN0YXRpYyB0ZW1wbGF0ZUNhY2hlKGUpe3JldHVybiBuZXcgVGVtcGxhdGVDYWNoZShlKX1zdGF0aWMgdGhyZXNob2xkKGUpe3JldHVybiBuZXcgVGhyZXNob2xkKGUpfXN0YXRpYyB0byhlKXtyZXR1cm4gbmV3IFRvKGUpfXN0YXRpYyB0cmFjZShlKXtyZXR1cm4gbmV3IFRyYWNlKGUpfXN0YXRpYyB0cmFuc2Zvcm0oZSl7cmV0dXJuIG5ldyBUcmFuc2Zvcm0oZSl9c3RhdGljIHR5cGUoZSl7cmV0dXJuIG5ldyBUeXBlKGUpfXN0YXRpYyB1cmkoZSl7cmV0dXJuIG5ldyBVcmkoZSl9c3RhdGljIHZhbGlkYXRlKGUpe3JldHVybiBuZXcgY29uZmlnX1ZhbGlkYXRlKGUpfXN0YXRpYyB2YWxpZGF0ZUFwcHJvdmFsU2lnbmF0dXJlcyhlKXtyZXR1cm4gbmV3IFZhbGlkYXRlQXBwcm92YWxTaWduYXR1cmVzKGUpfXN0YXRpYyB2YWxpZGF0aW9uTWVzc2FnaW5nKGUpe3JldHVybiBuZXcgVmFsaWRhdGlvbk1lc3NhZ2luZyhlKX1zdGF0aWMgdmVyc2lvbihlKXtyZXR1cm4gbmV3IFZlcnNpb24oZSl9c3RhdGljIHZlcnNpb25Db250cm9sKGUpe3JldHVybiBuZXcgVmVyc2lvbkNvbnRyb2woZSl9c3RhdGljIHZpZXdlclByZWZlcmVuY2VzKGUpe3JldHVybiBuZXcgVmlld2VyUHJlZmVyZW5jZXMoZSl9c3RhdGljIHdlYkNsaWVudChlKXtyZXR1cm4gbmV3IFdlYkNsaWVudChlKX1zdGF0aWMgd2hpdGVzcGFjZShlKXtyZXR1cm4gbmV3IFdoaXRlc3BhY2UoZSl9c3RhdGljIHdpbmRvdyhlKXtyZXR1cm4gbmV3IFdpbmRvdyhlKX1zdGF0aWMgeGRjKGUpe3JldHVybiBuZXcgWGRjKGUpfXN0YXRpYyB4ZHAoZSl7cmV0dXJuIG5ldyBYZHAoZSl9c3RhdGljIHhzbChlKXtyZXR1cm4gbmV3IFhzbChlKX1zdGF0aWMgenBsKGUpe3JldHVybiBuZXcgWnBsKGUpfX1jb25zdCBPbj1nbi5jb25uZWN0aW9uU2V0LmlkO2NsYXNzIENvbm5lY3Rpb25TZXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoT24sImNvbm5lY3Rpb25TZXQiLCEwKTt0aGlzLndzZGxDb25uZWN0aW9uPW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnhtbENvbm5lY3Rpb249bmV3IFhGQU9iamVjdEFycmF5O3RoaXMueHNkQ29ubmVjdGlvbj1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIEVmZmVjdGl2ZUlucHV0UG9saWN5IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE9uLCJlZmZlY3RpdmVJbnB1dFBvbGljeSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBFZmZlY3RpdmVPdXRwdXRQb2xpY3kgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoT24sImVmZmVjdGl2ZU91dHB1dFBvbGljeSIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBPcGVyYXRpb24gZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoT24sIm9wZXJhdGlvbiIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5pbnB1dD1lLmlucHV0fHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLm91dHB1dD1lLm91dHB1dHx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBSb290RWxlbWVudCBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihPbiwicm9vdEVsZW1lbnQiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgU29hcEFjdGlvbiBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihPbiwic29hcEFjdGlvbiIpO3RoaXMuaWQ9ZS5pZHx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51c2U9ZS51c2V8fCIiO3RoaXMudXNlaHJlZj1lLnVzZWhyZWZ8fCIifX1jbGFzcyBTb2FwQWRkcmVzcyBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihPbiwic29hcEFkZHJlc3MiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgY29ubmVjdGlvbl9zZXRfVXJpIGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE9uLCJ1cmkiKTt0aGlzLmlkPWUuaWR8fCIiO3RoaXMubmFtZT1lLm5hbWV8fCIiO3RoaXMudXNlPWUudXNlfHwiIjt0aGlzLnVzZWhyZWY9ZS51c2VocmVmfHwiIn19Y2xhc3MgV3NkbEFkZHJlc3MgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoT24sIndzZGxBZGRyZXNzIik7dGhpcy5pZD1lLmlkfHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnVzZT1lLnVzZXx8IiI7dGhpcy51c2VocmVmPWUudXNlaHJlZnx8IiJ9fWNsYXNzIFdzZGxDb25uZWN0aW9uIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKE9uLCJ3c2RsQ29ubmVjdGlvbiIsITApO3RoaXMuZGF0YURlc2NyaXB0aW9uPWUuZGF0YURlc2NyaXB0aW9ufHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLmVmZmVjdGl2ZUlucHV0UG9saWN5PW51bGw7dGhpcy5lZmZlY3RpdmVPdXRwdXRQb2xpY3k9bnVsbDt0aGlzLm9wZXJhdGlvbj1udWxsO3RoaXMuc29hcEFjdGlvbj1udWxsO3RoaXMuc29hcEFkZHJlc3M9bnVsbDt0aGlzLndzZGxBZGRyZXNzPW51bGx9fWNsYXNzIFhtbENvbm5lY3Rpb24gZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoT24sInhtbENvbm5lY3Rpb24iLCEwKTt0aGlzLmRhdGFEZXNjcmlwdGlvbj1lLmRhdGFEZXNjcmlwdGlvbnx8IiI7dGhpcy5uYW1lPWUubmFtZXx8IiI7dGhpcy51cmk9bnVsbH19Y2xhc3MgWHNkQ29ubmVjdGlvbiBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihPbiwieHNkQ29ubmVjdGlvbiIsITApO3RoaXMuZGF0YURlc2NyaXB0aW9uPWUuZGF0YURlc2NyaXB0aW9ufHwiIjt0aGlzLm5hbWU9ZS5uYW1lfHwiIjt0aGlzLnJvb3RFbGVtZW50PW51bGw7dGhpcy51cmk9bnVsbH19Y2xhc3MgQ29ubmVjdGlvblNldE5hbWVzcGFjZXtzdGF0aWNbb25dKGUsdCl7aWYoQ29ubmVjdGlvblNldE5hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gQ29ubmVjdGlvblNldE5hbWVzcGFjZVtlXSh0KX1zdGF0aWMgY29ubmVjdGlvblNldChlKXtyZXR1cm4gbmV3IENvbm5lY3Rpb25TZXQoZSl9c3RhdGljIGVmZmVjdGl2ZUlucHV0UG9saWN5KGUpe3JldHVybiBuZXcgRWZmZWN0aXZlSW5wdXRQb2xpY3koZSl9c3RhdGljIGVmZmVjdGl2ZU91dHB1dFBvbGljeShlKXtyZXR1cm4gbmV3IEVmZmVjdGl2ZU91dHB1dFBvbGljeShlKX1zdGF0aWMgb3BlcmF0aW9uKGUpe3JldHVybiBuZXcgT3BlcmF0aW9uKGUpfXN0YXRpYyByb290RWxlbWVudChlKXtyZXR1cm4gbmV3IFJvb3RFbGVtZW50KGUpfXN0YXRpYyBzb2FwQWN0aW9uKGUpe3JldHVybiBuZXcgU29hcEFjdGlvbihlKX1zdGF0aWMgc29hcEFkZHJlc3MoZSl7cmV0dXJuIG5ldyBTb2FwQWRkcmVzcyhlKX1zdGF0aWMgdXJpKGUpe3JldHVybiBuZXcgY29ubmVjdGlvbl9zZXRfVXJpKGUpfXN0YXRpYyB3c2RsQWRkcmVzcyhlKXtyZXR1cm4gbmV3IFdzZGxBZGRyZXNzKGUpfXN0YXRpYyB3c2RsQ29ubmVjdGlvbihlKXtyZXR1cm4gbmV3IFdzZGxDb25uZWN0aW9uKGUpfXN0YXRpYyB4bWxDb25uZWN0aW9uKGUpe3JldHVybiBuZXcgWG1sQ29ubmVjdGlvbihlKX1zdGF0aWMgeHNkQ29ubmVjdGlvbihlKXtyZXR1cm4gbmV3IFhzZENvbm5lY3Rpb24oZSl9fWNvbnN0IFBuPWduLmRhdGFzZXRzLmlkO2NsYXNzIGRhdGFzZXRzX0RhdGEgZXh0ZW5kcyBYbWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG4sImRhdGEiLGUpfVtHcl0oKXtyZXR1cm4hMH19Y2xhc3MgRGF0YXNldHMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoUG4sImRhdGFzZXRzIiwhMCk7dGhpcy5kYXRhPW51bGw7dGhpcy5TaWduYXR1cmU9bnVsbH1bS3JdKGUpe2NvbnN0IHQ9ZVtZcl07KCJkYXRhIj09PXQmJmVbSnJdPT09UG58fCJTaWduYXR1cmUiPT09dCYmZVtKcl09PT1nbi5zaWduYXR1cmUuaWQpJiYodGhpc1t0XT1lKTt0aGlzW1hzXShlKX19Y2xhc3MgRGF0YXNldHNOYW1lc3BhY2V7c3RhdGljW29uXShlLHQpe2lmKERhdGFzZXRzTmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXJldHVybiBEYXRhc2V0c05hbWVzcGFjZVtlXSh0KX1zdGF0aWMgZGF0YXNldHMoZSl7cmV0dXJuIG5ldyBEYXRhc2V0cyhlKX1zdGF0aWMgZGF0YShlKXtyZXR1cm4gbmV3IGRhdGFzZXRzX0RhdGEoZSl9fWNvbnN0IFduPWduLmxvY2FsZVNldC5pZDtjbGFzcyBDYWxlbmRhclN5bWJvbHMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sImNhbGVuZGFyU3ltYm9scyIsITApO3RoaXMubmFtZT0iZ3JlZ29yaWFuIjt0aGlzLmRheU5hbWVzPW5ldyBYRkFPYmplY3RBcnJheSgyKTt0aGlzLmVyYU5hbWVzPW51bGw7dGhpcy5tZXJpZGllbU5hbWVzPW51bGw7dGhpcy5tb250aE5hbWVzPW5ldyBYRkFPYmplY3RBcnJheSgyKX19Y2xhc3MgQ3VycmVuY3lTeW1ib2wgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sImN1cnJlbmN5U3ltYm9sIik7dGhpcy5uYW1lPWdldFN0cmluZ09wdGlvbihlLm5hbWUsWyJzeW1ib2wiLCJpc29uYW1lIiwiZGVjaW1hbCJdKX19Y2xhc3MgQ3VycmVuY3lTeW1ib2xzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFduLCJjdXJyZW5jeVN5bWJvbHMiLCEwKTt0aGlzLmN1cnJlbmN5U3ltYm9sPW5ldyBYRkFPYmplY3RBcnJheSgzKX19Y2xhc3MgRGF0ZVBhdHRlcm4gZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sImRhdGVQYXR0ZXJuIik7dGhpcy5uYW1lPWdldFN0cmluZ09wdGlvbihlLm5hbWUsWyJmdWxsIiwibG9uZyIsIm1lZCIsInNob3J0Il0pfX1jbGFzcyBEYXRlUGF0dGVybnMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sImRhdGVQYXR0ZXJucyIsITApO3RoaXMuZGF0ZVBhdHRlcm49bmV3IFhGQU9iamVjdEFycmF5KDQpfX1jbGFzcyBEYXRlVGltZVN5bWJvbHMgZXh0ZW5kcyBDb250ZW50T2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFduLCJkYXRlVGltZVN5bWJvbHMiKX19Y2xhc3MgRGF5IGV4dGVuZHMgU3RyaW5nT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFduLCJkYXkiKX19Y2xhc3MgRGF5TmFtZXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sImRheU5hbWVzIiwhMCk7dGhpcy5hYmJyPWdldEludGVnZXIoe2RhdGE6ZS5hYmJyLGRlZmF1bHRWYWx1ZTowLHZhbGlkYXRlOmU9PjE9PT1lfSk7dGhpcy5kYXk9bmV3IFhGQU9iamVjdEFycmF5KDcpfX1jbGFzcyBFcmEgZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sImVyYSIpfX1jbGFzcyBFcmFOYW1lcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihXbiwiZXJhTmFtZXMiLCEwKTt0aGlzLmVyYT1uZXcgWEZBT2JqZWN0QXJyYXkoMil9fWNsYXNzIGxvY2FsZV9zZXRfTG9jYWxlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFduLCJsb2NhbGUiLCEwKTt0aGlzLmRlc2M9ZS5kZXNjfHwiIjt0aGlzLm5hbWU9Imlzb25hbWUiO3RoaXMuY2FsZW5kYXJTeW1ib2xzPW51bGw7dGhpcy5jdXJyZW5jeVN5bWJvbHM9bnVsbDt0aGlzLmRhdGVQYXR0ZXJucz1udWxsO3RoaXMuZGF0ZVRpbWVTeW1ib2xzPW51bGw7dGhpcy5udW1iZXJQYXR0ZXJucz1udWxsO3RoaXMubnVtYmVyU3ltYm9scz1udWxsO3RoaXMudGltZVBhdHRlcm5zPW51bGw7dGhpcy50eXBlRmFjZXM9bnVsbH19Y2xhc3MgbG9jYWxlX3NldF9Mb2NhbGVTZXQgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sImxvY2FsZVNldCIsITApO3RoaXMubG9jYWxlPW5ldyBYRkFPYmplY3RBcnJheX19Y2xhc3MgTWVyaWRpZW0gZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sIm1lcmlkaWVtIil9fWNsYXNzIE1lcmlkaWVtTmFtZXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sIm1lcmlkaWVtTmFtZXMiLCEwKTt0aGlzLm1lcmlkaWVtPW5ldyBYRkFPYmplY3RBcnJheSgyKX19Y2xhc3MgTW9udGggZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sIm1vbnRoIil9fWNsYXNzIE1vbnRoTmFtZXMgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sIm1vbnRoTmFtZXMiLCEwKTt0aGlzLmFiYnI9Z2V0SW50ZWdlcih7ZGF0YTplLmFiYnIsZGVmYXVsdFZhbHVlOjAsdmFsaWRhdGU6ZT0+MT09PWV9KTt0aGlzLm1vbnRoPW5ldyBYRkFPYmplY3RBcnJheSgxMil9fWNsYXNzIE51bWJlclBhdHRlcm4gZXh0ZW5kcyBTdHJpbmdPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoV24sIm51bWJlclBhdHRlcm4iKTt0aGlzLm5hbWU9Z2V0U3RyaW5nT3B0aW9uKGUubmFtZSxbImZ1bGwiLCJsb25nIiwibWVkIiwic2hvcnQiXSl9fWNsYXNzIE51bWJlclBhdHRlcm5zIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFduLCJudW1iZXJQYXR0ZXJucyIsITApO3RoaXMubnVtYmVyUGF0dGVybj1uZXcgWEZBT2JqZWN0QXJyYXkoNCl9fWNsYXNzIE51bWJlclN5bWJvbCBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihXbiwibnVtYmVyU3ltYm9sIik7dGhpcy5uYW1lPWdldFN0cmluZ09wdGlvbihlLm5hbWUsWyJkZWNpbWFsIiwiZ3JvdXBpbmciLCJwZXJjZW50IiwibWludXMiLCJ6ZXJvIl0pfX1jbGFzcyBOdW1iZXJTeW1ib2xzIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFduLCJudW1iZXJTeW1ib2xzIiwhMCk7dGhpcy5udW1iZXJTeW1ib2w9bmV3IFhGQU9iamVjdEFycmF5KDUpfX1jbGFzcyBUaW1lUGF0dGVybiBleHRlbmRzIFN0cmluZ09iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihXbiwidGltZVBhdHRlcm4iKTt0aGlzLm5hbWU9Z2V0U3RyaW5nT3B0aW9uKGUubmFtZSxbImZ1bGwiLCJsb25nIiwibWVkIiwic2hvcnQiXSl9fWNsYXNzIFRpbWVQYXR0ZXJucyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihXbiwidGltZVBhdHRlcm5zIiwhMCk7dGhpcy50aW1lUGF0dGVybj1uZXcgWEZBT2JqZWN0QXJyYXkoNCl9fWNsYXNzIFR5cGVGYWNlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFduLCJ0eXBlRmFjZSIsITApO3RoaXMubmFtZT0iInxlLm5hbWV9fWNsYXNzIFR5cGVGYWNlcyBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihXbiwidHlwZUZhY2VzIiwhMCk7dGhpcy50eXBlRmFjZT1uZXcgWEZBT2JqZWN0QXJyYXl9fWNsYXNzIExvY2FsZVNldE5hbWVzcGFjZXtzdGF0aWNbb25dKGUsdCl7aWYoTG9jYWxlU2V0TmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXJldHVybiBMb2NhbGVTZXROYW1lc3BhY2VbZV0odCl9c3RhdGljIGNhbGVuZGFyU3ltYm9scyhlKXtyZXR1cm4gbmV3IENhbGVuZGFyU3ltYm9scyhlKX1zdGF0aWMgY3VycmVuY3lTeW1ib2woZSl7cmV0dXJuIG5ldyBDdXJyZW5jeVN5bWJvbChlKX1zdGF0aWMgY3VycmVuY3lTeW1ib2xzKGUpe3JldHVybiBuZXcgQ3VycmVuY3lTeW1ib2xzKGUpfXN0YXRpYyBkYXRlUGF0dGVybihlKXtyZXR1cm4gbmV3IERhdGVQYXR0ZXJuKGUpfXN0YXRpYyBkYXRlUGF0dGVybnMoZSl7cmV0dXJuIG5ldyBEYXRlUGF0dGVybnMoZSl9c3RhdGljIGRhdGVUaW1lU3ltYm9scyhlKXtyZXR1cm4gbmV3IERhdGVUaW1lU3ltYm9scyhlKX1zdGF0aWMgZGF5KGUpe3JldHVybiBuZXcgRGF5KGUpfXN0YXRpYyBkYXlOYW1lcyhlKXtyZXR1cm4gbmV3IERheU5hbWVzKGUpfXN0YXRpYyBlcmEoZSl7cmV0dXJuIG5ldyBFcmEoZSl9c3RhdGljIGVyYU5hbWVzKGUpe3JldHVybiBuZXcgRXJhTmFtZXMoZSl9c3RhdGljIGxvY2FsZShlKXtyZXR1cm4gbmV3IGxvY2FsZV9zZXRfTG9jYWxlKGUpfXN0YXRpYyBsb2NhbGVTZXQoZSl7cmV0dXJuIG5ldyBsb2NhbGVfc2V0X0xvY2FsZVNldChlKX1zdGF0aWMgbWVyaWRpZW0oZSl7cmV0dXJuIG5ldyBNZXJpZGllbShlKX1zdGF0aWMgbWVyaWRpZW1OYW1lcyhlKXtyZXR1cm4gbmV3IE1lcmlkaWVtTmFtZXMoZSl9c3RhdGljIG1vbnRoKGUpe3JldHVybiBuZXcgTW9udGgoZSl9c3RhdGljIG1vbnRoTmFtZXMoZSl7cmV0dXJuIG5ldyBNb250aE5hbWVzKGUpfXN0YXRpYyBudW1iZXJQYXR0ZXJuKGUpe3JldHVybiBuZXcgTnVtYmVyUGF0dGVybihlKX1zdGF0aWMgbnVtYmVyUGF0dGVybnMoZSl7cmV0dXJuIG5ldyBOdW1iZXJQYXR0ZXJucyhlKX1zdGF0aWMgbnVtYmVyU3ltYm9sKGUpe3JldHVybiBuZXcgTnVtYmVyU3ltYm9sKGUpfXN0YXRpYyBudW1iZXJTeW1ib2xzKGUpe3JldHVybiBuZXcgTnVtYmVyU3ltYm9scyhlKX1zdGF0aWMgdGltZVBhdHRlcm4oZSl7cmV0dXJuIG5ldyBUaW1lUGF0dGVybihlKX1zdGF0aWMgdGltZVBhdHRlcm5zKGUpe3JldHVybiBuZXcgVGltZVBhdHRlcm5zKGUpfXN0YXRpYyB0eXBlRmFjZShlKXtyZXR1cm4gbmV3IFR5cGVGYWNlKGUpfXN0YXRpYyB0eXBlRmFjZXMoZSl7cmV0dXJuIG5ldyBUeXBlRmFjZXMoZSl9fWNvbnN0IGpuPWduLnNpZ25hdHVyZS5pZDtjbGFzcyBzaWduYXR1cmVfU2lnbmF0dXJlIGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGpuLCJzaWduYXR1cmUiLCEwKX19Y2xhc3MgU2lnbmF0dXJlTmFtZXNwYWNle3N0YXRpY1tvbl0oZSx0KXtpZihTaWduYXR1cmVOYW1lc3BhY2UuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIFNpZ25hdHVyZU5hbWVzcGFjZVtlXSh0KX1zdGF0aWMgc2lnbmF0dXJlKGUpe3JldHVybiBuZXcgc2lnbmF0dXJlX1NpZ25hdHVyZShlKX19Y29uc3QgWG49Z24uc3R5bGVzaGVldC5pZDtjbGFzcyBTdHlsZXNoZWV0IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKFhuLCJzdHlsZXNoZWV0IiwhMCl9fWNsYXNzIFN0eWxlc2hlZXROYW1lc3BhY2V7c3RhdGljW29uXShlLHQpe2lmKFN0eWxlc2hlZXROYW1lc3BhY2UuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIFN0eWxlc2hlZXROYW1lc3BhY2VbZV0odCl9c3RhdGljIHN0eWxlc2hlZXQoZSl7cmV0dXJuIG5ldyBTdHlsZXNoZWV0KGUpfX1jb25zdCBabj1nbi54ZHAuaWQ7Y2xhc3MgeGRwX1hkcCBleHRlbmRzIFhGQU9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihabiwieGRwIiwhMCk7dGhpcy51dWlkPWUudXVpZHx8IiI7dGhpcy50aW1lU3RhbXA9ZS50aW1lU3RhbXB8fCIiO3RoaXMuY29uZmlnPW51bGw7dGhpcy5jb25uZWN0aW9uU2V0PW51bGw7dGhpcy5kYXRhc2V0cz1udWxsO3RoaXMubG9jYWxlU2V0PW51bGw7dGhpcy5zdHlsZXNoZWV0PW5ldyBYRkFPYmplY3RBcnJheTt0aGlzLnRlbXBsYXRlPW51bGx9W1RyXShlKXtjb25zdCB0PWduW2VbWXJdXTtyZXR1cm4gdCYmZVtKcl09PT10LmlkfX1jbGFzcyBYZHBOYW1lc3BhY2V7c3RhdGljW29uXShlLHQpe2lmKFhkcE5hbWVzcGFjZS5oYXNPd25Qcm9wZXJ0eShlKSlyZXR1cm4gWGRwTmFtZXNwYWNlW2VdKHQpfXN0YXRpYyB4ZHAoZSl7cmV0dXJuIG5ldyB4ZHBfWGRwKGUpfX1jb25zdCBWbj1nbi54aHRtbC5pZCx6bj1TeW1ib2woKSxfbj1uZXcgU2V0KFsiY29sb3IiLCJmb250IiwiZm9udC1mYW1pbHkiLCJmb250LXNpemUiLCJmb250LXN0cmV0Y2giLCJmb250LXN0eWxlIiwiZm9udC13ZWlnaHQiLCJtYXJnaW4iLCJtYXJnaW4tYm90dG9tIiwibWFyZ2luLWxlZnQiLCJtYXJnaW4tcmlnaHQiLCJtYXJnaW4tdG9wIiwibGV0dGVyLXNwYWNpbmciLCJsaW5lLWhlaWdodCIsIm9ycGhhbnMiLCJwYWdlLWJyZWFrLWFmdGVyIiwicGFnZS1icmVhay1iZWZvcmUiLCJwYWdlLWJyZWFrLWluc2lkZSIsInRhYi1pbnRlcnZhbCIsInRhYi1zdG9wIiwidGV4dC1hbGlnbiIsInRleHQtZGVjb3JhdGlvbiIsInRleHQtaW5kZW50IiwidmVydGljYWwtYWxpZ24iLCJ3aWRvd3MiLCJrZXJuaW5nLW1vZGUiLCJ4ZmEtZm9udC1ob3Jpem9udGFsLXNjYWxlIiwieGZhLWZvbnQtdmVydGljYWwtc2NhbGUiLCJ4ZmEtc3BhY2VydW4iLCJ4ZmEtdGFiLXN0b3BzIl0pLCRuPW5ldyBNYXAoW1sicGFnZS1icmVhay1hZnRlciIsImJyZWFrQWZ0ZXIiXSxbInBhZ2UtYnJlYWstYmVmb3JlIiwiYnJlYWtCZWZvcmUiXSxbInBhZ2UtYnJlYWstaW5zaWRlIiwiYnJlYWtJbnNpZGUiXSxbImtlcm5pbmctbW9kZSIsZT0+Im5vbmUiPT09ZT8ibm9uZSI6Im5vcm1hbCJdLFsieGZhLWZvbnQtaG9yaXpvbnRhbC1zY2FsZSIsZT0+YHNjYWxlWCgke01hdGgubWF4KDAsTWF0aC5taW4ocGFyc2VJbnQoZSkvMTAwKSkudG9GaXhlZCgyKX0pYF0sWyJ4ZmEtZm9udC12ZXJ0aWNhbC1zY2FsZSIsZT0+YHNjYWxlWSgke01hdGgubWF4KDAsTWF0aC5taW4ocGFyc2VJbnQoZSkvMTAwKSkudG9GaXhlZCgyKX0pYF0sWyJ4ZmEtc3BhY2VydW4iLCIiXSxbInhmYS10YWItc3RvcHMiLCIiXSxbImZvbnQtc2l6ZSIsKGUsdCk9Pm1lYXN1cmVUb1N0cmluZyguOTkqKGU9dC5mb250U2l6ZT1nZXRNZWFzdXJlbWVudChlKSkpXSxbImxldHRlci1zcGFjaW5nIixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbImxpbmUtaGVpZ2h0IixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbIm1hcmdpbiIsZT0+bWVhc3VyZVRvU3RyaW5nKGdldE1lYXN1cmVtZW50KGUpKV0sWyJtYXJnaW4tYm90dG9tIixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbIm1hcmdpbi1sZWZ0IixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbIm1hcmdpbi1yaWdodCIsZT0+bWVhc3VyZVRvU3RyaW5nKGdldE1lYXN1cmVtZW50KGUpKV0sWyJtYXJnaW4tdG9wIixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbInRleHQtaW5kZW50IixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXSxbImZvbnQtZmFtaWx5IixlPT5lXSxbInZlcnRpY2FsLWFsaWduIixlPT5tZWFzdXJlVG9TdHJpbmcoZ2V0TWVhc3VyZW1lbnQoZSkpXV0pLEFvPS9ccysvZyxlbz0vW1xyXG5dKy9nLHRvPS9cclxuPy9nO2Z1bmN0aW9uIG1hcFN0eWxlKGUsdCxpKXtjb25zdCBhPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoIWUpcmV0dXJuIGE7Y29uc3Qgcz1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdFt0LGldb2YgZS5zcGxpdCgiOyIpLm1hcCgoZT0+ZS5zcGxpdCgiOiIsMikpKSl7Y29uc3QgZT0kbi5nZXQodCk7aWYoIiI9PT1lKWNvbnRpbnVlO2xldCByPWk7ZSYmKHI9InN0cmluZyI9PXR5cGVvZiBlP2U6ZShpLHMpKTt0LmVuZHNXaXRoKCJzY2FsZSIpP2EudHJhbnNmb3JtPWEudHJhbnNmb3JtP2Ake2FbdF19ICR7cn1gOnI6YVt0LnJlcGxhY2VBbGwoLy0oW2EtekEtWl0pL2csKChlLHQpPT50LnRvVXBwZXJDYXNlKCkpKV09cn1hLmZvbnRGYW1pbHkmJnNldEZvbnRGYW1pbHkoe3R5cGVmYWNlOmEuZm9udEZhbWlseSx3ZWlnaHQ6YS5mb250V2VpZ2h0fHwibm9ybWFsIixwb3N0dXJlOmEuZm9udFN0eWxlfHwibm9ybWFsIixzaXplOnMuZm9udFNpemV8fDB9LHQsdFt5cl0uZm9udEZpbmRlcixhKTtpZihpJiZhLnZlcnRpY2FsQWxpZ24mJiIwcHgiIT09YS52ZXJ0aWNhbEFsaWduJiZhLmZvbnRTaXplKXtjb25zdCBlPS41ODMsdD0uMzMzLGk9Z2V0TWVhc3VyZW1lbnQoYS5mb250U2l6ZSk7YS5mb250U2l6ZT1tZWFzdXJlVG9TdHJpbmcoaSplKTthLnZlcnRpY2FsQWxpZ249bWVhc3VyZVRvU3RyaW5nKE1hdGguc2lnbihnZXRNZWFzdXJlbWVudChhLnZlcnRpY2FsQWxpZ24pKSppKnQpfWkmJmEuZm9udFNpemUmJihhLmZvbnRTaXplPWBjYWxjKCR7YS5mb250U2l6ZX0gKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWApO2ZpeFRleHRJbmRlbnQoYSk7cmV0dXJuIGF9Y29uc3QgaW89bmV3IFNldChbImJvZHkiLCJodG1sIl0pO2NsYXNzIFhodG1sT2JqZWN0IGV4dGVuZHMgWG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUsdCl7c3VwZXIoVm4sdCk7dGhpc1t6bl09ITE7dGhpcy5zdHlsZT1lLnN0eWxlfHwiIn1bVnNdKGUpe3N1cGVyW1ZzXShlKTt0aGlzLnN0eWxlPWZ1bmN0aW9uIGNoZWNrU3R5bGUoZSl7cmV0dXJuIGUuc3R5bGU/ZS5zdHlsZS50cmltKCkuc3BsaXQoL1xzKjtccyovKS5maWx0ZXIoKGU9PiEhZSkpLm1hcCgoZT0+ZS5zcGxpdCgvXHMqOlxzKi8sMikpKS5maWx0ZXIoKChbdCxpXSk9PnsiZm9udC1mYW1pbHkiPT09dCYmZVt5cl0udXNlZFR5cGVmYWNlcy5hZGQoaSk7cmV0dXJuIF9uLmhhcyh0KX0pKS5tYXAoKGU9PmUuam9pbigiOiIpKSkuam9pbigiOyIpOiIifSh0aGlzKX1bV3NdKCl7cmV0dXJuIWlvLmhhcyh0aGlzW1lyXSl9W3FyXShlLHQ9ITEpe2lmKHQpdGhpc1t6bl09ITA7ZWxzZXtlPWUucmVwbGFjZUFsbChlbywiIik7dGhpcy5zdHlsZS5pbmNsdWRlcygieGZhLXNwYWNlcnVuOnllcyIpfHwoZT1lLnJlcGxhY2VBbGwoQW8sIiAiKSl9ZSYmKHRoaXNbZXJdKz1lKX1bT3JdKGUsdD0hMCl7Y29uc3QgaT1PYmplY3QuY3JlYXRlKG51bGwpLGE9e3RvcDpOYU4sYm90dG9tOk5hTixsZWZ0Ok5hTixyaWdodDpOYU59O2xldCBzPW51bGw7Zm9yKGNvbnN0W2UsdF1vZiB0aGlzLnN0eWxlLnNwbGl0KCI7IikubWFwKChlPT5lLnNwbGl0KCI6IiwyKSkpKXN3aXRjaChlKXtjYXNlImZvbnQtZmFtaWx5IjppLnR5cGVmYWNlPXN0cmlwUXVvdGVzKHQpO2JyZWFrO2Nhc2UiZm9udC1zaXplIjppLnNpemU9Z2V0TWVhc3VyZW1lbnQodCk7YnJlYWs7Y2FzZSJmb250LXdlaWdodCI6aS53ZWlnaHQ9dDticmVhaztjYXNlImZvbnQtc3R5bGUiOmkucG9zdHVyZT10O2JyZWFrO2Nhc2UibGV0dGVyLXNwYWNpbmciOmkubGV0dGVyU3BhY2luZz1nZXRNZWFzdXJlbWVudCh0KTticmVhaztjYXNlIm1hcmdpbiI6Y29uc3QgZT10LnNwbGl0KC8gXHQvKS5tYXAoKGU9PmdldE1lYXN1cmVtZW50KGUpKSk7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDE6YS50b3A9YS5ib3R0b209YS5sZWZ0PWEucmlnaHQ9ZVswXTticmVhaztjYXNlIDI6YS50b3A9YS5ib3R0b209ZVswXTthLmxlZnQ9YS5yaWdodD1lWzFdO2JyZWFrO2Nhc2UgMzphLnRvcD1lWzBdO2EuYm90dG9tPWVbMl07YS5sZWZ0PWEucmlnaHQ9ZVsxXTticmVhaztjYXNlIDQ6YS50b3A9ZVswXTthLmxlZnQ9ZVsxXTthLmJvdHRvbT1lWzJdO2EucmlnaHQ9ZVszXX1icmVhaztjYXNlIm1hcmdpbi10b3AiOmEudG9wPWdldE1lYXN1cmVtZW50KHQpO2JyZWFrO2Nhc2UibWFyZ2luLWJvdHRvbSI6YS5ib3R0b209Z2V0TWVhc3VyZW1lbnQodCk7YnJlYWs7Y2FzZSJtYXJnaW4tbGVmdCI6YS5sZWZ0PWdldE1lYXN1cmVtZW50KHQpO2JyZWFrO2Nhc2UibWFyZ2luLXJpZ2h0IjphLnJpZ2h0PWdldE1lYXN1cmVtZW50KHQpO2JyZWFrO2Nhc2UibGluZS1oZWlnaHQiOnM9Z2V0TWVhc3VyZW1lbnQodCl9ZS5wdXNoRGF0YShpLGEscyk7aWYodGhpc1tlcl0pZS5hZGRTdHJpbmcodGhpc1tlcl0pO2Vsc2UgZm9yKGNvbnN0IHQgb2YgdGhpc1tFcl0oKSkiI3RleHQiIT09dFtZcl0/dFtPcl0oZSk6ZS5hZGRTdHJpbmcodFtlcl0pO3QmJmUucG9wRm9udCgpfVthbl0oZSl7Y29uc3QgdD1bXTt0aGlzW2FyXT17Y2hpbGRyZW46dH07dGhpc1tac10oe30pO2lmKDA9PT10Lmxlbmd0aCYmIXRoaXNbZXJdKXJldHVybiBIVE1MUmVzdWx0LkVNUFRZO2xldCBpO2k9dGhpc1t6bl0/dGhpc1tlcl0/dGhpc1tlcl0ucmVwbGFjZUFsbCh0bywiXG4iKTp2b2lkIDA6dGhpc1tlcl18fHZvaWQgMDtyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOnRoaXNbWXJdLGF0dHJpYnV0ZXM6e2hyZWY6dGhpcy5ocmVmLHN0eWxlOm1hcFN0eWxlKHRoaXMuc3R5bGUsdGhpcyx0aGlzW3puXSl9LGNoaWxkcmVuOnQsdmFsdWU6aX0pfX1jbGFzcyBBIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiYSIpO3RoaXMuaHJlZj1maXhVUkwoZS5ocmVmKXx8IiJ9fWNsYXNzIEIgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJiIil9W09yXShlKXtlLnB1c2hGb250KHt3ZWlnaHQ6ImJvbGQifSk7c3VwZXJbT3JdKGUpO2UucG9wRm9udCgpfX1jbGFzcyBCb2R5IGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiYm9keSIpfVthbl0oZSl7Y29uc3QgdD1zdXBlclthbl0oZSkse2h0bWw6aX09dDtpZighaSlyZXR1cm4gSFRNTFJlc3VsdC5FTVBUWTtpLm5hbWU9ImRpdiI7aS5hdHRyaWJ1dGVzLmNsYXNzPVsieGZhUmljaCJdO3JldHVybiB0fX1jbGFzcyBCciBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImJyIil9W2VuXSgpe3JldHVybiJcbiJ9W09yXShlKXtlLmFkZFN0cmluZygiXG4iKX1bYW5dKGUpe3JldHVybiBIVE1MUmVzdWx0LnN1Y2Nlc3Moe25hbWU6ImJyIn0pfX1jbGFzcyBIdG1sIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwiaHRtbCIpfVthbl0oZSl7Y29uc3QgdD1bXTt0aGlzW2FyXT17Y2hpbGRyZW46dH07dGhpc1tac10oe30pO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhUmljaCJdLHN0eWxlOnt9fSx2YWx1ZTp0aGlzW2VyXXx8IiJ9KTtpZigxPT09dC5sZW5ndGgpe2NvbnN0IGU9dFswXTtpZihlLmF0dHJpYnV0ZXM/LmNsYXNzLmluY2x1ZGVzKCJ4ZmFSaWNoIikpcmV0dXJuIEhUTUxSZXN1bHQuc3VjY2VzcyhlKX1yZXR1cm4gSFRNTFJlc3VsdC5zdWNjZXNzKHtuYW1lOiJkaXYiLGF0dHJpYnV0ZXM6e2NsYXNzOlsieGZhUmljaCJdLHN0eWxlOnt9fSxjaGlsZHJlbjp0fSl9fWNsYXNzIEkgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJpIil9W09yXShlKXtlLnB1c2hGb250KHtwb3N0dXJlOiJpdGFsaWMifSk7c3VwZXJbT3JdKGUpO2UucG9wRm9udCgpfX1jbGFzcyBMaSBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsImxpIil9fWNsYXNzIE9sIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwib2wiKX19Y2xhc3MgUCBleHRlbmRzIFhodG1sT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUsInAiKX1bT3JdKGUpe3N1cGVyW09yXShlLCExKTtlLmFkZFN0cmluZygiXG4iKTtlLmFkZFBhcmEoKTtlLnBvcEZvbnQoKX1bZW5dKCl7cmV0dXJuIHRoaXNbcHJdKClbRXJdKCkuYXQoLTEpPT09dGhpcz9zdXBlcltlbl0oKTpzdXBlcltlbl0oKSsiXG4ifX1jbGFzcyBTcGFuIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwic3BhbiIpfX1jbGFzcyBTdWIgZXh0ZW5kcyBYaHRtbE9iamVjdHtjb25zdHJ1Y3RvcihlKXtzdXBlcihlLCJzdWIiKX19Y2xhc3MgU3VwIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwic3VwIil9fWNsYXNzIFVsIGV4dGVuZHMgWGh0bWxPYmplY3R7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSwidWwiKX19Y2xhc3MgWGh0bWxOYW1lc3BhY2V7c3RhdGljW29uXShlLHQpe2lmKFhodG1sTmFtZXNwYWNlLmhhc093blByb3BlcnR5KGUpKXJldHVybiBYaHRtbE5hbWVzcGFjZVtlXSh0KX1zdGF0aWMgYShlKXtyZXR1cm4gbmV3IEEoZSl9c3RhdGljIGIoZSl7cmV0dXJuIG5ldyBCKGUpfXN0YXRpYyBib2R5KGUpe3JldHVybiBuZXcgQm9keShlKX1zdGF0aWMgYnIoZSl7cmV0dXJuIG5ldyBCcihlKX1zdGF0aWMgaHRtbChlKXtyZXR1cm4gbmV3IEh0bWwoZSl9c3RhdGljIGkoZSl7cmV0dXJuIG5ldyBJKGUpfXN0YXRpYyBsaShlKXtyZXR1cm4gbmV3IExpKGUpfXN0YXRpYyBvbChlKXtyZXR1cm4gbmV3IE9sKGUpfXN0YXRpYyBwKGUpe3JldHVybiBuZXcgUChlKX1zdGF0aWMgc3BhbihlKXtyZXR1cm4gbmV3IFNwYW4oZSl9c3RhdGljIHN1YihlKXtyZXR1cm4gbmV3IFN1YihlKX1zdGF0aWMgc3VwKGUpe3JldHVybiBuZXcgU3VwKGUpfXN0YXRpYyB1bChlKXtyZXR1cm4gbmV3IFVsKGUpfX1jb25zdCBhbz17Y29uZmlnOkNvbmZpZ05hbWVzcGFjZSxjb25uZWN0aW9uOkNvbm5lY3Rpb25TZXROYW1lc3BhY2UsZGF0YXNldHM6RGF0YXNldHNOYW1lc3BhY2UsbG9jYWxlU2V0OkxvY2FsZVNldE5hbWVzcGFjZSxzaWduYXR1cmU6U2lnbmF0dXJlTmFtZXNwYWNlLHN0eWxlc2hlZXQ6U3R5bGVzaGVldE5hbWVzcGFjZSx0ZW1wbGF0ZTpUZW1wbGF0ZU5hbWVzcGFjZSx4ZHA6WGRwTmFtZXNwYWNlLHhodG1sOlhodG1sTmFtZXNwYWNlfTtjbGFzcyBVbmtub3duTmFtZXNwYWNle2NvbnN0cnVjdG9yKGUpe3RoaXMubmFtZXNwYWNlSWQ9ZX1bb25dKGUsdCl7cmV0dXJuIG5ldyBYbWxPYmplY3QodGhpcy5uYW1lc3BhY2VJZCxlLHQpfX1jbGFzcyBSb290IGV4dGVuZHMgWEZBT2JqZWN0e2NvbnN0cnVjdG9yKGUpe3N1cGVyKC0xLCJyb290IixPYmplY3QuY3JlYXRlKG51bGwpKTt0aGlzLmVsZW1lbnQ9bnVsbDt0aGlzW2JyXT1lfVtLcl0oZSl7dGhpcy5lbGVtZW50PWU7cmV0dXJuITB9W3NyXSgpe3N1cGVyW3NyXSgpO2lmKHRoaXMuZWxlbWVudC50ZW1wbGF0ZSBpbnN0YW5jZW9mIFRlbXBsYXRlKXt0aGlzW2JyXS5zZXQoWHIsdGhpcy5lbGVtZW50KTt0aGlzLmVsZW1lbnQudGVtcGxhdGVbWnJdKHRoaXNbYnJdKTt0aGlzLmVsZW1lbnQudGVtcGxhdGVbYnJdPXRoaXNbYnJdfX19Y2xhc3MgRW1wdHkgZXh0ZW5kcyBYRkFPYmplY3R7Y29uc3RydWN0b3IoKXtzdXBlcigtMSwiIixPYmplY3QuY3JlYXRlKG51bGwpKX1bS3JdKGUpe3JldHVybiExfX1jbGFzcyBCdWlsZGVye2NvbnN0cnVjdG9yKGU9bnVsbCl7dGhpcy5fbmFtZXNwYWNlU3RhY2s9W107dGhpcy5fbnNBZ25vc3RpY0xldmVsPTA7dGhpcy5fbmFtZXNwYWNlUHJlZml4ZXM9bmV3IE1hcDt0aGlzLl9uYW1lc3BhY2VzPW5ldyBNYXA7dGhpcy5fbmV4dE5zSWQ9TWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhnbikubWFwKCgoe2lkOmV9KT0+ZSkpKTt0aGlzLl9jdXJyZW50TmFtZXNwYWNlPWV8fG5ldyBVbmtub3duTmFtZXNwYWNlKCsrdGhpcy5fbmV4dE5zSWQpfWJ1aWxkUm9vdChlKXtyZXR1cm4gbmV3IFJvb3QoZSl9YnVpbGQoe25zUHJlZml4OmUsbmFtZTp0LGF0dHJpYnV0ZXM6aSxuYW1lc3BhY2U6YSxwcmVmaXhlczpzfSl7Y29uc3Qgcj1udWxsIT09YTtpZihyKXt0aGlzLl9uYW1lc3BhY2VTdGFjay5wdXNoKHRoaXMuX2N1cnJlbnROYW1lc3BhY2UpO3RoaXMuX2N1cnJlbnROYW1lc3BhY2U9dGhpcy5fc2VhcmNoTmFtZXNwYWNlKGEpfXMmJnRoaXMuX2FkZE5hbWVzcGFjZVByZWZpeChzKTtpZihpLmhhc093blByb3BlcnR5KHZyKSl7Y29uc3QgZT1hby5kYXRhc2V0cyx0PWlbdnJdO2xldCBhPW51bGw7Zm9yKGNvbnN0W2ksc11vZiBPYmplY3QuZW50cmllcyh0KSl7aWYodGhpcy5fZ2V0TmFtZXNwYWNlVG9Vc2UoaSk9PT1lKXthPXt4ZmE6c307YnJlYWt9fWE/aVt2cl09YTpkZWxldGUgaVt2cl19Y29uc3Qgbj10aGlzLl9nZXROYW1lc3BhY2VUb1VzZShlKSxvPW4/Lltvbl0odCxpKXx8bmV3IEVtcHR5O29bR3JdKCkmJnRoaXMuX25zQWdub3N0aWNMZXZlbCsrOyhyfHxzfHxvW0dyXSgpKSYmKG9bX3NdPXtoYXNOYW1lc3BhY2U6cixwcmVmaXhlczpzLG5zQWdub3N0aWM6b1tHcl0oKX0pO3JldHVybiBvfWlzTnNBZ25vc3RpYygpe3JldHVybiB0aGlzLl9uc0Fnbm9zdGljTGV2ZWw+MH1fc2VhcmNoTmFtZXNwYWNlKGUpe2xldCB0PXRoaXMuX25hbWVzcGFjZXMuZ2V0KGUpO2lmKHQpcmV0dXJuIHQ7Zm9yKGNvbnN0W2kse2NoZWNrOmF9XW9mIE9iamVjdC5lbnRyaWVzKGduKSlpZihhKGUpKXt0PWFvW2ldO2lmKHQpe3RoaXMuX25hbWVzcGFjZXMuc2V0KGUsdCk7cmV0dXJuIHR9YnJlYWt9dD1uZXcgVW5rbm93bk5hbWVzcGFjZSgrK3RoaXMuX25leHROc0lkKTt0aGlzLl9uYW1lc3BhY2VzLnNldChlLHQpO3JldHVybiB0fV9hZGROYW1lc3BhY2VQcmVmaXgoZSl7Zm9yKGNvbnN0e3ByZWZpeDp0LHZhbHVlOml9b2YgZSl7Y29uc3QgZT10aGlzLl9zZWFyY2hOYW1lc3BhY2UoaSk7bGV0IGE9dGhpcy5fbmFtZXNwYWNlUHJlZml4ZXMuZ2V0KHQpO2lmKCFhKXthPVtdO3RoaXMuX25hbWVzcGFjZVByZWZpeGVzLnNldCh0LGEpfWEucHVzaChlKX19X2dldE5hbWVzcGFjZVRvVXNlKGUpe2lmKCFlKXJldHVybiB0aGlzLl9jdXJyZW50TmFtZXNwYWNlO2NvbnN0IHQ9dGhpcy5fbmFtZXNwYWNlUHJlZml4ZXMuZ2V0KGUpO2lmKHQ/Lmxlbmd0aD4wKXJldHVybiB0LmF0KC0xKTt3YXJuKGBVbmtub3duIG5hbWVzcGFjZSBwcmVmaXg6ICR7ZX0uYCk7cmV0dXJuIG51bGx9Y2xlYW4oZSl7Y29uc3R7aGFzTmFtZXNwYWNlOnQscHJlZml4ZXM6aSxuc0Fnbm9zdGljOmF9PWU7dCYmKHRoaXMuX2N1cnJlbnROYW1lc3BhY2U9dGhpcy5fbmFtZXNwYWNlU3RhY2sucG9wKCkpO2kmJmkuZm9yRWFjaCgoKHtwcmVmaXg6ZX0pPT57dGhpcy5fbmFtZXNwYWNlUHJlZml4ZXMuZ2V0KGUpLnBvcCgpfSkpO2EmJnRoaXMuX25zQWdub3N0aWNMZXZlbC0tfX1jbGFzcyBYRkFQYXJzZXIgZXh0ZW5kcyBYTUxQYXJzZXJCYXNle2NvbnN0cnVjdG9yKGU9bnVsbCx0PSExKXtzdXBlcigpO3RoaXMuX2J1aWxkZXI9bmV3IEJ1aWxkZXIoZSk7dGhpcy5fc3RhY2s9W107dGhpcy5fZ2xvYmFsRGF0YT17dXNlZFR5cGVmYWNlczpuZXcgU2V0fTt0aGlzLl9pZHM9bmV3IE1hcDt0aGlzLl9jdXJyZW50PXRoaXMuX2J1aWxkZXIuYnVpbGRSb290KHRoaXMuX2lkcyk7dGhpcy5fZXJyb3JDb2RlPU5zO3RoaXMuX3doaXRlUmVnZXg9L15ccyskLzt0aGlzLl9uYnNwcz0vXHhhMCsvZzt0aGlzLl9yaWNoVGV4dD10fXBhcnNlKGUpe3RoaXMucGFyc2VYbWwoZSk7aWYodGhpcy5fZXJyb3JDb2RlPT09TnMpe3RoaXMuX2N1cnJlbnRbc3JdKCk7cmV0dXJuIHRoaXMuX2N1cnJlbnQuZWxlbWVudH19b25UZXh0KGUpe2U9ZS5yZXBsYWNlKHRoaXMuX25ic3BzLChlPT5lLnNsaWNlKDEpKyIgIikpO3RoaXMuX3JpY2hUZXh0fHx0aGlzLl9jdXJyZW50W1dzXSgpP3RoaXMuX2N1cnJlbnRbcXJdKGUsdGhpcy5fcmljaFRleHQpOnRoaXMuX3doaXRlUmVnZXgudGVzdChlKXx8dGhpcy5fY3VycmVudFtxcl0oZS50cmltKCkpfW9uQ2RhdGEoZSl7dGhpcy5fY3VycmVudFtxcl0oZSl9X21rQXR0cmlidXRlcyhlLHQpe2xldCBpPW51bGwsYT1udWxsO2NvbnN0IHM9T2JqZWN0LmNyZWF0ZSh7fSk7Zm9yKGNvbnN0e25hbWU6cix2YWx1ZTpufW9mIGUpaWYoInhtbG5zIj09PXIpaT93YXJuKGBYRkEgLSBtdWx0aXBsZSBuYW1lc3BhY2UgZGVmaW5pdGlvbiBpbiA8JHt0fT5gKTppPW47ZWxzZSBpZihyLnN0YXJ0c1dpdGgoInhtbG5zOiIpKXtjb25zdCBlPXIuc3Vic3RyaW5nKDYpO2F8fChhPVtdKTthLnB1c2goe3ByZWZpeDplLHZhbHVlOm59KX1lbHNle2NvbnN0IGU9ci5pbmRleE9mKCI6Iik7aWYoLTE9PT1lKXNbcl09bjtlbHNle2xldCB0PXNbdnJdO3R8fCh0PXNbdnJdPU9iamVjdC5jcmVhdGUobnVsbCkpO2NvbnN0W2ksYV09W3Iuc2xpY2UoMCxlKSxyLnNsaWNlKGUrMSldOyh0W2ldfHw9T2JqZWN0LmNyZWF0ZShudWxsKSlbYV09bn19cmV0dXJuW2ksYSxzXX1fZ2V0TmFtZUFuZFByZWZpeChlLHQpe2NvbnN0IGk9ZS5pbmRleE9mKCI6Iik7cmV0dXJuLTE9PT1pP1tlLG51bGxdOltlLnN1YnN0cmluZyhpKzEpLHQ/IiI6ZS5zdWJzdHJpbmcoMCxpKV19b25CZWdpbkVsZW1lbnQoZSx0LGkpe2NvbnN0W2EscyxyXT10aGlzLl9ta0F0dHJpYnV0ZXModCxlKSxbbixvXT10aGlzLl9nZXROYW1lQW5kUHJlZml4KGUsdGhpcy5fYnVpbGRlci5pc05zQWdub3N0aWMoKSksZz10aGlzLl9idWlsZGVyLmJ1aWxkKHtuc1ByZWZpeDpvLG5hbWU6bixhdHRyaWJ1dGVzOnIsbmFtZXNwYWNlOmEscHJlZml4ZXM6c30pO2dbeXJdPXRoaXMuX2dsb2JhbERhdGE7aWYoaSl7Z1tzcl0oKTt0aGlzLl9jdXJyZW50W0tyXShnKSYmZ1t6cl0odGhpcy5faWRzKTtnW1ZzXSh0aGlzLl9idWlsZGVyKX1lbHNle3RoaXMuX3N0YWNrLnB1c2godGhpcy5fY3VycmVudCk7dGhpcy5fY3VycmVudD1nfX1vbkVuZEVsZW1lbnQoZSl7Y29uc3QgdD10aGlzLl9jdXJyZW50O2lmKHRbU3JdKCkmJiJzdHJpbmciPT10eXBlb2YgdFtlcl0pe2NvbnN0IGU9bmV3IFhGQVBhcnNlcjtlLl9nbG9iYWxEYXRhPXRoaXMuX2dsb2JhbERhdGE7Y29uc3QgaT1lLnBhcnNlKHRbZXJdKTt0W2VyXT1udWxsO3RbS3JdKGkpfXRbc3JdKCk7dGhpcy5fY3VycmVudD10aGlzLl9zdGFjay5wb3AoKTt0aGlzLl9jdXJyZW50W0tyXSh0KSYmdFt6cl0odGhpcy5faWRzKTt0W1ZzXSh0aGlzLl9idWlsZGVyKX1vbkVycm9yKGUpe3RoaXMuX2Vycm9yQ29kZT1lfX1jbGFzcyBYRkFGYWN0b3J5e2NvbnN0cnVjdG9yKGUpe3RyeXt0aGlzLnJvb3Q9KG5ldyBYRkFQYXJzZXIpLnBhcnNlKFhGQUZhY3RvcnkuX2NyZWF0ZURvY3VtZW50KGUpKTtjb25zdCB0PW5ldyBCaW5kZXIodGhpcy5yb290KTt0aGlzLmZvcm09dC5iaW5kKCk7dGhpcy5kYXRhSGFuZGxlcj1uZXcgRGF0YUhhbmRsZXIodGhpcy5yb290LHQuZ2V0RGF0YSgpKTt0aGlzLmZvcm1beXJdLnRlbXBsYXRlPXRoaXMuZm9ybX1jYXRjaChlKXt3YXJuKGBYRkEgLSBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgcGFyc2luZyBhbmQgYmluZGluZzogJHtlfWApfX1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMucm9vdCYmdGhpcy5mb3JtfV9jcmVhdGVQYWdlc0hlbHBlcigpe2NvbnN0IGU9dGhpcy5mb3JtW3RuXSgpO3JldHVybiBuZXcgUHJvbWlzZSgoKHQsaSk9Pntjb25zdCBuZXh0SXRlcmF0aW9uPSgpPT57dHJ5e2NvbnN0IGk9ZS5uZXh0KCk7aS5kb25lP3QoaS52YWx1ZSk6c2V0VGltZW91dChuZXh0SXRlcmF0aW9uLDApfWNhdGNoKGUpe2koZSl9fTtzZXRUaW1lb3V0KG5leHRJdGVyYXRpb24sMCl9KSl9YXN5bmMgX2NyZWF0ZVBhZ2VzKCl7dHJ5e3RoaXMucGFnZXM9YXdhaXQgdGhpcy5fY3JlYXRlUGFnZXNIZWxwZXIoKTt0aGlzLmRpbXM9dGhpcy5wYWdlcy5jaGlsZHJlbi5tYXAoKGU9Pntjb25zdHt3aWR0aDp0LGhlaWdodDppfT1lLmF0dHJpYnV0ZXMuc3R5bGU7cmV0dXJuWzAsMCxwYXJzZUludCh0KSxwYXJzZUludChpKV19KSl9Y2F0Y2goZSl7d2FybihgWEZBIC0gYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGxheW91dDogJHtlfWApfX1nZXRCb3VuZGluZ0JveChlKXtyZXR1cm4gdGhpcy5kaW1zW2VdfWFzeW5jIGdldE51bVBhZ2VzKCl7dGhpcy5wYWdlc3x8YXdhaXQgdGhpcy5fY3JlYXRlUGFnZXMoKTtyZXR1cm4gdGhpcy5kaW1zLmxlbmd0aH1zZXRJbWFnZXMoZSl7dGhpcy5mb3JtW3lyXS5pbWFnZXM9ZX1zZXRGb250cyhlKXt0aGlzLmZvcm1beXJdLmZvbnRGaW5kZXI9bmV3IEZvbnRGaW5kZXIoZSk7Y29uc3QgdD1bXTtmb3IobGV0IGUgb2YgdGhpcy5mb3JtW3lyXS51c2VkVHlwZWZhY2VzKXtlPXN0cmlwUXVvdGVzKGUpO3RoaXMuZm9ybVt5cl0uZm9udEZpbmRlci5maW5kKGUpfHx0LnB1c2goZSl9cmV0dXJuIHQubGVuZ3RoPjA/dDpudWxsfWFwcGVuZEZvbnRzKGUsdCl7dGhpcy5mb3JtW3lyXS5mb250RmluZGVyLmFkZChlLHQpfWFzeW5jIGdldFBhZ2VzKCl7dGhpcy5wYWdlc3x8YXdhaXQgdGhpcy5fY3JlYXRlUGFnZXMoKTtjb25zdCBlPXRoaXMucGFnZXM7dGhpcy5wYWdlcz1udWxsO3JldHVybiBlfXNlcmlhbGl6ZURhdGEoZSl7cmV0dXJuIHRoaXMuZGF0YUhhbmRsZXIuc2VyaWFsaXplKGUpfXN0YXRpYyBfY3JlYXRlRG9jdW1lbnQoZSl7cmV0dXJuIGVbIi94ZHA6eGRwIl0/T2JqZWN0LnZhbHVlcyhlKS5qb2luKCIiKTplWyJ4ZHA6eGRwIl19c3RhdGljIGdldFJpY2hUZXh0QXNIdG1sKGUpe2lmKCFlfHwic3RyaW5nIiE9dHlwZW9mIGUpcmV0dXJuIG51bGw7dHJ5e2xldCB0PW5ldyBYRkFQYXJzZXIoWGh0bWxOYW1lc3BhY2UsITApLnBhcnNlKGUpO2lmKCFbImJvZHkiLCJ4aHRtbCJdLmluY2x1ZGVzKHRbWXJdKSl7Y29uc3QgZT1YaHRtbE5hbWVzcGFjZS5ib2R5KHt9KTtlW1hzXSh0KTt0PWV9Y29uc3QgaT10W2FuXSgpO2lmKCFpLnN1Y2Nlc3MpcmV0dXJuIG51bGw7Y29uc3R7aHRtbDphfT1pLHthdHRyaWJ1dGVzOnN9PWE7aWYocyl7cy5jbGFzcyYmKHMuY2xhc3M9cy5jbGFzcy5maWx0ZXIoKGU9PiFlLnN0YXJ0c1dpdGgoInhmYSIpKSkpO3MuZGlyPSJhdXRvIn1yZXR1cm57aHRtbDphLHN0cjp0W2VuXSgpfX1jYXRjaChlKXt3YXJuKGBYRkEgLSBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgcGFyc2luZyBvZiByaWNoIHRleHQ6ICR7ZX1gKX1yZXR1cm4gbnVsbH19Y2xhc3MgQW5ub3RhdGlvbkZhY3Rvcnl7c3RhdGljIGNyZWF0ZUdsb2JhbHMoZSl7cmV0dXJuIFByb21pc2UuYWxsKFtlLmVuc3VyZUNhdGFsb2coImFjcm9Gb3JtIiksZS5lbnN1cmVEb2MoInhmYURhdGFzZXRzIiksZS5lbnN1cmVDYXRhbG9nKCJzdHJ1Y3RUcmVlUm9vdCIpLGUuZW5zdXJlQ2F0YWxvZygiYmFzZVVybCIpLGUuZW5zdXJlQ2F0YWxvZygiYXR0YWNobWVudHMiKV0pLnRoZW4oKChbdCxpLGEscyxyXSk9Pih7cGRmTWFuYWdlcjplLGFjcm9Gb3JtOnQgaW5zdGFuY2VvZiBEaWN0P3Q6RGljdC5lbXB0eSx4ZmFEYXRhc2V0czppLHN0cnVjdFRyZWVSb290OmEsYmFzZVVybDpzLGF0dGFjaG1lbnRzOnJ9KSksKGU9Pnt3YXJuKGBjcmVhdGVHbG9iYWxzOiAiJHtlfSIuYCk7cmV0dXJuIG51bGx9KSl9c3RhdGljIGFzeW5jIGNyZWF0ZShlLHQsaSxhLHMscil7Y29uc3Qgbj1zP2F3YWl0IHRoaXMuX2dldFBhZ2VJbmRleChlLHQsaS5wZGZNYW5hZ2VyKTpudWxsO3JldHVybiBpLnBkZk1hbmFnZXIuZW5zdXJlKHRoaXMsIl9jcmVhdGUiLFtlLHQsaSxhLHMsbixyXSl9c3RhdGljIF9jcmVhdGUoZSx0LGksYSxzPSExLHI9bnVsbCxuPW51bGwpe2NvbnN0IG89ZS5mZXRjaElmUmVmKHQpO2lmKCEobyBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtjb25zdHthY3JvRm9ybTpnLHBkZk1hbmFnZXI6Y309aSxDPXQgaW5zdGFuY2VvZiBSZWY/dC50b1N0cmluZygpOmBhbm5vdF8ke2EuY3JlYXRlT2JqSWQoKX1gO2xldCBoPW8uZ2V0KCJTdWJ0eXBlIik7aD1oIGluc3RhbmNlb2YgTmFtZT9oLm5hbWU6bnVsbDtjb25zdCBsPXt4cmVmOmUscmVmOnQsZGljdDpvLHN1YnR5cGU6aCxpZDpDLGFubm90YXRpb25HbG9iYWxzOmksY29sbGVjdEZpZWxkczpzLG5lZWRBcHBlYXJhbmNlczohcyYmITA9PT1nLmdldCgiTmVlZEFwcGVhcmFuY2VzIikscGFnZUluZGV4OnIsZXZhbHVhdG9yT3B0aW9uczpjLmV2YWx1YXRvck9wdGlvbnMscGFnZVJlZjpufTtzd2l0Y2goaCl7Y2FzZSJMaW5rIjpyZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uKGwpO2Nhc2UiVGV4dCI6cmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbihsKTtjYXNlIldpZGdldCI6bGV0IGU9Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDpvLGtleToiRlQifSk7ZT1lIGluc3RhbmNlb2YgTmFtZT9lLm5hbWU6bnVsbDtzd2l0Y2goZSl7Y2FzZSJUeCI6cmV0dXJuIG5ldyBUZXh0V2lkZ2V0QW5ub3RhdGlvbihsKTtjYXNlIkJ0biI6cmV0dXJuIG5ldyBCdXR0b25XaWRnZXRBbm5vdGF0aW9uKGwpO2Nhc2UiQ2giOnJldHVybiBuZXcgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbihsKTtjYXNlIlNpZyI6cmV0dXJuIG5ldyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uKGwpfXdhcm4oYFVuaW1wbGVtZW50ZWQgd2lkZ2V0IGZpZWxkIHR5cGUgIiR7ZX0iLCBmYWxsaW5nIGJhY2sgdG8gYmFzZSBmaWVsZCB0eXBlLmApO3JldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbihsKTtjYXNlIlBvcHVwIjpyZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbihsKTtjYXNlIkZyZWVUZXh0IjpyZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbihsKTtjYXNlIkxpbmUiOnJldHVybiBuZXcgTGluZUFubm90YXRpb24obCk7Y2FzZSJTcXVhcmUiOnJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbihsKTtjYXNlIkNpcmNsZSI6cmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uKGwpO2Nhc2UiUG9seUxpbmUiOnJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uKGwpO2Nhc2UiUG9seWdvbiI6cmV0dXJuIG5ldyBQb2x5Z29uQW5ub3RhdGlvbihsKTtjYXNlIkNhcmV0IjpyZXR1cm4gbmV3IENhcmV0QW5ub3RhdGlvbihsKTtjYXNlIkluayI6cmV0dXJuIG5ldyBJbmtBbm5vdGF0aW9uKGwpO2Nhc2UiSGlnaGxpZ2h0IjpyZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb24obCk7Y2FzZSJVbmRlcmxpbmUiOnJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbihsKTtjYXNlIlNxdWlnZ2x5IjpyZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbihsKTtjYXNlIlN0cmlrZU91dCI6cmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uKGwpO2Nhc2UiU3RhbXAiOnJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uKGwpO2Nhc2UiRmlsZUF0dGFjaG1lbnQiOnJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uKGwpO2RlZmF1bHQ6c3x8d2FybihoP2BVbmltcGxlbWVudGVkIGFubm90YXRpb24gdHlwZSAiJHtofSIsIGZhbGxpbmcgYmFjayB0byBiYXNlIGFubm90YXRpb24uYDoiQW5ub3RhdGlvbiBpcyBtaXNzaW5nIHRoZSByZXF1aXJlZCAvU3VidHlwZS4iKTtyZXR1cm4gbmV3IEFubm90YXRpb24obCl9fXN0YXRpYyBhc3luYyBfZ2V0UGFnZUluZGV4KGUsdCxpKXt0cnl7Y29uc3QgYT1hd2FpdCBlLmZldGNoSWZSZWZBc3luYyh0KTtpZighKGEgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm4tMTtjb25zdCBzPWEuZ2V0UmF3KCJQIik7aWYocyBpbnN0YW5jZW9mIFJlZil0cnl7cmV0dXJuIGF3YWl0IGkuZW5zdXJlQ2F0YWxvZygiZ2V0UGFnZUluZGV4Iixbc10pfWNhdGNoKGUpe2luZm8oYF9nZXRQYWdlSW5kZXggLS0gbm90IGEgdmFsaWQgcGFnZSByZWZlcmVuY2U6ICIke2V9Ii5gKX1pZihhLmhhcygiS2lkcyIpKXJldHVybi0xO2NvbnN0IHI9YXdhaXQgaS5lbnN1cmVEb2MoIm51bVBhZ2VzIik7Zm9yKGxldCBlPTA7ZTxyO2UrKyl7Y29uc3QgYT1hd2FpdCBpLmdldFBhZ2UoZSkscz1hd2FpdCBpLmVuc3VyZShhLCJhbm5vdGF0aW9ucyIpO2Zvcihjb25zdCBpIG9mIHMpaWYoaSBpbnN0YW5jZW9mIFJlZiYmaXNSZWZzRXF1YWwoaSx0KSlyZXR1cm4gZX19Y2F0Y2goZSl7d2FybihgX2dldFBhZ2VJbmRleDogIiR7ZX0iLmApfXJldHVybi0xfXN0YXRpYyBnZW5lcmF0ZUltYWdlcyhlLHQsaSl7aWYoIWkpe3dhcm4oImdlbmVyYXRlSW1hZ2VzOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZCwgY2Fubm90IHNhdmUgb3IgcHJpbnQgc29tZSBhbm5vdGF0aW9ucyB3aXRoIGltYWdlcy4iKTtyZXR1cm4gbnVsbH1sZXQgYTtmb3IoY29uc3R7Yml0bWFwSWQ6aSxiaXRtYXA6c31vZiBlKWlmKHMpe2F8fD1uZXcgTWFwO2Euc2V0KGksU3RhbXBBbm5vdGF0aW9uLmNyZWF0ZUltYWdlKHMsdCkpfXJldHVybiBhfXN0YXRpYyBhc3luYyBzYXZlTmV3QW5ub3RhdGlvbnMoZSx0LGksYSl7Y29uc3Qgcz1lLnhyZWY7bGV0IHI7Y29uc3Qgbj1bXSxvPVtdLHtpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDpnfT1lLm9wdGlvbnM7Zm9yKGNvbnN0IGMgb2YgaSlpZighYy5kZWxldGVkKXN3aXRjaChjLmFubm90YXRpb25UeXBlKXtjYXNlIHU6aWYoIXIpe2NvbnN0IGU9bmV3IERpY3Qocyk7ZS5zZXQoIkJhc2VGb250IixOYW1lLmdldCgiSGVsdmV0aWNhIikpO2Uuc2V0KCJUeXBlIixOYW1lLmdldCgiRm9udCIpKTtlLnNldCgiU3VidHlwZSIsTmFtZS5nZXQoIlR5cGUxIikpO2Uuc2V0KCJFbmNvZGluZyIsTmFtZS5nZXQoIldpbkFuc2lFbmNvZGluZyIpKTtjb25zdCB0PVtdO3I9cy5nZXROZXdUZW1wb3JhcnlSZWYoKTthd2FpdCB3cml0ZU9iamVjdChyLGUsdCxzKTtuLnB1c2goe3JlZjpyLGRhdGE6dC5qb2luKCIiKX0pfW8ucHVzaChGcmVlVGV4dEFubm90YXRpb24uY3JlYXRlTmV3QW5ub3RhdGlvbihzLGMsbix7ZXZhbHVhdG9yOmUsdGFzazp0LGJhc2VGb250UmVmOnJ9KSk7YnJlYWs7Y2FzZSBkOmMucXVhZFBvaW50cz9vLnB1c2goSGlnaGxpZ2h0QW5ub3RhdGlvbi5jcmVhdGVOZXdBbm5vdGF0aW9uKHMsYyxuKSk6by5wdXNoKElua0Fubm90YXRpb24uY3JlYXRlTmV3QW5ub3RhdGlvbihzLGMsbikpO2JyZWFrO2Nhc2UgcDpvLnB1c2goSW5rQW5ub3RhdGlvbi5jcmVhdGVOZXdBbm5vdGF0aW9uKHMsYyxuKSk7YnJlYWs7Y2FzZSBmOmlmKCFnKWJyZWFrO2NvbnN0IGk9YXdhaXQgYS5nZXQoYy5iaXRtYXBJZCk7aWYoaS5pbWFnZVN0cmVhbSl7Y29uc3R7aW1hZ2VTdHJlYW06ZSxzbWFza1N0cmVhbTp0fT1pLGE9W107aWYodCl7Y29uc3QgaT1zLmdldE5ld1RlbXBvcmFyeVJlZigpO2F3YWl0IHdyaXRlT2JqZWN0KGksdCxhLHMpO24ucHVzaCh7cmVmOmksZGF0YTphLmpvaW4oIiIpfSk7ZS5kaWN0LnNldCgiU01hc2siLGkpO2EubGVuZ3RoPTB9Y29uc3Qgcj1pLmltYWdlUmVmPXMuZ2V0TmV3VGVtcG9yYXJ5UmVmKCk7YXdhaXQgd3JpdGVPYmplY3QocixlLGEscyk7bi5wdXNoKHtyZWY6cixkYXRhOmEuam9pbigiIil9KTtpLmltYWdlU3RyZWFtPWkuc21hc2tTdHJlYW09bnVsbH1vLnB1c2goU3RhbXBBbm5vdGF0aW9uLmNyZWF0ZU5ld0Fubm90YXRpb24ocyxjLG4se2ltYWdlOml9KSl9cmV0dXJue2Fubm90YXRpb25zOmF3YWl0IFByb21pc2UuYWxsKG8pLGRlcGVuZGVuY2llczpufX1zdGF0aWMgYXN5bmMgcHJpbnROZXdBbm5vdGF0aW9ucyhlLHQsaSxhLHMpe2lmKCFhKXJldHVybiBudWxsO2NvbnN0e29wdGlvbnM6cix4cmVmOm59PXQsbz1bXTtmb3IoY29uc3QgZyBvZiBhKWlmKCFnLmRlbGV0ZWQpc3dpdGNoKGcuYW5ub3RhdGlvblR5cGUpe2Nhc2UgdTpvLnB1c2goRnJlZVRleHRBbm5vdGF0aW9uLmNyZWF0ZU5ld1ByaW50QW5ub3RhdGlvbihlLG4sZyx7ZXZhbHVhdG9yOnQsdGFzazppLGV2YWx1YXRvck9wdGlvbnM6cn0pKTticmVhaztjYXNlIGQ6Zy5xdWFkUG9pbnRzP28ucHVzaChIaWdobGlnaHRBbm5vdGF0aW9uLmNyZWF0ZU5ld1ByaW50QW5ub3RhdGlvbihlLG4sZyx7ZXZhbHVhdG9yT3B0aW9uczpyfSkpOm8ucHVzaChJbmtBbm5vdGF0aW9uLmNyZWF0ZU5ld1ByaW50QW5ub3RhdGlvbihlLG4sZyx7ZXZhbHVhdG9yT3B0aW9uczpyfSkpO2JyZWFrO2Nhc2UgcDpvLnB1c2goSW5rQW5ub3RhdGlvbi5jcmVhdGVOZXdQcmludEFubm90YXRpb24oZSxuLGcse2V2YWx1YXRvck9wdGlvbnM6cn0pKTticmVhaztjYXNlIGY6aWYoIXIuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpYnJlYWs7Y29uc3QgYT1hd2FpdCBzLmdldChnLmJpdG1hcElkKTtpZihhLmltYWdlU3RyZWFtKXtjb25zdHtpbWFnZVN0cmVhbTplLHNtYXNrU3RyZWFtOnR9PWE7dCYmZS5kaWN0LnNldCgiU01hc2siLHQpO2EuaW1hZ2VSZWY9bmV3IEpwZWdTdHJlYW0oZSxlLmxlbmd0aCk7YS5pbWFnZVN0cmVhbT1hLnNtYXNrU3RyZWFtPW51bGx9by5wdXNoKFN0YW1wQW5ub3RhdGlvbi5jcmVhdGVOZXdQcmludEFubm90YXRpb24oZSxuLGcse2ltYWdlOmEsZXZhbHVhdG9yT3B0aW9uczpyfSkpfXJldHVybiBQcm9taXNlLmFsbChvKX19ZnVuY3Rpb24gZ2V0UmdiQ29sb3IoZSx0PW5ldyBVaW50OENsYW1wZWRBcnJheSgzKSl7aWYoIUFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIHQ7Y29uc3QgaT10fHxuZXcgVWludDhDbGFtcGVkQXJyYXkoMyk7c3dpdGNoKGUubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIG51bGw7Y2FzZSAxOkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5ncmF5LmdldFJnYkl0ZW0oZSwwLGksMCk7cmV0dXJuIGk7Y2FzZSAzOkNvbG9yU3BhY2Uuc2luZ2xldG9ucy5yZ2IuZ2V0UmdiSXRlbShlLDAsaSwwKTtyZXR1cm4gaTtjYXNlIDQ6Q29sb3JTcGFjZS5zaW5nbGV0b25zLmNteWsuZ2V0UmdiSXRlbShlLDAsaSwwKTtyZXR1cm4gaTtkZWZhdWx0OnJldHVybiB0fX1mdW5jdGlvbiBnZXRQZGZDb2xvckFycmF5KGUpe3JldHVybiBBcnJheS5mcm9tKGUsKGU9PmUvMjU1KSl9ZnVuY3Rpb24gZ2V0UXVhZFBvaW50cyhlLHQpe2NvbnN0IGk9ZS5nZXRBcnJheSgiUXVhZFBvaW50cyIpO2lmKCFBcnJheS5pc0FycmF5KGkpfHwwPT09aS5sZW5ndGh8fGkubGVuZ3RoJTg+MClyZXR1cm4gbnVsbDtjb25zdCBhPVtdO2ZvcihsZXQgZT0wLHM9aS5sZW5ndGgvODtlPHM7ZSsrKXtsZXQgcz0xLzAscj0tMS8wLG49MS8wLG89LTEvMDtmb3IobGV0IHQ9OCplLGE9OCplKzg7dDxhO3QrPTIpe2NvbnN0IGU9aVt0XSxhPWlbdCsxXTtzPU1hdGgubWluKGUscyk7cj1NYXRoLm1heChlLHIpO249TWF0aC5taW4oYSxuKTtvPU1hdGgubWF4KGEsbyl9aWYobnVsbCE9PXQmJihzPHRbMF18fHI+dFsyXXx8bjx0WzFdfHxvPnRbM10pKXJldHVybiBudWxsO2EucHVzaChbe3g6cyx5Om99LHt4OnIseTpvfSx7eDpzLHk6bn0se3g6cix5Om59XSl9cmV0dXJuIGF9ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtTWF0cml4KGUsdCxpKXtjb25zdFthLHMscixuXT1VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHQsaSk7aWYoYT09PXJ8fHM9PT1uKXJldHVyblsxLDAsMCwxLGVbMF0sZVsxXV07Y29uc3Qgbz0oZVsyXS1lWzBdKS8oci1hKSxnPShlWzNdLWVbMV0pLyhuLXMpO3JldHVybltvLDAsMCxnLGVbMF0tYSpvLGVbMV0tcypnXX1jbGFzcyBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe2NvbnN0e2RpY3Q6dCx4cmVmOmksYW5ub3RhdGlvbkdsb2JhbHM6YX09ZTt0aGlzLnNldFRpdGxlKHQuZ2V0KCJUIikpO3RoaXMuc2V0Q29udGVudHModC5nZXQoIkNvbnRlbnRzIikpO3RoaXMuc2V0TW9kaWZpY2F0aW9uRGF0ZSh0LmdldCgiTSIpKTt0aGlzLnNldEZsYWdzKHQuZ2V0KCJGIikpO3RoaXMuc2V0UmVjdGFuZ2xlKHQuZ2V0QXJyYXkoIlJlY3QiKSk7dGhpcy5zZXRDb2xvcih0LmdldEFycmF5KCJDIikpO3RoaXMuc2V0Qm9yZGVyU3R5bGUodCk7dGhpcy5zZXRBcHBlYXJhbmNlKHQpO3RoaXMuc2V0T3B0aW9uYWxDb250ZW50KHQpO2NvbnN0IHM9dC5nZXQoIk1LIik7dGhpcy5zZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQ29sb3JzKHMpO3RoaXMuc2V0Um90YXRpb24ocyx0KTt0aGlzLnJlZj1lLnJlZiBpbnN0YW5jZW9mIFJlZj9lLnJlZjpudWxsO3RoaXMuX3N0cmVhbXM9W107dGhpcy5hcHBlYXJhbmNlJiZ0aGlzLl9zdHJlYW1zLnB1c2godGhpcy5hcHBlYXJhbmNlKTtjb25zdCByPSEhKHRoaXMuZmxhZ3MmQUEpLG49ISEodGhpcy5mbGFncyZlQSk7aWYoYS5zdHJ1Y3RUcmVlUm9vdCl7bGV0IGk9dC5nZXQoIlN0cnVjdFBhcmVudCIpO2k9TnVtYmVyLmlzSW50ZWdlcihpKSYmaT49MD9pOi0xO2Euc3RydWN0VHJlZVJvb3QuYWRkQW5ub3RhdGlvbklkVG9QYWdlKGUucGFnZVJlZixpKX10aGlzLmRhdGE9e2Fubm90YXRpb25GbGFnczp0aGlzLmZsYWdzLGJvcmRlclN0eWxlOnRoaXMuYm9yZGVyU3R5bGUsY29sb3I6dGhpcy5jb2xvcixiYWNrZ3JvdW5kQ29sb3I6dGhpcy5iYWNrZ3JvdW5kQ29sb3IsYm9yZGVyQ29sb3I6dGhpcy5ib3JkZXJDb2xvcixyb3RhdGlvbjp0aGlzLnJvdGF0aW9uLGNvbnRlbnRzT2JqOnRoaXMuX2NvbnRlbnRzLGhhc0FwcGVhcmFuY2U6ISF0aGlzLmFwcGVhcmFuY2UsaWQ6ZS5pZCxtb2RpZmljYXRpb25EYXRlOnRoaXMubW9kaWZpY2F0aW9uRGF0ZSxyZWN0OnRoaXMucmVjdGFuZ2xlLHN1YnR5cGU6ZS5zdWJ0eXBlLGhhc093bkNhbnZhczohMSxub1JvdGF0ZTohISh0aGlzLmZsYWdzJl8pLG5vSFRNTDpyJiZufTtpZihlLmNvbGxlY3RGaWVsZHMpe2NvbnN0IGE9dC5nZXQoIktpZHMiKTtpZihBcnJheS5pc0FycmF5KGEpKXtjb25zdCBlPVtdO2Zvcihjb25zdCB0IG9mIGEpdCBpbnN0YW5jZW9mIFJlZiYmZS5wdXNoKHQudG9TdHJpbmcoKSk7MCE9PWUubGVuZ3RoJiYodGhpcy5kYXRhLmtpZElkcz1lKX10aGlzLmRhdGEuYWN0aW9ucz1jb2xsZWN0QWN0aW9ucyhpLHQsdUEpO3RoaXMuZGF0YS5maWVsZE5hbWU9dGhpcy5fY29uc3RydWN0RmllbGROYW1lKHQpO3RoaXMuZGF0YS5wYWdlSW5kZXg9ZS5wYWdlSW5kZXh9dGhpcy5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ9ZS5ldmFsdWF0b3JPcHRpb25zLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkO3RoaXMuX2ZhbGxiYWNrRm9udERpY3Q9bnVsbDt0aGlzLl9uZWVkQXBwZWFyYW5jZXM9ITF9X2hhc0ZsYWcoZSx0KXtyZXR1cm4hIShlJnQpfV9pc1ZpZXdhYmxlKGUpe3JldHVybiF0aGlzLl9oYXNGbGFnKGUsWikmJiF0aGlzLl9oYXNGbGFnKGUsJCl9X2lzUHJpbnRhYmxlKGUpe3JldHVybiB0aGlzLl9oYXNGbGFnKGUseikmJiF0aGlzLl9oYXNGbGFnKGUsVikmJiF0aGlzLl9oYXNGbGFnKGUsWil9bXVzdEJlVmlld2VkKGUsdCl7Y29uc3QgaT1lPy5nZXQodGhpcy5kYXRhLmlkKT8ubm9WaWV3O3JldHVybiB2b2lkIDAhPT1pPyFpOnRoaXMudmlld2FibGUmJiF0aGlzLl9oYXNGbGFnKHRoaXMuZmxhZ3MsVil9bXVzdEJlUHJpbnRlZChlKXtjb25zdCB0PWU/LmdldCh0aGlzLmRhdGEuaWQpPy5ub1ByaW50O3JldHVybiB2b2lkIDAhPT10PyF0OnRoaXMucHJpbnRhYmxlfWdldCB2aWV3YWJsZSgpe3JldHVybiBudWxsIT09dGhpcy5kYXRhLnF1YWRQb2ludHMmJigwPT09dGhpcy5mbGFnc3x8dGhpcy5faXNWaWV3YWJsZSh0aGlzLmZsYWdzKSl9Z2V0IHByaW50YWJsZSgpe3JldHVybiBudWxsIT09dGhpcy5kYXRhLnF1YWRQb2ludHMmJigwIT09dGhpcy5mbGFncyYmdGhpcy5faXNQcmludGFibGUodGhpcy5mbGFncykpfV9wYXJzZVN0cmluZ0hlbHBlcihlKXtjb25zdCB0PSJzdHJpbmciPT10eXBlb2YgZT9zdHJpbmdUb1BERlN0cmluZyhlKToiIjtyZXR1cm57c3RyOnQsZGlyOnQmJiJydGwiPT09YmlkaSh0KS5kaXI/InJ0bCI6Imx0ciJ9fXNldERlZmF1bHRBcHBlYXJhbmNlKGUpe2NvbnN0e2RpY3Q6dCxhbm5vdGF0aW9uR2xvYmFsczppfT1lLGE9Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0LGtleToiREEifSl8fGkuYWNyb0Zvcm0uZ2V0KCJEQSIpO3RoaXMuX2RlZmF1bHRBcHBlYXJhbmNlPSJzdHJpbmciPT10eXBlb2YgYT9hOiIiO3RoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE9cGFyc2VEZWZhdWx0QXBwZWFyYW5jZSh0aGlzLl9kZWZhdWx0QXBwZWFyYW5jZSl9c2V0VGl0bGUoZSl7dGhpcy5fdGl0bGU9dGhpcy5fcGFyc2VTdHJpbmdIZWxwZXIoZSl9c2V0Q29udGVudHMoZSl7dGhpcy5fY29udGVudHM9dGhpcy5fcGFyc2VTdHJpbmdIZWxwZXIoZSl9c2V0TW9kaWZpY2F0aW9uRGF0ZShlKXt0aGlzLm1vZGlmaWNhdGlvbkRhdGU9InN0cmluZyI9PXR5cGVvZiBlP2U6bnVsbH1zZXRGbGFncyhlKXt0aGlzLmZsYWdzPU51bWJlci5pc0ludGVnZXIoZSkmJmU+MD9lOjA7dGhpcy5mbGFncyZaJiYiQW5ub3RhdGlvbiIhPT10aGlzLmNvbnN0cnVjdG9yLm5hbWUmJih0aGlzLmZsYWdzXj1aKX1oYXNGbGFnKGUpe3JldHVybiB0aGlzLl9oYXNGbGFnKHRoaXMuZmxhZ3MsZSl9c2V0UmVjdGFuZ2xlKGUpe3RoaXMucmVjdGFuZ2xlPUFycmF5LmlzQXJyYXkoZSkmJjQ9PT1lLmxlbmd0aD9VdGlsLm5vcm1hbGl6ZVJlY3QoZSk6WzAsMCwwLDBdfXNldENvbG9yKGUpe3RoaXMuY29sb3I9Z2V0UmdiQ29sb3IoZSl9c2V0TGluZUVuZGluZ3MoZSl7dGhpcy5saW5lRW5kaW5ncz1bIk5vbmUiLCJOb25lIl07aWYoQXJyYXkuaXNBcnJheShlKSYmMj09PWUubGVuZ3RoKWZvcihsZXQgdD0wO3Q8Mjt0Kyspe2NvbnN0IGk9ZVt0XTtpZihpIGluc3RhbmNlb2YgTmFtZSlzd2l0Y2goaS5uYW1lKXtjYXNlIk5vbmUiOmNvbnRpbnVlO2Nhc2UiU3F1YXJlIjpjYXNlIkNpcmNsZSI6Y2FzZSJEaWFtb25kIjpjYXNlIk9wZW5BcnJvdyI6Y2FzZSJDbG9zZWRBcnJvdyI6Y2FzZSJCdXR0IjpjYXNlIlJPcGVuQXJyb3ciOmNhc2UiUkNsb3NlZEFycm93IjpjYXNlIlNsYXNoIjp0aGlzLmxpbmVFbmRpbmdzW3RdPWkubmFtZTtjb250aW51ZX13YXJuKGBJZ25vcmluZyBpbnZhbGlkIGxpbmVFbmRpbmc6ICR7aX1gKX19c2V0Um90YXRpb24oZSx0KXt0aGlzLnJvdGF0aW9uPTA7bGV0IGk9ZSBpbnN0YW5jZW9mIERpY3Q/ZS5nZXQoIlIiKXx8MDp0LmdldCgiUm90YXRlIil8fDA7aWYoTnVtYmVyLmlzSW50ZWdlcihpKSYmMCE9PWkpe2klPTM2MDtpPDAmJihpKz0zNjApO2klOTA9PTAmJih0aGlzLnJvdGF0aW9uPWkpfX1zZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQ29sb3JzKGUpe2lmKGUgaW5zdGFuY2VvZiBEaWN0KXt0aGlzLmJvcmRlckNvbG9yPWdldFJnYkNvbG9yKGUuZ2V0QXJyYXkoIkJDIiksbnVsbCk7dGhpcy5iYWNrZ3JvdW5kQ29sb3I9Z2V0UmdiQ29sb3IoZS5nZXRBcnJheSgiQkciKSxudWxsKX1lbHNlIHRoaXMuYm9yZGVyQ29sb3I9dGhpcy5iYWNrZ3JvdW5kQ29sb3I9bnVsbH1zZXRCb3JkZXJTdHlsZShlKXt0aGlzLmJvcmRlclN0eWxlPW5ldyBBbm5vdGF0aW9uQm9yZGVyU3R5bGU7aWYoZSBpbnN0YW5jZW9mIERpY3QpaWYoZS5oYXMoIkJTIikpe2NvbnN0IHQ9ZS5nZXQoIkJTIik7aWYodCBpbnN0YW5jZW9mIERpY3Qpe2NvbnN0IGU9dC5nZXQoIlR5cGUiKTtpZighZXx8aXNOYW1lKGUsIkJvcmRlciIpKXt0aGlzLmJvcmRlclN0eWxlLnNldFdpZHRoKHQuZ2V0KCJXIiksdGhpcy5yZWN0YW5nbGUpO3RoaXMuYm9yZGVyU3R5bGUuc2V0U3R5bGUodC5nZXQoIlMiKSk7dGhpcy5ib3JkZXJTdHlsZS5zZXREYXNoQXJyYXkodC5nZXRBcnJheSgiRCIpKX19fWVsc2UgaWYoZS5oYXMoIkJvcmRlciIpKXtjb25zdCB0PWUuZ2V0QXJyYXkoIkJvcmRlciIpO2lmKEFycmF5LmlzQXJyYXkodCkmJnQubGVuZ3RoPj0zKXt0aGlzLmJvcmRlclN0eWxlLnNldEhvcml6b250YWxDb3JuZXJSYWRpdXModFswXSk7dGhpcy5ib3JkZXJTdHlsZS5zZXRWZXJ0aWNhbENvcm5lclJhZGl1cyh0WzFdKTt0aGlzLmJvcmRlclN0eWxlLnNldFdpZHRoKHRbMl0sdGhpcy5yZWN0YW5nbGUpOzQ9PT10Lmxlbmd0aCYmdGhpcy5ib3JkZXJTdHlsZS5zZXREYXNoQXJyYXkodFszXSwhMCl9fWVsc2UgdGhpcy5ib3JkZXJTdHlsZS5zZXRXaWR0aCgwKX1zZXRBcHBlYXJhbmNlKGUpe3RoaXMuYXBwZWFyYW5jZT1udWxsO2NvbnN0IHQ9ZS5nZXQoIkFQIik7aWYoISh0IGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2NvbnN0IGk9dC5nZXQoIk4iKTtpZihpIGluc3RhbmNlb2YgQmFzZVN0cmVhbSl7dGhpcy5hcHBlYXJhbmNlPWk7cmV0dXJufWlmKCEoaSBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtjb25zdCBhPWUuZ2V0KCJBUyIpO2lmKCEoYSBpbnN0YW5jZW9mIE5hbWUmJmkuaGFzKGEubmFtZSkpKXJldHVybjtjb25zdCBzPWkuZ2V0KGEubmFtZSk7cyBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJih0aGlzLmFwcGVhcmFuY2U9cyl9c2V0T3B0aW9uYWxDb250ZW50KGUpe3RoaXMub2M9bnVsbDtjb25zdCB0PWUuZ2V0KCJPQyIpO3QgaW5zdGFuY2VvZiBOYW1lP3dhcm4oInNldE9wdGlvbmFsQ29udGVudDogU3VwcG9ydCBmb3IgL05hbWUtZW50cnkgaXMgbm90IGltcGxlbWVudGVkLiIpOnQgaW5zdGFuY2VvZiBEaWN0JiYodGhpcy5vYz10KX1sb2FkUmVzb3VyY2VzKGUsdCl7cmV0dXJuIHQuZGljdC5nZXRBc3luYygiUmVzb3VyY2VzIikudGhlbigodD0+e2lmKCF0KXJldHVybjtyZXR1cm4gbmV3IE9iamVjdExvYWRlcih0LGUsdC54cmVmKS5sb2FkKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gdH0pKX0pKX1hc3luYyBnZXRPcGVyYXRvckxpc3QoZSx0LGksYSxzKXtjb25zdHtoYXNPd25DYW52YXM6cixpZDpuLHJlY3Q6b309dGhpcy5kYXRhO2xldCBjPXRoaXMuYXBwZWFyYW5jZTtjb25zdCBDPSEhKHImJmkmZyk7aWYoQyYmKG9bMF09PT1vWzJdfHxvWzFdPT09b1szXSkpe3RoaXMuZGF0YS5oYXNPd25DYW52YXM9ITE7cmV0dXJue29wTGlzdDpuZXcgT3BlcmF0b3JMaXN0LHNlcGFyYXRlRm9ybTohMSxzZXBhcmF0ZUNhbnZhczohMX19aWYoIWMpe2lmKCFDKXJldHVybntvcExpc3Q6bmV3IE9wZXJhdG9yTGlzdCxzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6ITF9O2M9bmV3IFN0cmluZ1N0cmVhbSgiIik7Yy5kaWN0PW5ldyBEaWN0fWNvbnN0IGg9Yy5kaWN0LGw9YXdhaXQgdGhpcy5sb2FkUmVzb3VyY2VzKFsiRXh0R1N0YXRlIiwiQ29sb3JTcGFjZSIsIlBhdHRlcm4iLCJTaGFkaW5nIiwiWE9iamVjdCIsIkZvbnQiXSxjKSxRPWguZ2V0QXJyYXkoIkJCb3giKXx8WzAsMCwxLDFdLEU9aC5nZXRBcnJheSgiTWF0cml4Iil8fFsxLDAsMCwxLDAsMF0sdT1nZXRUcmFuc2Zvcm1NYXRyaXgobyxRLEUpLGQ9bmV3IE9wZXJhdG9yTGlzdDtsZXQgZjt0aGlzLm9jJiYoZj1hd2FpdCBlLnBhcnNlTWFya2VkQ29udGVudFByb3BzKHRoaXMub2MsbnVsbCkpO3ZvaWQgMCE9PWYmJmQuYWRkT3AoSmUsWyJPQyIsZl0pO2QuYWRkT3AoV2UsW24sbyx1LEUsQ10pO2F3YWl0IGUuZ2V0T3BlcmF0b3JMaXN0KHtzdHJlYW06Yyx0YXNrOnQscmVzb3VyY2VzOmwsb3BlcmF0b3JMaXN0OmQsZmFsbGJhY2tGb250RGljdDp0aGlzLl9mYWxsYmFja0ZvbnREaWN0fSk7ZC5hZGRPcChqZSxbXSk7dm9pZCAwIT09ZiYmZC5hZGRPcChZZSxbXSk7dGhpcy5yZXNldCgpO3JldHVybntvcExpc3Q6ZCxzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6Q319YXN5bmMgc2F2ZShlLHQsaSl7cmV0dXJuIG51bGx9Z2V0IGhhc1RleHRDb250ZW50KCl7cmV0dXJuITF9YXN5bmMgZXh0cmFjdFRleHRDb250ZW50KGUsdCxpKXtpZighdGhpcy5hcHBlYXJhbmNlKXJldHVybjtjb25zdCBhPWF3YWl0IHRoaXMubG9hZFJlc291cmNlcyhbIkV4dEdTdGF0ZSIsIkZvbnQiLCJQcm9wZXJ0aWVzIiwiWE9iamVjdCJdLHRoaXMuYXBwZWFyYW5jZSkscz1bXSxyPVtdO2xldCBuPW51bGw7Y29uc3Qgbz17ZGVzaXJlZFNpemU6TWF0aC5JbmZpbml0eSxyZWFkeTohMCxlbnF1ZXVlKGUsdCl7Zm9yKGNvbnN0IHQgb2YgZS5pdGVtcylpZih2b2lkIDAhPT10LnN0cil7bnx8PXQudHJhbnNmb3JtLnNsaWNlKC0yKTtyLnB1c2godC5zdHIpO2lmKHQuaGFzRU9MKXtzLnB1c2goci5qb2luKCIiKS50cmltRW5kKCkpO3IubGVuZ3RoPTB9fX19O2F3YWl0IGUuZ2V0VGV4dENvbnRlbnQoe3N0cmVhbTp0aGlzLmFwcGVhcmFuY2UsdGFzazp0LHJlc291cmNlczphLGluY2x1ZGVNYXJrZWRDb250ZW50OiEwLGtlZXBXaGl0ZVNwYWNlOiEwLHNpbms6byx2aWV3Qm94Oml9KTt0aGlzLnJlc2V0KCk7ci5sZW5ndGgmJnMucHVzaChyLmpvaW4oIiIpLnRyaW1FbmQoKSk7aWYocy5sZW5ndGg+MXx8c1swXSl7Y29uc3QgZT10aGlzLmFwcGVhcmFuY2UuZGljdDt0aGlzLmRhdGEudGV4dFBvc2l0aW9uPXRoaXMuX3RyYW5zZm9ybVBvaW50KG4sZS5nZXRBcnJheSgiQkJveCIpLGUuZ2V0QXJyYXkoIk1hdHJpeCIpKTt0aGlzLmRhdGEudGV4dENvbnRlbnQ9c319X3RyYW5zZm9ybVBvaW50KGUsdCxpKXtjb25zdHtyZWN0OmF9PXRoaXMuZGF0YTt0fHw9WzAsMCwxLDFdO2l8fD1bMSwwLDAsMSwwLDBdO2NvbnN0IHM9Z2V0VHJhbnNmb3JtTWF0cml4KGEsdCxpKTtzWzRdLT1hWzBdO3NbNV0tPWFbMV07ZT1VdGlsLmFwcGx5VHJhbnNmb3JtKGUscyk7cmV0dXJuIFV0aWwuYXBwbHlUcmFuc2Zvcm0oZSxpKX1nZXRGaWVsZE9iamVjdCgpe3JldHVybiB0aGlzLmRhdGEua2lkSWRzP3tpZDp0aGlzLmRhdGEuaWQsYWN0aW9uczp0aGlzLmRhdGEuYWN0aW9ucyxuYW1lOnRoaXMuZGF0YS5maWVsZE5hbWUsc3Ryb2tlQ29sb3I6dGhpcy5kYXRhLmJvcmRlckNvbG9yLGZpbGxDb2xvcjp0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yLHR5cGU6IiIsa2lkSWRzOnRoaXMuZGF0YS5raWRJZHMscGFnZTp0aGlzLmRhdGEucGFnZUluZGV4LHJvdGF0aW9uOnRoaXMucm90YXRpb259Om51bGx9cmVzZXQoKXtmb3IoY29uc3QgZSBvZiB0aGlzLl9zdHJlYW1zKWUucmVzZXQoKX1fY29uc3RydWN0RmllbGROYW1lKGUpe2lmKCFlLmhhcygiVCIpJiYhZS5oYXMoIlBhcmVudCIpKXt3YXJuKCJVbmtub3duIGZpZWxkIG5hbWUsIGZhbGxpbmcgYmFjayB0byBlbXB0eSBmaWVsZCBuYW1lLiIpO3JldHVybiIifWlmKCFlLmhhcygiUGFyZW50IikpcmV0dXJuIHN0cmluZ1RvUERGU3RyaW5nKGUuZ2V0KCJUIikpO2NvbnN0IHQ9W107ZS5oYXMoIlQiKSYmdC51bnNoaWZ0KHN0cmluZ1RvUERGU3RyaW5nKGUuZ2V0KCJUIikpKTtsZXQgaT1lO2NvbnN0IGE9bmV3IFJlZlNldDtlLm9iaklkJiZhLnB1dChlLm9iaklkKTtmb3IoO2kuaGFzKCJQYXJlbnQiKTspe2k9aS5nZXQoIlBhcmVudCIpO2lmKCEoaSBpbnN0YW5jZW9mIERpY3QpfHxpLm9iaklkJiZhLmhhcyhpLm9iaklkKSlicmVhaztpLm9iaklkJiZhLnB1dChpLm9iaklkKTtpLmhhcygiVCIpJiZ0LnVuc2hpZnQoc3RyaW5nVG9QREZTdHJpbmcoaS5nZXQoIlQiKSkpfXJldHVybiB0LmpvaW4oIi4iKX19Y2xhc3MgQW5ub3RhdGlvbkJvcmRlclN0eWxle2NvbnN0cnVjdG9yKCl7dGhpcy53aWR0aD0xO3RoaXMuc3R5bGU9aEE7dGhpcy5kYXNoQXJyYXk9WzNdO3RoaXMuaG9yaXpvbnRhbENvcm5lclJhZGl1cz0wO3RoaXMudmVydGljYWxDb3JuZXJSYWRpdXM9MH1zZXRXaWR0aChlLHQ9WzAsMCwwLDBdKXtpZihlIGluc3RhbmNlb2YgTmFtZSl0aGlzLndpZHRoPTA7ZWxzZSBpZigibnVtYmVyIj09dHlwZW9mIGUpe2lmKGU+MCl7Y29uc3QgaT0odFsyXS10WzBdKS8yLGE9KHRbM10tdFsxXSkvMjtpZihpPjAmJmE+MCYmKGU+aXx8ZT5hKSl7d2FybihgQW5ub3RhdGlvbkJvcmRlclN0eWxlLnNldFdpZHRoIC0gaWdub3Jpbmcgd2lkdGg6ICR7ZX1gKTtlPTF9fXRoaXMud2lkdGg9ZX19c2V0U3R5bGUoZSl7aWYoZSBpbnN0YW5jZW9mIE5hbWUpc3dpdGNoKGUubmFtZSl7Y2FzZSJTIjp0aGlzLnN0eWxlPWhBO2JyZWFrO2Nhc2UiRCI6dGhpcy5zdHlsZT1sQTticmVhaztjYXNlIkIiOnRoaXMuc3R5bGU9QkE7YnJlYWs7Y2FzZSJJIjp0aGlzLnN0eWxlPVFBO2JyZWFrO2Nhc2UiVSI6dGhpcy5zdHlsZT1FQX19c2V0RGFzaEFycmF5KGUsdD0hMSl7aWYoQXJyYXkuaXNBcnJheShlKSl7bGV0IGk9ITAsYT0hMDtmb3IoY29uc3QgdCBvZiBlKXtpZighKCt0Pj0wKSl7aT0hMTticmVha310PjAmJihhPSExKX1pZigwPT09ZS5sZW5ndGh8fGkmJiFhKXt0aGlzLmRhc2hBcnJheT1lO3QmJnRoaXMuc2V0U3R5bGUoTmFtZS5nZXQoIkQiKSl9ZWxzZSB0aGlzLndpZHRoPTB9ZWxzZSBlJiYodGhpcy53aWR0aD0wKX1zZXRIb3Jpem9udGFsQ29ybmVyUmFkaXVzKGUpe051bWJlci5pc0ludGVnZXIoZSkmJih0aGlzLmhvcml6b250YWxDb3JuZXJSYWRpdXM9ZSl9c2V0VmVydGljYWxDb3JuZXJSYWRpdXMoZSl7TnVtYmVyLmlzSW50ZWdlcihlKSYmKHRoaXMudmVydGljYWxDb3JuZXJSYWRpdXM9ZSl9fWNsYXNzIE1hcmt1cEFubm90YXRpb24gZXh0ZW5kcyBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dH09ZTtpZih0LmhhcygiSVJUIikpe2NvbnN0IGU9dC5nZXRSYXcoIklSVCIpO3RoaXMuZGF0YS5pblJlcGx5VG89ZSBpbnN0YW5jZW9mIFJlZj9lLnRvU3RyaW5nKCk6bnVsbDtjb25zdCBpPXQuZ2V0KCJSVCIpO3RoaXMuZGF0YS5yZXBseVR5cGU9aSBpbnN0YW5jZW9mIE5hbWU/aS5uYW1lOlh9bGV0IGk9bnVsbDtpZih0aGlzLmRhdGEucmVwbHlUeXBlPT09ail7Y29uc3QgZT10LmdldCgiSVJUIik7dGhpcy5zZXRUaXRsZShlLmdldCgiVCIpKTt0aGlzLmRhdGEudGl0bGVPYmo9dGhpcy5fdGl0bGU7dGhpcy5zZXRDb250ZW50cyhlLmdldCgiQ29udGVudHMiKSk7dGhpcy5kYXRhLmNvbnRlbnRzT2JqPXRoaXMuX2NvbnRlbnRzO2lmKGUuaGFzKCJDcmVhdGlvbkRhdGUiKSl7dGhpcy5zZXRDcmVhdGlvbkRhdGUoZS5nZXQoIkNyZWF0aW9uRGF0ZSIpKTt0aGlzLmRhdGEuY3JlYXRpb25EYXRlPXRoaXMuY3JlYXRpb25EYXRlfWVsc2UgdGhpcy5kYXRhLmNyZWF0aW9uRGF0ZT1udWxsO2lmKGUuaGFzKCJNIikpe3RoaXMuc2V0TW9kaWZpY2F0aW9uRGF0ZShlLmdldCgiTSIpKTt0aGlzLmRhdGEubW9kaWZpY2F0aW9uRGF0ZT10aGlzLm1vZGlmaWNhdGlvbkRhdGV9ZWxzZSB0aGlzLmRhdGEubW9kaWZpY2F0aW9uRGF0ZT1udWxsO2k9ZS5nZXRSYXcoIlBvcHVwIik7aWYoZS5oYXMoIkMiKSl7dGhpcy5zZXRDb2xvcihlLmdldEFycmF5KCJDIikpO3RoaXMuZGF0YS5jb2xvcj10aGlzLmNvbG9yfWVsc2UgdGhpcy5kYXRhLmNvbG9yPW51bGx9ZWxzZXt0aGlzLmRhdGEudGl0bGVPYmo9dGhpcy5fdGl0bGU7dGhpcy5zZXRDcmVhdGlvbkRhdGUodC5nZXQoIkNyZWF0aW9uRGF0ZSIpKTt0aGlzLmRhdGEuY3JlYXRpb25EYXRlPXRoaXMuY3JlYXRpb25EYXRlO2k9dC5nZXRSYXcoIlBvcHVwIik7dC5oYXMoIkMiKXx8KHRoaXMuZGF0YS5jb2xvcj1udWxsKX10aGlzLmRhdGEucG9wdXBSZWY9aSBpbnN0YW5jZW9mIFJlZj9pLnRvU3RyaW5nKCk6bnVsbDt0LmhhcygiUkMiKSYmKHRoaXMuZGF0YS5yaWNoVGV4dD1YRkFGYWN0b3J5LmdldFJpY2hUZXh0QXNIdG1sKHQuZ2V0KCJSQyIpKSl9c2V0Q3JlYXRpb25EYXRlKGUpe3RoaXMuY3JlYXRpb25EYXRlPSJzdHJpbmciPT10eXBlb2YgZT9lOm51bGx9X3NldERlZmF1bHRBcHBlYXJhbmNlKHt4cmVmOmUsZXh0cmE6dCxzdHJva2VDb2xvcjppLGZpbGxDb2xvcjphLGJsZW5kTW9kZTpzLHN0cm9rZUFscGhhOnIsZmlsbEFscGhhOm4scG9pbnRzQ2FsbGJhY2s6b30pe2xldCBnPU51bWJlci5NQVhfVkFMVUUsYz1OdW1iZXIuTUFYX1ZBTFVFLEM9TnVtYmVyLk1JTl9WQUxVRSxoPU51bWJlci5NSU5fVkFMVUU7Y29uc3QgbD1bInEiXTt0JiZsLnB1c2godCk7aSYmbC5wdXNoKGAke2lbMF19ICR7aVsxXX0gJHtpWzJdfSBSR2ApO2EmJmwucHVzaChgJHthWzBdfSAke2FbMV19ICR7YVsyXX0gcmdgKTtsZXQgUT10aGlzLmRhdGEucXVhZFBvaW50cztRfHwoUT1bW3t4OnRoaXMucmVjdGFuZ2xlWzBdLHk6dGhpcy5yZWN0YW5nbGVbM119LHt4OnRoaXMucmVjdGFuZ2xlWzJdLHk6dGhpcy5yZWN0YW5nbGVbM119LHt4OnRoaXMucmVjdGFuZ2xlWzBdLHk6dGhpcy5yZWN0YW5nbGVbMV19LHt4OnRoaXMucmVjdGFuZ2xlWzJdLHk6dGhpcy5yZWN0YW5nbGVbMV19XV0pO2Zvcihjb25zdCBlIG9mIFEpe2NvbnN0W3QsaSxhLHNdPW8obCxlKTtnPU1hdGgubWluKGcsdCk7Qz1NYXRoLm1heChDLGkpO2M9TWF0aC5taW4oYyxhKTtoPU1hdGgubWF4KGgscyl9bC5wdXNoKCJRIik7Y29uc3QgRT1uZXcgRGljdChlKSx1PW5ldyBEaWN0KGUpO3Uuc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiRm9ybSIpKTtjb25zdCBkPW5ldyBTdHJpbmdTdHJlYW0obC5qb2luKCIgIikpO2QuZGljdD11O0Uuc2V0KCJGbTAiLGQpO2NvbnN0IGY9bmV3IERpY3QoZSk7cyYmZi5zZXQoIkJNIixOYW1lLmdldChzKSk7Im51bWJlciI9PXR5cGVvZiByJiZmLnNldCgiQ0EiLHIpOyJudW1iZXIiPT10eXBlb2YgbiYmZi5zZXQoImNhIixuKTtjb25zdCBwPW5ldyBEaWN0KGUpO3Auc2V0KCJHUzAiLGYpO2NvbnN0IG09bmV3IERpY3QoZSk7bS5zZXQoIkV4dEdTdGF0ZSIscCk7bS5zZXQoIlhPYmplY3QiLEUpO2NvbnN0IHk9bmV3IERpY3QoZSk7eS5zZXQoIlJlc291cmNlcyIsbSk7Y29uc3Qgdz10aGlzLmRhdGEucmVjdD1bZyxjLEMsaF07eS5zZXQoIkJCb3giLHcpO3RoaXMuYXBwZWFyYW5jZT1uZXcgU3RyaW5nU3RyZWFtKCIvR1MwIGdzIC9GbTAgRG8iKTt0aGlzLmFwcGVhcmFuY2UuZGljdD15O3RoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmFwcGVhcmFuY2UsZCl9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0Fubm90YXRpb24oZSx0LGksYSl7Y29uc3Qgcz10LnJlZnx8PWUuZ2V0TmV3VGVtcG9yYXJ5UmVmKCkscj1hd2FpdCB0aGlzLmNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0odCxlLGEpLG49W107bGV0IG87aWYocil7Y29uc3QgYT1lLmdldE5ld1RlbXBvcmFyeVJlZigpO289dGhpcy5jcmVhdGVOZXdEaWN0KHQsZSx7YXBSZWY6YX0pO2F3YWl0IHdyaXRlT2JqZWN0KGEscixuLGUpO2kucHVzaCh7cmVmOmEsZGF0YTpuLmpvaW4oIiIpfSl9ZWxzZSBvPXRoaXMuY3JlYXRlTmV3RGljdCh0LGUse30pO051bWJlci5pc0ludGVnZXIodC5wYXJlbnRUcmVlSWQpJiZvLnNldCgiU3RydWN0UGFyZW50Iix0LnBhcmVudFRyZWVJZCk7bi5sZW5ndGg9MDthd2FpdCB3cml0ZU9iamVjdChzLG8sbixlKTtyZXR1cm57cmVmOnMsZGF0YTpuLmpvaW4oIiIpfX1zdGF0aWMgYXN5bmMgY3JlYXRlTmV3UHJpbnRBbm5vdGF0aW9uKGUsdCxpLGEpe2NvbnN0IHM9YXdhaXQgdGhpcy5jcmVhdGVOZXdBcHBlYXJhbmNlU3RyZWFtKGksdCxhKSxyPXRoaXMuY3JlYXRlTmV3RGljdChpLHQse2FwOnN9KSxuPW5ldyB0aGlzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcih7ZGljdDpyLHhyZWY6dCxhbm5vdGF0aW9uR2xvYmFsczplLGV2YWx1YXRvck9wdGlvbnM6YS5ldmFsdWF0b3JPcHRpb25zfSk7aS5yZWYmJihuLnJlZj1uLnJlZlRvUmVwbGFjZT1pLnJlZik7cmV0dXJuIG59fWNsYXNzIFdpZGdldEFubm90YXRpb24gZXh0ZW5kcyBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dCx4cmVmOmksYW5ub3RhdGlvbkdsb2JhbHM6YX09ZSxzPXRoaXMuZGF0YTt0aGlzLl9uZWVkQXBwZWFyYW5jZXM9ZS5uZWVkQXBwZWFyYW5jZXM7cy5hbm5vdGF0aW9uVHlwZT1XO3ZvaWQgMD09PXMuZmllbGROYW1lJiYocy5maWVsZE5hbWU9dGhpcy5fY29uc3RydWN0RmllbGROYW1lKHQpKTt2b2lkIDA9PT1zLmFjdGlvbnMmJihzLmFjdGlvbnM9Y29sbGVjdEFjdGlvbnMoaSx0LHVBKSk7bGV0IHI9Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0LGtleToiViIsZ2V0QXJyYXk6ITB9KTtzLmZpZWxkVmFsdWU9dGhpcy5fZGVjb2RlRm9ybVZhbHVlKHIpO2NvbnN0IG49Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0LGtleToiRFYiLGdldEFycmF5OiEwfSk7cy5kZWZhdWx0RmllbGRWYWx1ZT10aGlzLl9kZWNvZGVGb3JtVmFsdWUobik7aWYodm9pZCAwPT09ciYmYS54ZmFEYXRhc2V0cyl7Y29uc3QgZT10aGlzLl90aXRsZS5zdHI7aWYoZSl7dGhpcy5faGFzVmFsdWVGcm9tWEZBPSEwO3MuZmllbGRWYWx1ZT1yPWEueGZhRGF0YXNldHMuZ2V0VmFsdWUoZSl9fXZvaWQgMD09PXImJm51bGwhPT1zLmRlZmF1bHRGaWVsZFZhbHVlJiYocy5maWVsZFZhbHVlPXMuZGVmYXVsdEZpZWxkVmFsdWUpO3MuYWx0ZXJuYXRpdmVUZXh0PXN0cmluZ1RvUERGU3RyaW5nKHQuZ2V0KCJUVSIpfHwiIik7dGhpcy5zZXREZWZhdWx0QXBwZWFyYW5jZShlKTtzLmhhc0FwcGVhcmFuY2V8fD10aGlzLl9uZWVkQXBwZWFyYW5jZXMmJnZvaWQgMCE9PXMuZmllbGRWYWx1ZSYmbnVsbCE9PXMuZmllbGRWYWx1ZTtjb25zdCBvPWdldEluaGVyaXRhYmxlUHJvcGVydHkoe2RpY3Q6dCxrZXk6IkZUIn0pO3MuZmllbGRUeXBlPW8gaW5zdGFuY2VvZiBOYW1lP28ubmFtZTpudWxsO2NvbnN0IGc9Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0LGtleToiRFIifSksYz1hLmFjcm9Gb3JtLmdldCgiRFIiKSxDPXRoaXMuYXBwZWFyYW5jZT8uZGljdC5nZXQoIlJlc291cmNlcyIpO3RoaXMuX2ZpZWxkUmVzb3VyY2VzPXtsb2NhbFJlc291cmNlczpnLGFjcm9Gb3JtUmVzb3VyY2VzOmMsYXBwZWFyYW5jZVJlc291cmNlczpDLG1lcmdlZFJlc291cmNlczpEaWN0Lm1lcmdlKHt4cmVmOmksZGljdEFycmF5OltnLEMsY10sbWVyZ2VTdWJEaWN0czohMH0pfTtzLmZpZWxkRmxhZ3M9Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0LGtleToiRmYifSk7KCFOdW1iZXIuaXNJbnRlZ2VyKHMuZmllbGRGbGFncyl8fHMuZmllbGRGbGFnczwwKSYmKHMuZmllbGRGbGFncz0wKTtzLnJlYWRPbmx5PXRoaXMuaGFzRmllbGRGbGFnKHRBKTtzLnJlcXVpcmVkPXRoaXMuaGFzRmllbGRGbGFnKGlBKTtzLmhpZGRlbj10aGlzLl9oYXNGbGFnKHMuYW5ub3RhdGlvbkZsYWdzLFYpfHx0aGlzLl9oYXNGbGFnKHMuYW5ub3RhdGlvbkZsYWdzLCQpfV9kZWNvZGVGb3JtVmFsdWUoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5maWx0ZXIoKGU9PiJzdHJpbmciPT10eXBlb2YgZSkpLm1hcCgoZT0+c3RyaW5nVG9QREZTdHJpbmcoZSkpKTplIGluc3RhbmNlb2YgTmFtZT9zdHJpbmdUb1BERlN0cmluZyhlLm5hbWUpOiJzdHJpbmciPT10eXBlb2YgZT9zdHJpbmdUb1BERlN0cmluZyhlKTpudWxsfWhhc0ZpZWxkRmxhZyhlKXtyZXR1cm4hISh0aGlzLmRhdGEuZmllbGRGbGFncyZlKX1faXNWaWV3YWJsZShlKXtyZXR1cm4hMH1tdXN0QmVWaWV3ZWQoZSx0KXtyZXR1cm4gdD90aGlzLnZpZXdhYmxlOnN1cGVyLm11c3RCZVZpZXdlZChlLHQpJiYhdGhpcy5faGFzRmxhZyh0aGlzLmZsYWdzLCQpfWdldFJvdGF0aW9uTWF0cml4KGUpe2xldCB0PWU/LmdldCh0aGlzLmRhdGEuaWQpPy5yb3RhdGlvbjt2b2lkIDA9PT10JiYodD10aGlzLnJvdGF0aW9uKTtpZigwPT09dClyZXR1cm4gaTtyZXR1cm4gZ2V0Um90YXRpb25NYXRyaXgodCx0aGlzLmRhdGEucmVjdFsyXS10aGlzLmRhdGEucmVjdFswXSx0aGlzLmRhdGEucmVjdFszXS10aGlzLmRhdGEucmVjdFsxXSl9Z2V0Qm9yZGVyQW5kQmFja2dyb3VuZEFwcGVhcmFuY2VzKGUpe2xldCB0PWU/LmdldCh0aGlzLmRhdGEuaWQpPy5yb3RhdGlvbjt2b2lkIDA9PT10JiYodD10aGlzLnJvdGF0aW9uKTtpZighdGhpcy5iYWNrZ3JvdW5kQ29sb3ImJiF0aGlzLmJvcmRlckNvbG9yKXJldHVybiIiO2NvbnN0IGk9dGhpcy5kYXRhLnJlY3RbMl0tdGhpcy5kYXRhLnJlY3RbMF0sYT10aGlzLmRhdGEucmVjdFszXS10aGlzLmRhdGEucmVjdFsxXSxzPTA9PT10fHwxODA9PT10P2AwIDAgJHtpfSAke2F9IHJlYDpgMCAwICR7YX0gJHtpfSByZWA7bGV0IHI9IiI7dGhpcy5iYWNrZ3JvdW5kQ29sb3ImJihyPWAke2dldFBkZkNvbG9yKHRoaXMuYmFja2dyb3VuZENvbG9yLCEwKX0gJHtzfSBmIGApO2lmKHRoaXMuYm9yZGVyQ29sb3Ipe3IrPWAke3RoaXMuYm9yZGVyU3R5bGUud2lkdGh8fDF9IHcgJHtnZXRQZGZDb2xvcih0aGlzLmJvcmRlckNvbG9yLCExKX0gJHtzfSBTIGB9cmV0dXJuIHJ9YXN5bmMgZ2V0T3BlcmF0b3JMaXN0KGUsdCxpLGEscyl7aWYoYSYmISh0aGlzIGluc3RhbmNlb2YgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbikmJiF0aGlzLmRhdGEubm9IVE1MJiYhdGhpcy5kYXRhLmhhc093bkNhbnZhcylyZXR1cm57b3BMaXN0Om5ldyBPcGVyYXRvckxpc3Qsc2VwYXJhdGVGb3JtOiEwLHNlcGFyYXRlQ2FudmFzOiExfTtpZighdGhpcy5faGFzVGV4dClyZXR1cm4gc3VwZXIuZ2V0T3BlcmF0b3JMaXN0KGUsdCxpLGEscyk7Y29uc3Qgcj1hd2FpdCB0aGlzLl9nZXRBcHBlYXJhbmNlKGUsdCxpLHMpO2lmKHRoaXMuYXBwZWFyYW5jZSYmbnVsbD09PXIpcmV0dXJuIHN1cGVyLmdldE9wZXJhdG9yTGlzdChlLHQsaSxhLHMpO2NvbnN0IG49bmV3IE9wZXJhdG9yTGlzdDtpZighdGhpcy5fZGVmYXVsdEFwcGVhcmFuY2V8fG51bGw9PT1yKXJldHVybntvcExpc3Q6bixzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6ITF9O2NvbnN0IG89ISEodGhpcy5kYXRhLmhhc093bkNhbnZhcyYmaSZnKSxjPVswLDAsdGhpcy5kYXRhLnJlY3RbMl0tdGhpcy5kYXRhLnJlY3RbMF0sdGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV1dLEM9Z2V0VHJhbnNmb3JtTWF0cml4KHRoaXMuZGF0YS5yZWN0LGMsWzEsMCwwLDEsMCwwXSk7bGV0IGg7dGhpcy5vYyYmKGg9YXdhaXQgZS5wYXJzZU1hcmtlZENvbnRlbnRQcm9wcyh0aGlzLm9jLG51bGwpKTt2b2lkIDAhPT1oJiZuLmFkZE9wKEplLFsiT0MiLGhdKTtuLmFkZE9wKFdlLFt0aGlzLmRhdGEuaWQsdGhpcy5kYXRhLnJlY3QsQyx0aGlzLmdldFJvdGF0aW9uTWF0cml4KHMpLG9dKTtjb25zdCBsPW5ldyBTdHJpbmdTdHJlYW0ocik7YXdhaXQgZS5nZXRPcGVyYXRvckxpc3Qoe3N0cmVhbTpsLHRhc2s6dCxyZXNvdXJjZXM6dGhpcy5fZmllbGRSZXNvdXJjZXMubWVyZ2VkUmVzb3VyY2VzLG9wZXJhdG9yTGlzdDpufSk7bi5hZGRPcChqZSxbXSk7dm9pZCAwIT09aCYmbi5hZGRPcChZZSxbXSk7cmV0dXJue29wTGlzdDpuLHNlcGFyYXRlRm9ybTohMSxzZXBhcmF0ZUNhbnZhczpvfX1fZ2V0TUtEaWN0KGUpe2NvbnN0IHQ9bmV3IERpY3QobnVsbCk7ZSYmdC5zZXQoIlIiLGUpO3RoaXMuYm9yZGVyQ29sb3ImJnQuc2V0KCJCQyIsZ2V0UGRmQ29sb3JBcnJheSh0aGlzLmJvcmRlckNvbG9yKSk7dGhpcy5iYWNrZ3JvdW5kQ29sb3ImJnQuc2V0KCJCRyIsZ2V0UGRmQ29sb3JBcnJheSh0aGlzLmJhY2tncm91bmRDb2xvcikpO3JldHVybiB0LnNpemU+MD90Om51bGx9YW1lbmRTYXZlZERpY3QoZSx0KXt9YXN5bmMgc2F2ZShlLHQsYSl7Y29uc3Qgcz1hPy5nZXQodGhpcy5kYXRhLmlkKTtsZXQgcj1zPy52YWx1ZSxuPXM/LnJvdGF0aW9uO2lmKHI9PT10aGlzLmRhdGEuZmllbGRWYWx1ZXx8dm9pZCAwPT09cil7aWYoIXRoaXMuX2hhc1ZhbHVlRnJvbVhGQSYmdm9pZCAwPT09bilyZXR1cm4gbnVsbDtyfHw9dGhpcy5kYXRhLmZpZWxkVmFsdWV9aWYodm9pZCAwPT09biYmIXRoaXMuX2hhc1ZhbHVlRnJvbVhGQSYmQXJyYXkuaXNBcnJheShyKSYmQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEuZmllbGRWYWx1ZSkmJnIubGVuZ3RoPT09dGhpcy5kYXRhLmZpZWxkVmFsdWUubGVuZ3RoJiZyLmV2ZXJ5KCgoZSx0KT0+ZT09PXRoaXMuZGF0YS5maWVsZFZhbHVlW3RdKSkpcmV0dXJuIG51bGw7dm9pZCAwPT09biYmKG49dGhpcy5yb3RhdGlvbik7bGV0IG89bnVsbDtpZighdGhpcy5fbmVlZEFwcGVhcmFuY2VzKXtvPWF3YWl0IHRoaXMuX2dldEFwcGVhcmFuY2UoZSx0LEMsYSk7aWYobnVsbD09PW8pcmV0dXJuIG51bGx9bGV0IGc9ITE7aWYobz8ubmVlZEFwcGVhcmFuY2VzKXtnPSEwO289bnVsbH1jb25zdHt4cmVmOmN9PWUsaD1jLmZldGNoSWZSZWYodGhpcy5yZWYpO2lmKCEoaCBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBudWxsO2NvbnN0IGw9bmV3IERpY3QoYyk7Zm9yKGNvbnN0IGUgb2YgaC5nZXRLZXlzKCkpIkFQIiE9PWUmJmwuc2V0KGUsaC5nZXRSYXcoZSkpO2NvbnN0IFE9e3BhdGg6dGhpcy5kYXRhLmZpZWxkTmFtZSx2YWx1ZTpyfSxlbmNvZGVyPWU9PmlzQXNjaWkoZSk/ZTpzdHJpbmdUb1VURjE2U3RyaW5nKGUsITApO2wuc2V0KCJWIixBcnJheS5pc0FycmF5KHIpP3IubWFwKGVuY29kZXIpOmVuY29kZXIocikpO3RoaXMuYW1lbmRTYXZlZERpY3QoYSxsKTtjb25zdCBFPXRoaXMuX2dldE1LRGljdChuKTtFJiZsLnNldCgiTUsiLEUpO2NvbnN0IHU9W10sZD1be3JlZjp0aGlzLnJlZixkYXRhOiIiLHhmYTpRLG5lZWRBcHBlYXJhbmNlczpnfV07aWYobnVsbCE9PW8pe2NvbnN0IGU9Yy5nZXROZXdUZW1wb3JhcnlSZWYoKSx0PW5ldyBEaWN0KGMpO2wuc2V0KCJBUCIsdCk7dC5zZXQoIk4iLGUpO2NvbnN0IHM9dGhpcy5fZ2V0U2F2ZUZpZWxkUmVzb3VyY2VzKGMpLHI9bmV3IFN0cmluZ1N0cmVhbShvKSxuPXIuZGljdD1uZXcgRGljdChjKTtuLnNldCgiU3VidHlwZSIsTmFtZS5nZXQoIkZvcm0iKSk7bi5zZXQoIlJlc291cmNlcyIscyk7bi5zZXQoIkJCb3giLFswLDAsdGhpcy5kYXRhLnJlY3RbMl0tdGhpcy5kYXRhLnJlY3RbMF0sdGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV1dKTtjb25zdCBnPXRoaXMuZ2V0Um90YXRpb25NYXRyaXgoYSk7ZyE9PWkmJm4uc2V0KCJNYXRyaXgiLGcpO2F3YWl0IHdyaXRlT2JqZWN0KGUscix1LGMpO2QucHVzaCh7cmVmOmUsZGF0YTp1LmpvaW4oIiIpLHhmYTpudWxsLG5lZWRBcHBlYXJhbmNlczohMX0pO3UubGVuZ3RoPTB9bC5zZXQoIk0iLGBEOiR7Z2V0TW9kaWZpY2F0aW9uRGF0ZSgpfWApO2F3YWl0IHdyaXRlT2JqZWN0KHRoaXMucmVmLGwsdSxjKTtkWzBdLmRhdGE9dS5qb2luKCIiKTtyZXR1cm4gZH1hc3luYyBfZ2V0QXBwZWFyYW5jZShlLHQsaSxhKXtpZih0aGlzLmhhc0ZpZWxkRmxhZyhzQSkpcmV0dXJuIG51bGw7Y29uc3Qgcz1hPy5nZXQodGhpcy5kYXRhLmlkKTtsZXQgcixvO2lmKHMpe3I9cy5mb3JtYXR0ZWRWYWx1ZXx8cy52YWx1ZTtvPXMucm90YXRpb259aWYodm9pZCAwPT09byYmdm9pZCAwPT09ciYmIXRoaXMuX25lZWRBcHBlYXJhbmNlcyYmKCF0aGlzLl9oYXNWYWx1ZUZyb21YRkF8fHRoaXMuYXBwZWFyYW5jZSkpcmV0dXJuIG51bGw7Y29uc3QgZz10aGlzLmdldEJvcmRlckFuZEJhY2tncm91bmRBcHBlYXJhbmNlcyhhKTtpZih2b2lkIDA9PT1yKXtyPXRoaXMuZGF0YS5maWVsZFZhbHVlO2lmKCFyKXJldHVybmAvVHggQk1DIHEgJHtnfVEgRU1DYH1BcnJheS5pc0FycmF5KHIpJiYxPT09ci5sZW5ndGgmJihyPXJbMF0pO2Fzc2VydCgic3RyaW5nIj09dHlwZW9mIHIsIkV4cGVjdGVkIGB2YWx1ZWAgdG8gYmUgYSBzdHJpbmcuIik7cj1yLnRyaW0oKTtpZih0aGlzLmRhdGEuY29tYm8pe2NvbnN0IGU9dGhpcy5kYXRhLm9wdGlvbnMuZmluZCgoKHtleHBvcnRWYWx1ZTplfSk9PnI9PT1lKSk7cj1lPy5kaXNwbGF5VmFsdWV8fHJ9aWYoIiI9PT1yKXJldHVybmAvVHggQk1DIHEgJHtnfVEgRU1DYDt2b2lkIDA9PT1vJiYobz10aGlzLnJvdGF0aW9uKTtsZXQgYyxoPS0xO2lmKHRoaXMuZGF0YS5tdWx0aUxpbmUpe2M9ci5zcGxpdCgvXHJcbj98XG4vKS5tYXAoKGU9PmUubm9ybWFsaXplKCJORkMiKSkpO2g9Yy5sZW5ndGh9ZWxzZSBjPVtyLnJlcGxhY2UoL1xyXG4/fFxuLywiIikubm9ybWFsaXplKCJORkMiKV07bGV0IGw9dGhpcy5kYXRhLnJlY3RbM10tdGhpcy5kYXRhLnJlY3RbMV0sUT10aGlzLmRhdGEucmVjdFsyXS10aGlzLmRhdGEucmVjdFswXTs5MCE9PW8mJjI3MCE9PW98fChbUSxsXT1bbCxRXSk7dGhpcy5fZGVmYXVsdEFwcGVhcmFuY2V8fCh0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhPXBhcnNlRGVmYXVsdEFwcGVhcmFuY2UodGhpcy5fZGVmYXVsdEFwcGVhcmFuY2U9Ii9IZWx2ZXRpY2EgMCBUZiAwIGciKSk7bGV0IEUsdSxkLGY9YXdhaXQgV2lkZ2V0QW5ub3RhdGlvbi5fZ2V0Rm9udERhdGEoZSx0LHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEsdGhpcy5fZmllbGRSZXNvdXJjZXMubWVyZ2VkUmVzb3VyY2VzKTtjb25zdCBwPVtdO2xldCBtPSExO2Zvcihjb25zdCBlIG9mIGMpe2NvbnN0IHQ9Zi5lbmNvZGVTdHJpbmcoZSk7dC5sZW5ndGg+MSYmKG09ITApO3AucHVzaCh0LmpvaW4oIiIpKX1pZihtJiZpJkMpcmV0dXJue25lZWRBcHBlYXJhbmNlczohMH07aWYobSYmdGhpcy5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpe2NvbnN0IGk9dGhpcy5kYXRhLmNvbWI/Im1vbm9zcGFjZSI6InNhbnMtc2VyaWYiLGE9bmV3IEZha2VVbmljb2RlRm9udChlLnhyZWYsaSkscz1hLmNyZWF0ZUZvbnRSZXNvdXJjZXMoYy5qb2luKCIiKSksbj1zLmdldFJhdygiRm9udCIpO2lmKHRoaXMuX2ZpZWxkUmVzb3VyY2VzLm1lcmdlZFJlc291cmNlcy5oYXMoIkZvbnQiKSl7Y29uc3QgZT10aGlzLl9maWVsZFJlc291cmNlcy5tZXJnZWRSZXNvdXJjZXMuZ2V0KCJGb250Iik7Zm9yKGNvbnN0IHQgb2Ygbi5nZXRLZXlzKCkpZS5zZXQodCxuLmdldFJhdyh0KSl9ZWxzZSB0aGlzLl9maWVsZFJlc291cmNlcy5tZXJnZWRSZXNvdXJjZXMuc2V0KCJGb250IixuKTtjb25zdCBvPWEuZm9udE5hbWUubmFtZTtmPWF3YWl0IFdpZGdldEFubm90YXRpb24uX2dldEZvbnREYXRhKGUsdCx7Zm9udE5hbWU6byxmb250U2l6ZTowfSxzKTtmb3IobGV0IGU9MCx0PXAubGVuZ3RoO2U8dDtlKyspcFtlXT1zdHJpbmdUb1VURjE2U3RyaW5nKGNbZV0pO2NvbnN0IGc9T2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEpO3RoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEuZm9udFNpemU9MDt0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnROYW1lPW87W0UsdSxkXT10aGlzLl9jb21wdXRlRm9udFNpemUobC0yLFEtNCxyLGYsaCk7dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YT1nfWVsc2V7dGhpcy5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWR8fHdhcm4oIl9nZXRBcHBlYXJhbmNlOiBPZmZzY3JlZW5DYW52YXMgaXMgbm90IHN1cHBvcnRlZCwgYW5ub3RhdGlvbiBtYXkgbm90IHJlbmRlciBjb3JyZWN0bHkuIik7W0UsdSxkXT10aGlzLl9jb21wdXRlRm9udFNpemUobC0yLFEtNCxyLGYsaCl9bGV0IHk9Zi5kZXNjZW50O3k9aXNOYU4oeSk/bipkOk1hdGgubWF4KG4qZCxNYXRoLmFicyh5KSp1KTtjb25zdCB3PU1hdGgubWluKE1hdGguZmxvb3IoKGwtdSkvMiksMSksYj10aGlzLmRhdGEudGV4dEFsaWdubWVudDtpZih0aGlzLmRhdGEubXVsdGlMaW5lKXJldHVybiB0aGlzLl9nZXRNdWx0aWxpbmVBcHBlYXJhbmNlKEUscCxmLHUsUSxsLGIsMix3LHksZCxhKTtpZih0aGlzLmRhdGEuY29tYilyZXR1cm4gdGhpcy5fZ2V0Q29tYkFwcGVhcmFuY2UoRSxmLHBbMF0sdSxRLGwsMix3LHksZCxhKTtjb25zdCBEPXcreTtpZigwPT09Ynx8Yj4yKXJldHVybmAvVHggQk1DIHEgJHtnfUJUIGArRStgIDEgMCAwIDEgJHtudW1iZXJUb1N0cmluZygyKX0gJHtudW1iZXJUb1N0cmluZyhEKX0gVG0gKCR7ZXNjYXBlU3RyaW5nKHBbMF0pfSkgVGogRVQgUSBFTUNgO3JldHVybmAvVHggQk1DIHEgJHtnfUJUIGArRStgIDEgMCAwIDEgMCAwIFRtICR7dGhpcy5fcmVuZGVyVGV4dChwWzBdLGYsdSxRLGIse3NoaWZ0OjB9LDIsRCl9IEVUIFEgRU1DYH1zdGF0aWMgYXN5bmMgX2dldEZvbnREYXRhKGUsdCxpLGEpe2NvbnN0IHM9bmV3IE9wZXJhdG9yTGlzdCxyPXtmb250Om51bGwsY2xvbmUoKXtyZXR1cm4gdGhpc319LHtmb250TmFtZTpuLGZvbnRTaXplOm99PWk7YXdhaXQgZS5oYW5kbGVTZXRGb250KGEsW24mJk5hbWUuZ2V0KG4pLG9dLG51bGwscyx0LHIsbnVsbCk7cmV0dXJuIHIuZm9udH1fZ2V0VGV4dFdpZHRoKGUsdCl7cmV0dXJuIHQuY2hhcnNUb0dseXBocyhlKS5yZWR1Y2UoKChlLHQpPT5lK3Qud2lkdGgpLDApLzFlM31fY29tcHV0ZUZvbnRTaXplKGUsdCxpLGEscil7bGV0e2ZvbnRTaXplOm59PXRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEsbz0obnx8MTIpKnMsZz1NYXRoLnJvdW5kKGUvbyk7aWYoIW4pe2NvbnN0IHJvdW5kV2l0aFR3b0RpZ2l0cz1lPT5NYXRoLmZsb29yKDEwMCplKS8xMDA7aWYoLTE9PT1yKXtjb25zdCByPXRoaXMuX2dldFRleHRXaWR0aChpLGEpO249cm91bmRXaXRoVHdvRGlnaXRzKE1hdGgubWluKGUvcyxyPnQ/dC9yOjEvMCkpO2c9MX1lbHNle2NvbnN0IGM9aS5zcGxpdCgvXHJcbj98XG4vKSxDPVtdO2Zvcihjb25zdCBlIG9mIGMpe2NvbnN0IHQ9YS5lbmNvZGVTdHJpbmcoZSkuam9pbigiIiksaT1hLmNoYXJzVG9HbHlwaHModCkscz1hLmdldENoYXJQb3NpdGlvbnModCk7Qy5wdXNoKHtsaW5lOnQsZ2x5cGhzOmkscG9zaXRpb25zOnN9KX1jb25zdCBpc1Rvb0JpZz1pPT57bGV0IHM9MDtmb3IoY29uc3QgciBvZiBDKXtzKz10aGlzLl9zcGxpdExpbmUobnVsbCxhLGksdCxyKS5sZW5ndGgqaTtpZihzPmUpcmV0dXJuITB9cmV0dXJuITF9O2c9TWF0aC5tYXgoZyxyKTtmb3IoOzspe289ZS9nO249cm91bmRXaXRoVHdvRGlnaXRzKG8vcyk7aWYoIWlzVG9vQmlnKG4pKWJyZWFrO2crK319Y29uc3R7Zm9udE5hbWU6Yyxmb250Q29sb3I6Q309dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTt0aGlzLl9kZWZhdWx0QXBwZWFyYW5jZT1mdW5jdGlvbiBjcmVhdGVEZWZhdWx0QXBwZWFyYW5jZSh7Zm9udFNpemU6ZSxmb250TmFtZTp0LGZvbnRDb2xvcjppfSl7cmV0dXJuYC8ke2VzY2FwZVBERk5hbWUodCl9ICR7ZX0gVGYgJHtnZXRQZGZDb2xvcihpLCEwKX1gfSh7Zm9udFNpemU6bixmb250TmFtZTpjLGZvbnRDb2xvcjpDfSl9cmV0dXJuW3RoaXMuX2RlZmF1bHRBcHBlYXJhbmNlLG4sZS9nXX1fcmVuZGVyVGV4dChlLHQsaSxhLHMscixuLG8pe2xldCBnO2lmKDE9PT1zKXtnPShhLXRoaXMuX2dldFRleHRXaWR0aChlLHQpKmkpLzJ9ZWxzZSBpZigyPT09cyl7Zz1hLXRoaXMuX2dldFRleHRXaWR0aChlLHQpKmktbn1lbHNlIGc9bjtjb25zdCBjPW51bWJlclRvU3RyaW5nKGctci5zaGlmdCk7ci5zaGlmdD1nO3JldHVybmAke2N9ICR7bz1udW1iZXJUb1N0cmluZyhvKX0gVGQgKCR7ZXNjYXBlU3RyaW5nKGUpfSkgVGpgfV9nZXRTYXZlRmllbGRSZXNvdXJjZXMoZSl7Y29uc3R7bG9jYWxSZXNvdXJjZXM6dCxhcHBlYXJhbmNlUmVzb3VyY2VzOmksYWNyb0Zvcm1SZXNvdXJjZXM6YX09dGhpcy5fZmllbGRSZXNvdXJjZXMscz10aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhPy5mb250TmFtZTtpZighcylyZXR1cm4gdHx8RGljdC5lbXB0eTtmb3IoY29uc3QgZSBvZlt0LGldKWlmKGUgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCB0PWUuZ2V0KCJGb250Iik7aWYodCBpbnN0YW5jZW9mIERpY3QmJnQuaGFzKHMpKXJldHVybiBlfWlmKGEgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBpPWEuZ2V0KCJGb250Iik7aWYoaSBpbnN0YW5jZW9mIERpY3QmJmkuaGFzKHMpKXtjb25zdCBhPW5ldyBEaWN0KGUpO2Euc2V0KHMsaS5nZXRSYXcocykpO2NvbnN0IHI9bmV3IERpY3QoZSk7ci5zZXQoIkZvbnQiLGEpO3JldHVybiBEaWN0Lm1lcmdlKHt4cmVmOmUsZGljdEFycmF5OltyLHRdLG1lcmdlU3ViRGljdHM6ITB9KX19cmV0dXJuIHR8fERpY3QuZW1wdHl9Z2V0RmllbGRPYmplY3QoKXtyZXR1cm4gbnVsbH19Y2xhc3MgVGV4dFdpZGdldEFubm90YXRpb24gZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5oYXNPd25DYW52YXM9dGhpcy5kYXRhLnJlYWRPbmx5JiYhdGhpcy5kYXRhLm5vSFRNTDt0aGlzLl9oYXNUZXh0PSEwO2NvbnN0IHQ9ZS5kaWN0OyJzdHJpbmciIT10eXBlb2YgdGhpcy5kYXRhLmZpZWxkVmFsdWUmJih0aGlzLmRhdGEuZmllbGRWYWx1ZT0iIik7bGV0IGk9Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0LGtleToiUSJ9KTsoIU51bWJlci5pc0ludGVnZXIoaSl8fGk8MHx8aT4yKSYmKGk9bnVsbCk7dGhpcy5kYXRhLnRleHRBbGlnbm1lbnQ9aTtsZXQgYT1nZXRJbmhlcml0YWJsZVByb3BlcnR5KHtkaWN0OnQsa2V5OiJNYXhMZW4ifSk7KCFOdW1iZXIuaXNJbnRlZ2VyKGEpfHxhPDApJiYoYT0wKTt0aGlzLmRhdGEubWF4TGVuPWE7dGhpcy5kYXRhLm11bHRpTGluZT10aGlzLmhhc0ZpZWxkRmxhZyhhQSk7dGhpcy5kYXRhLmNvbWI9dGhpcy5oYXNGaWVsZEZsYWcoQ0EpJiYhdGhpcy5oYXNGaWVsZEZsYWcoYUEpJiYhdGhpcy5oYXNGaWVsZEZsYWcoc0EpJiYhdGhpcy5oYXNGaWVsZEZsYWcoZ0EpJiYwIT09dGhpcy5kYXRhLm1heExlbjt0aGlzLmRhdGEuZG9Ob3RTY3JvbGw9dGhpcy5oYXNGaWVsZEZsYWcoY0EpfWdldCBoYXNUZXh0Q29udGVudCgpe3JldHVybiEhdGhpcy5hcHBlYXJhbmNlJiYhdGhpcy5fbmVlZEFwcGVhcmFuY2VzfV9nZXRDb21iQXBwZWFyYW5jZShlLHQsaSxhLHMscixuLG8sZyxjLEMpe2NvbnN0IGg9cy90aGlzLmRhdGEubWF4TGVuLGw9dGhpcy5nZXRCb3JkZXJBbmRCYWNrZ3JvdW5kQXBwZWFyYW5jZXMoQyksUT1bXSxFPXQuZ2V0Q2hhclBvc2l0aW9ucyhpKTtmb3IoY29uc3RbZSx0XW9mIEUpUS5wdXNoKGAoJHtlc2NhcGVTdHJpbmcoaS5zdWJzdHJpbmcoZSx0KSl9KSBUamApO2NvbnN0IHU9US5qb2luKGAgJHtudW1iZXJUb1N0cmluZyhoKX0gMCBUZCBgKTtyZXR1cm5gL1R4IEJNQyBxICR7bH1CVCBgK2UrYCAxIDAgMCAxICR7bnVtYmVyVG9TdHJpbmcobil9ICR7bnVtYmVyVG9TdHJpbmcobytnKX0gVG0gJHt1fSBFVCBRIEVNQ2B9X2dldE11bHRpbGluZUFwcGVhcmFuY2UoZSx0LGksYSxzLHIsbixvLGcsYyxDLGgpe2NvbnN0IGw9W10sUT1zLTIqbyxFPXtzaGlmdDowfTtmb3IobGV0IGU9MCxyPXQubGVuZ3RoO2U8cjtlKyspe2NvbnN0IHI9dFtlXSxoPXRoaXMuX3NwbGl0TGluZShyLGksYSxRKTtmb3IobGV0IHQ9MCxyPWgubGVuZ3RoO3Q8cjt0Kyspe2NvbnN0IHI9aFt0XSxRPTA9PT1lJiYwPT09dD8tZy0oQy1jKTotQztsLnB1c2godGhpcy5fcmVuZGVyVGV4dChyLGksYSxzLG4sRSxvLFEpKX19Y29uc3QgdT10aGlzLmdldEJvcmRlckFuZEJhY2tncm91bmRBcHBlYXJhbmNlcyhoKSxkPWwuam9pbigiXG4iKTtyZXR1cm5gL1R4IEJNQyBxICR7dX1CVCBgK2UrYCAxIDAgMCAxIDAgJHtudW1iZXJUb1N0cmluZyhyKX0gVG0gJHtkfSBFVCBRIEVNQ2B9X3NwbGl0TGluZShlLHQsaSxhLHM9e30pe2U9cy5saW5lfHxlO2NvbnN0IHI9cy5nbHlwaHN8fHQuY2hhcnNUb0dseXBocyhlKTtpZihyLmxlbmd0aDw9MSlyZXR1cm5bZV07Y29uc3Qgbj1zLnBvc2l0aW9uc3x8dC5nZXRDaGFyUG9zaXRpb25zKGUpLG89aS8xZTMsZz1bXTtsZXQgYz0tMSxDPS0xLGg9LTEsbD0wLFE9MDtmb3IobGV0IHQ9MCxpPXIubGVuZ3RoO3Q8aTt0Kyspe2NvbnN0W2ksc109blt0XSxFPXJbdF0sdT1FLndpZHRoKm87aWYoIiAiPT09RS51bmljb2RlKWlmKFErdT5hKXtnLnB1c2goZS5zdWJzdHJpbmcobCxpKSk7bD1pO1E9dTtjPS0xO2g9LTF9ZWxzZXtRKz11O2M9aTtDPXM7aD10fWVsc2UgaWYoUSt1PmEpaWYoLTEhPT1jKXtnLnB1c2goZS5zdWJzdHJpbmcobCxDKSk7bD1DO3Q9aCsxO2M9LTE7UT0wfWVsc2V7Zy5wdXNoKGUuc3Vic3RyaW5nKGwsaSkpO2w9aTtRPXV9ZWxzZSBRKz11fWw8ZS5sZW5ndGgmJmcucHVzaChlLnN1YnN0cmluZyhsLGUubGVuZ3RoKSk7cmV0dXJuIGd9Z2V0RmllbGRPYmplY3QoKXtyZXR1cm57aWQ6dGhpcy5kYXRhLmlkLHZhbHVlOnRoaXMuZGF0YS5maWVsZFZhbHVlLGRlZmF1bHRWYWx1ZTp0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWV8fCIiLG11bHRpbGluZTp0aGlzLmRhdGEubXVsdGlMaW5lLHBhc3N3b3JkOnRoaXMuaGFzRmllbGRGbGFnKHNBKSxjaGFyTGltaXQ6dGhpcy5kYXRhLm1heExlbixjb21iOnRoaXMuZGF0YS5jb21iLGVkaXRhYmxlOiF0aGlzLmRhdGEucmVhZE9ubHksaGlkZGVuOnRoaXMuZGF0YS5oaWRkZW4sbmFtZTp0aGlzLmRhdGEuZmllbGROYW1lLHJlY3Q6dGhpcy5kYXRhLnJlY3QsYWN0aW9uczp0aGlzLmRhdGEuYWN0aW9ucyxwYWdlOnRoaXMuZGF0YS5wYWdlSW5kZXgsc3Ryb2tlQ29sb3I6dGhpcy5kYXRhLmJvcmRlckNvbG9yLGZpbGxDb2xvcjp0aGlzLmRhdGEuYmFja2dyb3VuZENvbG9yLHJvdGF0aW9uOnRoaXMucm90YXRpb24sdHlwZToidGV4dCJ9fX1jbGFzcyBCdXR0b25XaWRnZXRBbm5vdGF0aW9uIGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmNoZWNrZWRBcHBlYXJhbmNlPW51bGw7dGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlPW51bGw7dGhpcy5kYXRhLmNoZWNrQm94PSF0aGlzLmhhc0ZpZWxkRmxhZyhyQSkmJiF0aGlzLmhhc0ZpZWxkRmxhZyhuQSk7dGhpcy5kYXRhLnJhZGlvQnV0dG9uPXRoaXMuaGFzRmllbGRGbGFnKHJBKSYmIXRoaXMuaGFzRmllbGRGbGFnKG5BKTt0aGlzLmRhdGEucHVzaEJ1dHRvbj10aGlzLmhhc0ZpZWxkRmxhZyhuQSk7dGhpcy5kYXRhLmlzVG9vbHRpcE9ubHk9ITE7aWYodGhpcy5kYXRhLmNoZWNrQm94KXRoaXMuX3Byb2Nlc3NDaGVja0JveChlKTtlbHNlIGlmKHRoaXMuZGF0YS5yYWRpb0J1dHRvbil0aGlzLl9wcm9jZXNzUmFkaW9CdXR0b24oZSk7ZWxzZSBpZih0aGlzLmRhdGEucHVzaEJ1dHRvbil7dGhpcy5kYXRhLmhhc093bkNhbnZhcz0hMDt0aGlzLmRhdGEubm9IVE1MPSExO3RoaXMuX3Byb2Nlc3NQdXNoQnV0dG9uKGUpfWVsc2Ugd2FybigiSW52YWxpZCBmaWVsZCBmbGFncyBmb3IgYnV0dG9uIHdpZGdldCBhbm5vdGF0aW9uIil9YXN5bmMgZ2V0T3BlcmF0b3JMaXN0KGUsdCxhLHMscil7aWYodGhpcy5kYXRhLnB1c2hCdXR0b24pcmV0dXJuIHN1cGVyLmdldE9wZXJhdG9yTGlzdChlLHQsYSwhMSxyKTtsZXQgbj1udWxsLG89bnVsbDtpZihyKXtjb25zdCBlPXIuZ2V0KHRoaXMuZGF0YS5pZCk7bj1lP2UudmFsdWU6bnVsbDtvPWU/ZS5yb3RhdGlvbjpudWxsfWlmKG51bGw9PT1uJiZ0aGlzLmFwcGVhcmFuY2UpcmV0dXJuIHN1cGVyLmdldE9wZXJhdG9yTGlzdChlLHQsYSxzLHIpO251bGw9PW4mJihuPXRoaXMuZGF0YS5jaGVja0JveD90aGlzLmRhdGEuZmllbGRWYWx1ZT09PXRoaXMuZGF0YS5leHBvcnRWYWx1ZTp0aGlzLmRhdGEuZmllbGRWYWx1ZT09PXRoaXMuZGF0YS5idXR0b25WYWx1ZSk7Y29uc3QgZz1uP3RoaXMuY2hlY2tlZEFwcGVhcmFuY2U6dGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlO2lmKGcpe2NvbnN0IG49dGhpcy5hcHBlYXJhbmNlLGM9Zy5kaWN0LmdldEFycmF5KCJNYXRyaXgiKXx8aTtvJiZnLmRpY3Quc2V0KCJNYXRyaXgiLHRoaXMuZ2V0Um90YXRpb25NYXRyaXgocikpO3RoaXMuYXBwZWFyYW5jZT1nO2NvbnN0IEM9c3VwZXIuZ2V0T3BlcmF0b3JMaXN0KGUsdCxhLHMscik7dGhpcy5hcHBlYXJhbmNlPW47Zy5kaWN0LnNldCgiTWF0cml4IixjKTtyZXR1cm4gQ31yZXR1cm57b3BMaXN0Om5ldyBPcGVyYXRvckxpc3Qsc2VwYXJhdGVGb3JtOiExLHNlcGFyYXRlQ2FudmFzOiExfX1hc3luYyBzYXZlKGUsdCxpKXtyZXR1cm4gdGhpcy5kYXRhLmNoZWNrQm94P3RoaXMuX3NhdmVDaGVja2JveChlLHQsaSk6dGhpcy5kYXRhLnJhZGlvQnV0dG9uP3RoaXMuX3NhdmVSYWRpb0J1dHRvbihlLHQsaSk6bnVsbH1hc3luYyBfc2F2ZUNoZWNrYm94KGUsdCxpKXtpZighaSlyZXR1cm4gbnVsbDtjb25zdCBhPWkuZ2V0KHRoaXMuZGF0YS5pZCk7bGV0IHM9YT8ucm90YXRpb24scj1hPy52YWx1ZTtpZih2b2lkIDA9PT1zKXtpZih2b2lkIDA9PT1yKXJldHVybiBudWxsO2lmKHRoaXMuZGF0YS5maWVsZFZhbHVlPT09dGhpcy5kYXRhLmV4cG9ydFZhbHVlPT09cilyZXR1cm4gbnVsbH1jb25zdCBuPWUueHJlZi5mZXRjaElmUmVmKHRoaXMucmVmKTtpZighKG4gaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm4gbnVsbDt2b2lkIDA9PT1zJiYocz10aGlzLnJvdGF0aW9uKTt2b2lkIDA9PT1yJiYocj10aGlzLmRhdGEuZmllbGRWYWx1ZT09PXRoaXMuZGF0YS5leHBvcnRWYWx1ZSk7Y29uc3Qgbz17cGF0aDp0aGlzLmRhdGEuZmllbGROYW1lLHZhbHVlOnI/dGhpcy5kYXRhLmV4cG9ydFZhbHVlOiIifSxnPU5hbWUuZ2V0KHI/dGhpcy5kYXRhLmV4cG9ydFZhbHVlOiJPZmYiKTtuLnNldCgiViIsZyk7bi5zZXQoIkFTIixnKTtuLnNldCgiTSIsYEQ6JHtnZXRNb2RpZmljYXRpb25EYXRlKCl9YCk7Y29uc3QgYz10aGlzLl9nZXRNS0RpY3Qocyk7YyYmbi5zZXQoIk1LIixjKTtjb25zdCBDPVtdO2F3YWl0IHdyaXRlT2JqZWN0KHRoaXMucmVmLG4sQyxlLnhyZWYpO3JldHVyblt7cmVmOnRoaXMucmVmLGRhdGE6Qy5qb2luKCIiKSx4ZmE6b31dfWFzeW5jIF9zYXZlUmFkaW9CdXR0b24oZSx0LGkpe2lmKCFpKXJldHVybiBudWxsO2NvbnN0IGE9aS5nZXQodGhpcy5kYXRhLmlkKTtsZXQgcz1hPy5yb3RhdGlvbixyPWE/LnZhbHVlO2lmKHZvaWQgMD09PXMpe2lmKHZvaWQgMD09PXIpcmV0dXJuIG51bGw7aWYodGhpcy5kYXRhLmZpZWxkVmFsdWU9PT10aGlzLmRhdGEuYnV0dG9uVmFsdWU9PT1yKXJldHVybiBudWxsfWNvbnN0IG49ZS54cmVmLmZldGNoSWZSZWYodGhpcy5yZWYpO2lmKCEobiBpbnN0YW5jZW9mIERpY3QpKXJldHVybiBudWxsO3ZvaWQgMD09PXImJihyPXRoaXMuZGF0YS5maWVsZFZhbHVlPT09dGhpcy5kYXRhLmJ1dHRvblZhbHVlKTt2b2lkIDA9PT1zJiYocz10aGlzLnJvdGF0aW9uKTtjb25zdCBvPXtwYXRoOnRoaXMuZGF0YS5maWVsZE5hbWUsdmFsdWU6cj90aGlzLmRhdGEuYnV0dG9uVmFsdWU6IiJ9LGc9TmFtZS5nZXQocj90aGlzLmRhdGEuYnV0dG9uVmFsdWU6Ik9mZiIpLGM9W107bGV0IEM9bnVsbDtpZihyKWlmKHRoaXMucGFyZW50IGluc3RhbmNlb2YgUmVmKXtjb25zdCB0PWUueHJlZi5mZXRjaCh0aGlzLnBhcmVudCk7dC5zZXQoIlYiLGcpO2F3YWl0IHdyaXRlT2JqZWN0KHRoaXMucGFyZW50LHQsYyxlLnhyZWYpO0M9Yy5qb2luKCIiKTtjLmxlbmd0aD0wfWVsc2UgdGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBEaWN0JiZ0aGlzLnBhcmVudC5zZXQoIlYiLGcpO24uc2V0KCJBUyIsZyk7bi5zZXQoIk0iLGBEOiR7Z2V0TW9kaWZpY2F0aW9uRGF0ZSgpfWApO2NvbnN0IGg9dGhpcy5fZ2V0TUtEaWN0KHMpO2gmJm4uc2V0KCJNSyIsaCk7YXdhaXQgd3JpdGVPYmplY3QodGhpcy5yZWYsbixjLGUueHJlZik7Y29uc3QgbD1be3JlZjp0aGlzLnJlZixkYXRhOmMuam9pbigiIikseGZhOm99XTtDJiZsLnB1c2goe3JlZjp0aGlzLnBhcmVudCxkYXRhOkMseGZhOm51bGx9KTtyZXR1cm4gbH1fZ2V0RGVmYXVsdENoZWNrZWRBcHBlYXJhbmNlKGUsdCl7Y29uc3QgaT10aGlzLmRhdGEucmVjdFsyXS10aGlzLmRhdGEucmVjdFswXSxhPXRoaXMuZGF0YS5yZWN0WzNdLXRoaXMuZGF0YS5yZWN0WzFdLHM9WzAsMCxpLGFdLHI9LjgqTWF0aC5taW4oaSxhKTtsZXQgbixvO2lmKCJjaGVjayI9PT10KXtuPXt3aWR0aDouNzU1KnIsaGVpZ2h0Oi43MDUqcn07bz0iMyJ9ZWxzZSBpZigiZGlzYyI9PT10KXtuPXt3aWR0aDouNzkxKnIsaGVpZ2h0Oi43MDUqcn07bz0ibCJ9ZWxzZSB1bnJlYWNoYWJsZShgX2dldERlZmF1bHRDaGVja2VkQXBwZWFyYW5jZSAtIHVuc3VwcG9ydGVkIHR5cGU6ICR7dH1gKTtjb25zdCBnPWBxIEJUIC9QZGZKc1phRGIgJHtyfSBUZiAwIGcgJHtudW1iZXJUb1N0cmluZygoaS1uLndpZHRoKS8yKX0gJHtudW1iZXJUb1N0cmluZygoYS1uLmhlaWdodCkvMil9IFRkICgke299KSBUaiBFVCBRYCxjPW5ldyBEaWN0KGUueHJlZik7Yy5zZXQoIkZvcm1UeXBlIiwxKTtjLnNldCgiU3VidHlwZSIsTmFtZS5nZXQoIkZvcm0iKSk7Yy5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJYT2JqZWN0IikpO2Muc2V0KCJCQm94IixzKTtjLnNldCgiTWF0cml4IixbMSwwLDAsMSwwLDBdKTtjLnNldCgiTGVuZ3RoIixnLmxlbmd0aCk7Y29uc3QgQz1uZXcgRGljdChlLnhyZWYpLGg9bmV3IERpY3QoZS54cmVmKTtoLnNldCgiUGRmSnNaYURiIix0aGlzLmZhbGxiYWNrRm9udERpY3QpO0Muc2V0KCJGb250IixoKTtjLnNldCgiUmVzb3VyY2VzIixDKTt0aGlzLmNoZWNrZWRBcHBlYXJhbmNlPW5ldyBTdHJpbmdTdHJlYW0oZyk7dGhpcy5jaGVja2VkQXBwZWFyYW5jZS5kaWN0PWM7dGhpcy5fc3RyZWFtcy5wdXNoKHRoaXMuY2hlY2tlZEFwcGVhcmFuY2UpfV9wcm9jZXNzQ2hlY2tCb3goZSl7Y29uc3QgdD1lLmRpY3QuZ2V0KCJBUCIpO2lmKCEodCBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtjb25zdCBpPXQuZ2V0KCJOIik7aWYoIShpIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2NvbnN0IGE9dGhpcy5fZGVjb2RlRm9ybVZhbHVlKGUuZGljdC5nZXQoIkFTIikpOyJzdHJpbmciPT10eXBlb2YgYSYmKHRoaXMuZGF0YS5maWVsZFZhbHVlPWEpO2NvbnN0IHM9bnVsbCE9PXRoaXMuZGF0YS5maWVsZFZhbHVlJiYiT2ZmIiE9PXRoaXMuZGF0YS5maWVsZFZhbHVlP3RoaXMuZGF0YS5maWVsZFZhbHVlOiJZZXMiLHI9aS5nZXRLZXlzKCk7aWYoMD09PXIubGVuZ3RoKXIucHVzaCgiT2ZmIixzKTtlbHNlIGlmKDE9PT1yLmxlbmd0aCkiT2ZmIj09PXJbMF0/ci5wdXNoKHMpOnIudW5zaGlmdCgiT2ZmIik7ZWxzZSBpZihyLmluY2x1ZGVzKHMpKXtyLmxlbmd0aD0wO3IucHVzaCgiT2ZmIixzKX1lbHNle2NvbnN0IGU9ci5maW5kKChlPT4iT2ZmIiE9PWUpKTtyLmxlbmd0aD0wO3IucHVzaCgiT2ZmIixlKX1yLmluY2x1ZGVzKHRoaXMuZGF0YS5maWVsZFZhbHVlKXx8KHRoaXMuZGF0YS5maWVsZFZhbHVlPSJPZmYiKTt0aGlzLmRhdGEuZXhwb3J0VmFsdWU9clsxXTtjb25zdCBuPWkuZ2V0KHRoaXMuZGF0YS5leHBvcnRWYWx1ZSk7dGhpcy5jaGVja2VkQXBwZWFyYW5jZT1uIGluc3RhbmNlb2YgQmFzZVN0cmVhbT9uOm51bGw7Y29uc3Qgbz1pLmdldCgiT2ZmIik7dGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlPW8gaW5zdGFuY2VvZiBCYXNlU3RyZWFtP286bnVsbDt0aGlzLmNoZWNrZWRBcHBlYXJhbmNlP3RoaXMuX3N0cmVhbXMucHVzaCh0aGlzLmNoZWNrZWRBcHBlYXJhbmNlKTp0aGlzLl9nZXREZWZhdWx0Q2hlY2tlZEFwcGVhcmFuY2UoZSwiY2hlY2siKTt0aGlzLnVuY2hlY2tlZEFwcGVhcmFuY2UmJnRoaXMuX3N0cmVhbXMucHVzaCh0aGlzLnVuY2hlY2tlZEFwcGVhcmFuY2UpO3RoaXMuX2ZhbGxiYWNrRm9udERpY3Q9dGhpcy5mYWxsYmFja0ZvbnREaWN0O251bGw9PT10aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUmJih0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWU9Ik9mZiIpfV9wcm9jZXNzUmFkaW9CdXR0b24oZSl7dGhpcy5kYXRhLmJ1dHRvblZhbHVlPW51bGw7Y29uc3QgdD1lLmRpY3QuZ2V0KCJQYXJlbnQiKTtpZih0IGluc3RhbmNlb2YgRGljdCl7dGhpcy5wYXJlbnQ9ZS5kaWN0LmdldFJhdygiUGFyZW50Iik7Y29uc3QgaT10LmdldCgiViIpO2kgaW5zdGFuY2VvZiBOYW1lJiYodGhpcy5kYXRhLmZpZWxkVmFsdWU9dGhpcy5fZGVjb2RlRm9ybVZhbHVlKGkpKX1jb25zdCBpPWUuZGljdC5nZXQoIkFQIik7aWYoIShpIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2NvbnN0IGE9aS5nZXQoIk4iKTtpZighKGEgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm47Zm9yKGNvbnN0IGUgb2YgYS5nZXRLZXlzKCkpaWYoIk9mZiIhPT1lKXt0aGlzLmRhdGEuYnV0dG9uVmFsdWU9dGhpcy5fZGVjb2RlRm9ybVZhbHVlKGUpO2JyZWFrfWNvbnN0IHM9YS5nZXQodGhpcy5kYXRhLmJ1dHRvblZhbHVlKTt0aGlzLmNoZWNrZWRBcHBlYXJhbmNlPXMgaW5zdGFuY2VvZiBCYXNlU3RyZWFtP3M6bnVsbDtjb25zdCByPWEuZ2V0KCJPZmYiKTt0aGlzLnVuY2hlY2tlZEFwcGVhcmFuY2U9ciBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/cjpudWxsO3RoaXMuY2hlY2tlZEFwcGVhcmFuY2U/dGhpcy5fc3RyZWFtcy5wdXNoKHRoaXMuY2hlY2tlZEFwcGVhcmFuY2UpOnRoaXMuX2dldERlZmF1bHRDaGVja2VkQXBwZWFyYW5jZShlLCJkaXNjIik7dGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlJiZ0aGlzLl9zdHJlYW1zLnB1c2godGhpcy51bmNoZWNrZWRBcHBlYXJhbmNlKTt0aGlzLl9mYWxsYmFja0ZvbnREaWN0PXRoaXMuZmFsbGJhY2tGb250RGljdDtudWxsPT09dGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlJiYodGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlPSJPZmYiKX1fcHJvY2Vzc1B1c2hCdXR0b24oZSl7Y29uc3R7ZGljdDp0LGFubm90YXRpb25HbG9iYWxzOml9PWU7aWYodC5oYXMoIkEiKXx8dC5oYXMoIkFBIil8fHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQpe3RoaXMuZGF0YS5pc1Rvb2x0aXBPbmx5PSF0LmhhcygiQSIpJiYhdC5oYXMoIkFBIik7Q2F0YWxvZy5wYXJzZURlc3REaWN0aW9uYXJ5KHtkZXN0RGljdDp0LHJlc3VsdE9iajp0aGlzLmRhdGEsZG9jQmFzZVVybDppLmJhc2VVcmwsZG9jQXR0YWNobWVudHM6aS5hdHRhY2htZW50c30pfWVsc2Ugd2FybigiUHVzaCBidXR0b25zIHdpdGhvdXQgYWN0aW9uIGRpY3Rpb25hcmllcyBhcmUgbm90IHN1cHBvcnRlZCIpfWdldEZpZWxkT2JqZWN0KCl7bGV0IGUsdD0iYnV0dG9uIjtpZih0aGlzLmRhdGEuY2hlY2tCb3gpe3Q9ImNoZWNrYm94IjtlPXRoaXMuZGF0YS5leHBvcnRWYWx1ZX1lbHNlIGlmKHRoaXMuZGF0YS5yYWRpb0J1dHRvbil7dD0icmFkaW9idXR0b24iO2U9dGhpcy5kYXRhLmJ1dHRvblZhbHVlfXJldHVybntpZDp0aGlzLmRhdGEuaWQsdmFsdWU6dGhpcy5kYXRhLmZpZWxkVmFsdWV8fCJPZmYiLGRlZmF1bHRWYWx1ZTp0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUsZXhwb3J0VmFsdWVzOmUsZWRpdGFibGU6IXRoaXMuZGF0YS5yZWFkT25seSxuYW1lOnRoaXMuZGF0YS5maWVsZE5hbWUscmVjdDp0aGlzLmRhdGEucmVjdCxoaWRkZW46dGhpcy5kYXRhLmhpZGRlbixhY3Rpb25zOnRoaXMuZGF0YS5hY3Rpb25zLHBhZ2U6dGhpcy5kYXRhLnBhZ2VJbmRleCxzdHJva2VDb2xvcjp0aGlzLmRhdGEuYm9yZGVyQ29sb3IsZmlsbENvbG9yOnRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3Iscm90YXRpb246dGhpcy5yb3RhdGlvbix0eXBlOnR9fWdldCBmYWxsYmFja0ZvbnREaWN0KCl7Y29uc3QgZT1uZXcgRGljdDtlLnNldCgiQmFzZUZvbnQiLE5hbWUuZ2V0KCJaYXBmRGluZ2JhdHMiKSk7ZS5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJGYWxsYmFja1R5cGUiKSk7ZS5zZXQoIlN1YnR5cGUiLE5hbWUuZ2V0KCJGYWxsYmFja1R5cGUiKSk7ZS5zZXQoIkVuY29kaW5nIixOYW1lLmdldCgiWmFwZkRpbmdiYXRzRW5jb2RpbmciKSk7cmV0dXJuIHNoYWRvdyh0aGlzLCJmYWxsYmFja0ZvbnREaWN0IixlKX19Y2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbiBleHRlbmRzIFdpZGdldEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LHhyZWY6aX09ZTt0aGlzLmluZGljZXM9dC5nZXRBcnJheSgiSSIpO3RoaXMuaGFzSW5kaWNlcz1BcnJheS5pc0FycmF5KHRoaXMuaW5kaWNlcykmJnRoaXMuaW5kaWNlcy5sZW5ndGg+MDt0aGlzLmRhdGEub3B0aW9ucz1bXTtjb25zdCBhPWdldEluaGVyaXRhYmxlUHJvcGVydHkoe2RpY3Q6dCxrZXk6Ik9wdCJ9KTtpZihBcnJheS5pc0FycmF5KGEpKWZvcihsZXQgZT0wLHQ9YS5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1pLmZldGNoSWZSZWYoYVtlXSkscz1BcnJheS5pc0FycmF5KHQpO3RoaXMuZGF0YS5vcHRpb25zW2VdPXtleHBvcnRWYWx1ZTp0aGlzLl9kZWNvZGVGb3JtVmFsdWUocz9pLmZldGNoSWZSZWYodFswXSk6dCksZGlzcGxheVZhbHVlOnRoaXMuX2RlY29kZUZvcm1WYWx1ZShzP2kuZmV0Y2hJZlJlZih0WzFdKTp0KX19aWYodGhpcy5oYXNJbmRpY2VzKXt0aGlzLmRhdGEuZmllbGRWYWx1ZT1bXTtjb25zdCBlPXRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtmb3IoY29uc3QgdCBvZiB0aGlzLmluZGljZXMpTnVtYmVyLmlzSW50ZWdlcih0KSYmdD49MCYmdDxlJiZ0aGlzLmRhdGEuZmllbGRWYWx1ZS5wdXNoKHRoaXMuZGF0YS5vcHRpb25zW3RdLmV4cG9ydFZhbHVlKX1lbHNlInN0cmluZyI9PXR5cGVvZiB0aGlzLmRhdGEuZmllbGRWYWx1ZT90aGlzLmRhdGEuZmllbGRWYWx1ZT1bdGhpcy5kYXRhLmZpZWxkVmFsdWVdOnRoaXMuZGF0YS5maWVsZFZhbHVlfHwodGhpcy5kYXRhLmZpZWxkVmFsdWU9W10pO3RoaXMuZGF0YS5jb21ibz10aGlzLmhhc0ZpZWxkRmxhZyhvQSk7dGhpcy5kYXRhLm11bHRpU2VsZWN0PXRoaXMuaGFzRmllbGRGbGFnKElBKTt0aGlzLl9oYXNUZXh0PSEwfWdldEZpZWxkT2JqZWN0KCl7Y29uc3QgZT10aGlzLmRhdGEuY29tYm8/ImNvbWJvYm94IjoibGlzdGJveCIsdD10aGlzLmRhdGEuZmllbGRWYWx1ZS5sZW5ndGg+MD90aGlzLmRhdGEuZmllbGRWYWx1ZVswXTpudWxsO3JldHVybntpZDp0aGlzLmRhdGEuaWQsdmFsdWU6dCxkZWZhdWx0VmFsdWU6dGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlLGVkaXRhYmxlOiF0aGlzLmRhdGEucmVhZE9ubHksbmFtZTp0aGlzLmRhdGEuZmllbGROYW1lLHJlY3Q6dGhpcy5kYXRhLnJlY3QsbnVtSXRlbXM6dGhpcy5kYXRhLmZpZWxkVmFsdWUubGVuZ3RoLG11bHRpcGxlU2VsZWN0aW9uOnRoaXMuZGF0YS5tdWx0aVNlbGVjdCxoaWRkZW46dGhpcy5kYXRhLmhpZGRlbixhY3Rpb25zOnRoaXMuZGF0YS5hY3Rpb25zLGl0ZW1zOnRoaXMuZGF0YS5vcHRpb25zLHBhZ2U6dGhpcy5kYXRhLnBhZ2VJbmRleCxzdHJva2VDb2xvcjp0aGlzLmRhdGEuYm9yZGVyQ29sb3IsZmlsbENvbG9yOnRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3Iscm90YXRpb246dGhpcy5yb3RhdGlvbix0eXBlOmV9fWFtZW5kU2F2ZWREaWN0KGUsdCl7aWYoIXRoaXMuaGFzSW5kaWNlcylyZXR1cm47bGV0IGk9ZT8uZ2V0KHRoaXMuZGF0YS5pZCk/LnZhbHVlO0FycmF5LmlzQXJyYXkoaSl8fChpPVtpXSk7Y29uc3QgYT1bXSx7b3B0aW9uczpzfT10aGlzLmRhdGE7Zm9yKGxldCBlPTAsdD0wLHI9cy5sZW5ndGg7ZTxyO2UrKylpZihzW2VdLmV4cG9ydFZhbHVlPT09aVt0XSl7YS5wdXNoKGUpO3QrPTF9dC5zZXQoIkkiLGEpfWFzeW5jIF9nZXRBcHBlYXJhbmNlKGUsdCxpLGEpe2lmKHRoaXMuZGF0YS5jb21ibylyZXR1cm4gc3VwZXIuX2dldEFwcGVhcmFuY2UoZSx0LGksYSk7bGV0IHIsbjtjb25zdCBvPWE/LmdldCh0aGlzLmRhdGEuaWQpO2lmKG8pe249by5yb3RhdGlvbjtyPW8udmFsdWV9aWYodm9pZCAwPT09biYmdm9pZCAwPT09ciYmIXRoaXMuX25lZWRBcHBlYXJhbmNlcylyZXR1cm4gbnVsbDt2b2lkIDA9PT1yP3I9dGhpcy5kYXRhLmZpZWxkVmFsdWU6QXJyYXkuaXNBcnJheShyKXx8KHI9W3JdKTtsZXQgZz10aGlzLmRhdGEucmVjdFszXS10aGlzLmRhdGEucmVjdFsxXSxjPXRoaXMuZGF0YS5yZWN0WzJdLXRoaXMuZGF0YS5yZWN0WzBdOzkwIT09biYmMjcwIT09bnx8KFtjLGddPVtnLGNdKTtjb25zdCBDPXRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aCxoPVtdO2ZvcihsZXQgZT0wO2U8QztlKyspe2NvbnN0e2V4cG9ydFZhbHVlOnR9PXRoaXMuZGF0YS5vcHRpb25zW2VdO3IuaW5jbHVkZXModCkmJmgucHVzaChlKX10aGlzLl9kZWZhdWx0QXBwZWFyYW5jZXx8KHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE9cGFyc2VEZWZhdWx0QXBwZWFyYW5jZSh0aGlzLl9kZWZhdWx0QXBwZWFyYW5jZT0iL0hlbHZldGljYSAwIFRmIDAgZyIpKTtjb25zdCBsPWF3YWl0IFdpZGdldEFubm90YXRpb24uX2dldEZvbnREYXRhKGUsdCx0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLHRoaXMuX2ZpZWxkUmVzb3VyY2VzLm1lcmdlZFJlc291cmNlcyk7bGV0IFEse2ZvbnRTaXplOkV9PXRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7aWYoRSlRPXRoaXMuX2RlZmF1bHRBcHBlYXJhbmNlO2Vsc2V7Y29uc3QgZT0oZy0xKS9DO2xldCB0LGk9LTE7Zm9yKGNvbnN0e2Rpc3BsYXlWYWx1ZTplfW9mIHRoaXMuZGF0YS5vcHRpb25zKXtjb25zdCBhPXRoaXMuX2dldFRleHRXaWR0aChlLGwpO2lmKGE+aSl7aT1hO3Q9ZX19W1EsRV09dGhpcy5fY29tcHV0ZUZvbnRTaXplKGUsYy00LHQsbCwtMSl9Y29uc3QgdT1FKnMsZD0odS1FKS8yLGY9TWF0aC5mbG9vcihnL3UpO2xldCBwPTA7aWYoaC5sZW5ndGg+MCl7Y29uc3QgZT1NYXRoLm1pbiguLi5oKSx0PU1hdGgubWF4KC4uLmgpO3A9TWF0aC5tYXgoMCx0LWYrMSk7cD5lJiYocD1lKX1jb25zdCBtPU1hdGgubWluKHArZisxLEMpLHk9WyIvVHggQk1DIHEiLGAxIDEgJHtjfSAke2d9IHJlIFcgbmBdO2lmKGgubGVuZ3RoKXt5LnB1c2goIjAuNjAwMDA2IDAuNzU2ODY2IDAuODU0OTA0IHJnIik7Zm9yKGNvbnN0IGUgb2YgaClwPD1lJiZlPG0mJnkucHVzaChgMSAke2ctKGUtcCsxKSp1fSAke2N9ICR7dX0gcmUgZmApfXkucHVzaCgiQlQiLFEsYDEgMCAwIDEgMCAke2d9IFRtYCk7Y29uc3Qgdz17c2hpZnQ6MH07Zm9yKGxldCBlPXA7ZTxtO2UrKyl7Y29uc3R7ZGlzcGxheVZhbHVlOnR9PXRoaXMuZGF0YS5vcHRpb25zW2VdLGk9ZT09PXA/ZDowO3kucHVzaCh0aGlzLl9yZW5kZXJUZXh0KHQsbCxFLGMsMCx3LDIsLXUraSkpfXkucHVzaCgiRVQgUSBFTUMiKTtyZXR1cm4geS5qb2luKCJcbiIpfX1jbGFzcyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uIGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTt0aGlzLmRhdGEuZmllbGRWYWx1ZT1udWxsO3RoaXMuZGF0YS5oYXNPd25DYW52YXM9dGhpcy5kYXRhLm5vUm90YXRlO3RoaXMuZGF0YS5ub0hUTUw9IXRoaXMuZGF0YS5oYXNPd25DYW52YXN9Z2V0RmllbGRPYmplY3QoKXtyZXR1cm57aWQ6dGhpcy5kYXRhLmlkLHZhbHVlOm51bGwscGFnZTp0aGlzLmRhdGEucGFnZUluZGV4LHR5cGU6InNpZ25hdHVyZSJ9fX1jbGFzcyBUZXh0QW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLm5vUm90YXRlPSEwO3RoaXMuZGF0YS5oYXNPd25DYW52YXM9dGhpcy5kYXRhLm5vUm90YXRlO3RoaXMuZGF0YS5ub0hUTUw9ITE7Y29uc3R7ZGljdDp0fT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1TO2lmKHRoaXMuZGF0YS5oYXNBcHBlYXJhbmNlKXRoaXMuZGF0YS5uYW1lPSJOb0ljb24iO2Vsc2V7dGhpcy5kYXRhLnJlY3RbMV09dGhpcy5kYXRhLnJlY3RbM10tMjI7dGhpcy5kYXRhLnJlY3RbMl09dGhpcy5kYXRhLnJlY3RbMF0rMjI7dGhpcy5kYXRhLm5hbWU9dC5oYXMoIk5hbWUiKT90LmdldCgiTmFtZSIpLm5hbWU6Ik5vdGUifWlmKHQuaGFzKCJTdGF0ZSIpKXt0aGlzLmRhdGEuc3RhdGU9dC5nZXQoIlN0YXRlIil8fG51bGw7dGhpcy5kYXRhLnN0YXRlTW9kZWw9dC5nZXQoIlN0YXRlTW9kZWwiKXx8bnVsbH1lbHNle3RoaXMuZGF0YS5zdGF0ZT1udWxsO3RoaXMuZGF0YS5zdGF0ZU1vZGVsPW51bGx9fX1jbGFzcyBMaW5rQW5ub3RhdGlvbiBleHRlbmRzIEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LGFubm90YXRpb25HbG9iYWxzOml9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPWs7dGhpcy5kYXRhLm5vSFRNTD0hMTtjb25zdCBhPWdldFF1YWRQb2ludHModCx0aGlzLnJlY3RhbmdsZSk7YSYmKHRoaXMuZGF0YS5xdWFkUG9pbnRzPWEpO3RoaXMuZGF0YS5ib3JkZXJDb2xvcnx8PXRoaXMuZGF0YS5jb2xvcjtDYXRhbG9nLnBhcnNlRGVzdERpY3Rpb25hcnkoe2Rlc3REaWN0OnQscmVzdWx0T2JqOnRoaXMuZGF0YSxkb2NCYXNlVXJsOmkuYmFzZVVybCxkb2NBdHRhY2htZW50czppLmF0dGFjaG1lbnRzfSl9fWNsYXNzIFBvcHVwQW5ub3RhdGlvbiBleHRlbmRzIEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0fT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1xO3RoaXMuZGF0YS5ub0hUTUw9ITE7dGhpcy5kYXRhLnJlY3RbMF0hPT10aGlzLmRhdGEucmVjdFsyXSYmdGhpcy5kYXRhLnJlY3RbMV0hPT10aGlzLmRhdGEucmVjdFszXXx8KHRoaXMuZGF0YS5yZWN0PW51bGwpO2xldCBpPXQuZ2V0KCJQYXJlbnQiKTtpZighaSl7d2FybigiUG9wdXAgYW5ub3RhdGlvbiBoYXMgYSBtaXNzaW5nIG9yIGludmFsaWQgcGFyZW50IGFubm90YXRpb24uIik7cmV0dXJufWNvbnN0IGE9aS5nZXRBcnJheSgiUmVjdCIpO3RoaXMuZGF0YS5wYXJlbnRSZWN0PUFycmF5LmlzQXJyYXkoYSkmJjQ9PT1hLmxlbmd0aD9VdGlsLm5vcm1hbGl6ZVJlY3QoYSk6bnVsbDtpc05hbWUoaS5nZXQoIlJUIiksaikmJihpPWkuZ2V0KCJJUlQiKSk7aWYoaS5oYXMoIk0iKSl7dGhpcy5zZXRNb2RpZmljYXRpb25EYXRlKGkuZ2V0KCJNIikpO3RoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlPXRoaXMubW9kaWZpY2F0aW9uRGF0ZX1lbHNlIHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlPW51bGw7aWYoaS5oYXMoIkMiKSl7dGhpcy5zZXRDb2xvcihpLmdldEFycmF5KCJDIikpO3RoaXMuZGF0YS5jb2xvcj10aGlzLmNvbG9yfWVsc2UgdGhpcy5kYXRhLmNvbG9yPW51bGw7aWYoIXRoaXMudmlld2FibGUpe2NvbnN0IGU9aS5nZXQoIkYiKTt0aGlzLl9pc1ZpZXdhYmxlKGUpJiZ0aGlzLnNldEZsYWdzKGUpfXRoaXMuc2V0VGl0bGUoaS5nZXQoIlQiKSk7dGhpcy5kYXRhLnRpdGxlT2JqPXRoaXMuX3RpdGxlO3RoaXMuc2V0Q29udGVudHMoaS5nZXQoIkNvbnRlbnRzIikpO3RoaXMuZGF0YS5jb250ZW50c09iaj10aGlzLl9jb250ZW50cztpLmhhcygiUkMiKSYmKHRoaXMuZGF0YS5yaWNoVGV4dD1YRkFGYWN0b3J5LmdldFJpY2hUZXh0QXNIdG1sKGkuZ2V0KCJSQyIpKSk7dGhpcy5kYXRhLm9wZW49ISF0LmdldCgiT3BlbiIpfX1jbGFzcyBGcmVlVGV4dEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5oYXNPd25DYW52YXM9IXRoaXMuZGF0YS5ub0hUTUw7dGhpcy5kYXRhLm5vSFRNTD0hMTtjb25zdHtldmFsdWF0b3JPcHRpb25zOnQseHJlZjppfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT1OO3RoaXMuc2V0RGVmYXVsdEFwcGVhcmFuY2UoZSk7dGhpcy5faGFzQXBwZWFyYW5jZT0hIXRoaXMuYXBwZWFyYW5jZTtpZih0aGlzLl9oYXNBcHBlYXJhbmNlKXtjb25zdHtmb250Q29sb3I6ZSxmb250U2l6ZTphfT1mdW5jdGlvbiBwYXJzZUFwcGVhcmFuY2VTdHJlYW0oZSx0LGkpe3JldHVybiBuZXcgQXBwZWFyYW5jZVN0cmVhbUV2YWx1YXRvcihlLHQsaSkucGFyc2UoKX0odGhpcy5hcHBlYXJhbmNlLHQsaSk7dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YS5mb250Q29sb3I9ZTt0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplPWF8fDEwfWVsc2V7dGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YS5mb250U2l6ZXx8PTEwO2NvbnN0e2ZvbnRDb2xvcjp0LGZvbnRTaXplOmF9PXRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7aWYodGhpcy5fY29udGVudHMuc3RyKXt0aGlzLmRhdGEudGV4dENvbnRlbnQ9dGhpcy5fY29udGVudHMuc3RyLnNwbGl0KC9cclxuP3xcbi8pLm1hcCgoZT0+ZS50cmltRW5kKCkpKTtjb25zdHtjb29yZHM6ZSxiYm94OnQsbWF0cml4Oml9PUZha2VVbmljb2RlRm9udC5nZXRGaXJzdFBvc2l0aW9uSW5mbyh0aGlzLnJlY3RhbmdsZSx0aGlzLnJvdGF0aW9uLGEpO3RoaXMuZGF0YS50ZXh0UG9zaXRpb249dGhpcy5fdHJhbnNmb3JtUG9pbnQoZSx0LGkpfWlmKHRoaXMuX2lzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKXtjb25zdCBzPWUuZGljdC5nZXQoIkNBIikscj1uZXcgRmFrZVVuaWNvZGVGb250KGksInNhbnMtc2VyaWYiKTt0aGlzLmFwcGVhcmFuY2U9ci5jcmVhdGVBcHBlYXJhbmNlKHRoaXMuX2NvbnRlbnRzLnN0cix0aGlzLnJlY3RhbmdsZSx0aGlzLnJvdGF0aW9uLGEsdCxzKTt0aGlzLl9zdHJlYW1zLnB1c2godGhpcy5hcHBlYXJhbmNlKX1lbHNlIHdhcm4oIkZyZWVUZXh0QW5ub3RhdGlvbjogT2Zmc2NyZWVuQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWQsIGFubm90YXRpb24gbWF5IG5vdCByZW5kZXIgY29ycmVjdGx5LiIpfX1nZXQgaGFzVGV4dENvbnRlbnQoKXtyZXR1cm4gdGhpcy5faGFzQXBwZWFyYW5jZX1zdGF0aWMgY3JlYXRlTmV3RGljdChlLHQse2FwUmVmOmksYXA6YX0pe2NvbnN0e2NvbG9yOnMsZm9udFNpemU6cixyZWN0Om4scm90YXRpb246byx1c2VyOmcsdmFsdWU6Y309ZSxDPW5ldyBEaWN0KHQpO0Muc2V0KCJUeXBlIixOYW1lLmdldCgiQW5ub3QiKSk7Qy5zZXQoIlN1YnR5cGUiLE5hbWUuZ2V0KCJGcmVlVGV4dCIpKTtDLnNldCgiQ3JlYXRpb25EYXRlIixgRDoke2dldE1vZGlmaWNhdGlvbkRhdGUoKX1gKTtDLnNldCgiUmVjdCIsbik7Y29uc3QgaD1gL0hlbHYgJHtyfSBUZiAke2dldFBkZkNvbG9yKHMsITApfWA7Qy5zZXQoIkRBIixoKTtDLnNldCgiQ29udGVudHMiLGlzQXNjaWkoYyk/YzpzdHJpbmdUb1VURjE2U3RyaW5nKGMsITApKTtDLnNldCgiRiIsNCk7Qy5zZXQoIkJvcmRlciIsWzAsMCwwXSk7Qy5zZXQoIlJvdGF0ZSIsbyk7ZyYmQy5zZXQoIlQiLGlzQXNjaWkoZyk/ZzpzdHJpbmdUb1VURjE2U3RyaW5nKGcsITApKTtpZihpfHxhKXtjb25zdCBlPW5ldyBEaWN0KHQpO0Muc2V0KCJBUCIsZSk7aT9lLnNldCgiTiIsaSk6ZS5zZXQoIk4iLGEpfXJldHVybiBDfXN0YXRpYyBhc3luYyBjcmVhdGVOZXdBcHBlYXJhbmNlU3RyZWFtKGUsdCxpKXtjb25zdHtiYXNlRm9udFJlZjphLGV2YWx1YXRvcjpyLHRhc2s6bn09aSx7Y29sb3I6byxmb250U2l6ZTpnLHJlY3Q6Yyxyb3RhdGlvbjpDLHZhbHVlOmh9PWUsbD1uZXcgRGljdCh0KSxRPW5ldyBEaWN0KHQpO2lmKGEpUS5zZXQoIkhlbHYiLGEpO2Vsc2V7Y29uc3QgZT1uZXcgRGljdCh0KTtlLnNldCgiQmFzZUZvbnQiLE5hbWUuZ2V0KCJIZWx2ZXRpY2EiKSk7ZS5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJGb250IikpO2Uuc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiVHlwZTEiKSk7ZS5zZXQoIkVuY29kaW5nIixOYW1lLmdldCgiV2luQW5zaUVuY29kaW5nIikpO1Euc2V0KCJIZWx2IixlKX1sLnNldCgiRm9udCIsUSk7Y29uc3QgRT1hd2FpdCBXaWRnZXRBbm5vdGF0aW9uLl9nZXRGb250RGF0YShyLG4se2ZvbnROYW1lOiJIZWx2Iixmb250U2l6ZTpnfSxsKSxbdSxkLGYscF09YztsZXQgbT1mLXUseT1wLWQ7QyUxODAhPTAmJihbbSx5XT1beSxtXSk7Y29uc3Qgdz1oLnNwbGl0KCJcbiIpLGI9Zy8xZTM7bGV0IEQ9LTEvMDtjb25zdCBGPVtdO2ZvcihsZXQgZSBvZiB3KXtjb25zdCB0PUUuZW5jb2RlU3RyaW5nKGUpO2lmKHQubGVuZ3RoPjEpcmV0dXJuIG51bGw7ZT10LmpvaW4oIiIpO0YucHVzaChlKTtsZXQgaT0wO2NvbnN0IGE9RS5jaGFyc1RvR2x5cGhzKGUpO2Zvcihjb25zdCBlIG9mIGEpaSs9ZS53aWR0aCpiO0Q9TWF0aC5tYXgoRCxpKX1sZXQgUz0xO0Q+bSYmKFM9bS9EKTtsZXQgaz0xO2NvbnN0IE49cypnLFI9MSpnLEc9Tip3Lmxlbmd0aDtHPnkmJihrPXkvRyk7Y29uc3QgeD1nKk1hdGgubWluKFMsayk7bGV0IFUsTSxMO3N3aXRjaChDKXtjYXNlIDA6TD1bMSwwLDAsMV07TT1bY1swXSxjWzFdLG0seV07VT1bY1swXSxjWzNdLVJdO2JyZWFrO2Nhc2UgOTA6TD1bMCwxLC0xLDBdO009W2NbMV0sLWNbMl0sbSx5XTtVPVtjWzFdLC1jWzBdLVJdO2JyZWFrO2Nhc2UgMTgwOkw9Wy0xLDAsMCwtMV07TT1bLWNbMl0sLWNbM10sbSx5XTtVPVstY1syXSwtY1sxXS1SXTticmVhaztjYXNlIDI3MDpMPVswLC0xLDEsMF07TT1bLWNbM10sY1swXSxtLHldO1U9Wy1jWzNdLGNbMl0tUl19Y29uc3QgSD1bInEiLGAke0wuam9pbigiICIpfSAwIDAgY21gLGAke00uam9pbigiICIpfSByZSBXIG5gLCJCVCIsYCR7Z2V0UGRmQ29sb3IobywhMCl9YCxgMCBUYyAvSGVsdiAke251bWJlclRvU3RyaW5nKHgpfSBUZmBdO0gucHVzaChgJHtVLmpvaW4oIiAiKX0gVGQgKCR7ZXNjYXBlU3RyaW5nKEZbMF0pfSkgVGpgKTtjb25zdCBKPW51bWJlclRvU3RyaW5nKE4pO2ZvcihsZXQgZT0xLHQ9Ri5sZW5ndGg7ZTx0O2UrKyl7Y29uc3QgdD1GW2VdO0gucHVzaChgMCAtJHtKfSBUZCAoJHtlc2NhcGVTdHJpbmcodCl9KSBUamApfUgucHVzaCgiRVQiLCJRIik7Y29uc3QgWT1ILmpvaW4oIlxuIiksdj1uZXcgRGljdCh0KTt2LnNldCgiRm9ybVR5cGUiLDEpO3Yuc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiRm9ybSIpKTt2LnNldCgiVHlwZSIsTmFtZS5nZXQoIlhPYmplY3QiKSk7di5zZXQoIkJCb3giLGMpO3Yuc2V0KCJSZXNvdXJjZXMiLGwpO3Yuc2V0KCJNYXRyaXgiLFsxLDAsMCwxLC1jWzBdLC1jWzFdXSk7Y29uc3QgSz1uZXcgU3RyaW5nU3RyZWFtKFkpO0suZGljdD12O3JldHVybiBLfX1jbGFzcyBMaW5lQW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LHhyZWY6aX09ZTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9Ujt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5ub1JvdGF0ZTt0aGlzLmRhdGEubm9IVE1MPSExO2NvbnN0IGE9dC5nZXRBcnJheSgiTCIpO3RoaXMuZGF0YS5saW5lQ29vcmRpbmF0ZXM9VXRpbC5ub3JtYWxpemVSZWN0KGEpO3RoaXMuc2V0TGluZUVuZGluZ3ModC5nZXRBcnJheSgiTEUiKSk7dGhpcy5kYXRhLmxpbmVFbmRpbmdzPXRoaXMubGluZUVuZGluZ3M7aWYoIXRoaXMuYXBwZWFyYW5jZSl7Y29uc3QgZT10aGlzLmNvbG9yP2dldFBkZkNvbG9yQXJyYXkodGhpcy5jb2xvcik6WzAsMCwwXSxzPXQuZ2V0KCJDQSIpLHI9Z2V0UmdiQ29sb3IodC5nZXRBcnJheSgiSUMiKSxudWxsKSxuPXI/Z2V0UGRmQ29sb3JBcnJheShyKTpudWxsLG89bj9zOm51bGwsZz10aGlzLmJvcmRlclN0eWxlLndpZHRofHwxLGM9MipnLEM9W3RoaXMuZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0tYyx0aGlzLmRhdGEubGluZUNvb3JkaW5hdGVzWzFdLWMsdGhpcy5kYXRhLmxpbmVDb29yZGluYXRlc1syXStjLHRoaXMuZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10rY107VXRpbC5pbnRlcnNlY3QodGhpcy5yZWN0YW5nbGUsQyl8fCh0aGlzLnJlY3RhbmdsZT1DKTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjppLGV4dHJhOmAke2d9IHdgLHN0cm9rZUNvbG9yOmUsZmlsbENvbG9yOm4sc3Ryb2tlQWxwaGE6cyxmaWxsQWxwaGE6byxwb2ludHNDYWxsYmFjazooZSx0KT0+e2UucHVzaChgJHthWzBdfSAke2FbMV19IG1gLGAke2FbMl19ICR7YVszXX0gbGAsIlMiKTtyZXR1cm5bdFswXS54LWcsdFsxXS54K2csdFszXS55LWcsdFsxXS55K2ddfX0pfX19Y2xhc3MgU3F1YXJlQW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LHhyZWY6aX09ZTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9Rzt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5ub1JvdGF0ZTt0aGlzLmRhdGEubm9IVE1MPSExO2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IGU9dGhpcy5jb2xvcj9nZXRQZGZDb2xvckFycmF5KHRoaXMuY29sb3IpOlswLDAsMF0sYT10LmdldCgiQ0EiKSxzPWdldFJnYkNvbG9yKHQuZ2V0QXJyYXkoIklDIiksbnVsbCkscj1zP2dldFBkZkNvbG9yQXJyYXkocyk6bnVsbCxuPXI/YTpudWxsO2lmKDA9PT10aGlzLmJvcmRlclN0eWxlLndpZHRoJiYhcilyZXR1cm47dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6aSxleHRyYTpgJHt0aGlzLmJvcmRlclN0eWxlLndpZHRofSB3YCxzdHJva2VDb2xvcjplLGZpbGxDb2xvcjpyLHN0cm9rZUFscGhhOmEsZmlsbEFscGhhOm4scG9pbnRzQ2FsbGJhY2s6KGUsdCk9Pntjb25zdCBpPXRbMl0ueCt0aGlzLmJvcmRlclN0eWxlLndpZHRoLzIsYT10WzJdLnkrdGhpcy5ib3JkZXJTdHlsZS53aWR0aC8yLHM9dFszXS54LXRbMl0ueC10aGlzLmJvcmRlclN0eWxlLndpZHRoLG49dFsxXS55LXRbM10ueS10aGlzLmJvcmRlclN0eWxlLndpZHRoO2UucHVzaChgJHtpfSAke2F9ICR7c30gJHtufSByZWApO3I/ZS5wdXNoKCJCIik6ZS5wdXNoKCJTIik7cmV0dXJuW3RbMF0ueCx0WzFdLngsdFszXS55LHRbMV0ueV19fSl9fX1jbGFzcyBDaXJjbGVBbm5vdGF0aW9uIGV4dGVuZHMgTWFya3VwQW5ub3RhdGlvbntjb25zdHJ1Y3RvcihlKXtzdXBlcihlKTtjb25zdHtkaWN0OnQseHJlZjppfT1lO3RoaXMuZGF0YS5hbm5vdGF0aW9uVHlwZT14O2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IGU9dGhpcy5jb2xvcj9nZXRQZGZDb2xvckFycmF5KHRoaXMuY29sb3IpOlswLDAsMF0sYT10LmdldCgiQ0EiKSxzPWdldFJnYkNvbG9yKHQuZ2V0QXJyYXkoIklDIiksbnVsbCkscj1zP2dldFBkZkNvbG9yQXJyYXkocyk6bnVsbCxuPXI/YTpudWxsO2lmKDA9PT10aGlzLmJvcmRlclN0eWxlLndpZHRoJiYhcilyZXR1cm47Y29uc3Qgbz00LzMqTWF0aC50YW4oTWF0aC5QSS84KTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjppLGV4dHJhOmAke3RoaXMuYm9yZGVyU3R5bGUud2lkdGh9IHdgLHN0cm9rZUNvbG9yOmUsZmlsbENvbG9yOnIsc3Ryb2tlQWxwaGE6YSxmaWxsQWxwaGE6bixwb2ludHNDYWxsYmFjazooZSx0KT0+e2NvbnN0IGk9dFswXS54K3RoaXMuYm9yZGVyU3R5bGUud2lkdGgvMixhPXRbMF0ueS10aGlzLmJvcmRlclN0eWxlLndpZHRoLzIscz10WzNdLngtdGhpcy5ib3JkZXJTdHlsZS53aWR0aC8yLG49dFszXS55K3RoaXMuYm9yZGVyU3R5bGUud2lkdGgvMixnPWkrKHMtaSkvMixjPWErKG4tYSkvMixDPShzLWkpLzIqbyxoPShuLWEpLzIqbztlLnB1c2goYCR7Z30gJHtufSBtYCxgJHtnK0N9ICR7bn0gJHtzfSAke2MraH0gJHtzfSAke2N9IGNgLGAke3N9ICR7Yy1ofSAke2crQ30gJHthfSAke2d9ICR7YX0gY2AsYCR7Zy1DfSAke2F9ICR7aX0gJHtjLWh9ICR7aX0gJHtjfSBjYCxgJHtpfSAke2MraH0gJHtnLUN9ICR7bn0gJHtnfSAke259IGNgLCJoIik7cj9lLnB1c2goIkIiKTplLnB1c2goIlMiKTtyZXR1cm5bdFswXS54LHRbMV0ueCx0WzNdLnksdFsxXS55XX19KX19fWNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LHhyZWY6aX09ZTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9TTt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5ub1JvdGF0ZTt0aGlzLmRhdGEubm9IVE1MPSExO3RoaXMuZGF0YS52ZXJ0aWNlcz1bXTtpZighKHRoaXMgaW5zdGFuY2VvZiBQb2x5Z29uQW5ub3RhdGlvbikpe3RoaXMuc2V0TGluZUVuZGluZ3ModC5nZXRBcnJheSgiTEUiKSk7dGhpcy5kYXRhLmxpbmVFbmRpbmdzPXRoaXMubGluZUVuZGluZ3N9Y29uc3QgYT10LmdldEFycmF5KCJWZXJ0aWNlcyIpO2lmKEFycmF5LmlzQXJyYXkoYSkpe2ZvcihsZXQgZT0wLHQ9YS5sZW5ndGg7ZTx0O2UrPTIpdGhpcy5kYXRhLnZlcnRpY2VzLnB1c2goe3g6YVtlXSx5OmFbZSsxXX0pO2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IGU9dGhpcy5jb2xvcj9nZXRQZGZDb2xvckFycmF5KHRoaXMuY29sb3IpOlswLDAsMF0sYT10LmdldCgiQ0EiKSxzPXRoaXMuYm9yZGVyU3R5bGUud2lkdGh8fDEscj0yKnMsbj1bMS8wLDEvMCwtMS8wLC0xLzBdO2Zvcihjb25zdCBlIG9mIHRoaXMuZGF0YS52ZXJ0aWNlcyl7blswXT1NYXRoLm1pbihuWzBdLGUueC1yKTtuWzFdPU1hdGgubWluKG5bMV0sZS55LXIpO25bMl09TWF0aC5tYXgoblsyXSxlLngrcik7blszXT1NYXRoLm1heChuWzNdLGUueStyKX1VdGlsLmludGVyc2VjdCh0aGlzLnJlY3RhbmdsZSxuKXx8KHRoaXMucmVjdGFuZ2xlPW4pO3RoaXMuX3NldERlZmF1bHRBcHBlYXJhbmNlKHt4cmVmOmksZXh0cmE6YCR7c30gd2Asc3Ryb2tlQ29sb3I6ZSxzdHJva2VBbHBoYTphLHBvaW50c0NhbGxiYWNrOihlLHQpPT57Y29uc3QgaT10aGlzLmRhdGEudmVydGljZXM7Zm9yKGxldCB0PTAsYT1pLmxlbmd0aDt0PGE7dCsrKWUucHVzaChgJHtpW3RdLnh9ICR7aVt0XS55fSAkezA9PT10PyJtIjoibCJ9YCk7ZS5wdXNoKCJTIik7cmV0dXJuW3RbMF0ueCx0WzFdLngsdFszXS55LHRbMV0ueV19fSl9fX19Y2xhc3MgUG9seWdvbkFubm90YXRpb24gZXh0ZW5kcyBQb2x5bGluZUFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPVV9fWNsYXNzIENhcmV0QW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPUt9fWNsYXNzIElua0Fubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMuZGF0YS5oYXNPd25DYW52YXM9dGhpcy5kYXRhLm5vUm90YXRlO3RoaXMuZGF0YS5ub0hUTUw9ITE7Y29uc3R7ZGljdDp0LHhyZWY6aX09ZTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9VDt0aGlzLmRhdGEuaW5rTGlzdHM9W107Y29uc3QgYT10LmdldEFycmF5KCJJbmtMaXN0Iik7aWYoQXJyYXkuaXNBcnJheShhKSl7Zm9yKGxldCBlPTAsdD1hLmxlbmd0aDtlPHQ7KytlKXt0aGlzLmRhdGEuaW5rTGlzdHMucHVzaChbXSk7Zm9yKGxldCB0PTAscz1hW2VdLmxlbmd0aDt0PHM7dCs9Mil0aGlzLmRhdGEuaW5rTGlzdHNbZV0ucHVzaCh7eDppLmZldGNoSWZSZWYoYVtlXVt0XSkseTppLmZldGNoSWZSZWYoYVtlXVt0KzFdKX0pfWlmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IGU9dGhpcy5jb2xvcj9nZXRQZGZDb2xvckFycmF5KHRoaXMuY29sb3IpOlswLDAsMF0sYT10LmdldCgiQ0EiKSxzPXRoaXMuYm9yZGVyU3R5bGUud2lkdGh8fDEscj0yKnMsbj1bMS8wLDEvMCwtMS8wLC0xLzBdO2Zvcihjb25zdCBlIG9mIHRoaXMuZGF0YS5pbmtMaXN0cylmb3IoY29uc3QgdCBvZiBlKXtuWzBdPU1hdGgubWluKG5bMF0sdC54LXIpO25bMV09TWF0aC5taW4oblsxXSx0Lnktcik7blsyXT1NYXRoLm1heChuWzJdLHQueCtyKTtuWzNdPU1hdGgubWF4KG5bM10sdC55K3IpfVV0aWwuaW50ZXJzZWN0KHRoaXMucmVjdGFuZ2xlLG4pfHwodGhpcy5yZWN0YW5nbGU9bik7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6aSxleHRyYTpgJHtzfSB3YCxzdHJva2VDb2xvcjplLHN0cm9rZUFscGhhOmEscG9pbnRzQ2FsbGJhY2s6KGUsdCk9Pntmb3IoY29uc3QgdCBvZiB0aGlzLmRhdGEuaW5rTGlzdHMpe2ZvcihsZXQgaT0wLGE9dC5sZW5ndGg7aTxhO2krKyllLnB1c2goYCR7dFtpXS54fSAke3RbaV0ueX0gJHswPT09aT8ibSI6ImwifWApO2UucHVzaCgiUyIpfXJldHVyblt0WzBdLngsdFsxXS54LHRbM10ueSx0WzFdLnldfX0pfX19c3RhdGljIGNyZWF0ZU5ld0RpY3QoZSx0LHthcFJlZjppLGFwOmF9KXtjb25zdHtjb2xvcjpzLG9wYWNpdHk6cixwYXRoczpuLG91dGxpbmVzOm8scmVjdDpnLHJvdGF0aW9uOmMsdGhpY2tuZXNzOkN9PWUsaD1uZXcgRGljdCh0KTtoLnNldCgiVHlwZSIsTmFtZS5nZXQoIkFubm90IikpO2guc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiSW5rIikpO2guc2V0KCJDcmVhdGlvbkRhdGUiLGBEOiR7Z2V0TW9kaWZpY2F0aW9uRGF0ZSgpfWApO2guc2V0KCJSZWN0IixnKTtoLnNldCgiSW5rTGlzdCIsbz8ucG9pbnRzfHxuLm1hcCgoZT0+ZS5wb2ludHMpKSk7aC5zZXQoIkYiLDQpO2guc2V0KCJSb3RhdGUiLGMpO28mJmguc2V0KCJJVCIsTmFtZS5nZXQoIklua0hpZ2hsaWdodCIpKTtjb25zdCBsPW5ldyBEaWN0KHQpO2guc2V0KCJCUyIsbCk7bC5zZXQoIlciLEMpO2guc2V0KCJDIixBcnJheS5mcm9tKHMsKGU9PmUvMjU1KSkpO2guc2V0KCJDQSIscik7Y29uc3QgUT1uZXcgRGljdCh0KTtoLnNldCgiQVAiLFEpO2k/US5zZXQoIk4iLGkpOlEuc2V0KCJOIixhKTtyZXR1cm4gaH1zdGF0aWMgYXN5bmMgY3JlYXRlTmV3QXBwZWFyYW5jZVN0cmVhbShlLHQsaSl7aWYoZS5vdXRsaW5lcylyZXR1cm4gdGhpcy5jcmVhdGVOZXdBcHBlYXJhbmNlU3RyZWFtRm9ySGlnaGxpZ2h0KGUsdCxpKTtjb25zdHtjb2xvcjphLHJlY3Q6cyxwYXRoczpyLHRoaWNrbmVzczpuLG9wYWNpdHk6b309ZSxnPVtgJHtufSB3IDEgSiAxIGpgLGAke2dldFBkZkNvbG9yKGEsITEpfWBdOzEhPT1vJiZnLnB1c2goIi9SMCBncyIpO2NvbnN0IGM9W107Zm9yKGNvbnN0e2JlemllcjplfW9mIHIpe2MubGVuZ3RoPTA7Yy5wdXNoKGAke251bWJlclRvU3RyaW5nKGVbMF0pfSAke251bWJlclRvU3RyaW5nKGVbMV0pfSBtYCk7aWYoMj09PWUubGVuZ3RoKWMucHVzaChgJHtudW1iZXJUb1N0cmluZyhlWzBdKX0gJHtudW1iZXJUb1N0cmluZyhlWzFdKX0gbCBTYCk7ZWxzZXtmb3IobGV0IHQ9MixpPWUubGVuZ3RoO3Q8aTt0Kz02KXtjb25zdCBpPWUuc2xpY2UodCx0KzYpLm1hcChudW1iZXJUb1N0cmluZykuam9pbigiICIpO2MucHVzaChgJHtpfSBjYCl9Yy5wdXNoKCJTIil9Zy5wdXNoKGMuam9pbigiXG4iKSl9Y29uc3QgQz1nLmpvaW4oIlxuIiksaD1uZXcgRGljdCh0KTtoLnNldCgiRm9ybVR5cGUiLDEpO2guc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiRm9ybSIpKTtoLnNldCgiVHlwZSIsTmFtZS5nZXQoIlhPYmplY3QiKSk7aC5zZXQoIkJCb3giLHMpO2guc2V0KCJMZW5ndGgiLEMubGVuZ3RoKTtpZigxIT09byl7Y29uc3QgZT1uZXcgRGljdCh0KSxpPW5ldyBEaWN0KHQpLGE9bmV3IERpY3QodCk7YS5zZXQoIkNBIixvKTthLnNldCgiVHlwZSIsTmFtZS5nZXQoIkV4dEdTdGF0ZSIpKTtpLnNldCgiUjAiLGEpO2Uuc2V0KCJFeHRHU3RhdGUiLGkpO2guc2V0KCJSZXNvdXJjZXMiLGUpfWNvbnN0IGw9bmV3IFN0cmluZ1N0cmVhbShDKTtsLmRpY3Q9aDtyZXR1cm4gbH1zdGF0aWMgYXN5bmMgY3JlYXRlTmV3QXBwZWFyYW5jZVN0cmVhbUZvckhpZ2hsaWdodChlLHQsaSl7Y29uc3R7Y29sb3I6YSxyZWN0OnMsb3V0bGluZXM6e291dGxpbmU6cn0sb3BhY2l0eTpufT1lLG89W2Ake2dldFBkZkNvbG9yKGEsITApfWAsIi9SMCBncyJdO28ucHVzaChgJHtudW1iZXJUb1N0cmluZyhyWzRdKX0gJHtudW1iZXJUb1N0cmluZyhyWzVdKX0gbWApO2ZvcihsZXQgZT02LHQ9ci5sZW5ndGg7ZTx0O2UrPTYpaWYoaXNOYU4ocltlXSl8fG51bGw9PT1yW2VdKW8ucHVzaChgJHtudW1iZXJUb1N0cmluZyhyW2UrNF0pfSAke251bWJlclRvU3RyaW5nKHJbZSs1XSl9IGxgKTtlbHNle2NvbnN0IHQ9ci5zbGljZShlLGUrNikubWFwKG51bWJlclRvU3RyaW5nKS5qb2luKCIgIik7by5wdXNoKGAke3R9IGNgKX1vLnB1c2goImggZiIpO2NvbnN0IGc9by5qb2luKCJcbiIpLGM9bmV3IERpY3QodCk7Yy5zZXQoIkZvcm1UeXBlIiwxKTtjLnNldCgiU3VidHlwZSIsTmFtZS5nZXQoIkZvcm0iKSk7Yy5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJYT2JqZWN0IikpO2Muc2V0KCJCQm94IixzKTtjLnNldCgiTGVuZ3RoIixnLmxlbmd0aCk7Y29uc3QgQz1uZXcgRGljdCh0KSxoPW5ldyBEaWN0KHQpO0Muc2V0KCJFeHRHU3RhdGUiLGgpO2Muc2V0KCJSZXNvdXJjZXMiLEMpO2NvbnN0IGw9bmV3IERpY3QodCk7aC5zZXQoIlIwIixsKTtsLnNldCgiQk0iLE5hbWUuZ2V0KCJNdWx0aXBseSIpKTtpZigxIT09bil7bC5zZXQoImNhIixuKTtsLnNldCgiVHlwZSIsTmFtZS5nZXQoIkV4dEdTdGF0ZSIpKX1jb25zdCBRPW5ldyBTdHJpbmdTdHJlYW0oZyk7US5kaWN0PWM7cmV0dXJuIFF9fWNsYXNzIEhpZ2hsaWdodEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dCx4cmVmOml9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPUw7aWYodGhpcy5kYXRhLnF1YWRQb2ludHM9Z2V0UXVhZFBvaW50cyh0LG51bGwpKXtjb25zdCBlPXRoaXMuYXBwZWFyYW5jZT8uZGljdC5nZXQoIlJlc291cmNlcyIpO2lmKCF0aGlzLmFwcGVhcmFuY2V8fCFlPy5oYXMoIkV4dEdTdGF0ZSIpKXt0aGlzLmFwcGVhcmFuY2UmJndhcm4oIkhpZ2hsaWdodEFubm90YXRpb24gLSBpZ25vcmluZyBidWlsdC1pbiBhcHBlYXJhbmNlIHN0cmVhbS4iKTtjb25zdCBlPXRoaXMuY29sb3I/Z2V0UGRmQ29sb3JBcnJheSh0aGlzLmNvbG9yKTpbMSwxLDBdLGE9dC5nZXQoIkNBIik7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6aSxmaWxsQ29sb3I6ZSxibGVuZE1vZGU6Ik11bHRpcGx5IixmaWxsQWxwaGE6YSxwb2ludHNDYWxsYmFjazooZSx0KT0+e2UucHVzaChgJHt0WzBdLnh9ICR7dFswXS55fSBtYCxgJHt0WzFdLnh9ICR7dFsxXS55fSBsYCxgJHt0WzNdLnh9ICR7dFszXS55fSBsYCxgJHt0WzJdLnh9ICR7dFsyXS55fSBsYCwiZiIpO3JldHVyblt0WzBdLngsdFsxXS54LHRbM10ueSx0WzFdLnldfX0pfX1lbHNlIHRoaXMuZGF0YS5wb3B1cFJlZj1udWxsfXN0YXRpYyBjcmVhdGVOZXdEaWN0KGUsdCx7YXBSZWY6aSxhcDphfSl7Y29uc3R7Y29sb3I6cyxvcGFjaXR5OnIscmVjdDpuLHJvdGF0aW9uOm8sdXNlcjpnLHF1YWRQb2ludHM6Y309ZSxDPW5ldyBEaWN0KHQpO0Muc2V0KCJUeXBlIixOYW1lLmdldCgiQW5ub3QiKSk7Qy5zZXQoIlN1YnR5cGUiLE5hbWUuZ2V0KCJIaWdobGlnaHQiKSk7Qy5zZXQoIkNyZWF0aW9uRGF0ZSIsYEQ6JHtnZXRNb2RpZmljYXRpb25EYXRlKCl9YCk7Qy5zZXQoIlJlY3QiLG4pO0Muc2V0KCJGIiw0KTtDLnNldCgiQm9yZGVyIixbMCwwLDBdKTtDLnNldCgiUm90YXRlIixvKTtDLnNldCgiUXVhZFBvaW50cyIsYyk7Qy5zZXQoIkMiLEFycmF5LmZyb20ocywoZT0+ZS8yNTUpKSk7Qy5zZXQoIkNBIixyKTtnJiZDLnNldCgiVCIsaXNBc2NpaShnKT9nOnN0cmluZ1RvVVRGMTZTdHJpbmcoZywhMCkpO2lmKGl8fGEpe2NvbnN0IGU9bmV3IERpY3QodCk7Qy5zZXQoIkFQIixlKTtlLnNldCgiTiIsaXx8YSl9cmV0dXJuIEN9c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0oZSx0LGkpe2NvbnN0e2NvbG9yOmEscmVjdDpzLG91dGxpbmVzOnIsb3BhY2l0eTpufT1lLG89W2Ake2dldFBkZkNvbG9yKGEsITApfWAsIi9SMCBncyJdLGc9W107Zm9yKGNvbnN0IGUgb2Ygcil7Zy5sZW5ndGg9MDtnLnB1c2goYCR7bnVtYmVyVG9TdHJpbmcoZVswXSl9ICR7bnVtYmVyVG9TdHJpbmcoZVsxXSl9IG1gKTtmb3IobGV0IHQ9MixpPWUubGVuZ3RoO3Q8aTt0Kz0yKWcucHVzaChgJHtudW1iZXJUb1N0cmluZyhlW3RdKX0gJHtudW1iZXJUb1N0cmluZyhlW3QrMV0pfSBsYCk7Zy5wdXNoKCJoIik7by5wdXNoKGcuam9pbigiXG4iKSl9by5wdXNoKCJmKiIpO2NvbnN0IGM9by5qb2luKCJcbiIpLEM9bmV3IERpY3QodCk7Qy5zZXQoIkZvcm1UeXBlIiwxKTtDLnNldCgiU3VidHlwZSIsTmFtZS5nZXQoIkZvcm0iKSk7Qy5zZXQoIlR5cGUiLE5hbWUuZ2V0KCJYT2JqZWN0IikpO0Muc2V0KCJCQm94IixzKTtDLnNldCgiTGVuZ3RoIixjLmxlbmd0aCk7Y29uc3QgaD1uZXcgRGljdCh0KSxsPW5ldyBEaWN0KHQpO2guc2V0KCJFeHRHU3RhdGUiLGwpO0Muc2V0KCJSZXNvdXJjZXMiLGgpO2NvbnN0IFE9bmV3IERpY3QodCk7bC5zZXQoIlIwIixRKTtRLnNldCgiQk0iLE5hbWUuZ2V0KCJNdWx0aXBseSIpKTtpZigxIT09bil7US5zZXQoImNhIixuKTtRLnNldCgiVHlwZSIsTmFtZS5nZXQoIkV4dEdTdGF0ZSIpKX1jb25zdCBFPW5ldyBTdHJpbmdTdHJlYW0oYyk7RS5kaWN0PUM7cmV0dXJuIEV9fWNsYXNzIFVuZGVybGluZUFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dCx4cmVmOml9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPUg7aWYodGhpcy5kYXRhLnF1YWRQb2ludHM9Z2V0UXVhZFBvaW50cyh0LG51bGwpKXtpZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCBlPXRoaXMuY29sb3I/Z2V0UGRmQ29sb3JBcnJheSh0aGlzLmNvbG9yKTpbMCwwLDBdLGE9dC5nZXQoIkNBIik7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6aSxleHRyYToiW10gMCBkIDAuNTcxIHciLHN0cm9rZUNvbG9yOmUsc3Ryb2tlQWxwaGE6YSxwb2ludHNDYWxsYmFjazooZSx0KT0+e2UucHVzaChgJHt0WzJdLnh9ICR7dFsyXS55KzEuM30gbWAsYCR7dFszXS54fSAke3RbM10ueSsxLjN9IGxgLCJTIik7cmV0dXJuW3RbMF0ueCx0WzFdLngsdFszXS55LHRbMV0ueV19fSl9fWVsc2UgdGhpcy5kYXRhLnBvcHVwUmVmPW51bGx9fWNsYXNzIFNxdWlnZ2x5QW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LHhyZWY6aX09ZTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9SjtpZih0aGlzLmRhdGEucXVhZFBvaW50cz1nZXRRdWFkUG9pbnRzKHQsbnVsbCkpe2lmKCF0aGlzLmFwcGVhcmFuY2Upe2NvbnN0IGU9dGhpcy5jb2xvcj9nZXRQZGZDb2xvckFycmF5KHRoaXMuY29sb3IpOlswLDAsMF0sYT10LmdldCgiQ0EiKTt0aGlzLl9zZXREZWZhdWx0QXBwZWFyYW5jZSh7eHJlZjppLGV4dHJhOiJbXSAwIGQgMSB3IixzdHJva2VDb2xvcjplLHN0cm9rZUFscGhhOmEscG9pbnRzQ2FsbGJhY2s6KGUsdCk9Pntjb25zdCBpPSh0WzBdLnktdFsyXS55KS82O2xldCBhPWkscz10WzJdLng7Y29uc3Qgcj10WzJdLnksbj10WzNdLng7ZS5wdXNoKGAke3N9ICR7cithfSBtYCk7ZG97cys9MjthPTA9PT1hP2k6MDtlLnB1c2goYCR7c30gJHtyK2F9IGxgKX13aGlsZShzPG4pO2UucHVzaCgiUyIpO3JldHVyblt0WzJdLngsbixyLTIqaSxyKzIqaV19fSl9fWVsc2UgdGhpcy5kYXRhLnBvcHVwUmVmPW51bGx9fWNsYXNzIFN0cmlrZU91dEFubm90YXRpb24gZXh0ZW5kcyBNYXJrdXBBbm5vdGF0aW9ue2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO2NvbnN0e2RpY3Q6dCx4cmVmOml9PWU7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPVk7aWYodGhpcy5kYXRhLnF1YWRQb2ludHM9Z2V0UXVhZFBvaW50cyh0LG51bGwpKXtpZighdGhpcy5hcHBlYXJhbmNlKXtjb25zdCBlPXRoaXMuY29sb3I/Z2V0UGRmQ29sb3JBcnJheSh0aGlzLmNvbG9yKTpbMCwwLDBdLGE9dC5nZXQoIkNBIik7dGhpcy5fc2V0RGVmYXVsdEFwcGVhcmFuY2Uoe3hyZWY6aSxleHRyYToiW10gMCBkIDEgdyIsc3Ryb2tlQ29sb3I6ZSxzdHJva2VBbHBoYTphLHBvaW50c0NhbGxiYWNrOihlLHQpPT57ZS5wdXNoKCh0WzBdLngrdFsyXS54KS8yKyIgIisodFswXS55K3RbMl0ueSkvMisiIG0iLCh0WzFdLngrdFszXS54KS8yKyIgIisodFsxXS55K3RbM10ueSkvMisiIGwiLCJTIik7cmV0dXJuW3RbMF0ueCx0WzFdLngsdFszXS55LHRbMV0ueV19fSl9fWVsc2UgdGhpcy5kYXRhLnBvcHVwUmVmPW51bGx9fWNsYXNzIFN0YW1wQW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5kYXRhLmFubm90YXRpb25UeXBlPXY7dGhpcy5kYXRhLmhhc093bkNhbnZhcz10aGlzLmRhdGEubm9Sb3RhdGU7dGhpcy5kYXRhLm5vSFRNTD0hMX1zdGF0aWMgYXN5bmMgY3JlYXRlSW1hZ2UoZSx0KXtjb25zdHt3aWR0aDppLGhlaWdodDphfT1lLHM9bmV3IE9mZnNjcmVlbkNhbnZhcyhpLGEpLHI9cy5nZXRDb250ZXh0KCIyZCIse2FscGhhOiEwfSk7ci5kcmF3SW1hZ2UoZSwwLDApO2NvbnN0IG49ci5nZXRJbWFnZURhdGEoMCwwLGksYSkuZGF0YSxvPW5ldyBVaW50MzJBcnJheShuLmJ1ZmZlciksZz1vLnNvbWUoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4/ZT0+ZT4+PjI0IT0yNTU6ZT0+MjU1IT0oMjU1JmUpKTtpZihnKXtyLmZpbGxTdHlsZT0id2hpdGUiO3IuZmlsbFJlY3QoMCwwLGksYSk7ci5kcmF3SW1hZ2UoZSwwLDApfWNvbnN0IGM9cy5jb252ZXJ0VG9CbG9iKHt0eXBlOiJpbWFnZS9qcGVnIixxdWFsaXR5OjF9KS50aGVuKChlPT5lLmFycmF5QnVmZmVyKCkpKSxDPU5hbWUuZ2V0KCJYT2JqZWN0IiksaD1OYW1lLmdldCgiSW1hZ2UiKSxsPW5ldyBEaWN0KHQpO2wuc2V0KCJUeXBlIixDKTtsLnNldCgiU3VidHlwZSIsaCk7bC5zZXQoIkJpdHNQZXJDb21wb25lbnQiLDgpO2wuc2V0KCJDb2xvclNwYWNlIixOYW1lLmdldCgiRGV2aWNlUkdCIikpO2wuc2V0KCJGaWx0ZXIiLE5hbWUuZ2V0KCJEQ1REZWNvZGUiKSk7bC5zZXQoIkJCb3giLFswLDAsaSxhXSk7bC5zZXQoIldpZHRoIixpKTtsLnNldCgiSGVpZ2h0IixhKTtsZXQgUT1udWxsO2lmKGcpe2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkoby5sZW5ndGgpO2lmKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKWZvcihsZXQgdD0wLGk9by5sZW5ndGg7dDxpO3QrKyllW3RdPW9bdF0+Pj4yNDtlbHNlIGZvcihsZXQgdD0wLGk9by5sZW5ndGg7dDxpO3QrKyllW3RdPTI1NSZvW3RdO2NvbnN0IHM9bmV3IERpY3QodCk7cy5zZXQoIlR5cGUiLEMpO3Muc2V0KCJTdWJ0eXBlIixoKTtzLnNldCgiQml0c1BlckNvbXBvbmVudCIsOCk7cy5zZXQoIkNvbG9yU3BhY2UiLE5hbWUuZ2V0KCJEZXZpY2VHcmF5IikpO3Muc2V0KCJXaWR0aCIsaSk7cy5zZXQoIkhlaWdodCIsYSk7UT1uZXcgU3RyZWFtKGUsMCwwLHMpfXJldHVybntpbWFnZVN0cmVhbTpuZXcgU3RyZWFtKGF3YWl0IGMsMCwwLGwpLHNtYXNrU3RyZWFtOlEsd2lkdGg6aSxoZWlnaHQ6YX19c3RhdGljIGNyZWF0ZU5ld0RpY3QoZSx0LHthcFJlZjppLGFwOmF9KXtjb25zdHtyZWN0OnMscm90YXRpb246cix1c2VyOm59PWUsbz1uZXcgRGljdCh0KTtvLnNldCgiVHlwZSIsTmFtZS5nZXQoIkFubm90IikpO28uc2V0KCJTdWJ0eXBlIixOYW1lLmdldCgiU3RhbXAiKSk7by5zZXQoIkNyZWF0aW9uRGF0ZSIsYEQ6JHtnZXRNb2RpZmljYXRpb25EYXRlKCl9YCk7by5zZXQoIlJlY3QiLHMpO28uc2V0KCJGIiw0KTtvLnNldCgiQm9yZGVyIixbMCwwLDBdKTtvLnNldCgiUm90YXRlIixyKTtuJiZvLnNldCgiVCIsaXNBc2NpaShuKT9uOnN0cmluZ1RvVVRGMTZTdHJpbmcobiwhMCkpO2lmKGl8fGEpe2NvbnN0IGU9bmV3IERpY3QodCk7by5zZXQoIkFQIixlKTtpP2Uuc2V0KCJOIixpKTplLnNldCgiTiIsYSl9cmV0dXJuIG99c3RhdGljIGFzeW5jIGNyZWF0ZU5ld0FwcGVhcmFuY2VTdHJlYW0oZSx0LGkpe2NvbnN0e3JvdGF0aW9uOmF9PWUse2ltYWdlUmVmOnMsd2lkdGg6cixoZWlnaHQ6bn09aS5pbWFnZSxvPW5ldyBEaWN0KHQpLGc9bmV3IERpY3QodCk7by5zZXQoIlhPYmplY3QiLGcpO2cuc2V0KCJJbTAiLHMpO2NvbnN0IGM9YHEgJHtyfSAwIDAgJHtufSAwIDAgY20gL0ltMCBEbyBRYCxDPW5ldyBEaWN0KHQpO0Muc2V0KCJGb3JtVHlwZSIsMSk7Qy5zZXQoIlN1YnR5cGUiLE5hbWUuZ2V0KCJGb3JtIikpO0Muc2V0KCJUeXBlIixOYW1lLmdldCgiWE9iamVjdCIpKTtDLnNldCgiQkJveCIsWzAsMCxyLG5dKTtDLnNldCgiUmVzb3VyY2VzIixvKTtpZihhKXtjb25zdCBlPWdldFJvdGF0aW9uTWF0cml4KGEscixuKTtDLnNldCgiTWF0cml4IixlKX1jb25zdCBoPW5ldyBTdHJpbmdTdHJlYW0oYyk7aC5kaWN0PUM7cmV0dXJuIGh9fWNsYXNzIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbiBleHRlbmRzIE1hcmt1cEFubm90YXRpb257Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3R7ZGljdDp0LHhyZWY6aX09ZSxhPW5ldyBGaWxlU3BlYyh0LmdldCgiRlMiKSxpKTt0aGlzLmRhdGEuYW5ub3RhdGlvblR5cGU9Tzt0aGlzLmRhdGEuaGFzT3duQ2FudmFzPXRoaXMuZGF0YS5ub1JvdGF0ZTt0aGlzLmRhdGEubm9IVE1MPSExO3RoaXMuZGF0YS5maWxlPWEuc2VyaWFsaXphYmxlO2NvbnN0IHM9dC5nZXQoIk5hbWUiKTt0aGlzLmRhdGEubmFtZT1zIGluc3RhbmNlb2YgTmFtZT9zdHJpbmdUb1BERlN0cmluZyhzLm5hbWUpOiJQdXNoUGluIjtjb25zdCByPXQuZ2V0KCJjYSIpO3RoaXMuZGF0YS5maWxsQWxwaGE9Im51bWJlciI9PXR5cGVvZiByJiZyPj0wJiZyPD0xP3I6bnVsbH19ZnVuY3Rpb24gZGVjb2RlU3RyaW5nKGUpe3RyeXtyZXR1cm4gc3RyaW5nVG9VVEY4U3RyaW5nKGUpfWNhdGNoKHQpe3dhcm4oYFVURi04IGRlY29kaW5nIGZhaWxlZDogIiR7dH0iLmApO3JldHVybiBlfX1jbGFzcyBEYXRhc2V0WE1MUGFyc2VyIGV4dGVuZHMgU2ltcGxlWE1MUGFyc2Vye2NvbnN0cnVjdG9yKGUpe3N1cGVyKGUpO3RoaXMubm9kZT1udWxsfW9uRW5kRWxlbWVudChlKXtjb25zdCB0PXN1cGVyLm9uRW5kRWxlbWVudChlKTtpZih0JiYieGZhOmRhdGFzZXRzIj09PWUpe3RoaXMubm9kZT10O3Rocm93IG5ldyBFcnJvcigiQWJvcnRpbmcgRGF0YXNldFhNTFBhcnNlci4iKX19fWNsYXNzIERhdGFzZXRSZWFkZXJ7Y29uc3RydWN0b3IoZSl7aWYoZS5kYXRhc2V0cyl0aGlzLm5vZGU9bmV3IFNpbXBsZVhNTFBhcnNlcih7aGFzQXR0cmlidXRlczohMH0pLnBhcnNlRnJvbVN0cmluZyhlLmRhdGFzZXRzKS5kb2N1bWVudEVsZW1lbnQ7ZWxzZXtjb25zdCB0PW5ldyBEYXRhc2V0WE1MUGFyc2VyKHtoYXNBdHRyaWJ1dGVzOiEwfSk7dHJ5e3QucGFyc2VGcm9tU3RyaW5nKGVbInhkcDp4ZHAiXSl9Y2F0Y2h7fXRoaXMubm9kZT10Lm5vZGV9fWdldFZhbHVlKGUpe2lmKCF0aGlzLm5vZGV8fCFlKXJldHVybiIiO2NvbnN0IHQ9dGhpcy5ub2RlLnNlYXJjaE5vZGUocGFyc2VYRkFQYXRoKGUpLDApO2lmKCF0KXJldHVybiIiO2NvbnN0IGk9dC5maXJzdENoaWxkO3JldHVybiJ2YWx1ZSI9PT1pPy5ub2RlTmFtZT90LmNoaWxkcmVuLm1hcCgoZT0+ZGVjb2RlU3RyaW5nKGUudGV4dENvbnRlbnQpKSk6ZGVjb2RlU3RyaW5nKHQudGV4dENvbnRlbnQpfX1jbGFzcyBYUmVmeyNIPW51bGw7Y29uc3RydWN0b3IoZSx0KXt0aGlzLnN0cmVhbT1lO3RoaXMucGRmTWFuYWdlcj10O3RoaXMuZW50cmllcz1bXTt0aGlzLl94cmVmU3Rtcz1uZXcgU2V0O3RoaXMuX2NhY2hlTWFwPW5ldyBNYXA7dGhpcy5fcGVuZGluZ1JlZnM9bmV3IFJlZlNldDt0aGlzLl9uZXdQZXJzaXN0ZW50UmVmTnVtPW51bGw7dGhpcy5fbmV3VGVtcG9yYXJ5UmVmTnVtPW51bGw7dGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZT1udWxsfWdldE5ld1BlcnNpc3RlbnRSZWYoZSl7bnVsbD09PXRoaXMuX25ld1BlcnNpc3RlbnRSZWZOdW0mJih0aGlzLl9uZXdQZXJzaXN0ZW50UmVmTnVtPXRoaXMuZW50cmllcy5sZW5ndGh8fDEpO2NvbnN0IHQ9dGhpcy5fbmV3UGVyc2lzdGVudFJlZk51bSsrO3RoaXMuX2NhY2hlTWFwLnNldCh0LGUpO3JldHVybiBSZWYuZ2V0KHQsMCl9Z2V0TmV3VGVtcG9yYXJ5UmVmKCl7aWYobnVsbD09PXRoaXMuX25ld1RlbXBvcmFyeVJlZk51bSl7dGhpcy5fbmV3VGVtcG9yYXJ5UmVmTnVtPXRoaXMuZW50cmllcy5sZW5ndGh8fDE7aWYodGhpcy5fbmV3UGVyc2lzdGVudFJlZk51bSl7dGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZT1uZXcgTWFwO2ZvcihsZXQgZT10aGlzLl9uZXdUZW1wb3JhcnlSZWZOdW07ZTx0aGlzLl9uZXdQZXJzaXN0ZW50UmVmTnVtO2UrKyl7dGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZS5zZXQoZSx0aGlzLl9jYWNoZU1hcC5nZXQoZSkpO3RoaXMuX2NhY2hlTWFwLmRlbGV0ZShlKX19fXJldHVybiBSZWYuZ2V0KHRoaXMuX25ld1RlbXBvcmFyeVJlZk51bSsrLDApfXJlc2V0TmV3VGVtcG9yYXJ5UmVmKCl7dGhpcy5fbmV3VGVtcG9yYXJ5UmVmTnVtPW51bGw7aWYodGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZSlmb3IoY29uc3RbZSx0XW9mIHRoaXMuX3BlcnNpc3RlbnRSZWZzQ2FjaGUpdGhpcy5fY2FjaGVNYXAuc2V0KGUsdCk7dGhpcy5fcGVyc2lzdGVudFJlZnNDYWNoZT1udWxsfXNldFN0YXJ0WFJlZihlKXt0aGlzLnN0YXJ0WFJlZlF1ZXVlPVtlXX1wYXJzZShlPSExKXtsZXQgdCxpLGE7aWYoZSl7d2FybigiSW5kZXhpbmcgYWxsIFBERiBvYmplY3RzIik7dD10aGlzLmluZGV4T2JqZWN0cygpfWVsc2UgdD10aGlzLnJlYWRYUmVmKCk7dC5hc3NpZ25YcmVmKHRoaXMpO3RoaXMudHJhaWxlcj10O3RyeXtpPXQuZ2V0KCJFbmNyeXB0Iil9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybihgWFJlZi5wYXJzZSAtIEludmFsaWQgIkVuY3J5cHQiIHJlZmVyZW5jZTogIiR7ZX0iLmApfWlmKGkgaW5zdGFuY2VvZiBEaWN0KXtjb25zdCBlPXQuZ2V0KCJJRCIpLGE9ZT8ubGVuZ3RoP2VbMF06IiI7aS5zdXBwcmVzc0VuY3J5cHRpb249ITA7dGhpcy5lbmNyeXB0PW5ldyBDaXBoZXJUcmFuc2Zvcm1GYWN0b3J5KGksYSx0aGlzLnBkZk1hbmFnZXIucGFzc3dvcmQpfXRyeXthPXQuZ2V0KCJSb290Iil9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybihgWFJlZi5wYXJzZSAtIEludmFsaWQgIlJvb3QiIHJlZmVyZW5jZTogIiR7ZX0iLmApfWlmKGEgaW5zdGFuY2VvZiBEaWN0KXRyeXtpZihhLmdldCgiUGFnZXMiKWluc3RhbmNlb2YgRGljdCl7dGhpcy5yb290PWE7cmV0dXJufX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTt3YXJuKGBYUmVmLnBhcnNlIC0gSW52YWxpZCAiUGFnZXMiIHJlZmVyZW5jZTogIiR7ZX0iLmApfWlmKCFlKXRocm93IG5ldyBYUmVmUGFyc2VFeGNlcHRpb247dGhyb3cgbmV3IEludmFsaWRQREZFeGNlcHRpb24oIkludmFsaWQgUm9vdCByZWZlcmVuY2UuIil9cHJvY2Vzc1hSZWZUYWJsZShlKXsidGFibGVTdGF0ZSJpbiB0aGlzfHwodGhpcy50YWJsZVN0YXRlPXtlbnRyeU51bTowLHN0cmVhbVBvczplLmxleGVyLnN0cmVhbS5wb3MscGFyc2VyQnVmMTplLmJ1ZjEscGFyc2VyQnVmMjplLmJ1ZjJ9KTtpZighaXNDbWQodGhpcy5yZWFkWFJlZlRhYmxlKGUpLCJ0cmFpbGVyIikpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgdGFibGU6IGNvdWxkIG5vdCBmaW5kIHRyYWlsZXIgZGljdGlvbmFyeSIpO2xldCB0PWUuZ2V0T2JqKCk7dCBpbnN0YW5jZW9mIERpY3R8fCF0LmRpY3R8fCh0PXQuZGljdCk7aWYoISh0IGluc3RhbmNlb2YgRGljdCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgdGFibGU6IGNvdWxkIG5vdCBwYXJzZSB0cmFpbGVyIGRpY3Rpb25hcnkiKTtkZWxldGUgdGhpcy50YWJsZVN0YXRlO3JldHVybiB0fXJlYWRYUmVmVGFibGUoZSl7Y29uc3QgdD1lLmxleGVyLnN0cmVhbSxpPXRoaXMudGFibGVTdGF0ZTt0LnBvcz1pLnN0cmVhbVBvcztlLmJ1ZjE9aS5wYXJzZXJCdWYxO2UuYnVmMj1pLnBhcnNlckJ1ZjI7bGV0IGE7Zm9yKDs7KXtpZighKCJmaXJzdEVudHJ5TnVtImluIGkpfHwhKCJlbnRyeUNvdW50ImluIGkpKXtpZihpc0NtZChhPWUuZ2V0T2JqKCksInRyYWlsZXIiKSlicmVhaztpLmZpcnN0RW50cnlOdW09YTtpLmVudHJ5Q291bnQ9ZS5nZXRPYmooKX1sZXQgcz1pLmZpcnN0RW50cnlOdW07Y29uc3Qgcj1pLmVudHJ5Q291bnQ7aWYoIU51bWJlci5pc0ludGVnZXIocyl8fCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIHRhYmxlOiB3cm9uZyB0eXBlcyBpbiBzdWJzZWN0aW9uIGhlYWRlciIpO2ZvcihsZXQgYT1pLmVudHJ5TnVtO2E8cjthKyspe2kuc3RyZWFtUG9zPXQucG9zO2kuZW50cnlOdW09YTtpLnBhcnNlckJ1ZjE9ZS5idWYxO2kucGFyc2VyQnVmMj1lLmJ1ZjI7Y29uc3Qgbj17fTtuLm9mZnNldD1lLmdldE9iaigpO24uZ2VuPWUuZ2V0T2JqKCk7Y29uc3Qgbz1lLmdldE9iaigpO2lmKG8gaW5zdGFuY2VvZiBDbWQpc3dpdGNoKG8uY21kKXtjYXNlImYiOm4uZnJlZT0hMDticmVhaztjYXNlIm4iOm4udW5jb21wcmVzc2VkPSEwfWlmKCFOdW1iZXIuaXNJbnRlZ2VyKG4ub2Zmc2V0KXx8IU51bWJlci5pc0ludGVnZXIobi5nZW4pfHwhbi5mcmVlJiYhbi51bmNvbXByZXNzZWQpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIGVudHJ5IGluIFhSZWYgc3Vic2VjdGlvbjogJHtzfSwgJHtyfWApOzA9PT1hJiZuLmZyZWUmJjE9PT1zJiYocz0wKTt0aGlzLmVudHJpZXNbYStzXXx8KHRoaXMuZW50cmllc1thK3NdPW4pfWkuZW50cnlOdW09MDtpLnN0cmVhbVBvcz10LnBvcztpLnBhcnNlckJ1ZjE9ZS5idWYxO2kucGFyc2VyQnVmMj1lLmJ1ZjI7ZGVsZXRlIGkuZmlyc3RFbnRyeU51bTtkZWxldGUgaS5lbnRyeUNvdW50fWlmKHRoaXMuZW50cmllc1swXSYmIXRoaXMuZW50cmllc1swXS5mcmVlKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIHRhYmxlOiB1bmV4cGVjdGVkIGZpcnN0IG9iamVjdCIpO3JldHVybiBhfXByb2Nlc3NYUmVmU3RyZWFtKGUpe2lmKCEoInN0cmVhbVN0YXRlImluIHRoaXMpKXtjb25zdCB0PWUuZGljdCxpPXQuZ2V0KCJXIik7bGV0IGE9dC5nZXQoIkluZGV4Iik7YXx8KGE9WzAsdC5nZXQoIlNpemUiKV0pO3RoaXMuc3RyZWFtU3RhdGU9e2VudHJ5UmFuZ2VzOmEsYnl0ZVdpZHRoczppLGVudHJ5TnVtOjAsc3RyZWFtUG9zOmUucG9zfX10aGlzLnJlYWRYUmVmU3RyZWFtKGUpO2RlbGV0ZSB0aGlzLnN0cmVhbVN0YXRlO3JldHVybiBlLmRpY3R9cmVhZFhSZWZTdHJlYW0oZSl7Y29uc3QgdD10aGlzLnN0cmVhbVN0YXRlO2UucG9zPXQuc3RyZWFtUG9zO2NvbnN0W2ksYSxzXT10LmJ5dGVXaWR0aHMscj10LmVudHJ5UmFuZ2VzO2Zvcig7ci5sZW5ndGg+MDspe2NvbnN0W24sb109cjtpZighTnVtYmVyLmlzSW50ZWdlcihuKXx8IU51bWJlci5pc0ludGVnZXIobykpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIFhSZWYgcmFuZ2UgZmllbGRzOiAke259LCAke299YCk7aWYoIU51bWJlci5pc0ludGVnZXIoaSl8fCFOdW1iZXIuaXNJbnRlZ2VyKGEpfHwhTnVtYmVyLmlzSW50ZWdlcihzKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoYEludmFsaWQgWFJlZiBlbnRyeSBmaWVsZHMgbGVuZ3RoOiAke259LCAke299YCk7Zm9yKGxldCByPXQuZW50cnlOdW07cjxvOysrcil7dC5lbnRyeU51bT1yO3Quc3RyZWFtUG9zPWUucG9zO2xldCBvPTAsZz0wLGM9MDtmb3IobGV0IHQ9MDt0PGk7Kyt0KXtjb25zdCB0PWUuZ2V0Qnl0ZSgpO2lmKC0xPT09dCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgWFJlZiBieXRlV2lkdGhzICd0eXBlJy4iKTtvPW88PDh8dH0wPT09aSYmKG89MSk7Zm9yKGxldCB0PTA7dDxhOysrdCl7Y29uc3QgdD1lLmdldEJ5dGUoKTtpZigtMT09PXQpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgYnl0ZVdpZHRocyAnb2Zmc2V0Jy4iKTtnPWc8PDh8dH1mb3IobGV0IHQ9MDt0PHM7Kyt0KXtjb25zdCB0PWUuZ2V0Qnl0ZSgpO2lmKC0xPT09dCl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkludmFsaWQgWFJlZiBieXRlV2lkdGhzICdnZW5lcmF0aW9uJy4iKTtjPWM8PDh8dH1jb25zdCBDPXt9O0Mub2Zmc2V0PWc7Qy5nZW49Yztzd2l0Y2gobyl7Y2FzZSAwOkMuZnJlZT0hMDticmVhaztjYXNlIDE6Qy51bmNvbXByZXNzZWQ9ITA7YnJlYWs7Y2FzZSAyOmJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEZvcm1hdEVycm9yKGBJbnZhbGlkIFhSZWYgZW50cnkgdHlwZTogJHtvfWApfXRoaXMuZW50cmllc1tuK3JdfHwodGhpcy5lbnRyaWVzW24rcl09Qyl9dC5lbnRyeU51bT0wO3Quc3RyZWFtUG9zPWUucG9zO3Iuc3BsaWNlKDAsMil9fWluZGV4T2JqZWN0cygpe2Z1bmN0aW9uIHJlYWRUb2tlbihlLHQpe2xldCBpPSIiLGE9ZVt0XTtmb3IoOzEwIT09YSYmMTMhPT1hJiY2MCE9PWEmJiEoKyt0Pj1lLmxlbmd0aCk7KXtpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpO2E9ZVt0XX1yZXR1cm4gaX1mdW5jdGlvbiBza2lwVW50aWwoZSx0LGkpe2NvbnN0IGE9aS5sZW5ndGgscz1lLmxlbmd0aDtsZXQgcj0wO2Zvcig7dDxzOyl7bGV0IHM9MDtmb3IoO3M8YSYmZVt0K3NdPT09aVtzXTspKytzO2lmKHM+PWEpYnJlYWs7dCsrO3IrK31yZXR1cm4gcn1jb25zdCBlPS9cYihlbmRvYmp8XGQrXHMrXGQrXHMrb2JqfHhyZWZ8dHJhaWxlclxzKjw8KVxiL2csdD0vXGIoc3RhcnR4cmVmfFxkK1xzK1xkK1xzK29iailcYi9nLGk9L14oXGQrKVxzKyhcZCspXHMrb2JqXGIvLGE9bmV3IFVpbnQ4QXJyYXkoWzExNiwxMTQsOTcsMTA1LDEwOCwxMDEsMTE0XSkscz1uZXcgVWludDhBcnJheShbMTE1LDExNiw5NywxMTQsMTE2LDEyMCwxMTQsMTAxLDEwMl0pLHI9bmV3IFVpbnQ4QXJyYXkoWzQ3LDg4LDgyLDEwMSwxMDJdKTt0aGlzLmVudHJpZXMubGVuZ3RoPTA7dGhpcy5fY2FjaGVNYXAuY2xlYXIoKTtjb25zdCBuPXRoaXMuc3RyZWFtO24ucG9zPTA7Y29uc3Qgbz1uLmdldEJ5dGVzKCksZz1ieXRlc1RvU3RyaW5nKG8pLGM9by5sZW5ndGg7bGV0IEM9bi5zdGFydDtjb25zdCBoPVtdLGw9W107Zm9yKDtDPGM7KXtsZXQgUT1vW0NdO2lmKDk9PT1RfHwxMD09PVF8fDEzPT09UXx8MzI9PT1RKXsrK0M7Y29udGludWV9aWYoMzc9PT1RKXtkb3srK0M7aWYoQz49YylicmVhaztRPW9bQ119d2hpbGUoMTAhPT1RJiYxMyE9PVEpO2NvbnRpbnVlfWNvbnN0IEU9cmVhZFRva2VuKG8sQyk7bGV0IHU7aWYoRS5zdGFydHNXaXRoKCJ4cmVmIikmJig0PT09RS5sZW5ndGh8fC9ccy8udGVzdChFWzRdKSkpe0MrPXNraXBVbnRpbChvLEMsYSk7aC5wdXNoKEMpO0MrPXNraXBVbnRpbChvLEMscyl9ZWxzZSBpZih1PWkuZXhlYyhFKSl7Y29uc3QgdD0wfHVbMV0saT0wfHVbMl0sYT1DK0UubGVuZ3RoO2xldCBzLGg9ITE7aWYodGhpcy5lbnRyaWVzW3RdKXtpZih0aGlzLmVudHJpZXNbdF0uZ2VuPT09aSl0cnl7bmV3IFBhcnNlcih7bGV4ZXI6bmV3IExleGVyKG4ubWFrZVN1YlN0cmVhbShhKSl9KS5nZXRPYmooKTtoPSEwfWNhdGNoKGUpe2UgaW5zdGFuY2VvZiBQYXJzZXJFT0ZFeGNlcHRpb24/d2FybihgaW5kZXhPYmplY3RzIC0tIGNoZWNraW5nIG9iamVjdCAoJHtFfSk6ICIke2V9Ii5gKTpoPSEwfX1lbHNlIGg9ITA7aCYmKHRoaXMuZW50cmllc1t0XT17b2Zmc2V0OkMtbi5zdGFydCxnZW46aSx1bmNvbXByZXNzZWQ6ITB9KTtlLmxhc3RJbmRleD1hO2NvbnN0IFE9ZS5leGVjKGcpO2lmKFEpe3M9ZS5sYXN0SW5kZXgrMS1DO2lmKCJlbmRvYmoiIT09UVsxXSl7d2FybihgaW5kZXhPYmplY3RzOiBGb3VuZCAiJHtRWzFdfSIgaW5zaWRlIG9mIGFub3RoZXIgIm9iaiIsIGNhdXNlZCBieSBtaXNzaW5nICJlbmRvYmoiIC0tIHRyeWluZyB0byByZWNvdmVyLmApO3MtPVFbMV0ubGVuZ3RoKzF9fWVsc2Ugcz1jLUM7Y29uc3QgZD1vLnN1YmFycmF5KEMsQytzKSxmPXNraXBVbnRpbChkLDAscik7aWYoZjxzJiZkW2YrNV08NjQpe2wucHVzaChDLW4uc3RhcnQpO3RoaXMuX3hyZWZTdG1zLmFkZChDLW4uc3RhcnQpfUMrPXN9ZWxzZSBpZihFLnN0YXJ0c1dpdGgoInRyYWlsZXIiKSYmKDc9PT1FLmxlbmd0aHx8L1xzLy50ZXN0KEVbN10pKSl7aC5wdXNoKEMpO2NvbnN0IGU9QytFLmxlbmd0aDtsZXQgaTt0Lmxhc3RJbmRleD1lO2NvbnN0IGE9dC5leGVjKGcpO2lmKGEpe2k9dC5sYXN0SW5kZXgrMS1DO2lmKCJzdGFydHhyZWYiIT09YVsxXSl7d2FybihgaW5kZXhPYmplY3RzOiBGb3VuZCAiJHthWzFdfSIgYWZ0ZXIgInRyYWlsZXIiLCBjYXVzZWQgYnkgbWlzc2luZyAic3RhcnR4cmVmIiAtLSB0cnlpbmcgdG8gcmVjb3Zlci5gKTtpLT1hWzFdLmxlbmd0aCsxfX1lbHNlIGk9Yy1DO0MrPWl9ZWxzZSBDKz1FLmxlbmd0aCsxfWZvcihjb25zdCBlIG9mIGwpe3RoaXMuc3RhcnRYUmVmUXVldWUucHVzaChlKTt0aGlzLnJlYWRYUmVmKCEwKX1jb25zdCBRPVtdO2xldCBFLHUsZD0hMTtmb3IoY29uc3QgZSBvZiBoKXtuLnBvcz1lO2NvbnN0IHQ9bmV3IFBhcnNlcih7bGV4ZXI6bmV3IExleGVyKG4pLHhyZWY6dGhpcyxhbGxvd1N0cmVhbXM6ITAscmVjb3ZlcnlNb2RlOiEwfSk7aWYoIWlzQ21kKHQuZ2V0T2JqKCksInRyYWlsZXIiKSljb250aW51ZTtjb25zdCBpPXQuZ2V0T2JqKCk7aWYoaSBpbnN0YW5jZW9mIERpY3Qpe1EucHVzaChpKTtpLmhhcygiRW5jcnlwdCIpJiYoZD0hMCl9fWZvcihjb25zdCBlIG9mWy4uLlEsImdlbkZhbGxiYWNrIiwuLi5RXSl7aWYoImdlbkZhbGxiYWNrIj09PWUpe2lmKCF1KWJyZWFrO3RoaXMuX2dlbmVyYXRpb25GYWxsYmFjaz0hMDtjb250aW51ZX1sZXQgdD0hMTt0cnl7Y29uc3QgaT1lLmdldCgiUm9vdCIpO2lmKCEoaSBpbnN0YW5jZW9mIERpY3QpKWNvbnRpbnVlO2NvbnN0IGE9aS5nZXQoIlBhZ2VzIik7aWYoIShhIGluc3RhbmNlb2YgRGljdCkpY29udGludWU7Y29uc3Qgcz1hLmdldCgiQ291bnQiKTtOdW1iZXIuaXNJbnRlZ2VyKHMpJiYodD0hMCl9Y2F0Y2goZSl7dT1lO2NvbnRpbnVlfWlmKHQmJighZHx8ZS5oYXMoIkVuY3J5cHQiKSkmJmUuaGFzKCJJRCIpKXJldHVybiBlO0U9ZX1pZihFKXJldHVybiBFO2lmKHRoaXMudG9wRGljdClyZXR1cm4gdGhpcy50b3BEaWN0O3Rocm93IG5ldyBJbnZhbGlkUERGRXhjZXB0aW9uKCJJbnZhbGlkIFBERiBzdHJ1Y3R1cmUuIil9cmVhZFhSZWYoZT0hMSl7Y29uc3QgdD10aGlzLnN0cmVhbSxpPW5ldyBTZXQ7Zm9yKDt0aGlzLnN0YXJ0WFJlZlF1ZXVlLmxlbmd0aDspe3RyeXtjb25zdCBlPXRoaXMuc3RhcnRYUmVmUXVldWVbMF07aWYoaS5oYXMoZSkpe3dhcm4oInJlYWRYUmVmIC0gc2tpcHBpbmcgWFJlZiB0YWJsZSBzaW5jZSBpdCB3YXMgYWxyZWFkeSBwYXJzZWQuIik7dGhpcy5zdGFydFhSZWZRdWV1ZS5zaGlmdCgpO2NvbnRpbnVlfWkuYWRkKGUpO3QucG9zPWUrdC5zdGFydDtjb25zdCBhPW5ldyBQYXJzZXIoe2xleGVyOm5ldyBMZXhlcih0KSx4cmVmOnRoaXMsYWxsb3dTdHJlYW1zOiEwfSk7bGV0IHMscj1hLmdldE9iaigpO2lmKGlzQ21kKHIsInhyZWYiKSl7cz10aGlzLnByb2Nlc3NYUmVmVGFibGUoYSk7dGhpcy50b3BEaWN0fHwodGhpcy50b3BEaWN0PXMpO3I9cy5nZXQoIlhSZWZTdG0iKTtpZihOdW1iZXIuaXNJbnRlZ2VyKHIpJiYhdGhpcy5feHJlZlN0bXMuaGFzKHIpKXt0aGlzLl94cmVmU3Rtcy5hZGQocik7dGhpcy5zdGFydFhSZWZRdWV1ZS5wdXNoKHIpO3RoaXMuI0g/Pz1yfX1lbHNle2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBYUmVmIHN0cmVhbSBoZWFkZXIiKTtpZighKE51bWJlci5pc0ludGVnZXIoYS5nZXRPYmooKSkmJmlzQ21kKGEuZ2V0T2JqKCksIm9iaiIpJiYocj1hLmdldE9iaigpKWluc3RhbmNlb2YgQmFzZVN0cmVhbSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKCJJbnZhbGlkIFhSZWYgc3RyZWFtIik7cz10aGlzLnByb2Nlc3NYUmVmU3RyZWFtKHIpO3RoaXMudG9wRGljdHx8KHRoaXMudG9wRGljdD1zKTtpZighcyl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIkZhaWxlZCB0byByZWFkIFhSZWYgc3RyZWFtIil9cj1zLmdldCgiUHJldiIpO051bWJlci5pc0ludGVnZXIocik/dGhpcy5zdGFydFhSZWZRdWV1ZS5wdXNoKHIpOnIgaW5zdGFuY2VvZiBSZWYmJnRoaXMuc3RhcnRYUmVmUXVldWUucHVzaChyLm51bSl9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7aW5mbygiKHdoaWxlIHJlYWRpbmcgWFJlZik6ICIrZSl9dGhpcy5zdGFydFhSZWZRdWV1ZS5zaGlmdCgpfWlmKHRoaXMudG9wRGljdClyZXR1cm4gdGhpcy50b3BEaWN0O2lmKCFlKXRocm93IG5ldyBYUmVmUGFyc2VFeGNlcHRpb259Z2V0IGxhc3RYUmVmU3RyZWFtUG9zKCl7cmV0dXJuIHRoaXMuI0g/Pyh0aGlzLl94cmVmU3Rtcy5zaXplPjA/TWF0aC5tYXgoLi4udGhpcy5feHJlZlN0bXMpOm51bGwpfWdldEVudHJ5KGUpe2NvbnN0IHQ9dGhpcy5lbnRyaWVzW2VdO3JldHVybiB0JiYhdC5mcmVlJiZ0Lm9mZnNldD90Om51bGx9ZmV0Y2hJZlJlZihlLHQ9ITEpe3JldHVybiBlIGluc3RhbmNlb2YgUmVmP3RoaXMuZmV0Y2goZSx0KTplfWZldGNoKGUsdD0hMSl7aWYoIShlIGluc3RhbmNlb2YgUmVmKSl0aHJvdyBuZXcgRXJyb3IoInJlZiBvYmplY3QgaXMgbm90IGEgcmVmZXJlbmNlIik7Y29uc3QgaT1lLm51bSxhPXRoaXMuX2NhY2hlTWFwLmdldChpKTtpZih2b2lkIDAhPT1hKXthIGluc3RhbmNlb2YgRGljdCYmIWEub2JqSWQmJihhLm9iaklkPWUudG9TdHJpbmcoKSk7cmV0dXJuIGF9bGV0IHM9dGhpcy5nZXRFbnRyeShpKTtpZihudWxsPT09cyl7dGhpcy5fY2FjaGVNYXAuc2V0KGkscyk7cmV0dXJuIHN9aWYodGhpcy5fcGVuZGluZ1JlZnMuaGFzKGUpKXt0aGlzLl9wZW5kaW5nUmVmcy5yZW1vdmUoZSk7d2FybihgSWdub3JpbmcgY2lyY3VsYXIgcmVmZXJlbmNlOiAke2V9LmApO3JldHVybiBmdH10aGlzLl9wZW5kaW5nUmVmcy5wdXQoZSk7dHJ5e3M9cy51bmNvbXByZXNzZWQ/dGhpcy5mZXRjaFVuY29tcHJlc3NlZChlLHMsdCk6dGhpcy5mZXRjaENvbXByZXNzZWQoZSxzLHQpO3RoaXMuX3BlbmRpbmdSZWZzLnJlbW92ZShlKX1jYXRjaCh0KXt0aGlzLl9wZW5kaW5nUmVmcy5yZW1vdmUoZSk7dGhyb3cgdH1zIGluc3RhbmNlb2YgRGljdD9zLm9iaklkPWUudG9TdHJpbmcoKTpzIGluc3RhbmNlb2YgQmFzZVN0cmVhbSYmKHMuZGljdC5vYmpJZD1lLnRvU3RyaW5nKCkpO3JldHVybiBzfWZldGNoVW5jb21wcmVzc2VkKGUsdCxpPSExKXtjb25zdCBhPWUuZ2VuO2xldCBzPWUubnVtO2lmKHQuZ2VuIT09YSl7Y29uc3Qgcj1gSW5jb25zaXN0ZW50IGdlbmVyYXRpb24gaW4gWFJlZjogJHtlfWA7aWYodGhpcy5fZ2VuZXJhdGlvbkZhbGxiYWNrJiZ0LmdlbjxhKXt3YXJuKHIpO3JldHVybiB0aGlzLmZldGNoVW5jb21wcmVzc2VkKFJlZi5nZXQocyx0LmdlbiksdCxpKX10aHJvdyBuZXcgWFJlZkVudHJ5RXhjZXB0aW9uKHIpfWNvbnN0IHI9dGhpcy5zdHJlYW0ubWFrZVN1YlN0cmVhbSh0Lm9mZnNldCt0aGlzLnN0cmVhbS5zdGFydCksbj1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIocikseHJlZjp0aGlzLGFsbG93U3RyZWFtczohMH0pLG89bi5nZXRPYmooKSxnPW4uZ2V0T2JqKCksYz1uLmdldE9iaigpO2lmKG8hPT1zfHxnIT09YXx8IShjIGluc3RhbmNlb2YgQ21kKSl0aHJvdyBuZXcgWFJlZkVudHJ5RXhjZXB0aW9uKGBCYWQgKHVuY29tcHJlc3NlZCkgWFJlZiBlbnRyeTogJHtlfWApO2lmKCJvYmoiIT09Yy5jbWQpe2lmKGMuY21kLnN0YXJ0c1dpdGgoIm9iaiIpKXtzPXBhcnNlSW50KGMuY21kLnN1YnN0cmluZygzKSwxMCk7aWYoIU51bWJlci5pc05hTihzKSlyZXR1cm4gc310aHJvdyBuZXcgWFJlZkVudHJ5RXhjZXB0aW9uKGBCYWQgKHVuY29tcHJlc3NlZCkgWFJlZiBlbnRyeTogJHtlfWApfSh0PXRoaXMuZW5jcnlwdCYmIWk/bi5nZXRPYmoodGhpcy5lbmNyeXB0LmNyZWF0ZUNpcGhlclRyYW5zZm9ybShzLGEpKTpuLmdldE9iaigpKWluc3RhbmNlb2YgQmFzZVN0cmVhbXx8dGhpcy5fY2FjaGVNYXAuc2V0KHMsdCk7cmV0dXJuIHR9ZmV0Y2hDb21wcmVzc2VkKGUsdCxpPSExKXtjb25zdCBhPXQub2Zmc2V0LHM9dGhpcy5mZXRjaChSZWYuZ2V0KGEsMCkpO2lmKCEocyBpbnN0YW5jZW9mIEJhc2VTdHJlYW0pKXRocm93IG5ldyBGb3JtYXRFcnJvcigiYmFkIE9ialN0bSBzdHJlYW0iKTtjb25zdCByPXMuZGljdC5nZXQoIkZpcnN0Iiksbj1zLmRpY3QuZ2V0KCJOIik7aWYoIU51bWJlci5pc0ludGVnZXIocil8fCFOdW1iZXIuaXNJbnRlZ2VyKG4pKXRocm93IG5ldyBGb3JtYXRFcnJvcigiaW52YWxpZCBmaXJzdCBhbmQgbiBwYXJhbWV0ZXJzIGZvciBPYmpTdG0gc3RyZWFtIik7bGV0IG89bmV3IFBhcnNlcih7bGV4ZXI6bmV3IExleGVyKHMpLHhyZWY6dGhpcyxhbGxvd1N0cmVhbXM6ITB9KTtjb25zdCBnPW5ldyBBcnJheShuKSxjPW5ldyBBcnJheShuKTtmb3IobGV0IGU9MDtlPG47KytlKXtjb25zdCB0PW8uZ2V0T2JqKCk7aWYoIU51bWJlci5pc0ludGVnZXIodCkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBpbnZhbGlkIG9iamVjdCBudW1iZXIgaW4gdGhlIE9ialN0bSBzdHJlYW06ICR7dH1gKTtjb25zdCBpPW8uZ2V0T2JqKCk7aWYoIU51bWJlci5pc0ludGVnZXIoaSkpdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBpbnZhbGlkIG9iamVjdCBvZmZzZXQgaW4gdGhlIE9ialN0bSBzdHJlYW06ICR7aX1gKTtnW2VdPXQ7Y1tlXT1pfWNvbnN0IEM9KHMuc3RhcnR8fDApK3IsaD1uZXcgQXJyYXkobik7Zm9yKGxldCBlPTA7ZTxuOysrZSl7Y29uc3QgdD1lPG4tMT9jW2UrMV0tY1tlXTp2b2lkIDA7aWYodDwwKXRocm93IG5ldyBGb3JtYXRFcnJvcigiSW52YWxpZCBvZmZzZXQgaW4gdGhlIE9ialN0bSBzdHJlYW0uIik7bz1uZXcgUGFyc2VyKHtsZXhlcjpuZXcgTGV4ZXIocy5tYWtlU3ViU3RyZWFtKEMrY1tlXSx0LHMuZGljdCkpLHhyZWY6dGhpcyxhbGxvd1N0cmVhbXM6ITB9KTtjb25zdCBpPW8uZ2V0T2JqKCk7aFtlXT1pO2lmKGkgaW5zdGFuY2VvZiBCYXNlU3RyZWFtKWNvbnRpbnVlO2NvbnN0IHI9Z1tlXSxsPXRoaXMuZW50cmllc1tyXTtsJiZsLm9mZnNldD09PWEmJmwuZ2VuPT09ZSYmdGhpcy5fY2FjaGVNYXAuc2V0KHIsaSl9aWYodm9pZCAwPT09KHQ9aFt0Lmdlbl0pKXRocm93IG5ldyBYUmVmRW50cnlFeGNlcHRpb24oYEJhZCAoY29tcHJlc3NlZCkgWFJlZiBlbnRyeTogJHtlfWApO3JldHVybiB0fWFzeW5jIGZldGNoSWZSZWZBc3luYyhlLHQpe3JldHVybiBlIGluc3RhbmNlb2YgUmVmP3RoaXMuZmV0Y2hBc3luYyhlLHQpOmV9YXN5bmMgZmV0Y2hBc3luYyhlLHQpe3RyeXtyZXR1cm4gdGhpcy5mZXRjaChlLHQpfWNhdGNoKGkpe2lmKCEoaSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKSl0aHJvdyBpO2F3YWl0IHRoaXMucGRmTWFuYWdlci5yZXF1ZXN0UmFuZ2UoaS5iZWdpbixpLmVuZCk7cmV0dXJuIHRoaXMuZmV0Y2hBc3luYyhlLHQpfX1nZXRDYXRhbG9nT2JqKCl7cmV0dXJuIHRoaXMucm9vdH19Y29uc3Qgc289WzAsMCw2MTIsNzkyXTtjbGFzcyBQYWdle2NvbnN0cnVjdG9yKHtwZGZNYW5hZ2VyOmUseHJlZjp0LHBhZ2VJbmRleDppLHBhZ2VEaWN0OmEscmVmOnMsZ2xvYmFsSWRGYWN0b3J5OnIsZm9udENhY2hlOm4sYnVpbHRJbkNNYXBDYWNoZTpvLHN0YW5kYXJkRm9udERhdGFDYWNoZTpnLGdsb2JhbEltYWdlQ2FjaGU6YyxzeXN0ZW1Gb250Q2FjaGU6Qyxub25CbGVuZE1vZGVzU2V0OmgseGZhRmFjdG9yeTpsfSl7dGhpcy5wZGZNYW5hZ2VyPWU7dGhpcy5wYWdlSW5kZXg9aTt0aGlzLnBhZ2VEaWN0PWE7dGhpcy54cmVmPXQ7dGhpcy5yZWY9czt0aGlzLmZvbnRDYWNoZT1uO3RoaXMuYnVpbHRJbkNNYXBDYWNoZT1vO3RoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlPWc7dGhpcy5nbG9iYWxJbWFnZUNhY2hlPWM7dGhpcy5zeXN0ZW1Gb250Q2FjaGU9Qzt0aGlzLm5vbkJsZW5kTW9kZXNTZXQ9aDt0aGlzLmV2YWx1YXRvck9wdGlvbnM9ZS5ldmFsdWF0b3JPcHRpb25zO3RoaXMucmVzb3VyY2VzUHJvbWlzZT1udWxsO3RoaXMueGZhRmFjdG9yeT1sO2NvbnN0IFE9e29iajowfTt0aGlzLl9sb2NhbElkRmFjdG9yeT1jbGFzcyBleHRlbmRzIHJ7c3RhdGljIGNyZWF0ZU9iaklkKCl7cmV0dXJuYHAke2l9XyR7KytRLm9ian1gfXN0YXRpYyBnZXRQYWdlT2JqSWQoKXtyZXR1cm5gcCR7cy50b1N0cmluZygpfWB9fX1fZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eShlLHQ9ITEpe2NvbnN0IGk9Z2V0SW5oZXJpdGFibGVQcm9wZXJ0eSh7ZGljdDp0aGlzLnBhZ2VEaWN0LGtleTplLGdldEFycmF5OnQsc3RvcFdoZW5Gb3VuZDohMX0pO3JldHVybiBBcnJheS5pc0FycmF5KGkpPzEhPT1pLmxlbmd0aCYmaVswXWluc3RhbmNlb2YgRGljdD9EaWN0Lm1lcmdlKHt4cmVmOnRoaXMueHJlZixkaWN0QXJyYXk6aX0pOmlbMF06aX1nZXQgY29udGVudCgpe3JldHVybiB0aGlzLnBhZ2VEaWN0LmdldEFycmF5KCJDb250ZW50cyIpfWdldCByZXNvdXJjZXMoKXtjb25zdCBlPXRoaXMuX2dldEluaGVyaXRhYmxlUHJvcGVydHkoIlJlc291cmNlcyIpO3JldHVybiBzaGFkb3codGhpcywicmVzb3VyY2VzIixlIGluc3RhbmNlb2YgRGljdD9lOkRpY3QuZW1wdHkpfV9nZXRCb3VuZGluZ0JveChlKXtpZih0aGlzLnhmYURhdGEpcmV0dXJuIHRoaXMueGZhRGF0YS5iYm94O2xldCB0PXRoaXMuX2dldEluaGVyaXRhYmxlUHJvcGVydHkoZSwhMCk7aWYoQXJyYXkuaXNBcnJheSh0KSYmND09PXQubGVuZ3RoKXt0PVV0aWwubm9ybWFsaXplUmVjdCh0KTtpZih0WzJdLXRbMF0+MCYmdFszXS10WzFdPjApcmV0dXJuIHQ7d2FybihgRW1wdHksIG9yIGludmFsaWQsIC8ke2V9IGVudHJ5LmApfXJldHVybiBudWxsfWdldCBtZWRpYUJveCgpe3JldHVybiBzaGFkb3codGhpcywibWVkaWFCb3giLHRoaXMuX2dldEJvdW5kaW5nQm94KCJNZWRpYUJveCIpfHxzbyl9Z2V0IGNyb3BCb3goKXtyZXR1cm4gc2hhZG93KHRoaXMsImNyb3BCb3giLHRoaXMuX2dldEJvdW5kaW5nQm94KCJDcm9wQm94Iil8fHRoaXMubWVkaWFCb3gpfWdldCB1c2VyVW5pdCgpe2xldCBlPXRoaXMucGFnZURpY3QuZ2V0KCJVc2VyVW5pdCIpOygibnVtYmVyIiE9dHlwZW9mIGV8fGU8PTApJiYoZT0xKTtyZXR1cm4gc2hhZG93KHRoaXMsInVzZXJVbml0IixlKX1nZXQgdmlldygpe2NvbnN0e2Nyb3BCb3g6ZSxtZWRpYUJveDp0fT10aGlzO2lmKGUhPT10JiYhaXNBcnJheUVxdWFsKGUsdCkpe2NvbnN0IGk9VXRpbC5pbnRlcnNlY3QoZSx0KTtpZihpJiZpWzJdLWlbMF0+MCYmaVszXS1pWzFdPjApcmV0dXJuIHNoYWRvdyh0aGlzLCJ2aWV3IixpKTt3YXJuKCJFbXB0eSAvQ3JvcEJveCBhbmQgL01lZGlhQm94IGludGVyc2VjdGlvbi4iKX1yZXR1cm4gc2hhZG93KHRoaXMsInZpZXciLHQpfWdldCByb3RhdGUoKXtsZXQgZT10aGlzLl9nZXRJbmhlcml0YWJsZVByb3BlcnR5KCJSb3RhdGUiKXx8MDtlJTkwIT0wP2U9MDplPj0zNjA/ZSU9MzYwOmU8MCYmKGU9KGUlMzYwKzM2MCklMzYwKTtyZXR1cm4gc2hhZG93KHRoaXMsInJvdGF0ZSIsZSl9X29uU3ViU3RyZWFtRXJyb3IoZSx0KXtpZighdGhpcy5ldmFsdWF0b3JPcHRpb25zLmlnbm9yZUVycm9ycyl0aHJvdyBlO3dhcm4oYGdldENvbnRlbnRTdHJlYW0gLSBpZ25vcmluZyBzdWItc3RyZWFtICgke3R9KTogIiR7ZX0iLmApfWdldENvbnRlbnRTdHJlYW0oKXtyZXR1cm4gdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZSh0aGlzLCJjb250ZW50IikudGhlbigoZT0+ZSBpbnN0YW5jZW9mIEJhc2VTdHJlYW0/ZTpBcnJheS5pc0FycmF5KGUpP25ldyBTdHJlYW1zU2VxdWVuY2VTdHJlYW0oZSx0aGlzLl9vblN1YlN0cmVhbUVycm9yLmJpbmQodGhpcykpOm5ldyBOdWxsU3RyZWFtKSl9Z2V0IHhmYURhdGEoKXtyZXR1cm4gc2hhZG93KHRoaXMsInhmYURhdGEiLHRoaXMueGZhRmFjdG9yeT97YmJveDp0aGlzLnhmYUZhY3RvcnkuZ2V0Qm91bmRpbmdCb3godGhpcy5wYWdlSW5kZXgpfTpudWxsKX0jSihlLHQsaSl7Zm9yKGNvbnN0IGEgb2YgZSlpZihhLmlkKXtjb25zdCBlPVJlZi5mcm9tU3RyaW5nKGEuaWQpO2lmKCFlKXt3YXJuKGBBIG5vbi1saW5rZWQgYW5ub3RhdGlvbiBjYW5ub3QgYmUgbW9kaWZpZWQ6ICR7YS5pZH1gKTtjb250aW51ZX1pZihhLmRlbGV0ZWQpe3QucHV0KGUsZSk7Y29udGludWV9aT8ucHV0KGUpO2EucmVmPWU7ZGVsZXRlIGEuaWR9fWFzeW5jIHNhdmVOZXdBbm5vdGF0aW9ucyhlLHQsaSxhKXtpZih0aGlzLnhmYUZhY3RvcnkpdGhyb3cgbmV3IEVycm9yKCJYRkE6IENhbm5vdCBzYXZlIG5ldyBhbm5vdGF0aW9ucy4iKTtjb25zdCBzPW5ldyBQYXJ0aWFsRXZhbHVhdG9yKHt4cmVmOnRoaXMueHJlZixoYW5kbGVyOmUscGFnZUluZGV4OnRoaXMucGFnZUluZGV4LGlkRmFjdG9yeTp0aGlzLl9sb2NhbElkRmFjdG9yeSxmb250Q2FjaGU6dGhpcy5mb250Q2FjaGUsYnVpbHRJbkNNYXBDYWNoZTp0aGlzLmJ1aWx0SW5DTWFwQ2FjaGUsc3RhbmRhcmRGb250RGF0YUNhY2hlOnRoaXMuc3RhbmRhcmRGb250RGF0YUNhY2hlLGdsb2JhbEltYWdlQ2FjaGU6dGhpcy5nbG9iYWxJbWFnZUNhY2hlLHN5c3RlbUZvbnRDYWNoZTp0aGlzLnN5c3RlbUZvbnRDYWNoZSxvcHRpb25zOnRoaXMuZXZhbHVhdG9yT3B0aW9uc30pLHI9bmV3IFJlZlNldENhY2hlLG49bmV3IFJlZlNldDt0aGlzLiNKKGkscixuKTtjb25zdCBvPXRoaXMucGFnZURpY3QsZz10aGlzLmFubm90YXRpb25zLmZpbHRlcigoZT0+IShlIGluc3RhbmNlb2YgUmVmJiZyLmhhcyhlKSkpKSxjPWF3YWl0IEFubm90YXRpb25GYWN0b3J5LnNhdmVOZXdBbm5vdGF0aW9ucyhzLHQsaSxhKTtmb3IoY29uc3R7cmVmOmV9b2YgYy5hbm5vdGF0aW9ucyllIGluc3RhbmNlb2YgUmVmJiYhbi5oYXMoZSkmJmcucHVzaChlKTtjb25zdCBDPW8uZ2V0KCJBbm5vdHMiKTtvLnNldCgiQW5ub3RzIixnKTtjb25zdCBoPVtdO2F3YWl0IHdyaXRlT2JqZWN0KHRoaXMucmVmLG8saCx0aGlzLnhyZWYpO0MmJm8uc2V0KCJBbm5vdHMiLEMpO2NvbnN0IGw9Yy5kZXBlbmRlbmNpZXM7bC5wdXNoKHtyZWY6dGhpcy5yZWYsZGF0YTpoLmpvaW4oIiIpfSwuLi5jLmFubm90YXRpb25zKTtmb3IoY29uc3QgZSBvZiByKWwucHVzaCh7cmVmOmUsZGF0YTpudWxsfSk7cmV0dXJuIGx9c2F2ZShlLHQsaSl7Y29uc3QgYT1uZXcgUGFydGlhbEV2YWx1YXRvcih7eHJlZjp0aGlzLnhyZWYsaGFuZGxlcjplLHBhZ2VJbmRleDp0aGlzLnBhZ2VJbmRleCxpZEZhY3Rvcnk6dGhpcy5fbG9jYWxJZEZhY3RvcnksZm9udENhY2hlOnRoaXMuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dGhpcy5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZSxzeXN0ZW1Gb250Q2FjaGU6dGhpcy5zeXN0ZW1Gb250Q2FjaGUsb3B0aW9uczp0aGlzLmV2YWx1YXRvck9wdGlvbnN9KTtyZXR1cm4gdGhpcy5fcGFyc2VkQW5ub3RhdGlvbnMudGhlbigoZnVuY3Rpb24oZSl7Y29uc3Qgcz1bXTtmb3IoY29uc3QgciBvZiBlKXIubXVzdEJlUHJpbnRlZChpKSYmcy5wdXNoKHIuc2F2ZShhLHQsaSkuY2F0Y2goKGZ1bmN0aW9uKGUpe3dhcm4oYHNhdmUgLSBpZ25vcmluZyBhbm5vdGF0aW9uIGRhdGEgZHVyaW5nICIke3QubmFtZX0iIHRhc2s6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH0pKSk7cmV0dXJuIFByb21pc2UuYWxsKHMpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBlLmZpbHRlcigoZT0+ISFlKSl9KSl9KSl9bG9hZFJlc291cmNlcyhlKXt0aGlzLnJlc291cmNlc1Byb21pc2V8fCh0aGlzLnJlc291cmNlc1Byb21pc2U9dGhpcy5wZGZNYW5hZ2VyLmVuc3VyZSh0aGlzLCJyZXNvdXJjZXMiKSk7cmV0dXJuIHRoaXMucmVzb3VyY2VzUHJvbWlzZS50aGVuKCgoKT0+bmV3IE9iamVjdExvYWRlcih0aGlzLnJlc291cmNlcyxlLHRoaXMueHJlZikubG9hZCgpKSl9Z2V0T3BlcmF0b3JMaXN0KHtoYW5kbGVyOmUsc2luazp0LHRhc2s6aSxpbnRlbnQ6YSxjYWNoZUtleTpzLGFubm90YXRpb25TdG9yYWdlOnI9bnVsbH0pe2NvbnN0IG49dGhpcy5nZXRDb250ZW50U3RyZWFtKCksQz10aGlzLmxvYWRSZXNvdXJjZXMoWyJDb2xvclNwYWNlIiwiRXh0R1N0YXRlIiwiRm9udCIsIlBhdHRlcm4iLCJQcm9wZXJ0aWVzIiwiU2hhZGluZyIsIlhPYmplY3QiXSksUT1uZXcgUGFydGlhbEV2YWx1YXRvcih7eHJlZjp0aGlzLnhyZWYsaGFuZGxlcjplLHBhZ2VJbmRleDp0aGlzLnBhZ2VJbmRleCxpZEZhY3Rvcnk6dGhpcy5fbG9jYWxJZEZhY3RvcnksZm9udENhY2hlOnRoaXMuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dGhpcy5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZSxzeXN0ZW1Gb250Q2FjaGU6dGhpcy5zeXN0ZW1Gb250Q2FjaGUsb3B0aW9uczp0aGlzLmV2YWx1YXRvck9wdGlvbnN9KSx1PXRoaXMueGZhRmFjdG9yeT9udWxsOmdldE5ld0Fubm90YXRpb25zTWFwKHIpO2xldCBkPW51bGwsZj1Qcm9taXNlLnJlc29sdmUobnVsbCk7aWYodSl7Y29uc3QgZT11LmdldCh0aGlzLnBhZ2VJbmRleCk7aWYoZSl7Y29uc3QgdD10aGlzLnBkZk1hbmFnZXIuZW5zdXJlRG9jKCJhbm5vdGF0aW9uR2xvYmFscyIpO2xldCBhO2NvbnN0IHM9bmV3IFNldDtmb3IoY29uc3R7Yml0bWFwSWQ6dCxiaXRtYXA6aX1vZiBlKSF0fHxpfHxzLmhhcyh0KXx8cy5hZGQodCk7Y29uc3R7aXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQ6bn09dGhpcy5ldmFsdWF0b3JPcHRpb25zO2lmKHMuc2l6ZT4wKXtjb25zdCB0PWUuc2xpY2UoKTtmb3IoY29uc3RbZSxpXW9mIHIpZS5zdGFydHNXaXRoKEUpJiZpLmJpdG1hcCYmcy5oYXMoaS5iaXRtYXBJZCkmJnQucHVzaChpKTthPUFubm90YXRpb25GYWN0b3J5LmdlbmVyYXRlSW1hZ2VzKHQsdGhpcy54cmVmLG4pfWVsc2UgYT1Bbm5vdGF0aW9uRmFjdG9yeS5nZW5lcmF0ZUltYWdlcyhlLHRoaXMueHJlZixuKTtkPW5ldyBSZWZTZXQ7dGhpcy4jSihlLGQsbnVsbCk7Zj10LnRoZW4oKHQ9PnQ/QW5ub3RhdGlvbkZhY3RvcnkucHJpbnROZXdBbm5vdGF0aW9ucyh0LFEsaSxlLGEpOm51bGwpKX19Y29uc3QgcD1Qcm9taXNlLmFsbChbbixDXSkudGhlbigoKFtyXSk9Pntjb25zdCBuPW5ldyBPcGVyYXRvckxpc3QoYSx0KTtlLnNlbmQoIlN0YXJ0UmVuZGVyUGFnZSIse3RyYW5zcGFyZW5jeTpRLmhhc0JsZW5kTW9kZXModGhpcy5yZXNvdXJjZXMsdGhpcy5ub25CbGVuZE1vZGVzU2V0KSxwYWdlSW5kZXg6dGhpcy5wYWdlSW5kZXgsY2FjaGVLZXk6c30pO3JldHVybiBRLmdldE9wZXJhdG9yTGlzdCh7c3RyZWFtOnIsdGFzazppLHJlc291cmNlczp0aGlzLnJlc291cmNlcyxvcGVyYXRvckxpc3Q6bn0pLnRoZW4oKGZ1bmN0aW9uKCl7cmV0dXJuIG59KSl9KSk7cmV0dXJuIFByb21pc2UuYWxsKFtwLHRoaXMuX3BhcnNlZEFubm90YXRpb25zLGZdKS50aGVuKChmdW5jdGlvbihbZSx0LHNdKXtpZihzKXt0PXQuZmlsdGVyKChlPT4hKGUucmVmJiZkLmhhcyhlLnJlZikpKSk7Zm9yKGxldCBlPTAsaT1zLmxlbmd0aDtlPGk7ZSsrKXtjb25zdCBhPXNbZV07aWYoYS5yZWZUb1JlcGxhY2Upe2NvbnN0IHI9dC5maW5kSW5kZXgoKGU9PmUucmVmJiZpc1JlZnNFcXVhbChlLnJlZixhLnJlZlRvUmVwbGFjZSkpKTtpZihyPj0wKXt0LnNwbGljZShyLDEsYSk7cy5zcGxpY2UoZS0tLDEpO2ktLX19fXQ9dC5jb25jYXQocyl9aWYoMD09PXQubGVuZ3RofHxhJmwpe2UuZmx1c2goITApO3JldHVybntsZW5ndGg6ZS50b3RhbExlbmd0aH19Y29uc3Qgbj0hIShhJmgpLEM9ISEoYSZvKSxFPSEhKGEmZyksdT0hIShhJmMpLGY9W107Zm9yKGNvbnN0IGUgb2YgdCkoQ3x8RSYmZS5tdXN0QmVWaWV3ZWQocixuKXx8dSYmZS5tdXN0QmVQcmludGVkKHIpKSYmZi5wdXNoKGUuZ2V0T3BlcmF0b3JMaXN0KFEsaSxhLG4scikuY2F0Y2goKGZ1bmN0aW9uKGUpe3dhcm4oYGdldE9wZXJhdG9yTGlzdCAtIGlnbm9yaW5nIGFubm90YXRpb24gZGF0YSBkdXJpbmcgIiR7aS5uYW1lfSIgdGFzazogIiR7ZX0iLmApO3JldHVybntvcExpc3Q6bnVsbCxzZXBhcmF0ZUZvcm06ITEsc2VwYXJhdGVDYW52YXM6ITF9fSkpKTtyZXR1cm4gUHJvbWlzZS5hbGwoZikudGhlbigoZnVuY3Rpb24odCl7bGV0IGk9ITEsYT0hMTtmb3IoY29uc3R7b3BMaXN0OnMsc2VwYXJhdGVGb3JtOnIsc2VwYXJhdGVDYW52YXM6bn1vZiB0KXtlLmFkZE9wTGlzdChzKTtpfHw9cjthfHw9bn1lLmZsdXNoKCEwLHtmb3JtOmksY2FudmFzOmF9KTtyZXR1cm57bGVuZ3RoOmUudG90YWxMZW5ndGh9fSkpfSkpfWV4dHJhY3RUZXh0Q29udGVudCh7aGFuZGxlcjplLHRhc2s6dCxpbmNsdWRlTWFya2VkQ29udGVudDppLGRpc2FibGVOb3JtYWxpemF0aW9uOmEsc2luazpzfSl7Y29uc3Qgcj10aGlzLmdldENvbnRlbnRTdHJlYW0oKSxuPXRoaXMubG9hZFJlc291cmNlcyhbIkV4dEdTdGF0ZSIsIkZvbnQiLCJQcm9wZXJ0aWVzIiwiWE9iamVjdCJdKTtyZXR1cm4gUHJvbWlzZS5hbGwoW3Isbl0pLnRoZW4oKChbcl0pPT5uZXcgUGFydGlhbEV2YWx1YXRvcih7eHJlZjp0aGlzLnhyZWYsaGFuZGxlcjplLHBhZ2VJbmRleDp0aGlzLnBhZ2VJbmRleCxpZEZhY3Rvcnk6dGhpcy5fbG9jYWxJZEZhY3RvcnksZm9udENhY2hlOnRoaXMuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dGhpcy5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0aGlzLnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnRoaXMuZ2xvYmFsSW1hZ2VDYWNoZSxzeXN0ZW1Gb250Q2FjaGU6dGhpcy5zeXN0ZW1Gb250Q2FjaGUsb3B0aW9uczp0aGlzLmV2YWx1YXRvck9wdGlvbnN9KS5nZXRUZXh0Q29udGVudCh7c3RyZWFtOnIsdGFzazp0LHJlc291cmNlczp0aGlzLnJlc291cmNlcyxpbmNsdWRlTWFya2VkQ29udGVudDppLGRpc2FibGVOb3JtYWxpemF0aW9uOmEsc2luazpzLHZpZXdCb3g6dGhpcy52aWV3fSkpKX1hc3luYyBnZXRTdHJ1Y3RUcmVlKCl7Y29uc3QgZT1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlQ2F0YWxvZygic3RydWN0VHJlZVJvb3QiKTtpZighZSlyZXR1cm4gbnVsbDthd2FpdCB0aGlzLl9wYXJzZWRBbm5vdGF0aW9ucztyZXR1cm4oYXdhaXQgdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZSh0aGlzLCJfcGFyc2VTdHJ1Y3RUcmVlIixbZV0pKS5zZXJpYWxpemFibGV9X3BhcnNlU3RydWN0VHJlZShlKXtjb25zdCB0PW5ldyBTdHJ1Y3RUcmVlUGFnZShlLHRoaXMucGFnZURpY3QpO3QucGFyc2UodGhpcy5yZWYpO3JldHVybiB0fWFzeW5jIGdldEFubm90YXRpb25zRGF0YShlLHQsaSl7Y29uc3QgYT1hd2FpdCB0aGlzLl9wYXJzZWRBbm5vdGF0aW9ucztpZigwPT09YS5sZW5ndGgpcmV0dXJuIGE7Y29uc3Qgcz1bXSxyPVtdO2xldCBuO2NvbnN0IEM9ISEoaSZvKSxoPSEhKGkmZyksbD0hIShpJmMpO2Zvcihjb25zdCBpIG9mIGEpe2NvbnN0IGE9Q3x8aCYmaS52aWV3YWJsZTsoYXx8bCYmaS5wcmludGFibGUpJiZzLnB1c2goaS5kYXRhKTtpZihpLmhhc1RleHRDb250ZW50JiZhKXtufHw9bmV3IFBhcnRpYWxFdmFsdWF0b3Ioe3hyZWY6dGhpcy54cmVmLGhhbmRsZXI6ZSxwYWdlSW5kZXg6dGhpcy5wYWdlSW5kZXgsaWRGYWN0b3J5OnRoaXMuX2xvY2FsSWRGYWN0b3J5LGZvbnRDYWNoZTp0aGlzLmZvbnRDYWNoZSxidWlsdEluQ01hcENhY2hlOnRoaXMuYnVpbHRJbkNNYXBDYWNoZSxzdGFuZGFyZEZvbnREYXRhQ2FjaGU6dGhpcy5zdGFuZGFyZEZvbnREYXRhQ2FjaGUsZ2xvYmFsSW1hZ2VDYWNoZTp0aGlzLmdsb2JhbEltYWdlQ2FjaGUsc3lzdGVtRm9udENhY2hlOnRoaXMuc3lzdGVtRm9udENhY2hlLG9wdGlvbnM6dGhpcy5ldmFsdWF0b3JPcHRpb25zfSk7ci5wdXNoKGkuZXh0cmFjdFRleHRDb250ZW50KG4sdCxbLTEvMCwtMS8wLDEvMCwxLzBdKS5jYXRjaCgoZnVuY3Rpb24oZSl7d2FybihgZ2V0QW5ub3RhdGlvbnNEYXRhIC0gaWdub3JpbmcgdGV4dENvbnRlbnQgZHVyaW5nICIke3QubmFtZX0iIHRhc2s6ICIke2V9Ii5gKX0pKSl9fWF3YWl0IFByb21pc2UuYWxsKHIpO3JldHVybiBzfWdldCBhbm5vdGF0aW9ucygpe2NvbnN0IGU9dGhpcy5fZ2V0SW5oZXJpdGFibGVQcm9wZXJ0eSgiQW5ub3RzIik7cmV0dXJuIHNoYWRvdyh0aGlzLCJhbm5vdGF0aW9ucyIsQXJyYXkuaXNBcnJheShlKT9lOltdKX1nZXQgX3BhcnNlZEFubm90YXRpb25zKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJfcGFyc2VkQW5ub3RhdGlvbnMiLHRoaXMucGRmTWFuYWdlci5lbnN1cmUodGhpcywiYW5ub3RhdGlvbnMiKS50aGVuKChhc3luYyBlPT57aWYoMD09PWUubGVuZ3RoKXJldHVybiBlO2NvbnN0IHQ9YXdhaXQgdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZURvYygiYW5ub3RhdGlvbkdsb2JhbHMiKTtpZighdClyZXR1cm5bXTtjb25zdCBpPVtdO2Zvcihjb25zdCBhIG9mIGUpaS5wdXNoKEFubm90YXRpb25GYWN0b3J5LmNyZWF0ZSh0aGlzLnhyZWYsYSx0LHRoaXMuX2xvY2FsSWRGYWN0b3J5LCExLHRoaXMucmVmKS5jYXRjaCgoZnVuY3Rpb24oZSl7d2FybihgX3BhcnNlZEFubm90YXRpb25zOiAiJHtlfSIuYCk7cmV0dXJuIG51bGx9KSkpO2NvbnN0IGE9W107bGV0IHMscjtmb3IoY29uc3QgZSBvZiBhd2FpdCBQcm9taXNlLmFsbChpKSllJiYoZSBpbnN0YW5jZW9mIFdpZGdldEFubm90YXRpb24/KHJ8fD1bXSkucHVzaChlKTplIGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uPyhzfHw9W10pLnB1c2goZSk6YS5wdXNoKGUpKTtyJiZhLnB1c2goLi4ucik7cyYmYS5wdXNoKC4uLnMpO3JldHVybiBhfSkpKX1nZXQganNBY3Rpb25zKCl7cmV0dXJuIHNoYWRvdyh0aGlzLCJqc0FjdGlvbnMiLGNvbGxlY3RBY3Rpb25zKHRoaXMueHJlZix0aGlzLnBhZ2VEaWN0LGZBKSl9fWNvbnN0IHJvPW5ldyBVaW50OEFycmF5KFszNyw4MCw2OCw3MCw0NV0pLG5vPW5ldyBVaW50OEFycmF5KFsxMTUsMTE2LDk3LDExNCwxMTYsMTIwLDExNCwxMDEsMTAyXSksb289bmV3IFVpbnQ4QXJyYXkoWzEwMSwxMTAsMTAwLDExMSw5OCwxMDZdKTtmdW5jdGlvbiBmaW5kKGUsdCxpPTEwMjQsYT0hMSl7Y29uc3Qgcz10Lmxlbmd0aCxyPWUucGVla0J5dGVzKGkpLG49ci5sZW5ndGgtcztpZihuPD0wKXJldHVybiExO2lmKGEpe2NvbnN0IGk9cy0xO2xldCBhPXIubGVuZ3RoLTE7Zm9yKDthPj1pOyl7bGV0IG49MDtmb3IoO248cyYmclthLW5dPT09dFtpLW5dOyluKys7aWYobj49cyl7ZS5wb3MrPWEtaTtyZXR1cm4hMH1hLS19fWVsc2V7bGV0IGk9MDtmb3IoO2k8PW47KXtsZXQgYT0wO2Zvcig7YTxzJiZyW2krYV09PT10W2FdOylhKys7aWYoYT49cyl7ZS5wb3MrPWk7cmV0dXJuITB9aSsrfX1yZXR1cm4hMX1jbGFzcyBQREZEb2N1bWVudHtjb25zdHJ1Y3RvcihlLHQpe2lmKHQubGVuZ3RoPD0wKXRocm93IG5ldyBJbnZhbGlkUERGRXhjZXB0aW9uKCJUaGUgUERGIGZpbGUgaXMgZW1wdHksIGkuZS4gaXRzIHNpemUgaXMgemVybyBieXRlcy4iKTt0aGlzLnBkZk1hbmFnZXI9ZTt0aGlzLnN0cmVhbT10O3RoaXMueHJlZj1uZXcgWFJlZih0LGUpO3RoaXMuX3BhZ2VQcm9taXNlcz1uZXcgTWFwO3RoaXMuX3ZlcnNpb249bnVsbDtjb25zdCBpPXtmb250OjB9O3RoaXMuX2dsb2JhbElkRmFjdG9yeT1jbGFzc3tzdGF0aWMgZ2V0RG9jSWQoKXtyZXR1cm5gZ18ke2UuZG9jSWR9YH1zdGF0aWMgY3JlYXRlRm9udElkKCl7cmV0dXJuImYiKyArK2kuZm9udH1zdGF0aWMgY3JlYXRlT2JqSWQoKXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGBjcmVhdGVPYmpJZGAgY2FsbGVkLiIpfXN0YXRpYyBnZXRQYWdlT2JqSWQoKXt1bnJlYWNoYWJsZSgiQWJzdHJhY3QgbWV0aG9kIGBnZXRQYWdlT2JqSWRgIGNhbGxlZC4iKX19fXBhcnNlKGUpe3RoaXMueHJlZi5wYXJzZShlKTt0aGlzLmNhdGFsb2c9bmV3IENhdGFsb2codGhpcy5wZGZNYW5hZ2VyLHRoaXMueHJlZil9Z2V0IGxpbmVhcml6YXRpb24oKXtsZXQgZT1udWxsO3RyeXtlPUxpbmVhcml6YXRpb24uY3JlYXRlKHRoaXMuc3RyZWFtKX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2YgTWlzc2luZ0RhdGFFeGNlcHRpb24pdGhyb3cgZTtpbmZvKGUpfXJldHVybiBzaGFkb3codGhpcywibGluZWFyaXphdGlvbiIsZSl9Z2V0IHN0YXJ0WFJlZigpe2NvbnN0IGU9dGhpcy5zdHJlYW07bGV0IHQ9MDtpZih0aGlzLmxpbmVhcml6YXRpb24pe2UucmVzZXQoKTtpZihmaW5kKGUsb28pKXtlLnNraXAoNik7bGV0IGk9ZS5wZWVrQnl0ZSgpO2Zvcig7aXNXaGl0ZVNwYWNlKGkpOyl7ZS5wb3MrKztpPWUucGVla0J5dGUoKX10PWUucG9zLWUuc3RhcnR9fWVsc2V7Y29uc3QgaT0xMDI0LGE9bm8ubGVuZ3RoO2xldCBzPSExLHI9ZS5lbmQ7Zm9yKDshcyYmcj4wOyl7ci09aS1hO3I8MCYmKHI9MCk7ZS5wb3M9cjtzPWZpbmQoZSxubyxpLCEwKX1pZihzKXtlLnNraXAoOSk7bGV0IGk7ZG97aT1lLmdldEJ5dGUoKX13aGlsZShpc1doaXRlU3BhY2UoaSkpO2xldCBhPSIiO2Zvcig7aT49MzImJmk8PTU3Oyl7YSs9U3RyaW5nLmZyb21DaGFyQ29kZShpKTtpPWUuZ2V0Qnl0ZSgpfXQ9cGFyc2VJbnQoYSwxMCk7aXNOYU4odCkmJih0PTApfX1yZXR1cm4gc2hhZG93KHRoaXMsInN0YXJ0WFJlZiIsdCl9Y2hlY2tIZWFkZXIoKXtjb25zdCBlPXRoaXMuc3RyZWFtO2UucmVzZXQoKTtpZighZmluZChlLHJvKSlyZXR1cm47ZS5tb3ZlU3RhcnQoKTtlLnNraXAocm8ubGVuZ3RoKTtsZXQgdCxpPSIiO2Zvcig7KHQ9ZS5nZXRCeXRlKCkpPjMyJiZpLmxlbmd0aDw3OylpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO0R0LnRlc3QoaSk/dGhpcy5fdmVyc2lvbj1pOndhcm4oYEludmFsaWQgUERGIGhlYWRlciB2ZXJzaW9uOiAke2l9YCl9cGFyc2VTdGFydFhSZWYoKXt0aGlzLnhyZWYuc2V0U3RhcnRYUmVmKHRoaXMuc3RhcnRYUmVmKX1nZXQgbnVtUGFnZXMoKXtsZXQgZT0wO2U9dGhpcy5jYXRhbG9nLmhhc0FjdHVhbE51bVBhZ2VzP3RoaXMuY2F0YWxvZy5udW1QYWdlczp0aGlzLnhmYUZhY3Rvcnk/dGhpcy54ZmFGYWN0b3J5LmdldE51bVBhZ2VzKCk6dGhpcy5saW5lYXJpemF0aW9uP3RoaXMubGluZWFyaXphdGlvbi5udW1QYWdlczp0aGlzLmNhdGFsb2cubnVtUGFnZXM7cmV0dXJuIHNoYWRvdyh0aGlzLCJudW1QYWdlcyIsZSl9X2hhc09ubHlEb2N1bWVudFNpZ25hdHVyZXMoZSx0PTApe3JldHVybiEhQXJyYXkuaXNBcnJheShlKSYmZS5ldmVyeSgoZT0+e2lmKCEoKGU9dGhpcy54cmVmLmZldGNoSWZSZWYoZSkpaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm4hMTtpZihlLmhhcygiS2lkcyIpKXtpZigrK3Q+MTApe3dhcm4oIl9oYXNPbmx5RG9jdW1lbnRTaWduYXR1cmVzOiBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aCByZWFjaGVkIik7cmV0dXJuITF9cmV0dXJuIHRoaXMuX2hhc09ubHlEb2N1bWVudFNpZ25hdHVyZXMoZS5nZXQoIktpZHMiKSx0KX1jb25zdCBpPWlzTmFtZShlLmdldCgiRlQiKSwiU2lnIiksYT1lLmdldCgiUmVjdCIpLHM9QXJyYXkuaXNBcnJheShhKSYmYS5ldmVyeSgoZT0+MD09PWUpKTtyZXR1cm4gaSYmc30pKX1nZXQgX3hmYVN0cmVhbXMoKXtjb25zdCBlPXRoaXMuY2F0YWxvZy5hY3JvRm9ybTtpZighZSlyZXR1cm4gbnVsbDtjb25zdCB0PWUuZ2V0KCJYRkEiKSxpPXsieGRwOnhkcCI6IiIsdGVtcGxhdGU6IiIsZGF0YXNldHM6IiIsY29uZmlnOiIiLGNvbm5lY3Rpb25TZXQ6IiIsbG9jYWxlU2V0OiIiLHN0eWxlc2hlZXQ6IiIsIi94ZHA6eGRwIjoiIn07aWYodCBpbnN0YW5jZW9mIEJhc2VTdHJlYW0mJiF0LmlzRW1wdHkpe2lbInhkcDp4ZHAiXT10O3JldHVybiBpfWlmKCFBcnJheS5pc0FycmF5KHQpfHwwPT09dC5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTAsYT10Lmxlbmd0aDtlPGE7ZSs9Mil7bGV0IHM7cz0wPT09ZT8ieGRwOnhkcCI6ZT09PWEtMj8iL3hkcDp4ZHAiOnRbZV07aWYoIWkuaGFzT3duUHJvcGVydHkocykpY29udGludWU7Y29uc3Qgcj10aGlzLnhyZWYuZmV0Y2hJZlJlZih0W2UrMV0pO3IgaW5zdGFuY2VvZiBCYXNlU3RyZWFtJiYhci5pc0VtcHR5JiYoaVtzXT1yKX1yZXR1cm4gaX1nZXQgeGZhRGF0YXNldHMoKXtjb25zdCBlPXRoaXMuX3hmYVN0cmVhbXM7aWYoIWUpcmV0dXJuIHNoYWRvdyh0aGlzLCJ4ZmFEYXRhc2V0cyIsbnVsbCk7Zm9yKGNvbnN0IHQgb2ZbImRhdGFzZXRzIiwieGRwOnhkcCJdKXtjb25zdCBpPWVbdF07aWYoaSl0cnl7Y29uc3QgZT1zdHJpbmdUb1VURjhTdHJpbmcoaS5nZXRTdHJpbmcoKSk7cmV0dXJuIHNoYWRvdyh0aGlzLCJ4ZmFEYXRhc2V0cyIsbmV3IERhdGFzZXRSZWFkZXIoe1t0XTplfSkpfWNhdGNoe3dhcm4oIlhGQSAtIEludmFsaWQgdXRmLTggc3RyaW5nLiIpO2JyZWFrfX1yZXR1cm4gc2hhZG93KHRoaXMsInhmYURhdGFzZXRzIixudWxsKX1nZXQgeGZhRGF0YSgpe2NvbnN0IGU9dGhpcy5feGZhU3RyZWFtcztpZighZSlyZXR1cm4gbnVsbDtjb25zdCB0PU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGNvbnN0W2ksYV1vZiBPYmplY3QuZW50cmllcyhlKSlpZihhKXRyeXt0W2ldPXN0cmluZ1RvVVRGOFN0cmluZyhhLmdldFN0cmluZygpKX1jYXRjaHt3YXJuKCJYRkEgLSBJbnZhbGlkIHV0Zi04IHN0cmluZy4iKTtyZXR1cm4gbnVsbH1yZXR1cm4gdH1nZXQgeGZhRmFjdG9yeSgpe2xldCBlO3RoaXMucGRmTWFuYWdlci5lbmFibGVYZmEmJnRoaXMuY2F0YWxvZy5uZWVkc1JlbmRlcmluZyYmdGhpcy5mb3JtSW5mby5oYXNYZmEmJiF0aGlzLmZvcm1JbmZvLmhhc0Fjcm9Gb3JtJiYoZT10aGlzLnhmYURhdGEpO3JldHVybiBzaGFkb3codGhpcywieGZhRmFjdG9yeSIsZT9uZXcgWEZBRmFjdG9yeShlKTpudWxsKX1nZXQgaXNQdXJlWGZhKCl7cmV0dXJuISF0aGlzLnhmYUZhY3RvcnkmJnRoaXMueGZhRmFjdG9yeS5pc1ZhbGlkKCl9Z2V0IGh0bWxGb3JYZmEoKXtyZXR1cm4gdGhpcy54ZmFGYWN0b3J5P3RoaXMueGZhRmFjdG9yeS5nZXRQYWdlcygpOm51bGx9YXN5bmMgbG9hZFhmYUltYWdlcygpe2NvbnN0IGU9YXdhaXQgdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZUNhdGFsb2coInhmYUltYWdlcyIpO2lmKCFlKXJldHVybjtjb25zdCB0PWUuZ2V0S2V5cygpLGk9bmV3IE9iamVjdExvYWRlcihlLHQsdGhpcy54cmVmKTthd2FpdCBpLmxvYWQoKTtjb25zdCBhPW5ldyBNYXA7Zm9yKGNvbnN0IGkgb2YgdCl7Y29uc3QgdD1lLmdldChpKTt0IGluc3RhbmNlb2YgQmFzZVN0cmVhbSYmYS5zZXQoaSx0LmdldEJ5dGVzKCkpfXRoaXMueGZhRmFjdG9yeS5zZXRJbWFnZXMoYSl9YXN5bmMgbG9hZFhmYUZvbnRzKGUsdCl7Y29uc3QgaT1hd2FpdCB0aGlzLnBkZk1hbmFnZXIuZW5zdXJlQ2F0YWxvZygiYWNyb0Zvcm0iKTtpZighaSlyZXR1cm47Y29uc3QgYT1hd2FpdCBpLmdldEFzeW5jKCJEUiIpO2lmKCEoYSBpbnN0YW5jZW9mIERpY3QpKXJldHVybjtjb25zdCBzPW5ldyBPYmplY3RMb2FkZXIoYSxbIkZvbnQiXSx0aGlzLnhyZWYpO2F3YWl0IHMubG9hZCgpO2NvbnN0IHI9YS5nZXQoIkZvbnQiKTtpZighKHIgaW5zdGFuY2VvZiBEaWN0KSlyZXR1cm47Y29uc3Qgbj1PYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5wZGZNYW5hZ2VyLmV2YWx1YXRvck9wdGlvbnMpO24udXNlU3lzdGVtRm9udHM9ITE7Y29uc3Qgbz1uZXcgUGFydGlhbEV2YWx1YXRvcih7eHJlZjp0aGlzLnhyZWYsaGFuZGxlcjplLHBhZ2VJbmRleDotMSxpZEZhY3Rvcnk6dGhpcy5fZ2xvYmFsSWRGYWN0b3J5LGZvbnRDYWNoZTp0aGlzLmNhdGFsb2cuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dGhpcy5jYXRhbG9nLmJ1aWx0SW5DTWFwQ2FjaGUsc3RhbmRhcmRGb250RGF0YUNhY2hlOnRoaXMuY2F0YWxvZy5zdGFuZGFyZEZvbnREYXRhQ2FjaGUsb3B0aW9uczpufSksZz1uZXcgT3BlcmF0b3JMaXN0LGM9W10sQz17Z2V0IGZvbnQoKXtyZXR1cm4gYy5hdCgtMSl9LHNldCBmb250KGUpe2MucHVzaChlKX0sY2xvbmUoKXtyZXR1cm4gdGhpc319LGg9bmV3IE1hcDtyLmZvckVhY2goKChlLHQpPT57aC5zZXQoZSx0KX0pKTtjb25zdCBsPVtdO2Zvcihjb25zdFtlLGldb2YgaCl7Y29uc3Qgcz1pLmdldCgiRm9udERlc2NyaXB0b3IiKTtpZighKHMgaW5zdGFuY2VvZiBEaWN0KSljb250aW51ZTtsZXQgcj1zLmdldCgiRm9udEZhbWlseSIpO3I9ci5yZXBsYWNlQWxsKC9bIF0rKFxkKS9nLCIkMSIpO2NvbnN0IG49e2ZvbnRGYW1pbHk6cixmb250V2VpZ2h0OnMuZ2V0KCJGb250V2VpZ2h0IiksaXRhbGljQW5nbGU6LXMuZ2V0KCJJdGFsaWNBbmdsZSIpfTt2YWxpZGF0ZUNTU0ZvbnQobikmJmwucHVzaChvLmhhbmRsZVNldEZvbnQoYSxbTmFtZS5nZXQoZSksMV0sbnVsbCxnLHQsQyxudWxsLG4pLmNhdGNoKChmdW5jdGlvbihlKXt3YXJuKGBsb2FkWGZhRm9udHM6ICIke2V9Ii5gKTtyZXR1cm4gbnVsbH0pKSl9YXdhaXQgUHJvbWlzZS5hbGwobCk7Y29uc3QgUT10aGlzLnhmYUZhY3Rvcnkuc2V0Rm9udHMoYyk7aWYoIVEpcmV0dXJuO24uaWdub3JlRXJyb3JzPSEwO2wubGVuZ3RoPTA7Yy5sZW5ndGg9MDtjb25zdCBFPW5ldyBTZXQ7Zm9yKGNvbnN0IGUgb2YgUSlnZXRYZmFGb250TmFtZShgJHtlfS1SZWd1bGFyYCl8fEUuYWRkKGUpO0Uuc2l6ZSYmUS5wdXNoKCJQZGZKUy1GYWxsYmFjayIpO2Zvcihjb25zdCBlIG9mIFEpaWYoIUUuaGFzKGUpKWZvcihjb25zdCBpIG9mW3tuYW1lOiJSZWd1bGFyIixmb250V2VpZ2h0OjQwMCxpdGFsaWNBbmdsZTowfSx7bmFtZToiQm9sZCIsZm9udFdlaWdodDo3MDAsaXRhbGljQW5nbGU6MH0se25hbWU6Ikl0YWxpYyIsZm9udFdlaWdodDo0MDAsaXRhbGljQW5nbGU6MTJ9LHtuYW1lOiJCb2xkSXRhbGljIixmb250V2VpZ2h0OjcwMCxpdGFsaWNBbmdsZToxMn1dKXtjb25zdCBzPWAke2V9LSR7aS5uYW1lfWAscj1nZXRYZmFGb250RGljdChzKTtsLnB1c2goby5oYW5kbGVTZXRGb250KGEsW05hbWUuZ2V0KHMpLDFdLG51bGwsZyx0LEMscix7Zm9udEZhbWlseTplLGZvbnRXZWlnaHQ6aS5mb250V2VpZ2h0LGl0YWxpY0FuZ2xlOmkuaXRhbGljQW5nbGV9KS5jYXRjaCgoZnVuY3Rpb24oZSl7d2FybihgbG9hZFhmYUZvbnRzOiAiJHtlfSIuYCk7cmV0dXJuIG51bGx9KSkpfWF3YWl0IFByb21pc2UuYWxsKGwpO3RoaXMueGZhRmFjdG9yeS5hcHBlbmRGb250cyhjLEUpfWFzeW5jIHNlcmlhbGl6ZVhmYURhdGEoZSl7cmV0dXJuIHRoaXMueGZhRmFjdG9yeT90aGlzLnhmYUZhY3Rvcnkuc2VyaWFsaXplRGF0YShlKTpudWxsfWdldCB2ZXJzaW9uKCl7cmV0dXJuIHRoaXMuY2F0YWxvZy52ZXJzaW9ufHx0aGlzLl92ZXJzaW9ufWdldCBmb3JtSW5mbygpe2NvbnN0IGU9e2hhc0ZpZWxkczohMSxoYXNBY3JvRm9ybTohMSxoYXNYZmE6ITEsaGFzU2lnbmF0dXJlczohMX0sdD10aGlzLmNhdGFsb2cuYWNyb0Zvcm07aWYoIXQpcmV0dXJuIHNoYWRvdyh0aGlzLCJmb3JtSW5mbyIsZSk7dHJ5e2NvbnN0IGk9dC5nZXQoIkZpZWxkcyIpLGE9QXJyYXkuaXNBcnJheShpKSYmaS5sZW5ndGg+MDtlLmhhc0ZpZWxkcz1hO2NvbnN0IHM9dC5nZXQoIlhGQSIpO2UuaGFzWGZhPUFycmF5LmlzQXJyYXkocykmJnMubGVuZ3RoPjB8fHMgaW5zdGFuY2VvZiBCYXNlU3RyZWFtJiYhcy5pc0VtcHR5O2NvbnN0IHI9ISEoMSZ0LmdldCgiU2lnRmxhZ3MiKSksbj1yJiZ0aGlzLl9oYXNPbmx5RG9jdW1lbnRTaWduYXR1cmVzKGkpO2UuaGFzQWNyb0Zvcm09YSYmIW47ZS5oYXNTaWduYXR1cmVzPXJ9Y2F0Y2goZSl7aWYoZSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKXRocm93IGU7d2FybihgQ2Fubm90IGZldGNoIGZvcm0gaW5mb3JtYXRpb246ICIke2V9Ii5gKX1yZXR1cm4gc2hhZG93KHRoaXMsImZvcm1JbmZvIixlKX1nZXQgZG9jdW1lbnRJbmZvKCl7Y29uc3QgZT17UERGRm9ybWF0VmVyc2lvbjp0aGlzLnZlcnNpb24sTGFuZ3VhZ2U6dGhpcy5jYXRhbG9nLmxhbmcsRW5jcnlwdEZpbHRlck5hbWU6dGhpcy54cmVmLmVuY3J5cHQ/dGhpcy54cmVmLmVuY3J5cHQuZmlsdGVyTmFtZTpudWxsLElzTGluZWFyaXplZDohIXRoaXMubGluZWFyaXphdGlvbixJc0Fjcm9Gb3JtUHJlc2VudDp0aGlzLmZvcm1JbmZvLmhhc0Fjcm9Gb3JtLElzWEZBUHJlc2VudDp0aGlzLmZvcm1JbmZvLmhhc1hmYSxJc0NvbGxlY3Rpb25QcmVzZW50OiEhdGhpcy5jYXRhbG9nLmNvbGxlY3Rpb24sSXNTaWduYXR1cmVzUHJlc2VudDp0aGlzLmZvcm1JbmZvLmhhc1NpZ25hdHVyZXN9O2xldCB0O3RyeXt0PXRoaXMueHJlZi50cmFpbGVyLmdldCgiSW5mbyIpfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBNaXNzaW5nRGF0YUV4Y2VwdGlvbil0aHJvdyBlO2luZm8oIlRoZSBkb2N1bWVudCBpbmZvcm1hdGlvbiBkaWN0aW9uYXJ5IGlzIGludmFsaWQuIil9aWYoISh0IGluc3RhbmNlb2YgRGljdCkpcmV0dXJuIHNoYWRvdyh0aGlzLCJkb2N1bWVudEluZm8iLGUpO2Zvcihjb25zdCBpIG9mIHQuZ2V0S2V5cygpKXtjb25zdCBhPXQuZ2V0KGkpO3N3aXRjaChpKXtjYXNlIlRpdGxlIjpjYXNlIkF1dGhvciI6Y2FzZSJTdWJqZWN0IjpjYXNlIktleXdvcmRzIjpjYXNlIkNyZWF0b3IiOmNhc2UiUHJvZHVjZXIiOmNhc2UiQ3JlYXRpb25EYXRlIjpjYXNlIk1vZERhdGUiOmlmKCJzdHJpbmciPT10eXBlb2YgYSl7ZVtpXT1zdHJpbmdUb1BERlN0cmluZyhhKTtjb250aW51ZX1icmVhaztjYXNlIlRyYXBwZWQiOmlmKGEgaW5zdGFuY2VvZiBOYW1lKXtlW2ldPWE7Y29udGludWV9YnJlYWs7ZGVmYXVsdDpsZXQgdDtzd2l0Y2godHlwZW9mIGEpe2Nhc2Uic3RyaW5nIjp0PXN0cmluZ1RvUERGU3RyaW5nKGEpO2JyZWFrO2Nhc2UibnVtYmVyIjpjYXNlImJvb2xlYW4iOnQ9YTticmVhaztkZWZhdWx0OmEgaW5zdGFuY2VvZiBOYW1lJiYodD1hKX1pZih2b2lkIDA9PT10KXt3YXJuKGBCYWQgdmFsdWUsIGZvciBjdXN0b20ga2V5ICIke2l9IiwgaW4gSW5mbzogJHthfS5gKTtjb250aW51ZX1lLkN1c3RvbXx8KGUuQ3VzdG9tPU9iamVjdC5jcmVhdGUobnVsbCkpO2UuQ3VzdG9tW2ldPXQ7Y29udGludWV9d2FybihgQmFkIHZhbHVlLCBmb3Iga2V5ICIke2l9IiwgaW4gSW5mbzogJHthfS5gKX1yZXR1cm4gc2hhZG93KHRoaXMsImRvY3VtZW50SW5mbyIsZSl9Z2V0IGZpbmdlcnByaW50cygpe2Z1bmN0aW9uIHZhbGlkYXRlKGUpe3JldHVybiJzdHJpbmciPT10eXBlb2YgZSYmZS5sZW5ndGg+MCYmIlwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwXDBcMFwwIiE9PWV9ZnVuY3Rpb24gaGV4U3RyaW5nKGUpe2NvbnN0IHQ9W107Zm9yKGNvbnN0IGkgb2YgZSl7Y29uc3QgZT1pLnRvU3RyaW5nKDE2KTt0LnB1c2goZS5wYWRTdGFydCgyLCIwIikpfXJldHVybiB0LmpvaW4oIiIpfWNvbnN0IGU9dGhpcy54cmVmLnRyYWlsZXIuZ2V0KCJJRCIpO2xldCB0LGk7aWYoQXJyYXkuaXNBcnJheShlKSYmdmFsaWRhdGUoZVswXSkpe3Q9c3RyaW5nVG9CeXRlcyhlWzBdKTtlWzFdIT09ZVswXSYmdmFsaWRhdGUoZVsxXSkmJihpPXN0cmluZ1RvQnl0ZXMoZVsxXSkpfWVsc2UgdD1Icyh0aGlzLnN0cmVhbS5nZXRCeXRlUmFuZ2UoMCwxMDI0KSwwLDEwMjQpO3JldHVybiBzaGFkb3codGhpcywiZmluZ2VycHJpbnRzIixbaGV4U3RyaW5nKHQpLGk/aGV4U3RyaW5nKGkpOm51bGxdKX1hc3luYyBfZ2V0TGluZWFyaXphdGlvblBhZ2UoZSl7Y29uc3R7Y2F0YWxvZzp0LGxpbmVhcml6YXRpb246aSx4cmVmOmF9PXRoaXMscz1SZWYuZ2V0KGkub2JqZWN0TnVtYmVyRmlyc3QsMCk7dHJ5e2NvbnN0IGU9YXdhaXQgYS5mZXRjaEFzeW5jKHMpO2lmKGUgaW5zdGFuY2VvZiBEaWN0KXtsZXQgaT1lLmdldFJhdygiVHlwZSIpO2kgaW5zdGFuY2VvZiBSZWYmJihpPWF3YWl0IGEuZmV0Y2hBc3luYyhpKSk7aWYoaXNOYW1lKGksIlBhZ2UiKXx8IWUuaGFzKCJUeXBlIikmJiFlLmhhcygiS2lkcyIpKXt0LnBhZ2VLaWRzQ291bnRDYWNoZS5oYXMocyl8fHQucGFnZUtpZHNDb3VudENhY2hlLnB1dChzLDEpO3QucGFnZUluZGV4Q2FjaGUuaGFzKHMpfHx0LnBhZ2VJbmRleENhY2hlLnB1dChzLDApO3JldHVybltlLHNdfX10aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlRoZSBMaW5lYXJpemF0aW9uIGRpY3Rpb25hcnkgZG9lc24ndCBwb2ludCB0byBhIHZhbGlkIFBhZ2UgZGljdGlvbmFyeS4iKX1jYXRjaChpKXt3YXJuKGBfZ2V0TGluZWFyaXphdGlvblBhZ2U6ICIke2kubWVzc2FnZX0iLmApO3JldHVybiB0LmdldFBhZ2VEaWN0KGUpfX1nZXRQYWdlKGUpe2NvbnN0IHQ9dGhpcy5fcGFnZVByb21pc2VzLmdldChlKTtpZih0KXJldHVybiB0O2NvbnN0e2NhdGFsb2c6aSxsaW5lYXJpemF0aW9uOmEseGZhRmFjdG9yeTpzfT10aGlzO2xldCByO3I9cz9Qcm9taXNlLnJlc29sdmUoW0RpY3QuZW1wdHksbnVsbF0pOmE/LnBhZ2VGaXJzdD09PWU/dGhpcy5fZ2V0TGluZWFyaXphdGlvblBhZ2UoZSk6aS5nZXRQYWdlRGljdChlKTtyPXIudGhlbigoKFt0LGFdKT0+bmV3IFBhZ2Uoe3BkZk1hbmFnZXI6dGhpcy5wZGZNYW5hZ2VyLHhyZWY6dGhpcy54cmVmLHBhZ2VJbmRleDplLHBhZ2VEaWN0OnQscmVmOmEsZ2xvYmFsSWRGYWN0b3J5OnRoaXMuX2dsb2JhbElkRmFjdG9yeSxmb250Q2FjaGU6aS5mb250Q2FjaGUsYnVpbHRJbkNNYXBDYWNoZTppLmJ1aWx0SW5DTWFwQ2FjaGUsc3RhbmRhcmRGb250RGF0YUNhY2hlOmkuc3RhbmRhcmRGb250RGF0YUNhY2hlLGdsb2JhbEltYWdlQ2FjaGU6aS5nbG9iYWxJbWFnZUNhY2hlLHN5c3RlbUZvbnRDYWNoZTppLnN5c3RlbUZvbnRDYWNoZSxub25CbGVuZE1vZGVzU2V0Omkubm9uQmxlbmRNb2Rlc1NldCx4ZmFGYWN0b3J5OnN9KSkpO3RoaXMuX3BhZ2VQcm9taXNlcy5zZXQoZSxyKTtyZXR1cm4gcn1hc3luYyBjaGVja0ZpcnN0UGFnZShlPSExKXtpZighZSl0cnl7YXdhaXQgdGhpcy5nZXRQYWdlKDApfWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBYUmVmRW50cnlFeGNlcHRpb24pe3RoaXMuX3BhZ2VQcm9taXNlcy5kZWxldGUoMCk7YXdhaXQgdGhpcy5jbGVhbnVwKCk7dGhyb3cgbmV3IFhSZWZQYXJzZUV4Y2VwdGlvbn19fWFzeW5jIGNoZWNrTGFzdFBhZ2UoZT0hMSl7Y29uc3R7Y2F0YWxvZzp0LHBkZk1hbmFnZXI6aX09dGhpczt0LnNldEFjdHVhbE51bVBhZ2VzKCk7bGV0IGE7dHJ5e2F3YWl0IFByb21pc2UuYWxsKFtpLmVuc3VyZURvYygieGZhRmFjdG9yeSIpLGkuZW5zdXJlRG9jKCJsaW5lYXJpemF0aW9uIiksaS5lbnN1cmVDYXRhbG9nKCJudW1QYWdlcyIpXSk7aWYodGhpcy54ZmFGYWN0b3J5KXJldHVybjthPXRoaXMubGluZWFyaXphdGlvbj90aGlzLmxpbmVhcml6YXRpb24ubnVtUGFnZXM6dC5udW1QYWdlcztpZighTnVtYmVyLmlzSW50ZWdlcihhKSl0aHJvdyBuZXcgRm9ybWF0RXJyb3IoIlBhZ2UgY291bnQgaXMgbm90IGFuIGludGVnZXIuIik7aWYoYTw9MSlyZXR1cm47YXdhaXQgdGhpcy5nZXRQYWdlKGEtMSl9Y2F0Y2gocyl7dGhpcy5fcGFnZVByb21pc2VzLmRlbGV0ZShhLTEpO2F3YWl0IHRoaXMuY2xlYW51cCgpO2lmKHMgaW5zdGFuY2VvZiBYUmVmRW50cnlFeGNlcHRpb24mJiFlKXRocm93IG5ldyBYUmVmUGFyc2VFeGNlcHRpb247d2FybihgY2hlY2tMYXN0UGFnZSAtIGludmFsaWQgL1BhZ2VzIHRyZWUgL0NvdW50OiAke2F9LmApO2xldCByO3RyeXtyPWF3YWl0IHQuZ2V0QWxsUGFnZURpY3RzKGUpfWNhdGNoKGkpe2lmKGkgaW5zdGFuY2VvZiBYUmVmRW50cnlFeGNlcHRpb24mJiFlKXRocm93IG5ldyBYUmVmUGFyc2VFeGNlcHRpb247dC5zZXRBY3R1YWxOdW1QYWdlcygxKTtyZXR1cm59Zm9yKGNvbnN0W2UsW2Esc11db2Ygcil7bGV0IHI7aWYoYSBpbnN0YW5jZW9mIEVycm9yKXtyPVByb21pc2UucmVqZWN0KGEpO3IuY2F0Y2goKCgpPT57fSkpfWVsc2Ugcj1Qcm9taXNlLnJlc29sdmUobmV3IFBhZ2Uoe3BkZk1hbmFnZXI6aSx4cmVmOnRoaXMueHJlZixwYWdlSW5kZXg6ZSxwYWdlRGljdDphLHJlZjpzLGdsb2JhbElkRmFjdG9yeTp0aGlzLl9nbG9iYWxJZEZhY3RvcnksZm9udENhY2hlOnQuZm9udENhY2hlLGJ1aWx0SW5DTWFwQ2FjaGU6dC5idWlsdEluQ01hcENhY2hlLHN0YW5kYXJkRm9udERhdGFDYWNoZTp0LnN0YW5kYXJkRm9udERhdGFDYWNoZSxnbG9iYWxJbWFnZUNhY2hlOnQuZ2xvYmFsSW1hZ2VDYWNoZSxzeXN0ZW1Gb250Q2FjaGU6dC5zeXN0ZW1Gb250Q2FjaGUsbm9uQmxlbmRNb2Rlc1NldDp0Lm5vbkJsZW5kTW9kZXNTZXQseGZhRmFjdG9yeTpudWxsfSkpO3RoaXMuX3BhZ2VQcm9taXNlcy5zZXQoZSxyKX10LnNldEFjdHVhbE51bVBhZ2VzKHIuc2l6ZSl9fWZvbnRGYWxsYmFjayhlLHQpe3JldHVybiB0aGlzLmNhdGFsb2cuZm9udEZhbGxiYWNrKGUsdCl9YXN5bmMgY2xlYW51cChlPSExKXtyZXR1cm4gdGhpcy5jYXRhbG9nP3RoaXMuY2F0YWxvZy5jbGVhbnVwKGUpOmNsZWFyR2xvYmFsQ2FjaGVzKCl9YXN5bmMjWShlLHQsaSxhLHMpe2NvbnN0e3hyZWY6cn09dGhpcztpZighKHQgaW5zdGFuY2VvZiBSZWYpfHxzLmhhcyh0KSlyZXR1cm47cy5wdXQodCk7Y29uc3Qgbj1hd2FpdCByLmZldGNoQXN5bmModCk7aWYoIShuIGluc3RhbmNlb2YgRGljdCkpcmV0dXJuO2lmKG4uaGFzKCJUIikpe2NvbnN0IHQ9c3RyaW5nVG9QREZTdHJpbmcoYXdhaXQgbi5nZXRBc3luYygiVCIpKTtlPSIiPT09ZT90OmAke2V9LiR7dH1gfWVsc2V7bGV0IHQ9bjtmb3IoOzspe3Q9dC5nZXRSYXcoIlBhcmVudCIpO2lmKHQgaW5zdGFuY2VvZiBSZWYpe2lmKHMuaGFzKHQpKWJyZWFrO3Q9YXdhaXQgci5mZXRjaEFzeW5jKHQpfWlmKCEodCBpbnN0YW5jZW9mIERpY3QpKWJyZWFrO2lmKHQuaGFzKCJUIikpe2NvbnN0IGk9c3RyaW5nVG9QREZTdHJpbmcoYXdhaXQgdC5nZXRBc3luYygiVCIpKTtlPSIiPT09ZT9pOmAke2V9LiR7aX1gO2JyZWFrfX19aS5oYXMoZSl8fGkuc2V0KGUsW10pO2kuZ2V0KGUpLnB1c2goQW5ub3RhdGlvbkZhY3RvcnkuY3JlYXRlKHIsdCxhLG51bGwsITAsbnVsbCkudGhlbigoZT0+ZT8uZ2V0RmllbGRPYmplY3QoKSkpLmNhdGNoKChmdW5jdGlvbihlKXt3YXJuKGAjY29sbGVjdEZpZWxkT2JqZWN0czogIiR7ZX0iLmApO3JldHVybiBudWxsfSkpKTtpZighbi5oYXMoIktpZHMiKSlyZXR1cm47Y29uc3Qgbz1hd2FpdCBuLmdldEFzeW5jKCJLaWRzIik7aWYoQXJyYXkuaXNBcnJheShvKSlmb3IoY29uc3QgdCBvZiBvKWF3YWl0IHRoaXMuI1koZSx0LGksYSxzKX1nZXQgZmllbGRPYmplY3RzKCl7aWYoIXRoaXMuZm9ybUluZm8uaGFzRmllbGRzKXJldHVybiBzaGFkb3codGhpcywiZmllbGRPYmplY3RzIixQcm9taXNlLnJlc29sdmUobnVsbCkpO3JldHVybiBzaGFkb3codGhpcywiZmllbGRPYmplY3RzIixQcm9taXNlLmFsbChbdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZURvYygiYW5ub3RhdGlvbkdsb2JhbHMiKSx0aGlzLnBkZk1hbmFnZXIuZW5zdXJlQ2F0YWxvZygiYWNyb0Zvcm0iKV0pLnRoZW4oKGFzeW5jKFtlLHRdKT0+e2lmKCFlKXJldHVybiBudWxsO2NvbnN0IGk9bmV3IFJlZlNldCxhPU9iamVjdC5jcmVhdGUobnVsbCkscz1uZXcgTWFwO2Zvcihjb25zdCBhIG9mIGF3YWl0IHQuZ2V0QXN5bmMoIkZpZWxkcyIpKWF3YWl0IHRoaXMuI1koIiIsYSxzLGUsaSk7Y29uc3Qgcj1bXTtmb3IoY29uc3RbZSx0XW9mIHMpci5wdXNoKFByb21pc2UuYWxsKHQpLnRoZW4oKHQ9PnsodD10LmZpbHRlcigoZT0+ISFlKSkpLmxlbmd0aD4wJiYoYVtlXT10KX0pKSk7YXdhaXQgUHJvbWlzZS5hbGwocik7cmV0dXJuIGF9KSkpfWdldCBoYXNKU0FjdGlvbnMoKXtyZXR1cm4gc2hhZG93KHRoaXMsImhhc0pTQWN0aW9ucyIsdGhpcy5wZGZNYW5hZ2VyLmVuc3VyZURvYygiX3BhcnNlSGFzSlNBY3Rpb25zIikpfWFzeW5jIF9wYXJzZUhhc0pTQWN0aW9ucygpe2NvbnN0W2UsdF09YXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGRmTWFuYWdlci5lbnN1cmVDYXRhbG9nKCJqc0FjdGlvbnMiKSx0aGlzLnBkZk1hbmFnZXIuZW5zdXJlRG9jKCJmaWVsZE9iamVjdHMiKV0pO3JldHVybiEhZXx8ISF0JiZPYmplY3QudmFsdWVzKHQpLnNvbWUoKGU9PmUuc29tZSgoZT0+bnVsbCE9PWUuYWN0aW9ucykpKSl9Z2V0IGNhbGN1bGF0aW9uT3JkZXJJZHMoKXtjb25zdCBlPXRoaXMuY2F0YWxvZy5hY3JvRm9ybTtpZighZT8uaGFzKCJDTyIpKXJldHVybiBzaGFkb3codGhpcywiY2FsY3VsYXRpb25PcmRlcklkcyIsbnVsbCk7Y29uc3QgdD1lLmdldCgiQ08iKTtpZighQXJyYXkuaXNBcnJheSh0KXx8MD09PXQubGVuZ3RoKXJldHVybiBzaGFkb3codGhpcywiY2FsY3VsYXRpb25PcmRlcklkcyIsbnVsbCk7Y29uc3QgaT1bXTtmb3IoY29uc3QgZSBvZiB0KWUgaW5zdGFuY2VvZiBSZWYmJmkucHVzaChlLnRvU3RyaW5nKCkpO3JldHVybiAwPT09aS5sZW5ndGg/c2hhZG93KHRoaXMsImNhbGN1bGF0aW9uT3JkZXJJZHMiLG51bGwpOnNoYWRvdyh0aGlzLCJjYWxjdWxhdGlvbk9yZGVySWRzIixpKX1nZXQgYW5ub3RhdGlvbkdsb2JhbHMoKXtyZXR1cm4gc2hhZG93KHRoaXMsImFubm90YXRpb25HbG9iYWxzIixBbm5vdGF0aW9uRmFjdG9yeS5jcmVhdGVHbG9iYWxzKHRoaXMucGRmTWFuYWdlcikpfX1jbGFzcyBCYXNlUGRmTWFuYWdlcntjb25zdHJ1Y3RvcihlKXt0aGlzLmNvbnN0cnVjdG9yPT09QmFzZVBkZk1hbmFnZXImJnVucmVhY2hhYmxlKCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlUGRmTWFuYWdlci4iKTt0aGlzLl9kb2NCYXNlVXJsPWZ1bmN0aW9uIHBhcnNlRG9jQmFzZVVybChlKXtpZihlKXtjb25zdCB0PWNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwoZSk7aWYodClyZXR1cm4gdC5ocmVmO3dhcm4oYEludmFsaWQgYWJzb2x1dGUgZG9jQmFzZVVybDogIiR7ZX0iLmApfXJldHVybiBudWxsfShlLmRvY0Jhc2VVcmwpO3RoaXMuX2RvY0lkPWUuZG9jSWQ7dGhpcy5fcGFzc3dvcmQ9ZS5wYXNzd29yZDt0aGlzLmVuYWJsZVhmYT1lLmVuYWJsZVhmYTtlLmV2YWx1YXRvck9wdGlvbnMuaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQmJj1GZWF0dXJlVGVzdC5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDt0aGlzLmV2YWx1YXRvck9wdGlvbnM9ZS5ldmFsdWF0b3JPcHRpb25zfWdldCBkb2NJZCgpe3JldHVybiB0aGlzLl9kb2NJZH1nZXQgcGFzc3dvcmQoKXtyZXR1cm4gdGhpcy5fcGFzc3dvcmR9Z2V0IGRvY0Jhc2VVcmwoKXtyZXR1cm4gdGhpcy5fZG9jQmFzZVVybH1nZXQgY2F0YWxvZygpe3JldHVybiB0aGlzLnBkZkRvY3VtZW50LmNhdGFsb2d9ZW5zdXJlRG9jKGUsdCl7cmV0dXJuIHRoaXMuZW5zdXJlKHRoaXMucGRmRG9jdW1lbnQsZSx0KX1lbnN1cmVYUmVmKGUsdCl7cmV0dXJuIHRoaXMuZW5zdXJlKHRoaXMucGRmRG9jdW1lbnQueHJlZixlLHQpfWVuc3VyZUNhdGFsb2coZSx0KXtyZXR1cm4gdGhpcy5lbnN1cmUodGhpcy5wZGZEb2N1bWVudC5jYXRhbG9nLGUsdCl9Z2V0UGFnZShlKXtyZXR1cm4gdGhpcy5wZGZEb2N1bWVudC5nZXRQYWdlKGUpfWZvbnRGYWxsYmFjayhlLHQpe3JldHVybiB0aGlzLnBkZkRvY3VtZW50LmZvbnRGYWxsYmFjayhlLHQpfWxvYWRYZmFGb250cyhlLHQpe3JldHVybiB0aGlzLnBkZkRvY3VtZW50LmxvYWRYZmFGb250cyhlLHQpfWxvYWRYZmFJbWFnZXMoKXtyZXR1cm4gdGhpcy5wZGZEb2N1bWVudC5sb2FkWGZhSW1hZ2VzKCl9c2VyaWFsaXplWGZhRGF0YShlKXtyZXR1cm4gdGhpcy5wZGZEb2N1bWVudC5zZXJpYWxpemVYZmFEYXRhKGUpfWNsZWFudXAoZT0hMSl7cmV0dXJuIHRoaXMucGRmRG9jdW1lbnQuY2xlYW51cChlKX1hc3luYyBlbnN1cmUoZSx0LGkpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYGVuc3VyZWAgY2FsbGVkIil9cmVxdWVzdFJhbmdlKGUsdCl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgcmVxdWVzdFJhbmdlYCBjYWxsZWQiKX1yZXF1ZXN0TG9hZGVkU3RyZWFtKGU9ITEpe3VucmVhY2hhYmxlKCJBYnN0cmFjdCBtZXRob2QgYHJlcXVlc3RMb2FkZWRTdHJlYW1gIGNhbGxlZCIpfXNlbmRQcm9ncmVzc2l2ZURhdGEoZSl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgc2VuZFByb2dyZXNzaXZlRGF0YWAgY2FsbGVkIil9dXBkYXRlUGFzc3dvcmQoZSl7dGhpcy5fcGFzc3dvcmQ9ZX10ZXJtaW5hdGUoZSl7dW5yZWFjaGFibGUoIkFic3RyYWN0IG1ldGhvZCBgdGVybWluYXRlYCBjYWxsZWQiKX19Y2xhc3MgTG9jYWxQZGZNYW5hZ2VyIGV4dGVuZHMgQmFzZVBkZk1hbmFnZXJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7Y29uc3QgdD1uZXcgU3RyZWFtKGUuc291cmNlKTt0aGlzLnBkZkRvY3VtZW50PW5ldyBQREZEb2N1bWVudCh0aGlzLHQpO3RoaXMuX2xvYWRlZFN0cmVhbVByb21pc2U9UHJvbWlzZS5yZXNvbHZlKHQpfWFzeW5jIGVuc3VyZShlLHQsaSl7Y29uc3QgYT1lW3RdO3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBhP2EuYXBwbHkoZSxpKTphfXJlcXVlc3RSYW5nZShlLHQpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKX1yZXF1ZXN0TG9hZGVkU3RyZWFtKGU9ITEpe3JldHVybiB0aGlzLl9sb2FkZWRTdHJlYW1Qcm9taXNlfXRlcm1pbmF0ZShlKXt9fWNsYXNzIE5ldHdvcmtQZGZNYW5hZ2VyIGV4dGVuZHMgQmFzZVBkZk1hbmFnZXJ7Y29uc3RydWN0b3IoZSl7c3VwZXIoZSk7dGhpcy5zdHJlYW1NYW5hZ2VyPW5ldyBDaHVua2VkU3RyZWFtTWFuYWdlcihlLnNvdXJjZSx7bXNnSGFuZGxlcjplLmhhbmRsZXIsbGVuZ3RoOmUubGVuZ3RoLGRpc2FibGVBdXRvRmV0Y2g6ZS5kaXNhYmxlQXV0b0ZldGNoLHJhbmdlQ2h1bmtTaXplOmUucmFuZ2VDaHVua1NpemV9KTt0aGlzLnBkZkRvY3VtZW50PW5ldyBQREZEb2N1bWVudCh0aGlzLHRoaXMuc3RyZWFtTWFuYWdlci5nZXRTdHJlYW0oKSl9YXN5bmMgZW5zdXJlKGUsdCxpKXt0cnl7Y29uc3QgYT1lW3RdO3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBhP2EuYXBwbHkoZSxpKTphfWNhdGNoKGEpe2lmKCEoYSBpbnN0YW5jZW9mIE1pc3NpbmdEYXRhRXhjZXB0aW9uKSl0aHJvdyBhO2F3YWl0IHRoaXMucmVxdWVzdFJhbmdlKGEuYmVnaW4sYS5lbmQpO3JldHVybiB0aGlzLmVuc3VyZShlLHQsaSl9fXJlcXVlc3RSYW5nZShlLHQpe3JldHVybiB0aGlzLnN0cmVhbU1hbmFnZXIucmVxdWVzdFJhbmdlKGUsdCl9cmVxdWVzdExvYWRlZFN0cmVhbShlPSExKXtyZXR1cm4gdGhpcy5zdHJlYW1NYW5hZ2VyLnJlcXVlc3RBbGxDaHVua3MoZSl9c2VuZFByb2dyZXNzaXZlRGF0YShlKXt0aGlzLnN0cmVhbU1hbmFnZXIub25SZWNlaXZlRGF0YSh7Y2h1bms6ZX0pfXRlcm1pbmF0ZShlKXt0aGlzLnN0cmVhbU1hbmFnZXIuYWJvcnQoZSl9fWNvbnN0IGdvPTEsSW89Mixjbz0xLENvPTIsaG89Myxsbz00LEJvPTUsUW89NixFbz03LHVvPTg7ZnVuY3Rpb24gd3JhcFJlYXNvbihlKXtlIGluc3RhbmNlb2YgRXJyb3J8fCJvYmplY3QiPT10eXBlb2YgZSYmbnVsbCE9PWV8fHVucmVhY2hhYmxlKCd3cmFwUmVhc29uOiBFeHBlY3RlZCAicmVhc29uIiB0byBiZSBhIChwb3NzaWJseSBjbG9uZWQpIEVycm9yLicpO3N3aXRjaChlLm5hbWUpe2Nhc2UiQWJvcnRFeGNlcHRpb24iOnJldHVybiBuZXcgQWJvcnRFeGNlcHRpb24oZS5tZXNzYWdlKTtjYXNlIk1pc3NpbmdQREZFeGNlcHRpb24iOnJldHVybiBuZXcgTWlzc2luZ1BERkV4Y2VwdGlvbihlLm1lc3NhZ2UpO2Nhc2UiUGFzc3dvcmRFeGNlcHRpb24iOnJldHVybiBuZXcgUGFzc3dvcmRFeGNlcHRpb24oZS5tZXNzYWdlLGUuY29kZSk7Y2FzZSJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24iOnJldHVybiBuZXcgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKGUubWVzc2FnZSxlLnN0YXR1cyk7Y2FzZSJVbmtub3duRXJyb3JFeGNlcHRpb24iOnJldHVybiBuZXcgVW5rbm93bkVycm9yRXhjZXB0aW9uKGUubWVzc2FnZSxlLmRldGFpbHMpO2RlZmF1bHQ6cmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZS5tZXNzYWdlLGUudG9TdHJpbmcoKSl9fWNsYXNzIE1lc3NhZ2VIYW5kbGVye2NvbnN0cnVjdG9yKGUsdCxpKXt0aGlzLnNvdXJjZU5hbWU9ZTt0aGlzLnRhcmdldE5hbWU9dDt0aGlzLmNvbU9iaj1pO3RoaXMuY2FsbGJhY2tJZD0xO3RoaXMuc3RyZWFtSWQ9MTt0aGlzLnN0cmVhbVNpbmtzPU9iamVjdC5jcmVhdGUobnVsbCk7dGhpcy5zdHJlYW1Db250cm9sbGVycz1PYmplY3QuY3JlYXRlKG51bGwpO3RoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXM9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLmFjdGlvbkhhbmRsZXI9T2JqZWN0LmNyZWF0ZShudWxsKTt0aGlzLl9vbkNvbU9iak9uTWVzc2FnZT1lPT57Y29uc3QgdD1lLmRhdGE7aWYodC50YXJnZXROYW1lIT09dGhpcy5zb3VyY2VOYW1lKXJldHVybjtpZih0LnN0cmVhbSl7dGhpcy4jdih0KTtyZXR1cm59aWYodC5jYWxsYmFjayl7Y29uc3QgZT10LmNhbGxiYWNrSWQsaT10aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2VdO2lmKCFpKXRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtlfWApO2RlbGV0ZSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2VdO2lmKHQuY2FsbGJhY2s9PT1nbylpLnJlc29sdmUodC5kYXRhKTtlbHNle2lmKHQuY2FsbGJhY2shPT1Jbyl0aHJvdyBuZXcgRXJyb3IoIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZSIpO2kucmVqZWN0KHdyYXBSZWFzb24odC5yZWFzb24pKX1yZXR1cm59Y29uc3QgYT10aGlzLmFjdGlvbkhhbmRsZXJbdC5hY3Rpb25dO2lmKCFhKXRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7dC5hY3Rpb259YCk7aWYodC5jYWxsYmFja0lkKXtjb25zdCBlPXRoaXMuc291cmNlTmFtZSxzPXQuc291cmNlTmFtZTtuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7ZShhKHQuZGF0YSkpfSkpLnRoZW4oKGZ1bmN0aW9uKGEpe2kucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6ZSx0YXJnZXROYW1lOnMsY2FsbGJhY2s6Z28sY2FsbGJhY2tJZDp0LmNhbGxiYWNrSWQsZGF0YTphfSl9KSwoZnVuY3Rpb24oYSl7aS5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTplLHRhcmdldE5hbWU6cyxjYWxsYmFjazpJbyxjYWxsYmFja0lkOnQuY2FsbGJhY2tJZCxyZWFzb246d3JhcFJlYXNvbihhKX0pfSkpfWVsc2UgdC5zdHJlYW1JZD90aGlzLiNLKHQpOmEodC5kYXRhKX07aS5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIix0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSl9b24oZSx0KXtjb25zdCBpPXRoaXMuYWN0aW9uSGFuZGxlcjtpZihpW2VdKXRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCAiJHtlfSJgKTtpW2VdPXR9c2VuZChlLHQsaSl7dGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6dGhpcy5zb3VyY2VOYW1lLHRhcmdldE5hbWU6dGhpcy50YXJnZXROYW1lLGFjdGlvbjplLGRhdGE6dH0saSl9c2VuZFdpdGhQcm9taXNlKGUsdCxpKXtjb25zdCBhPXRoaXMuY2FsbGJhY2tJZCsrLHM9UHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7dGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1thXT1zO3RyeXt0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTp0aGlzLnNvdXJjZU5hbWUsdGFyZ2V0TmFtZTp0aGlzLnRhcmdldE5hbWUsYWN0aW9uOmUsY2FsbGJhY2tJZDphLGRhdGE6dH0saSl9Y2F0Y2goZSl7cy5yZWplY3QoZSl9cmV0dXJuIHMucHJvbWlzZX1zZW5kV2l0aFN0cmVhbShlLHQsaSxhKXtjb25zdCBzPXRoaXMuc3RyZWFtSWQrKyxyPXRoaXMuc291cmNlTmFtZSxuPXRoaXMudGFyZ2V0TmFtZSxvPXRoaXMuY29tT2JqO3JldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe3N0YXJ0Omk9Pntjb25zdCBnPVByb21pc2Uud2l0aFJlc29sdmVycygpO3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbc109e2NvbnRyb2xsZXI6aSxzdGFydENhbGw6ZyxwdWxsQ2FsbDpudWxsLGNhbmNlbENhbGw6bnVsbCxpc0Nsb3NlZDohMX07by5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTpyLHRhcmdldE5hbWU6bixhY3Rpb246ZSxzdHJlYW1JZDpzLGRhdGE6dCxkZXNpcmVkU2l6ZTppLmRlc2lyZWRTaXplfSxhKTtyZXR1cm4gZy5wcm9taXNlfSxwdWxsOmU9Pntjb25zdCB0PVByb21pc2Uud2l0aFJlc29sdmVycygpO3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbc10ucHVsbENhbGw9dDtvLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOnIsdGFyZ2V0TmFtZTpuLHN0cmVhbTpRbyxzdHJlYW1JZDpzLGRlc2lyZWRTaXplOmUuZGVzaXJlZFNpemV9KTtyZXR1cm4gdC5wcm9taXNlfSxjYW5jZWw6ZT0+e2Fzc2VydChlIGluc3RhbmNlb2YgRXJyb3IsImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb24iKTtjb25zdCB0PVByb21pc2Uud2l0aFJlc29sdmVycygpO3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbc10uY2FuY2VsQ2FsbD10O3RoaXMuc3RyZWFtQ29udHJvbGxlcnNbc10uaXNDbG9zZWQ9ITA7by5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTpyLHRhcmdldE5hbWU6bixzdHJlYW06Y28sc3RyZWFtSWQ6cyxyZWFzb246d3JhcFJlYXNvbihlKX0pO3JldHVybiB0LnByb21pc2V9fSxpKX0jSyhlKXtjb25zdCB0PWUuc3RyZWFtSWQsaT10aGlzLnNvdXJjZU5hbWUsYT1lLnNvdXJjZU5hbWUscz10aGlzLmNvbU9iaixyPXRoaXMsbj10aGlzLmFjdGlvbkhhbmRsZXJbZS5hY3Rpb25dLG89e2VucXVldWUoZSxyPTEsbil7aWYodGhpcy5pc0NhbmNlbGxlZClyZXR1cm47Y29uc3Qgbz10aGlzLmRlc2lyZWRTaXplO3RoaXMuZGVzaXJlZFNpemUtPXI7aWYobz4wJiZ0aGlzLmRlc2lyZWRTaXplPD0wKXt0aGlzLnNpbmtDYXBhYmlsaXR5PVByb21pc2Uud2l0aFJlc29sdmVycygpO3RoaXMucmVhZHk9dGhpcy5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlfXMucG9zdE1lc3NhZ2Uoe3NvdXJjZU5hbWU6aSx0YXJnZXROYW1lOmEsc3RyZWFtOmxvLHN0cmVhbUlkOnQsY2h1bms6ZX0sbil9LGNsb3NlKCl7aWYoIXRoaXMuaXNDYW5jZWxsZWQpe3RoaXMuaXNDYW5jZWxsZWQ9ITA7cy5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTppLHRhcmdldE5hbWU6YSxzdHJlYW06aG8sc3RyZWFtSWQ6dH0pO2RlbGV0ZSByLnN0cmVhbVNpbmtzW3RdfX0sZXJyb3IoZSl7YXNzZXJ0KGUgaW5zdGFuY2VvZiBFcnJvciwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uIik7aWYoIXRoaXMuaXNDYW5jZWxsZWQpe3RoaXMuaXNDYW5jZWxsZWQ9ITA7cy5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTppLHRhcmdldE5hbWU6YSxzdHJlYW06Qm8sc3RyZWFtSWQ6dCxyZWFzb246d3JhcFJlYXNvbihlKX0pfX0sc2lua0NhcGFiaWxpdHk6UHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksb25QdWxsOm51bGwsb25DYW5jZWw6bnVsbCxpc0NhbmNlbGxlZDohMSxkZXNpcmVkU2l6ZTplLmRlc2lyZWRTaXplLHJlYWR5Om51bGx9O28uc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO28ucmVhZHk9by5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO3RoaXMuc3RyZWFtU2lua3NbdF09bztuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7dChuKGUuZGF0YSxvKSl9KSkudGhlbigoZnVuY3Rpb24oKXtzLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmksdGFyZ2V0TmFtZTphLHN0cmVhbTp1byxzdHJlYW1JZDp0LHN1Y2Nlc3M6ITB9KX0pLChmdW5jdGlvbihlKXtzLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmksdGFyZ2V0TmFtZTphLHN0cmVhbTp1byxzdHJlYW1JZDp0LHJlYXNvbjp3cmFwUmVhc29uKGUpfSl9KSl9I3YoZSl7Y29uc3QgdD1lLnN0cmVhbUlkLGk9dGhpcy5zb3VyY2VOYW1lLGE9ZS5zb3VyY2VOYW1lLHM9dGhpcy5jb21PYmoscj10aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3RdLG49dGhpcy5zdHJlYW1TaW5rc1t0XTtzd2l0Y2goZS5zdHJlYW0pe2Nhc2UgdW86ZS5zdWNjZXNzP3Iuc3RhcnRDYWxsLnJlc29sdmUoKTpyLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihlLnJlYXNvbikpO2JyZWFrO2Nhc2UgRW86ZS5zdWNjZXNzP3IucHVsbENhbGwucmVzb2x2ZSgpOnIucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZS5yZWFzb24pKTticmVhaztjYXNlIFFvOmlmKCFuKXtzLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmksdGFyZ2V0TmFtZTphLHN0cmVhbTpFbyxzdHJlYW1JZDp0LHN1Y2Nlc3M6ITB9KTticmVha31uLmRlc2lyZWRTaXplPD0wJiZlLmRlc2lyZWRTaXplPjAmJm4uc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO24uZGVzaXJlZFNpemU9ZS5kZXNpcmVkU2l6ZTtuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7ZShuLm9uUHVsbD8uKCkpfSkpLnRoZW4oKGZ1bmN0aW9uKCl7cy5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTppLHRhcmdldE5hbWU6YSxzdHJlYW06RW8sc3RyZWFtSWQ6dCxzdWNjZXNzOiEwfSl9KSwoZnVuY3Rpb24oZSl7cy5wb3N0TWVzc2FnZSh7c291cmNlTmFtZTppLHRhcmdldE5hbWU6YSxzdHJlYW06RW8sc3RyZWFtSWQ6dCxyZWFzb246d3JhcFJlYXNvbihlKX0pfSkpO2JyZWFrO2Nhc2UgbG86YXNzZXJ0KHIsImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXIiKTtpZihyLmlzQ2xvc2VkKWJyZWFrO3IuY29udHJvbGxlci5lbnF1ZXVlKGUuY2h1bmspO2JyZWFrO2Nhc2UgaG86YXNzZXJ0KHIsImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyIik7aWYoci5pc0Nsb3NlZClicmVhaztyLmlzQ2xvc2VkPSEwO3IuY29udHJvbGxlci5jbG9zZSgpO3RoaXMuI1Qocix0KTticmVhaztjYXNlIEJvOmFzc2VydChyLCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlciIpO3IuY29udHJvbGxlci5lcnJvcih3cmFwUmVhc29uKGUucmVhc29uKSk7dGhpcy4jVChyLHQpO2JyZWFrO2Nhc2UgQ286ZS5zdWNjZXNzP3IuY2FuY2VsQ2FsbC5yZXNvbHZlKCk6ci5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGUucmVhc29uKSk7dGhpcy4jVChyLHQpO2JyZWFrO2Nhc2UgY286aWYoIW4pYnJlYWs7bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe3Qobi5vbkNhbmNlbD8uKHdyYXBSZWFzb24oZS5yZWFzb24pKSl9KSkudGhlbigoZnVuY3Rpb24oKXtzLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmksdGFyZ2V0TmFtZTphLHN0cmVhbTpDbyxzdHJlYW1JZDp0LHN1Y2Nlc3M6ITB9KX0pLChmdW5jdGlvbihlKXtzLnBvc3RNZXNzYWdlKHtzb3VyY2VOYW1lOmksdGFyZ2V0TmFtZTphLHN0cmVhbTpDbyxzdHJlYW1JZDp0LHJlYXNvbjp3cmFwUmVhc29uKGUpfSl9KSk7bi5zaW5rQ2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihlLnJlYXNvbikpO24uaXNDYW5jZWxsZWQ9ITA7ZGVsZXRlIHRoaXMuc3RyZWFtU2lua3NbdF07YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2UiKX19YXN5bmMjVChlLHQpe2F3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbZS5zdGFydENhbGw/LnByb21pc2UsZS5wdWxsQ2FsbD8ucHJvbWlzZSxlLmNhbmNlbENhbGw/LnByb21pc2VdKTtkZWxldGUgdGhpcy5zdHJlYW1Db250cm9sbGVyc1t0XX1kZXN0cm95KCl7dGhpcy5jb21PYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpfX1jbGFzcyBQREZXb3JrZXJTdHJlYW17Y29uc3RydWN0b3IoZSl7dGhpcy5fbXNnSGFuZGxlcj1lO3RoaXMuX2NvbnRlbnRMZW5ndGg9bnVsbDt0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj1udWxsO3RoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnM9W119Z2V0RnVsbFJlYWRlcigpe2Fzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIlBERldvcmtlclN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLiIpO3RoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPW5ldyBQREZXb3JrZXJTdHJlYW1SZWFkZXIodGhpcy5fbXNnSGFuZGxlcik7cmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyfWdldFJhbmdlUmVhZGVyKGUsdCl7Y29uc3QgaT1uZXcgUERGV29ya2VyU3RyZWFtUmFuZ2VSZWFkZXIoZSx0LHRoaXMuX21zZ0hhbmRsZXIpO3RoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChpKTtyZXR1cm4gaX1jYW5jZWxBbGxSZXF1ZXN0cyhlKXt0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKGUpO2Zvcihjb25zdCB0IG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpdC5jYW5jZWwoZSl9fWNsYXNzIFBERldvcmtlclN0cmVhbVJlYWRlcntjb25zdHJ1Y3RvcihlKXt0aGlzLl9tc2dIYW5kbGVyPWU7dGhpcy5vblByb2dyZXNzPW51bGw7dGhpcy5fY29udGVudExlbmd0aD1udWxsO3RoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ9ITE7dGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ9ITE7Y29uc3QgdD10aGlzLl9tc2dIYW5kbGVyLnNlbmRXaXRoU3RyZWFtKCJHZXRSZWFkZXIiKTt0aGlzLl9yZWFkZXI9dC5nZXRSZWFkZXIoKTt0aGlzLl9oZWFkZXJzUmVhZHk9dGhpcy5fbXNnSGFuZGxlci5zZW5kV2l0aFByb21pc2UoIlJlYWRlckhlYWRlcnNSZWFkeSIpLnRoZW4oKGU9Pnt0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZD1lLmlzU3RyZWFtaW5nU3VwcG9ydGVkO3RoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ9ZS5pc1JhbmdlU3VwcG9ydGVkO3RoaXMuX2NvbnRlbnRMZW5ndGg9ZS5jb250ZW50TGVuZ3RofSkpfWdldCBoZWFkZXJzUmVhZHkoKXtyZXR1cm4gdGhpcy5faGVhZGVyc1JlYWR5fWdldCBjb250ZW50TGVuZ3RoKCl7cmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGh9Z2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCl7cmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkfWdldCBpc1JhbmdlU3VwcG9ydGVkKCl7cmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWR9YXN5bmMgcmVhZCgpe2NvbnN0e3ZhbHVlOmUsZG9uZTp0fT1hd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO3JldHVybiB0P3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06e3ZhbHVlOmUuYnVmZmVyLGRvbmU6ITF9fWNhbmNlbChlKXt0aGlzLl9yZWFkZXIuY2FuY2VsKGUpfX1jbGFzcyBQREZXb3JrZXJTdHJlYW1SYW5nZVJlYWRlcntjb25zdHJ1Y3RvcihlLHQsaSl7dGhpcy5fbXNnSGFuZGxlcj1pO3RoaXMub25Qcm9ncmVzcz1udWxsO2NvbnN0IGE9dGhpcy5fbXNnSGFuZGxlci5zZW5kV2l0aFN0cmVhbSgiR2V0UmFuZ2VSZWFkZXIiLHtiZWdpbjplLGVuZDp0fSk7dGhpcy5fcmVhZGVyPWEuZ2V0UmVhZGVyKCl9Z2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCl7cmV0dXJuITF9YXN5bmMgcmVhZCgpe2NvbnN0e3ZhbHVlOmUsZG9uZTp0fT1hd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO3JldHVybiB0P3t2YWx1ZTp2b2lkIDAsZG9uZTohMH06e3ZhbHVlOmUuYnVmZmVyLGRvbmU6ITF9fWNhbmNlbChlKXt0aGlzLl9yZWFkZXIuY2FuY2VsKGUpfX1jbGFzcyBXb3JrZXJUYXNre2NvbnN0cnVjdG9yKGUpe3RoaXMubmFtZT1lO3RoaXMudGVybWluYXRlZD0hMTt0aGlzLl9jYXBhYmlsaXR5PVByb21pc2Uud2l0aFJlc29sdmVycygpfWdldCBmaW5pc2hlZCgpe3JldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2V9ZmluaXNoKCl7dGhpcy5fY2FwYWJpbGl0eS5yZXNvbHZlKCl9dGVybWluYXRlKCl7dGhpcy50ZXJtaW5hdGVkPSEwfWVuc3VyZU5vdFRlcm1pbmF0ZWQoKXtpZih0aGlzLnRlcm1pbmF0ZWQpdGhyb3cgbmV3IEVycm9yKCJXb3JrZXIgdGFzayB3YXMgdGVybWluYXRlZCIpfX1jbGFzcyBXb3JrZXJNZXNzYWdlSGFuZGxlcntzdGF0aWMgc2V0dXAoZSx0KXtsZXQgaT0hMTtlLm9uKCJ0ZXN0IiwoZnVuY3Rpb24odCl7aWYoIWkpe2k9ITA7ZS5zZW5kKCJ0ZXN0Iix0IGluc3RhbmNlb2YgVWludDhBcnJheSl9fSkpO2Uub24oImNvbmZpZ3VyZSIsKGZ1bmN0aW9uKGUpeyFmdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChlKXtOdW1iZXIuaXNJbnRlZ2VyKGUpJiYoc3Q9ZSl9KGUudmVyYm9zaXR5KX0pKTtlLm9uKCJHZXREb2NSZXF1ZXN0IiwoZnVuY3Rpb24oZSl7cmV0dXJuIFdvcmtlck1lc3NhZ2VIYW5kbGVyLmNyZWF0ZURvY3VtZW50SGFuZGxlcihlLHQpfSkpfXN0YXRpYyBjcmVhdGVEb2N1bWVudEhhbmRsZXIoZSx0KXtsZXQgaSxhPSExLHM9bnVsbDtjb25zdCByPW5ldyBTZXQsbj1nZXRWZXJib3NpdHlMZXZlbCgpLHtkb2NJZDpvLGFwaVZlcnNpb246Z309ZSxjPSI0LjIuNjciO2lmKGchPT1jKXRocm93IG5ldyBFcnJvcihgVGhlIEFQSSB2ZXJzaW9uICIke2d9IiBkb2VzIG5vdCBtYXRjaCB0aGUgV29ya2VyIHZlcnNpb24gIiR7Y30iLmApO2NvbnN0IEM9W107Zm9yKGNvbnN0IGUgaW5bXSlDLnB1c2goZSk7aWYoQy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCJUaGUgYEFycmF5LnByb3RvdHlwZWAgY29udGFpbnMgdW5leHBlY3RlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXM6ICIrQy5qb2luKCIsICIpKyI7IHRodXMgYnJlYWtpbmcgZS5nLiBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBvZiBgQXJyYXlgcy4iKTtjb25zdCBoPW8rIl93b3JrZXIiO2xldCBsPW5ldyBNZXNzYWdlSGFuZGxlcihoLG8sdCk7ZnVuY3Rpb24gZW5zdXJlTm90VGVybWluYXRlZCgpe2lmKGEpdGhyb3cgbmV3IEVycm9yKCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQiKX1mdW5jdGlvbiBzdGFydFdvcmtlclRhc2soZSl7ci5hZGQoZSl9ZnVuY3Rpb24gZmluaXNoV29ya2VyVGFzayhlKXtlLmZpbmlzaCgpO3IuZGVsZXRlKGUpfWFzeW5jIGZ1bmN0aW9uIGxvYWREb2N1bWVudChlKXthd2FpdCBpLmVuc3VyZURvYygiY2hlY2tIZWFkZXIiKTthd2FpdCBpLmVuc3VyZURvYygicGFyc2VTdGFydFhSZWYiKTthd2FpdCBpLmVuc3VyZURvYygicGFyc2UiLFtlXSk7YXdhaXQgaS5lbnN1cmVEb2MoImNoZWNrRmlyc3RQYWdlIixbZV0pO2F3YWl0IGkuZW5zdXJlRG9jKCJjaGVja0xhc3RQYWdlIixbZV0pO2NvbnN0IHQ9YXdhaXQgaS5lbnN1cmVEb2MoImlzUHVyZVhmYSIpO2lmKHQpe2NvbnN0IGU9bmV3IFdvcmtlclRhc2soImxvYWRYZmFGb250cyIpO3N0YXJ0V29ya2VyVGFzayhlKTthd2FpdCBQcm9taXNlLmFsbChbaS5sb2FkWGZhRm9udHMobCxlKS5jYXRjaCgoZT0+e30pKS50aGVuKCgoKT0+ZmluaXNoV29ya2VyVGFzayhlKSkpLGkubG9hZFhmYUltYWdlcygpXSl9Y29uc3RbYSxzXT1hd2FpdCBQcm9taXNlLmFsbChbaS5lbnN1cmVEb2MoIm51bVBhZ2VzIiksaS5lbnN1cmVEb2MoImZpbmdlcnByaW50cyIpXSk7cmV0dXJue251bVBhZ2VzOmEsZmluZ2VycHJpbnRzOnMsaHRtbEZvclhmYTp0P2F3YWl0IGkuZW5zdXJlRG9jKCJodG1sRm9yWGZhIik6bnVsbH19ZnVuY3Rpb24gZ2V0UGRmTWFuYWdlcih7ZGF0YTplLHBhc3N3b3JkOnQsZGlzYWJsZUF1dG9GZXRjaDppLHJhbmdlQ2h1bmtTaXplOmEsbGVuZ3RoOnIsZG9jQmFzZVVybDpuLGVuYWJsZVhmYTpnLGV2YWx1YXRvck9wdGlvbnM6Y30pe2NvbnN0IEM9e3NvdXJjZTpudWxsLGRpc2FibGVBdXRvRmV0Y2g6aSxkb2NCYXNlVXJsOm4sZG9jSWQ6byxlbmFibGVYZmE6ZyxldmFsdWF0b3JPcHRpb25zOmMsaGFuZGxlcjpsLGxlbmd0aDpyLHBhc3N3b3JkOnQscmFuZ2VDaHVua1NpemU6YX0saD1Qcm9taXNlLndpdGhSZXNvbHZlcnMoKTtsZXQgUTtpZihlKXt0cnl7Qy5zb3VyY2U9ZTtRPW5ldyBMb2NhbFBkZk1hbmFnZXIoQyk7aC5yZXNvbHZlKFEpfWNhdGNoKGUpe2gucmVqZWN0KGUpfXJldHVybiBoLnByb21pc2V9bGV0IEUsdT1bXTt0cnl7RT1uZXcgUERGV29ya2VyU3RyZWFtKGwpfWNhdGNoKGUpe2gucmVqZWN0KGUpO3JldHVybiBoLnByb21pc2V9Y29uc3QgZD1FLmdldEZ1bGxSZWFkZXIoKTtkLmhlYWRlcnNSZWFkeS50aGVuKChmdW5jdGlvbigpe2lmKGQuaXNSYW5nZVN1cHBvcnRlZCl7Qy5zb3VyY2U9RTtDLmxlbmd0aD1kLmNvbnRlbnRMZW5ndGg7Qy5kaXNhYmxlQXV0b0ZldGNofHw9ZC5pc1N0cmVhbWluZ1N1cHBvcnRlZDtRPW5ldyBOZXR3b3JrUGRmTWFuYWdlcihDKTtmb3IoY29uc3QgZSBvZiB1KVEuc2VuZFByb2dyZXNzaXZlRGF0YShlKTt1PVtdO2gucmVzb2x2ZShRKTtzPW51bGx9fSkpLmNhdGNoKChmdW5jdGlvbihlKXtoLnJlamVjdChlKTtzPW51bGx9KSk7bGV0IGY9MDtuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSx0KXtjb25zdCByZWFkQ2h1bms9ZnVuY3Rpb24oe3ZhbHVlOmUsZG9uZTppfSl7dHJ5e2Vuc3VyZU5vdFRlcm1pbmF0ZWQoKTtpZihpKXtRfHxmdW5jdGlvbigpe2NvbnN0IGU9YXJyYXlCdWZmZXJzVG9CeXRlcyh1KTtyJiZlLmxlbmd0aCE9PXImJndhcm4oInJlcG9ydGVkIEhUVFAgbGVuZ3RoIGlzIGRpZmZlcmVudCBmcm9tIGFjdHVhbCIpO3RyeXtDLnNvdXJjZT1lO1E9bmV3IExvY2FsUGRmTWFuYWdlcihDKTtoLnJlc29sdmUoUSl9Y2F0Y2goZSl7aC5yZWplY3QoZSl9dT1bXX0oKTtzPW51bGw7cmV0dXJufWYrPWUuYnl0ZUxlbmd0aDtkLmlzU3RyZWFtaW5nU3VwcG9ydGVkfHxsLnNlbmQoIkRvY1Byb2dyZXNzIix7bG9hZGVkOmYsdG90YWw6TWF0aC5tYXgoZixkLmNvbnRlbnRMZW5ndGh8fDApfSk7UT9RLnNlbmRQcm9ncmVzc2l2ZURhdGEoZSk6dS5wdXNoKGUpO2QucmVhZCgpLnRoZW4ocmVhZENodW5rLHQpfWNhdGNoKGUpe3QoZSl9fTtkLnJlYWQoKS50aGVuKHJlYWRDaHVuayx0KX0pKS5jYXRjaCgoZnVuY3Rpb24oZSl7aC5yZWplY3QoZSk7cz1udWxsfSkpO3M9ZnVuY3Rpb24oZSl7RS5jYW5jZWxBbGxSZXF1ZXN0cyhlKX07cmV0dXJuIGgucHJvbWlzZX1sLm9uKCJHZXRQYWdlIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGkuZ2V0UGFnZShlLnBhZ2VJbmRleCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIFByb21pc2UuYWxsKFtpLmVuc3VyZShlLCJyb3RhdGUiKSxpLmVuc3VyZShlLCJyZWYiKSxpLmVuc3VyZShlLCJ1c2VyVW5pdCIpLGkuZW5zdXJlKGUsInZpZXciKV0pLnRoZW4oKGZ1bmN0aW9uKFtlLHQsaSxhXSl7cmV0dXJue3JvdGF0ZTplLHJlZjp0LHJlZlN0cjp0Py50b1N0cmluZygpPz9udWxsLHVzZXJVbml0OmksdmlldzphfX0pKX0pKX0pKTtsLm9uKCJHZXRQYWdlSW5kZXgiLChmdW5jdGlvbihlKXtjb25zdCB0PVJlZi5nZXQoZS5udW0sZS5nZW4pO3JldHVybiBpLmVuc3VyZUNhdGFsb2coImdldFBhZ2VJbmRleCIsW3RdKX0pKTtsLm9uKCJHZXREZXN0aW5hdGlvbnMiLChmdW5jdGlvbihlKXtyZXR1cm4gaS5lbnN1cmVDYXRhbG9nKCJkZXN0aW5hdGlvbnMiKX0pKTtsLm9uKCJHZXREZXN0aW5hdGlvbiIsKGZ1bmN0aW9uKGUpe3JldHVybiBpLmVuc3VyZUNhdGFsb2coImdldERlc3RpbmF0aW9uIixbZS5pZF0pfSkpO2wub24oIkdldFBhZ2VMYWJlbHMiLChmdW5jdGlvbihlKXtyZXR1cm4gaS5lbnN1cmVDYXRhbG9nKCJwYWdlTGFiZWxzIil9KSk7bC5vbigiR2V0UGFnZUxheW91dCIsKGZ1bmN0aW9uKGUpe3JldHVybiBpLmVuc3VyZUNhdGFsb2coInBhZ2VMYXlvdXQiKX0pKTtsLm9uKCJHZXRQYWdlTW9kZSIsKGZ1bmN0aW9uKGUpe3JldHVybiBpLmVuc3VyZUNhdGFsb2coInBhZ2VNb2RlIil9KSk7bC5vbigiR2V0Vmlld2VyUHJlZmVyZW5jZXMiLChmdW5jdGlvbihlKXtyZXR1cm4gaS5lbnN1cmVDYXRhbG9nKCJ2aWV3ZXJQcmVmZXJlbmNlcyIpfSkpO2wub24oIkdldE9wZW5BY3Rpb24iLChmdW5jdGlvbihlKXtyZXR1cm4gaS5lbnN1cmVDYXRhbG9nKCJvcGVuQWN0aW9uIil9KSk7bC5vbigiR2V0QXR0YWNobWVudHMiLChmdW5jdGlvbihlKXtyZXR1cm4gaS5lbnN1cmVDYXRhbG9nKCJhdHRhY2htZW50cyIpfSkpO2wub24oIkdldERvY0pTQWN0aW9ucyIsKGZ1bmN0aW9uKGUpe3JldHVybiBpLmVuc3VyZUNhdGFsb2coImpzQWN0aW9ucyIpfSkpO2wub24oIkdldFBhZ2VKU0FjdGlvbnMiLChmdW5jdGlvbih7cGFnZUluZGV4OmV9KXtyZXR1cm4gaS5nZXRQYWdlKGUpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBpLmVuc3VyZShlLCJqc0FjdGlvbnMiKX0pKX0pKTtsLm9uKCJHZXRPdXRsaW5lIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGkuZW5zdXJlQ2F0YWxvZygiZG9jdW1lbnRPdXRsaW5lIil9KSk7bC5vbigiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGkuZW5zdXJlQ2F0YWxvZygib3B0aW9uYWxDb250ZW50Q29uZmlnIil9KSk7bC5vbigiR2V0UGVybWlzc2lvbnMiLChmdW5jdGlvbihlKXtyZXR1cm4gaS5lbnN1cmVDYXRhbG9nKCJwZXJtaXNzaW9ucyIpfSkpO2wub24oIkdldE1ldGFkYXRhIiwoZnVuY3Rpb24oZSl7cmV0dXJuIFByb21pc2UuYWxsKFtpLmVuc3VyZURvYygiZG9jdW1lbnRJbmZvIiksaS5lbnN1cmVDYXRhbG9nKCJtZXRhZGF0YSIpXSl9KSk7bC5vbigiR2V0TWFya0luZm8iLChmdW5jdGlvbihlKXtyZXR1cm4gaS5lbnN1cmVDYXRhbG9nKCJtYXJrSW5mbyIpfSkpO2wub24oIkdldERhdGEiLChmdW5jdGlvbihlKXtyZXR1cm4gaS5yZXF1ZXN0TG9hZGVkU3RyZWFtKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuYnl0ZXN9KSl9KSk7bC5vbigiR2V0QW5ub3RhdGlvbnMiLChmdW5jdGlvbih7cGFnZUluZGV4OmUsaW50ZW50OnR9KXtyZXR1cm4gaS5nZXRQYWdlKGUpLnRoZW4oKGZ1bmN0aW9uKGkpe2NvbnN0IGE9bmV3IFdvcmtlclRhc2soYEdldEFubm90YXRpb25zOiBwYWdlICR7ZX1gKTtzdGFydFdvcmtlclRhc2soYSk7cmV0dXJuIGkuZ2V0QW5ub3RhdGlvbnNEYXRhKGwsYSx0KS50aGVuKChlPT57ZmluaXNoV29ya2VyVGFzayhhKTtyZXR1cm4gZX0pLChlPT57ZmluaXNoV29ya2VyVGFzayhhKTt0aHJvdyBlfSkpfSkpfSkpO2wub24oIkdldEZpZWxkT2JqZWN0cyIsKGZ1bmN0aW9uKGUpe3JldHVybiBpLmVuc3VyZURvYygiZmllbGRPYmplY3RzIil9KSk7bC5vbigiSGFzSlNBY3Rpb25zIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGkuZW5zdXJlRG9jKCJoYXNKU0FjdGlvbnMiKX0pKTtsLm9uKCJHZXRDYWxjdWxhdGlvbk9yZGVySWRzIiwoZnVuY3Rpb24oZSl7cmV0dXJuIGkuZW5zdXJlRG9jKCJjYWxjdWxhdGlvbk9yZGVySWRzIil9KSk7bC5vbigiU2F2ZURvY3VtZW50IiwoYXN5bmMgZnVuY3Rpb24oe2lzUHVyZVhmYTplLG51bVBhZ2VzOnQsYW5ub3RhdGlvblN0b3JhZ2U6YSxmaWxlbmFtZTpzfSl7Y29uc3Qgcj1baS5yZXF1ZXN0TG9hZGVkU3RyZWFtKCksaS5lbnN1cmVDYXRhbG9nKCJhY3JvRm9ybSIpLGkuZW5zdXJlQ2F0YWxvZygiYWNyb0Zvcm1SZWYiKSxpLmVuc3VyZURvYygic3RhcnRYUmVmIiksaS5lbnN1cmVEb2MoInhyZWYiKSxpLmVuc3VyZURvYygibGluZWFyaXphdGlvbiIpLGkuZW5zdXJlQ2F0YWxvZygic3RydWN0VHJlZVJvb3QiKV0sbj1bXSxvPWU/bnVsbDpnZXROZXdBbm5vdGF0aW9uc01hcChhKSxbZyxjLEMsaCxRLEUsdV09YXdhaXQgUHJvbWlzZS5hbGwociksZD1RLnRyYWlsZXIuZ2V0UmF3KCJSb290Iil8fG51bGw7bGV0IGY7aWYobyl7dT9hd2FpdCB1LmNhblVwZGF0ZVN0cnVjdFRyZWUoe3BkZk1hbmFnZXI6aSx4cmVmOlEsbmV3QW5ub3RhdGlvbnNCeVBhZ2U6b30pJiYoZj11KTphd2FpdCBTdHJ1Y3RUcmVlUm9vdC5jYW5DcmVhdGVTdHJ1Y3R1cmVUcmVlKHtjYXRhbG9nUmVmOmQscGRmTWFuYWdlcjppLG5ld0Fubm90YXRpb25zQnlQYWdlOm99KSYmKGY9bnVsbCk7Y29uc3QgZT1Bbm5vdGF0aW9uRmFjdG9yeS5nZW5lcmF0ZUltYWdlcyhhLnZhbHVlcygpLFEsaS5ldmFsdWF0b3JPcHRpb25zLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSx0PXZvaWQgMD09PWY/bjpbXTtmb3IoY29uc3RbYSxzXW9mIG8pdC5wdXNoKGkuZ2V0UGFnZShhKS50aGVuKCh0PT57Y29uc3QgaT1uZXcgV29ya2VyVGFzayhgU2F2ZSAoZWRpdG9yKTogcGFnZSAke2F9YCk7cmV0dXJuIHQuc2F2ZU5ld0Fubm90YXRpb25zKGwsaSxzLGUpLmZpbmFsbHkoKGZ1bmN0aW9uKCl7ZmluaXNoV29ya2VyVGFzayhpKX0pKX0pKSk7bnVsbD09PWY/bi5wdXNoKFByb21pc2UuYWxsKHQpLnRoZW4oKGFzeW5jIGU9Pnthd2FpdCBTdHJ1Y3RUcmVlUm9vdC5jcmVhdGVTdHJ1Y3R1cmVUcmVlKHtuZXdBbm5vdGF0aW9uc0J5UGFnZTpvLHhyZWY6USxjYXRhbG9nUmVmOmQscGRmTWFuYWdlcjppLG5ld1JlZnM6ZX0pO3JldHVybiBlfSkpKTpmJiZuLnB1c2goUHJvbWlzZS5hbGwodCkudGhlbigoYXN5bmMgZT0+e2F3YWl0IGYudXBkYXRlU3RydWN0dXJlVHJlZSh7bmV3QW5ub3RhdGlvbnNCeVBhZ2U6byxwZGZNYW5hZ2VyOmksbmV3UmVmczplfSk7cmV0dXJuIGV9KSkpfWlmKGUpbi5wdXNoKGkuc2VyaWFsaXplWGZhRGF0YShhKSk7ZWxzZSBmb3IobGV0IGU9MDtlPHQ7ZSsrKW4ucHVzaChpLmdldFBhZ2UoZSkudGhlbigoZnVuY3Rpb24odCl7Y29uc3QgaT1uZXcgV29ya2VyVGFzayhgU2F2ZTogcGFnZSAke2V9YCk7cmV0dXJuIHQuc2F2ZShsLGksYSkuZmluYWxseSgoZnVuY3Rpb24oKXtmaW5pc2hXb3JrZXJUYXNrKGkpfSkpfSkpKTtjb25zdCBwPWF3YWl0IFByb21pc2UuYWxsKG4pO2xldCBtPVtdLHk9bnVsbDtpZihlKXt5PXBbMF07aWYoIXkpcmV0dXJuIGcuYnl0ZXN9ZWxzZXttPXAuZmxhdCgyKTtpZigwPT09bS5sZW5ndGgpcmV0dXJuIGcuYnl0ZXN9Y29uc3Qgdz1DJiZjIGluc3RhbmNlb2YgRGljdCYmbS5zb21lKChlPT5lLm5lZWRBcHBlYXJhbmNlcykpLGI9YyBpbnN0YW5jZW9mIERpY3QmJmMuZ2V0KCJYRkEiKXx8bnVsbDtsZXQgRD1udWxsLEY9ITE7aWYoQXJyYXkuaXNBcnJheShiKSl7Zm9yKGxldCBlPTAsdD1iLmxlbmd0aDtlPHQ7ZSs9MilpZigiZGF0YXNldHMiPT09YltlXSl7RD1iW2UrMV07Rj0hMH1udWxsPT09RCYmKEQ9US5nZXROZXdUZW1wb3JhcnlSZWYoKSl9ZWxzZSBiJiZ3YXJuKCJVbnN1cHBvcnRlZCBYRkEgdHlwZS4iKTtsZXQgUz1PYmplY3QuY3JlYXRlKG51bGwpO2lmKFEudHJhaWxlcil7Y29uc3QgZT1PYmplY3QuY3JlYXRlKG51bGwpLHQ9US50cmFpbGVyLmdldCgiSW5mbyIpfHxudWxsO3QgaW5zdGFuY2VvZiBEaWN0JiZ0LmZvckVhY2goKCh0LGkpPT57InN0cmluZyI9PXR5cGVvZiBpJiYoZVt0XT1zdHJpbmdUb1BERlN0cmluZyhpKSl9KSk7Uz17cm9vdFJlZjpkLGVuY3J5cHRSZWY6US50cmFpbGVyLmdldFJhdygiRW5jcnlwdCIpfHxudWxsLG5ld1JlZjpRLmdldE5ld1RlbXBvcmFyeVJlZigpLGluZm9SZWY6US50cmFpbGVyLmdldFJhdygiSW5mbyIpfHxudWxsLGluZm86ZSxmaWxlSWRzOlEudHJhaWxlci5nZXQoIklEIil8fG51bGwsc3RhcnRYUmVmOkU/aDpRLmxhc3RYUmVmU3RyZWFtUG9zPz9oLGZpbGVuYW1lOnN9fXJldHVybiBpbmNyZW1lbnRhbFVwZGF0ZSh7b3JpZ2luYWxEYXRhOmcuYnl0ZXMseHJlZkluZm86UyxuZXdSZWZzOm0seHJlZjpRLGhhc1hmYTohIWIseGZhRGF0YXNldHNSZWY6RCxoYXNYZmFEYXRhc2V0c0VudHJ5OkYsbmVlZEFwcGVhcmFuY2VzOncsYWNyb0Zvcm1SZWY6QyxhY3JvRm9ybTpjLHhmYURhdGE6eSx1c2VYcmVmU3RyZWFtOmlzRGljdChRLnRvcERpY3QsIlhSZWYiKX0pLmZpbmFsbHkoKCgpPT57US5yZXNldE5ld1RlbXBvcmFyeVJlZigpfSkpfSkpO2wub24oIkdldE9wZXJhdG9yTGlzdCIsKGZ1bmN0aW9uKGUsdCl7Y29uc3QgYT1lLnBhZ2VJbmRleDtpLmdldFBhZ2UoYSkudGhlbigoZnVuY3Rpb24oaSl7Y29uc3Qgcz1uZXcgV29ya2VyVGFzayhgR2V0T3BlcmF0b3JMaXN0OiBwYWdlICR7YX1gKTtzdGFydFdvcmtlclRhc2socyk7Y29uc3Qgcj1uPj1wQS5JTkZPUz9EYXRlLm5vdygpOjA7aS5nZXRPcGVyYXRvckxpc3Qoe2hhbmRsZXI6bCxzaW5rOnQsdGFzazpzLGludGVudDplLmludGVudCxjYWNoZUtleTplLmNhY2hlS2V5LGFubm90YXRpb25TdG9yYWdlOmUuYW5ub3RhdGlvblN0b3JhZ2V9KS50aGVuKChmdW5jdGlvbihlKXtmaW5pc2hXb3JrZXJUYXNrKHMpO3ImJmluZm8oYHBhZ2U9JHthKzF9IC0gZ2V0T3BlcmF0b3JMaXN0OiB0aW1lPSR7RGF0ZS5ub3coKS1yfW1zLCBsZW49JHtlLmxlbmd0aH1gKTt0LmNsb3NlKCl9KSwoZnVuY3Rpb24oZSl7ZmluaXNoV29ya2VyVGFzayhzKTtzLnRlcm1pbmF0ZWR8fHQuZXJyb3IoZSl9KSl9KSl9KSk7bC5vbigiR2V0VGV4dENvbnRlbnQiLChmdW5jdGlvbihlLHQpe2NvbnN0e3BhZ2VJbmRleDphLGluY2x1ZGVNYXJrZWRDb250ZW50OnMsZGlzYWJsZU5vcm1hbGl6YXRpb246cn09ZTtpLmdldFBhZ2UoYSkudGhlbigoZnVuY3Rpb24oZSl7Y29uc3QgaT1uZXcgV29ya2VyVGFzaygiR2V0VGV4dENvbnRlbnQ6IHBhZ2UgIithKTtzdGFydFdvcmtlclRhc2soaSk7Y29uc3Qgbz1uPj1wQS5JTkZPUz9EYXRlLm5vdygpOjA7ZS5leHRyYWN0VGV4dENvbnRlbnQoe2hhbmRsZXI6bCx0YXNrOmksc2luazp0LGluY2x1ZGVNYXJrZWRDb250ZW50OnMsZGlzYWJsZU5vcm1hbGl6YXRpb246cn0pLnRoZW4oKGZ1bmN0aW9uKCl7ZmluaXNoV29ya2VyVGFzayhpKTtvJiZpbmZvKGBwYWdlPSR7YSsxfSAtIGdldFRleHRDb250ZW50OiB0aW1lPWArKERhdGUubm93KCktbykrIm1zIik7dC5jbG9zZSgpfSksKGZ1bmN0aW9uKGUpe2ZpbmlzaFdvcmtlclRhc2soaSk7aS50ZXJtaW5hdGVkfHx0LmVycm9yKGUpfSkpfSkpfSkpO2wub24oIkdldFN0cnVjdFRyZWUiLChmdW5jdGlvbihlKXtyZXR1cm4gaS5nZXRQYWdlKGUucGFnZUluZGV4KS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gaS5lbnN1cmUoZSwiZ2V0U3RydWN0VHJlZSIpfSkpfSkpO2wub24oIkZvbnRGYWxsYmFjayIsKGZ1bmN0aW9uKGUpe3JldHVybiBpLmZvbnRGYWxsYmFjayhlLmlkLGwpfSkpO2wub24oIkNsZWFudXAiLChmdW5jdGlvbihlKXtyZXR1cm4gaS5jbGVhbnVwKCEwKX0pKTtsLm9uKCJUZXJtaW5hdGUiLChmdW5jdGlvbihlKXthPSEwO2NvbnN0IHQ9W107aWYoaSl7aS50ZXJtaW5hdGUobmV3IEFib3J0RXhjZXB0aW9uKCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuIikpO2NvbnN0IGU9aS5jbGVhbnVwKCk7dC5wdXNoKGUpO2k9bnVsbH1lbHNlIGNsZWFyR2xvYmFsQ2FjaGVzKCk7cyYmcyhuZXcgQWJvcnRFeGNlcHRpb24oIldvcmtlciB3YXMgdGVybWluYXRlZC4iKSk7Zm9yKGNvbnN0IGUgb2Ygcil7dC5wdXNoKGUuZmluaXNoZWQpO2UudGVybWluYXRlKCl9cmV0dXJuIFByb21pc2UuYWxsKHQpLnRoZW4oKGZ1bmN0aW9uKCl7bC5kZXN0cm95KCk7bD1udWxsfSkpfSkpO2wub24oIlJlYWR5IiwoZnVuY3Rpb24odCl7IWZ1bmN0aW9uIHNldHVwRG9jKGUpe2Z1bmN0aW9uIG9uU3VjY2VzcyhlKXtlbnN1cmVOb3RUZXJtaW5hdGVkKCk7bC5zZW5kKCJHZXREb2MiLHtwZGZJbmZvOmV9KX1mdW5jdGlvbiBvbkZhaWx1cmUoZSl7ZW5zdXJlTm90VGVybWluYXRlZCgpO2lmKGUgaW5zdGFuY2VvZiBQYXNzd29yZEV4Y2VwdGlvbil7Y29uc3QgdD1uZXcgV29ya2VyVGFzayhgUGFzc3dvcmRFeGNlcHRpb246IHJlc3BvbnNlICR7ZS5jb2RlfWApO3N0YXJ0V29ya2VyVGFzayh0KTtsLnNlbmRXaXRoUHJvbWlzZSgiUGFzc3dvcmRSZXF1ZXN0IixlKS50aGVuKChmdW5jdGlvbih7cGFzc3dvcmQ6ZX0pe2ZpbmlzaFdvcmtlclRhc2sodCk7aS51cGRhdGVQYXNzd29yZChlKTtwZGZNYW5hZ2VyUmVhZHkoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtmaW5pc2hXb3JrZXJUYXNrKHQpO2wuc2VuZCgiRG9jRXhjZXB0aW9uIixlKX0pKX1lbHNlIGUgaW5zdGFuY2VvZiBJbnZhbGlkUERGRXhjZXB0aW9ufHxlIGluc3RhbmNlb2YgTWlzc2luZ1BERkV4Y2VwdGlvbnx8ZSBpbnN0YW5jZW9mIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbnx8ZSBpbnN0YW5jZW9mIFVua25vd25FcnJvckV4Y2VwdGlvbj9sLnNlbmQoIkRvY0V4Y2VwdGlvbiIsZSk6bC5zZW5kKCJEb2NFeGNlcHRpb24iLG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZS5tZXNzYWdlLGUudG9TdHJpbmcoKSkpfWZ1bmN0aW9uIHBkZk1hbmFnZXJSZWFkeSgpe2Vuc3VyZU5vdFRlcm1pbmF0ZWQoKTtsb2FkRG9jdW1lbnQoITEpLnRoZW4ob25TdWNjZXNzLChmdW5jdGlvbihlKXtlbnN1cmVOb3RUZXJtaW5hdGVkKCk7ZSBpbnN0YW5jZW9mIFhSZWZQYXJzZUV4Y2VwdGlvbj9pLnJlcXVlc3RMb2FkZWRTdHJlYW0oKS50aGVuKChmdW5jdGlvbigpe2Vuc3VyZU5vdFRlcm1pbmF0ZWQoKTtsb2FkRG9jdW1lbnQoITApLnRoZW4ob25TdWNjZXNzLG9uRmFpbHVyZSl9KSk6b25GYWlsdXJlKGUpfSkpfWVuc3VyZU5vdFRlcm1pbmF0ZWQoKTtnZXRQZGZNYW5hZ2VyKGUpLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKGEpe2UudGVybWluYXRlKG5ldyBBYm9ydEV4Y2VwdGlvbigiV29ya2VyIHdhcyB0ZXJtaW5hdGVkLiIpKTt0aHJvdyBuZXcgRXJyb3IoIldvcmtlciB3YXMgdGVybWluYXRlZCIpfWk9ZTtpLnJlcXVlc3RMb2FkZWRTdHJlYW0oITApLnRoZW4oKGU9PntsLnNlbmQoIkRhdGFMb2FkZWQiLHtsZW5ndGg6ZS5ieXRlcy5ieXRlTGVuZ3RofSl9KSl9KSkudGhlbihwZGZNYW5hZ2VyUmVhZHksb25GYWlsdXJlKX0oZSk7ZT1udWxsfSkpO3JldHVybiBofXN0YXRpYyBpbml0aWFsaXplRnJvbVBvcnQoZSl7Y29uc3QgdD1uZXcgTWVzc2FnZUhhbmRsZXIoIndvcmtlciIsIm1haW4iLGUpO1dvcmtlck1lc3NhZ2VIYW5kbGVyLnNldHVwKHQsZSk7dC5zZW5kKCJyZWFkeSIsbnVsbCl9fSJ1bmRlZmluZWQiPT10eXBlb2Ygd2luZG93JiYhdCYmInVuZGVmaW5lZCIhPXR5cGVvZiBzZWxmJiZmdW5jdGlvbiBpc01lc3NhZ2VQb3J0KGUpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBlLnBvc3RNZXNzYWdlJiYib25tZXNzYWdlImluIGV9KHNlbGYpJiZXb3JrZXJNZXNzYWdlSGFuZGxlci5pbml0aWFsaXplRnJvbVBvcnQoc2VsZik7dmFyIGZvPV9fd2VicGFja19leHBvcnRzX18uV29ya2VyTWVzc2FnZUhhbmRsZXI7ZXhwb3J0e2ZvIGFzIFdvcmtlck1lc3NhZ2VIYW5kbGVyfTs=", import.meta.url).href;
    XM.workerSrc = t;
    const n = Ml(!1), e = Ml(/* @__PURE__ */ new Map()), d = Ml(1), a = Ml(0), U = Ml(!1), V = Ml(0), h = Ml(""), W = Ml(0), Z = Ml(1), s = Ml("");
    let o = "";
    nt("containerScale", Z), nt("index", d), nt("pdfExamplePages", a), nt("searchValue", s), nt("pdfContainer", o), nt("navigationRef", U);
    const F = (c = "/src/assets/text.pdf") => {
      YM(c).promise.then(async (R) => {
        o = R, await Q(R);
        const { numPages: m } = R;
        a.value = m;
      });
    }, N = (c) => {
      n.value = c;
    }, Q = async (c) => {
      const R = await c.getPage(1), m = R.view[3], M = R.view[2];
      V.value = m, W.value = M;
    }, u = (c) => {
      h.value = c, n.value = !0;
    }, i = (c, R) => {
      e.value.set(c, R);
    };
    return F(), Bl(
      () => e.value,
      () => {
        let c = 1e3;
        e.value.forEach((R, m) => {
          R && +m < c && (c = +m);
        }), d.value = c;
      },
      {
        deep: !0
      }
    ), (c, R) => (Vt(), mt("div", lp, [
      H(at(Rn), {
        class: "image",
        width: "0",
        height: "0",
        style: { display: "none", overflow: "hidden" },
        preview: {
          maskClassName: "custom-class",
          visible: n.value,
          onVisibleChange: N
        },
        src: h.value
      }, null, 8, ["preview", "src"]),
      H(RM),
      St("div", tp, [
        U.value && a.value ? (Vt(), as(GM, {
          key: 0,
          navigationRef: U.value,
          canvasWidth: W.value,
          imageRenderHeight: V.value,
          pdfJsViewer: GU,
          pdfContainer: at(o)
        }, null, 8, ["navigationRef", "canvasWidth", "imageRenderHeight", "pdfContainer"])) : _e("", !0),
        a.value ? (Vt(), mt("div", np, [
          (Vt(!0), mt(st, null, yU(a.value, (m) => (Vt(), as(ZF, {
            onHandleIntersection: i,
            style: { margin: "10px 0px" },
            onHandleSetImageUrl: u,
            pdfOptions: {
              containerScale: Z.value,
              scale: 1.5
            },
            pdfJsViewer: GU,
            pageNum: m,
            canvasWidth: W.value,
            searchValue: s.value,
            imageRenderHeight: V.value,
            pdfContainer: at(o)
          }, null, 8, ["pdfOptions", "pageNum", "canvasWidth", "searchValue", "imageRenderHeight", "pdfContainer"]))), 256))
        ])) : _e("", !0)
      ])
    ]));
  }
}), de = /* @__PURE__ */ Un(dp, [["__scopeId", "data-v-56bc850a"]]);
de.install = (l) => (console.log(de, de.name, "Pdf"), l.component(de.name, de), l);
export {
  de as default
};
